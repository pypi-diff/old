--- tmp/pymc-marketing-0.0.4.tar.gz
+++ tmp/pymc-marketing-0.1.0.tar.gz
â”œâ”€â”€ filetype from file(1)
â”‚ @@ -1 +1 @@
â”‚ -gzip compressed data, was "pymc-marketing-0.0.4.tar", last modified: Tue Feb 28 12:12:12 2023, max compression
â”‚ +gzip compressed data, was "pymc-marketing-0.1.0.tar", last modified: Thu Apr  6 12:34:13 2023, max compression
â”‚   --- pymc-marketing-0.0.4.tar
â”œâ”€â”€ +++ pymc-marketing-0.1.0.tar
â”‚ â”œâ”€â”€ file list
â”‚ â”‚ @@ -1,35 +1,35 @@
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.132322 pymc-marketing-0.0.4/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    11357 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/LICENSE
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    19070 2023-02-28 12:12:12.132322 pymc-marketing-0.0.4/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5725 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/README.md
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.128322 pymc-marketing-0.0.4/pymc_marketing/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       83 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/__init__.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.128322 pymc-marketing-0.0.4/pymc_marketing/clv/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      555 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    14430 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/distributions.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.128322 pymc-marketing-0.0.4/pymc_marketing/clv/models/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      448 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/models/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3752 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/models/basic.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    12574 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/models/beta_geo.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    16215 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/models/gamma_gamma.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     7266 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/models/shifted_beta_geo.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4500 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/plotting.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    12842 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/clv/utils.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.132322 pymc-marketing-0.0.4/pymc_marketing/mmm/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      334 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    14726 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5044 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/delayed_saturated_mmm.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2081 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/preprocessing.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4738 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/transformers.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      948 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/utils.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2750 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/mmm/validating.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      266 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/version.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)        6 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pymc_marketing/version.txt
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-02-28 12:12:12.128322 pymc-marketing-0.0.4/pymc_marketing.egg-info/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    19070 2023-02-28 12:12:12.000000 pymc-marketing-0.0.4/pymc_marketing.egg-info/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      859 2023-02-28 12:12:12.000000 pymc-marketing-0.0.4/pymc_marketing.egg-info/SOURCES.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)        1 2023-02-28 12:12:12.000000 pymc-marketing-0.0.4/pymc_marketing.egg-info/dependency_links.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      414 2023-02-28 12:12:12.000000 pymc-marketing-0.0.4/pymc_marketing.egg-info/requires.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       15 2023-02-28 12:12:12.000000 pymc-marketing-0.0.4/pymc_marketing.egg-info/top_level.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1588 2023-02-28 12:12:02.000000 pymc-marketing-0.0.4/pyproject.toml
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       38 2023-02-28 12:12:12.132322 pymc-marketing-0.0.4/setup.cfg
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    11357 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/LICENSE
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    20911 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7566 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/README.md
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/pymc_marketing/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       83 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/__init__.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/pymc_marketing/clv/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      555 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    14430 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/distributions.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/pymc_marketing/clv/models/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      448 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/models/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3728 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/models/basic.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    12544 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/models/beta_geo.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    16215 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/models/gamma_gamma.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7266 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/models/shifted_beta_geo.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4500 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/plotting.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    12842 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/clv/utils.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/pymc_marketing/mmm/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      334 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    14741 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4286 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/delayed_saturated_mmm.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2031 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/preprocessing.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6050 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/transformers.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      948 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/utils.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2708 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/mmm/validating.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      266 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/version.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)        6 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pymc_marketing/version.txt
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/pymc_marketing.egg-info/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    20911 2023-04-06 12:34:13.000000 pymc-marketing-0.1.0/pymc_marketing.egg-info/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      859 2023-04-06 12:34:13.000000 pymc-marketing-0.1.0/pymc_marketing.egg-info/SOURCES.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-06 12:34:13.000000 pymc-marketing-0.1.0/pymc_marketing.egg-info/dependency_links.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      421 2023-04-06 12:34:13.000000 pymc-marketing-0.1.0/pymc_marketing.egg-info/requires.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       15 2023-04-06 12:34:13.000000 pymc-marketing-0.1.0/pymc_marketing.egg-info/top_level.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1602 2023-04-06 12:34:03.000000 pymc-marketing-0.1.0/pyproject.toml
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-06 12:34:13.707226 pymc-marketing-0.1.0/setup.cfg
â”‚ â”‚   --- pymc-marketing-0.0.4/LICENSE
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/LICENSE
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/PKG-INFO
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/PKG-INFO
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: pymc-marketing
â”‚ â”‚ -Version: 0.0.4
â”‚ â”‚ +Version: 0.1.0
â”‚ â”‚  Summary: Marketing Statistical Models in PyMC
â”‚ â”‚  Maintainer-email: PyMC Labs <info@pymc-labs.io>
â”‚ â”‚  License:                                  Apache License
â”‚ â”‚                                     Version 2.0, January 2004
â”‚ â”‚                                  http://www.apache.org/licenses/
â”‚ â”‚          
â”‚ â”‚             TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
â”‚ â”‚ @@ -211,24 +211,51 @@
â”‚ â”‚  Provides-Extra: docs
â”‚ â”‚  Provides-Extra: lint
â”‚ â”‚  Provides-Extra: test
â”‚ â”‚  License-File: LICENSE
â”‚ â”‚  
â”‚ â”‚  # PyMC-Marketing
â”‚ â”‚  
â”‚ â”‚ -![Build](https://github.com/pymc-labs/pymmmc/workflows/ci/badge.svg)
â”‚ â”‚ +![Build](https://github.com/pymc-labs/pymc-marketing/workflows/ci/badge.svg)
â”‚ â”‚  [![codecov](https://codecov.io/gh/pymc-labs/pymc-marketing/branch/main/graph/badge.svg?token=OBV3BS5TYE)](https://codecov.io/gh/pymc-labs/pymc-marketing)
â”‚ â”‚  [![docs](https://readthedocs.org/projects/pymc-marketing/badge/?version=latest)](https://docs.readthedocs.io/en/latest/)
â”‚ â”‚  [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
â”‚ â”‚  [![PyPI Version](https://img.shields.io/pypi/v/pymc-marketing.svg)](https://pypi.python.org/pypi/pymc-marketing)
â”‚ â”‚  [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
â”‚ â”‚  
â”‚ â”‚ +**Unlock the power of marketing analytics with PyMC-Marketing â€“ the open source solution for smarter decision-making.** Media mix modeling and customer lifetime value modules allow businesses to make data-driven decisions about their marketing campaigns. Optimize your marketing strategy and unlock the full potential of your customer data.
â”‚ â”‚ +
â”‚ â”‚ +---
â”‚ â”‚ +
â”‚ â”‚ +## Installation
â”‚ â”‚ +
â”‚ â”‚ +Start by setting up an environment (e.g. `marketing_env`) with PyMC. It may look something like the following:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +mamba create -c conda-forge -n marketing_env python "pymc>=5"
â”‚ â”‚ +mamba activate marketing_env
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +See the official [PyMC installation guide](https://www.pymc.io/projects/docs/en/latest/installation.html) if more detail is needed.
â”‚ â”‚ +
â”‚ â”‚ +Assuming you have an environment set up then install PyMC-Marketing with the following command. This will give you the latest version of the library from PyPI.
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install pymc-marketing
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +Alternatively you can install from GitHub directly:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install git+https://github.com/pymc-labs/pymc-marketing.git
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚  ## Bayesian Media Mix Models (MMMs) in PyMC
â”‚ â”‚  
â”‚ â”‚ -In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/). Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variiables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚ +In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/) Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚  
â”‚ â”‚  $$
â”‚ â”‚  y_{t} = \alpha + \sum_{m=1}^{M}\beta_{m}f(x_{m, t}) +  \sum_{c=1}^{C}\gamma_{c}z_{c, t} + \varepsilon_{t},
â”‚ â”‚  $$
â”‚ â”‚  
â”‚ â”‚  where $\alpha$ is the intercept, $f$ is a media transformation function and $\varepsilon_{t}$ is the error therm which we assume is normally distributed. The function $f$ encodes the contribution of media on the target variable. Typically we consider two types of transformation: adstock (carry-over) and saturation effects.
â”‚ â”‚  
â”‚ â”‚ @@ -246,70 +273,42 @@
â”‚ â”‚    - [Improving the Speed and Accuracy of Bayesian Media Mix Models](https://www.pymc-labs.io/blog-posts/reducing-customer-acquisition-costs-how-we-helped-optimizing-hellofreshs-marketing-budget/)
â”‚ â”‚  - [Johns, Michael and Wang,  Zhenyu. "A Bayesian Approach to Media Mix Modeling"](https://www.youtube.com/watch?v=UznM_-_760Y)
â”‚ â”‚  - [Orduz, Juan. "Media Effect Estimation with PyMC: Adstock, Saturation & Diminishing Returns"](https://juanitorduz.github.io/pymc_mmm/)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚  ## Bayesian CLVs in PyMC
â”‚ â”‚ -[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) models is another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚ +[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) (CLV) models are another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚  
â”‚ â”‚  ### Examples
â”‚ â”‚  
â”‚ â”‚  |                | **Non-contractual** | **Contractual**                 |
â”‚ â”‚  |----------------|---------------------|---------------------------------|
â”‚ â”‚  | **Continuous** | Buying groceries    | Audible                         |
â”‚ â”‚  | **Discrete**   | Cinema ticket       | Monthly or yearly subscriptions |
â”‚ â”‚  
â”‚ â”‚  To explain further:
â”‚ â”‚ -- **Contractual:** In contractual settings a customer has a contract which continues to be active until it is explicitly cancelled. Therefore in contractual settings, customer churn events are observed.
â”‚ â”‚ +- **Contractual:** In contractual settings, a customer has a contract which continues to be active until it is explicitly cancelled. Therefore, customer churn events are observed.
â”‚ â”‚  
â”‚ â”‚  - **Non-contractual:** In non-contractual settings, there is no ongoing contract that a customer has with a company. Instead, purchases can be ad hoc and churn events are unobserved.
â”‚ â”‚  
â”‚ â”‚  - **Discrete:** Here, purchases are made at discrete points in time. This obviously depends upon the timescale that we are working on, but typically a relevant time period would be a month or year. However it could be more granualar than this - think of taking the 2nd of 4 inter-city train journeys offered per day.
â”‚ â”‚  
â”‚ â”‚ -- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚ +- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering, this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚  
â”‚ â”‚ -In the documentation we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚ +In the documentation, we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚  
â”‚ â”‚  - [CLV Quickstart](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/clv_quickstart.html)
â”‚ â”‚  - [BG/NBD model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/bg_nbd.html)
â”‚ â”‚  - [Gamma-Gamma model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/gamma_gamma.html)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚ -## Local Development
â”‚ â”‚ +## ðŸ“ž Schedule a Consultation
â”‚ â”‚ +Unlock your potential with a free 30-minute strategy session with our PyMC experts. Discover how open source solutions and pymc-marketing can elevate your media-mix models and customer lifetime value analyses. Boost your career and organization by making smarter, data-driven decisions. Don't waitâ€”[claim your complimentary session](https://calendly.com/benjamin-vincent/pymc-marketing) today and lead the way in marketing and data science innovation.
â”‚ â”‚  
â”‚ â”‚ -1. Create conda environment. For example:
â”‚ â”‚ +## Using PyMC-Marketing and how PyMC Labs can help you
â”‚ â”‚ +PyMC-Marketing uses the [Apache 2.0 licence](LICENSE) which permits commercial use, amongst other things.
â”‚ â”‚  
â”‚ â”‚ -```shell
â”‚ â”‚ -conda create -n pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ +If you want to build upon the package, please feel free to fork the repo and submit a pull request. If in doubt, please open an issue.
â”‚ â”‚  
â”‚ â”‚ -2. Activate environment.
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -conda activate pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -3. Install `pymc_marketing` package:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make init
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -4. To run tests:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make test
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -5. To check code style:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make check_lint
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -6. Set [pre-commit hooks](https://pre-commit.com/) (Optional):
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -pre-commit install
â”‚ â”‚ -```
â”‚ â”‚ +For companies that want to use PyMC-Marketing in production, [PyMC Labs](https://www.pymc-labs.io) is available for consulting and training. We can help you build and deploy your models in production. We have experience with cutting edge Bayesian modelling techniques in general, and in particular with MMMs and CLVs. For example, see our video on [Bayesian Marketing Mix Models: State of the Art and their Future](https://www.youtube.com/watch?v=xVx91prC81g).
â”‚ â”‚   --- pymc-marketing-0.0.4/README.md
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/README.md
â”‚ â”‚â”„ Files 20% similar despite different names
â”‚ â”‚ @@ -1,19 +1,46 @@
â”‚ â”‚  # PyMC-Marketing
â”‚ â”‚  
â”‚ â”‚ -![Build](https://github.com/pymc-labs/pymmmc/workflows/ci/badge.svg)
â”‚ â”‚ +![Build](https://github.com/pymc-labs/pymc-marketing/workflows/ci/badge.svg)
â”‚ â”‚  [![codecov](https://codecov.io/gh/pymc-labs/pymc-marketing/branch/main/graph/badge.svg?token=OBV3BS5TYE)](https://codecov.io/gh/pymc-labs/pymc-marketing)
â”‚ â”‚  [![docs](https://readthedocs.org/projects/pymc-marketing/badge/?version=latest)](https://docs.readthedocs.io/en/latest/)
â”‚ â”‚  [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
â”‚ â”‚  [![PyPI Version](https://img.shields.io/pypi/v/pymc-marketing.svg)](https://pypi.python.org/pypi/pymc-marketing)
â”‚ â”‚  [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
â”‚ â”‚  
â”‚ â”‚ +**Unlock the power of marketing analytics with PyMC-Marketing â€“ the open source solution for smarter decision-making.** Media mix modeling and customer lifetime value modules allow businesses to make data-driven decisions about their marketing campaigns. Optimize your marketing strategy and unlock the full potential of your customer data.
â”‚ â”‚ +
â”‚ â”‚ +---
â”‚ â”‚ +
â”‚ â”‚ +## Installation
â”‚ â”‚ +
â”‚ â”‚ +Start by setting up an environment (e.g. `marketing_env`) with PyMC. It may look something like the following:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +mamba create -c conda-forge -n marketing_env python "pymc>=5"
â”‚ â”‚ +mamba activate marketing_env
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +See the official [PyMC installation guide](https://www.pymc.io/projects/docs/en/latest/installation.html) if more detail is needed.
â”‚ â”‚ +
â”‚ â”‚ +Assuming you have an environment set up then install PyMC-Marketing with the following command. This will give you the latest version of the library from PyPI.
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install pymc-marketing
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +Alternatively you can install from GitHub directly:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install git+https://github.com/pymc-labs/pymc-marketing.git
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚  ## Bayesian Media Mix Models (MMMs) in PyMC
â”‚ â”‚  
â”‚ â”‚ -In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/). Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variiables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚ +In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/) Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚  
â”‚ â”‚  $$
â”‚ â”‚  y_{t} = \alpha + \sum_{m=1}^{M}\beta_{m}f(x_{m, t}) +  \sum_{c=1}^{C}\gamma_{c}z_{c, t} + \varepsilon_{t},
â”‚ â”‚  $$
â”‚ â”‚  
â”‚ â”‚  where $\alpha$ is the intercept, $f$ is a media transformation function and $\varepsilon_{t}$ is the error therm which we assume is normally distributed. The function $f$ encodes the contribution of media on the target variable. Typically we consider two types of transformation: adstock (carry-over) and saturation effects.
â”‚ â”‚  
â”‚ â”‚ @@ -31,70 +58,42 @@
â”‚ â”‚    - [Improving the Speed and Accuracy of Bayesian Media Mix Models](https://www.pymc-labs.io/blog-posts/reducing-customer-acquisition-costs-how-we-helped-optimizing-hellofreshs-marketing-budget/)
â”‚ â”‚  - [Johns, Michael and Wang,  Zhenyu. "A Bayesian Approach to Media Mix Modeling"](https://www.youtube.com/watch?v=UznM_-_760Y)
â”‚ â”‚  - [Orduz, Juan. "Media Effect Estimation with PyMC: Adstock, Saturation & Diminishing Returns"](https://juanitorduz.github.io/pymc_mmm/)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚  ## Bayesian CLVs in PyMC
â”‚ â”‚ -[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) models is another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚ +[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) (CLV) models are another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚  
â”‚ â”‚  ### Examples
â”‚ â”‚  
â”‚ â”‚  |                | **Non-contractual** | **Contractual**                 |
â”‚ â”‚  |----------------|---------------------|---------------------------------|
â”‚ â”‚  | **Continuous** | Buying groceries    | Audible                         |
â”‚ â”‚  | **Discrete**   | Cinema ticket       | Monthly or yearly subscriptions |
â”‚ â”‚  
â”‚ â”‚  To explain further:
â”‚ â”‚ -- **Contractual:** In contractual settings a customer has a contract which continues to be active until it is explicitly cancelled. Therefore in contractual settings, customer churn events are observed.
â”‚ â”‚ +- **Contractual:** In contractual settings, a customer has a contract which continues to be active until it is explicitly cancelled. Therefore, customer churn events are observed.
â”‚ â”‚  
â”‚ â”‚  - **Non-contractual:** In non-contractual settings, there is no ongoing contract that a customer has with a company. Instead, purchases can be ad hoc and churn events are unobserved.
â”‚ â”‚  
â”‚ â”‚  - **Discrete:** Here, purchases are made at discrete points in time. This obviously depends upon the timescale that we are working on, but typically a relevant time period would be a month or year. However it could be more granualar than this - think of taking the 2nd of 4 inter-city train journeys offered per day.
â”‚ â”‚  
â”‚ â”‚ -- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚ +- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering, this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚  
â”‚ â”‚ -In the documentation we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚ +In the documentation, we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚  
â”‚ â”‚  - [CLV Quickstart](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/clv_quickstart.html)
â”‚ â”‚  - [BG/NBD model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/bg_nbd.html)
â”‚ â”‚  - [Gamma-Gamma model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/gamma_gamma.html)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚ -## Local Development
â”‚ â”‚ +## ðŸ“ž Schedule a Consultation
â”‚ â”‚ +Unlock your potential with a free 30-minute strategy session with our PyMC experts. Discover how open source solutions and pymc-marketing can elevate your media-mix models and customer lifetime value analyses. Boost your career and organization by making smarter, data-driven decisions. Don't waitâ€”[claim your complimentary session](https://calendly.com/benjamin-vincent/pymc-marketing) today and lead the way in marketing and data science innovation.
â”‚ â”‚  
â”‚ â”‚ -1. Create conda environment. For example:
â”‚ â”‚ +## Using PyMC-Marketing and how PyMC Labs can help you
â”‚ â”‚ +PyMC-Marketing uses the [Apache 2.0 licence](LICENSE) which permits commercial use, amongst other things.
â”‚ â”‚  
â”‚ â”‚ -```shell
â”‚ â”‚ -conda create -n pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ +If you want to build upon the package, please feel free to fork the repo and submit a pull request. If in doubt, please open an issue.
â”‚ â”‚  
â”‚ â”‚ -2. Activate environment.
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -conda activate pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -3. Install `pymc_marketing` package:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make init
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -4. To run tests:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make test
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -5. To check code style:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make check_lint
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -6. Set [pre-commit hooks](https://pre-commit.com/) (Optional):
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -pre-commit install
â”‚ â”‚ -```
â”‚ â”‚ +For companies that want to use PyMC-Marketing in production, [PyMC Labs](https://www.pymc-labs.io) is available for consulting and training. We can help you build and deploy your models in production. We have experience with cutting edge Bayesian modelling techniques in general, and in particular with MMMs and CLVs. For example, see our video on [Bayesian Marketing Mix Models: State of the Art and their Future](https://www.youtube.com/watch?v=xVx91prC81g).
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/__init__.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/__init__.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/distributions.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/distributions.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/models/basic.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/models/basic.py
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -33,33 +33,33 @@
â”‚ â”‚              raise ValueError("Prior variables must be unique")
â”‚ â”‚  
â”‚ â”‚          # Related to https://github.com/pymc-devs/pymc/issues/6311
â”‚ â”‚          for prior in priors:
â”‚ â”‚              prior.str_repr = types.MethodType(str_for_dist, prior)
â”‚ â”‚          return priors
â”‚ â”‚  
â”‚ â”‚ -    def fit(self, fitting_method="mcmc", **kwargs):
â”‚ â”‚ +    def fit(self, fit_method="mcmc", **kwargs):
â”‚ â”‚          """Infer model posterior
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚ -        fitting_method: str
â”‚ â”‚ +        fit_method: str
â”‚ â”‚              Method used to fit the model. Options are:
â”‚ â”‚              - "mcmc": Samples from the posterior via `pymc.sample` (default)
â”‚ â”‚              - "map": Finds maximum a posteriori via `pymc.find_MAP`
â”‚ â”‚          kwargs:
â”‚ â”‚              Other keyword arguments passed to the underlying PyMC routines
â”‚ â”‚          """
â”‚ â”‚ -        if fitting_method == "mcmc":
â”‚ â”‚ +        if fit_method == "mcmc":
â”‚ â”‚              res = self._fit_mcmc(**kwargs)
â”‚ â”‚ -        elif fitting_method == "map":
â”‚ â”‚ +        elif fit_method == "map":
â”‚ â”‚              res = self._fit_MAP(**kwargs)
â”‚ â”‚          else:
â”‚ â”‚              raise ValueError(
â”‚ â”‚ -                f"Fitting method options are ['mcmc', 'map'], got: {fitting_method}"
â”‚ â”‚ +                f"Fit method options are ['mcmc', 'map'], got: {fit_method}"
â”‚ â”‚              )
â”‚ â”‚          self.fit_result = res
â”‚ â”‚          return res
â”‚ â”‚  
â”‚ â”‚      def _fit_mcmc(self, **kwargs):
â”‚ â”‚          """Draw samples from model posterior using MCMC sampling"""
â”‚ â”‚          with self.model:
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/models/beta_geo.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/models/beta_geo.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -1,15 +1,15 @@
â”‚ â”‚  from typing import Optional, Union
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚  import pandas as pd
â”‚ â”‚  import pymc as pm
â”‚ â”‚  import pytensor.tensor as pt
â”‚ â”‚  import xarray as xr
â”‚ â”‚ -from pymc.distributions.dist_math import betaln, check_parameters
â”‚ â”‚ +from pymc.distributions.dist_math import check_parameters
â”‚ â”‚  from pytensor.tensor import TensorVariable
â”‚ â”‚  from scipy.special import expit, hyp2f1
â”‚ â”‚  
â”‚ â”‚  from pymc_marketing.clv.models.basic import CLVModel
â”‚ â”‚  from pymc_marketing.clv.utils import to_xarray
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ @@ -141,32 +141,31 @@
â”‚ â”‚              r = self.model.register_rv(r_prior, name="r")
â”‚ â”‚  
â”‚ â”‚              def logp(t_x, x, a, b, r, alpha, T):
â”‚ â”‚                  """
â”‚ â”‚                  The log-likelihood expression here aligns with expression (4) from [3]
â”‚ â”‚                  due to the possible numerical instability of expression (3).
â”‚ â”‚                  """
â”‚ â”‚ -                zero_observations = pt.eq(x, 0)
â”‚ â”‚ +                x_non_zero = x > 0
â”‚ â”‚  
â”‚ â”‚ -                A = betaln(a, b + x) - betaln(a, b) + pt.gammaln(r + x) - pt.gammaln(r)
â”‚ â”‚ -                A += r * pt.log(alpha) - (r + x) * pt.log(alpha + T)
â”‚ â”‚ -
â”‚ â”‚ -                B = (
â”‚ â”‚ -                    betaln(a + 1, b + x - 1)
â”‚ â”‚ -                    - betaln(a, b)
â”‚ â”‚ -                    + pt.gammaln(r + x)
â”‚ â”‚ +                # Refactored for numerical error
â”‚ â”‚ +                d1 = (
â”‚ â”‚ +                    pt.gammaln(r + x)
â”‚ â”‚                      - pt.gammaln(r)
â”‚ â”‚ +                    + pt.gammaln(a + b)
â”‚ â”‚ +                    + pt.gammaln(b + x)
â”‚ â”‚ +                    - pt.gammaln(b)
â”‚ â”‚ +                    - pt.gammaln(a + b + x)
â”‚ â”‚                  )
â”‚ â”‚ -                B += r * pt.log(alpha) - (r + x) * pt.log(alpha + t_x)
â”‚ â”‚  
â”‚ â”‚ -                logp = pt.switch(
â”‚ â”‚ -                    zero_observations,
â”‚ â”‚ -                    A,
â”‚ â”‚ -                    pt.logaddexp(A, B),
â”‚ â”‚ -                )
â”‚ â”‚ +                d2 = r * pt.log(alpha) - (r + x) * pt.log(alpha + t_x)
â”‚ â”‚ +                c3 = ((alpha + t_x) / (alpha + T)) ** (r + x)
â”‚ â”‚ +                c4 = a / (b + x - 1)
â”‚ â”‚ +
â”‚ â”‚ +                logp = d1 + d2 + pt.log(c3 + pt.switch(x_non_zero, c4, 0))
â”‚ â”‚  
â”‚ â”‚                  return check_parameters(
â”‚ â”‚                      logp,
â”‚ â”‚                      a > 0,
â”‚ â”‚                      b > 0,
â”‚ â”‚                      alpha > 0,
â”‚ â”‚                      r > 0,
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/models/gamma_gamma.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/models/gamma_gamma.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/models/shifted_beta_geo.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/models/shifted_beta_geo.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/plotting.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/plotting.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/clv/utils.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/clv/utils.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/mmm/base.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/mmm/base.py
â”‚ â”‚â”„ Files 19% similar despite different names
â”‚ â”‚ @@ -28,36 +28,36 @@
â”‚ â”‚  
â”‚ â”‚  __all__ = ("BaseMMM", "MMM")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class BaseMMM:
â”‚ â”‚      def __init__(
â”‚ â”‚          self,
â”‚ â”‚ -        data_df: pd.DataFrame,
â”‚ â”‚ +        data: pd.DataFrame,
â”‚ â”‚          target_column: str,
â”‚ â”‚          date_column: str,
â”‚ â”‚          channel_columns: Union[List[str], Tuple[str]],
â”‚ â”‚          validate_data: bool = True,
â”‚ â”‚          **kwargs,
â”‚ â”‚      ) -> None:
â”‚ â”‚ -        self.data_df: pd.DataFrame = data_df
â”‚ â”‚ +        self.data: pd.DataFrame = data
â”‚ â”‚          self.target_column: str = target_column
â”‚ â”‚          self.date_column: str = date_column
â”‚ â”‚          self.channel_columns: Union[List[str], Tuple[str]] = channel_columns
â”‚ â”‚ -        self.n_obs: int = data_df.shape[0]
â”‚ â”‚ +        self.n_obs: int = data.shape[0]
â”‚ â”‚          self.n_channel: int = len(channel_columns)
â”‚ â”‚          self._fit_result: Optional[az.InferenceData] = None
â”‚ â”‚          self._posterior_predictive: Optional[az.InferenceData] = None
â”‚ â”‚  
â”‚ â”‚          if validate_data:
â”‚ â”‚ -            self.validate(self.data_df)
â”‚ â”‚ -        self.preprocessed_data = self.preprocess(self.data_df.copy())
â”‚ â”‚ +            self.validate(self.data)
â”‚ â”‚ +        self.preprocessed_data = self.preprocess(self.data.copy())
â”‚ â”‚  
â”‚ â”‚          self.build_model(
â”‚ â”‚ -            data_df=self.preprocessed_data,
â”‚ â”‚ +            data=self.preprocessed_data,
â”‚ â”‚              **kwargs,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      @property
â”‚ â”‚      def methods(self) -> List[Any]:
â”‚ â”‚          maybe_methods = [getattr_static(self, attr) for attr in dir(self)]
â”‚ â”‚          return [
â”‚ â”‚ @@ -91,22 +91,22 @@
â”‚ â”‚      def get_target_transformer(self) -> Pipeline:
â”‚ â”‚          try:
â”‚ â”‚              return self.target_transformer
â”‚ â”‚          except AttributeError:
â”‚ â”‚              identity_transformer = FunctionTransformer()
â”‚ â”‚              return Pipeline(steps=[("scaler", identity_transformer)])
â”‚ â”‚  
â”‚ â”‚ -    def validate(self, data_df: pd.DataFrame):
â”‚ â”‚ +    def validate(self, data: pd.DataFrame):
â”‚ â”‚          for method in self.validation_methods:
â”‚ â”‚ -            method(self, data_df)
â”‚ â”‚ +            method(self, data)
â”‚ â”‚  
â”‚ â”‚ -    def preprocess(self, data_df: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ +    def preprocess(self, data: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚          for method in self.preprocessing_methods:
â”‚ â”‚ -            data_df = method(self, data_df)
â”‚ â”‚ -        return data_df
â”‚ â”‚ +            data = method(self, data)
â”‚ â”‚ +        return data
â”‚ â”‚  
â”‚ â”‚      @abstractmethod
â”‚ â”‚      def build_model(*args, **kwargs):
â”‚ â”‚          raise NotImplementedError()
â”‚ â”‚  
â”‚ â”‚      def get_prior_predictive_data(self, *args, **kwargs) -> az.InferenceData:
â”‚ â”‚          try:
â”‚ â”‚ @@ -158,33 +158,33 @@
â”‚ â”‚          likelihood_hdi_50: DataArray = az.hdi(
â”‚ â”‚              ary=prior_predictive_data["prior_predictive"], hdi_prob=0.50
â”‚ â”‚          )["likelihood"]
â”‚ â”‚  
â”‚ â”‚          fig, ax = plt.subplots(**plt_kwargs)
â”‚ â”‚  
â”‚ â”‚          ax.fill_between(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y1=likelihood_hdi_94[:, 0],
â”‚ â”‚              y2=likelihood_hdi_94[:, 1],
â”‚ â”‚              color="C0",
â”‚ â”‚              alpha=0.2,
â”‚ â”‚              label="94% HDI",
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          ax.fill_between(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y1=likelihood_hdi_50[:, 0],
â”‚ â”‚              y2=likelihood_hdi_50[:, 1],
â”‚ â”‚              color="C0",
â”‚ â”‚              alpha=0.3,
â”‚ â”‚              label="50% HDI",
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          ax.plot(
â”‚ â”‚ -            self.data_df[self.date_column],
â”‚ â”‚ +            self.data[self.date_column],
â”‚ â”‚              self.preprocessed_data[self.target_column],
â”‚ â”‚              color="black",
â”‚ â”‚          )
â”‚ â”‚          ax.set(title="Prior Predictive Check", xlabel="date", ylabel=self.target_column)
â”‚ â”‚          return fig
â”‚ â”‚  
â”‚ â”‚      def plot_posterior_predictive(
â”‚ â”‚ @@ -206,37 +206,37 @@
â”‚ â”‚              likelihood_hdi_50 = self.get_target_transformer().inverse_transform(
â”‚ â”‚                  Xt=likelihood_hdi_50
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚          fig, ax = plt.subplots(**plt_kwargs)
â”‚ â”‚  
â”‚ â”‚          ax.fill_between(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y1=likelihood_hdi_94[:, 0],
â”‚ â”‚              y2=likelihood_hdi_94[:, 1],
â”‚ â”‚              color="C0",
â”‚ â”‚              alpha=0.2,
â”‚ â”‚              label="94% HDI",
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          ax.fill_between(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y1=likelihood_hdi_50[:, 0],
â”‚ â”‚              y2=likelihood_hdi_50[:, 1],
â”‚ â”‚              color="C0",
â”‚ â”‚              alpha=0.3,
â”‚ â”‚              label="50% HDI",
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          target_to_plot: pd.Series = (
â”‚ â”‚ -            self.data_df[self.target_column]
â”‚ â”‚ +            self.data[self.target_column]
â”‚ â”‚              if original_scale
â”‚ â”‚              else self.preprocessed_data[self.target_column]
â”‚ â”‚          )
â”‚ â”‚ -        ax.plot(self.data_df[self.date_column], target_to_plot, color="black")
â”‚ â”‚ +        ax.plot(self.data[self.date_column], target_to_plot, color="black")
â”‚ â”‚          ax.set(
â”‚ â”‚              title="Posterior Predictive Check",
â”‚ â”‚              xlabel="date",
â”‚ â”‚              ylabel=self.target_column,
â”‚ â”‚          )
â”‚ â”‚          return fig
â”‚ â”‚  
â”‚ â”‚ @@ -286,50 +286,50 @@
â”‚ â”‚              zip(
â”‚ â”‚                  means,
â”‚ â”‚                  contribution_vars,
â”‚ â”‚                  ["channel_contribution", "control_contribution"],
â”‚ â”‚              )
â”‚ â”‚          ):
â”‚ â”‚              ax.fill_between(
â”‚ â”‚ -                x=self.data_df[self.date_column],
â”‚ â”‚ +                x=self.data[self.date_column],
â”‚ â”‚                  y1=hdi.isel(hdi=0),
â”‚ â”‚                  y2=hdi.isel(hdi=1),
â”‚ â”‚                  color=f"C{i}",
â”‚ â”‚                  alpha=0.25,
â”‚ â”‚                  label=f"$94 %$ HDI ({var_contribution})",
â”‚ â”‚              )
â”‚ â”‚              sns.lineplot(
â”‚ â”‚ -                x=self.data_df[self.date_column],
â”‚ â”‚ +                x=self.data[self.date_column],
â”‚ â”‚                  y=mean,
â”‚ â”‚                  color=f"C{i}",
â”‚ â”‚                  ax=ax,
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚          intercept = az.extract(self.fit_result, var_names=["intercept"], combined=False)
â”‚ â”‚          intercept_hdi = np.repeat(
â”‚ â”‚              a=az.hdi(intercept).intercept.data[None, ...],
â”‚ â”‚              repeats=self.n_obs,
â”‚ â”‚              axis=0,
â”‚ â”‚          )
â”‚ â”‚          sns.lineplot(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y=intercept.mean().data,
â”‚ â”‚              color=f"C{i + 1}",
â”‚ â”‚              ax=ax,
â”‚ â”‚          )
â”‚ â”‚          ax.fill_between(
â”‚ â”‚ -            x=self.data_df[self.date_column],
â”‚ â”‚ +            x=self.data[self.date_column],
â”‚ â”‚              y1=intercept_hdi[:, 0],
â”‚ â”‚              y2=intercept_hdi[:, 1],
â”‚ â”‚              color=f"C{i + 1}",
â”‚ â”‚              alpha=0.25,
â”‚ â”‚              label="$94 %$ HDI (intercept)",
â”‚ â”‚          )
â”‚ â”‚          ax.plot(
â”‚ â”‚ -            self.data_df[self.date_column],
â”‚ â”‚ +            self.data[self.date_column],
â”‚ â”‚              self.preprocessed_data[self.target_column],
â”‚ â”‚              color="black",
â”‚ â”‚          )
â”‚ â”‚          ax.legend(title="components", loc="center left", bbox_to_anchor=(1, 0.5))
â”‚ â”‚          ax.set(
â”‚ â”‚              title="Posterior Predictive Model Components",
â”‚ â”‚              xlabel="date",
â”‚ â”‚ @@ -388,15 +388,15 @@
â”‚ â”‚              figsize=(12, 4 * self.n_channel),
â”‚ â”‚              layout="constrained",
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          for i, channel in enumerate(self.channel_columns):
â”‚ â”‚              ax = axes[i]
â”‚ â”‚              sns.regplot(
â”‚ â”‚ -                x=self.data_df[self.channel_columns].to_numpy()[:, i],
â”‚ â”‚ +                x=self.data[self.channel_columns].to_numpy()[:, i],
â”‚ â”‚                  y=channel_contributions.sel(channel=channel),
â”‚ â”‚                  color=f"C{i}",
â”‚ â”‚                  order=2,
â”‚ â”‚                  ci=None,
â”‚ â”‚                  line_kws={
â”‚ â”‚                      "linestyle": "--",
â”‚ â”‚                      "alpha": 0.5,
â”‚ â”‚ @@ -432,10 +432,13 @@
â”‚ â”‚              backend_kwargs=plot_kwargs,
â”‚ â”‚          )
â”‚ â”‚          ax.xaxis.set_major_formatter(mtick.FuncFormatter(lambda y, _: f"{y: 0.0%}"))
â”‚ â”‚          fig: plt.Figure = plt.gcf()
â”‚ â”‚          fig.suptitle("channel Contribution Share", fontsize=16, y=1.05)
â”‚ â”‚          return fig
â”‚ â”‚  
â”‚ â”‚ +    def graphviz(self, **kwargs):
â”‚ â”‚ +        return pm.model_to_graphviz(self.model, **kwargs)
â”‚ â”‚ +
â”‚ â”‚  
â”‚ â”‚  class MMM(BaseMMM, ValidateTargetColumn, ValidateDateColumn, ValidateChannelColumns):
â”‚ â”‚      pass
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/mmm/delayed_saturated_mmm.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/mmm/delayed_saturated_mmm.py
â”‚ â”‚â”„ Files 16% similar despite different names
â”‚ â”‚ @@ -1,58 +1,53 @@
â”‚ â”‚  from typing import Any, Dict, List, Optional
â”‚ â”‚  
â”‚ â”‚ -import arviz as az
â”‚ â”‚  import pandas as pd
â”‚ â”‚  import pymc as pm
â”‚ â”‚ -from xarray import DataArray
â”‚ â”‚  
â”‚ â”‚  from pymc_marketing.mmm.base import MMM
â”‚ â”‚ -from pymc_marketing.mmm.preprocessing import MaxAbsScaleChannels, MixMaxScaleTarget
â”‚ â”‚ -from pymc_marketing.mmm.transformers import (
â”‚ â”‚ -    geometric_adstock_vectorized,
â”‚ â”‚ -    logistic_saturation,
â”‚ â”‚ -)
â”‚ â”‚ +from pymc_marketing.mmm.preprocessing import MaxAbsScaleChannels, MaxAbsScaleTarget
â”‚ â”‚ +from pymc_marketing.mmm.transformers import geometric_adstock, logistic_saturation
â”‚ â”‚  from pymc_marketing.mmm.validating import ValidateControlColumns
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class DelayedSaturatedMMM(
â”‚ â”‚ -    MMM, MixMaxScaleTarget, MaxAbsScaleChannels, ValidateControlColumns
â”‚ â”‚ +    MMM, MaxAbsScaleTarget, MaxAbsScaleChannels, ValidateControlColumns
â”‚ â”‚  ):
â”‚ â”‚      def __init__(
â”‚ â”‚          self,
â”‚ â”‚ -        data_df: pd.DataFrame,
â”‚ â”‚ +        data: pd.DataFrame,
â”‚ â”‚          target_column: str,
â”‚ â”‚          date_column: str,
â”‚ â”‚          channel_columns: List[str],
â”‚ â”‚          validate_data: bool = True,
â”‚ â”‚          control_columns: Optional[List[str]] = None,
â”‚ â”‚          adstock_max_lag: int = 4,
â”‚ â”‚          **kwargs,
â”‚ â”‚      ) -> None:
â”‚ â”‚          self.control_columns = control_columns
â”‚ â”‚          self.adstock_max_lag = adstock_max_lag
â”‚ â”‚          super().__init__(
â”‚ â”‚ -            data_df=data_df,
â”‚ â”‚ +            data=data,
â”‚ â”‚              target_column=target_column,
â”‚ â”‚              date_column=date_column,
â”‚ â”‚              channel_columns=channel_columns,
â”‚ â”‚              validate_data=validate_data,
â”‚ â”‚              adstock_max_lag=adstock_max_lag,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      def build_model(
â”‚ â”‚          self,
â”‚ â”‚ -        data_df: pd.DataFrame,
â”‚ â”‚ +        data: pd.DataFrame,
â”‚ â”‚          adstock_max_lag: int = 4,
â”‚ â”‚      ) -> None:
â”‚ â”‚ -        date_data = data_df[self.date_column]
â”‚ â”‚ -        target_data = data_df[self.target_column]
â”‚ â”‚ -        channel_data = data_df[self.channel_columns]
â”‚ â”‚ +        date_data = data[self.date_column]
â”‚ â”‚ +        target_data = data[self.target_column]
â”‚ â”‚ +        channel_data = data[self.channel_columns]
â”‚ â”‚          if self.control_columns is not None:
â”‚ â”‚ -            control_data: Optional[pd.DataFrame] = data_df[self.control_columns]
â”‚ â”‚ +            control_data: Optional[pd.DataFrame] = data[self.control_columns]
â”‚ â”‚          else:
â”‚ â”‚              control_data = None
â”‚ â”‚          coords: Dict[str, Any] = {
â”‚ â”‚              "date": date_data,
â”‚ â”‚              "channel": channel_data.columns,
â”‚ â”‚          }
â”‚ â”‚  
â”‚ â”‚ @@ -78,19 +73,20 @@
â”‚ â”‚  
â”‚ â”‚              lam = pm.Gamma(name="lam", alpha=3, beta=1, dims="channel")
â”‚ â”‚  
â”‚ â”‚              sigma = pm.HalfNormal(name="sigma", sigma=2)
â”‚ â”‚  
â”‚ â”‚              channel_adstock = pm.Deterministic(
â”‚ â”‚                  name="channel_adstock",
â”‚ â”‚ -                var=geometric_adstock_vectorized(
â”‚ â”‚ +                var=geometric_adstock(
â”‚ â”‚                      x=channel_data_,
â”‚ â”‚                      alpha=alpha,
â”‚ â”‚                      l_max=adstock_max_lag,
â”‚ â”‚                      normalize=True,
â”‚ â”‚ +                    axis=0,
â”‚ â”‚                  ),
â”‚ â”‚                  dims=("date", "channel"),
â”‚ â”‚              )
â”‚ â”‚              channel_adstock_saturated = pm.Deterministic(
â”‚ â”‚                  name="channel_adstock_saturated",
â”‚ â”‚                  var=logistic_saturation(x=channel_adstock, lam=lam),
â”‚ â”‚                  dims=("date", "channel"),
â”‚ â”‚ @@ -125,25 +121,7 @@
â”‚ â”‚              pm.Normal(
â”‚ â”‚                  name="likelihood",
â”‚ â”‚                  mu=mu,
â”‚ â”‚                  sigma=sigma,
â”‚ â”‚                  observed=target_,
â”‚ â”‚                  dims="date",
â”‚ â”‚              )
â”‚ â”‚ -
â”‚ â”‚ -    def compute_channel_contribution_original_scale(self) -> DataArray:
â”‚ â”‚ -        beta_channel_samples_extended: DataArray = az.extract(
â”‚ â”‚ -            data=self.fit_result, var_names=["beta_channel"], combined=False
â”‚ â”‚ -        ).expand_dims({"date": self.n_obs}, axis=2)
â”‚ â”‚ -
â”‚ â”‚ -        channel_transformed: DataArray = az.extract(
â”‚ â”‚ -            data=self.fit_result,
â”‚ â”‚ -            var_names=["channel_adstock_saturated"],
â”‚ â”‚ -            combined=False,
â”‚ â”‚ -        )
â”‚ â”‚ -
â”‚ â”‚ -        normalization_factor: float = self.target_transformer.named_steps[
â”‚ â”‚ -            "scaler"
â”‚ â”‚ -        ].scale_.item()
â”‚ â”‚ -        return (
â”‚ â”‚ -            beta_channel_samples_extended * channel_transformed
â”‚ â”‚ -        ) / normalization_factor
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/mmm/preprocessing.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/mmm/preprocessing.py
â”‚ â”‚â”„ Files 21% similar despite different names
â”‚ â”‚ @@ -1,58 +1,58 @@
â”‚ â”‚  from typing import Callable
â”‚ â”‚  
â”‚ â”‚  import pandas as pd
â”‚ â”‚  from sklearn.pipeline import Pipeline
â”‚ â”‚ -from sklearn.preprocessing import MaxAbsScaler, MinMaxScaler, StandardScaler
â”‚ â”‚ +from sklearn.preprocessing import MaxAbsScaler, StandardScaler
â”‚ â”‚  
â”‚ â”‚  __all__ = [
â”‚ â”‚      "preprocessing_method",
â”‚ â”‚ -    "MixMaxScaleTarget",
â”‚ â”‚ +    "MaxAbsScaleTarget",
â”‚ â”‚      "MaxAbsScaleChannels",
â”‚ â”‚      "StandardizeControls",
â”‚ â”‚  ]
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def preprocessing_method(method: Callable) -> Callable:
â”‚ â”‚      if not hasattr(method, "_tags"):
â”‚ â”‚          method._tags = {}
â”‚ â”‚      method._tags["preprocessing"] = True
â”‚ â”‚      return method
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -class MixMaxScaleTarget:
â”‚ â”‚ +class MaxAbsScaleTarget:
â”‚ â”‚      @preprocessing_method
â”‚ â”‚ -    def min_max_scale_target_data(self, data_df: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ -        target_vector = data_df[self.target_column].to_numpy().reshape(-1, 1)
â”‚ â”‚ -        transformers = [("scaler", MinMaxScaler())]
â”‚ â”‚ +    def max_abs_scale_target_data(self, data: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ +        target_vector = data[self.target_column].to_numpy().reshape(-1, 1)
â”‚ â”‚ +        transformers = [("scaler", MaxAbsScaler())]
â”‚ â”‚          pipeline = Pipeline(steps=transformers)
â”‚ â”‚          self.target_transformer: Pipeline = pipeline.fit(X=target_vector)
â”‚ â”‚ -        data_df[self.target_column] = self.target_transformer.transform(
â”‚ â”‚ +        data[self.target_column] = self.target_transformer.transform(
â”‚ â”‚              X=target_vector
â”‚ â”‚          ).flatten()
â”‚ â”‚ -        return data_df
â”‚ â”‚ +        return data
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class MaxAbsScaleChannels:
â”‚ â”‚      @preprocessing_method
â”‚ â”‚ -    def max_abs_scale_channel_data(self, data_df: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ -        channel_data: pd.DataFrame = data_df[self.channel_columns]
â”‚ â”‚ +    def max_abs_scale_channel_data(self, data: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ +        channel_data: pd.DataFrame = data[self.channel_columns]
â”‚ â”‚          transformers = [("scaler", MaxAbsScaler())]
â”‚ â”‚          pipeline: Pipeline = Pipeline(steps=transformers)
â”‚ â”‚          self.channel_transformer: Pipeline = pipeline.fit(X=channel_data.to_numpy())
â”‚ â”‚ -        data_df[self.channel_columns] = self.channel_transformer.transform(
â”‚ â”‚ +        data[self.channel_columns] = self.channel_transformer.transform(
â”‚ â”‚              channel_data.to_numpy()
â”‚ â”‚          )
â”‚ â”‚ -        return data_df
â”‚ â”‚ +        return data
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class StandardizeControls:
â”‚ â”‚      @preprocessing_method
â”‚ â”‚ -    def standardize_control_data(self, data_df: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ -        control_data: pd.DataFrame = data_df[self.control_columns]
â”‚ â”‚ +    def standardize_control_data(self, data: pd.DataFrame) -> pd.DataFrame:
â”‚ â”‚ +        control_data: pd.DataFrame = data[self.control_columns]
â”‚ â”‚          transformers = [("scaler", StandardScaler())]
â”‚ â”‚          pipeline: Pipeline = Pipeline(steps=transformers)
â”‚ â”‚          self.control_transformer: Pipeline = pipeline.fit(X=control_data.to_numpy())
â”‚ â”‚ -        data_df[self.control_columns] = self.control_transformer.transform(
â”‚ â”‚ +        data[self.control_columns] = self.control_transformer.transform(
â”‚ â”‚              control_data.to_numpy()
â”‚ â”‚          )
â”‚ â”‚ -        return data_df
â”‚ â”‚ +        return data
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/mmm/utils.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/mmm/utils.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing/mmm/validating.py
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing/mmm/validating.py
â”‚ â”‚â”„ Files 13% similar despite different names
â”‚ â”‚ @@ -16,57 +16,57 @@
â”‚ â”‚          method._tags = {}
â”‚ â”‚      method._tags["validation"] = True
â”‚ â”‚      return method
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class ValidateTargetColumn:
â”‚ â”‚      @validation_method
â”‚ â”‚ -    def validate_target(self, data_df: pd.DataFrame) -> None:
â”‚ â”‚ -        if self.target_column not in data_df.columns:
â”‚ â”‚ -            raise ValueError(f"target {self.target_column} not in data_df")
â”‚ â”‚ +    def validate_target(self, data: pd.DataFrame) -> None:
â”‚ â”‚ +        if self.target_column not in data.columns:
â”‚ â”‚ +            raise ValueError(f"target {self.target_column} not in data")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class ValidateDateColumn:
â”‚ â”‚      @validation_method
â”‚ â”‚ -    def validate_date_col(self, data_df: pd.DataFrame) -> None:
â”‚ â”‚ -        if self.date_column not in data_df.columns:
â”‚ â”‚ -            raise ValueError(f"date_col {self.date_column} not in data_df")
â”‚ â”‚ -        if not data_df[self.date_column].is_unique:
â”‚ â”‚ +    def validate_date_col(self, data: pd.DataFrame) -> None:
â”‚ â”‚ +        if self.date_column not in data.columns:
â”‚ â”‚ +            raise ValueError(f"date_col {self.date_column} not in data")
â”‚ â”‚ +        if not data[self.date_column].is_unique:
â”‚ â”‚              raise ValueError(f"date_col {self.date_column} has repeated values")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class ValidateChannelColumns:
â”‚ â”‚      @validation_method
â”‚ â”‚ -    def validate_channel_columns(self, data_df: pd.DataFrame) -> None:
â”‚ â”‚ +    def validate_channel_columns(self, data: pd.DataFrame) -> None:
â”‚ â”‚          if not isinstance(self.channel_columns, (list, tuple)):
â”‚ â”‚              raise ValueError("channel_columns must be a list or tuple")
â”‚ â”‚          if len(self.channel_columns) == 0:
â”‚ â”‚              raise ValueError("channel_columns must not be empty")
â”‚ â”‚ -        if not set(self.channel_columns).issubset(data_df.columns):
â”‚ â”‚ -            raise ValueError(f"channel_columns {self.channel_columns} not in data_df")
â”‚ â”‚ +        if not set(self.channel_columns).issubset(data.columns):
â”‚ â”‚ +            raise ValueError(f"channel_columns {self.channel_columns} not in data")
â”‚ â”‚          if len(set(self.channel_columns)) != len(self.channel_columns):
â”‚ â”‚              raise ValueError(
â”‚ â”‚                  f"channel_columns {self.channel_columns} contains duplicates"
â”‚ â”‚              )
â”‚ â”‚ -        if (data_df[self.channel_columns] < 0).any().any():
â”‚ â”‚ +        if (data[self.channel_columns] < 0).any().any():
â”‚ â”‚              raise ValueError(
â”‚ â”‚                  f"channel_columns {self.channel_columns} contains negative values"
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class ValidateControlColumns:
â”‚ â”‚      @validation_method
â”‚ â”‚ -    def validate_control_columns(self, data_df: pd.DataFrame) -> None:
â”‚ â”‚ +    def validate_control_columns(self, data: pd.DataFrame) -> None:
â”‚ â”‚          if self.control_columns is None:
â”‚ â”‚              return None
â”‚ â”‚          if not isinstance(self.control_columns, (list, tuple)):
â”‚ â”‚              raise ValueError("control_columns must be None, a list or tuple")
â”‚ â”‚          if len(self.control_columns) == 0:
â”‚ â”‚              raise ValueError(
â”‚ â”‚                  "If control_columns is not None, then it must not be empty"
â”‚ â”‚              )
â”‚ â”‚ -        if not set(self.control_columns).issubset(data_df.columns):
â”‚ â”‚ -            raise ValueError(f"control_columns {self.control_columns} not in data_df")
â”‚ â”‚ +        if not set(self.control_columns).issubset(data.columns):
â”‚ â”‚ +            raise ValueError(f"control_columns {self.control_columns} not in data")
â”‚ â”‚          if len(set(self.control_columns)) != len(self.control_columns):
â”‚ â”‚              raise ValueError(
â”‚ â”‚                  f"control_columns {self.control_columns} contains duplicates"
â”‚ â”‚              )
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing.egg-info/PKG-INFO
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing.egg-info/PKG-INFO
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: pymc-marketing
â”‚ â”‚ -Version: 0.0.4
â”‚ â”‚ +Version: 0.1.0
â”‚ â”‚  Summary: Marketing Statistical Models in PyMC
â”‚ â”‚  Maintainer-email: PyMC Labs <info@pymc-labs.io>
â”‚ â”‚  License:                                  Apache License
â”‚ â”‚                                     Version 2.0, January 2004
â”‚ â”‚                                  http://www.apache.org/licenses/
â”‚ â”‚          
â”‚ â”‚             TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
â”‚ â”‚ @@ -211,24 +211,51 @@
â”‚ â”‚  Provides-Extra: docs
â”‚ â”‚  Provides-Extra: lint
â”‚ â”‚  Provides-Extra: test
â”‚ â”‚  License-File: LICENSE
â”‚ â”‚  
â”‚ â”‚  # PyMC-Marketing
â”‚ â”‚  
â”‚ â”‚ -![Build](https://github.com/pymc-labs/pymmmc/workflows/ci/badge.svg)
â”‚ â”‚ +![Build](https://github.com/pymc-labs/pymc-marketing/workflows/ci/badge.svg)
â”‚ â”‚  [![codecov](https://codecov.io/gh/pymc-labs/pymc-marketing/branch/main/graph/badge.svg?token=OBV3BS5TYE)](https://codecov.io/gh/pymc-labs/pymc-marketing)
â”‚ â”‚  [![docs](https://readthedocs.org/projects/pymc-marketing/badge/?version=latest)](https://docs.readthedocs.io/en/latest/)
â”‚ â”‚  [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
â”‚ â”‚  [![PyPI Version](https://img.shields.io/pypi/v/pymc-marketing.svg)](https://pypi.python.org/pypi/pymc-marketing)
â”‚ â”‚  [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
â”‚ â”‚  
â”‚ â”‚ +**Unlock the power of marketing analytics with PyMC-Marketing â€“ the open source solution for smarter decision-making.** Media mix modeling and customer lifetime value modules allow businesses to make data-driven decisions about their marketing campaigns. Optimize your marketing strategy and unlock the full potential of your customer data.
â”‚ â”‚ +
â”‚ â”‚ +---
â”‚ â”‚ +
â”‚ â”‚ +## Installation
â”‚ â”‚ +
â”‚ â”‚ +Start by setting up an environment (e.g. `marketing_env`) with PyMC. It may look something like the following:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +mamba create -c conda-forge -n marketing_env python "pymc>=5"
â”‚ â”‚ +mamba activate marketing_env
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +See the official [PyMC installation guide](https://www.pymc.io/projects/docs/en/latest/installation.html) if more detail is needed.
â”‚ â”‚ +
â”‚ â”‚ +Assuming you have an environment set up then install PyMC-Marketing with the following command. This will give you the latest version of the library from PyPI.
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install pymc-marketing
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚ +Alternatively you can install from GitHub directly:
â”‚ â”‚ +
â”‚ â”‚ +```bash
â”‚ â”‚ +pip install git+https://github.com/pymc-labs/pymc-marketing.git
â”‚ â”‚ +```
â”‚ â”‚ +
â”‚ â”‚  ## Bayesian Media Mix Models (MMMs) in PyMC
â”‚ â”‚  
â”‚ â”‚ -In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/). Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variiables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚ +In this package we provide an API for a Bayesian media mix model (MMM) specification following [Jin, Yuxue, et al. â€œBayesian methods for media mix modeling with carryover and shape effects.â€ (2017).](https://research.google/pubs/pub46001/) Concretely, given a time series target variable $y_{t}$ (e.g. sales on conversions), media variables $x_{m, t}$ (e.g. impressions, clicks or costs) and a set of control covariates $z_{c, t}$ (e.g. holidays, special events) we consider a linear model of the form
â”‚ â”‚  
â”‚ â”‚  $$
â”‚ â”‚  y_{t} = \alpha + \sum_{m=1}^{M}\beta_{m}f(x_{m, t}) +  \sum_{c=1}^{C}\gamma_{c}z_{c, t} + \varepsilon_{t},
â”‚ â”‚  $$
â”‚ â”‚  
â”‚ â”‚  where $\alpha$ is the intercept, $f$ is a media transformation function and $\varepsilon_{t}$ is the error therm which we assume is normally distributed. The function $f$ encodes the contribution of media on the target variable. Typically we consider two types of transformation: adstock (carry-over) and saturation effects.
â”‚ â”‚  
â”‚ â”‚ @@ -246,70 +273,42 @@
â”‚ â”‚    - [Improving the Speed and Accuracy of Bayesian Media Mix Models](https://www.pymc-labs.io/blog-posts/reducing-customer-acquisition-costs-how-we-helped-optimizing-hellofreshs-marketing-budget/)
â”‚ â”‚  - [Johns, Michael and Wang,  Zhenyu. "A Bayesian Approach to Media Mix Modeling"](https://www.youtube.com/watch?v=UznM_-_760Y)
â”‚ â”‚  - [Orduz, Juan. "Media Effect Estimation with PyMC: Adstock, Saturation & Diminishing Returns"](https://juanitorduz.github.io/pymc_mmm/)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚  ## Bayesian CLVs in PyMC
â”‚ â”‚ -[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) models is another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚ +[Customer Lifetime Value](https://en.wikipedia.org/wiki/Customer_lifetime_value) (CLV) models are another important class of models. There are many different types of CLV models and it can be helpful to conceptualise them as fitting in a 2-dimensional grid as below. An excellent set of introduction slides to CLV's is provided in [Probability Models for Customer-Base Analysis](https://www.brucehardie.com/talks/ho_cba_tut_art_09.pdf) by Fader & Hardie (2009).
â”‚ â”‚  
â”‚ â”‚  ### Examples
â”‚ â”‚  
â”‚ â”‚  |                | **Non-contractual** | **Contractual**                 |
â”‚ â”‚  |----------------|---------------------|---------------------------------|
â”‚ â”‚  | **Continuous** | Buying groceries    | Audible                         |
â”‚ â”‚  | **Discrete**   | Cinema ticket       | Monthly or yearly subscriptions |
â”‚ â”‚  
â”‚ â”‚  To explain further:
â”‚ â”‚ -- **Contractual:** In contractual settings a customer has a contract which continues to be active until it is explicitly cancelled. Therefore in contractual settings, customer churn events are observed.
â”‚ â”‚ +- **Contractual:** In contractual settings, a customer has a contract which continues to be active until it is explicitly cancelled. Therefore, customer churn events are observed.
â”‚ â”‚  
â”‚ â”‚  - **Non-contractual:** In non-contractual settings, there is no ongoing contract that a customer has with a company. Instead, purchases can be ad hoc and churn events are unobserved.
â”‚ â”‚  
â”‚ â”‚  - **Discrete:** Here, purchases are made at discrete points in time. This obviously depends upon the timescale that we are working on, but typically a relevant time period would be a month or year. However it could be more granualar than this - think of taking the 2nd of 4 inter-city train journeys offered per day.
â”‚ â”‚  
â”‚ â”‚ -- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚ +- **Continuous:** In the continuous-time domain, purchases can be made at any point within a firms opening hours. For online ordering, this could be any point within a 24 hour cycle, or purchases in physical stores could be made at any point during the trading day.
â”‚ â”‚  
â”‚ â”‚ -In the documentation we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚ +In the documentation, we provide some examples on how to use the CLV API. We use the data from the [`lifetimes`](https://github.com/CamDavidsonPilon/lifetimes) package to illustrate the models.
â”‚ â”‚  
â”‚ â”‚  - [CLV Quickstart](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/clv_quickstart.html)
â”‚ â”‚  - [BG/NBD model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/bg_nbd.html)
â”‚ â”‚  - [Gamma-Gamma model](https://pymc-marketing.readthedocs.io/en/stable/notebooks/clv/gamma_gamma.html)
â”‚ â”‚  
â”‚ â”‚  ---
â”‚ â”‚  
â”‚ â”‚ -## Local Development
â”‚ â”‚ +## ðŸ“ž Schedule a Consultation
â”‚ â”‚ +Unlock your potential with a free 30-minute strategy session with our PyMC experts. Discover how open source solutions and pymc-marketing can elevate your media-mix models and customer lifetime value analyses. Boost your career and organization by making smarter, data-driven decisions. Don't waitâ€”[claim your complimentary session](https://calendly.com/benjamin-vincent/pymc-marketing) today and lead the way in marketing and data science innovation.
â”‚ â”‚  
â”‚ â”‚ -1. Create conda environment. For example:
â”‚ â”‚ +## Using PyMC-Marketing and how PyMC Labs can help you
â”‚ â”‚ +PyMC-Marketing uses the [Apache 2.0 licence](LICENSE) which permits commercial use, amongst other things.
â”‚ â”‚  
â”‚ â”‚ -```shell
â”‚ â”‚ -conda create -n pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ +If you want to build upon the package, please feel free to fork the repo and submit a pull request. If in doubt, please open an issue.
â”‚ â”‚  
â”‚ â”‚ -2. Activate environment.
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -conda activate pymc_marketing_env
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -3. Install `pymc_marketing` package:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make init
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -4. To run tests:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make test
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -5. To check code style:
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -make check_lint
â”‚ â”‚ -```
â”‚ â”‚ -
â”‚ â”‚ -6. Set [pre-commit hooks](https://pre-commit.com/) (Optional):
â”‚ â”‚ -
â”‚ â”‚ -```shell
â”‚ â”‚ -pre-commit install
â”‚ â”‚ -```
â”‚ â”‚ +For companies that want to use PyMC-Marketing in production, [PyMC Labs](https://www.pymc-labs.io) is available for consulting and training. We can help you build and deploy your models in production. We have experience with cutting edge Bayesian modelling techniques in general, and in particular with MMMs and CLVs. For example, see our video on [Bayesian Marketing Mix Models: State of the Art and their Future](https://www.youtube.com/watch?v=xVx91prC81g).
â”‚ â”‚   --- pymc-marketing-0.0.4/pymc_marketing.egg-info/SOURCES.txt
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pymc_marketing.egg-info/SOURCES.txt
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- pymc-marketing-0.0.4/pyproject.toml
â”‚ â”œâ”€â”€ +++ pymc-marketing-0.1.0/pyproject.toml
â”‚ â”‚â”„ Files 7% similar despite different names
â”‚ â”‚ @@ -12,15 +12,15 @@
â”‚ â”‚  maintainers = [{ name = "PyMC Labs", email = "info@pymc-labs.io" }]
â”‚ â”‚  
â”‚ â”‚  dependencies = [
â”‚ â”‚      "arviz>=0.13.0",
â”‚ â”‚      "matplotlib>=3.5.1",
â”‚ â”‚      "numpy>=1.17",
â”‚ â”‚      "pandas",
â”‚ â”‚ -    "pymc>=5.0.0",
â”‚ â”‚ +    "pymc>=5.1.2",
â”‚ â”‚      "scikit-learn>=1.1.1",
â”‚ â”‚      "seaborn>=0.12.2",
â”‚ â”‚      "xarray"
â”‚ â”‚  ]
â”‚ â”‚  
â”‚ â”‚  [project.optional-dependencies]
â”‚ â”‚  docs = [
â”‚ â”‚ @@ -35,15 +35,16 @@
â”‚ â”‚      "sphinx-notfound-page",
â”‚ â”‚      "sphinx-design"
â”‚ â”‚  ]
â”‚ â”‚  lint = [
â”‚ â”‚      "black>=22.3.0",
â”‚ â”‚      "flake8>=4.0.1",
â”‚ â”‚      "isort>=5.10.1",
â”‚ â”‚ -    "pre-commit>=2.19.0"
â”‚ â”‚ +    "pre-commit>=2.19.0",
â”‚ â”‚ +    "pylint"
â”‚ â”‚  ]
â”‚ â”‚  test = [
â”‚ â”‚      "lifetimes==0.11.3",
â”‚ â”‚      "pytest==7.0.1",
â”‚ â”‚      "pytest-cov==3.0.0"
â”‚ â”‚  ]
