--- tmp/pysura-0.99.81.tar.gz
+++ tmp/pysura-0.99.9.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "pysura-0.99.81.tar", last modified: Thu Apr  6 22:10:46 2023, max compression
│ +gzip compressed data, was "pysura-0.99.9.tar", last modified: Fri Mar 31 01:04:39 2023, max compression
│   --- pysura-0.99.81.tar
├── +++ pysura-0.99.9.tar
│ ├── file list
│ │ @@ -1,110 +1,75 @@
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.625612 pysura-0.99.81/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1069 2023-03-20 10:07:23.000000 pysura-0.99.81/LICENSE.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    11717 2023-04-06 22:10:46.625717 pysura-0.99.81/PKG-INFO
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    10980 2023-04-05 22:05:09.000000 pysura-0.99.81/README.rst
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.604740 pysura-0.99.81/pysura/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-23 15:46:21.000000 pysura-0.99.81/pysura/__init__.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.606283 pysura-0.99.81/pysura/cli/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-22 06:05:11.000000 pysura-0.99.81/pysura/cli/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      771 2023-04-02 23:46:54.000000 pysura-0.99.81/pysura/cli/app.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)   157163 2023-04-06 22:10:37.000000 pysura-0.99.81/pysura/cli/google_root.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.607631 pysura-0.99.81/pysura/faster_api/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        1 2023-03-31 02:57:53.000000 pysura-0.99.81/pysura/faster_api/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      157 2023-04-01 13:36:35.000000 pysura-0.99.81/pysura/faster_api/enums.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1040 2023-04-02 22:11:13.000000 pysura-0.99.81/pysura/faster_api/models.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    11856 2023-04-06 00:54:39.000000 pysura-0.99.81/pysura/faster_api/security.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.603471 pysura-0.99.81/pysura/library_data/
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.608373 pysura-0.99.81/pysura/library_data/pysura_auth/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-26 12:15:47.000000 pysura-0.99.81/pysura/library_data/pysura_auth/.gcloudignore
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     3056 2023-04-01 19:05:04.000000 pysura-0.99.81/pysura/library_data/pysura_auth/main.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      958 2023-03-27 11:41:24.000000 pysura-0.99.81/pysura/library_data/pysura_auth/requirements.txt
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.608965 pysura-0.99.81/pysura/library_data/pysura_frontend/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      691 2023-04-04 01:50:17.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/build.yaml
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.609524 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.611575 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1075 2023-03-31 06:17:27.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/app_color.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2531 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/app_route.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2453 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/app_text_style.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1632 2023-03-31 06:19:26.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/app_theme.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      213 2023-04-04 16:39:17.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/constants.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      412 2023-03-31 06:21:23.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/date_util.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     3988 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/popups.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1285 2023-04-04 04:19:48.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/utils.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.612443 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2400 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/auth_controller.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1000 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/data_controller.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1980 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/graphql_controller.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      452 2023-03-31 07:01:52.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/theme_controller.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.615041 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1034 2023-04-04 03:45:32.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/actions.graphql
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    71391 2023-04-04 02:34:58.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/actions.graphql.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    43063 2023-04-04 01:21:17.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/schema.graphql
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)   368298 2023-04-04 02:34:58.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/schema.graphql.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      646 2023-04-04 02:16:17.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/user.graphql
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    63297 2023-04-04 02:34:58.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/graphql/user.graphql.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1966 2023-04-05 15:18:37.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/main.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.602834 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.615932 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/auth/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     5781 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/auth/login_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2441 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/auth/login_page_controller.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.616619 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.617073 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/action/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     9580 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/action/action_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     4908 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/action/action_page_controller.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.617570 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/home/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     7574 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/home/home_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     5621 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/home/home_page_controller.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1162 2023-03-31 15:44:39.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/main_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      744 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/main_page_controller.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      964 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/main_page_middleware.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.618045 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/settings/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     5506 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/settings/settings_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2298 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/main/settings/settings_page_controller.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.618542 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      350 2023-03-31 07:37:44.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/error_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      378 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/loading_page.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.618904 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/splash/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      883 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/splash/splash_page.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      658 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/misc/splash/splash_page_controller.dart
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.619633 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      888 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/graphql_provider_widget.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1530 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/phone_number_field.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1156 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/primary_button.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1007 2023-04-04 16:09:45.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/secondary_button.dart
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2021 2023-04-05 15:14:39.000000 pysura-0.99.81/pysura/library_data/pysura_frontend/pubspec.yaml
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.621302 pysura-0.99.81/pysura/library_data/pysura_microservice/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      596 2023-03-30 01:08:14.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/Dockerfile
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       30 2023-03-30 05:47:17.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/README.md
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.622108 pysura-0.99.81/pysura/library_data/pysura_microservice/actions/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       19 2023-03-30 22:32:31.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/actions/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1842 2023-04-03 22:19:14.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/actions/action_template.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     4884 2023-04-06 05:55:22.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/actions/action_upload_file.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1452 2023-04-02 23:37:34.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/app.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      754 2023-04-06 00:25:39.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/app_secrets.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.622402 pysura-0.99.81/pysura/library_data/pysura_microservice/crons/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       18 2023-03-30 01:13:17.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/crons/__init__.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.622870 pysura-0.99.81/pysura/library_data/pysura_microservice/events/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       19 2023-03-30 01:13:17.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/events/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2013 2023-04-03 22:19:14.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/events/event_update_user_role.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    10748 2023-04-06 01:14:19.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/pysura_metadata.json
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1231 2023-04-03 07:53:42.000000 pysura-0.99.81/pysura/library_data/pysura_microservice/requirements.txt
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.623453 pysura-0.99.81/pysura/library_data/pysura_ssr/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       52 2023-04-05 20:24:54.000000 pysura-0.99.81/pysura/library_data/pysura_ssr/.firebaserc
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      239 2023-04-05 20:25:13.000000 pysura-0.99.81/pysura/library_data/pysura_ssr/firebase.json
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.624257 pysura-0.99.81/pysura/playground/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-04-01 13:54:32.000000 pysura-0.99.81/pysura/playground/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     1796 2023-03-31 03:54:29.000000 pysura-0.99.81/pysura/playground/tmp.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     2386 2023-03-31 03:14:29.000000 pysura-0.99.81/pysura/playground/tmp2.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.625200 pysura-0.99.81/pysura/pysura_types/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-23 16:42:48.000000 pysura-0.99.81/pysura/pysura_types/__init__.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    20772 2023-04-06 00:22:51.000000 pysura-0.99.81/pysura/pysura_types/google_pysura_env.py
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     6647 2023-04-05 18:30:55.000000 pysura-0.99.81/pysura/pysura_types/root_cmd.py
│ │ -drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-04-06 22:10:46.605613 pysura-0.99.81/pysura.egg-info/
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)    11717 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/PKG-INFO
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     4300 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        1 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       46 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/entry_points.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)       63 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/requires.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)        7 2023-04-06 22:10:46.000000 pysura-0.99.81/pysura.egg-info/top_level.txt
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)      106 2023-04-06 22:10:46.626110 pysura-0.99.81/setup.cfg
│ │ --rw-r--r--   0 thegoodz   (501) staff       (20)     5467 2023-04-06 22:09:49.000000 pysura-0.99.81/setup.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.098084 pysura-0.99.9/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1069 2023-03-20 10:07:23.000000 pysura-0.99.9/LICENSE.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     9127 2023-03-31 01:04:39.098186 pysura-0.99.9/PKG-INFO
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     8354 2023-03-30 07:12:08.000000 pysura-0.99.9/README.rst
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.085116 pysura-0.99.9/pysura/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-23 15:46:21.000000 pysura-0.99.9/pysura/__init__.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.086513 pysura-0.99.9/pysura/cli/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-22 06:05:11.000000 pysura-0.99.9/pysura/cli/__init__.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      675 2023-03-26 09:40:52.000000 pysura-0.99.9/pysura/cli/app.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)    98193 2023-03-31 01:02:09.000000 pysura-0.99.9/pysura/cli/google_root.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.087841 pysura-0.99.9/pysura/faster_api/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       25 2023-03-23 14:15:46.000000 pysura-0.99.9/pysura/faster_api/__init__.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      206 2023-03-30 05:06:41.000000 pysura-0.99.9/pysura/faster_api/enums.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     5914 2023-03-30 21:39:40.000000 pysura-0.99.9/pysura/faster_api/security.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      148 2023-03-24 15:28:42.000000 pysura-0.99.9/pysura/faster_api/test_class.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.082157 pysura-0.99.9/pysura/library_data/
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.088559 pysura-0.99.9/pysura/library_data/pysura_auth/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-26 12:15:47.000000 pysura-0.99.9/pysura/library_data/pysura_auth/.gcloudignore
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     2646 2023-03-30 06:54:45.000000 pysura-0.99.9/pysura/library_data/pysura_auth/main.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      958 2023-03-27 11:41:24.000000 pysura-0.99.9/pysura/library_data/pysura_auth/requirements.txt
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.088798 pysura-0.99.9/pysura/library_data/pysura_frontend/
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.089170 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.090834 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      373 2023-03-27 17:25:23.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/constants.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      393 2023-03-27 16:40:53.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/date_util.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     3130 2023-03-27 16:46:35.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/popups.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     2025 2023-03-27 16:50:56.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/styles.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      729 2023-03-27 16:42:08.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/common/utils.dart
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.091573 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/controllers/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1560 2023-03-27 16:42:36.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/controllers/auth_controller.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1969 2023-03-27 16:46:35.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/controllers/graphql_controller.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     2516 2023-03-29 21:00:46.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/main.dart
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.082026 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.092079 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/auth/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     5158 2023-03-27 16:43:52.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/auth/login_page.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     2047 2023-03-27 16:44:22.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/auth/login_page_controller.dart
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.092678 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/main/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      882 2023-03-27 23:17:43.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/main/main_page.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      718 2023-03-27 23:17:17.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/main/main_page_controller.dart
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.093184 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/misc/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      338 2023-03-27 16:50:56.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/misc/error_page.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      301 2023-03-27 16:50:56.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/misc/loading_page.dart
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.094390 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      708 2023-03-27 16:50:56.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/graphql_provider_widget.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1536 2023-03-27 16:50:56.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/phone_number_field.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1393 2023-03-27 16:51:23.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/primary_button.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1466 2023-03-27 16:51:50.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/secondary_button.dart
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1954 2023-03-29 21:12:03.000000 pysura-0.99.9/pysura/library_data/pysura_frontend/pubspec.yaml
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.096315 pysura-0.99.9/pysura/library_data/pysura_microservice/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      596 2023-03-30 01:08:14.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/Dockerfile
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       30 2023-03-30 05:47:17.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/README.md
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.096781 pysura-0.99.9/pysura/library_data/pysura_microservice/actions/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       19 2023-03-30 22:32:31.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/actions/__init__.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1689 2023-03-30 17:37:02.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/actions/action_template.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      746 2023-03-30 21:11:23.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/app.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1050 2023-03-30 21:37:32.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/app_secrets.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.097095 pysura-0.99.9/pysura/library_data/pysura_microservice/crons/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       18 2023-03-30 01:13:17.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/crons/__init__.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.097283 pysura-0.99.9/pysura/library_data/pysura_microservice/events/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       19 2023-03-30 01:13:17.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/events/__init__.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     5947 2023-03-30 17:37:02.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/pysura_metadata.json
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     1165 2023-03-30 01:13:17.000000 pysura-0.99.9/pysura/library_data/pysura_microservice/requirements.txt
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.097972 pysura-0.99.9/pysura/pysura_types/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        0 2023-03-23 16:42:48.000000 pysura-0.99.9/pysura/pysura_types/__init__.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)    19300 2023-03-30 18:35:44.000000 pysura-0.99.9/pysura/pysura_types/google_pysura_env.py
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     5720 2023-03-31 01:03:50.000000 pysura-0.99.9/pysura/pysura_types/root_cmd.py
│ │ +drwxr-xr-x   0 thegoodz   (501) staff       (20)        0 2023-03-31 01:04:39.085984 pysura-0.99.9/pysura.egg-info/
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     9127 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     2492 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        1 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)       47 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/entry_points.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      153 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/requires.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)        7 2023-03-31 01:04:39.000000 pysura-0.99.9/pysura.egg-info/top_level.txt
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)      106 2023-03-31 01:04:39.099183 pysura-0.99.9/setup.cfg
│ │ +-rw-r--r--   0 thegoodz   (501) staff       (20)     3675 2023-03-31 01:04:14.000000 pysura-0.99.9/setup.py
│ │   --- pysura-0.99.81/LICENSE.txt
│ ├── +++ pysura-0.99.9/LICENSE.txt
│ │┄ Files identical despite different names
│ │   --- pysura-0.99.81/PKG-INFO
│ ├── +++ pysura-0.99.9/PKG-INFO
│ │┄ Files 14% similar despite different names
│ │ @@ -1,59 +1,67 @@
│ │  Metadata-Version: 2.1
│ │  Name: pysura
│ │ -Version: 0.99.81
│ │ +Version: 0.99.9
│ │  Summary: A useful tool that provides commands to help ease the installation process of Hasura, and manage its actions, events, and scheduled jobs with baked in phone Auth and a Flutter frontend.
│ │  Home-page: https://github.com/tristengoodz/pysura
│ │  Author: Tristen Harr
│ │  Author-email: tristen@thegoodzapp.com
│ │ +License: UNKNOWN
│ │  Keywords: hasura,graphql,postgresql,google-cloud,python,pysura,backend,backend-in-a-box
│ │ +Platform: UNKNOWN
│ │  Classifier: Development Status :: 4 - Beta
│ │  Classifier: Intended Audience :: Developers
│ │  Classifier: Topic :: Software Development :: Build Tools
│ │  Classifier: License :: OSI Approved :: MIT License
│ │  Classifier: Programming Language :: Python :: 3
│ │  Requires-Python: >=3.9
│ │  License-File: LICENSE.txt
│ │  
│ │  
│ │  Pysura - BETA
│ │  =============
│ │  
│ │  Hasura + Python = Pysura. An open source solution.
│ │ ---------------------------------------------------
│ │ +^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  Because everyone should be a code wizard.
│ │  
│ │  
│ │  .. image:: images/code_wizard.png
│ │     :target: images/code_wizard.png
│ │     :alt: img_1.png
│ │  
│ │  
│ │  Requirements:
│ │ -^^^^^^^^^^^^^
│ │ +-------------
│ │  
│ │  To deploy Hasura with Pysura with baked in Auth and a templated Flutter Frontend:
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  
│ │ -* Python 3.9+
│ │  * gcloud CLI
│ │  * gcloud beta CLI
│ │  * A billing account with Google Cloud
│ │  * Docker (Make sure it's running in the background or your deployment will fail!)
│ │ +* Python 3.9+
│ │  * Firebase CLI
│ │  * npm
│ │ +* flutterfire_cli
│ │  * Dart
│ │  * Flutter
│ │ +* XCode (for iOS apps) and iOS Dev Tools
│ │ +* Android Studio (for Android apps) and Android Dev Tools
│ │ +* Gradle (for Android apps)
│ │  
│ │  .. code-block:: commandline
│ │  
│ │     pip install pysura
│ │     pysura
│ │ +   (pysura_cli) >>> choose_provider
│ │ +   Please choose a provider: [google,]: google
│ │     (pysura_cli) >>> setup_pysura
│ │  
│ │  Note: The installer is doing a lot of things. Some of them take a long time, like creating databases, firewalls, and VPC
│ │  networks. Sometimes it might look frozen, but give it some time to do its thing. It's automagically building an entire
│ │  application for you. I promise doing this by hand takes longer. ;)
│ │  
│ │  
│ │ @@ -69,15 +77,15 @@
│ │  
│ │  Linux - It should work on Linux, it is untested. Let me know!
│ │  
│ │  Windows - With minor updates it should work. I think the majority of the deployer works, but it might run into issues on
│ │  the Firebase and Flutterfire CLI's.
│ │  
│ │  What is Pysura?
│ │ ----------------
│ │ +===============
│ │  
│ │  Pysura is a CLI tool that's designed to make building and deploying multi-tenant enterprise grade applications as easy
│ │  as a freshman year algorithms class. It's a highly opinionated way because it's the right way.
│ │  
│ │  It's kind of like running npm init, if npm was for backends and frontends, it provides your backend, auth, and database
│ │  for you in the cloud in a way that is infinitely scalable and uses zero-trust, with a type-safe GraphQL backend and a
│ │  bring-your-own front-end approach with special built-in support for Flutter which is the default setup.
│ │ @@ -86,72 +94,27 @@
│ │  
│ │  So that it doesn't matter what you are building, you can build it on Pysura. It's about damn time that Python developers
│ │  have better mobile support. Let's bring python to mobile. Let's bring python to the web. Let's bring python to the edge.
│ │  Let's bring python everywhere. And let's skin it with Flutter and feed it all the data it wants with GraphQL and Hasura.
│ │  
│ │  Do I have to use Flutter for the frontend? No way! Pysura places firebase in front of your Hasura instance, so if your
│ │  frontend of choice supports Firebase Auth integrations or libraries, you can use it, or even better open a PR and add a
│ │ -template for your provider. You *do* need Flutter for installation
│ │ -
│ │ -What does the Pysura installer do?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ -
│ │ -
│ │ -* Authenticates you with gcloud
│ │ -* Creates a new project in Google Cloud
│ │ -* Sets up a VPC network inside the project
│ │ -* Creates a new Cloud SQL instance running Postgres 14
│ │ -* Stores all Env variables in secret manager to be loaded from containers
│ │ -* Creates a new Hasura instance in Cloud Run with scaling settings always allocating memory for at least 1 instance
│ │ -* Attaches Firebase to the project
│ │ -* Deploys firebase functions triggering on user.create/delete managing Hasura user data each with min instances set to 1
│ │ -* Adds JWT authentication via Firebase to Hasura with phone sign in
│ │ -* Creates a new Flutter app with Firebase Auth using flutterfire
│ │ -* Configures Android signing keys (COMING SOON: Auto app icon configuration)
│ │ -* Configures iOS URL schemes (COMING SOON: Auto app icon configuration)
│ │ -* Updates the default flutter template to use the Pysura template for Flutter 
│ │ -* Deploys the flutter template to Firebase hosting for the web. (COMING SOON: Auto app icon configuration)
│ │ -* Deploys a default microservice on Cloud Run using Pysura! Includes default event that handles JWT claim changes
│ │ +template for your provider.
│ │  
│ │  What is a Pysura Microservice?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  It's a wrapper around a FastAPI app that holds a collection of actions, events, and chron-jobs related to its function.
│ │  I.e. A payment microservice might have all code related to payment processing. It bakes in Auth with an extra decorator
│ │  which gives you easy access to the calling user each time a method is called. This works by using opaque tokens that
│ │  pass through the headers into the microservice. It's a very simple way to do auth, and it's very secure. It gives full
│ │  RBAC at a column level, and you can design rather complex auth rules using Hasura's permission system. Each action,
│ │  event, and chron-job is placed in a separate file with routing already handled and the calling users information passed
│ │  in the calling context. It makes it very easy to build your business logic in a clean, consistent way that is easy to
│ │  test and maintain, and also easy to hand off to other developers.
│ │  
│ │ -Pysura uses middleware to handle the auth, and provide you access to app resources like the database, and the caller.
│ │ -It wraps FastAPI, and uses a router for each action, event, or chron-job. Separating the business logic into collections
│ │ -of microservices each containing folders of actions, events, and chron-jobs each delegated to their own file which 
│ │ -makes it easy to scale and maintain.
│ │ -
│ │ -Front-end clients should utilize the Hasura GraphQL API to access and mutate the data in the database. This is the 
│ │ -recommended way to access the data. It is important to make sure you set up proper roles and permissions in Hasura to
│ │ -ensure that only the correct users can access the data meant for them. By default, Pysura includes a user and admin role
│ │ -
│ │ -Actions are used to allow the front-end client a way to perform custom business logic, or do a task that requires
│ │ -calling third party APIs or services. Actions are called via the Hasura GraphQL API, and are executed on the 
│ │ -microservice instance.
│ │ -
│ │ -Events are used to trigger custom business logic when something occurs in the database. For example, when a user is
│ │ -created, you might want to send them a welcome email. Events are triggered by Hasura (via the Database),
│ │ -and are executed on the microservice instance.
│ │ -
│ │ -Crons are used to trigger custom business logic on a schedule. For example, you might want to send a report to the
│ │ -admin every day at 8am. Crons are triggered by Hasura (via the Database), and are executed on the microservice instance.
│ │ -
│ │ -By default, the application is configured with an event secret that must be passed to all microservices in the header
│ │ -from Hasura. This ensures that all traffic is coming from Hasura, and not from a malicious source. This makes things
│ │ -SUPER secure, with JWT auth, and event secrets. It's a very secure way to build an application.
│ │ -
│ │  Do I need to deploy Hasura with Pysura to use it?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  As of right now yes. In the future, no!
│ │  
│ │  Is this just a wrapper for the Hasura CLI?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ @@ -206,17 +169,14 @@
│ │  
│ │  A: Please open an issue or a feature request. I'm sure I missed some things. Stitching this together required a bit of
│ │  everything, including working outside my area of expertise.
│ │  
│ │  TODOS:
│ │  ^^^^^^
│ │  
│ │ -Remove pyscopg2 dependency to drop postgres req
│ │ -===============================================
│ │ -
│ │  DONE:
│ │  
│ │  
│ │  * [x] Add support for Google Cloud
│ │  * [x] Add support for Firebase Auth
│ │  * [x] Add ios/android wizard
│ │  * [x] Add support for Flutter
│ │ @@ -233,18 +193,24 @@
│ │  * [ ] Add support for other auth providers (Auth0, etc) @Unclaimed
│ │  
│ │    * [ ] Auth0
│ │    * [ ] ???
│ │  
│ │  * [ ] Flutter SSR bindings for Web @Unclaimed
│ │  * [ ] Caching Wizard @Tristen
│ │ +* [ ] Update the pysura/pysura_types/root_cmd.py to make better use of prompt_toolkit. It would be nice to have multiple
│ │ +  tabs for different level of logs. @Unclaimed
│ │  * [ ] Built in API Version Control @Tristen
│ │ +* [ ] Tighten up the command loops. (Ex. Test the deployer and input values that will fail, and make sure it can recover
│ │ +  more gracefully) @Unclaimed
│ │  
│ │  LOW PRIORITY:
│ │  
│ │  
│ │  * [ ] Add support for AWS/Azure/Etc.
│ │  * [ ] Add support for other databases (Postgres, MySQL, BigQuery, etc)
│ │  * [ ] Add support for other frontends (React, Vue, etc)
│ │  * [ ] Rewrite the CLI tool in a more modular way, with command plug-ins.
│ │  * [ ] It should be possible to introspect the entirety of the gcloud CLI by parsing the output of ``gcloud help``. And
│ │    walking the CLI tool This would allow for a more dynamic CLI tool that could be used for other projects.
│ │ +
│ │ +
│ │   --- pysura-0.99.81/README.rst
│ ├── +++ pysura-0.99.9/pysura.egg-info/PKG-INFO
│ │┄ Files 14% similar despite different names
│ │ @@ -1,43 +1,67 @@
│ │ +Metadata-Version: 2.1
│ │ +Name: pysura
│ │ +Version: 0.99.9
│ │ +Summary: A useful tool that provides commands to help ease the installation process of Hasura, and manage its actions, events, and scheduled jobs with baked in phone Auth and a Flutter frontend.
│ │ +Home-page: https://github.com/tristengoodz/pysura
│ │ +Author: Tristen Harr
│ │ +Author-email: tristen@thegoodzapp.com
│ │ +License: UNKNOWN
│ │ +Keywords: hasura,graphql,postgresql,google-cloud,python,pysura,backend,backend-in-a-box
│ │ +Platform: UNKNOWN
│ │ +Classifier: Development Status :: 4 - Beta
│ │ +Classifier: Intended Audience :: Developers
│ │ +Classifier: Topic :: Software Development :: Build Tools
│ │ +Classifier: License :: OSI Approved :: MIT License
│ │ +Classifier: Programming Language :: Python :: 3
│ │ +Requires-Python: >=3.9
│ │ +License-File: LICENSE.txt
│ │ +
│ │  
│ │  Pysura - BETA
│ │  =============
│ │  
│ │  Hasura + Python = Pysura. An open source solution.
│ │ ---------------------------------------------------
│ │ +^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  Because everyone should be a code wizard.
│ │  
│ │  
│ │  .. image:: images/code_wizard.png
│ │     :target: images/code_wizard.png
│ │     :alt: img_1.png
│ │  
│ │  
│ │  Requirements:
│ │ -^^^^^^^^^^^^^
│ │ +-------------
│ │  
│ │  To deploy Hasura with Pysura with baked in Auth and a templated Flutter Frontend:
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  
│ │ -* Python 3.9+
│ │  * gcloud CLI
│ │  * gcloud beta CLI
│ │  * A billing account with Google Cloud
│ │  * Docker (Make sure it's running in the background or your deployment will fail!)
│ │ +* Python 3.9+
│ │  * Firebase CLI
│ │  * npm
│ │ +* flutterfire_cli
│ │  * Dart
│ │  * Flutter
│ │ +* XCode (for iOS apps) and iOS Dev Tools
│ │ +* Android Studio (for Android apps) and Android Dev Tools
│ │ +* Gradle (for Android apps)
│ │  
│ │  .. code-block:: commandline
│ │  
│ │     pip install pysura
│ │     pysura
│ │ +   (pysura_cli) >>> choose_provider
│ │ +   Please choose a provider: [google,]: google
│ │     (pysura_cli) >>> setup_pysura
│ │  
│ │  Note: The installer is doing a lot of things. Some of them take a long time, like creating databases, firewalls, and VPC
│ │  networks. Sometimes it might look frozen, but give it some time to do its thing. It's automagically building an entire
│ │  application for you. I promise doing this by hand takes longer. ;)
│ │  
│ │  
│ │ @@ -53,15 +77,15 @@
│ │  
│ │  Linux - It should work on Linux, it is untested. Let me know!
│ │  
│ │  Windows - With minor updates it should work. I think the majority of the deployer works, but it might run into issues on
│ │  the Firebase and Flutterfire CLI's.
│ │  
│ │  What is Pysura?
│ │ ----------------
│ │ +===============
│ │  
│ │  Pysura is a CLI tool that's designed to make building and deploying multi-tenant enterprise grade applications as easy
│ │  as a freshman year algorithms class. It's a highly opinionated way because it's the right way.
│ │  
│ │  It's kind of like running npm init, if npm was for backends and frontends, it provides your backend, auth, and database
│ │  for you in the cloud in a way that is infinitely scalable and uses zero-trust, with a type-safe GraphQL backend and a
│ │  bring-your-own front-end approach with special built-in support for Flutter which is the default setup.
│ │ @@ -70,72 +94,27 @@
│ │  
│ │  So that it doesn't matter what you are building, you can build it on Pysura. It's about damn time that Python developers
│ │  have better mobile support. Let's bring python to mobile. Let's bring python to the web. Let's bring python to the edge.
│ │  Let's bring python everywhere. And let's skin it with Flutter and feed it all the data it wants with GraphQL and Hasura.
│ │  
│ │  Do I have to use Flutter for the frontend? No way! Pysura places firebase in front of your Hasura instance, so if your
│ │  frontend of choice supports Firebase Auth integrations or libraries, you can use it, or even better open a PR and add a
│ │ -template for your provider. You *do* need Flutter for installation
│ │ -
│ │ -What does the Pysura installer do?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ -
│ │ -
│ │ -* Authenticates you with gcloud
│ │ -* Creates a new project in Google Cloud
│ │ -* Sets up a VPC network inside the project
│ │ -* Creates a new Cloud SQL instance running Postgres 14
│ │ -* Stores all Env variables in secret manager to be loaded from containers
│ │ -* Creates a new Hasura instance in Cloud Run with scaling settings always allocating memory for at least 1 instance
│ │ -* Attaches Firebase to the project
│ │ -* Deploys firebase functions triggering on user.create/delete managing Hasura user data each with min instances set to 1
│ │ -* Adds JWT authentication via Firebase to Hasura with phone sign in
│ │ -* Creates a new Flutter app with Firebase Auth using flutterfire
│ │ -* Configures Android signing keys (COMING SOON: Auto app icon configuration)
│ │ -* Configures iOS URL schemes (COMING SOON: Auto app icon configuration)
│ │ -* Updates the default flutter template to use the Pysura template for Flutter 
│ │ -* Deploys the flutter template to Firebase hosting for the web. (COMING SOON: Auto app icon configuration)
│ │ -* Deploys a default microservice on Cloud Run using Pysura! Includes default event that handles JWT claim changes
│ │ +template for your provider.
│ │  
│ │  What is a Pysura Microservice?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  It's a wrapper around a FastAPI app that holds a collection of actions, events, and chron-jobs related to its function.
│ │  I.e. A payment microservice might have all code related to payment processing. It bakes in Auth with an extra decorator
│ │  which gives you easy access to the calling user each time a method is called. This works by using opaque tokens that
│ │  pass through the headers into the microservice. It's a very simple way to do auth, and it's very secure. It gives full
│ │  RBAC at a column level, and you can design rather complex auth rules using Hasura's permission system. Each action,
│ │  event, and chron-job is placed in a separate file with routing already handled and the calling users information passed
│ │  in the calling context. It makes it very easy to build your business logic in a clean, consistent way that is easy to
│ │  test and maintain, and also easy to hand off to other developers.
│ │  
│ │ -Pysura uses middleware to handle the auth, and provide you access to app resources like the database, and the caller.
│ │ -It wraps FastAPI, and uses a router for each action, event, or chron-job. Separating the business logic into collections
│ │ -of microservices each containing folders of actions, events, and chron-jobs each delegated to their own file which 
│ │ -makes it easy to scale and maintain.
│ │ -
│ │ -Front-end clients should utilize the Hasura GraphQL API to access and mutate the data in the database. This is the 
│ │ -recommended way to access the data. It is important to make sure you set up proper roles and permissions in Hasura to
│ │ -ensure that only the correct users can access the data meant for them. By default, Pysura includes a user and admin role
│ │ -
│ │ -Actions are used to allow the front-end client a way to perform custom business logic, or do a task that requires
│ │ -calling third party APIs or services. Actions are called via the Hasura GraphQL API, and are executed on the 
│ │ -microservice instance.
│ │ -
│ │ -Events are used to trigger custom business logic when something occurs in the database. For example, when a user is
│ │ -created, you might want to send them a welcome email. Events are triggered by Hasura (via the Database),
│ │ -and are executed on the microservice instance.
│ │ -
│ │ -Crons are used to trigger custom business logic on a schedule. For example, you might want to send a report to the
│ │ -admin every day at 8am. Crons are triggered by Hasura (via the Database), and are executed on the microservice instance.
│ │ -
│ │ -By default, the application is configured with an event secret that must be passed to all microservices in the header
│ │ -from Hasura. This ensures that all traffic is coming from Hasura, and not from a malicious source. This makes things
│ │ -SUPER secure, with JWT auth, and event secrets. It's a very secure way to build an application.
│ │ -
│ │  Do I need to deploy Hasura with Pysura to use it?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  As of right now yes. In the future, no!
│ │  
│ │  Is this just a wrapper for the Hasura CLI?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ @@ -190,17 +169,14 @@
│ │  
│ │  A: Please open an issue or a feature request. I'm sure I missed some things. Stitching this together required a bit of
│ │  everything, including working outside my area of expertise.
│ │  
│ │  TODOS:
│ │  ^^^^^^
│ │  
│ │ -Remove pyscopg2 dependency to drop postgres req
│ │ -===============================================
│ │ -
│ │  DONE:
│ │  
│ │  
│ │  * [x] Add support for Google Cloud
│ │  * [x] Add support for Firebase Auth
│ │  * [x] Add ios/android wizard
│ │  * [x] Add support for Flutter
│ │ @@ -217,18 +193,24 @@
│ │  * [ ] Add support for other auth providers (Auth0, etc) @Unclaimed
│ │  
│ │    * [ ] Auth0
│ │    * [ ] ???
│ │  
│ │  * [ ] Flutter SSR bindings for Web @Unclaimed
│ │  * [ ] Caching Wizard @Tristen
│ │ +* [ ] Update the pysura/pysura_types/root_cmd.py to make better use of prompt_toolkit. It would be nice to have multiple
│ │ +  tabs for different level of logs. @Unclaimed
│ │  * [ ] Built in API Version Control @Tristen
│ │ +* [ ] Tighten up the command loops. (Ex. Test the deployer and input values that will fail, and make sure it can recover
│ │ +  more gracefully) @Unclaimed
│ │  
│ │  LOW PRIORITY:
│ │  
│ │  
│ │  * [ ] Add support for AWS/Azure/Etc.
│ │  * [ ] Add support for other databases (Postgres, MySQL, BigQuery, etc)
│ │  * [ ] Add support for other frontends (React, Vue, etc)
│ │  * [ ] Rewrite the CLI tool in a more modular way, with command plug-ins.
│ │  * [ ] It should be possible to introspect the entirety of the gcloud CLI by parsing the output of ``gcloud help``. And
│ │    walking the CLI tool This would allow for a more dynamic CLI tool that could be used for other projects.
│ │ +
│ │ +
│ │   --- pysura-0.99.81/pysura/cli/google_root.py
│ ├── +++ pysura-0.99.9/pysura/cli/google_root.py
│ │┄ Files 23% similar despite different names
│ │ @@ -1,104 +1,48 @@
│ │ -# BEWARE OF DRAGONS 🐉
│ │  from pysura.pysura_types.root_cmd import RootCmd
│ │  from pysura.pysura_types.google_pysura_env import *
│ │  import json
│ │  import os
│ │  from pydantic.error_wrappers import ValidationError
│ │  import logging
│ │  import random
│ │  from string import ascii_letters, digits
│ │ +import psycopg2
│ │  import site
│ │  import shutil
│ │  import plistlib
│ │ -from python_graphql_client import GraphqlClient
│ │ -from requests.exceptions import ConnectionError
│ │ -import time
│ │  import re
│ │ -import asyncpg
│ │ -import asyncio
│ │ -
│ │ -
│ │ -class Gql:
│ │ -    GET_USER_ID_BY_PHONE_GQL = """query GetUserIdByPhone($phone_number: String = "") {
│ │ -  user(where: {user_phone: {_eq: $phone_number}}, limit: 1) {
│ │ -    user_id
│ │ -  }
│ │ -}
│ │ -"""
│ │ -
│ │ -    UPDATE_USER_ROLE_GQL = """mutation UpdateUserRole($user_id: String = "", $role: ENUM_ROLE_enum = admin) {
│ │ -  update_user_by_pk(pk_columns: {user_id: $user_id}, _set: {role: $role}) {
│ │ -    user_id
│ │ -  }
│ │ -}
│ │ -"""
│ │  
│ │  
│ │  class GoogleRoot(RootCmd):
│ │  
│ │      def __init__(self, *arg, **kwargs):
│ │          super().__init__(*arg, **kwargs)
│ │          self.intro = "Welcome to Pysura for Google Architectures! Type help or ? to list commands."
│ │          self.prompt = "(pysura_cli) >>> "
│ │ -        self.setup_step = 0
│ │ -        self.graphql_client = None
│ │ -
│ │ -    def get_graphql_client(self):
│ │ -        env = self.get_env()
│ │ -        if env.hasura_service_url is None:
│ │ -            self.log("Hasura service url is not set!", logging.ERROR)
│ │ -            return None
│ │ -        if env.hasura is None or env.hasura.HASURA_GRAPHQL_ADMIN_SECRET is None:
│ │ -            self.log("Hasura admin secret is not set!", logging.ERROR)
│ │ -            return None
│ │ -        graphql_url = f"{env.hasura_service_url}/v1/graphql"
│ │ -        headers = {
│ │ -            "Content-Type": "application/json",
│ │ -            "X-Hasura-Admin-Secret": env.hasura.HASURA_GRAPHQL_ADMIN_SECRET
│ │ -        }
│ │ -        self.graphql_client = GraphqlClient(endpoint=graphql_url, headers=headers)
│ │ -        return self.graphql_client
│ │ -
│ │ -    def execute_graphql(self, gql_str, variables):
│ │ -        response = None
│ │ -        client = self.graphql_client
│ │ -        if client is None:
│ │ -            client = self.get_graphql_client()
│ │ -        try:
│ │ -            response = client.execute(query=gql_str, variables=variables)
│ │ -        except ConnectionError as e:
│ │ -            self.log(str(e), logging.ERROR)
│ │ -            client = self.get_graphql_client()
│ │ -            response = client.execute(query=gql_str, variables=variables)
│ │ -        except Exception as e:
│ │ -            self.log(str(e), logging.ERROR)
│ │ -        finally:
│ │ -            return response
│ │  
│ │      @staticmethod
│ │      def get_site_packages_path(submodule="pysura_auth"):
│ │          return os.path.join(site.getsitepackages()[0], "pysura", "library_data", submodule)
│ │  
│ │      @staticmethod
│ │ -    async def run_sql(host="secret",
│ │ -                      name="postgres",
│ │ -                      user="postgres",
│ │ -                      password="secret",
│ │ -                      port=5432,
│ │ -                      sql=""):
│ │ -        conn = await asyncpg.connect(
│ │ +    def get_database_connection(
│ │ +            host="secret",
│ │ +            name="postgres",
│ │ +            user="postgres",
│ │ +            password="secret",
│ │ +            port=5432):
│ │ +        conn = psycopg2.connect(
│ │              host=host,
│ │              database=name,
│ │              user=user,
│ │              password=password,
│ │              port=port
│ │          )
│ │ -        await conn.execute(sql)
│ │ -        await conn.close()
│ │ +        return conn
│ │  
│ │      @staticmethod
│ │      def password(length: int = 64):
│ │          return "".join(random.choices(ascii_letters + digits, k=length))
│ │  
│ │      @staticmethod
│ │      def get_env(file_name: str = "env.json") -> GooglePysuraEnv:
│ │ @@ -119,25 +63,25 @@
│ │      def gcloud_list_typed_choice(self, command_str, prompt_str, default="name"):
│ │          self.log(command_str, logging.DEBUG)
│ │          response = os.popen(command_str).read()
│ │          gcloud_list = json.loads(response)
│ │          try:
│ │              choice_list = [i[default] for i in gcloud_list]
│ │          except KeyError:
│ │ -            self.log(f"Invalid default: {default}", level=logging.ERROR)
│ │ +            self.log(f"Invalid default: {default}")
│ │              return
│ │          try:
│ │              if len(gcloud_list) > 0:
│ │                  choice = self.collect(prompt_str, choice_list)
│ │                  if choice not in choice_list:
│ │ -                    self.log("Invalid choice.", logging.ERROR)
│ │ +                    self.log("Invalid choice.")
│ │                      return
│ │                  return choice
│ │              else:
│ │ -                self.log("No items found.", logging.ERROR)
│ │ +                self.log("No items found.")
│ │          except Exception as e:
│ │              self.log(str(e), logging.ERROR)
│ │  
│ │      @staticmethod
│ │      def get_env_names(cls):
│ │          cls_name = cls.schema()["title"]
│ │          attr_names = {
│ │ @@ -155,64 +99,63 @@
│ │  
│ │      def gcloud_list_choice(self, command_str, model):
│ │          env_names = self.get_env_names(model)
│ │          self.log(command_str, logging.DEBUG)
│ │          if "--format" not in command_str:
│ │              command_str += " --format=json"
│ │          response = os.popen(command_str).read()
│ │ -        self.log(response, logging.DEBUG)
│ │          gcloud_list = json.loads(response)
│ │          choice = None
│ │          if choice is None:
│ │              for i, gcloud_dict in enumerate(gcloud_list):
│ │ -                self.log(f"\n{i}\t{gcloud_dict.get('name', None)}:\n{json.dumps(gcloud_dict, indent=4)}", logging.INFO)
│ │ +                self.log(f"\n{i}\t{gcloud_dict.get('name', None)}:\n{json.dumps(gcloud_dict, indent=4)}")
│ │              choice = self.collect("Select a number from the list above: ").strip()
│ │              choice = int(choice)
│ │          if choice is not None:
│ │              env_item = gcloud_list[choice]
│ │              try:
│ │                  env_item = model(**env_item)
│ │              except ValidationError:
│ │ -                self.log("The selected item has inconsistent metadata.", logging.ERROR)
│ │ +                self.log("The selected item has inconsistent metadata.")
│ │                  return self.gcloud_list_choice(command_str, model)
│ │              env = self.get_env()
│ │              env[env_names["selected"]] = env_item
│ │              self.set_env(env)
│ │              return env_item, gcloud_list
│ │  
│ │      def do_exit(self, _):
│ │          """
│ │          Exits the application.
│ │          Usage: exit
│ │          """
│ │ -        self.log("Exiting...", level=logging.INFO)
│ │ +        self.log("Exiting...")
│ │          exit(0)
│ │  
│ │      def do_quit(self, _):
│ │          """
│ │          Exits the application.
│ │          Usage: quit
│ │          """
│ │ -        self.log("Exiting...", level=logging.INFO)
│ │ +        self.log("Exiting...")
│ │          exit(0)
│ │  
│ │      def do_gcloud_login(self, check_logged_in=False, auto_advance=True):
│ │          """
│ │          Logs into gcloud.
│ │          Usage: gcloud_login
│ │          """
│ │          if isinstance(check_logged_in, str):
│ │              check_logged_in = False
│ │          if check_logged_in:
│ │              env = self.get_env()
│ │ -            self.log("Checking if already logged into gcloud...", level=logging.INFO)
│ │ +            self.log("Checking if already logged into gcloud...")
│ │              if env.gcloud_logged_in:
│ │ -                self.log("Already logged into gcloud!", level=logging.INFO)
│ │ +                self.log("Already logged into gcloud!")
│ │                  return
│ │ -        self.log("Logging into gcloud...", level=logging.INFO)
│ │ +        self.log("Logging into gcloud...")
│ │          cmd_str = "gcloud auth login"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          if not auto_advance:
│ │              login_success = self.collect("Did you successfully login? (y/n) ")
│ │              if login_success.strip().lower() == "y":
│ │                  env = self.get_env()
│ │ @@ -243,67 +186,51 @@
│ │          env.billing_accounts = billing_accounts
│ │          self.set_env(env)
│ │          cmd_str = f"gcloud beta billing projects link {project_id} " \
│ │                    f"--billing-account={billing_account.name.split('/')[-1]}"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │  
│ │ -    def do_gcloud_shutdown_project(self, _):
│ │ -        """
│ │ -        Shuts down the current project
│ │ -        """
│ │ -        pass
│ │ -
│ │ -    async def async_gcloud_enable_api_services(self):
│ │ -        env = self.get_env()
│ │ -        project_id = env.project.name.split("/")[-1]
│ │ -        services_to_enable = [
│ │ -            "servicenetworking.googleapis.com",
│ │ -            "compute.googleapis.com",
│ │ -            "sqladmin.googleapis.com",
│ │ -            "vpcaccess.googleapis.com",
│ │ -            "identitytoolkit.googleapis.com",
│ │ -            "run.googleapis.com",
│ │ -            "secretmanager.googleapis.com",
│ │ -            "cloudfunctions.googleapis.com",
│ │ -            "cloudbuild.googleapis.com",
│ │ -            "artifactregistry.googleapis.com",
│ │ -            "storage-api.googleapis.com",
│ │ -        ]
│ │ -        await self.enable_services(services_to_enable, project_id)
│ │ -
│ │ -    async def enable_services(self, services: List[str], project_id: str):
│ │ -        tasks = [self.enable_service(service, project_id) for service in services]
│ │ -        await asyncio.gather(*tasks)
│ │ -
│ │ -    async def enable_service(self, service: str, project_id: str):
│ │ -        cmd_str = f"gcloud services enable {service} --project={project_id}"
│ │ -        self.log(cmd_str, level=logging.DEBUG)
│ │ -        await self.run_async_cmd(cmd_str)
│ │ -
│ │ -    async def run_async_cmd(self, cmd: str) -> str:
│ │ -        proc = await asyncio.create_subprocess_shell(
│ │ -            cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
│ │ -        )
│ │ -
│ │ -        stdout, stderr = await proc.communicate()
│ │ -
│ │ -        if proc.returncode != 0:
│ │ -            self.log(f"Command '{cmd}' failed with return code {proc.returncode}", level=logging.ERROR)
│ │ -            self.log(f"Error output: {stderr.decode()}", level=logging.ERROR)
│ │ -        return stdout.decode()
│ │ -
│ │ -    def gcloud_enable_api_services(self):
│ │ +    def do_gcloud_enable_api_services(self, _):
│ │          env = self.get_env()
│ │          if env.project is None:
│ │              self.log("No project selected.")
│ │              return
│ │          self.log("Enabling services...")
│ │ -        asyncio.run(self.async_gcloud_enable_api_services())
│ │          project_id = env.project.name.split("/")[-1]
│ │ +        cmd_str = f"gcloud services enable servicenetworking.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable compute.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable sqladmin.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable vpcaccess.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable identitytoolkit.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable run.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable secretmanager.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable cloudfunctions.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable cloudbuild.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │ +        cmd_str = f"gcloud services enable artifactregistry.googleapis.com --project={project_id}"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        os.system(cmd_str)
│ │          cmd_str = f"gcloud services list --project={project_id} --format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          response = os.popen(cmd_str).read()
│ │          services = json.loads(response)
│ │          env.api_services = services
│ │          self.set_env(env)
│ │  
│ │ @@ -315,25 +242,25 @@
│ │          self.log("Choosing organization...")
│ │          org, orgs = self.gcloud_list_choice("gcloud organizations list --format=json", GoogleOrganization)
│ │          env = self.get_env()
│ │          env.organization = org
│ │          env.organizations = orgs
│ │          self.set_env(env)
│ │  
│ │ -    def gcloud_create_project(self, project_id=""):
│ │ +    def do_gcloud_create_project(self, project_id=""):
│ │          """
│ │          Creates a gcloud project.
│ │          Usage: gcloud_project_create
│ │          """
│ │          env = self.get_env()
│ │          use_organization = self.collect("Do you want to use an organization? (y/n) ")
│ │          use_org = use_organization.strip().lower() == "y"
│ │          if use_org:
│ │              if env.organization is None:
│ │ -                self.log("No organization selected.", level=logging.ERROR)
│ │ +                self.log("No organization selected.")
│ │                  return
│ │          arg_len = len(project_id.strip())
│ │          if arg_len == 0:
│ │              project_name = self.collect("Enter a project name: ")
│ │          else:
│ │              project_name = project_id
│ │          if arg_len > 0 or self.confirm_loop(project_name):
│ │ @@ -349,43 +276,50 @@
│ │              projects = json.loads(response)
│ │              project = None
│ │              for p in projects:
│ │                  project_data = GoogleProject(**p)
│ │                  if project_data.name.split("/")[-1] == project_name:
│ │                      project = GoogleProject(**p)
│ │                      break
│ │ -            if project is None:
│ │ -                time.sleep(1)
│ │ -                cmd_str = f"gcloud projects list --format=json"
│ │ -                self.log(cmd_str, level=logging.DEBUG)
│ │ -                response = os.popen(cmd_str).read()
│ │ -                projects = json.loads(response)
│ │ -                for p in projects:
│ │ -                    project_data = GoogleProject(**p)
│ │ -                    if project_data.name.split("/")[-1] == project_name:
│ │ -                        project = GoogleProject(**p)
│ │ -                        break
│ │              assert project is not None
│ │              cmd_str = f"gcloud config set project {project.name.split('/')[-1]}"
│ │              self.log(cmd_str, level=logging.DEBUG)
│ │              os.system(cmd_str)
│ │              env.project = project
│ │              env.projects = projects
│ │              self.set_env(env)
│ │          else:
│ │ -            self.user_input_no_loop(self.gcloud_create_project)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_project)
│ │  
│ │ -    def gcloud_create_network(self, network_id=""):
│ │ +    def do_gcloud_choose_project(self, _):
│ │ +        """
│ │ +        Chooses a project.
│ │ +        Usage: gcloud_choose_project
│ │ +        """
│ │ +        env = self.get_env()
│ │ +        if not env.gcloud_logged_in:
│ │ +            self.do_gcloud_login()
│ │ +        self.log("Choosing project...")
│ │ +        project, projects = self.gcloud_list_choice("gcloud projects list --format=json", GoogleProject)
│ │ +        env.project = project
│ │ +        env.projects = projects
│ │ +        self.set_env(env)
│ │ +        if project is not None:
│ │ +            cmd_str = f"gcloud config set project {project.name.split('/')[-1]}"
│ │ +            self.log(cmd_str, level=logging.DEBUG)
│ │ +            os.system(cmd_str)
│ │ +
│ │ +    def do_gcloud_create_network(self, network_id=""):
│ │          """
│ │          Creates a Network.
│ │          Usage: gcloud_network_create
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          arg_len = len(network_id.strip())
│ │          if arg_len == 0:
│ │              network_name = self.collect("Enter a network name: ")
│ │          else:
│ │              network_name = network_id
│ │          if arg_len > 0 or self.confirm_loop(network_name):
│ │ @@ -393,15 +327,15 @@
│ │                        f" --subnet-mode=auto" \
│ │                        f" --project={env.project.name.split('/')[-1]}"
│ │              self.log(cmd_str, level=logging.DEBUG)
│ │              os.system(cmd_str)
│ │              cmd_str = f"gcloud compute networks list " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--format=json"
│ │ -            gcloud_list = self.gcloud_retry_loop(cmd_str, network_name)
│ │ +            gcloud_list = self.retry_loop(cmd_str, network_name)
│ │              network_selected = None
│ │              network_set = []
│ │              for gcloud_item in gcloud_list:
│ │                  network = GoogleNetwork(
│ │                      **gcloud_item
│ │                  )
│ │                  network_set.append(network)
│ │ @@ -411,27 +345,44 @@
│ │              if network_selected is None:
│ │                  self.log("Network not found.")
│ │                  return
│ │              env.network = network_selected
│ │              env.networks = network_set
│ │              self.set_env(env)
│ │          else:
│ │ -            self.user_input_no_loop(self.gcloud_create_network)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_network)
│ │  
│ │ -    def gcloud_create_address(self, address_id=""):
│ │ +    def do_gcloud_choose_network(self, _):
│ │ +        """
│ │ +        Chooses a Network.
│ │ +        Usage: gcloud_network_choose
│ │ +        """
│ │ +        env = self.get_env()
│ │ +        if env.project is None:
│ │ +            self.log("No project selected.")
│ │ +            return
│ │ +        self.log("Choosing network...")
│ │ +        network, networks = self.gcloud_list_choice(f"gcloud compute networks list "
│ │ +                                                    f"--project={env.project.name.split('/')[-1]} "
│ │ +                                                    f"--format=json", GoogleNetwork)
│ │ +        env.network = network
│ │ +        env.networks = networks
│ │ +        self.set_env(env)
│ │ +
│ │ +    def do_gcloud_create_address(self, address_id=""):
│ │          """
│ │          Creates an address.
│ │          Usage: gcloud_address_create
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │          arg_len = len(address_id.strip())
│ │          if arg_len == 0:
│ │              address_name = self.collect("Enter an address name: ")
│ │          else:
│ │              address_name = address_id
│ │          if arg_len > 0 or self.confirm_loop(address_name):
│ │ @@ -442,50 +393,70 @@
│ │                        f"--network={env.network.name.split('/')[-1]} " \
│ │                        f"--project={env.project.name.split('/')[-1]}"
│ │              self.log(cmd_str, level=logging.DEBUG)
│ │              os.system(cmd_str)
│ │              cmd_str = f"gcloud compute addresses list " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--format=json"
│ │ -            gcloud_list = self.gcloud_retry_loop(cmd_str, address_name)
│ │ +            gcloud_list = self.retry_loop(cmd_str, address_name)
│ │              address_selected = None
│ │              address_set = []
│ │              for gcloud_item in gcloud_list:
│ │                  address = GoogleAddress(
│ │                      **gcloud_item
│ │                  )
│ │                  address_set.append(address)
│ │                  if address.name.split('/')[-1] == address_name:
│ │                      address_selected = address
│ │              if address_selected is None:
│ │ -                self.log("Address not found.", level=logging.ERROR)
│ │ +                self.log("Address not found.")
│ │                  return
│ │              env.address = address_selected
│ │              env.addresses = address_set
│ │              self.set_env(env)
│ │              if address_selected is None:
│ │ -                self.log("Address not found.", level=logging.ERROR)
│ │ +                self.log("Address not found.")
│ │                  return
│ │          else:
│ │ -            self.user_input_no_loop(self.gcloud_create_address)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_address)
│ │ +
│ │ +    def do_gcloud_choose_address(self, _):
│ │ +        """
│ │ +        Chooses an address.
│ │ +        Usage: gcloud_address_choose
│ │ +        """
│ │ +        env = self.get_env()
│ │ +        if env.project is None:
│ │ +            self.log("No project selected.")
│ │ +            return
│ │ +        if env.network is None:
│ │ +            self.log("No network selected.")
│ │ +            return
│ │ +        self.log("Choosing address...")
│ │ +        address, addresses = self.gcloud_list_choice(f"gcloud compute addresses list "
│ │ +                                                     f"--project={env.project.name.split('/')[-1]} "
│ │ +                                                     f"--format=json", GoogleAddress)
│ │ +        env.address = address
│ │ +        env.addresses = addresses
│ │ +        self.set_env(env)
│ │  
│ │ -    def gcloud_create_vpc_peering(self, peering_id=""):
│ │ +    def do_gcloud_create_vpc_peering(self, peering_id=""):
│ │          """
│ │          Creates a VPC Peering.
│ │          Usage: gcloud_vpc_peering_create
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │          if env.address is None:
│ │ -            self.log("No address selected.", level=logging.ERROR)
│ │ +            self.log("No address selected.")
│ │              return
│ │  
│ │          arg_len = len(peering_id.strip())
│ │          if arg_len == 0:
│ │              peering_name = self.collect("Enter a peering name: ")
│ │          else:
│ │              peering_name = peering_id
│ │ @@ -496,157 +467,131 @@
│ │                        f"--network={env.network.name.split('/')[-1]} " \
│ │                        f"--project={env.project.name.split('/')[-1]}"
│ │              self.log(cmd_str, level=logging.DEBUG)
│ │              os.system(cmd_str)
│ │              cmd_str = f"gcloud services vpc-peerings list " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--network={env.network.name.split('/')[-1]} --format=json"
│ │ -            gcloud_list = self.gcloud_retry_loop(cmd_str, peering_name)
│ │ +            gcloud_list = self.retry_loop(cmd_str, peering_name)
│ │              peering_selected = None
│ │              peering_set = []
│ │              for peering in gcloud_list:
│ │                  peering_data = GoogleVpcPeering(
│ │                      **peering
│ │                  )
│ │                  peering_set.append(peering_data)
│ │                  if peering_name in peering_data.reservedPeeringRanges:
│ │                      peering_selected = peering_data
│ │              if peering_selected is None:
│ │ -                self.log("Peering not found.", level=logging.ERROR)
│ │ +                self.log("Peering not found.")
│ │                  return
│ │              env.peering = peering_selected
│ │              env.peerings = peering_set
│ │              self.set_env(env)
│ │          else:
│ │ -            self.user_input_no_loop(self.gcloud_create_vpc_peering)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_vpc_peering)
│ │  
│ │ -    async def async_gcloud_create_firewall(self, firewall_id=""):
│ │ +    def do_gcloud_choose_vpc_peering(self, _):
│ │ +        """
│ │ +        Chooses a VPC Peering.
│ │ +        Usage: gcloud_vpc_peering_choose
│ │ +        """
│ │          env = self.get_env()
│ │ -        project_id = env.project.name.split("/")[-1]
│ │ -
│ │ +        if env.project is None:
│ │ +            self.log("No project selected.")
│ │ +            return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │ -
│ │ -        firewall_name = firewall_id.strip() or self.collect("Enter a firewall name: ")
│ │ -
│ │ -        if len(firewall_id) > 0 or self.confirm_loop(firewall_name):
│ │ -            firewall_rules = [
│ │ -                {
│ │ -                    "name": f"{firewall_name}-allow-traffic",
│ │ -                    "allow": "tcp,udp,icmp",
│ │ -                    "source_ranges": "0.0.0.0/0",
│ │ -                },
│ │ -                {
│ │ -                    "name": f"{firewall_name}-allow-ssh",
│ │ -                    "allow": "tcp:22,tcp:3389,icmp",
│ │ -                },
│ │ -            ]
│ │ -            await self.create_firewall_rules(firewall_rules, project_id, env.network.name.split('/')[-1])
│ │ -
│ │ -            cmd_str = f"gcloud compute firewall-rules list --project={project_id} --format=json"
│ │ -            self.log(cmd_str, level=logging.DEBUG)
│ │ -            gcloud_list = json.loads(await self.run_async_cmd(cmd_str))
│ │ -            firewall_set = []
│ │ -            for firewall in gcloud_list:
│ │ -                firewall_data = GoogleFirewall(
│ │ -                    **firewall
│ │ -                )
│ │ -                firewall_set.append(firewall_data)
│ │ -            env.firewalls = firewall_set
│ │ -            self.set_env(env)
│ │ -        else:
│ │ -            self.user_input_no_loop(self.async_gcloud_create_firewall)
│ │ -
│ │ -    async def create_firewall_rules(self, firewall_rules: List[dict], project_id: str, network_name: str):
│ │ -        tasks = [self.create_firewall_rule(rule, project_id, network_name) for rule in firewall_rules]
│ │ -        await asyncio.gather(*tasks)
│ │ -
│ │ -    async def create_firewall_rule(self, rule: dict, project_id: str, network_name: str):
│ │ -        cmd_str = (
│ │ -            f"gcloud compute firewall-rules create {rule['name']} "
│ │ -            f"--network={network_name} "
│ │ -            f"--allow={rule['allow']} "
│ │ +        if env.address is None:
│ │ +            self.log("No address selected.")
│ │ +            return
│ │ +        self.log("Choosing peering...")
│ │ +        peering, peerings = self.gcloud_list_choice(
│ │ +            f"gcloud services vpc-peerings list "
│ │ +            f"--project={env.project.name.split('/')[-1]} "
│ │ +            f"--network={env.network.name.split('/')[-1]} --format=json",
│ │ +            GoogleVpcPeering
│ │          )
│ │ -        if "source_ranges" in rule:
│ │ -            cmd_str += f"--source-ranges={rule['source_ranges']} "
│ │ -        cmd_str += f"--project={project_id}"
│ │ -        self.log(cmd_str, level=logging.DEBUG)
│ │ -        await self.run_async_cmd(cmd_str)
│ │ +        env.peering = peering
│ │ +        env.peerings = peerings
│ │ +        self.set_env(env)
│ │  
│ │ -    def gcloud_create_firewall(self, firewall_id=""):
│ │ +    def do_gcloud_create_firewall(self, firewall_id=""):
│ │          """
│ │          Creates a firewall.
│ │          Usage: gcloud_firewall_create
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │          if env.address is None:
│ │ -            self.log("No address selected.", level=logging.ERROR)
│ │ +            self.log("No address selected.")
│ │              return
│ │          if env.peering is None:
│ │ -            self.log("No peering selected.", level=logging.ERROR)
│ │ +            self.log("No peering selected.")
│ │              return
│ │  
│ │          arg_len = len(firewall_id.strip())
│ │          if arg_len == 0:
│ │              firewall_name = self.collect("Enter a firewall name: ")
│ │          else:
│ │              firewall_name = firewall_id
│ │          if arg_len > 0 or self.confirm_loop(firewall_name):
│ │ -            asyncio.run(self.async_gcloud_create_firewall(firewall_name))
│ │ +            cmd_str = f"gcloud compute firewall-rules create {firewall_name}-allow-traffic  " \
│ │ +                      f"--network={env.network.name.split('/')[-1]} " \
│ │ +                      f"--allow=tcp,udp,icmp " \
│ │ +                      f"--source-ranges=0.0.0.0/0 " \
│ │ +                      f"--project={env.project.name.split('/')[-1]}"
│ │ +            self.log(cmd_str, level=logging.DEBUG)
│ │ +            os.system(cmd_str)
│ │ +            cmd_str = f"gcloud compute firewall-rules list " \
│ │ +                      f"--project={env.project.name.split('/')[-1]} " \
│ │ +                      f"--format=json"
│ │ +            self.retry_loop(cmd_str, f"{firewall_name}-allow-traffic")
│ │ +            cmd_str = f"gcloud compute firewall-rules create {firewall_name}-allow-ssh  " \
│ │ +                      f"--network={env.network.name.split('/')[-1]} " \
│ │ +                      f"--allow=tcp:22,tcp:3389,icmp " \
│ │ +                      f"--project={env.project.name.split('/')[-1]}"
│ │ +            self.log(cmd_str, level=logging.DEBUG)
│ │ +            os.system(cmd_str)
│ │              cmd_str = f"gcloud compute firewall-rules list " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--format=json"
│ │              self.log(cmd_str, level=logging.DEBUG)
│ │              gcloud_list = json.loads(os.popen(cmd_str).read())
│ │              firewall_set = []
│ │              for firewall in gcloud_list:
│ │                  firewall_data = GoogleFirewall(
│ │                      **firewall
│ │                  )
│ │                  firewall_set.append(firewall_data)
│ │              env.firewalls = firewall_set
│ │              self.set_env(env)
│ │          else:
│ │ -            self.user_input_no_loop(self.gcloud_create_firewall)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_firewall)
│ │  
│ │      def do_gcloud_create_database(self,
│ │                                    database_id="",
│ │                                    cpu_default="2",
│ │                                    memory_default="8192",
│ │                                    db_version_default="POSTGRES_14",
│ │                                    zone_default="us-central1-b",
│ │                                    availability_type_default="regional",
│ │                                    auto_advance=True):
│ │ -        """
│ │ -        Creates a database.
│ │ -        :param database_id: The name for the database
│ │ -        :param cpu_default: The number of CPU's for the database
│ │ -        :param memory_default: The amount of RAM for the database
│ │ -        :param db_version_default: The version of the database
│ │ -        :param zone_default: The zone to create the database in
│ │ -        :param availability_type_default:  The type of availability for the database
│ │ -        :param auto_advance: Whether to automatically advance to the creation step
│ │ -
│ │ -
│ │ -        Usage: gcloud_create_database database_id
│ │ -        Example: gcloud_create_database my-database 2 8192 POSTGRES_14 us-central1-b regional True
│ │ -        """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │  
│ │          arg_len = len(database_id.strip())
│ │          if arg_len == 0:
│ │              db_name = self.collect("Enter a database name: ")
│ │          else:
│ │              db_name = database_id
│ │ @@ -675,21 +620,21 @@
│ │          if len(zone_default.strip()) == 0:
│ │              zone = self.gcloud_list_typed_choice(f"gcloud compute zones list "
│ │                                                   f"--project={env.project.name.split('/')[-1]} "
│ │                                                   f"--format=json", "Enter a zone (Ex. us-central1-b): ", "name")
│ │          else:
│ │              zone = zone_default
│ │          if zone is None:
│ │ -            self.log("No zone selected.", level=logging.ERROR)
│ │ +            self.log("No zone selected.")
│ │              return
│ │          if len(availability_type_default.strip()) == 0:
│ │              availability_types = ["regional", "zonal"]
│ │              availability_type = self.collect("Enter the availability type (regional/zonal): ", availability_types)
│ │              if availability_type not in availability_types:
│ │ -                self.log("Invalid availability type.", level=logging.ERROR)
│ │ +                self.log("Invalid availability type.")
│ │                  return
│ │          else:
│ │              availability_type = availability_type_default
│ │          db_password = self.password()
│ │          self.log(f"You are preparing to create a database with the following parameters: "
│ │                   f"Name: {db_name}, CPU's: {cpu_number}, Memory: {memory_amount}, "
│ │                   f"Version: {db_version}, Zone: {zone}, "
│ │ @@ -713,27 +658,27 @@
│ │              f"--enable-google-private-path"
│ │          )
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          cmd_str = f"gcloud sql instances list " \
│ │                    f"--project={env.project.name.split('/')[-1]} " \
│ │                    f"--format=json"
│ │ -        gcloud_list = self.gcloud_retry_loop(cmd_str, f"{db_name}")
│ │ +        gcloud_list = self.retry_loop(cmd_str, f"{db_name}")
│ │          db_selected = None
│ │          db_set = []
│ │          for db_instance in gcloud_list:
│ │              db_data = GoogleDatabase(
│ │                  **db_instance
│ │              )
│ │              db_set.append(db_data)
│ │              if db_data.name.split('/')[-1] == db_name:
│ │                  db_selected = db_data
│ │  
│ │          if db_selected is None:
│ │ -            self.log("Database not found.", level=logging.ERROR)
│ │ +            self.log("Database not found.")
│ │              return
│ │  
│ │          db_creds = DatabaseCredential()
│ │          db_creds.database_id = db_name
│ │          db_creds.password = db_password
│ │          private_address = None
│ │          for addr in db_selected.ipAddresses:
│ │ @@ -750,87 +695,87 @@
│ │              env.database_credential = db_creds
│ │          if env.database_credentials is None:
│ │              env.database_credentials = [db_creds]
│ │          else:
│ │              env.database_credentials.append(db_creds)
│ │          self.set_env(env)
│ │  
│ │ -    def gcloud_create_serverless_connector(self,
│ │ -                                           connector_id="",
│ │ -                                           range_default="10.8.0.0/28"):
│ │ +    def do_gcloud_create_serverless_connector(self,
│ │ +                                              connector_id="",
│ │ +                                              range_default="10.8.0.0/28"):
│ │          """
│ │          Creates a serverless connector.
│ │          Usage: create_serverless_connector
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │          if env.database is None:
│ │ -            self.log("No database selected.", level=logging.ERROR)
│ │ +            self.log("No database selected.")
│ │              return
│ │  
│ │          if len(range_default.strip()) == 0:
│ │              range_choice = self.collect("Select a range (Ex. 10.8.0.0/28): ", [f"10.{i}.0.0/28" for i in range(8, 100)])
│ │              arg_len = len(connector_id.split())
│ │          else:
│ │              range_choice = range_default
│ │              arg_len = len(connector_id.split())
│ │          if arg_len == 0:
│ │              connector_name = self.collect("Enter a connector name: ")
│ │          else:
│ │              connector_name = connector_id
│ │          if arg_len == 0 and not self.confirm_loop(connector_name):
│ │ -            self.user_input_no_loop(self.gcloud_create_serverless_connector)
│ │ +            self.user_input_no_loop(self.do_gcloud_create_serverless_connector)
│ │              return
│ │          cmd_str = f"gcloud compute networks vpc-access connectors create {connector_name} " \
│ │                    f"--network={env.network.name.split('/')[-1]} " \
│ │                    f"--region={env.database.region} " \
│ │                    f"--range={range_choice} " \
│ │                    f"--project={env.project.name.split('/')[-1]}"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          cmd_str = f"gcloud compute networks vpc-access connectors list " \
│ │                    f"--project={env.project.name.split('/')[-1]} " \
│ │                    f"--region={env.database.region} --format=json"
│ │ -        gcloud_list = self.gcloud_retry_loop(cmd_str, f"{connector_name}")
│ │ +        gcloud_list = self.retry_loop(cmd_str, f"{connector_name}")
│ │          connector_selected = None
│ │          connector_set = []
│ │          for connector in gcloud_list:
│ │              connector_data = GoogleConnector(
│ │                  **connector
│ │              )
│ │              connector_set.append(connector_data)
│ │              if connector_data.name.split("/")[-1] == connector_name:
│ │                  connector_selected = connector_data
│ │  
│ │          if connector_selected is None:
│ │ -            self.log("Connector not found.", level=logging.ERROR)
│ │ +            self.log("Connector not found.")
│ │              return
│ │          env.connector = connector_selected
│ │          env.connectors = connector_set
│ │          self.set_env(env)
│ │  
│ │ -    def gcloud_choose_serverless_connector(self):
│ │ +    def do_gcloud_choose_serverless_connector(self, _):
│ │          """
│ │          Chooses a serverless connector.
│ │          Usage: choose_serverless_connector
│ │          """
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.network is None:
│ │ -            self.log("No network selected.", level=logging.ERROR)
│ │ +            self.log("No network selected.")
│ │              return
│ │          if env.database is None:
│ │ -            self.log("No database selected.", level=logging.ERROR)
│ │ +            self.log("No database selected.")
│ │              return
│ │  
│ │          cmd_str = f"gcloud compute networks vpc-access connectors list " \
│ │                    f"--region={env.database.region} " \
│ │                    f"--project={env.project.name.split('/')[-1]} --format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          response = os.popen(cmd_str).read()
│ │ @@ -842,15 +787,15 @@
│ │                  **connector
│ │              )
│ │              connector_set.append(connector_data)
│ │              if connector_data.name.split("/")[-1] == env.connector.name.split('/')[-1]:
│ │                  connector_selected = connector_data
│ │  
│ │          if connector_selected is None:
│ │ -            self.log("Connector not found.", level=logging.ERROR)
│ │ +            self.log("Connector not found.")
│ │              return
│ │  
│ │          env.connector = connector_selected
│ │          env.connectors = connector_set
│ │          self.set_env(env)
│ │  
│ │      def do_gcloud_set_secret(self, secret_key, secret_value):
│ │ @@ -880,91 +825,78 @@
│ │          else:
│ │              cmd_str = f"gcloud secrets versions add {secret_key} " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--data-file=secret"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          os.remove("secret")
│ │ -        secrets = self.gcloud_retry_loop(f"gcloud secrets list --project={env.project.name.split('/')[-1]} "
│ │ -                                         f"--format=json",
│ │ -                                         f"{secret_key}")
│ │ +        secrets = self.retry_loop(f"gcloud secrets list --project={env.project.name.split('/')[-1]} --format=json",
│ │ +                                  f"{secret_key}")
│ │          secret_selected = None
│ │          secret_set = []
│ │          for secret in secrets:
│ │              secret_data = GoogleSecret(
│ │                  **secret
│ │              )
│ │              secret_set.append(secret_data)
│ │              if secret_data.name.split("/")[-1] == secret_key:
│ │                  secret_selected = secret_data
│ │          if secret_selected is None:
│ │ -            self.log("Secret not found.", level=logging.ERROR)
│ │ +            self.log("Secret not found.")
│ │              return
│ │          env.secrets = secret_set
│ │          self.set_env(env)
│ │  
│ │ -    def update_default_compute_engine_service_account(self):
│ │ +    def do_update_default_compute_engine_service_account(self, _):
│ │          env = self.get_env()
│ │          account_choices = json.loads(os.popen(f"gcloud iam service-accounts list "
│ │                                                f"--project={env.project.name.split('/')[-1]} "
│ │                                                f"--format=json").read())
│ │ -        self.log(account_choices, level=logging.DEBUG)
│ │          service_accounts = []
│ │          for i, account in enumerate(account_choices):
│ │              account_data = GoogleServiceAccount(**account)
│ │              if account_data.displayName == "Compute Engine default service account":
│ │                  env.hasura_service_account = account_data
│ │              service_accounts.append(account_data)
│ │          if env.hasura_service_account is None:
│ │ -            account_choices = json.loads(os.popen(f"gcloud iam service-accounts list "
│ │ -                                                  f"--project={env.project.name.split('/')[-1]} "
│ │ -                                                  f"--format=json").read())
│ │ -            self.log(account_choices, level=logging.DEBUG)
│ │ -            service_accounts = []
│ │ -            for i, account in enumerate(account_choices):
│ │ -                account_data = GoogleServiceAccount(**account)
│ │ -                if account_data.displayName == "Compute Engine default service account":
│ │ -                    env.hasura_service_account = account_data
│ │ -                service_accounts.append(account_data)
│ │ -        if env.hasura_service_account is None:
│ │ -            self.log("No service account found.", level=logging.ERROR)
│ │ +            self.log("No service account found.")
│ │              return
│ │          env.service_accounts = service_accounts
│ │          cmd_log_str = (f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} "
│ │                         f"--member=serviceAccount:{env.hasura_service_account.email} "
│ │                         f"--role=roles/cloudbuild.builds.builder "
│ │                         f"--format=json"
│ │                         )
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_log_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_log_str).read()
│ │          cmd_log_str = (f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} "
│ │                         f"--member=serviceAccount:{env.hasura_service_account.email} "
│ │                         f"--role=roles/run.admin "
│ │                         f"--format=json"
│ │                         )
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_log_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_log_str).read()
│ │          cmd_log_str = (f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} "
│ │                         f"--member=serviceAccount:{env.hasura_service_account.email} "
│ │                         f"--role=roles/secretmanager.secretAccessor "
│ │                         f"--format=json"
│ │                         )
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_log_str).read(), level=logging.DEBUG)
│ │ -        self.set_env(env)
│ │ +        os.popen(cmd_log_str).read()
│ │  
│ │      def do_gcloud_deploy_hasura(self, timeout_default="600s", memory_default="2Gi", max_instances_default="10"):
│ │          env = self.get_env()
│ │          if env.project is None:
│ │ -            self.log("No project selected.", level=logging.ERROR)
│ │ +            self.log("No project selected.")
│ │              return
│ │          if env.connector is None:
│ │ -            self.log("No connector selected.", level=logging.ERROR)
│ │ +            self.log("No connector selected.")
│ │              return
│ │          if env.hasura is None:
│ │ +            self.do_update_default_compute_engine_service_account(None)
│ │              cmd_log_str = "docker pull --platform=linux/amd64 hasura/graphql-engine:latest"
│ │              self.log(cmd_log_str, level=logging.DEBUG)
│ │              os.system(cmd_log_str)
│ │              cmd_log_str = f"docker tag hasura/graphql-engine:latest " \
│ │                            f"gcr.io/{env.project.name.split('/')[-1]}/hasura:latest"
│ │              self.log(cmd_log_str, level=logging.DEBUG)
│ │              os.system(cmd_log_str)
│ │ @@ -982,28 +914,22 @@
│ │              else:
│ │                  memory = memory_default
│ │              if len(max_instances_default.strip()) == 0:
│ │                  max_instances = self.collect("Max instances (Ex. 10): ")
│ │              else:
│ │                  max_instances = max_instances_default
│ │              hasura_event_secret = self.password()
│ │ -            hasura_storage_bucket = f"{env.project.name.split('/')[-1]}-hasura-storage-{int(time.time())}"
│ │ -            cmd_str = f"gcloud storage buckets create gs://{hasura_storage_bucket} " \
│ │ -                      f"--project={env.project.name.split('/')[-1]}"
│ │ -            self.log(cmd_str, level=logging.DEBUG)
│ │ -            os.system(cmd_str)
│ │              hasura = Hasura(
│ │                  HASURA_GRAPHQL_CORS_DOMAIN="*",
│ │                  HASURA_GRAPHQL_ENABLED_CORS="true",
│ │                  HASURA_GRAPHQL_ENABLE_CONSOLE="true",
│ │                  HASURA_GRAPHQL_ADMIN_SECRET=hasura_secret,
│ │                  HASURA_GRAPHQL_DATABASE_URL=env.database_credential.connect_url,
│ │                  HASURA_GRAPHQL_METADATA_DATABASE_URL=env.database_credential.connect_url,
│ │                  HASURA_EVENT_SECRET=hasura_event_secret,
│ │ -                HASURA_STORAGE_BUCKET=hasura_storage_bucket,
│ │                  vpc_connector=env.connector.name.split('/')[-1],
│ │                  timeout=timeout,
│ │                  project_id=env.project.name.split('/')[-1],
│ │                  cpu="1",
│ │                  memory=memory,
│ │                  min_instances="1",
│ │                  max_instances=max_instances
│ │ @@ -1050,16 +976,14 @@
│ │                            f"--timeout=600s "
│ │                            f"--platform=managed "
│ │                            f"--allow-unauthenticated "
│ │                            f"--no-cpu-throttling "
│ │                            f"--project={env.project.name.split('/')[-1]}")
│ │          deploy_command += secret_text
│ │          self.log(deploy_command, level=logging.DEBUG)
│ │ -        with open("deploy.txt", "w") as f:
│ │ -            f.write(deploy_command)
│ │          os.system(deploy_command)
│ │          services = json.loads(os.popen(f"gcloud run services list "
│ │                                         f"--project={env.project.name.split('/')[-1]} "
│ │                                         f"--format=json").read())
│ │          new_services = []
│ │          for service in services:
│ │              service_data = GoogleService(**service)
│ │ @@ -1067,14 +991,15 @@
│ │                  env.hasura_service = service_data
│ │                  env.hasura_service_url = service_data.status.url
│ │                  env.hasura.HASURA_GRAPHQL_URL_ROOT = f"{service_data.status.url}/v1/graphql"
│ │                  self.do_gcloud_set_secret("HASURA_GRAPHQL_URL_ROOT", env.hasura.HASURA_GRAPHQL_URL_ROOT)
│ │              new_services.append(service_data)
│ │          env.services = new_services
│ │          self.set_env(env)
│ │ +        self.do_import_hasura_metadata(None)
│ │  
│ │      def do_set_hasura_service_url(self, service_url):
│ │          """
│ │          Sets the service URL for Hasura.
│ │          Usage: set_hasura_metadata_url <service_url>
│ │          Example: set_hasura_metadata_url https://hasura-1234567-uc.a.run.app
│ │          """
│ │ @@ -1104,63 +1029,57 @@
│ │      def do_import_hasura_metadata(self, _):
│ │          """
│ │          Imports Hasura metadata.
│ │          Usage: import_hasura_metadata
│ │          """
│ │          env = self.get_env()
│ │          if env.hasura_service_url is None:
│ │ -            self.log("No metadata URL set. Please set one with set_hasura_metadata_url.", level=logging.ERROR)
│ │ +            self.log("No metadata URL set. Please set one with set_hasura_metadata_url.")
│ │              return
│ │          if env.hasura_admin_secret is None:
│ │ -            self.log("No admin secret set. Please set one with set_hasura_admin_secret.", level=logging.ERROR)
│ │ +            self.log("No admin secret set. Please set one with set_hasura_admin_secret.")
│ │              return
│ │          metadata_url = env.hasura_service_url + "/v1/metadata"
│ │          cmd_str = f"""curl -d'{{"type": "export_metadata", "args": {{}}}}' {metadata_url} -H "X-Hasura-Admin-Secret: {
│ │          env.hasura_admin_secret}" -o hasura_metadata.json"""
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │  
│ │      def do_export_hasura_metadata(self, _):
│ │          self.log("Exporting Hasura metadata...")
│ │          env = self.get_env()
│ │          if env.hasura_service_url is None:
│ │ -            self.log("No metadata URL set. Please set one with set_hasura_metadata_url.", level=logging.ERROR)
│ │ +            self.log("No metadata URL set. Please set one with set_hasura_metadata_url.")
│ │              return
│ │          if env.hasura_admin_secret is None:
│ │ -            self.log("No admin secret set. Please set one with set_hasura_admin_secret.", level=logging.ERROR)
│ │ +            self.log("No admin secret set. Please set one with set_hasura_admin_secret.")
│ │              return
│ │          metadata_url = env.hasura_service_url + "/v1/metadata"
│ │          with open("hasura_metadata.json", "r") as f:
│ │              json_data = json.load(f)
│ │          hasura_metadata = HasuraMetadata(**json_data)
│ │          json_data = json.dumps(json_data)
│ │          cmd_str = f"""curl -d'{{"type": "replace_metadata", "args": {json_data}}}' {metadata_url} -H """ + \
│ │                    f'''"X-Hasura-Admin-Secret: {env.hasura_admin_secret}"'''
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        response = json.loads(os.popen(cmd_str).read())
│ │ -        retry_count = 0
│ │ -        while response.get("message", None) != "success" and retry_count < 5:
│ │ -            time.sleep(3 * retry_count)
│ │ -            response = json.loads(os.popen(cmd_str).read())
│ │ -            retry_count += 1
│ │ -
│ │ +        os.system(cmd_str)
│ │          env.hasura_metadata = hasura_metadata
│ │          self.set_env(env)
│ │  
│ │ -    def gcloud_interactive(self):
│ │ +    def do_gcloud_interactive(self, _):
│ │          """
│ │          Starts an interactive gcloud shell.
│ │          Usage: gcloud_interactive
│ │          """
│ │          self.log("Starting gcloud interactive shell...")
│ │          cmd_str = "gcloud beta interactive"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │  
│ │ -    def enable_database_local(self, database_id=""):
│ │ +    def do_enable_database_local(self, database_id=""):
│ │          env = self.get_env()
│ │          if env.database is None:
│ │              self.log("No database set.")
│ │              return
│ │          if database_id == "":
│ │              if env.database is None:
│ │                  self.log("No database selected.")
│ │ @@ -1173,45 +1092,48 @@
│ │              if db.name.split("/")[-1] == database_id:
│ │                  db_instance = db
│ │              if db_creds.database_id.split("/")[-1] == database_id:
│ │                  db_credentials = db_creds
│ │              if db_instance is not None and db_credentials is not None:
│ │                  break
│ │          if db_instance is None or db_credentials is None:
│ │ -            self.log("Invalid database id.", level=logging.ERROR)
│ │ +            self.log("Invalid database id.")
│ │              return
│ │          cmd_str = "curl ifconfig.me"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          ip_address = os.popen(cmd_str).read().strip()
│ │          self.log(f"Your IP address is {ip_address}.")
│ │          cmd_str = cmd_log_str = (f"gcloud sql instances patch {db_instance.name.split('/')[-1]} "
│ │                                   f"--authorized-networks={ip_address}")
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │ -        env.local_database_enabled = True
│ │ -        self.set_env(env)
│ │  
│ │ -    def create_default_user_table(self):
│ │ +    def do_create_default_user_table(self, _):
│ │          env = self.get_env()
│ │          if env.database is None:
│ │ -            self.log("No database set.", level=logging.ERROR)
│ │ +            self.log("No database set.")
│ │              return
│ │          if env.database_credentials is None:
│ │ -            self.log("No database credentials set.", level=logging.ERROR)
│ │ +            self.log("No database credentials set.")
│ │              return
│ │  
│ │          host = None
│ │          for ip_addr in env.database.ipAddresses:
│ │              if ip_addr.type == "PRIMARY":
│ │                  host = ip_addr.ipAddress
│ │  
│ │          if host is None:
│ │ -            self.log("No primary IP address found.", level=logging.ERROR)
│ │ +            self.log("No primary IP address found.")
│ │              return
│ │  
│ │ +        conn = self.get_database_connection(
│ │ +            host=host,
│ │ +            password=env.database_credential.password
│ │ +        )
│ │ +
│ │          db_string = """create table "ENUM_ROLE"
│ │  (
│ │      value   text not null,
│ │      comment text,
│ │      primary key (value)
│ │  );
│ │  
│ │ @@ -1241,61 +1163,21 @@
│ │      number  integer default 0                     not null,
│ │      primary key (user_id),
│ │      foreign key (user_id) references "user"
│ │          on update cascade on delete cascade
│ │  );
│ │  
│ │  alter table public_user
│ │ -    owner to postgres;
│ │ -
│ │ -create table file
│ │ -(
│ │ -    file_id    text    default gen_random_uuid() not null,
│ │ -    user_id    text,
│ │ -    name       text                              not null,
│ │ -    type       text                              not null,
│ │ -    signed_url text                              not null,
│ │ -    public     boolean default true              not null,
│ │ -    primary key (file_id),
│ │ -    foreign key (user_id) references "user"
│ │ -        on update cascade on delete set null
│ │ -);
│ │ -
│ │ -alter table file
│ │ -    owner to postgres;
│ │ -
│ │ -create table app
│ │ -(
│ │ -    name              text not null,
│ │ -    storage_bucket    text not null,
│ │ -    version_latest    text not null,
│ │ -    version_supported text not null,
│ │ -    primary key (name)
│ │ -);
│ │ -
│ │ -alter table app
│ │      owner to postgres;"""
│ │ -        self.log(db_string, level=logging.DEBUG)
│ │ -        asyncio.run(self.run_sql(
│ │ -            host=host,
│ │ -            password=env.database_credential.password,
│ │ -            sql=db_string
│ │ -        ))
│ │ -        db_string = "insert into \"ENUM_ROLE\" (value) values ('admin')"
│ │ -        asyncio.run(self.run_sql(
│ │ -            host=host,
│ │ -            password=env.database_credential.password,
│ │ -            sql=db_string
│ │ -        ))
│ │ -        db_string = "insert into \"ENUM_ROLE\" (value) values ('user')"
│ │ -        asyncio.run(self.run_sql(
│ │ -            host=host,
│ │ -            password=env.database_credential.password,
│ │ -            sql=db_string
│ │ -        ))
│ │ +        cursor = conn.cursor()
│ │ +        cursor.execute(db_string)
│ │ +        cursor.execute("insert into \"ENUM_ROLE\" (value) values ('admin')")
│ │ +        cursor.execute("insert into \"ENUM_ROLE\" (value) values ('user')")
│ │ +        conn.commit()
│ │ +        conn.close()
│ │          self.do_import_hasura_metadata(None)
│ │          with open("hasura_metadata.json", "r") as f:
│ │              metadata = json.load(f)
│ │          metadata["sources"][0]["tables"] = [
│ │              {
│ │                  "table": {
│ │                      "name": "ENUM_ROLE",
│ │ @@ -1313,111 +1195,14 @@
│ │                              "filter": {}
│ │                          }
│ │                      }
│ │                  ]
│ │              },
│ │              {
│ │                  "table": {
│ │ -                    "name": "app",
│ │ -                    "schema": "public"
│ │ -                }
│ │ -            },
│ │ -            {
│ │ -                "table": {
│ │ -                    "name": "file",
│ │ -                    "schema": "public"
│ │ -                },
│ │ -                "insert_permissions": [
│ │ -                    {
│ │ -                        "role": "user",
│ │ -                        "permission": {
│ │ -                            "check": {
│ │ -                                "user_id": {
│ │ -                                    "_eq": "X-Hasura-User-Id"
│ │ -                                }
│ │ -                            },
│ │ -                            "columns": [
│ │ -                                "file_id",
│ │ -                                "name",
│ │ -                                "signed_url",
│ │ -                                "type",
│ │ -                                "user_id"
│ │ -                            ]
│ │ -                        }
│ │ -                    }
│ │ -                ],
│ │ -                "select_permissions": [
│ │ -                    {
│ │ -                        "role": "user",
│ │ -                        "permission": {
│ │ -                            "columns": [
│ │ -                                "file_id",
│ │ -                                "name",
│ │ -                                "public",
│ │ -                                "signed_url",
│ │ -                                "type",
│ │ -                                "user_id"
│ │ -                            ],
│ │ -                            "filter": {
│ │ -                                "_or": [
│ │ -                                    {
│ │ -                                        "user_id": {
│ │ -                                            "_eq": "X-Hasura-User-Id"
│ │ -                                        }
│ │ -                                    },
│ │ -                                    {
│ │ -                                        "public": {
│ │ -                                            "_eq": True
│ │ -                                        }
│ │ -                                    }
│ │ -                                ]
│ │ -                            }
│ │ -                        }
│ │ -                    }
│ │ -                ],
│ │ -                "update_permissions": [
│ │ -                    {
│ │ -                        "role": "user",
│ │ -                        "permission": {
│ │ -                            "columns": [
│ │ -                                "public",
│ │ -                                "file_id",
│ │ -                                "name",
│ │ -                                "signed_url",
│ │ -                                "type",
│ │ -                                "user_id"
│ │ -                            ],
│ │ -                            "filter": {
│ │ -                                "user_id": {
│ │ -                                    "_eq": "X-Hasura-User-Id"
│ │ -                                }
│ │ -                            },
│ │ -                            "check": {
│ │ -                                "user_id": {
│ │ -                                    "_eq": "X-Hasura-User-Id"
│ │ -                                }
│ │ -                            }
│ │ -                        }
│ │ -                    }
│ │ -                ],
│ │ -                "delete_permissions": [
│ │ -                    {
│ │ -                        "role": "user",
│ │ -                        "permission": {
│ │ -                            "filter": {
│ │ -                                "user_id": {
│ │ -                                    "_eq": "X-Hasura-User-Id"
│ │ -                                }
│ │ -                            }
│ │ -                        }
│ │ -                    }
│ │ -                ]
│ │ -            },
│ │ -            {
│ │ -                "table": {
│ │                      "name": "public_user",
│ │                      "schema": "public"
│ │                  },
│ │                  "insert_permissions": [
│ │                      {
│ │                          "role": "user",
│ │                          "permission": {
│ │ @@ -1541,27 +1326,25 @@
│ │                      }
│ │                  ]
│ │              }
│ │          ]
│ │          with open("hasura_metadata.json", "w") as f:
│ │              json.dump(metadata, f)
│ │          self.do_export_hasura_metadata(None)
│ │ -        env.default_user_table_created = True
│ │ -        self.set_env(env)
│ │  
│ │ -    def gcloud_create_auth_service_account(self):
│ │ +    def do_gcloud_create_auth_service_account(self, _):
│ │          env = self.get_env()
│ │          if env.auth_service_account is not None:
│ │ -            self.log(f"Service account already created: {env.auth_service_account.email}", level=logging.DEBUG)
│ │ +            self.log(f"Service account already created: {env.auth_service_account.email}")
│ │              return
│ │          if env.project is None:
│ │ -            self.log("No project set. Please set one with gcloud_create_project.", level=logging.ERROR)
│ │ +            self.log("No project set. Please set one with gcloud_create_project.")
│ │              return
│ │          if env.hasura_service is None:
│ │ -            self.log("No service account found.", level=logging.ERROR)
│ │ +            self.log("No service account found.")
│ │              return
│ │          cmd_log_str = f"gcloud iam service-accounts create pysura-admin " \
│ │                        f"--project={env.project.name.split('/')[-1]} " \
│ │                        f"--display-name=pysuraadmin"
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │          os.system(cmd_log_str)
│ │          cmd_str = f"gcloud iam service-accounts list " \
│ │ @@ -1579,46 +1362,40 @@
│ │              self.log("No service account found.")
│ │              return
│ │          cmd_str = f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} " \
│ │                    f"--member=serviceAccount:{env.auth_service_account.email} " \
│ │                    f"--role=roles/firebase.admin " \
│ │                    f"--format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} " \
│ │                    f"--member=serviceAccount:{env.auth_service_account.email} " \
│ │                    f"--role=roles/cloudbuild.builds.builder " \
│ │                    f"--format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} " \
│ │                    f"--member=serviceAccount:{env.auth_service_account.email} " \
│ │                    f"--role=roles/firebaseauth.admin " \
│ │                    f"--format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ -        cmd_str = f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} " \
│ │ -                  f"--member=serviceAccount:{env.auth_service_account.email} " \
│ │ -                  f"--role=roles/cloudsql.client " \
│ │ -                  f"--format=json"
│ │ -        self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = f"gcloud iam service-accounts keys create admin.json " \
│ │                    f"--iam-account={env.auth_service_account.email} " \
│ │                    f"--format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          with open("admin.json", "r") as f:
│ │              admin_secrets = json.load(f)
│ │          env.auth_service_account.key_file = admin_secrets
│ │          env.service_accounts = service_accounts
│ │          self.set_env(env)
│ │          os.remove("admin.json")
│ │  
│ │ -    def attach_auth(self):
│ │ +    def do_attach_auth(self, _):
│ │          env = self.get_env()
│ │          if os.path.isdir("pysura_auth"):
│ │              os.chdir("pysura_auth")
│ │          else:
│ │              os.mkdir("pysura_auth")
│ │              os.chdir("pysura_auth")
│ │          path = self.get_site_packages_path(submodule="pysura_auth")
│ │ @@ -1645,31 +1422,31 @@
│ │  
│ │          cmd_log_str = (f"gcloud projects add-iam-policy-binding {env.project.name.split('/')[-1]} "
│ │                         f"--member=serviceAccount:{env.project.name.split('/')[-1]}@appspot.gserviceaccount.com "
│ │                         f"--role=roles/secretmanager.secretAccessor "
│ │                         f"--format=json"
│ │                         )
│ │          self.log(cmd_log_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_log_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_log_str).read()
│ │          cmd_str = f'gcloud functions deploy on_user_create ' \
│ │                    f'--runtime=python39 ' \
│ │                    f'--trigger-event=providers/firebase.auth/eventTypes/user.create ' \
│ │                    f'--trigger-resource={env.project.name.split("/")[-1]} ' \
│ │                    f'--min-instances=1 ' \
│ │                    f'--format=json'
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = f'gcloud functions deploy on_user_delete ' \
│ │                    f'--runtime=python39 ' \
│ │                    f'--trigger-event=providers/firebase.auth/eventTypes/user.delete ' \
│ │                    f'--trigger-resource={env.project.name.split("/")[-1]} ' \
│ │                    f'--min-instances=1 ' \
│ │                    f'--format=json'
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          os.chdir("..")
│ │          cmd_str = f"gcloud functions list " \
│ │                    f"--project={env.project.name.split('/')[-1]} " \
│ │                    f"--format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          functions = json.loads(os.popen(cmd_str).read())
│ │          new_functions = []
│ │ @@ -1683,52 +1460,46 @@
│ │            "audience": "PROJECT_ID",
│ │            "issuer": "https://securetoken.google.com/PROJECT_ID"
│ │          }""".replace("PROJECT_ID", env.project.name.split("/")[-1])))
│ │          env.hasura.HASURA_GRAPHQL_JWT_SECRET = jwt_config
│ │          self.set_env(env)
│ │          self.do_gcloud_deploy_hasura()
│ │  
│ │ -    def attach_firebase(self):
│ │ +    def do_attach_firebase(self, _):
│ │          env = self.get_env()
│ │          cmd_str = f"firebase projects:addfirebase  {env.project.name.split('/')[-1]}"
│ │ -        log_str = "Please login to the same account that you used to create the project with firebase!"
│ │ -        self.log(log_str, level=logging.INFO)
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          cmd_str = f"firebase login --interactive"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          if env.auth_service_account is None:
│ │ -            self.gcloud_create_auth_service_account()
│ │ +            self.do_gcloud_create_auth_service_account(None)
│ │              env = self.get_env()
│ │          with open("admin.json", "w") as f:
│ │              json.dump(env.auth_service_account.key_file, f)
│ │          admin_json = json.dumps(env.auth_service_account.key_file)
│ │          self.do_gcloud_set_secret("HASURA_FIREBASE_SERVICE_ACCOUNT", admin_json)
│ │ -        env.firebase_attached = True
│ │ -        self.set_env(env)
│ │ -
│ │ -    def activate_firebase_auth(self):
│ │ -        env = self.get_env()
│ │ +        self.do_attach_flutter(None)
│ │          cmd_str = f"gcloud auth activate-service-account --key-file=admin.json {env.auth_service_account.email}"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          cmd_str = "gcloud auth print-access-token"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          access_token = os.popen(cmd_str).read().strip()
│ │          cmd_str = f"curl -X POST -H 'Authorization:Bearer {access_token}' -H 'Content-Type:application/json' " \
│ │                    f"'https://identitytoolkit.googleapis.com/v2/projects" \
│ │                    f"/{env.project.name.split('/')[-1]}/identityPlatform:initializeAuth'"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = f"curl -H 'Authorization:Bearer {access_token}' -H 'Content-Type:application/json' " \
│ │                    f"'https://identitytoolkit.googleapis.com/admin/v2/projects" \
│ │                    f"/{env.project.name.split('/')[-1]}/config'"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          body_data = {
│ │              "authorizedDomains": [
│ │                  "localhost",
│ │                  f"{env.project.name.split('/')[-1]}.firebaseapp.com",
│ │                  f"{env.project.name.split('/')[-1]}.web.app"
│ │              ],
│ │              "signIn": {
│ │ @@ -1736,15 +1507,15 @@
│ │                      "enabled": True,
│ │                      "testPhoneNumbers": {
│ │                          "+15555215551": "000001",
│ │                          "+15555215552": "000002"
│ │                      }
│ │                  },
│ │                  "email": {
│ │ -                    "enabled": True,
│ │ +                    "enabled": False,
│ │                      "passwordRequired": False
│ │                  },
│ │                  "anonymous": {
│ │                      "enabled": False
│ │                  },
│ │                  "allowDuplicateEmails": False
│ │              }
│ │ @@ -1756,133 +1527,101 @@
│ │                    f"/{env.project.name.split('/')[-1]}/config?updateMask=Config.authorizedDomains," \
│ │                    f"Config.signIn.email.enabled,Config.signIn.email.passwordRequired," \
│ │                    f"Config.signIn.phoneNumber.enabled,Config.signIn.phoneNumber.testPhoneNumbers," \
│ │                    f"Config.signIn.anonymous.enabled," \
│ │                    f"Config.signIn.allowDuplicateEmails' " \
│ │                    f"-d '{json.dumps(body_data)}'"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │ -        self.log(os.popen(cmd_str).read(), level=logging.DEBUG)
│ │ +        os.popen(cmd_str).read()
│ │          cmd_str = "gcloud auth login"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │ -        self.attach_auth()
│ │ +        self.do_attach_auth(None)
│ │          self.log("Please enable phone sign in in the Firebase console", level=logging.INFO)
│ │          self.log(f"https://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/authentication"
│ │                   f"/providers",
│ │                   level=logging.INFO
│ │                   )
│ │          ready = self.collect("Have you enabled phone sign in in the Firebase console? (y/n): ")
│ │          if ready != "y":
│ │              self.log("Please enable phone sign in in the Firebase console", level=logging.INFO)
│ │              return
│ │ -        env.firebase_auth_activated = True
│ │ -        self.set_env(env)
│ │  
│ │ -    def check_gcloud(self):
│ │ +    def do_check_gcloud(self, _):
│ │          cmd_str = "gcloud version --format=json"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          try:
│ │              gcloud_version = json.loads(os.popen(cmd_str).read().strip())
│ │              self.log(gcloud_version, level=logging.DEBUG)
│ │              # ensure that Google Cloud SDK is at least 411.0.0
│ │              if gcloud_version["Google Cloud SDK"] < "411.0.0":
│ │                  raise Exception("Google Cloud SDK is not up to date")
│ │ +            # ensure that alpha is at least 2022.12.05
│ │ +            if gcloud_version["alpha"] < "2022.12.05":
│ │ +                raise Exception("Google Cloud SDK alpha is not up to date")
│ │              # ensure that beta is at least 2022.12.05
│ │              if gcloud_version["beta"] < "2022.12.05":
│ │                  raise Exception("Google Cloud SDK beta is not up to date")
│ │              return True
│ │          except Exception as e:
│ │              self.log(str(e), level=logging.ERROR)
│ │              self.log("Please update Google Cloud SDK", level=logging.ERROR)
│ │              return False
│ │  
│ │ -    def check_npm(self):
│ │ -        try:
│ │ -            result = os.popen('npm -v')
│ │ -            output = result.read()
│ │ -            version_regex = re.compile(r'^(\d+\.\d+\.\d+)$', re.MULTILINE)
│ │ -            match = version_regex.search(output)
│ │ -            if match is None:
│ │ -                self.log("Please install npm", level=logging.ERROR)
│ │ -                raise Exception("npm not installed")
│ │ -            return True
│ │ -        except Exception as e:
│ │ -            self.log(str(e), level=logging.ERROR)
│ │ -            return False
│ │ -
│ │ -    def check_flutter(self):
│ │ -        try:
│ │ -            result = os.popen('flutter --version')
│ │ -            output = result.read()
│ │ -            version_regex = re.compile(r'^Flutter\s+(\d+\.\d+\.\d+)', re.MULTILINE)
│ │ -            match = version_regex.search(output)
│ │ -            if match is None:
│ │ -                self.log("Please install flutter", level=logging.ERROR)
│ │ -                raise Exception("flutter not installed")
│ │ -            return True
│ │ -        except Exception as e:
│ │ -            self.log(str(e), level=logging.ERROR)
│ │ -            return False
│ │ -
│ │ -    def check_firebase(self):
│ │ -        try:
│ │ -            result = os.popen('firebase --version')
│ │ -            output = result.read()
│ │ -            version_regex = re.compile(r'^(\d+\.\d+\.\d+)$', re.MULTILINE)
│ │ -            match = version_regex.search(output)
│ │ -            if match is None:
│ │ -                self.log("Please install firebase", level=logging.ERROR)
│ │ -                raise Exception("firebase not installed")
│ │ -            return True
│ │ -        except Exception as e:
│ │ -            self.log(str(e), level=logging.ERROR)
│ │ -            return False
│ │ -
│ │ -    def check_docker(self):
│ │ -        try:
│ │ -            result = os.popen('docker info')
│ │ -            output = result.read()
│ │ -            not_running = "Is the docker daemon running?"
│ │ -            if not_running in output:
│ │ -                self.log("Please start the docker daemon!", level=logging.ERROR)
│ │ -                raise Exception("docker daemon not running")
│ │ -            return True
│ │ -        except Exception as e:
│ │ -            self.log(str(e), level=logging.ERROR)
│ │ -            return False
│ │ -
│ │ -    def attach_flutter(self):
│ │ +    def do_attach_flutter(self, _):
│ │          env = self.get_env()
│ │          if env.hasura is None:
│ │              self.log("Please setup Hasura first", level=logging.ERROR)
│ │              return
│ │ -        self.log(f"Your project name is: {env.project.name.split('/')[-1]}", level=logging.INFO)
│ │ -        confirm_choice = self.collect(f"Please enter a name of the Flutter project.\n"
│ │ -                                      f"This will be used to register your app.\n"
│ │ -                                      f"com.example.[projectName]\n"
│ │ -                                      f"Do not use spaces, and use _ instead of -\n"
│ │ -                                      f"Project Name: ",
│ │ -                                      [env.project.name.split('/')[-1].replace("-", "_").replace(" ", "_")])
│ │ -        if not self.confirm_loop(confirm_choice):
│ │ -            self.attach_flutter()
│ │ -        project_name = confirm_choice
│ │ -        if os.path.isdir(project_name):
│ │ -            os.chdir(project_name)
│ │ +        if os.path.isdir("flutter_frontend"):
│ │ +            os.chdir("flutter_frontend")
│ │          else:
│ │ -            os.mkdir(project_name)
│ │ -            os.chdir(project_name)
│ │ +            os.mkdir("flutter_frontend")
│ │ +            os.chdir("flutter_frontend")
│ │          cmd_str = f"flutter create . "
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │ +        os.chdir("android")
│ │ +        cmd_str = "./gradlew signingReport"
│ │ +        self.log(cmd_str, level=logging.DEBUG)
│ │ +        response = os.popen(cmd_str).read()
│ │ +        variants = re.findall(r'Variant: (.+)', response)
│ │ +        configs = re.findall(r'Config: (.+)', response)
│ │ +        md5s = re.findall(r'MD5: (.+)', response)
│ │ +        sha1s = re.findall(r'SHA1: (.+)', response)
│ │ +        sha256s = re.findall(r'SHA-256: (.+)', response)
│ │ +        valid_until = re.findall(r'Valid until: (.+)', response)
│ │ +        signing_reports = []
│ │ +        for variant, config, md5, sha1, sha256, valid in zip(variants, configs, md5s, sha1s, sha256s, valid_until):
│ │ +            signing_report_data = {
│ │ +                'variant': variant,
│ │ +                'config': config,
│ │ +                'md5': md5,
│ │ +                'sha1': sha1,
│ │ +                'sha256': sha256,
│ │ +                'valid_until': valid
│ │ +            }
│ │ +            android_report = AndroidSigningReport(**signing_report_data)
│ │ +            signing_reports.append(android_report)
│ │ +            if android_report.variant == "debug":
│ │ +                env.android_debug_signing_report = android_report
│ │ +        env.android_signing_reports = signing_reports
│ │ +        os.chdir("..")
│ │ +        if not os.path.exists("pubspec.yaml"):
│ │ +            self.log("pubspec.yaml not found", level=logging.ERROR)
│ │ +            return
│ │ +        os.remove("pubspec.yaml")
│ │ +        if not os.path.exists("lib/main.dart"):
│ │ +            self.log("lib/main.dart not found", level=logging.ERROR)
│ │ +            return
│ │ +        os.remove("lib/main.dart")
│ │          os.mkdir("lib/common")
│ │          os.mkdir("lib/controllers")
│ │          os.mkdir("lib/pages")
│ │          os.mkdir("lib/widgets")
│ │ -        os.remove("lib/main.dart")
│ │ -        os.remove("pubspec.yaml")
│ │          os.remove("test/widget_test.dart")
│ │          path = self.get_site_packages_path(submodule="pysura_frontend")
│ │          for root, dirs, files in os.walk(path):
│ │              for f in files:
│ │                  if "__pycache__" in root or ".dart_tool" in root or ".idea" in root or ".git" in root:
│ │                      continue
│ │                  if f == "pubspec.yaml":
│ │ @@ -1913,122 +1652,192 @@
│ │          cmd_str = f"dart pub global run flutterfire_cli:flutterfire configure " \
│ │                    f"--platforms=android,ios,macos,web,linux,windows"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │          cmd_str = "flutter pub get"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │ +        with open("ios/Runner/GoogleService-Info.plist", "rb") as f:
│ │ +            ios_plist = plistlib.load(f)
│ │ +        reversed_ios_client_id = ios_plist["REVERSED_CLIENT_ID"]
│ │ +        with open("ios/Runner/Info.plist", "rb") as f:
│ │ +            ios_plist = plistlib.load(f)
│ │ +        ios_bundle = {
│ │ +            "CFBundleTypeRole": "Editor",
│ │ +            "CFBundleURLSchemes": [reversed_ios_client_id]
│ │ +        }
│ │ +        ios_plist["CFBundleURLTypes"] = [
│ │ +            ios_bundle
│ │ +        ]
│ │ +        env.ios_cf_bundle_url_types = IosCFBundleURLTypes(**ios_bundle)
│ │ +        with open("ios/Runner/Info.plist", "wb") as f:
│ │ +            plistlib.dump(ios_plist, f)
│ │ +        self.log(f"SHA1:\n{env.android_debug_signing_report.sha1}", level=logging.DEBUG)
│ │ +        self.log(f"SHA256:\n{env.android_debug_signing_report.sha256}", level=logging.DEBUG)
│ │ +        self.log(f"Please visit:\nhttps://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/"
│ │ +                 f"settings/general/android\nAdd the SHA1 and SHA256 to the list of fingerprints", level=logging.DEBUG)
│ │ +        ready = self.collect("Are you ready to continue? (y/n): ")
│ │ +        while ready != "y":
│ │ +            ready = self.collect("Are you ready to continue? (y/n): ")
│ │          cmd_str = "flutter doctor"
│ │          self.log(cmd_str, level=logging.DEBUG)
│ │          os.system(cmd_str)
│ │ -        if os.path.exists("ios/Runner/GoogleService-Info.plist") and os.path.exists("ios/Runner/Info.plist"):
│ │ -            with open("ios/Runner/GoogleService-Info.plist", "rb") as f:
│ │ -                ios_plist = plistlib.load(f)
│ │ -            reversed_ios_client_id = ios_plist["REVERSED_CLIENT_ID"]
│ │ -            with open("ios/Runner/Info.plist", "rb") as f:
│ │ -                ios_plist = plistlib.load(f)
│ │ -            ios_bundle = {
│ │ -                "CFBundleTypeRole": "Editor",
│ │ -                "CFBundleURLSchemes": [reversed_ios_client_id]
│ │ -            }
│ │ -            ios_plist["CFBundleURLTypes"] = [
│ │ -                ios_bundle
│ │ -            ]
│ │ -            env.ios_cf_bundle_url_types = IosCFBundleURLTypes(**ios_bundle)
│ │ -            with open("ios/Runner/Info.plist", "wb") as f:
│ │ -                plistlib.dump(ios_plist, f)
│ │ -
│ │ -        if os.path.isdir("android"):
│ │ -            os.chdir("android")
│ │ -            cmd_str = "./gradlew signingReport"
│ │ -            self.log(cmd_str, level=logging.DEBUG)
│ │ -            response = os.popen(cmd_str).read()
│ │ -            variants = re.findall(r'Variant: (.+)', response)
│ │ -            configs = re.findall(r'Config: (.+)', response)
│ │ -            md5s = re.findall(r'MD5: (.+)', response)
│ │ -            sha1s = re.findall(r'SHA1: (.+)', response)
│ │ -            sha256s = re.findall(r'SHA-256: (.+)', response)
│ │ -            valid_until = re.findall(r'Valid until: (.+)', response)
│ │ -            if len(variants) == 0:
│ │ -                self.log("No signing report found", level=logging.WARNING)
│ │ -                cmd_str = "gradlew signingReport"
│ │ -                self.log(cmd_str, level=logging.DEBUG)
│ │ -                response = os.popen(cmd_str).read()
│ │ -                variants = re.findall(r'Variant: (.+)', response)
│ │ -                configs = re.findall(r'Config: (.+)', response)
│ │ -                md5s = re.findall(r'MD5: (.+)', response)
│ │ -                sha1s = re.findall(r'SHA1: (.+)', response)
│ │ -                sha256s = re.findall(r'SHA-256: (.+)', response)
│ │ -                valid_until = re.findall(r'Valid until: (.+)', response)
│ │ -
│ │ -            if len(variants) != 0:
│ │ -                signing_reports = []
│ │ -                for variant, config, md5, sha1, sha256, valid in zip(variants, configs, md5s, sha1s, sha256s,
│ │ -                                                                     valid_until):
│ │ -                    signing_report_data = {
│ │ -                        'variant': variant,
│ │ -                        'config': config,
│ │ -                        'md5': md5,
│ │ -                        'sha1': sha1,
│ │ -                        'sha256': sha256,
│ │ -                        'valid_until': valid
│ │ -                    }
│ │ -                    android_report = AndroidSigningReport(**signing_report_data)
│ │ -                    signing_reports.append(android_report)
│ │ -                    if android_report.variant == "debug":
│ │ -                        env.android_debug_signing_report = android_report
│ │ -
│ │ -                env.android_signing_reports = signing_reports
│ │ -            else:
│ │ -                self.log("No signing report found", level=logging.WARNING)
│ │ -                env.android_signing_reports = []
│ │ -            if env.android_debug_signing_report is not None and \
│ │ -                    env.android_debug_signing_report.sha1 is not None and \
│ │ -                    env.android_debug_signing_report.sha256 is not None:
│ │ -                self.log(f"SHA1:\n{env.android_debug_signing_report.sha1}", level=logging.INFO)
│ │ -                self.log(f"SHA256:\n{env.android_debug_signing_report.sha256}", level=logging.INFO)
│ │ -                self.log(
│ │ -                    f"Please visit:\nhttps://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/"
│ │ -                    f"settings/general/android\nAdd the SHA1 and SHA256 to the list of fingerprints",
│ │ -                    level=logging.INFO)
│ │ -                ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -                while ready != "y":
│ │ -                    ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -            os.chdir("..")
│ │ -        if env.hasura is not None and env.hasura.HASURA_GRAPHQL_URL_ROOT is not None and \
│ │ -                env.hasura.HASURA_GRAPHQL_ADMIN_SECRET is not None:
│ │ -            graphql_file = """{
│ │ -  "name": "GraphQL Schema",
│ │ -  "schemaPath": "schema.graphql",
│ │ -  "extensions": {
│ │ -    "endpoints": {
│ │ -      "Default GraphQL Endpoint": {
│ │ -        "url": "HASURA_GRAPHQL_URL_ROOT",
│ │ -        "headers": {
│ │ -          "x-hasura-admin-secret": "HASURA_GRAPHQL_ADMIN_SECRET"
│ │ -        },
│ │ -        "introspect": false
│ │ -      }
│ │ -    }
│ │ -  }
│ │ -}""".replace("HASURA_GRAPHQL_URL_ROOT", env.hasura.HASURA_GRAPHQL_URL_ROOT
│ │ -             ).replace("HASURA_GRAPHQL_ADMIN_SECRET", env.hasura.HASURA_GRAPHQL_ADMIN_SECRET)
│ │ -            with open("lib/graphql/.graphql", "w") as f:
│ │ -                f.write(graphql_file)
│ │          os.chdir("..")
│ │ -        env.flutter_attached = True
│ │ -        env.flutter_app_name = project_name
│ │          self.set_env(env)
│ │  
│ │      @staticmethod
│ │ -    def generate_types(ordered_custom_objects, ordered_custom_input_objects):
│ │ +    def router_generator(hasura_metadata, service_url="{{HASURA_MICROSERVICE_URL}}"):
│ │ +        """Generates a router for the current microservice"""
│ │ +
│ │ +        def collect_types(object_data, custom_object_type="object"):
│ │ +            root_type = {}
│ │ +            custom_name = object_data.get("name")
│ │ +            root_type[custom_name] = {
│ │ +                "name": custom_name,
│ │ +                "fields": {},
│ │ +                "required_objects": set(),
│ │ +                "custom_type": custom_object_type
│ │ +            }
│ │ +            default_types = ["String", "Int", "Float", "Boolean", "ID"]
│ │ +            for field in object_data.get("fields", []):
│ │ +                is_list = False
│ │ +                is_object = False
│ │ +                is_optional = True
│ │ +                field_collect_type = field.get("type", {})
│ │ +                if field_collect_type[0] == "[" and field_collect_type[-1] == "]":
│ │ +                    field_collect_type = field_collect_type[1:-1]
│ │ +                    is_list = True
│ │ +                if field_collect_type[-1] == "!":
│ │ +                    field_collect_type = field_collect_type[:-1]
│ │ +                    is_optional = False
│ │ +                if field_collect_type not in default_types:
│ │ +                    is_object = True
│ │ +
│ │ +                root_type[custom_name]["fields"][field.get("name")] = {
│ │ +                    "type": field_collect_type,
│ │ +                    "is_list": is_list,
│ │ +                    "is_object": is_object,
│ │ +                    "is_optional": is_optional,
│ │ +                }
│ │ +                if is_object:
│ │ +                    root_type[custom_name]["required_objects"].add(field_collect_type)
│ │ +            return root_type
│ │ +
│ │ +        included_types = []
│ │ +        excluded_types = []
│ │ +        actions = {}
│ │ +        included_actions = set()
│ │ +        for action in hasura_metadata.get("actions", []):
│ │ +            action_name = action.get("name")
│ │ +            action_handler = action.get("definition", {}).get("handler", None)
│ │ +            output_type = action.get("definition", {}).get("output_type", None)
│ │ +            input_type = action.get("definition", {}).get("arguments", [{'type': None}])[0].get("type", None)
│ │ +            if action_handler == service_url:
│ │ +                included_types.append(output_type)
│ │ +                included_types.append(input_type)
│ │ +                included_actions.add(action_name)
│ │ +            else:
│ │ +                excluded_types.append(output_type)
│ │ +                excluded_types.append(input_type)
│ │ +            actions[action_name] = {
│ │ +                "name": action_name,
│ │ +                "handler": action_handler,
│ │ +                "output_type": output_type,
│ │ +                "input_type": input_type
│ │ +            }
│ │ +
│ │ +        unordered_custom_objects = []
│ │ +        for custom_object in hasura_metadata.get("custom_types", {}).get("objects", []):
│ │ +            types = collect_types(custom_object)
│ │ +            unordered_custom_objects.append(types)
│ │ +
│ │ +        unordered_custom_input_objects = []
│ │ +        for custom_input_object in hasura_metadata.get("custom_types", {}).get("input_objects", []):
│ │ +            types = collect_types(custom_input_object)
│ │ +            unordered_custom_input_objects.append(types)
│ │ +
│ │ +        excluded = []
│ │ +        included = []
│ │ +        for co in unordered_custom_objects:
│ │ +            co_key = list(co.keys())[0]
│ │ +            required_objects = co[co_key]["required_objects"]
│ │ +            if co_key in excluded_types:
│ │ +                excluded.extend([co_key, *required_objects])
│ │ +            elif co_key in included_types:
│ │ +                included.extend([co_key, *required_objects])
│ │ +
│ │ +        for co in unordered_custom_input_objects:
│ │ +            co_key = list(co.keys())[0]
│ │ +            required_objects = co[co_key]["required_objects"]
│ │ +            if co_key in excluded_types:
│ │ +                excluded.extend([co_key, *required_objects])
│ │ +            elif co_key in included_types:
│ │ +                included.extend([co_key, *required_objects])
│ │ +
│ │ +        included_set = set(included)
│ │ +        new_unordered_custom_objects = []
│ │ +        for co in unordered_custom_objects:
│ │ +            co_key = list(co.keys())[0]
│ │ +            if co_key in included_set:
│ │ +                new_unordered_custom_objects.append(co)
│ │ +        unordered_custom_objects = new_unordered_custom_objects
│ │ +
│ │ +        new_unordered_custom_input_objects = []
│ │ +        for co in unordered_custom_input_objects:
│ │ +            co_key = list(co.keys())[0]
│ │ +            if co_key in included_set:
│ │ +                new_unordered_custom_input_objects.append(co)
│ │ +        unordered_custom_input_objects = new_unordered_custom_input_objects
│ │ +
│ │ +        ordered_objects_handled = set()
│ │ +        ordered_custom_objects = []
│ │ +        loop_count = 0
│ │ +        # At most, we will have to loop through the list of custom objects as many times as there are custom objects
│ │ +        # This would be worst case if every object was nested in another object
│ │ +        while len(unordered_custom_objects) != len(ordered_custom_objects) and loop_count < len(
│ │ +                unordered_custom_objects) + 1:
│ │ +            loop_count += 1
│ │ +            for custom_object in unordered_custom_objects:
│ │ +                assert len(custom_object) == 1
│ │ +                custom_object_name = list(custom_object.keys())[0]
│ │ +                if custom_object_name in ordered_objects_handled:
│ │ +                    continue
│ │ +                else:
│ │ +                    required_objects = custom_object[custom_object_name]["required_objects"]
│ │ +                    if required_objects.issubset(ordered_objects_handled):
│ │ +                        ordered_custom_objects.append(custom_object)
│ │ +                        ordered_objects_handled.add(custom_object_name)
│ │ +                    else:
│ │ +                        continue
│ │ +
│ │ +        ordered_input_objects_handled = set()
│ │ +        ordered_custom_input_objects = []
│ │ +        loop_count = 0
│ │ +        # At most, we will have to loop through the list of custom objects as many times as there are custom objects
│ │ +        # This would be worst case if every object was nested in another object
│ │ +        while len(unordered_custom_input_objects) != len(ordered_custom_input_objects) and loop_count < len(
│ │ +                unordered_custom_input_objects) + 1:
│ │ +            loop_count += 1
│ │ +            for custom_input_object in unordered_custom_input_objects:
│ │ +                assert len(custom_input_object) == 1
│ │ +                custom_input_object_name = list(custom_input_object.keys())[0]
│ │ +                if custom_input_object_name in ordered_input_objects_handled:
│ │ +                    continue
│ │ +                else:
│ │ +                    required_objects = custom_input_object[custom_input_object_name]["required_objects"]
│ │ +                    if required_objects.issubset(ordered_input_objects_handled):
│ │ +                        ordered_custom_input_objects.append(custom_input_object)
│ │ +                        ordered_input_objects_handled.add(custom_input_object_name)
│ │ +                    else:
│ │ +                        continue
│ │ +
│ │          base_models_template = """from typing import List
│ │  from pydantic import BaseModel
│ │  
│ │ -        """
│ │ +"""
│ │  
│ │          object_template = """\nclass {name}(BaseModel):\n    {fields}{config}\n"""
│ │          field_template = "{}: {}"
│ │          config_template = '\n\n    class Config:\n        schema_extra = {extra}'
│ │          config_extra_start = '{"example": {'
│ │          config_extra_middle_piece = '{field_pieces}'
│ │          config_extra_end = "}}"
│ │ @@ -2121,145 +1930,86 @@
│ │              base_models_template += "\n"
│ │  
│ │          base_models_template = base_models_template.rstrip("\n")
│ │          base_models_template += "\n"
│ │          with open("generated_types.py", "w") as f:
│ │              f.write(base_models_template)
│ │  
│ │ -    @staticmethod
│ │ -    def generate_actions(hasura_metadata, service_url, included_actions, new_hasura_metadata):
│ │ -        action_template = """# (IMPORTS-START) - DO NOT DELETE THIS LINE!
│ │ -import logging
│ │ +        action_template = """import logging
│ │  
│ │  from fastapi import APIRouter, Depends, Request
│ │ -from pysura.faster_api.security import PysuraSecurity, PysuraProvider, Provider
│ │ +from pysura.faster_api.security import backend_auth, UserIdentity, identity, IDENTITY_PROVIDER
│ │  from pysura.faster_api.enums import ApiResponse, ClientRole
│ │  from generated_types import *
│ │  
│ │ -# (IMPORTS-END) - DO NOT DELETE THIS LINE!
│ │ -
│ │  ROUTE = "/SNAKE/"
│ │  ALLOWED_ROLES = [  # The roles allowed to call this action
│ │      # ALLOWED ROLES HERE
│ │  ]
│ │  SNAKE_router = APIRouter(
│ │      tags=["SNAKE"]
│ │  )
│ │  
│ │  
│ │  @SNAKE_router.post(ROUTE,
│ │ -                   dependencies=[
│ │ -                       Depends(PysuraSecurity(
│ │ -                           require_jwt=True,
│ │ -                           require_event_secret=True,
│ │ -                           allowed_roles=ALLOWED_ROLES
│ │ -                       ))
│ │ -                   ],
│ │ -                   response_model=CAMELOutput
│ │ -                   )
│ │ +                   dependencies=[Depends(backend_auth)])
│ │ +@identity(allowed_roles=ALLOWED_ROLES,
│ │ +          identity_provider=IDENTITY_PROVIDER,
│ │ +          function_input=CAMELInput
│ │ +          )
│ │  async def SNAKE(_: Request,
│ │                  SNAKE_input: CAMELInput | None = None,
│ │ -                provider: Provider | None = Depends(PysuraProvider(
│ │ -                    # (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!
│ │ -                    provide_identity=True,
│ │ -                    provide_firebase=True,
│ │ -                    provide_graphql=True,
│ │ -                    provide_storage=True
│ │ -                    # (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!
│ │ -                ))):
│ │ +                injected_user_identity: UserIdentity | None = None
│ │ +                ):
│ │ +    # (AUTH-LOCK-START) - DO NOT DELETE THIS LINE!
│ │ +    if injected_user_identity is None or injected_user_identity.user_id is None:
│ │ +        return {
│ │ +            "response_name": ApiResponse.UNAUTHORIZED.name,
│ │ +            "response_value": ApiResponse.UNAUTHORIZED.value
│ │ +        }
│ │ +    logging.log(logging.INFO, f"User {injected_user_identity.user_id} is authorized to access {ROUTE}")
│ │ +    # (AUTH-LOCK-END) - DO NOT DELETE THIS LINE!
│ │ +
│ │      # (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!
│ │ -    logging.log(logging.INFO, f"User {provider.user_identity.user_id} is authorized to access {ROUTE}")
│ │ -    logging.log(logging.INFO, SNAKE_input)
│ │ -    logging.log(logging.INFO, provider)
│ │ +    print(SNAKE_input)
│ │      response = CAMELOutput(
│ │          data=None,
│ │          nodes=None,
│ │          response_name=ApiResponse.SUCCESS.name,
│ │          response_value=ApiResponse.SUCCESS.value
│ │      ).dict()
│ │ +    print(response)
│ │      return response
│ │      # (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!
│ │ -"""
│ │ +
│ │ +    """
│ │          for action in hasura_metadata.get("actions", []):
│ │              action_handler = action.get("definition", {}).get("handler", None)
│ │              if action_handler == service_url:
│ │                  snake_replace = action["name"]
│ │                  camel_replace = snake_replace.replace("_", " ").title().replace(" ", "")
│ │                  new_action_template = action_template.replace("SNAKE", snake_replace).replace("CAMEL", camel_replace)
│ │                  collect_perms = []
│ │                  for permission in action["permissions"]:
│ │                      collect_perms.append(permission["role"])
│ │                  else:
│ │                      collect_perms.append("admin")
│ │                  collect_perms = [f"ClientRole.{i}.name" for i in sorted(list(set(collect_perms)))]
│ │                  new_action_template = new_action_template.replace("# ALLOWED ROLES HERE", ", ".join(collect_perms))
│ │ -                rewrite = False
│ │ -                original_data = None
│ │ -                if os.path.isfile(f"actions/{snake_replace}.py"):
│ │ -                    rewrite = True
│ │ -                    with open(f"actions/{snake_replace}.py", "r") as f:
│ │ -                        original_data = f.readlines()
│ │ -                if rewrite:
│ │ -                    dependency_injection = []
│ │ -                    business_logic = []
│ │ -                    import_lines = []
│ │ -                    in_dependency_injection = False
│ │ -                    in_business_logic = False
│ │ -                    in_import_lines = False
│ │ -                    for line in original_data:
│ │ -                        if "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_import_lines = False
│ │ -                        if "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_business_logic = False
│ │ -                        if "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_dependency_injection = False
│ │ -                        if in_business_logic:
│ │ -                            business_logic.append(line)
│ │ -                        if in_dependency_injection:
│ │ -                            dependency_injection.append(line)
│ │ -                        if in_import_lines:
│ │ -                            import_lines.append(line)
│ │ -                        if "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_import_lines = True
│ │ -                        if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_business_logic = True
│ │ -                        if "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_dependency_injection = True
│ │ -
│ │ -                    new_lines = []
│ │ -                    in_business_logic = False
│ │ -                    in_dependency_injection = False
│ │ -                    in_import_lines = False
│ │ -                    for line in new_action_template.splitlines():
│ │ -                        if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_business_logic = True
│ │ -                            new_lines.append(line + "\n")
│ │ -                            for business_line in business_logic:
│ │ -                                new_lines.append(business_line)
│ │ -                        elif "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_dependency_injection = True
│ │ -                            new_lines.append(line + "\n")
│ │ -                            for dependency_line in dependency_injection:
│ │ -                                new_lines.append(dependency_line)
│ │ -                        elif "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_import_lines = True
│ │ -                            new_lines.append(line + "\n")
│ │ -                            for import_line in import_lines:
│ │ -                                new_lines.append(import_line)
│ │ -                        elif "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_business_logic = False
│ │ -                        elif "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_dependency_injection = False
│ │ -                        elif "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                            in_import_lines = False
│ │ -                        if (not in_business_logic) and (not in_dependency_injection) and (not in_import_lines):
│ │ -                            new_lines.append(line + "\n")
│ │ -                    new_action_template = "".join(new_lines)
│ │                  with open(f"actions/{snake_replace}.py", "w") as f:
│ │                      f.write(new_action_template)
│ │ +
│ │ +        new_hasura_metadata = {
│ │ +            "actions": [],
│ │ +            "custom_types": {
│ │ +                "objects": [],
│ │ +                "input_objects": []
│ │ +            }
│ │ +        }
│ │ +
│ │          action_names = []
│ │          for action_data in hasura_metadata.get("actions", []):
│ │              if action_data.get("name") in included_actions:
│ │                  new_hasura_metadata["actions"].append(action_data)
│ │                  action_names.append(action_data.get("name"))
│ │  
│ │          init_str = ""
│ │ @@ -2269,655 +2019,90 @@
│ │          init_str += f"\naction_routers = [\n"
│ │          for action_name in action_names:
│ │              init_str += f"    {action_name}_router,\n"
│ │          init_str += "]\n"
│ │          with open("actions/__init__.py", "w") as f:
│ │              f.write(init_str)
│ │  
│ │ -        return new_hasura_metadata
│ │ -
│ │ -    @staticmethod
│ │ -    def generate_event_triggers(hasura_metadata, service_url, new_hasura_metadata):
│ │ -        event_triggers = []
│ │ -        if isinstance(hasura_metadata.get("sources", None), list):
│ │ -            sources = hasura_metadata.get("sources", [])
│ │ -            for s in sources:
│ │ -                source_name = s.get("name", None)
│ │ -                tables = s.get("tables", None)
│ │ -                if isinstance(tables, list):
│ │ -                    for t in tables:
│ │ -                        table_data = t.get("table", None)
│ │ -                        table_name = table_data.get("name", None) if isinstance(table_data, dict) else None
│ │ -                        for trigger in t.get("event_triggers", []):
│ │ -                            if trigger.get("webhook", None) == service_url:
│ │ -                                trigger_name = trigger.get("name", None)
│ │ -                                event_triggers.append({
│ │ -                                    "location": f"{source_name}.{table_name}.{trigger_name}",
│ │ -                                    **trigger
│ │ -                                })
│ │ -        new_hasura_metadata["event_triggers"] = event_triggers
│ │ -
│ │ -        event_trigger_template = """# (IMPORTS-START) - DO NOT DELETE THIS LINE!
│ │ -import logging
│ │ -
│ │ -from fastapi import APIRouter, Depends, Request, Body, Response
│ │ -from pysura.faster_api.security import PysuraSecurity, PysuraProvider, Provider
│ │ -from pysura.faster_api.models import Event
│ │ -
│ │ -# (IMPORTS-END) - DO NOT DELETE THIS LINE!
│ │ -
│ │ -ROUTE = "/SNAKE/"
│ │ -SNAKE_router = APIRouter(
│ │ -    tags=["SNAKE"]
│ │ -)
│ │ -
│ │ -
│ │ -@SNAKE_router.post(ROUTE, dependencies=[Depends(PysuraSecurity(require_jwt=False, require_event_secret=True))])
│ │ -async def SNAKE(_: Request,
│ │ -                provider: Provider | None = Depends(
│ │ -                    PysuraProvider(
│ │ -                        # (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!
│ │ -                        provide_identity=False,
│ │ -                        provide_firebase=True,
│ │ -                        provide_graphql=True,
│ │ -                        provide_storage=True
│ │ -                        # (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!
│ │ -                    )
│ │ -                ),
│ │ -                data: Event = Body(...)):
│ │ -    # (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!
│ │ -    logging.log(logging.INFO, f"Event {data.id} is authorized to access {ROUTE}")
│ │ -    logging.log(logging.INFO, data)
│ │ -    logging.log(logging.INFO, provider)
│ │ -    return Response(status_code=200)
│ │ -    # (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!
│ │ -"""
│ │ -        event_init = ""
│ │ -        event_routers = []
│ │ -        for event_trigger in event_triggers:
│ │ -            event_init += f"from events.{event_trigger['name']} import {event_trigger['name']}_router\n"
│ │ -            event_routers.append(f"    {event_trigger['name']}_router")
│ │ -            snake_replace = event_trigger["name"]
│ │ -            new_event_template = event_trigger_template.replace("SNAKE", snake_replace)
│ │ -            rewrite = False
│ │ -            original_data = None
│ │ -            if os.path.isfile(f"events/{snake_replace}.py"):
│ │ -                rewrite = True
│ │ -                with open(f"events/{snake_replace}.py", "r") as f:
│ │ -                    original_data = f.readlines()
│ │ -            if rewrite:
│ │ -                dependency_injection = []
│ │ -                business_logic = []
│ │ -                import_lines = []
│ │ -                in_dependency_injection = False
│ │ -                in_business_logic = False
│ │ -                in_import_lines = False
│ │ -                for line in original_data:
│ │ -                    if "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_import_lines = False
│ │ -                    if "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_business_logic = False
│ │ -                    if "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_dependency_injection = False
│ │ -                    if in_business_logic:
│ │ -                        business_logic.append(line)
│ │ -                    if in_dependency_injection:
│ │ -                        dependency_injection.append(line)
│ │ -                    if in_import_lines:
│ │ -                        import_lines.append(line)
│ │ -                    if "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_import_lines = True
│ │ -                    if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_business_logic = True
│ │ -                    if "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_dependency_injection = True
│ │ -
│ │ -                new_lines = []
│ │ -                in_business_logic = False
│ │ -                in_dependency_injection = False
│ │ -                in_import_lines = False
│ │ -                for line in new_event_template.splitlines():
│ │ -                    if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_business_logic = True
│ │ -                        new_lines.append(line + "\n")
│ │ -                        for business_line in business_logic:
│ │ -                            new_lines.append(business_line)
│ │ -                    elif "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_dependency_injection = True
│ │ -                        new_lines.append(line + "\n")
│ │ -                        for dependency_line in dependency_injection:
│ │ -                            new_lines.append(dependency_line)
│ │ -                    elif "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_import_lines = True
│ │ -                        new_lines.append(line + "\n")
│ │ -                        for import_line in import_lines:
│ │ -                            new_lines.append(import_line)
│ │ -                    elif "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_business_logic = False
│ │ -                    elif "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_dependency_injection = False
│ │ -                    elif "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                        in_import_lines = False
│ │ -                    if (not in_business_logic) and (not in_dependency_injection) and (not in_import_lines):
│ │ -                        new_lines.append(line + "\n")
│ │ -                new_event_template = "".join(new_lines)
│ │ -            with open(f"events/{snake_replace}.py", "w") as f:
│ │ -                f.write(new_event_template)
│ │ -
│ │ -        event_init += f"\nevent_routers = [\n"
│ │ -        for event_router in event_routers:
│ │ -            event_init += f"    {event_router},\n"
│ │ -        event_init += f"]\n"
│ │ -        with open(f"events/__init__.py", "w") as f:
│ │ -            f.write(event_init)
│ │ -
│ │ -        return new_hasura_metadata
│ │ -
│ │ -    @staticmethod
│ │ -    def generate_crons(hasura_metadata, service_url, new_hasura_metadata):
│ │ -        cron_template = """# (IMPORTS-START) - DO NOT DELETE THIS LINE!
│ │ -import logging
│ │ -
│ │ -from fastapi import APIRouter, Depends, Request, Body, Response
│ │ -from pysura.faster_api.security import PysuraSecurity, PysuraProvider, Provider
│ │ -
│ │ -# (IMPORTS-END) - DO NOT DELETE THIS LINE!
│ │ -
│ │ -ROUTE = "/SNAKE/"
│ │ -SNAKE_router = APIRouter(
│ │ -    tags=["SNAKE"]
│ │ -)
│ │ -
│ │ -
│ │ -@SNAKE_router.post(ROUTE, dependencies=[Depends(PysuraSecurity(require_jwt=False, require_event_secret=True))])
│ │ -async def SNAKE(_: Request,
│ │ -                provider: Provider | None = Depends(
│ │ -                    PysuraProvider(
│ │ -                        # (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!
│ │ -                        provide_identity=False,
│ │ -                        provide_firebase=True,
│ │ -                        provide_graphql=True,
│ │ -                        provide_storage=True
│ │ -                        # (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!
│ │ -                    )
│ │ -                ),
│ │ -                data=Body(...)):
│ │ -    # (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!
│ │ -    logging.log(logging.INFO, data)
│ │ -    logging.log(logging.INFO, provider)
│ │ -    return Response(status_code=200)
│ │ -    # (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!
│ │ -"""
│ │ -
│ │ -        if isinstance(hasura_metadata.get("cron_triggers", None), list):
│ │ -            cron_triggers = hasura_metadata.get("cron_triggers", [])
│ │ -            cron_triggers_init = ""
│ │ -            cron_names = []
│ │ -            for cron_trigger in cron_triggers:
│ │ -                if cron_trigger.get("webhook", None) == service_url:
│ │ -                    new_hasura_metadata["cron_triggers"].append(cron_trigger)
│ │ -                    snake_replace = cron_trigger["name"]
│ │ -                    cron_names.append(snake_replace)
│ │ -                    cron_triggers_init += f"from crons.{snake_replace} import {snake_replace}_router\n"
│ │ -                    new_cron_template = cron_template.replace("SNAKE", snake_replace)
│ │ -                    rewrite = False
│ │ -                    original_data = None
│ │ -                    if os.path.isfile(f"crons/{snake_replace}.py"):
│ │ -                        rewrite = True
│ │ -                        with open(f"crons/{snake_replace}.py", "r") as f:
│ │ -                            original_data = f.readlines()
│ │ -                    if rewrite:
│ │ -                        dependency_injection = []
│ │ -                        business_logic = []
│ │ -                        import_lines = []
│ │ -                        in_dependency_injection = False
│ │ -                        in_business_logic = False
│ │ -                        in_import_lines = False
│ │ -                        for line in original_data:
│ │ -                            if "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_import_lines = False
│ │ -                            if "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_business_logic = False
│ │ -                            if "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_dependency_injection = False
│ │ -                            if in_business_logic:
│ │ -                                business_logic.append(line)
│ │ -                            if in_dependency_injection:
│ │ -                                dependency_injection.append(line)
│ │ -                            if in_import_lines:
│ │ -                                import_lines.append(line)
│ │ -                            if "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_import_lines = True
│ │ -                            if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_business_logic = True
│ │ -                            if "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_dependency_injection = True
│ │ -
│ │ -                        new_lines = []
│ │ -                        in_business_logic = False
│ │ -                        in_dependency_injection = False
│ │ -                        in_import_lines = False
│ │ -                        for line in new_cron_template.splitlines():
│ │ -                            if "# (BUSINESS-LOGIC-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_business_logic = True
│ │ -                                new_lines.append(line + "\n")
│ │ -                                for business_line in business_logic:
│ │ -                                    new_lines.append(business_line)
│ │ -                            elif "# (DEPENDENCY-INJECTION-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_dependency_injection = True
│ │ -                                new_lines.append(line + "\n")
│ │ -                                for dependency_line in dependency_injection:
│ │ -                                    new_lines.append(dependency_line)
│ │ -                            elif "# (IMPORTS-START) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_import_lines = True
│ │ -                                new_lines.append(line + "\n")
│ │ -                                for import_line in import_lines:
│ │ -                                    new_lines.append(import_line)
│ │ -                            elif "# (BUSINESS-LOGIC-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_business_logic = False
│ │ -                            elif "# (DEPENDENCY-INJECTION-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_dependency_injection = False
│ │ -                            elif "# (IMPORTS-END) - DO NOT DELETE THIS LINE!" in line:
│ │ -                                in_import_lines = False
│ │ -                            if (not in_business_logic) and (not in_dependency_injection) and (not in_import_lines):
│ │ -                                new_lines.append(line + "\n")
│ │ -                        new_cron_template = "".join(new_lines)
│ │ -                    with open(f"crons/{snake_replace}.py", "w") as f:
│ │ -                        f.write(new_cron_template)
│ │ -            cron_triggers_init += f"\ncron_routers = [\n"
│ │ -            for cron_name in cron_names:
│ │ -                cron_triggers_init += f"    {cron_name}_router,\n"
│ │ -            cron_triggers_init += f"]\n"
│ │ -            with open(f"crons/__init__.py", "w") as f:
│ │ -                f.write(cron_triggers_init)
│ │ -        return new_hasura_metadata
│ │ -
│ │ -    @staticmethod
│ │ -    def router_generator(hasura_metadata, service_url="{{HASURA_MICROSERVICE_URL}}"):
│ │ -        """Generates a router for the current microservice"""
│ │ -
│ │ -        def collect_types(object_data, custom_object_type="object"):
│ │ -            root_type = {}
│ │ -            custom_name = object_data.get("name")
│ │ -            root_type[custom_name] = {
│ │ -                "name": custom_name,
│ │ -                "fields": {},
│ │ -                "required_objects": set(),
│ │ -                "custom_type": custom_object_type
│ │ -            }
│ │ -            default_types = ["String", "Int", "Float", "Boolean", "ID"]
│ │ -            for field in object_data.get("fields", []):
│ │ -                is_list = False
│ │ -                is_object = False
│ │ -                is_optional = True
│ │ -                field_collect_type = field.get("type", {})
│ │ -                if field_collect_type[0] == "[" and field_collect_type[-1] == "]":
│ │ -                    field_collect_type = field_collect_type[1:-1]
│ │ -                    is_list = True
│ │ -                if field_collect_type[-1] == "!":
│ │ -                    field_collect_type = field_collect_type[:-1]
│ │ -                    is_optional = False
│ │ -                if field_collect_type not in default_types:
│ │ -                    is_object = True
│ │ -
│ │ -                root_type[custom_name]["fields"][field.get("name")] = {
│ │ -                    "type": field_collect_type,
│ │ -                    "is_list": is_list,
│ │ -                    "is_object": is_object,
│ │ -                    "is_optional": is_optional,
│ │ -                }
│ │ -                if is_object:
│ │ -                    root_type[custom_name]["required_objects"].add(field_collect_type)
│ │ -            return root_type
│ │ -
│ │ -        included_types = []
│ │ -        excluded_types = []
│ │ -        actions = {}
│ │ -        included_actions = set()
│ │ -        for action in hasura_metadata.get("actions", []):
│ │ -            action_name = action.get("name")
│ │ -            action_handler = action.get("definition", {}).get("handler", None)
│ │ -            output_type = action.get("definition", {}).get("output_type", None)
│ │ -            input_type = action.get("definition", {}).get("arguments", [{'type': None}])[0].get("type", None)
│ │ -            if action_handler == service_url:
│ │ -                included_types.append(output_type)
│ │ -                included_types.append(input_type)
│ │ -                included_actions.add(action_name)
│ │ -            else:
│ │ -                excluded_types.append(output_type)
│ │ -                excluded_types.append(input_type)
│ │ -            actions[action_name] = {
│ │ -                "name": action_name,
│ │ -                "handler": action_handler,
│ │ -                "output_type": output_type,
│ │ -                "input_type": input_type
│ │ -            }
│ │ -
│ │ -        unordered_custom_objects = []
│ │ -        for custom_object in hasura_metadata.get("custom_types", {}).get("objects", []):
│ │ -            types = collect_types(custom_object)
│ │ -            unordered_custom_objects.append(types)
│ │ -
│ │ -        unordered_custom_input_objects = []
│ │ -        for custom_input_object in hasura_metadata.get("custom_types", {}).get("input_objects", []):
│ │ -            types = collect_types(custom_input_object)
│ │ -            unordered_custom_input_objects.append(types)
│ │ -
│ │ -        excluded = []
│ │ -        included = []
│ │ -        for co in unordered_custom_objects:
│ │ -            co_key = list(co.keys())[0]
│ │ -            required_objects = co[co_key]["required_objects"]
│ │ -            if co_key in excluded_types:
│ │ -                excluded.extend([co_key, *required_objects])
│ │ -            elif co_key in included_types:
│ │ -                included.extend([co_key, *required_objects])
│ │ -
│ │ -        for co in unordered_custom_input_objects:
│ │ -            co_key = list(co.keys())[0]
│ │ -            required_objects = co[co_key]["required_objects"]
│ │ -            if co_key in excluded_types:
│ │ -                excluded.extend([co_key, *required_objects])
│ │ -            elif co_key in included_types:
│ │ -                included.extend([co_key, *required_objects])
│ │ -
│ │ -        included_set = set(included)
│ │ -        new_unordered_custom_objects = []
│ │ -        for co in unordered_custom_objects:
│ │ -            co_key = list(co.keys())[0]
│ │ -            if co_key in included_set:
│ │ -                new_unordered_custom_objects.append(co)
│ │ -        unordered_custom_objects = new_unordered_custom_objects
│ │ -
│ │ -        new_unordered_custom_input_objects = []
│ │ -        for co in unordered_custom_input_objects:
│ │ -            co_key = list(co.keys())[0]
│ │ -            if co_key in included_set:
│ │ -                new_unordered_custom_input_objects.append(co)
│ │ -        unordered_custom_input_objects = new_unordered_custom_input_objects
│ │ -
│ │ -        ordered_objects_handled = set()
│ │ -        ordered_custom_objects = []
│ │ -        loop_count = 0
│ │ -        # At most, we will have to loop through the list of custom objects as many times as there are custom objects
│ │ -        # This would be worst case if every object was nested in another object
│ │ -        while len(unordered_custom_objects) != len(ordered_custom_objects) and loop_count < len(
│ │ -                unordered_custom_objects) + 1:
│ │ -            loop_count += 1
│ │ -            for custom_object in unordered_custom_objects:
│ │ -                assert len(custom_object) == 1
│ │ -                custom_object_name = list(custom_object.keys())[0]
│ │ -                if custom_object_name in ordered_objects_handled:
│ │ -                    continue
│ │ -                else:
│ │ -                    required_objects = custom_object[custom_object_name]["required_objects"]
│ │ -                    if required_objects.issubset(ordered_objects_handled):
│ │ -                        ordered_custom_objects.append(custom_object)
│ │ -                        ordered_objects_handled.add(custom_object_name)
│ │ -                    else:
│ │ -                        continue
│ │ -
│ │ -        ordered_input_objects_handled = set()
│ │ -        ordered_custom_input_objects = []
│ │ -        loop_count = 0
│ │ -        # At most, we will have to loop through the list of custom objects as many times as there are custom objects
│ │ -        # This would be worst case if every object was nested in another object
│ │ -        while len(unordered_custom_input_objects) != len(ordered_custom_input_objects) and loop_count < len(
│ │ -                unordered_custom_input_objects) + 1:
│ │ -            loop_count += 1
│ │ -            for custom_input_object in unordered_custom_input_objects:
│ │ -                assert len(custom_input_object) == 1
│ │ -                custom_input_object_name = list(custom_input_object.keys())[0]
│ │ -                if custom_input_object_name in ordered_input_objects_handled:
│ │ -                    continue
│ │ -                else:
│ │ -                    required_objects = custom_input_object[custom_input_object_name]["required_objects"]
│ │ -                    if required_objects.issubset(ordered_input_objects_handled):
│ │ -                        ordered_custom_input_objects.append(custom_input_object)
│ │ -                        ordered_input_objects_handled.add(custom_input_object_name)
│ │ -                    else:
│ │ -                        continue
│ │ -
│ │ -        GoogleRoot.generate_types(ordered_custom_objects=ordered_custom_objects,
│ │ -                                  ordered_custom_input_objects=ordered_custom_input_objects)
│ │ -        new_hasura_metadata = {
│ │ -            "actions": [],
│ │ -            "custom_types": {
│ │ -                "objects": [],
│ │ -                "input_objects": []
│ │ -            },
│ │ -            "event_triggers": [],
│ │ -            "cron_triggers": []
│ │ -        }
│ │ -        new_hasura_metadata = GoogleRoot.generate_actions(hasura_metadata=hasura_metadata,
│ │ -                                                          service_url=service_url,
│ │ -                                                          included_actions=included_actions,
│ │ -                                                          new_hasura_metadata=new_hasura_metadata)
│ │ -
│ │ -        new_hasura_metadata = GoogleRoot.generate_event_triggers(hasura_metadata=hasura_metadata,
│ │ -                                                                 service_url=service_url,
│ │ -                                                                 new_hasura_metadata=new_hasura_metadata
│ │ -                                                                 )
│ │ -
│ │ -        new_hasura_metadata = GoogleRoot.generate_crons(hasura_metadata=hasura_metadata,
│ │ -                                                        service_url=service_url,
│ │ -                                                        new_hasura_metadata=new_hasura_metadata)
│ │ -
│ │          for custom_type in hasura_metadata.get("custom_types", {}).get("objects", []):
│ │              if custom_type.get("name") in included_set:
│ │                  new_hasura_metadata["custom_types"]["objects"].append(custom_type)
│ │  
│ │          for custom_type in hasura_metadata.get("custom_types", {}).get("input_objects", []):
│ │              if custom_type.get("name") in included_set:
│ │                  new_hasura_metadata["custom_types"]["input_objects"].append(custom_type)
│ │  
│ │          return new_hasura_metadata
│ │  
│ │ -    def do_generate_microservice_template(self,
│ │ -                                          hasura_metadata_path="hasura_metadata.json",
│ │ -                                          microservice_name="template",
│ │ -                                          microservice_url="{{HASURA_MICROSERVICE_URL}}"
│ │ -                                          ):
│ │ -        """
│ │ -        Generate a microservice template
│ │ -        :param hasura_metadata_path: /path/to/hasura_metadata.json
│ │ -        :param microservice_name: name_of_service
│ │ -        :param microservice_url: {{HASURA_MICROSERVICE_URL}} -> Webhook name in schema
│ │ -
│ │ -        Microservice URL is used to parse the hasura metadata to determine which actions, events, and crons to use.
│ │ -
│ │ -        Parsed from action
│ │ -        {
│ │ -          "name": "action_query_ping",
│ │ -          "definition": {
│ │ -            "handler": "{{HASURA_MICROSERVICE_URL}}"
│ │ -          }
│ │ -        }
│ │ -
│ │ -        Parsed from cron
│ │ -        {
│ │ -          "name": "cron_update_app_message",
│ │ -          "webhook": "{{HASURA_MICROSERVICE_URL}}"
│ │ -        }
│ │ -
│ │ -        Parsed from event
│ │ -        {
│ │ -          "name": "event_update_user_role",
│ │ -          "webhook": "{{HASURA_MICROSERVICE_URL}}"
│ │ -        }
│ │ -
│ │ -
│ │ -        """
│ │ -        if microservice_name == "" or len(microservice_name.strip()) == 0:
│ │ -            self.log("Microservice name cannot be empty", level=logging.ERROR)
│ │ -            return
│ │ -        env = self.get_env()
│ │ -        if env.auth_service_account is None or env.auth_service_account.key_file is None:
│ │ -            self.log("No auth service account specified", level=logging.ERROR)
│ │ -            return
│ │ -        if not os.path.isdir("microservices"):
│ │ -            os.mkdir("microservices")
│ │ -        os.chdir("microservices")
│ │ -        if not os.path.isdir(microservice_name):
│ │ -            os.mkdir(microservice_name)
│ │ -        os.chdir(microservice_name)
│ │ -        os.mkdir("actions")
│ │ -        os.mkdir("crons")
│ │ -        os.mkdir("events")
│ │ -        path = self.get_site_packages_path(submodule="pysura_microservice")
│ │ -        default_actions = []
│ │ -        default_events = []
│ │ -        default_crons = []
│ │ -        for root, dirs, files in os.walk(path):
│ │ -            for f in files:
│ │ -                if "__pycache__" in root or ".dart_tool" in root or ".idea" in root or ".git" in root:
│ │ -                    continue
│ │ -                if f in ["requirements.txt", "app.py", "Dockerfile", "app_secrets.py", "README.md"]:
│ │ -                    shutil.copy(os.path.join(root, f), ".")
│ │ -                elif f == "pysura_metadata.json" and microservice_name == "default":
│ │ -                    shutil.copy(os.path.join(root, f), ".")
│ │ -                else:
│ │ -                    if "actions" in root:
│ │ -                        if f != "action_template.py":
│ │ -                            dir_path = os.path.join(os.getcwd(), "actions")
│ │ -                            if not os.path.isdir(dir_path):
│ │ -                                os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_actions.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │ -                            shutil.copy(os.path.join(root, f), dir_path)
│ │ -                    elif "crons" in root:
│ │ -                        if f != "cron_template.py":
│ │ -                            dir_path = os.path.join(os.getcwd(), "crons")
│ │ -                            if not os.path.isdir(dir_path):
│ │ -                                os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_crons.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │ -                            shutil.copy(os.path.join(root, f), dir_path)
│ │ -                    elif "events" in root:
│ │ -                        if f != "event_template.py":
│ │ -                            dir_path = os.path.join(os.getcwd(), "events")
│ │ -                            if not os.path.isdir(dir_path):
│ │ -                                os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_events.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │ -                            shutil.copy(os.path.join(root, f), dir_path)
│ │ -        with open(hasura_metadata_path, "r") as f:
│ │ -            metadata = json.load(f)
│ │ -        with open("app_secrets.py", "r") as f:
│ │ -            app_secrets_py = f.read()
│ │ -        app_secrets_py = app_secrets_py.replace("YOUR_PROJECT_ID", env.project.name.split("/")[-1])
│ │ -        with open("app_secrets.py", "w") as f:
│ │ -            f.write(app_secrets_py)
│ │ -        self.router_generator(metadata, microservice_url)
│ │ -        os.chdir("../..")
│ │ -
│ │      def do_deploy_microservice(self,
│ │                                 microservice_name="default",
│ │ -                               url_wrapper="{{HASURA_MICROSERVICE_URL}}",
│ │                                 timeout_default="600s",
│ │                                 memory_default="2Gi",
│ │ -                               max_instances_default="10",
│ │ -                               default_init: bool | str = ""):
│ │ -        """
│ │ -        Deploys, or redeploys a microservice. Will rebuild routers, but as long as you leave the comments alone, it
│ │ -        won't overwrite your code!
│ │ -
│ │ -        :param microservice_name: default
│ │ -        :param url_wrapper: {{HASURA_MICROSERVICE_URL}}
│ │ -        :param timeout_default: 600s
│ │ -        :param memory_default: 2Gi
│ │ -        :param max_instances_default: 10
│ │ -        :param default_init: Internal! Do not use!
│ │ -        Example: deploy_microservice default 600s 2Gi 10
│ │ -        """
│ │ -        if isinstance(default_init, str) and default_init.strip() == "":
│ │ -            default_init = False
│ │ +                               max_instances_default="10"):
│ │          if microservice_name == "" or len(microservice_name.strip()) == 0:
│ │              self.log("Microservice name cannot be empty", level=logging.ERROR)
│ │              return
│ │          env = self.get_env()
│ │          if env.auth_service_account is None or env.auth_service_account.key_file is None:
│ │              self.log("No auth service account specified", level=logging.ERROR)
│ │              return
│ │          if not os.path.isdir("microservices"):
│ │              os.mkdir("microservices")
│ │          os.chdir("microservices")
│ │          if not os.path.isdir(microservice_name):
│ │              os.mkdir(microservice_name)
│ │          os.chdir(microservice_name)
│ │ -        if not os.path.isdir("actions"):
│ │ -            os.mkdir("actions")
│ │ -        if not os.path.isdir("crons"):
│ │ -            os.mkdir("crons")
│ │ -        if not os.path.isdir("events"):
│ │ -            os.mkdir("events")
│ │ +        os.mkdir("actions")
│ │ +        os.mkdir("crons")
│ │ +        os.mkdir("events")
│ │          path = self.get_site_packages_path(submodule="pysura_microservice")
│ │ -        default_actions = []
│ │ -        default_events = []
│ │ -        default_crons = []
│ │          for root, dirs, files in os.walk(path):
│ │              for f in files:
│ │ -                self.log(f"Copying {f} to {microservice_name} microservice", level=logging.INFO)
│ │                  if "__pycache__" in root or ".dart_tool" in root or ".idea" in root or ".git" in root:
│ │                      continue
│ │                  if f in ["requirements.txt", "app.py", "Dockerfile", "app_secrets.py", "README.md"]:
│ │                      shutil.copy(os.path.join(root, f), ".")
│ │                  elif f == "pysura_metadata.json" and microservice_name == "default":
│ │                      shutil.copy(os.path.join(root, f), ".")
│ │                  else:
│ │                      if "actions" in root:
│ │                          if f != "action_template.py":
│ │                              dir_path = os.path.join(os.getcwd(), "actions")
│ │                              if not os.path.isdir(dir_path):
│ │                                  os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_actions.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │                              shutil.copy(os.path.join(root, f), dir_path)
│ │                      elif "crons" in root:
│ │                          if f != "cron_template.py":
│ │                              dir_path = os.path.join(os.getcwd(), "crons")
│ │                              if not os.path.isdir(dir_path):
│ │                                  os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_crons.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │                              shutil.copy(os.path.join(root, f), dir_path)
│ │                      elif "events" in root:
│ │                          if f != "event_template.py":
│ │                              dir_path = os.path.join(os.getcwd(), "events")
│ │                              if not os.path.isdir(dir_path):
│ │                                  os.mkdir(dir_path)
│ │ -                            if f != "__init__.py" and microservice_name == "default":
│ │ -                                default_events.append(f.replace(".py", ""))
│ │ -                            if microservice_name != "default":
│ │ -                                continue
│ │                              shutil.copy(os.path.join(root, f), dir_path)
│ │ -        if microservice_name == "default" and default_init:
│ │ +        if microservice_name == "default":
│ │              with open("pysura_metadata.json", "r") as f:
│ │                  metadata = json.load(f)
│ │          else:
│ │              os.chdir("../..")
│ │              with open("hasura_metadata.json", "r") as f:
│ │                  metadata = json.load(f)
│ │              os.chdir("microservices")
│ │              os.chdir(microservice_name)
│ │          with open("app_secrets.py", "r") as f:
│ │              app_secrets_py = f.read()
│ │          app_secrets_py = app_secrets_py.replace("YOUR_PROJECT_ID", env.project.name.split("/")[-1])
│ │          with open("app_secrets.py", "w") as f:
│ │              f.write(app_secrets_py)
│ │ +        url_wrapper = "{{HASURA_MICROSERVICE_URL}}"
│ │ +        if microservice_name != "default":
│ │ +            url_wrapper = "{{" + f"HASURA_{microservice_name}_URL" + "}}"
│ │          new_hasura_metadata = self.router_generator(metadata, url_wrapper)
│ │          input_objects_set = set(
│ │              [i.get("name", None) for i in new_hasura_metadata.get("custom_types", {}).get("input_objects", [])]
│ │          )
│ │          objects_set = set(
│ │              [i.get("name", None) for i in new_hasura_metadata.get("custom_types", {}).get("objects", [])]
│ │          )
│ │ @@ -2940,17 +2125,15 @@
│ │                    f"--max-instances={max_instances} " \
│ │                    f"--cpu=1 " \
│ │                    f"--memory={memory} " \
│ │                    f"--timeout={timeout} " \
│ │                    f"--allow-unauthenticated " \
│ │                    f"--no-cpu-throttling " \
│ │                    f"--project={env.project.name.split('/')[-1]}"
│ │ -        self.log(cmd_str, level=logging.DEBUG)
│ │ -        with open("deploy.txt", "w") as f:
│ │ -            f.write(cmd_str)
│ │ +        self.log(cmd_str, level=logging.INFO)
│ │          os.system(cmd_str)
│ │          services = json.loads(os.popen(f"gcloud run services list "
│ │                                         f"--project={env.project.name.split('/')[-1]} "
│ │                                         f"--format=json").read())
│ │          new_services = []
│ │          if env.hasura.microservice_urls is None:
│ │              env.hasura.microservice_urls = []
│ │ @@ -2961,15 +2144,15 @@
│ │                      env.default_microservice = service_data
│ │                      env.default_microservice_url = service_data.status.url
│ │                      env.hasura.HASURA_MICROSERVICE_URL = f"{service_data.status.url}"
│ │                  else:
│ │                      microservice_url = MicroserviceUrl(
│ │                          url=service_data.status.url,
│ │                          name=microservice_name,
│ │ -                        url_wrapper=url_wrapper
│ │ +                        url_wrapper=f"HASURA_{microservice_name}_URL"
│ │                      )
│ │                      append_flag = True
│ │                      for url in env.hasura.microservice_urls:
│ │                          if url.name == microservice_name:
│ │                              append_flag = False
│ │                              break
│ │                      if append_flag:
│ │ @@ -2981,110 +2164,35 @@
│ │          self.do_gcloud_deploy_hasura()
│ │          with open("hasura_metadata.json", "r") as f:
│ │              metadata = json.load(f)
│ │          new_metadata = {}
│ │          new_actions = []
│ │          new_objects = []
│ │          new_input_objects = []
│ │ -        if metadata.get("actions", None) is None:
│ │ -            metadata["actions"] = []
│ │ -        if metadata.get("custom_types", None) is None:
│ │ -            metadata["custom_types"] = {
│ │ -                "objects": [],
│ │ -                "input_objects": []
│ │ -            }
│ │ -        if metadata.get("sources", None) is None:
│ │ -            metadata["sources"] = []
│ │ -        if metadata.get("cron_triggers", None) is None:
│ │ -            metadata["cron_triggers"] = []
│ │          for key, value in metadata.items():
│ │              if key == "actions":
│ │                  for action in value:
│ │ -                    if action.get("definition", None) is None:
│ │ -                        action["definition"] = {}
│ │ -                    if action["definition"].get("request_transform", None) is None:
│ │ -                        action["definition"]["request_transform"] = {}
│ │ -                    action["definition"]["request_transform"]["body"] = {
│ │ -                        "action": "transform",
│ │ -                        "template": "{{" + f"$body?.input?.{action['name']}_input" + "}}"
│ │ -                    }
│ │ -                    if action.get("definition", None).get("handler", None) == url_wrapper:
│ │ +                    if action["handler"] == url_wrapper:
│ │                          continue
│ │                      new_actions.append(action)
│ │              elif key == "custom_types":
│ │                  objects = value.get("objects", [])
│ │                  for obj in objects:
│ │                      if obj["name"] in objects_set:
│ │                          continue
│ │                      new_objects.append(obj)
│ │                  input_objects = value.get("input_objects", [])
│ │                  for obj in input_objects:
│ │                      if obj["name"] in input_objects_set:
│ │                          continue
│ │                      new_input_objects.append(obj)
│ │ -            elif key == "sources":
│ │ -                for event_trigger in new_hasura_metadata["event_triggers"]:
│ │ -                    source_name, table_name, trigger_name = event_trigger.pop('location').split(".")
│ │ -                    for source in value:
│ │ -                        self.log("source: " + str(source), level=logging.DEBUG)
│ │ -                        if source["name"] == source_name:
│ │ -                            for table in source.get("tables", []):
│ │ -                                table_data = table.get("table", None)
│ │ -                                tb_name = table_data.get("name", None) if isinstance(table_data, dict) else None
│ │ -                                if tb_name == table_name:
│ │ -                                    new_event_triggers = []
│ │ -                                    if isinstance(table.get("event_triggers", None), list):
│ │ -                                        trigger_found = False
│ │ -                                        for trigger in table.get("event_triggers", []):
│ │ -                                            if trigger.get("name", None) == trigger_name:
│ │ -                                                new_event_triggers.append(event_trigger)
│ │ -                                                trigger_found = True
│ │ -                                            else:
│ │ -                                                new_event_triggers.append(trigger)
│ │ -                                        if not trigger_found:
│ │ -                                            new_event_triggers.append(event_trigger)
│ │ -                                    else:
│ │ -                                        new_event_triggers.append(event_trigger)
│ │ -                                    if len(new_event_triggers) != 0:
│ │ -                                        table["event_triggers"] = new_event_triggers
│ │ -                new_metadata[key] = value
│ │ -            elif key == "cron_triggers":
│ │ -                new_cron_triggers = []
│ │ -                crons_added = []
│ │ -                for new_cron_trigger in new_hasura_metadata["cron_triggers"]:
│ │ -                    trigger_found = False
│ │ -                    for cron_trigger in value:
│ │ -                        if cron_trigger.get("name", None) == new_cron_trigger["name"]:
│ │ -                            trigger_found = True
│ │ -                            break
│ │ -                        if cron_trigger.get("name", None) in crons_added:
│ │ -                            continue
│ │ -                        new_cron_triggers.append(cron_trigger)
│ │ -                        crons_added.append(cron_trigger.get("name", None))
│ │ -                    if not trigger_found:
│ │ -                        new_cron_triggers.append(new_cron_trigger)
│ │ -                new_metadata[key] = new_cron_triggers
│ │              else:
│ │                  new_metadata[key] = value
│ │  
│ │          for action in new_hasura_metadata.get("actions", []):
│ │ -            if action.get("definition", None) is None:
│ │ -                action["definition"] = {}
│ │ -            if action["definition"].get("request_transform", None) is None:
│ │ -                action["definition"]["request_transform"] = {}
│ │ -            action["definition"]["request_transform"]["body"] = {
│ │ -                "action": "transform",
│ │ -                "template": "{{" + f"$body?.input?.{action['name']}_input" + "}}"
│ │ -            }
│ │ -            action["definition"]["request_transform"]["method"] = "POST"
│ │ -            action["definition"]["request_transform"]["url"] = "{{$base_url}}" + f"/{action['name']}/"
│ │ -            action["definition"]["request_transform"]["query_params"] = action["definition"]["request_transform"].get(
│ │ -                "query_params", {})
│ │ -            action["definition"]["request_transform"]["template_engine"] = "Kriti"
│ │ -            action["definition"]["request_transform"]["version"] = 2
│ │              new_actions.append(action)
│ │  
│ │          for obj in new_hasura_metadata.get("custom_types", {}).get("objects", []):
│ │              new_objects.append(obj)
│ │  
│ │          for obj in new_hasura_metadata.get("custom_types", {}).get("input_objects", []):
│ │              new_input_objects.append(obj)
│ │ @@ -3092,354 +2200,47 @@
│ │          new_metadata["actions"] = new_actions
│ │          new_metadata["custom_types"] = {
│ │              "objects": new_objects,
│ │              "input_objects": new_input_objects
│ │          }
│ │          with open("hasura_metadata.json", "w") as f:
│ │              json.dump(new_metadata, f, indent=4)
│ │ +        self.do_export_hasura_metadata(None)
│ │  
│ │ -    def do_deploy_frontend(self, _):
│ │ -        env = self.get_env()
│ │ -        if env.flutter_app_name is None:
│ │ -            self.log("No flutter app name found. Skipping flutter app deployment.", level=logging.WARNING)
│ │ -            return
│ │ -        project_name = env.flutter_app_name
│ │ -        if not os.path.exists("microservices"):
│ │ -            os.mkdir("microservices")
│ │ -        if not os.path.exists(f"microservices/{project_name}_web"):
│ │ -            os.mkdir(f"microservices/{project_name}_web")
│ │ -        path = self.get_site_packages_path(submodule="pysura_ssr")
│ │ -        for root, dirs, files in os.walk(path):
│ │ -            for f in files:
│ │ -                if "__pycache__" in root or ".dart_tool" in root or ".idea" in root or ".git" in root:
│ │ -                    continue
│ │ -                if f in [".firebaserc", "firebase.json"]:
│ │ -                    shutil.copy(os.path.join(root, f), f"microservices/{project_name}_web")
│ │ -        if not os.path.isdir(f"microservices/{project_name}_web/build"):
│ │ -            os.mkdir(f"microservices/{project_name}_web/build")
│ │ -        else:
│ │ -            shutil.rmtree(f"microservices/{project_name}_web/build")
│ │ -            os.mkdir(f"microservices/{project_name}_web/build")
│ │ -
│ │ -        if os.path.exists(f"{project_name}/web"):
│ │ -            os.chdir(f"{project_name}")
│ │ -            cmd_str = "flutter build web --release"
│ │ -            self.log(f"Running command: {cmd_str}", level=logging.INFO)
│ │ -            os.system(cmd_str)
│ │ -            os.chdir("..")
│ │ -
│ │ -        src_dir = f"{project_name}/build/web"
│ │ -        dst_dir = f"microservices/{project_name}_web/build/web"
│ │ -        shutil.copytree(src_dir, dst_dir)
│ │ -        os.chdir(f"microservices/{project_name}_web")
│ │ -        with open(".firebaserc") as f:
│ │ -            data = json.load(f)
│ │ -        data["projects"]["default"] = env.project.name.split('/')[-1]
│ │ -        with open(".firebaserc", "w") as f:
│ │ -            json.dump(data, f, indent=4)
│ │ -        deploy_command = f"firebase deploy --only hosting"
│ │ -        self.log(deploy_command, level=logging.DEBUG)
│ │ -        with open("deploy.txt", "w") as f:
│ │ -            f.write(deploy_command)
│ │ -        os.system(deploy_command)
│ │ -        os.chdir("../..")
│ │ -        self.set_env(env)
│ │ -
│ │ -    def do_setup_pysura(self, recurse=0):
│ │ +    def do_setup_pysura(self, _):
│ │          """
│ │          Setups up a Pysura project
│ │          """
│ │ -        if recurse == "":
│ │ -            recurse = 0
│ │ -        else:
│ │ -            if recurse > 10:
│ │ -                self.log("Too many attempts. Aborting project setup.", level=logging.WARNING)
│ │ -                return
│ │ -        if not self.check_gcloud():
│ │ -            return
│ │ -        if not self.check_npm():
│ │ -            return
│ │ -        if not self.check_flutter():
│ │ -            return
│ │ -        if not self.check_firebase():
│ │ -            return
│ │ -        if not self.check_docker():
│ │ +        if not self.do_check_gcloud(None):
│ │              return
│ │          env = self.get_env()
│ │          if env.gcloud_logged_in is False:
│ │              self.do_gcloud_login()
│ │ -            env = self.get_env()
│ │ -        if not env.gcloud_logged_in:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        cmd_str = "gcloud auth configure-docker gcr.io"
│ │ -        self.log(f"Running command: {cmd_str}", level=logging.INFO)
│ │ -        os.system(cmd_str)
│ │          if env.organization is None:
│ │              self.do_gcloud_choose_organization(None)
│ │ -            env = self.get_env()
│ │ -        if env.project is None:
│ │ -            hasura_project_name = self.collect("Hasura project name: ")
│ │ -            if not self.confirm_loop(hasura_project_name):
│ │ -                self.log("Aborting project setup.", level=logging.WARNING)
│ │ -                return
│ │ -        else:
│ │ -            hasura_project_name = env.project.name.split("/")[-1]
│ │ -        hasura_project_name = hasura_project_name.replace("_", "-").replace(" ", "-")
│ │ -        if env.project is None:
│ │ -            self.gcloud_create_project(project_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        else:
│ │ -            cmd_str = f"gcloud config set project {env.project.name.split('/')[-1]}"
│ │ -            self.log(cmd_str, level=logging.DEBUG)
│ │ -            os.system(cmd_str)
│ │ -        if env.project is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.billing_account is None:
│ │ -            self.do_gcloud_link_billing_account()
│ │ -            env = self.get_env()
│ │ -        if env.billing_account is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.api_services is None:
│ │ -            self.gcloud_enable_api_services()
│ │ -            env = self.get_env()
│ │ -        if env.api_services is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.network is None:
│ │ -            self.gcloud_create_network(network_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.network is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.address is None:
│ │ -            self.gcloud_create_address(address_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.address is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.peering is None:
│ │ -            self.gcloud_create_vpc_peering(peering_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.peering is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.firewalls is None:
│ │ -            self.gcloud_create_firewall(firewall_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.firewalls is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.database_credential is None:
│ │ -            self.do_gcloud_create_database(database_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.database_credential is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.connector is None:
│ │ -            self.gcloud_create_serverless_connector(connector_id=hasura_project_name)
│ │ -            env = self.get_env()
│ │ -        if env.connector is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.hasura_service_account is None:
│ │ -            self.update_default_compute_engine_service_account()
│ │ -            env = self.get_env()
│ │ -        if env.hasura_service_account is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.hasura is None:
│ │ +        hasura_project_name = self.collect("Hasura project name: ")
│ │ +        if self.confirm_loop(hasura_project_name):
│ │ +            if env.project is None:
│ │ +                self.do_gcloud_create_project(project_id=hasura_project_name)
│ │ +            if env.billing_account is None:
│ │ +                self.do_gcloud_link_billing_account()
│ │ +            if env.api_services is None:
│ │ +                self.do_gcloud_enable_api_services(None)
│ │ +            if env.network is None:
│ │ +                self.do_gcloud_create_network(network_id=hasura_project_name)
│ │ +            if env.address is None:
│ │ +                self.do_gcloud_create_address(address_id=hasura_project_name)
│ │ +            if env.peering is None:
│ │ +                self.do_gcloud_create_vpc_peering(peering_id=hasura_project_name)
│ │ +            if env.firewalls is None:
│ │ +                self.do_gcloud_create_firewall(firewall_id=hasura_project_name)
│ │ +            if env.database_credential is None:
│ │ +                self.do_gcloud_create_database(database_id=hasura_project_name)
│ │ +            if env.connector is None:
│ │ +                self.do_gcloud_create_serverless_connector(connector_id=hasura_project_name)
│ │              self.do_gcloud_deploy_hasura()
│ │ +            self.do_gcloud_create_auth_service_account(None)
│ │              env = self.get_env()
│ │ -        if env.hasura is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        self.do_import_hasura_metadata(None)
│ │ -        if env.auth_service_account is None:
│ │ -            self.gcloud_create_auth_service_account()
│ │ -        env = self.get_env()
│ │ -        if env.auth_service_account is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.local_database_enabled is False:
│ │ -            self.enable_database_local(database_id=env.database.name.split("/")[-1])
│ │ -            env = self.get_env()
│ │ -        if env.local_database_enabled is False:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.default_user_table_created is False:
│ │ -            self.create_default_user_table()
│ │ -            env = self.get_env()
│ │ -        if env.default_user_table_created is False:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.firebase_attached is False:
│ │ -            self.attach_firebase()
│ │ -            env = self.get_env()
│ │ -        if env.firebase_attached is False:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.flutter_attached is False:
│ │ -            self.attach_flutter()
│ │ -            env = self.get_env()
│ │ -        if env.flutter_attached is False:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.firebase_auth_activated is False:
│ │ -            self.activate_firebase_auth()
│ │ -            env = self.get_env()
│ │ -        if env.firebase_auth_activated is False:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        if env.default_microservice is None:
│ │ -            self.do_deploy_microservice(microservice_name="default", default_init=True)
│ │ -            env = self.get_env()
│ │ -        if env.default_microservice is None:
│ │ -            return self.do_setup_pysura(recurse=recurse + 1)
│ │ -        self.do_export_hasura_metadata(None)
│ │ -        self.do_deploy_frontend(None)
│ │ -        env = self.get_env()
│ │ -        phone_wizard = self.collect(
│ │ -            "Would you like to add test phone numbers to your firebase project using the setup wizard? (y/n): "
│ │ -        )
│ │ -        if phone_wizard.strip().lower() == "y":
│ │ -            add_admin = True
│ │ -            add_user = True
│ │ -        else:
│ │ -            add_admin = False
│ │ -            add_user = False
│ │ -        test_phone_numbers = env.test_phone_numbers
│ │ -        if isinstance(test_phone_numbers, list):
│ │ -            for test_phone_number in test_phone_numbers:
│ │ -                if test_phone_number.role == "admin":
│ │ -                    add_admin = False
│ │ -                elif test_phone_number.role == "user":
│ │ -                    add_user = False
│ │ -        else:
│ │ -            test_phone_numbers = []
│ │ -
│ │ -        if add_admin:
│ │ -            self.log("Please add a test phone number to be granted ADMIN access in the firebase console.",
│ │ -                     level=logging.INFO)
│ │ -            self.log(f"https://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/authentication"
│ │ -                     f"/providers",
│ │ -                     level=logging.INFO
│ │ -                     )
│ │ -            admin_phone = self.collect("What phone number did you add? (Ex. +15555215551): ")
│ │ -            while not self.confirm_loop(admin_phone):
│ │ -                self.log("Please add a test phone number to be granted ADMIN access in the firebase console.",
│ │ -                         level=logging.INFO)
│ │ -                self.log(
│ │ -                    f"https://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/authentication"
│ │ -                    f"/providers",
│ │ -                    level=logging.INFO
│ │ -                )
│ │ -                admin_phone = self.collect("What phone number did you add? (Ex. +15555215551): ")
│ │ -            admin_code = self.collect(f"What is the verification code for {admin_phone} number?: ")
│ │ -            while not self.confirm_loop(admin_code):
│ │ -                admin_code = self.collect(f"What is the verification code for {admin_phone} number?: ")
│ │ -            self.log(f"Please login to your app with the phone number you just added!\n"
│ │ -                     f"https://{env.project.name.split('/')[-1]}.web.app/", level=logging.INFO)
│ │ -            ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -            while ready != "y":
│ │ -                ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -            user_data = self.execute_graphql(Gql.GET_USER_ID_BY_PHONE_GQL, {"phone_number": admin_phone})
│ │ -            if user_data.get("data", None) is None:
│ │ -                self.log("Could not find user, please try again.", level=logging.ERROR)
│ │ -                return
│ │ -            if len(user_data["data"]["user"]) == 0:
│ │ -                self.log("Could not find user, please try again.", level=logging.ERROR)
│ │ -                return
│ │ -            user_id = user_data["data"]["user"][0]["user_id"]
│ │ -            self.execute_graphql(Gql.UPDATE_USER_ROLE_GQL, {"user_id": user_id, "role": "admin"})
│ │ -            admin_number = TestPhoneNumber(
│ │ -                role="admin",
│ │ -                phone_number=admin_phone,
│ │ -                code=admin_code,
│ │ -                uid=user_id
│ │ -            )
│ │ -            test_phone_numbers.append(admin_number)
│ │ -
│ │ -        if add_user:
│ │ -            self.log("Please add a test phone number to be granted USER access in the firebase console.",
│ │ -                     level=logging.INFO)
│ │ -            self.log(f"https://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/authentication"
│ │ -                     f"/providers",
│ │ -                     level=logging.INFO
│ │ -                     )
│ │ -            user_phone = self.collect("What phone number did you add?: ")
│ │ -            while not self.confirm_loop(user_phone):
│ │ -                self.log("Please add a test phone number to be granted USER access in the firebase console.",
│ │ -                         level=logging.INFO)
│ │ -                self.log(
│ │ -                    f"https://console.firebase.google.com/project/{env.project.name.split('/')[-1]}/authentication"
│ │ -                    f"/providers",
│ │ -                    level=logging.INFO
│ │ -                )
│ │ -                user_phone = self.collect("What phone number did you add? (Ex. +15555215551): ")
│ │ -            user_code = self.collect(f"What is the verification code for {user_phone} number?: ")
│ │ -            while not self.confirm_loop(user_code):
│ │ -                user_code = self.collect(f"What is the verification code for {user_phone} number?: ")
│ │ -            self.log(f"Please login to your app with the phone number you just added!\n"
│ │ -                     f"https://{env.project.name.split('/')[-1]}.web.app/", level=logging.INFO)
│ │ -            ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -            while ready != "y":
│ │ -                ready = self.collect("Are you ready to continue? (y/n): ")
│ │ -            user_data = self.execute_graphql(Gql.GET_USER_ID_BY_PHONE_GQL, {"phone_number": user_phone})
│ │ -            if user_data.get("data", None) is None:
│ │ -                self.log("Could not find user, please try again.", level=logging.ERROR)
│ │ -                return
│ │ -            if len(user_data["data"]["user"]) == 0:
│ │ -                self.log("Could not find user, please try again.", level=logging.ERROR)
│ │ -                return
│ │ -            user_id = user_data["data"]["user"][0]["user_id"]
│ │ -            user_number = TestPhoneNumber(
│ │ -                role="user",
│ │ -                phone_number=user_phone,
│ │ -                code=user_code,
│ │ -                uid=user_id
│ │ -            )
│ │ -            test_phone_numbers.append(user_number)
│ │ -        if isinstance(test_phone_numbers, list) and len(test_phone_numbers) > 0:
│ │ -            env.test_phone_numbers = test_phone_numbers
│ │ -            self.set_env(env)
│ │ -        self.log(f"Pysura App is ready to run!, open the folder named {env.flutter_app_name} in Android Studio!",
│ │ -                 level=logging.INFO)
│ │ -        assert env.hasura is not None
│ │ -        assert env.hasura_metadata is not None
│ │ -        if env.hasura.microservice_urls is not None:
│ │ -            num_services = len(env.hasura.microservice_urls)
│ │ -        else:
│ │ -            num_services = 0
│ │ -        log_str = f"""
│ │ -Pysura Project Setup Complete!
│ │ -
│ │ -The default microservice can be found at:
│ │ -{env.default_microservice_url}/docs
│ │ -
│ │ -"""
│ │ -        actions = [action for action in env.hasura_metadata.actions if
│ │ -                   action.definition.handler == "{{HASURA_MICROSERVICE_URL}}"]
│ │ -        if len(actions) > 0:
│ │ -            log_str += f"""The default microservice has {len(actions)} actions:\n"""
│ │ -            for action in actions:
│ │ -                log_str += f"""\t{action.name}\n"""
│ │ -
│ │ -        log_str += f"""\nYou have {num_services} additional microservice(s) deployed."""
│ │ -        if num_services > 0:
│ │ -            log_str += "\n\tMicroservice URLs:\n"
│ │ -
│ │ -        for microservice_url in env.hasura.microservice_urls:
│ │ -            actions = [action for action in env.hasura_metadata.actions if
│ │ -                       action.definition.handler == microservice_url.url_wrapper]
│ │ -            log_str += f"""\t{microservice_url.url}\n"""
│ │ -            if len(actions) > 0:
│ │ -                log_str += f"""\t\t{len(actions)} action(s):\n"""
│ │ -                for action in actions:
│ │ -                    log_str += f"""\t\t\t{action.name}\n"""
│ │ -
│ │ -        log_str += f"""
│ │ -
│ │ -Your Hasura instance can be found at:
│ │ -{env.hasura_service.status.address.url}/console
│ │ -
│ │ -Your Hasura Admin Secret is:
│ │ -{env.hasura.HASURA_GRAPHQL_ADMIN_SECRET}
│ │ -
│ │ -The event secret for the all attached microservices is:
│ │ -{env.hasura.HASURA_EVENT_SECRET}
│ │ -
│ │ -You can find authorization tokens for your microservice by running your flutter application and logging in, navigate to
│ │ -the settings tab, and click the "Copy GraphQL Token" button and a bearer token will be copied to your clipboard.
│ │ -The bearer token will have the role of the user that is logged in.
│ │ -
│ │ -You can find your web application here:
│ │ -https://{env.project.name.split('/')[-1]}.web.app/
│ │ -
│ │ -
│ │ -"""
│ │ -
│ │ -        self.log(log_str, level=logging.INFO)
│ │ +            self.do_enable_database_local(database_id=env.database.name.split("/")[-1])
│ │ +            self.do_create_default_user_table(None)
│ │ +            self.do_attach_firebase(None)
│ │ +            self.do_deploy_microservice(microservice_name="default")
│ │ ├── encoding
│ │ │ @@ -1 +1 @@
│ │ │ -utf-8
│ │ │ +us-ascii
│ │   --- pysura-0.99.81/pysura/library_data/pysura_auth/main.py
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_auth/main.py
│ │┄ Files 22% similar despite different names
│ │ @@ -1,16 +1,17 @@
│ │ +from flask.wrappers import Request
│ │  import firebase_admin
│ │ -from firebase_admin import auth
│ │ +import functions_framework
│ │  from google.cloud import secretmanager
│ │  from python_graphql_client import GraphqlClient
│ │  from requests.exceptions import ConnectionError
│ │  import logging
│ │  
│ │  PROJECT_ID = "PROJECT_ID_HERE"
│ │ -app = firebase_admin.initialize_app()
│ │ +firebase_admin.initialize_app()
│ │  
│ │  
│ │  def get_secret_by_id(secret_id, version_id="latest"):
│ │      client = secretmanager.SecretManagerServiceClient()
│ │      name = f"projects/{PROJECT_ID}/secrets/{secret_id}/versions/{version_id}"
│ │      response = client.access_secret_version(name=name)
│ │      return response.payload.data.decode("UTF-8")
│ │ @@ -58,45 +59,34 @@
│ │          response = client.execute(headers=headers, query=gql, variables=variables)
│ │      except Exception as e:
│ │          logging.error(e)
│ │      finally:
│ │          return response
│ │  
│ │  
│ │ -def on_user_create(data, _):
│ │ +def on_user_create(data, context):
│ │ +    print(data)
│ │ +    print(context)
│ │      try:
│ │          user_uid = data["uid"]
│ │ -        user_phone = data.get("phoneNumber", None)
│ │ -        if user_phone is None:
│ │ -            user_phone = data.get("email", None)
│ │ -        if user_phone is None:
│ │ -            print("No phone or email")
│ │ -            return 400, "ERROR"
│ │ +        user_phone = data["phoneNumber"]
│ │          variables = {"user_id": user_uid, "user_phone": user_phone}
│ │          response = execute(GQL.CREATE_USER, variables)
│ │          if response.get("errors", None) is not None:
│ │              print(response)
│ │              return response
│ │ -        auth.set_custom_user_claims(
│ │ -            user_uid,
│ │ -            {
│ │ -                "https://hasura.io/jwt/claims": {
│ │ -                    "x-hasura-allowed-roles": ["user"],
│ │ -                    "x-hasura-default-role": "user",
│ │ -                    "x-hasura-user-id": user_uid,
│ │ -                }
│ │ -            }
│ │ -        )
│ │      except Exception as e:
│ │          print(e)
│ │          return 500, "ERROR"
│ │      return 200, "OK"
│ │  
│ │  
│ │ -def on_user_delete(data, _):
│ │ +def on_user_delete(data, context):
│ │ +    print(data)
│ │ +    print(context)
│ │      try:
│ │          user_uid = data["uid"]
│ │          variables = {"user_id": user_uid}
│ │          response = execute(GQL.DELETE_USER, variables)
│ │          if response.get("errors", None) is not None:
│ │              print(response)
│ │              return response
│ │   --- pysura-0.99.81/pysura/library_data/pysura_auth/requirements.txt
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_auth/requirements.txt
│ │┄ Files identical despite different names
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/common/app_route.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/main.dart
│ │┄ Files 24% similar despite different names
│ │ @@ -1,83 +1,81 @@
│ │ +import 'package:firebase_auth/firebase_auth.dart';
│ │ +import 'package:firebase_core/firebase_core.dart';
│ │ +import 'package:flutter/material.dart';
│ │  import 'package:get/get.dart';
│ │  
│ │ -import '../pages/misc/splash/splash_page.dart';
│ │ -import '../pages/misc/splash/splash_page_controller.dart';
│ │ -import '../pages/misc/error_page.dart';
│ │ -import '../pages/misc/loading_page.dart';
│ │ -import '../pages/auth/login_page.dart';
│ │ -import '../pages/auth/login_page_controller.dart';
│ │ -import '../pages/main/main_page.dart';
│ │ -import '../pages/main/main_page_controller.dart';
│ │ -import '../pages/main/main_page_middleware.dart';
│ │ -import '../pages/main/home/home_page_controller.dart';
│ │ -import '../pages/main/action/action_page_controller.dart';
│ │ -import '../pages/main/settings/settings_page.dart';
│ │ -import '../pages/main/settings/settings_page_controller.dart';
│ │ -
│ │ -class AppRoute {
│ │ -  static const String kSplashRoute = '/splash';
│ │ -  static const String kLoginRoute = '/login';
│ │ -  static const String kMainRoute = '/main/';
│ │ -  static const String kMainTabRoute = '/main/:tab';
│ │ -  static const String kSettingsRoute = '/settings';
│ │ -  static const String kErrorRoute = '/error';
│ │ -  static const String kLoadingRoute = '/loading';
│ │ -
│ │ -  static const String kHomeTab = 'home';
│ │ -  static const String kActionTab = 'action';
│ │ -
│ │ -  static List<GetPage> setupPageRoutes() {
│ │ -    return [
│ │ -      GetPage(
│ │ -        name: kSplashRoute,
│ │ -        page: () => const SplashPage(),
│ │ -        binding: BindingsBuilder(() {
│ │ -          Get.put(SplashPageController());
│ │ -        }),
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kLoginRoute,
│ │ -        page: () => const LoginPage(),
│ │ -        binding: BindingsBuilder(() {
│ │ -          Get.put(LoginPageController());
│ │ -        }),
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kMainRoute,
│ │ -        page: () => const MainPage(),
│ │ -        binding: BindingsBuilder(() {
│ │ -          Get.put(HomePageController());
│ │ -          Get.put(ActionPageController());
│ │ -          Get.put(MainPageController());
│ │ -        }),
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kMainTabRoute,
│ │ -        page: () => const MainPage(),
│ │ -        binding: BindingsBuilder(() {
│ │ -          Get.put(HomePageController());
│ │ -          Get.put(ActionPageController());
│ │ -          Get.put(MainPageController());
│ │ -        }),
│ │ -        middlewares: [
│ │ -          MainPageMiddleware(),
│ │ -        ],
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kSettingsRoute,
│ │ -        page: () => const SettingsPage(),
│ │ -        binding: BindingsBuilder(() {
│ │ -          Get.put(SettingsPageController());
│ │ -        }),
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kErrorRoute,
│ │ -        page: () => const ErrorPage(),
│ │ -      ),
│ │ -      GetPage(
│ │ -        name: kLoadingRoute,
│ │ -        page: () => const LoadingPage(),
│ │ +import 'pages/auth/login_page.dart';
│ │ +import 'pages/auth/login_page_controller.dart';
│ │ +import 'pages/main/main_page.dart';
│ │ +import 'pages/main/main_page_controller.dart';
│ │ +import 'pages/misc/error_page.dart';
│ │ +import 'pages/misc/loading_page.dart';
│ │ +import 'common/constants.dart';
│ │ +import 'common/styles.dart';
│ │ +import 'controllers/auth_controller.dart';
│ │ +import 'controllers/graphql_controller.dart';
│ │ +import 'widgets/graphql_provider_widget.dart';
│ │ +import 'firebase_options.dart';
│ │ +
│ │ +void main() {
│ │ +  WidgetsFlutterBinding.ensureInitialized();
│ │ +
│ │ +  Get.put(AuthController());
│ │ +  Get.put(GraphqlController());
│ │ +
│ │ +  runApp(GraphQLProviderWidget(
│ │ +    child: MyApp(),
│ │ +  ));
│ │ +}
│ │ +
│ │ +class MyApp extends StatelessWidget {
│ │ +  final Future<FirebaseApp> _initApp = Firebase.initializeApp(
│ │ +        options: DefaultFirebaseOptions.currentPlatform,
│ │ +  );
│ │ +
│ │ +  MyApp({super.key});
│ │ +
│ │ +  // This widget is the root of your application.
│ │ +  @override
│ │ +  Widget build(BuildContext context) {
│ │ +    return GetMaterialApp(
│ │ +      theme: kMainTheme,
│ │ +      debugShowCheckedModeBanner: false,
│ │ +      home: FutureBuilder(
│ │ +        future: _initApp,
│ │ +        builder: (context, appSnapshot) {
│ │ +          if (appSnapshot.hasError) {
│ │ +            return ErrorPage(
│ │ +              message: appSnapshot.error.toString(),
│ │ +            );
│ │ +          }
│ │ +          if (appSnapshot.connectionState == ConnectionState.waiting) {
│ │ +            return const LoadingPage();
│ │ +          }
│ │ +          return appSnapshot.connectionState != ConnectionState.done
│ │ +              ? const ErrorPage(message: 'No internet connection.')
│ │ +              : StreamBuilder(
│ │ +                  stream: FirebaseAuth.instance.authStateChanges(),
│ │ +                  builder: (ctx, userSnapshot) {
│ │ +                    if (userSnapshot.hasData) {
│ │ +                      _deleteAuthPageControllers();
│ │ +                      authController.user = FirebaseAuth.instance.currentUser!;
│ │ +                      return const MainPage(); // changing this will change the default screen
│ │ +                    } else {
│ │ +                      _deleteMainPageControllers();
│ │ +                      return const LoginPage();
│ │ +                    }
│ │ +                  },
│ │ +                );
│ │ +        },
│ │        ),
│ │ -    ];
│ │ +    );
│ │ +  }
│ │ +
│ │ +  _deleteAuthPageControllers() {
│ │ +    Get.delete<LoginPageController>();
│ │ +  }
│ │ +
│ │ +  _deleteMainPageControllers() {
│ │ +    Get.delete<MainPageController>();
│ │    }
│ │  }
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/auth_controller.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/controllers/auth_controller.dart
│ │┄ Files 17% similar despite different names
│ │ @@ -1,54 +1,20 @@
│ │ -import 'dart:async';
│ │ -
│ │  import 'package:firebase_auth/firebase_auth.dart';
│ │  import 'package:get/get.dart';
│ │  
│ │ -import '../common/utils.dart';
│ │ -import '../common/app_route.dart';
│ │ -
│ │  class AuthController extends GetxController {
│ │ -  final _user = Rx<User?>(null);
│ │ -  User? get user => _user.value;
│ │ -  set user(User? value) => _user.value = value;
│ │ -
│ │ -  var signedIn = false.obs;
│ │ -
│ │ -  StreamSubscription? _authStateChangesSubscription;
│ │ +  static AuthController instance = Get.find();
│ │  
│ │ -  @override
│ │ -  onInit() {
│ │ -    super.onInit();
│ │ -    appLog('AuthController onInit()');
│ │ -  }
│ │ -
│ │ -  initAuth() {
│ │ -    user = FirebaseAuth.instance.currentUser;
│ │ +  final _user = Rx<User?>(null);
│ │  
│ │ -    _authStateChangesSubscription =
│ │ -        FirebaseAuth.instance.authStateChanges().listen((user) {
│ │ -      appLog('FirebaseAuth.authStateChanges()');
│ │ -      this.user = user;
│ │ -      if (user == null) {
│ │ -        Get.offAllNamed(AppRoute.kLoginRoute);
│ │ -      } else {
│ │ -        Get.offAllNamed(AppRoute.kMainRoute);
│ │ -      }
│ │ -    });
│ │ -  }
│ │ +  User? get user => _user.value;
│ │  
│ │ -  @override
│ │ -  void onClose() {
│ │ -    appLog('AuthController onClose()');
│ │ -    _authStateChangesSubscription?.cancel();
│ │ -    super.onClose();
│ │ -  }
│ │ +  set user(User? value) => _user.value = value;
│ │  
│ │ -  Future<void> verifyPhoneNumber(
│ │ -    String phoneNumber, {
│ │ +  Future<void> verifyPhoneNumber(String phoneNumber, {
│ │      required Function(String) onError,
│ │      required Function(String) onSmsReady,
│ │    }) async {
│ │      final auth = FirebaseAuth.instance;
│ │      await auth.verifyPhoneNumber(
│ │        phoneNumber: phoneNumber,
│ │        verificationCompleted: (PhoneAuthCredential credential) async {
│ │ @@ -66,24 +32,18 @@
│ │          // Update the UI - wait for the user to enter the SMS code
│ │          onSmsReady(verificationId);
│ │        },
│ │        codeAutoRetrievalTimeout: (String verificationId) {},
│ │      );
│ │    }
│ │  
│ │ -  Future<String?> signInWithSmsCode(
│ │ -      String verificationId, String smsCode) async {
│ │ +  Future<void> signInWithSmsCode(String verificationId, String smsCode) async {
│ │      final auth = FirebaseAuth.instance;
│ │      PhoneAuthCredential credential = PhoneAuthProvider.credential(
│ │          verificationId: verificationId, smsCode: smsCode);
│ │ -    try {
│ │ -      await auth.signInWithCredential(credential);
│ │ -    } catch (e) {
│ │ -      return e.toString();
│ │ -    }
│ │ -    return null;
│ │ +    await auth.signInWithCredential(credential);
│ │    }
│ │  
│ │    Future<void> signOut() async {
│ │      await FirebaseAuth.instance.signOut();
│ │    }
│ │ -}
│ │ +}
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/controllers/graphql_controller.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/controllers/graphql_controller.dart
│ │┄ Files 17% similar despite different names
│ │ @@ -1,76 +1,77 @@
│ │  import 'package:firebase_auth/firebase_auth.dart';
│ │  import 'package:get/get.dart';
│ │  import 'package:graphql_flutter/graphql_flutter.dart';
│ │  
│ │ -import '../common/constants.dart';
│ │ -import '../common/utils.dart';
│ │ +import '/common/constants.dart';
│ │  
│ │ -class GraphQLController extends GetxController {
│ │ +class GraphqlController extends GetxController {
│ │ +  static GraphqlController instance = Get.find();
│ │    final _client = Rxn<GraphQLClient>();
│ │ +
│ │    GraphQLClient? get client {
│ │      if (_client.value == null) {
│ │        client = _graphqlClient();
│ │      }
│ │      return _client.value;
│ │    }
│ │  
│ │    set client(GraphQLClient? value) => _client.value = value;
│ │  
│ │    final _token = Rxn<String>();
│ │ +
│ │    String? get token => _token.value;
│ │ +
│ │    set token(String? value) => _token.value = value;
│ │  
│ │    GraphQLClient _graphqlClient() {
│ │ -    final httpLink = HttpLink(Constants.kGraphqlHttpUrl);
│ │ +    final httpLink = HttpLink(kGraphqlHttpUrl);
│ │  
│ │      final authLink = AuthLink(
│ │        // ignore: undefined_identifier
│ │        // this gets called when the user makes a graphql request
│ │ -      getToken: getToken,
│ │ +      getToken: () async {
│ │ +        var user = FirebaseAuth.instance.currentUser;
│ │ +        if (user == null) {
│ │ +          return "";
│ │ +        }
│ │ +
│ │ +        var token = await user.getIdTokenResult(true);
│ │ +        this.token = "Bearer ${token.token!}";
│ │ +        return "Bearer ${token.token!}";
│ │ +      },
│ │      );
│ │  
│ │      var link = authLink.concat(httpLink);
│ │ -    if (Constants.kEnableWebsockets) {
│ │ -      final websocketLink = WebSocketLink(Constants.kGraphqlWsUrl,
│ │ +    if (kEnableWebsockets) {
│ │ +      final websocketLink = WebSocketLink(kGraphqlWsUrl,
│ │            config: SocketClientConfig(
│ │                autoReconnect: true,
│ │                inactivityTimeout: const Duration(seconds: 30),
│ │                initialPayload: () async {
│ │                  return {
│ │                    "headers": {
│ │                      "Authorization": await authLink.getToken(),
│ │                    }
│ │                  };
│ │                }));
│ │  
│ │        link = Link.split(
│ │ -        (request) => request.isSubscription,
│ │ +            (request) => request.isSubscription,
│ │          websocketLink,
│ │          link,
│ │        );
│ │      }
│ │  
│ │      return GraphQLClient(
│ │        link: link,
│ │        cache: GraphQLCache(),
│ │      );
│ │    }
│ │  
│ │    @override
│ │    void onInit() {
│ │      super.onInit();
│ │ -    appLog("GraphqlController onInit");
│ │ +    print("GraphqlController onInit");
│ │      client = _graphqlClient();
│ │    }
│ │ -
│ │ -  Future<String> getToken() async {
│ │ -    var user = FirebaseAuth.instance.currentUser;
│ │ -    if (user == null) {
│ │ -      return "";
│ │ -    }
│ │ -
│ │ -    var token = await user.getIdTokenResult(true);
│ │ -    this.token = "Bearer ${token.token!}";
│ │ -    return "Bearer ${token.token!}";
│ │ -  }
│ │ -}
│ │ +}
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/auth/login_page.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/auth/login_page.dart
│ │┄ Files 20% similar despite different names
│ │ @@ -1,160 +1,145 @@
│ │  import 'package:flutter/material.dart';
│ │  import 'package:google_fonts/google_fonts.dart';
│ │  import 'package:get/get.dart';
│ │  
│ │ -import 'login_page_controller.dart';
│ │ -import '../../widgets/primary_button.dart';
│ │ -import '../../widgets/secondary_button.dart';
│ │ -import '../../common/constants.dart';
│ │ -import '../../widgets/phone_number_field.dart';
│ │ -import '../../common/app_text_style.dart';
│ │ -import '../../common/app_color.dart';
│ │ +import '/common/styles.dart';
│ │ +import '/pages/auth/login_page_controller.dart';
│ │ +import '/widgets/primary_button.dart';
│ │ +import '/widgets/secondary_button.dart';
│ │ +import '/common/constants.dart';
│ │ +import '/widgets/phone_number_field.dart';
│ │  
│ │  class LoginPage extends StatelessWidget {
│ │    const LoginPage({
│ │      Key? key,
│ │    }) : super(key: key);
│ │  
│ │    @override
│ │    Widget build(BuildContext context) {
│ │ -    final LoginPageController controller = Get.find();
│ │ -    return Obx(
│ │ -      () => Scaffold(
│ │ -        body: SafeArea(
│ │ -          child: Container(
│ │ -            padding: const EdgeInsets.all(20),
│ │ +    final LoginPageController controller = Get.put(LoginPageController());
│ │ +    return Scaffold(
│ │ +      body: Obx(() =>
│ │ +          Container(
│ │ +            constraints: const BoxConstraints(maxWidth: 400),
│ │ +            padding: const EdgeInsets.all(24),
│ │              child: Column(
│ │                mainAxisAlignment: MainAxisAlignment.center,
│ │                crossAxisAlignment: CrossAxisAlignment.stretch,
│ │                children: [
│ │                  const Spacer(),
│ │ -
│ │ -                /// Title and App Name
│ │                  Text(
│ │                    'Login',
│ │ -                  style: GoogleFonts.poppins(
│ │ -                    textStyle: AppTextStyle.displaySmall,
│ │ -                    color: AppColor.primary,
│ │ +                  style: GoogleFonts.roboto(
│ │ +                    fontSize: 30,
│ │ +                    fontWeight: FontWeight.bold,
│ │                    ),
│ │                  ),
│ │ -                const SizedBox(height: 16),
│ │                  Text(
│ │ -                  'Welcome to ${Constants.kAppName}',
│ │ +                  'Welcome to $kAppName',
│ │                    style: GoogleFonts.poppins(
│ │ -                    textStyle: AppTextStyle.headlineSmall,
│ │ -                    color: AppColor.primary,
│ │ +                    fontSize: 18,
│ │ +                    color: kDarkGrey,
│ │                    ),
│ │                  ),
│ │ -                const SizedBox(height: 32),
│ │ -
│ │ -                /// Phone number text field and Code request button
│ │ +                const SizedBox(
│ │ +                  height: 32,
│ │ +                ),
│ │                  Row(
│ │                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
│ │ -                  mainAxisSize: MainAxisSize.max,
│ │                    children: [
│ │ -                    Expanded(
│ │ +                    Flexible(
│ │ +                      flex: 3,
│ │                        child: PhoneNumberField(
│ │                          onNumberChanged: (number) {
│ │                            controller.phoneNumber = number ?? '';
│ │                          },
│ │                        ),
│ │                      ),
│ │ -                    Row(
│ │ -                      children: [
│ │ -                        const SizedBox(
│ │ -                          width: 20,
│ │ -                        ),
│ │ -                        SizedBox(
│ │ -                          width: 90,
│ │ -                          child: SecondaryButton(
│ │ -                            title: 'Code',
│ │ -                            textStyle: GoogleFonts.poppins(
│ │ -                              textStyle: AppTextStyle.titleMedium,
│ │ -                            ),
│ │ -                            onPressed: () {
│ │ -                              controller.requestSmsCode();
│ │ -                            },
│ │ -                            isBusy: controller.codeRequested,
│ │ -                          ),
│ │ -                        ),
│ │ -                      ],
│ │ +                    const SizedBox(
│ │ +                      width: 16,
│ │ +                    ),
│ │ +                    Flexible(
│ │ +                      flex: 1,
│ │ +                      child: SecondaryButton(
│ │ +                        title: 'Code',
│ │ +                        fontSize: 14,
│ │ +                        onPressed: () {
│ │ +                          controller.requestSmsCode();
│ │ +                        },
│ │ +                        isBusy: controller.codeRequested,
│ │ +                        expanded: true,
│ │ +                      ),
│ │                      ),
│ │                    ],
│ │                  ),
│ │ -                const SizedBox(height: 20),
│ │ -
│ │ -                /// SMS Code input box and Login button
│ │ +                const SizedBox(
│ │ +                  height: 16,
│ │ +                ),
│ │                  Opacity(
│ │                    opacity: controller.shouldShowSmsCodeBox ? 1 : 0,
│ │                    child: Column(
│ │                      children: [
│ │                        TextField(
│ │                          controller: controller.smsCodeController,
│ │ -                        decoration: AppTextStyle.generateTextFieldDecoration(
│ │ -                            'SMS Code', ''),
│ │ +                        decoration: generateTextFieldDecoration(
│ │ +                            'Code', 'Enter your SMS code'),
│ │                          keyboardType: TextInputType.number,
│ │                          textAlign: TextAlign.center,
│ │ -                        style: GoogleFonts.poppins(
│ │ -                          textStyle: AppTextStyle.displaySmall,
│ │ +                        style: GoogleFonts.roboto(
│ │ +                          fontSize: 24,
│ │ +                          color: kBlack,
│ │                          ),
│ │                        ),
│ │                        const SizedBox(
│ │ -                        height: 20,
│ │ +                        height: 32,
│ │                        ),
│ │                        SizedBox(
│ │                          height: 60,
│ │ -                        width: double.infinity,
│ │                          child: PrimaryButton(
│ │                            title: 'Login',
│ │ -                          textStyle: GoogleFonts.poppins(
│ │ -                            textStyle: AppTextStyle.headlineMedium,
│ │ -                          ),
│ │ +                          fontSize: 18,
│ │                            onPressed: () {
│ │                              controller.signIn();
│ │                            },
│ │                            isBusy: controller.signInRequested,
│ │ +                          expanded: true,
│ │                          ),
│ │                        ),
│ │                      ],
│ │                    ),
│ │                  ),
│ │                  const Spacer(),
│ │ -
│ │ -                /// Privacy policy link
│ │                  Padding(
│ │ -                  padding: const EdgeInsets.only(bottom: 20.0),
│ │ +                  padding: const EdgeInsets.only(bottom: 32.0),
│ │                    child: InkWell(
│ │                      onTap: () {
│ │ -                      controller.openPrivacyPolicy();
│ │ +                      print('Open privacy policy webpage');
│ │                      },
│ │ -                    child: RichText(
│ │ -                      textAlign: TextAlign.center,
│ │ -                      text: TextSpan(
│ │ -                        style: GoogleFonts.poppins(
│ │ -                          textStyle: AppTextStyle.bodySmall,
│ │ -                          color: AppColor.secondary,
│ │ -                        ),
│ │ -                        children: const [
│ │ -                          TextSpan(
│ │ -                            text: 'By logging in, you agree to our\n',
│ │ +                    child: Center(
│ │ +                      child: RichText(
│ │ +                        text: TextSpan(
│ │ +                          style: GoogleFonts.poppins(
│ │ +                            color: kPrimaryColor,
│ │ +                            fontSize: 12,
│ │ +                            fontWeight: FontWeight.normal,
│ │                            ),
│ │ -                          TextSpan(
│ │ -                            text: 'Privacy policy and Terms of use',
│ │ -                            style: TextStyle(
│ │ -                              fontWeight: FontWeight.bold,
│ │ -                              decoration: TextDecoration.underline,
│ │ -                            ),
│ │ -                          ),
│ │ -                        ],
│ │ +                          children: const [
│ │ +                            TextSpan(text: 'By logging in, you agree to our\n'),
│ │ +                            TextSpan(
│ │ +                                text: 'Privacy policy and Terms of use',
│ │ +                                style: TextStyle(
│ │ +                                  fontWeight: FontWeight.bold,
│ │ +                                  decoration: TextDecoration.underline,
│ │ +                                )),
│ │ +                          ],
│ │ +                        ),
│ │                        ),
│ │                      ),
│ │                    ),
│ │                  ),
│ │                ],
│ │              ),
│ │ -          ),
│ │ -        ),
│ │ -      ),
│ │ +          )),
│ │      );
│ │    }
│ │ -}
│ │ +}
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/pages/auth/login_page_controller.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/pages/auth/login_page_controller.dart
│ │┄ Files 18% similar despite different names
│ │ @@ -1,80 +1,78 @@
│ │  import 'package:get/get.dart';
│ │  import 'package:flutter/material.dart';
│ │  
│ │ -import '../../common/utils.dart';
│ │ -import '../../controllers/auth_controller.dart';
│ │ -import '../../common/popups.dart';
│ │ +import '/common/popups.dart';
│ │ +import '/common/constants.dart';
│ │  
│ │  class LoginPageController extends GetxController {
│ │    final _codeRequested = false.obs;
│ │ +
│ │    bool get codeRequested => _codeRequested.value;
│ │ +
│ │    set codeRequested(bool value) => _codeRequested.value = value;
│ │  
│ │    final _shouldShowSmsCodeBox = false.obs;
│ │ +
│ │    bool get shouldShowSmsCodeBox => _shouldShowSmsCodeBox.value;
│ │ +
│ │    set shouldShowSmsCodeBox(bool value) => _shouldShowSmsCodeBox.value = value;
│ │  
│ │    final _signInRequested = false.obs;
│ │ +
│ │    bool get signInRequested => _signInRequested.value;
│ │ +
│ │    set signInRequested(bool value) => _signInRequested.value = value;
│ │  
│ │    final _phoneNumber = ''.obs;
│ │ +
│ │    String get phoneNumber => _phoneNumber.value;
│ │ +
│ │    set phoneNumber(String value) => _phoneNumber.value = value;
│ │  
│ │    final _verificationId = ''.obs;
│ │ +
│ │    String get verificationId => _verificationId.value;
│ │ +
│ │    set verificationId(String value) => _verificationId.value = value;
│ │  
│ │    final _smsCodeController = TextEditingController().obs;
│ │ +
│ │    TextEditingController get smsCodeController => _smsCodeController.value;
│ │ +
│ │    set smsCodeController(TextEditingController value) =>
│ │        _smsCodeController.value = value;
│ │  
│ │ -  final authController = Get.find<AuthController>();
│ │ -
│ │    @override
│ │    onInit() {
│ │      super.onInit();
│ │ -    appLog('LoginPageController onInit()');
│ │ +    print('LoginPageController onInit()');
│ │    }
│ │  
│ │    @override
│ │    dispose() {
│ │ -    appLog('LoginPageController dispose()');
│ │ +    print('LoginPageController dispose()');
│ │      smsCodeController.dispose();
│ │      super.dispose();
│ │    }
│ │  
│ │    requestSmsCode() {
│ │      codeRequested = true;
│ │ -    shouldShowSmsCodeBox = false;
│ │      authController.verifyPhoneNumber(phoneNumber, onError: (errorMsg) {
│ │        showSimpleSnackBar(errorMsg);
│ │        codeRequested = false;
│ │        shouldShowSmsCodeBox = false;
│ │ +      codeRequested = false;
│ │      }, onSmsReady: (verificationId) {
│ │        this.verificationId = verificationId;
│ │ -      codeRequested = false;
│ │        shouldShowSmsCodeBox = true;
│ │ +      codeRequested = false;
│ │      });
│ │    }
│ │  
│ │ -  signIn() async {
│ │ +  signIn() {
│ │      final smsCode = smsCodeController.text;
│ │      if (smsCode.isEmpty) return;
│ │ +    authController.signInWithSmsCode(verificationId, smsCode);
│ │      signInRequested = true;
│ │ -    final error =
│ │ -        await authController.signInWithSmsCode(verificationId, smsCode);
│ │ -    if (error != null) {
│ │ -      showSimpleSnackBar(error);
│ │ -      codeRequested = false;
│ │ -      signInRequested = false;
│ │ -    }
│ │ -  }
│ │ -
│ │ -  openPrivacyPolicy() {
│ │ -    // TODO: - link privacy policy page
│ │ -    showSimpleSnackBar('Link your privacy policy page here');
│ │    }
│ │ -}
│ │ +}
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/graphql_provider_widget.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/graphql_provider_widget.dart
│ │┄ Files 10% similar despite different names
│ │ @@ -1,30 +1,26 @@
│ │  import 'package:flutter/material.dart';
│ │  import 'package:graphql_flutter/graphql_flutter.dart';
│ │ -import 'package:get/get.dart';
│ │  
│ │ -import '../common/app_color.dart';
│ │ -import '../controllers/graphql_controller.dart';
│ │ +import '/common/constants.dart';
│ │  
│ │  class GraphQLProviderWidget extends StatelessWidget {
│ │    final Widget child;
│ │ +
│ │    const GraphQLProviderWidget({
│ │      super.key,
│ │      required this.child,
│ │    });
│ │  
│ │    @override
│ │    Widget build(BuildContext context) {
│ │ -    final graphqlController = Get.find<GraphQLController>();
│ │      final graphqlClient = graphqlController.client;
│ │      if (graphqlClient == null) {
│ │ -      return Center(
│ │ -        child: CircularProgressIndicator(
│ │ -          color: AppColor.primary,
│ │ -        ),
│ │ +      return const Center(
│ │ +        child: CircularProgressIndicator(),
│ │        );
│ │      }
│ │      final client = ValueNotifier<GraphQLClient>(
│ │        graphqlClient,
│ │      );
│ │  
│ │      return GraphQLProvider(
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/lib/widgets/phone_number_field.dart
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/lib/widgets/phone_number_field.dart
│ │┄ Files 13% similar despite different names
│ │ @@ -1,45 +1,56 @@
│ │ -import 'package:flutter/material.dart';
│ │ +import 'package:flutter/cupertino.dart';
│ │  import 'package:google_fonts/google_fonts.dart';
│ │  import 'package:phone_form_field/phone_form_field.dart';
│ │  
│ │ -import '../common/app_text_style.dart';
│ │ +import '/common/styles.dart';
│ │  
│ │  class PhoneNumberField extends StatelessWidget {
│ │    final Function(String?)? onNumberChanged;
│ │  
│ │    const PhoneNumberField({
│ │      super.key,
│ │      this.onNumberChanged,
│ │    });
│ │  
│ │    @override
│ │    Widget build(BuildContext context) {
│ │      return PhoneFormField(
│ │ -      controller: null, // controller & initialValue value
│ │ -      initialValue: null, // can't be supplied simultaneously
│ │ -      shouldFormat: true, // default
│ │ -      defaultCountry: IsoCode.US, // default
│ │ -      autovalidateMode: AutovalidateMode.disabled, // default
│ │ -      decoration: AppTextStyle.generateTextFieldDecoration(
│ │ -          'Phone', 'Enter your phone number'),
│ │ +      controller: null,
│ │ +      // controller & initialValue value
│ │ +      initialValue: null,
│ │ +      // can't be supplied simultaneously
│ │ +      shouldFormat: true,
│ │ +      // default
│ │ +      defaultCountry: IsoCode.US,
│ │ +      // default
│ │ +      autovalidateMode: AutovalidateMode.disabled,
│ │ +      // default
│ │ +      decoration:
│ │ +          generateTextFieldDecoration('Phone', 'Enter your phone number'),
│ │        // validator: PhoneValidator.validMobile(), // default PhoneValidator.valid()
│ │ -      isCountryChipPersistent: false, // default
│ │ -      isCountrySelectionEnabled: true, // default
│ │ +      isCountryChipPersistent: false,
│ │ +      // default
│ │ +      isCountrySelectionEnabled: true,
│ │ +      // default
│ │        countrySelectorNavigator: const CountrySelectorNavigator.bottomSheet(),
│ │ -      showFlagInInput: true, // default
│ │ -      flagSize: 16, // default
│ │ -      enabled: true, // default
│ │ +      showFlagInInput: true,
│ │ +      // default
│ │ +      flagSize: 16,
│ │ +      // default
│ │ +      enabled: true,
│ │ +      // default
│ │        autofocus: true,
│ │ -      style: GoogleFonts.poppins(
│ │ -        textStyle: Theme.of(context).textTheme.titleMedium,
│ │ +      style: GoogleFonts.roboto(
│ │ +        fontSize: 16,
│ │ +        color: kBlack,
│ │ +      ),
│ │ +      countryCodeStyle: GoogleFonts.roboto(
│ │ +        fontSize: 16,
│ │ +        color: kDarkGrey,
│ │        ),
│ │ -      countryCodeStyle: GoogleFonts.poppins(
│ │ -          // fontSize: 16,
│ │ -          // color: kDarkGrey,
│ │ -          ),
│ │        onChanged: (PhoneNumber? number) {
│ │          onNumberChanged?.call(number?.international);
│ │        },
│ │      );
│ │    }
│ │  }
│ │   --- pysura-0.99.81/pysura/library_data/pysura_frontend/pubspec.yaml
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_frontend/pubspec.yaml
│ │┄ Files 6% similar despite different names
│ │ @@ -13,27 +13,24 @@
│ │      sdk: flutter
│ │  
│ │  
│ │    # The following adds the Cupertino Icons font to your application.
│ │    # Use with the CupertinoIcons class for iOS style icons.
│ │    cupertino_icons: ^1.0.2
│ │    firebase_core: ^2.7.1
│ │ -  firebase_core_web: ^2.3.0
│ │ +  firebase_core_web: ^2.2.2
│ │    firebase_auth: ^4.2.10
│ │    graphql_flutter: ^5.1.2
│ │    google_fonts: ^4.0.3
│ │    google_sign_in: ^5.2.1
│ │    get: ^4.6.5
│ │    phone_form_field: ^7.0.6
│ │    tuple: ^2.0.1
│ │    loading_indicator: ^3.1.0
│ │ -  uuid: ^3.0.7
│ │ -  flutter_colorpicker: ^1.0.3
│ │    intl: ^0.17.0
│ │ -  file_picker: ^5.2.6
│ │  
│ │  dev_dependencies:
│ │    flutter_test:
│ │      sdk: flutter
│ │  
│ │    flutter_lints: ^2.0.0
│ │    graphql_codegen: ^0.12.0-beta.14
│ │   --- pysura-0.99.81/pysura/library_data/pysura_microservice/Dockerfile
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_microservice/Dockerfile
│ │┄ Files identical despite different names
│ │   --- pysura-0.99.81/pysura/library_data/pysura_microservice/requirements.txt
│ ├── +++ pysura-0.99.9/pysura/library_data/pysura_microservice/requirements.txt
│ │┄ Files 4% similar despite different names
│ │ @@ -51,12 +51,8 @@
│ │  sniffio>=1.3.0
│ │  starlette>=0.26.1
│ │  typing_extensions>=4.5.0
│ │  uritemplate>=4.1.1
│ │  urllib3>=1.26.15
│ │  uvicorn>=0.21.1
│ │  websockets>=10.4
│ │ -yarl>=1.8.2
│ │ -pysura>=0.99.10
│ │ -Pillow>=9.5.0
│ │ -starlette>=0.26.1
│ │ -SQLAlchemy>=2.0.8
│ │ +yarl>=1.8.2
│ │   --- pysura-0.99.81/pysura/pysura_types/google_pysura_env.py
│ ├── +++ pysura-0.99.9/pysura/pysura_types/google_pysura_env.py
│ │┄ Files 2% similar despite different names
│ │ @@ -235,15 +235,15 @@
│ │      HASURA_GRAPHQL_ADMIN_SECRET: str | None = None
│ │      HASURA_GRAPHQL_DATABASE_URL: str | None = None
│ │      HASURA_GRAPHQL_METADATA_DATABASE_URL: str | None = None
│ │      HASURA_GRAPHQL_JWT_SECRET: str | None = None
│ │      HASURA_GRAPHQL_URL_ROOT: str | None = None
│ │      HASURA_EVENT_SECRET: str | None = None
│ │      HASURA_MICROSERVICE_URL: str | None = None
│ │ -    HASURA_STORAGE_BUCKET: str | None = None
│ │ +    HASURA_FIREBASE_SERVICE_ACCOUNT: str | None = None
│ │      microservice_urls: List[MicroserviceUrl] | None = None
│ │      vpc_connector: str | None = None
│ │      timeout: str | None = None
│ │      project_id: str | None = None
│ │      cpu: str | None = None
│ │      memory: str | None = None
│ │      min_instances: str | None = None
│ │ @@ -447,65 +447,64 @@
│ │      sourceUploadUrl: str | None = None
│ │      status: str | None = None
│ │      timeout: str | None = None
│ │      updateTime: str | None = None
│ │      versionId: str | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTriggerUpdate(DictModel):
│ │ +class HasuraMetadataUserId(DictModel):
│ │ +    _eq: str | None = None
│ │ +
│ │ +
│ │ +class HasuraMetadataUserIdFilter(DictModel):
│ │ +    user_id: HasuraMetadataUserId | None = None
│ │ +
│ │ +
│ │ +class HasuraMetadataPermission(DictModel):
│ │      columns: List[str] | None = None
│ │ +    filter: HasuraMetadataUserIdFilter | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTriggerDefinition(DictModel):
│ │ -    enable_manual: bool | None = None
│ │ -    update: HasuraMetadataEventTriggerUpdate | None = None
│ │ +class HasuraMetadataSelectPermission(DictModel):
│ │ +    role: str | None = None
│ │ +    permission: HasuraMetadataPermission | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTriggerRetryConf(DictModel):
│ │ -    interval_sec: int | None = None
│ │ -    num_retries: int | None = None
│ │ -    timeout_sec: int | None = None
│ │ +class HasuraMetadataInsertPermission(DictModel):
│ │ +    role: str | None = None
│ │ +    permission: HasuraMetadataPermission | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTriggerHeader(DictModel):
│ │ -    name: str | None = None
│ │ -    value_from_env: str | None = None
│ │ +class HasuraMetadataUpdatePermission(DictModel):
│ │ +    columns: List[str] | None = None
│ │ +    filter: HasuraMetadataUserIdFilter | None = None
│ │ +    check: HasuraMetadataUserIdFilter | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTriggerRequestTransform(DictModel):
│ │ -    method: str | None = None
│ │ -    query_params: Dict[str, Any] | None = None
│ │ -    template_engine: str | None = None
│ │ -    version: int | None = None
│ │ +class HasuraMetadataUpdatePermissions(DictModel):
│ │ +    role: str | None = None
│ │ +    permission: HasuraMetadataUpdatePermission | None = None
│ │  
│ │  
│ │ -class HasuraMetadataEventTrigger(DictModel):
│ │ -    location: str | None = None
│ │ -    name: str | None = None
│ │ -    definition: HasuraMetadataEventTriggerDefinition | None = None
│ │ -    retry_conf: HasuraMetadataEventTriggerRetryConf | None = None
│ │ -    webhook: str | None = None
│ │ -    headers: List[HasuraMetadataEventTriggerHeader] | None = None
│ │ -    request_transform: HasuraMetadataEventTriggerRequestTransform | None = None
│ │ +class HasuraMetadataDeletePermission(DictModel):
│ │ +    filter: HasuraMetadataUserIdFilter | None = None
│ │  
│ │  
│ │ -class HasuraMetadataPermission(DictModel):
│ │ -    columns: List[str] | None = None
│ │ -    filter: Dict[str, Any] | None = None
│ │ -    check: Dict[str, Any] | None = None
│ │ +class HasuraMetadataDeletePermissions(DictModel):
│ │ +    role: str | None = None
│ │ +    permission: HasuraMetadataDeletePermission | None = None
│ │  
│ │  
│ │  class HasuraMetadataPermissionsTable(DictModel):
│ │      table: Dict[str, Any] | None = None
│ │      is_enum: bool | None = None
│ │ -    select_permissions: List[HasuraMetadataPermission] | None = None
│ │ -    insert_permissions: List[HasuraMetadataPermission] | None = None
│ │ -    update_permissions: List[HasuraMetadataPermission] | None = None
│ │ -    delete_permissions: List[HasuraMetadataPermission] | None = None
│ │ -    event_triggers: List[HasuraMetadataEventTrigger] | None = None
│ │ +    select_permissions: List[HasuraMetadataSelectPermission] | None = None
│ │ +    insert_permissions: List[HasuraMetadataInsertPermission] | None = None
│ │ +    update_permissions: List[HasuraMetadataUpdatePermissions] | None = None
│ │ +    delete_permissions: List[HasuraMetadataDeletePermissions] | None = None
│ │  
│ │  
│ │  class HasuraMetadataDatabaseUrl(DictModel):
│ │      from_env: str | None = None
│ │  
│ │  
│ │  class HasuraMetadataPoolSettings(DictModel):
│ │ @@ -573,59 +572,19 @@
│ │  
│ │  
│ │  class HasuraMetadataCustomTypes(DictModel):
│ │      input_objects: List[HasuraMetadataObject] | None = None
│ │      objects: List[HasuraMetadataObject] | None = None
│ │  
│ │  
│ │ -class HasuraCronRetryConf(DictModel):
│ │ -    num_retries: int
│ │ -    retry_interval_seconds: int
│ │ -    timeout_seconds: int
│ │ -    tolerance_seconds: int
│ │ -
│ │ -
│ │ -class HasuraCronHeader(DictModel):
│ │ -    name: str
│ │ -    value_from_env: str
│ │ -
│ │ -
│ │ -class HasuraCronRequestTransform(DictModel):
│ │ -    method: str
│ │ -    query_params: Dict[str, Any]
│ │ -    template_engine: str
│ │ -    url: str
│ │ -    version: int
│ │ -
│ │ -
│ │ -class HasuraCron(DictModel):
│ │ -    name: str | None = None
│ │ -    webhook: str | None = None
│ │ -    schedule: str | None = None
│ │ -    include_in_metadata: bool | None = None
│ │ -    payload: Dict | None = None
│ │ -    retry_conf: HasuraCronRetryConf | None = None
│ │ -    headers: List[HasuraCronHeader] | None = None
│ │ -    comment: str | None = None
│ │ -    request_transform: HasuraCronRequestTransform | None = None
│ │ -
│ │ -
│ │  class HasuraMetadata(DictModel):
│ │      version: int | None = None
│ │      sources: List[HasuraMetadataSource] | None = None
│ │      actions: List[HasuraMetadataAction] | None = None
│ │      custom_types: HasuraMetadataCustomTypes | None = None
│ │ -    cron_triggers: List[HasuraCron] | None = None
│ │ -
│ │ -
│ │ -class TestPhoneNumber(DictModel):
│ │ -    role: str | None = None
│ │ -    phone_number: str | None = None
│ │ -    code: str | None = None
│ │ -    uid: str | None = None
│ │  
│ │  
│ │  class GooglePysuraEnv(DictModel):
│ │      gcloud_cli_installed: bool = False
│ │      gcloud_alpha_cli_installed: bool = False
│ │      gcloud_beta_cli_installed: bool = False
│ │      gcloud_logged_in: bool = False
│ │ @@ -652,26 +611,19 @@
│ │      connectors: List[GoogleConnector] | None = None
│ │      api_services: List[GoogleApiServices] | None = None
│ │      services: List[GoogleService] | None = None
│ │      secrets: List[GoogleSecret] | None = None
│ │      service_accounts: List[GoogleServiceAccount] | None = None
│ │      hasura: Hasura | None = None
│ │      hasura_admin_secret: str | None = None
│ │ +    hasura_backend_event_secret: str | None = None
│ │      hasura_service: GoogleService | None = None
│ │      hasura_service_url: str | None = None
│ │      hasura_service_account: GoogleServiceAccount | None = None
│ │      auth_service_account: GoogleServiceAccount | None = None
│ │      functions: List[GoogleCloudFunction] | None = None
│ │      ios_cf_bundle_url_types: IosCFBundleURLTypes | None = None
│ │      android_signing_reports: List[AndroidSigningReport] | None = None
│ │      android_debug_signing_report: AndroidSigningReport | None = None
│ │      hasura_metadata: HasuraMetadata | None = None
│ │      default_microservice: GoogleService | None = None
│ │      default_microservice_url: str | None = None
│ │ -    test_phone_numbers: List[TestPhoneNumber] | None = None
│ │ -    local_database_enabled: bool = False
│ │ -    default_user_table_created: bool = False
│ │ -    firebase_attached: bool = False
│ │ -    flutter_attached: bool = False
│ │ -    flutter_app_name: str | None = None
│ │ -    firebase_auth_activated: bool = False
│ │ -    frontend_ssr_service: GoogleService | None = None
│ │   --- pysura-0.99.81/pysura/pysura_types/root_cmd.py
│ ├── +++ pysura-0.99.9/pysura/pysura_types/root_cmd.py
│ │┄ Files 7% similar despite different names
│ │ @@ -1,37 +1,26 @@
│ │ -# This is the command line
│ │ +# INSTRUCTIONS FOR GPT4
│ │ +
│ │ +# Make it so that there are two windows. One for the command line, and one for the output. Use prompt_toolkit
│ │ +
│ │  from cmd import Cmd
│ │  from prompt_toolkit import prompt
│ │  from prompt_toolkit.history import InMemoryHistory
│ │  from prompt_toolkit.completion import WordCompleter
│ │  import inspect
│ │  import logging
│ │  import sys
│ │  import time
│ │  import os
│ │  import json
│ │  
│ │  
│ │ -class LogLevelFilter(logging.Filter):
│ │ -    """This is a logging filter that filters out all messages that are not of a certain level."""
│ │ -
│ │ -    def __init__(self, level):
│ │ -        super().__init__()
│ │ -        self.level = level
│ │ -
│ │ -    def filter(self, record):
│ │ -        return record.levelno == self.level
│ │ -
│ │ -
│ │  class RootCmd(Cmd):
│ │  
│ │      def setup_logging(self):
│ │ -        """
│ │ -        This setup_logging function is called to create the log handlers and loggers for each file.
│ │ -        """
│ │          if not os.path.exists("logs"):
│ │              os.mkdir("logs")
│ │          log_path = os.path.join(os.getcwd(), "logs")
│ │          log_levels = {
│ │              'debug': logging.DEBUG,
│ │              'info': logging.INFO,
│ │              'warning': logging.WARNING,
│ │ @@ -45,51 +34,40 @@
│ │  
│ │              for level_name, level in log_levels.items():
│ │                  log_file_handler = logging.FileHandler(f'{log_path}/{level_name}.log', mode='a')
│ │                  log_file_handler.setLevel(level)
│ │                  log_file_formatter = logging.Formatter(fmt="%(asctime)s %(levelname)-5s %(message)s",
│ │                                                         datefmt="%Y-%m-%d %I:%H:%M")
│ │                  log_file_handler.setFormatter(log_file_formatter)
│ │ -
│ │ -                level_filter = LogLevelFilter(level)
│ │ -                log_file_handler.addFilter(level_filter)
│ │ -
│ │ -                level_logger = logging.getLogger(level_name)
│ │ -                level_logger.setLevel(level)
│ │ -                level_logger.addHandler(log_file_handler)
│ │ -                level_logger.propagate = False
│ │ -
│ │                  root_logger.addHandler(log_file_handler)
│ │  
│ │              root_handler = logging.StreamHandler(sys.stdout)
│ │ -            root_handler.setLevel(logging.INFO)
│ │ +            root_handler.setLevel(logging.DEBUG)
│ │              root_formatter = logging.Formatter(fmt="%(asctime)s %(levelname)-5s %(message)s",
│ │                                                 datefmt="%Y-%m-%d %I:%H:%M")
│ │              root_handler.setFormatter(root_formatter)
│ │              root_logger.addHandler(root_handler)
│ │          self.root = root_logger
│ │  
│ │      def __init__(self, *args, logger=None, **kwargs):
│ │          super().__init__(*args, **kwargs)
│ │          self.prompt = "root> "
│ │ -        # We are overriding Cmd, so all commands with a do_ prefix will be turned into command line commands.
│ │          # Auto build a command completer by inspecting the methods attached to self, and stripping the "do_" prefix
│ │          self.completer = WordCompleter([
│ │              *[i[0][3:] for i in inspect.getmembers(self, predicate=inspect.isfunction) if
│ │                i[0].startswith("do_")],
│ │              *[i[0][3:] for i in inspect.getmembers(self, predicate=inspect.ismethod) if
│ │                i[0].startswith("do_")]
│ │          ])
│ │          self.root = None
│ │          if logger is None:
│ │              self.setup_logging()
│ │          else:
│ │              self.root = logger
│ │          self.history = InMemoryHistory()
│ │ -        self.setup_step = 0
│ │  
│ │      def cmdloop(self, intro=None):
│ │          self.preloop()
│ │  
│ │          try:
│ │              if intro is not None:
│ │                  self.intro = intro
│ │ @@ -141,33 +119,32 @@
│ │  
│ │      def user_input_no_loop(self, func):
│ │          try_again = self.collect("Try again? (y/n)")
│ │          if try_again.strip().lower() == "y":
│ │              func()
│ │  
│ │      def confirm_loop(self, confirm_str):
│ │ -        confirm = self.collect(f"Retype to confirm (Retype this {confirm_str}, Up key = History): ")
│ │ +        confirm = self.collect("Retype to confirm: ")
│ │          if confirm.strip() != confirm_str.strip():
│ │              self.log("Cancelled.")
│ │              return False
│ │          return True
│ │  
│ │ -    def gcloud_retry_loop(self, cmd_str, name):
│ │ +    def retry_loop(self, cmd_str, name):
│ │          for i in range(5):
│ │              try:
│ │                  response = os.popen(cmd_str).read()
│ │                  response = json.loads(response)
│ │                  if len(response) == 0:
│ │                      raise Exception(f"No {name} found.")
│ │                  for r in response:
│ │                      if r["name"].split("/")[-1] == name:
│ │                          return response
│ │                  raise Exception(f"No {name} found.")
│ │ -            except Exception as e:
│ │ -                self.log(f"{e}\nName not found in response, trying network", level=logging.DEBUG)
│ │ +            except Exception as _:
│ │                  try:
│ │                      response = os.popen(cmd_str).read()
│ │                      response = json.loads(response)
│ │                      if len(response) == 0:
│ │                          raise Exception(f"No {name} found.")
│ │                      for r in response:
│ │                          if r["network"].split("/")[-1] == name:
│ │   --- pysura-0.99.81/pysura.egg-info/PKG-INFO
│ ├── +++ pysura-0.99.9/README.rst
│ │┄ Files 20% similar despite different names
│ │ @@ -1,59 +1,49 @@
│ │ -Metadata-Version: 2.1
│ │ -Name: pysura
│ │ -Version: 0.99.81
│ │ -Summary: A useful tool that provides commands to help ease the installation process of Hasura, and manage its actions, events, and scheduled jobs with baked in phone Auth and a Flutter frontend.
│ │ -Home-page: https://github.com/tristengoodz/pysura
│ │ -Author: Tristen Harr
│ │ -Author-email: tristen@thegoodzapp.com
│ │ -Keywords: hasura,graphql,postgresql,google-cloud,python,pysura,backend,backend-in-a-box
│ │ -Classifier: Development Status :: 4 - Beta
│ │ -Classifier: Intended Audience :: Developers
│ │ -Classifier: Topic :: Software Development :: Build Tools
│ │ -Classifier: License :: OSI Approved :: MIT License
│ │ -Classifier: Programming Language :: Python :: 3
│ │ -Requires-Python: >=3.9
│ │ -License-File: LICENSE.txt
│ │ -
│ │  
│ │  Pysura - BETA
│ │  =============
│ │  
│ │  Hasura + Python = Pysura. An open source solution.
│ │ ---------------------------------------------------
│ │ +^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  Because everyone should be a code wizard.
│ │  
│ │  
│ │  .. image:: images/code_wizard.png
│ │     :target: images/code_wizard.png
│ │     :alt: img_1.png
│ │  
│ │  
│ │  Requirements:
│ │ -^^^^^^^^^^^^^
│ │ +-------------
│ │  
│ │  To deploy Hasura with Pysura with baked in Auth and a templated Flutter Frontend:
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  
│ │ -* Python 3.9+
│ │  * gcloud CLI
│ │  * gcloud beta CLI
│ │  * A billing account with Google Cloud
│ │  * Docker (Make sure it's running in the background or your deployment will fail!)
│ │ +* Python 3.9+
│ │  * Firebase CLI
│ │  * npm
│ │ +* flutterfire_cli
│ │  * Dart
│ │  * Flutter
│ │ +* XCode (for iOS apps) and iOS Dev Tools
│ │ +* Android Studio (for Android apps) and Android Dev Tools
│ │ +* Gradle (for Android apps)
│ │  
│ │  .. code-block:: commandline
│ │  
│ │     pip install pysura
│ │     pysura
│ │ +   (pysura_cli) >>> choose_provider
│ │ +   Please choose a provider: [google,]: google
│ │     (pysura_cli) >>> setup_pysura
│ │  
│ │  Note: The installer is doing a lot of things. Some of them take a long time, like creating databases, firewalls, and VPC
│ │  networks. Sometimes it might look frozen, but give it some time to do its thing. It's automagically building an entire
│ │  application for you. I promise doing this by hand takes longer. ;)
│ │  
│ │  
│ │ @@ -69,15 +59,15 @@
│ │  
│ │  Linux - It should work on Linux, it is untested. Let me know!
│ │  
│ │  Windows - With minor updates it should work. I think the majority of the deployer works, but it might run into issues on
│ │  the Firebase and Flutterfire CLI's.
│ │  
│ │  What is Pysura?
│ │ ----------------
│ │ +===============
│ │  
│ │  Pysura is a CLI tool that's designed to make building and deploying multi-tenant enterprise grade applications as easy
│ │  as a freshman year algorithms class. It's a highly opinionated way because it's the right way.
│ │  
│ │  It's kind of like running npm init, if npm was for backends and frontends, it provides your backend, auth, and database
│ │  for you in the cloud in a way that is infinitely scalable and uses zero-trust, with a type-safe GraphQL backend and a
│ │  bring-your-own front-end approach with special built-in support for Flutter which is the default setup.
│ │ @@ -86,72 +76,27 @@
│ │  
│ │  So that it doesn't matter what you are building, you can build it on Pysura. It's about damn time that Python developers
│ │  have better mobile support. Let's bring python to mobile. Let's bring python to the web. Let's bring python to the edge.
│ │  Let's bring python everywhere. And let's skin it with Flutter and feed it all the data it wants with GraphQL and Hasura.
│ │  
│ │  Do I have to use Flutter for the frontend? No way! Pysura places firebase in front of your Hasura instance, so if your
│ │  frontend of choice supports Firebase Auth integrations or libraries, you can use it, or even better open a PR and add a
│ │ -template for your provider. You *do* need Flutter for installation
│ │ -
│ │ -What does the Pysura installer do?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ -
│ │ -
│ │ -* Authenticates you with gcloud
│ │ -* Creates a new project in Google Cloud
│ │ -* Sets up a VPC network inside the project
│ │ -* Creates a new Cloud SQL instance running Postgres 14
│ │ -* Stores all Env variables in secret manager to be loaded from containers
│ │ -* Creates a new Hasura instance in Cloud Run with scaling settings always allocating memory for at least 1 instance
│ │ -* Attaches Firebase to the project
│ │ -* Deploys firebase functions triggering on user.create/delete managing Hasura user data each with min instances set to 1
│ │ -* Adds JWT authentication via Firebase to Hasura with phone sign in
│ │ -* Creates a new Flutter app with Firebase Auth using flutterfire
│ │ -* Configures Android signing keys (COMING SOON: Auto app icon configuration)
│ │ -* Configures iOS URL schemes (COMING SOON: Auto app icon configuration)
│ │ -* Updates the default flutter template to use the Pysura template for Flutter 
│ │ -* Deploys the flutter template to Firebase hosting for the web. (COMING SOON: Auto app icon configuration)
│ │ -* Deploys a default microservice on Cloud Run using Pysura! Includes default event that handles JWT claim changes
│ │ +template for your provider.
│ │  
│ │  What is a Pysura Microservice?
│ │ -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  It's a wrapper around a FastAPI app that holds a collection of actions, events, and chron-jobs related to its function.
│ │  I.e. A payment microservice might have all code related to payment processing. It bakes in Auth with an extra decorator
│ │  which gives you easy access to the calling user each time a method is called. This works by using opaque tokens that
│ │  pass through the headers into the microservice. It's a very simple way to do auth, and it's very secure. It gives full
│ │  RBAC at a column level, and you can design rather complex auth rules using Hasura's permission system. Each action,
│ │  event, and chron-job is placed in a separate file with routing already handled and the calling users information passed
│ │  in the calling context. It makes it very easy to build your business logic in a clean, consistent way that is easy to
│ │  test and maintain, and also easy to hand off to other developers.
│ │  
│ │ -Pysura uses middleware to handle the auth, and provide you access to app resources like the database, and the caller.
│ │ -It wraps FastAPI, and uses a router for each action, event, or chron-job. Separating the business logic into collections
│ │ -of microservices each containing folders of actions, events, and chron-jobs each delegated to their own file which 
│ │ -makes it easy to scale and maintain.
│ │ -
│ │ -Front-end clients should utilize the Hasura GraphQL API to access and mutate the data in the database. This is the 
│ │ -recommended way to access the data. It is important to make sure you set up proper roles and permissions in Hasura to
│ │ -ensure that only the correct users can access the data meant for them. By default, Pysura includes a user and admin role
│ │ -
│ │ -Actions are used to allow the front-end client a way to perform custom business logic, or do a task that requires
│ │ -calling third party APIs or services. Actions are called via the Hasura GraphQL API, and are executed on the 
│ │ -microservice instance.
│ │ -
│ │ -Events are used to trigger custom business logic when something occurs in the database. For example, when a user is
│ │ -created, you might want to send them a welcome email. Events are triggered by Hasura (via the Database),
│ │ -and are executed on the microservice instance.
│ │ -
│ │ -Crons are used to trigger custom business logic on a schedule. For example, you might want to send a report to the
│ │ -admin every day at 8am. Crons are triggered by Hasura (via the Database), and are executed on the microservice instance.
│ │ -
│ │ -By default, the application is configured with an event secret that must be passed to all microservices in the header
│ │ -from Hasura. This ensures that all traffic is coming from Hasura, and not from a malicious source. This makes things
│ │ -SUPER secure, with JWT auth, and event secrets. It's a very secure way to build an application.
│ │ -
│ │  Do I need to deploy Hasura with Pysura to use it?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │  
│ │  As of right now yes. In the future, no!
│ │  
│ │  Is this just a wrapper for the Hasura CLI?
│ │  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
│ │ @@ -206,17 +151,14 @@
│ │  
│ │  A: Please open an issue or a feature request. I'm sure I missed some things. Stitching this together required a bit of
│ │  everything, including working outside my area of expertise.
│ │  
│ │  TODOS:
│ │  ^^^^^^
│ │  
│ │ -Remove pyscopg2 dependency to drop postgres req
│ │ -===============================================
│ │ -
│ │  DONE:
│ │  
│ │  
│ │  * [x] Add support for Google Cloud
│ │  * [x] Add support for Firebase Auth
│ │  * [x] Add ios/android wizard
│ │  * [x] Add support for Flutter
│ │ @@ -233,15 +175,19 @@
│ │  * [ ] Add support for other auth providers (Auth0, etc) @Unclaimed
│ │  
│ │    * [ ] Auth0
│ │    * [ ] ???
│ │  
│ │  * [ ] Flutter SSR bindings for Web @Unclaimed
│ │  * [ ] Caching Wizard @Tristen
│ │ +* [ ] Update the pysura/pysura_types/root_cmd.py to make better use of prompt_toolkit. It would be nice to have multiple
│ │ +  tabs for different level of logs. @Unclaimed
│ │  * [ ] Built in API Version Control @Tristen
│ │ +* [ ] Tighten up the command loops. (Ex. Test the deployer and input values that will fail, and make sure it can recover
│ │ +  more gracefully) @Unclaimed
│ │  
│ │  LOW PRIORITY:
│ │  
│ │  
│ │  * [ ] Add support for AWS/Azure/Etc.
│ │  * [ ] Add support for other databases (Postgres, MySQL, BigQuery, etc)
│ │  * [ ] Add support for other frontends (React, Vue, etc)
