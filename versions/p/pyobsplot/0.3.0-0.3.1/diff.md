# Comparing `tmp/pyobsplot-0.3.0.tar.gz` & `tmp/pyobsplot-0.3.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyobsplot-0.3.0.tar", max compression
+gzip compressed data, was "pyobsplot-0.3.1.tar", max compression
```

## Comparing `pyobsplot-0.3.0.tar` & `pyobsplot-0.3.1.tar`

### file list

```diff
@@ -1,13 +1,14 @@
--rw-r--r--   0        0        0     1071 2023-03-29 08:42:01.834769 pyobsplot-0.3.0/LICENSE
--rw-r--r--   0        0        0     3830 2023-04-05 14:06:25.509832 pyobsplot-0.3.0/README.md
--rw-r--r--   0        0        0      772 2023-04-05 14:07:14.826127 pyobsplot-0.3.0/pyproject.toml
--rw-r--r--   0        0        0      500 2023-04-04 23:28:42.014730 pyobsplot-0.3.0/src/pyobsplot/__init__.py
--rw-r--r--   0        0        0     2553 2023-03-30 12:48:09.497135 pyobsplot-0.3.0/src/pyobsplot/data.py
--rw-r--r--   0        0        0     1773 2023-04-05 10:58:55.024938 pyobsplot-0.3.0/src/pyobsplot/jsdom.py
--rw-r--r--   0        0        0     2475 2023-04-05 14:06:25.509832 pyobsplot-0.3.0/src/pyobsplot/obsplot.py
--rw-r--r--   0        0        0     6293 2023-04-02 22:13:00.227364 pyobsplot-0.3.0/src/pyobsplot/parsing.py
--rw-r--r--   0        0        0       89 2023-04-05 14:08:20.006514 pyobsplot-0.3.0/src/pyobsplot/static/styles.css
--rw-r--r--   0        0        0  1317642 2023-04-05 14:08:20.006514 pyobsplot-0.3.0/src/pyobsplot/static/widget.js
--rw-r--r--   0        0        0      148 2023-04-05 14:06:25.509832 pyobsplot-0.3.0/src/pyobsplot/utils.py
--rw-r--r--   0        0        0      997 2023-04-04 20:56:44.518103 pyobsplot-0.3.0/src/pyobsplot/widget.py
--rw-r--r--   0        0        0     4593 1970-01-01 00:00:00.000000 pyobsplot-0.3.0/PKG-INFO
+-rw-r--r--   0        0        0     1071 2023-03-29 08:42:01.834769 pyobsplot-0.3.1/LICENSE
+-rw-r--r--   0        0        0     3816 2023-04-06 15:53:55.434769 pyobsplot-0.3.1/README.md
+-rw-r--r--   0        0        0     1251 2023-04-06 16:14:11.004831 pyobsplot-0.3.1/pyproject.toml
+-rw-r--r--   0        0        0      535 2023-04-06 08:28:46.892341 pyobsplot-0.3.1/src/pyobsplot/__init__.py
+-rw-r--r--   0        0        0     2553 2023-03-30 12:48:09.497135 pyobsplot-0.3.1/src/pyobsplot/data.py
+-rw-r--r--   0        0        0     1810 2023-04-06 09:50:53.580377 pyobsplot-0.3.1/src/pyobsplot/jsdom.py
+-rw-r--r--   0        0        0     1943 2023-04-06 14:50:12.511091 pyobsplot-0.3.1/src/pyobsplot/jsmodules.py
+-rw-r--r--   0        0        0     3150 2023-04-06 10:10:11.360454 pyobsplot-0.3.1/src/pyobsplot/obsplot.py
+-rw-r--r--   0        0        0     5511 2023-04-06 14:15:31.707100 pyobsplot-0.3.1/src/pyobsplot/parsing.py
+-rw-r--r--   0        0        0       89 2023-04-06 16:25:33.736471 pyobsplot-0.3.1/src/pyobsplot/static/styles.css
+-rw-r--r--   0        0        0  2268308 2023-04-06 16:25:33.736471 pyobsplot-0.3.1/src/pyobsplot/static/widget.js
+-rw-r--r--   0        0        0      148 2023-04-05 14:06:25.509832 pyobsplot-0.3.1/src/pyobsplot/utils.py
+-rw-r--r--   0        0        0     1067 2023-04-06 09:50:18.108129 pyobsplot-0.3.1/src/pyobsplot/widget.py
+-rw-r--r--   0        0        0     5088 1970-01-01 00:00:00.000000 pyobsplot-0.3.1/PKG-INFO
```

### Comparing `pyobsplot-0.3.0/LICENSE` & `pyobsplot-0.3.1/LICENSE`

 * *Files identical despite different names*

### Comparing `pyobsplot-0.3.0/README.md` & `pyobsplot-0.3.1/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -2,27 +2,25 @@
 
 [![PyPI](https://img.shields.io/pypi/v/pyobsplot.svg?color=green)](https://pypi.org/project/pyobsplot)
 [![Tests](https://github.com/juba/pyobsplot/actions/workflows/tests.yml/badge.svg)](https://github.com/juba/pyobsplot/actions/workflows/tests.yml)
 [![Documentation](https://github.com/juba/pyobsplot/actions/workflows/publish.yml/badge.svg)](https://github.com/juba/pyobsplot/actions/workflows/publish.yml)
 [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/juba/pyobsplot/blob/main/examples/introduction.ipynb)
 
 
-`pyobsplot` allows to use [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot) to create charts in Jupyter notebooks. Plots are produced as [widgets](https://ipywidgets.readthedocs.io/en/latest/index.html) from Python code with a syntax as close as possible to the JavaScript one.
+`pyobsplot` allows to use [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot) to create charts in Jupyter notebooks, VSCode notebooks, Google Colab and Quarto documents. Plots are created from Python code with a syntax as close as possible to the JavaScript one.
 
 It allows to do things like :
 
 ```python
 import polars as pl
-from pyobsplot import Obsplot, Plot
+from pyobsplot import Plot
 
-penguins = pl.read_csv("data/penguins.csv")
+penguins = pl.read_csv("https://github.com/juba/pyobsplot/raw/main/doc/data/penguins.csv")
 
-op = Obsplot()
-
-op({
+Plot.plot({
     "grid": True,
     "color": {"legend": True},
     "marks": [
         Plot.dot(
             penguins, 
             {"x": "flipper_length_mm", "y": "body_mass_g", "fill": "species"}
         ),
@@ -35,15 +33,15 @@
 ```
 
 ![Sample plot screenshot](https://github.com/juba/pyobsplot/raw/main/doc/screenshots/readme_plot.png)
 
 
 ## Installation and usage
 
-> **Warning**: this project is at a very early stage. There will be bugs, and please take a look at the limitations listed below.
+> **Warning**: this project is at an early stage. There will be bugs, and the API may change.
 
 `pyobsplot` can be installed with `pip`:
 
 ```sh
 pip install pyobsplot
 ```
 
@@ -64,16 +62,16 @@
 - Caching mechanism of data objects if they are used several times in the same plot
 - Custom JavaScript code can be passed as strings with the `js` method
 - Python `date` and `datetime` objects are automatically converted to JavaScript `Date` objects
 - Works with Jupyter notebooks and Quarto HTML documents. Plots without legends are also supported in PDF and docx outputs with the `jsdom` renderer.
 
 **Limitations:**
 
-- Plots with legends don't work in Quarto in formats other than HTML.
-- Some faceting operations produce warnings when used as top-level faceting (but the plots should be fine). This doesn't happen when using mark-level faceting (with the `fx` and `fy` channels).
+- Plots with legends don't work in Quarto in formats other than HTML. (#9)
+- Some faceting operations produce warnings when used as top-level faceting (but the plots should be fine). This doesn't happen when using mark-level faceting (with the `fx` and `fy` channels). (#3)
 
 
 
 ## Credits
 
 - [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot), developed by [Mike Bostock](https://observablehq.com/@mbostock) and [Philippe Rivi√®re](https://observablehq.com/@fil) among others.
 - The widget is developed thanks to the [anywidget](https://anywidget.dev) framework.
```

### Comparing `pyobsplot-0.3.0/pyproject.toml` & `pyobsplot-0.3.1/pyproject.toml`

 * *Files 26% similar despite different names*

```diff
@@ -1,19 +1,29 @@
 [tool.poetry]
 name = "pyobsplot"
-version = "0.3.0"
-description = "Observable Plot in Jupyter notebooks"
+version = "0.3.1"
+description = "Observable Plot in Jupyter notebooks and Quarto documents"
 authors = ["Julien Barnier <julien@nozav.org>"]
 license = "MIT"
 readme = "README.md"
 include = ["src/pyobsplot/static/*"]
-
-
-[project.urls]
 homepage = "https://github.com/juba/pyobsplot"
+documentation = "https://juba.github.io/pyobsplot"
+repository = "https://github.com/juba/pyobsplot"
+classifiers = [
+    "Development Status :: 3 - Alpha",
+    "Framework :: Jupyter :: JupyterLab",
+    "License :: OSI Approved :: MIT License",
+    "Programming Language :: Python :: 3",
+    "Programming Language :: JavaScript",
+    "Topic :: Scientific/Engineering :: Visualization"
+]
+
+[tool.poetry.urls]
+changelog = "https://github.com/juba/pyobsplot/blob/main/NEWS.md"
 
 [tool.poetry.dependencies]
 python = "^3.8"
 anywidget = {extras = ["dev"], version = "^0.2.0"}
 pandas = ">=1.2.0"
 polars = ">=0.16.0"
 pyarrow = "^11.0.0"
@@ -21,15 +31,15 @@
 jupyterlab = ">=3.6.0"
 
 [tool.poetry.group.dev.dependencies]
 ruff = "^0.0.259"
 black = "^23.1.0"
 pytest = "^7.2.2"
 requests = "^2.28.2"
-topojson = "^1.5"
+geopandas = "^0.12.2"
 
 [build-system]
 requires = ["poetry-core"]
 build-backend = "poetry.core.masonry.api"
 
 [tool.pytest.ini_options]
 testpaths = "tests"
```

### Comparing `pyobsplot-0.3.0/src/pyobsplot/data.py` & `pyobsplot-0.3.1/src/pyobsplot/data.py`

 * *Files identical despite different names*

### Comparing `pyobsplot-0.3.0/src/pyobsplot/jsdom.py` & `pyobsplot-0.3.1/src/pyobsplot/jsdom.py`

 * *Files 4% similar despite different names*

```diff
@@ -18,24 +18,24 @@
     The class takes a plot specification as input and generates a plot as SVG or HTML
     by calling a JSDom script with node.
 
     The specification can be given as a dict, a Plot function call or as
     Python kwargs.
     """
 
-    def __init__(self, spec: Any) -> None:
+    def __init__(self, spec: Any, debug: bool = False) -> None:
         """
         Constructor. Parse the spec given as argument.
         """
         # Create parser
         parser = SpecParser("jsdom")
         # Parse spec code
         code = parser.parse(spec)
         # Create spec object
-        spec = {"data": parser.serialize_data(), "code": code}
+        spec = {"data": parser.serialize_data(), "code": code, "debug": debug}
         self.spec = spec
 
     def plot(self):
         """Generates the plot by calling node script.
 
         Returns:
             Either an HTML or SVG IPython.display object.
```

### Comparing `pyobsplot-0.3.0/src/pyobsplot/obsplot.py` & `pyobsplot-0.3.1/src/pyobsplot/obsplot.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,79 +13,96 @@
     """
     Main Obsplot class.
 
     Launches a Jupyter widget with ObsplotWidget class, or displays an IPython display
     with ObsplotJsdom depending on the renderer.
     """
 
-    @staticmethod
-    def get_spec(*args, **kwargs) -> dict:
-        """
-        Extract plot specification from args and kwargs, taking into account
-        the alternative specification syntaxes.
-        """
-
-        # Only one dict arg -> spec passed as dict
-        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], dict):
-            spec = args[0]
-        # Only one kwarg called spec
-        elif len(args) == 0 and len(kwargs) == 1 and "spec" in kwargs:
-            spec = kwargs["spec"]
-        # Only kwargs -> spec is kwargs
-        elif len(args) == 0 and len(kwargs) > 0:
-            spec = kwargs
-        else:
-            raise ValueError("Incorrect ObsPlot arguments")
-        return spec
-
-    def __new__(cls, renderer: str = "widget", *args, **kwargs) -> Any:
+    def __new__(cls, renderer: str = "widget", debug: bool = False) -> Any:
         """
         Main Obsplot class constructor. Returns a Creator instance depending on the
         renderer passed as argument.
         """
 
         available_renderers = ["widget", "jsdom"]
 
         # Plot spec with the configured renderer
         if renderer == "widget":
-            return ObsplotWidgetCreator(*args, **kwargs)
+            return ObsplotWidgetCreator(debug)
         elif renderer == "jsdom":
-            return ObsplotJsdomCreator(*args, **kwargs)
+            if debug:
+                raise ValueError("debug mode is not available with jsdom renderer")
+            return ObsplotJsdomCreator()
         else:
             raise ValueError(
                 f"""
                 Incorrect renderer '{renderer}'. 
                 Available renderers are {available_renderers}
                 """
             )
 
 
-class ObsplotWidgetCreator:
+class ObsplotCreator:
+    """
+    Creator class.
+    """
+
+    def get_spec(self, *args, **kwargs):
+        """
+        Extract plot specification from args and kwargs, taking into account
+        the alternative specification syntaxes.
+        """
+
+        # Only one arg which is already a widget output -> returns it as is
+        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], (ObsplotWidget)):
+            spec = "widget"
+        # Only one dict arg -> spec passed as dict
+        elif len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], dict):
+            spec = args[0]
+        # Only one kwarg called spec
+        elif len(args) == 0 and len(kwargs) == 1 and "spec" in kwargs:
+            spec = kwargs["spec"]
+        # Only kwargs -> spec is kwargs
+        elif len(args) == 0 and len(kwargs) > 0:
+            spec = kwargs
+        # No arguments given
+        elif len(args) == 0 and len(kwargs) == 0:
+            raise ValueError("Missing plot specification")
+        else:
+            raise ValueError("Incorrect plot specification")
+        return spec
+
+
+class ObsplotWidgetCreator(ObsplotCreator):
     """
     Widget renderer Creator class.
     """
 
-    def __init__(self, *args, **kwargs) -> None:
-        pass
+    def __init__(self, debug: bool = False) -> None:
+        self._debug = debug
 
-    def __call__(self, *args, **kwargs):
+    def __call__(self, *args, **kwargs) -> ObsplotWidget:
         """
         Method called whent an instance is called.
         """
-        spec = Obsplot.get_spec(*args, **kwargs)
-        return ObsplotWidget(spec)
+        spec = self.get_spec(*args, **kwargs)
+        if spec == "widget":
+            return args[0]
+        return ObsplotWidget(spec, debug=self._debug)
 
 
-class ObsplotJsdomCreator:
+class ObsplotJsdomCreator(ObsplotCreator):
     """
     Jsdom renderer Creator class.
     """
 
-    def __init___(self, *args, **kwargs) -> None:
+    def __init__(self) -> None:
         pass
 
-    def __call__(self, *args, **kwargs):
+    def __call__(self, *args, **kwargs) -> None:
         """
         Method called whent an instance is called.
         """
-        spec = Obsplot.get_spec(*args, **kwargs)
+        spec = self.get_spec(*args, **kwargs)
+        if spec == "widget":
+            raise ValueError("Incorrect plot specification")
         display(ObsplotJsdom(spec).plot())
```

### Comparing `pyobsplot-0.3.0/src/pyobsplot/parsing.py` & `pyobsplot-0.3.1/src/pyobsplot/parsing.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Plot specification parsing.
 """
 
 import datetime
+import json
 import base64
 import pandas as pd
 import polars as pl
 
 from typing import Any, Optional
 
 from .data import pd_to_arrow, pl_to_arrow
@@ -49,17 +50,20 @@
 
         Returns:
             Any: parsed specification or part of a specification.
         """
         if spec is None:
             return None
         # If list or tuple, recursively parse elements
-        if isinstance(spec, list) or isinstance(spec, tuple):
+        if isinstance(spec, (list, tuple)):
             return [self.parse(s) for s in spec]
-        # If Geojson, handle caching, don't parse, add type and returns as is
+        # If Geojson as string, parse as dict and continue parsing
+        if isinstance(spec, str) and spec[0:28] == '{"type": "FeatureCollection"':
+            spec = json.loads(spec)
+        # If Geojson as dict, handle caching, don't parse, add type and returns as is
         if (
             isinstance(spec, dict)
             and "type" in spec
             and spec["type"] == "FeatureCollection"
         ):
             index = self.cache_index(spec)
             if index is None:
@@ -135,53 +139,14 @@
                 result.append({"pyobsplot-type": "DataFrame", "value": value})
             # Else, keep as is
             else:
                 result.append(d)
         return result
 
 
-class JSModule(type):
-    """metaclass to allow JavaScript module and methods handling."""
-
-    def __getattr__(cls: type, name: str) -> callable:
-        """Intercept methods calling and returns a parsed and typed dict object."""
-
-        def wrapper(*args, **kwargs) -> dict:
-            if kwargs:
-                raise ValueError(
-                    f"kwargs must not be passed to {cls.__name__}.{name} : {kwargs}"
-                )
-            return {
-                "pyobsplot-type": "function",
-                "module": cls.__name__,
-                "method": name,
-                "args": args,
-            }
-
-        return wrapper
-
-
-class Plot(metaclass=JSModule):
-    """JSModule class to allow Plot objects in specification."""
-
-    pass
-
-
-class d3(metaclass=JSModule):
-    """JSModule class to allow d3 objects in specification."""
-
-    pass
-
-
-class Math(metaclass=JSModule):
-    """JSModule class to allow Math objects in specification."""
-
-    pass
-
-
 def js(txt: str) -> dict:
     """Tag a string as JavaScript code.
 
     Args:
         txt (str): string containing JavaScript code.
 
     Returns:
```

### Comparing `pyobsplot-0.3.0/src/pyobsplot/static/widget.js` & `pyobsplot-0.3.1/src/pyobsplot/static/widget.js`

 * *Files 22% similar despite different names*

#### js-beautify {}

```diff
@@ -40,116 +40,116 @@
 ));
 
 // node_modules/binary-search-bounds/search-bounds.js
 var require_search_bounds = __commonJS({
     "node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
         "use strict";
 
-        function ge(a4, y4, c6, l, h) {
+        function ge(a7, y7, c11, l, h) {
             var i = h + 1;
             while (l <= h) {
-                var m3 = l + h >>> 1,
-                    x4 = a4[m3];
-                var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
                 if (p >= 0) {
-                    i = m3;
-                    h = m3 - 1;
+                    i = m5;
+                    h = m5 - 1;
                 } else {
-                    l = m3 + 1;
+                    l = m5 + 1;
                 }
             }
             return i;
         }
 
-        function gt(a4, y4, c6, l, h) {
+        function gt(a7, y7, c11, l, h) {
             var i = h + 1;
             while (l <= h) {
-                var m3 = l + h >>> 1,
-                    x4 = a4[m3];
-                var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
                 if (p > 0) {
-                    i = m3;
-                    h = m3 - 1;
+                    i = m5;
+                    h = m5 - 1;
                 } else {
-                    l = m3 + 1;
+                    l = m5 + 1;
                 }
             }
             return i;
         }
 
-        function lt(a4, y4, c6, l, h) {
+        function lt(a7, y7, c11, l, h) {
             var i = l - 1;
             while (l <= h) {
-                var m3 = l + h >>> 1,
-                    x4 = a4[m3];
-                var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
                 if (p < 0) {
-                    i = m3;
-                    l = m3 + 1;
+                    i = m5;
+                    l = m5 + 1;
                 } else {
-                    h = m3 - 1;
+                    h = m5 - 1;
                 }
             }
             return i;
         }
 
-        function le(a4, y4, c6, l, h) {
+        function le(a7, y7, c11, l, h) {
             var i = l - 1;
             while (l <= h) {
-                var m3 = l + h >>> 1,
-                    x4 = a4[m3];
-                var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
                 if (p <= 0) {
-                    i = m3;
-                    l = m3 + 1;
+                    i = m5;
+                    l = m5 + 1;
                 } else {
-                    h = m3 - 1;
+                    h = m5 - 1;
                 }
             }
             return i;
         }
 
-        function eq(a4, y4, c6, l, h) {
+        function eq(a7, y7, c11, l, h) {
             while (l <= h) {
-                var m3 = l + h >>> 1,
-                    x4 = a4[m3];
-                var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
                 if (p === 0) {
-                    return m3;
+                    return m5;
                 }
                 if (p <= 0) {
-                    l = m3 + 1;
+                    l = m5 + 1;
                 } else {
-                    h = m3 - 1;
+                    h = m5 - 1;
                 }
             }
             return -1;
         }
 
-        function norm(a4, y4, c6, l, h, f) {
-            if (typeof c6 === "function") {
-                return f(a4, y4, c6, l === void 0 ? 0 : l | 0, h === void 0 ? a4.length - 1 : h | 0);
+        function norm(a7, y7, c11, l, h, f) {
+            if (typeof c11 === "function") {
+                return f(a7, y7, c11, l === void 0 ? 0 : l | 0, h === void 0 ? a7.length - 1 : h | 0);
             }
-            return f(a4, y4, void 0, c6 === void 0 ? 0 : c6 | 0, l === void 0 ? a4.length - 1 : l | 0);
+            return f(a7, y7, void 0, c11 === void 0 ? 0 : c11 | 0, l === void 0 ? a7.length - 1 : l | 0);
         }
         module.exports = {
-            ge: function(a4, y4, c6, l, h) {
-                return norm(a4, y4, c6, l, h, ge);
+            ge: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, ge);
             },
-            gt: function(a4, y4, c6, l, h) {
-                return norm(a4, y4, c6, l, h, gt);
+            gt: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, gt);
             },
-            lt: function(a4, y4, c6, l, h) {
-                return norm(a4, y4, c6, l, h, lt);
+            lt: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, lt);
             },
-            le: function(a4, y4, c6, l, h) {
-                return norm(a4, y4, c6, l, h, le);
+            le: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, le);
             },
-            eq: function(a4, y4, c6, l, h) {
-                return norm(a4, y4, c6, l, h, eq);
+            eq: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, eq);
             }
         };
     }
 });
 
 // node_modules/interval-tree-1d/interval-tree.js
 var require_interval_tree = __commonJS({
@@ -157,52 +157,52 @@
         "use strict";
         var bounds = require_search_bounds();
         var NOT_FOUND = 0;
         var SUCCESS = 1;
         var EMPTY = 2;
         module.exports = createWrapper;
 
-        function IntervalTreeNode(mid2, left2, right2, leftPoints, rightPoints) {
-            this.mid = mid2;
-            this.left = left2;
-            this.right = right2;
+        function IntervalTreeNode(mid3, left3, right3, leftPoints, rightPoints) {
+            this.mid = mid3;
+            this.left = left3;
+            this.right = right3;
             this.leftPoints = leftPoints;
             this.rightPoints = rightPoints;
-            this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;
+            this.count = (left3 ? left3.count : 0) + (right3 ? right3.count : 0) + leftPoints.length;
         }
         var proto = IntervalTreeNode.prototype;
 
-        function copy3(a4, b) {
-            a4.mid = b.mid;
-            a4.left = b.left;
-            a4.right = b.right;
-            a4.leftPoints = b.leftPoints;
-            a4.rightPoints = b.rightPoints;
-            a4.count = b.count;
+        function copy5(a7, b) {
+            a7.mid = b.mid;
+            a7.left = b.left;
+            a7.right = b.right;
+            a7.leftPoints = b.leftPoints;
+            a7.rightPoints = b.rightPoints;
+            a7.count = b.count;
         }
 
         function rebuild(node, intervals) {
             var ntree = createIntervalTree(intervals);
             node.mid = ntree.mid;
             node.left = ntree.left;
             node.right = ntree.right;
             node.leftPoints = ntree.leftPoints;
             node.rightPoints = ntree.rightPoints;
             node.count = ntree.count;
         }
 
-        function rebuildWithInterval(node, interval2) {
+        function rebuildWithInterval(node, interval3) {
             var intervals = node.intervals([]);
-            intervals.push(interval2);
+            intervals.push(interval3);
             rebuild(node, intervals);
         }
 
-        function rebuildWithoutInterval(node, interval2) {
+        function rebuildWithoutInterval(node, interval3) {
             var intervals = node.intervals([]);
-            var idx = intervals.indexOf(interval2);
+            var idx = intervals.indexOf(interval3);
             if (idx < 0) {
                 return NOT_FOUND;
             }
             intervals.splice(idx, 1);
             rebuild(node, intervals);
             return SUCCESS;
         }
@@ -212,89 +212,89 @@
                 this.left.intervals(result);
             }
             if (this.right) {
                 this.right.intervals(result);
             }
             return result;
         };
-        proto.insert = function(interval2) {
+        proto.insert = function(interval3) {
             var weight = this.count - this.leftPoints.length;
             this.count += 1;
-            if (interval2[1] < this.mid) {
+            if (interval3[1] < this.mid) {
                 if (this.left) {
                     if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
-                        rebuildWithInterval(this, interval2);
+                        rebuildWithInterval(this, interval3);
                     } else {
-                        this.left.insert(interval2);
+                        this.left.insert(interval3);
                     }
                 } else {
-                    this.left = createIntervalTree([interval2]);
+                    this.left = createIntervalTree([interval3]);
                 }
-            } else if (interval2[0] > this.mid) {
+            } else if (interval3[0] > this.mid) {
                 if (this.right) {
                     if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
-                        rebuildWithInterval(this, interval2);
+                        rebuildWithInterval(this, interval3);
                     } else {
-                        this.right.insert(interval2);
+                        this.right.insert(interval3);
                     }
                 } else {
-                    this.right = createIntervalTree([interval2]);
+                    this.right = createIntervalTree([interval3]);
                 }
             } else {
-                var l = bounds.ge(this.leftPoints, interval2, compareBegin);
-                var r = bounds.ge(this.rightPoints, interval2, compareEnd);
-                this.leftPoints.splice(l, 0, interval2);
-                this.rightPoints.splice(r, 0, interval2);
+                var l = bounds.ge(this.leftPoints, interval3, compareBegin);
+                var r = bounds.ge(this.rightPoints, interval3, compareEnd);
+                this.leftPoints.splice(l, 0, interval3);
+                this.rightPoints.splice(r, 0, interval3);
             }
         };
-        proto.remove = function(interval2) {
+        proto.remove = function(interval3) {
             var weight = this.count - this.leftPoints;
-            if (interval2[1] < this.mid) {
+            if (interval3[1] < this.mid) {
                 if (!this.left) {
                     return NOT_FOUND;
                 }
                 var rw = this.right ? this.right.count : 0;
                 if (4 * rw > 3 * (weight - 1)) {
-                    return rebuildWithoutInterval(this, interval2);
+                    return rebuildWithoutInterval(this, interval3);
                 }
-                var r = this.left.remove(interval2);
+                var r = this.left.remove(interval3);
                 if (r === EMPTY) {
                     this.left = null;
                     this.count -= 1;
                     return SUCCESS;
                 } else if (r === SUCCESS) {
                     this.count -= 1;
                 }
                 return r;
-            } else if (interval2[0] > this.mid) {
+            } else if (interval3[0] > this.mid) {
                 if (!this.right) {
                     return NOT_FOUND;
                 }
                 var lw = this.left ? this.left.count : 0;
                 if (4 * lw > 3 * (weight - 1)) {
-                    return rebuildWithoutInterval(this, interval2);
+                    return rebuildWithoutInterval(this, interval3);
                 }
-                var r = this.right.remove(interval2);
+                var r = this.right.remove(interval3);
                 if (r === EMPTY) {
                     this.right = null;
                     this.count -= 1;
                     return SUCCESS;
                 } else if (r === SUCCESS) {
                     this.count -= 1;
                 }
                 return r;
             } else {
                 if (this.count === 1) {
-                    if (this.leftPoints[0] === interval2) {
+                    if (this.leftPoints[0] === interval3) {
                         return EMPTY;
                     } else {
                         return NOT_FOUND;
                     }
                 }
-                if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
+                if (this.leftPoints.length === 1 && this.leftPoints[0] === interval3) {
                     if (this.left && this.right) {
                         var p = this;
                         var n = this.left;
                         while (n.right) {
                             p = n;
                             n = n.right;
                         }
@@ -304,34 +304,34 @@
                             var l = this.left;
                             var r = this.right;
                             p.count -= n.count;
                             p.right = n.left;
                             n.left = l;
                             n.right = r;
                         }
-                        copy3(this, n);
+                        copy5(this, n);
                         this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
                     } else if (this.left) {
-                        copy3(this, this.left);
+                        copy5(this, this.left);
                     } else {
-                        copy3(this, this.right);
+                        copy5(this, this.right);
                     }
                     return SUCCESS;
                 }
-                for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {
-                    if (this.leftPoints[l][0] !== interval2[0]) {
+                for (var l = bounds.ge(this.leftPoints, interval3, compareBegin); l < this.leftPoints.length; ++l) {
+                    if (this.leftPoints[l][0] !== interval3[0]) {
                         break;
                     }
-                    if (this.leftPoints[l] === interval2) {
+                    if (this.leftPoints[l] === interval3) {
                         this.count -= 1;
                         this.leftPoints.splice(l, 1);
-                        for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {
-                            if (this.rightPoints[r][1] !== interval2[1]) {
+                        for (var r = bounds.ge(this.rightPoints, interval3, compareEnd); r < this.rightPoints.length; ++r) {
+                            if (this.rightPoints[r][1] !== interval3[1]) {
                                 break;
-                            } else if (this.rightPoints[r] === interval2) {
+                            } else if (this.rightPoints[r] === interval3) {
                                 this.rightPoints.splice(r, 1);
                                 return SUCCESS;
                             }
                         }
                     }
                 }
                 return NOT_FOUND;
@@ -360,31 +360,31 @@
             for (var i = 0; i < arr.length; ++i) {
                 var r = cb(arr[i]);
                 if (r) {
                     return r;
                 }
             }
         }
-        proto.queryPoint = function(x4, cb) {
-            if (x4 < this.mid) {
+        proto.queryPoint = function(x7, cb) {
+            if (x7 < this.mid) {
                 if (this.left) {
-                    var r = this.left.queryPoint(x4, cb);
+                    var r = this.left.queryPoint(x7, cb);
                     if (r) {
                         return r;
                     }
                 }
-                return reportLeftRange(this.leftPoints, x4, cb);
-            } else if (x4 > this.mid) {
+                return reportLeftRange(this.leftPoints, x7, cb);
+            } else if (x7 > this.mid) {
                 if (this.right) {
-                    var r = this.right.queryPoint(x4, cb);
+                    var r = this.right.queryPoint(x7, cb);
                     if (r) {
                         return r;
                     }
                 }
-                return reportRightRange(this.rightPoints, x4, cb);
+                return reportRightRange(this.rightPoints, x7, cb);
             } else {
                 return reportRange(this.leftPoints, cb);
             }
         };
         proto.queryInterval = function(lo, hi, cb) {
             if (lo < this.mid && this.left) {
                 var r = this.left.queryInterval(lo, hi, cb);
@@ -403,84 +403,84 @@
             } else if (lo > this.mid) {
                 return reportRightRange(this.rightPoints, lo, cb);
             } else {
                 return reportRange(this.leftPoints, cb);
             }
         };
 
-        function compareNumbers(a4, b) {
-            return a4 - b;
+        function compareNumbers(a7, b) {
+            return a7 - b;
         }
 
-        function compareBegin(a4, b) {
-            var d = a4[0] - b[0];
+        function compareBegin(a7, b) {
+            var d = a7[0] - b[0];
             if (d) {
                 return d;
             }
-            return a4[1] - b[1];
+            return a7[1] - b[1];
         }
 
-        function compareEnd(a4, b) {
-            var d = a4[1] - b[1];
+        function compareEnd(a7, b) {
+            var d = a7[1] - b[1];
             if (d) {
                 return d;
             }
-            return a4[0] - b[0];
+            return a7[0] - b[0];
         }
 
         function createIntervalTree(intervals) {
             if (intervals.length === 0) {
                 return null;
             }
             var pts = [];
             for (var i = 0; i < intervals.length; ++i) {
                 pts.push(intervals[i][0], intervals[i][1]);
             }
             pts.sort(compareNumbers);
-            var mid2 = pts[pts.length >> 1];
+            var mid3 = pts[pts.length >> 1];
             var leftIntervals = [];
             var rightIntervals = [];
             var centerIntervals = [];
             for (var i = 0; i < intervals.length; ++i) {
-                var s2 = intervals[i];
-                if (s2[1] < mid2) {
-                    leftIntervals.push(s2);
-                } else if (mid2 < s2[0]) {
-                    rightIntervals.push(s2);
+                var s3 = intervals[i];
+                if (s3[1] < mid3) {
+                    leftIntervals.push(s3);
+                } else if (mid3 < s3[0]) {
+                    rightIntervals.push(s3);
                 } else {
-                    centerIntervals.push(s2);
+                    centerIntervals.push(s3);
                 }
             }
             var leftPoints = centerIntervals;
             var rightPoints = centerIntervals.slice();
             leftPoints.sort(compareBegin);
             rightPoints.sort(compareEnd);
             return new IntervalTreeNode(
-                mid2,
+                mid3,
                 createIntervalTree(leftIntervals),
                 createIntervalTree(rightIntervals),
                 leftPoints,
                 rightPoints
             );
         }
 
-        function IntervalTree2(root3) {
-            this.root = root3;
+        function IntervalTree3(root5) {
+            this.root = root5;
         }
-        var tproto = IntervalTree2.prototype;
-        tproto.insert = function(interval2) {
+        var tproto = IntervalTree3.prototype;
+        tproto.insert = function(interval3) {
             if (this.root) {
-                this.root.insert(interval2);
+                this.root.insert(interval3);
             } else {
-                this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
+                this.root = new IntervalTreeNode(interval3[0], null, null, [interval3], [interval3]);
             }
         };
-        tproto.remove = function(interval2) {
+        tproto.remove = function(interval3) {
             if (this.root) {
-                var r = this.root.remove(interval2);
+                var r = this.root.remove(interval3);
                 if (r === EMPTY) {
                     this.root = null;
                 }
                 return r !== NOT_FOUND;
             }
             return false;
         };
@@ -509,17 +509,498 @@
                 }
                 return [];
             }
         });
 
         function createWrapper(intervals) {
             if (!intervals || intervals.length === 0) {
-                return new IntervalTree2(null);
+                return new IntervalTree3(null);
             }
-            return new IntervalTree2(createIntervalTree(intervals));
+            return new IntervalTree3(createIntervalTree(intervals));
+        }
+    }
+});
+
+// js/pyobsplot-js/node_modules/binary-search-bounds/search-bounds.js
+var require_search_bounds2 = __commonJS({
+    "js/pyobsplot-js/node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
+        "use strict";
+
+        function ge(a7, y7, c11, l, h) {
+            var i = h + 1;
+            while (l <= h) {
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
+                if (p >= 0) {
+                    i = m5;
+                    h = m5 - 1;
+                } else {
+                    l = m5 + 1;
+                }
+            }
+            return i;
+        }
+
+        function gt(a7, y7, c11, l, h) {
+            var i = h + 1;
+            while (l <= h) {
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
+                if (p > 0) {
+                    i = m5;
+                    h = m5 - 1;
+                } else {
+                    l = m5 + 1;
+                }
+            }
+            return i;
+        }
+
+        function lt(a7, y7, c11, l, h) {
+            var i = l - 1;
+            while (l <= h) {
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
+                if (p < 0) {
+                    i = m5;
+                    l = m5 + 1;
+                } else {
+                    h = m5 - 1;
+                }
+            }
+            return i;
+        }
+
+        function le(a7, y7, c11, l, h) {
+            var i = l - 1;
+            while (l <= h) {
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
+                if (p <= 0) {
+                    i = m5;
+                    l = m5 + 1;
+                } else {
+                    h = m5 - 1;
+                }
+            }
+            return i;
+        }
+
+        function eq(a7, y7, c11, l, h) {
+            while (l <= h) {
+                var m5 = l + h >>> 1,
+                    x7 = a7[m5];
+                var p = c11 !== void 0 ? c11(x7, y7) : x7 - y7;
+                if (p === 0) {
+                    return m5;
+                }
+                if (p <= 0) {
+                    l = m5 + 1;
+                } else {
+                    h = m5 - 1;
+                }
+            }
+            return -1;
+        }
+
+        function norm(a7, y7, c11, l, h, f) {
+            if (typeof c11 === "function") {
+                return f(a7, y7, c11, l === void 0 ? 0 : l | 0, h === void 0 ? a7.length - 1 : h | 0);
+            }
+            return f(a7, y7, void 0, c11 === void 0 ? 0 : c11 | 0, l === void 0 ? a7.length - 1 : l | 0);
+        }
+        module.exports = {
+            ge: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, ge);
+            },
+            gt: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, gt);
+            },
+            lt: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, lt);
+            },
+            le: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, le);
+            },
+            eq: function(a7, y7, c11, l, h) {
+                return norm(a7, y7, c11, l, h, eq);
+            }
+        };
+    }
+});
+
+// js/pyobsplot-js/node_modules/interval-tree-1d/interval-tree.js
+var require_interval_tree2 = __commonJS({
+    "js/pyobsplot-js/node_modules/interval-tree-1d/interval-tree.js"(exports, module) {
+        "use strict";
+        var bounds = require_search_bounds2();
+        var NOT_FOUND = 0;
+        var SUCCESS = 1;
+        var EMPTY = 2;
+        module.exports = createWrapper;
+
+        function IntervalTreeNode(mid3, left3, right3, leftPoints, rightPoints) {
+            this.mid = mid3;
+            this.left = left3;
+            this.right = right3;
+            this.leftPoints = leftPoints;
+            this.rightPoints = rightPoints;
+            this.count = (left3 ? left3.count : 0) + (right3 ? right3.count : 0) + leftPoints.length;
+        }
+        var proto = IntervalTreeNode.prototype;
+
+        function copy5(a7, b) {
+            a7.mid = b.mid;
+            a7.left = b.left;
+            a7.right = b.right;
+            a7.leftPoints = b.leftPoints;
+            a7.rightPoints = b.rightPoints;
+            a7.count = b.count;
+        }
+
+        function rebuild(node, intervals) {
+            var ntree = createIntervalTree(intervals);
+            node.mid = ntree.mid;
+            node.left = ntree.left;
+            node.right = ntree.right;
+            node.leftPoints = ntree.leftPoints;
+            node.rightPoints = ntree.rightPoints;
+            node.count = ntree.count;
+        }
+
+        function rebuildWithInterval(node, interval3) {
+            var intervals = node.intervals([]);
+            intervals.push(interval3);
+            rebuild(node, intervals);
+        }
+
+        function rebuildWithoutInterval(node, interval3) {
+            var intervals = node.intervals([]);
+            var idx = intervals.indexOf(interval3);
+            if (idx < 0) {
+                return NOT_FOUND;
+            }
+            intervals.splice(idx, 1);
+            rebuild(node, intervals);
+            return SUCCESS;
+        }
+        proto.intervals = function(result) {
+            result.push.apply(result, this.leftPoints);
+            if (this.left) {
+                this.left.intervals(result);
+            }
+            if (this.right) {
+                this.right.intervals(result);
+            }
+            return result;
+        };
+        proto.insert = function(interval3) {
+            var weight = this.count - this.leftPoints.length;
+            this.count += 1;
+            if (interval3[1] < this.mid) {
+                if (this.left) {
+                    if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
+                        rebuildWithInterval(this, interval3);
+                    } else {
+                        this.left.insert(interval3);
+                    }
+                } else {
+                    this.left = createIntervalTree([interval3]);
+                }
+            } else if (interval3[0] > this.mid) {
+                if (this.right) {
+                    if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
+                        rebuildWithInterval(this, interval3);
+                    } else {
+                        this.right.insert(interval3);
+                    }
+                } else {
+                    this.right = createIntervalTree([interval3]);
+                }
+            } else {
+                var l = bounds.ge(this.leftPoints, interval3, compareBegin);
+                var r = bounds.ge(this.rightPoints, interval3, compareEnd);
+                this.leftPoints.splice(l, 0, interval3);
+                this.rightPoints.splice(r, 0, interval3);
+            }
+        };
+        proto.remove = function(interval3) {
+            var weight = this.count - this.leftPoints;
+            if (interval3[1] < this.mid) {
+                if (!this.left) {
+                    return NOT_FOUND;
+                }
+                var rw = this.right ? this.right.count : 0;
+                if (4 * rw > 3 * (weight - 1)) {
+                    return rebuildWithoutInterval(this, interval3);
+                }
+                var r = this.left.remove(interval3);
+                if (r === EMPTY) {
+                    this.left = null;
+                    this.count -= 1;
+                    return SUCCESS;
+                } else if (r === SUCCESS) {
+                    this.count -= 1;
+                }
+                return r;
+            } else if (interval3[0] > this.mid) {
+                if (!this.right) {
+                    return NOT_FOUND;
+                }
+                var lw = this.left ? this.left.count : 0;
+                if (4 * lw > 3 * (weight - 1)) {
+                    return rebuildWithoutInterval(this, interval3);
+                }
+                var r = this.right.remove(interval3);
+                if (r === EMPTY) {
+                    this.right = null;
+                    this.count -= 1;
+                    return SUCCESS;
+                } else if (r === SUCCESS) {
+                    this.count -= 1;
+                }
+                return r;
+            } else {
+                if (this.count === 1) {
+                    if (this.leftPoints[0] === interval3) {
+                        return EMPTY;
+                    } else {
+                        return NOT_FOUND;
+                    }
+                }
+                if (this.leftPoints.length === 1 && this.leftPoints[0] === interval3) {
+                    if (this.left && this.right) {
+                        var p = this;
+                        var n = this.left;
+                        while (n.right) {
+                            p = n;
+                            n = n.right;
+                        }
+                        if (p === this) {
+                            n.right = this.right;
+                        } else {
+                            var l = this.left;
+                            var r = this.right;
+                            p.count -= n.count;
+                            p.right = n.left;
+                            n.left = l;
+                            n.right = r;
+                        }
+                        copy5(this, n);
+                        this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
+                    } else if (this.left) {
+                        copy5(this, this.left);
+                    } else {
+                        copy5(this, this.right);
+                    }
+                    return SUCCESS;
+                }
+                for (var l = bounds.ge(this.leftPoints, interval3, compareBegin); l < this.leftPoints.length; ++l) {
+                    if (this.leftPoints[l][0] !== interval3[0]) {
+                        break;
+                    }
+                    if (this.leftPoints[l] === interval3) {
+                        this.count -= 1;
+                        this.leftPoints.splice(l, 1);
+                        for (var r = bounds.ge(this.rightPoints, interval3, compareEnd); r < this.rightPoints.length; ++r) {
+                            if (this.rightPoints[r][1] !== interval3[1]) {
+                                break;
+                            } else if (this.rightPoints[r] === interval3) {
+                                this.rightPoints.splice(r, 1);
+                                return SUCCESS;
+                            }
+                        }
+                    }
+                }
+                return NOT_FOUND;
+            }
+        };
+
+        function reportLeftRange(arr, hi, cb) {
+            for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
+                var r = cb(arr[i]);
+                if (r) {
+                    return r;
+                }
+            }
+        }
+
+        function reportRightRange(arr, lo, cb) {
+            for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
+                var r = cb(arr[i]);
+                if (r) {
+                    return r;
+                }
+            }
+        }
+
+        function reportRange(arr, cb) {
+            for (var i = 0; i < arr.length; ++i) {
+                var r = cb(arr[i]);
+                if (r) {
+                    return r;
+                }
+            }
+        }
+        proto.queryPoint = function(x7, cb) {
+            if (x7 < this.mid) {
+                if (this.left) {
+                    var r = this.left.queryPoint(x7, cb);
+                    if (r) {
+                        return r;
+                    }
+                }
+                return reportLeftRange(this.leftPoints, x7, cb);
+            } else if (x7 > this.mid) {
+                if (this.right) {
+                    var r = this.right.queryPoint(x7, cb);
+                    if (r) {
+                        return r;
+                    }
+                }
+                return reportRightRange(this.rightPoints, x7, cb);
+            } else {
+                return reportRange(this.leftPoints, cb);
+            }
+        };
+        proto.queryInterval = function(lo, hi, cb) {
+            if (lo < this.mid && this.left) {
+                var r = this.left.queryInterval(lo, hi, cb);
+                if (r) {
+                    return r;
+                }
+            }
+            if (hi > this.mid && this.right) {
+                var r = this.right.queryInterval(lo, hi, cb);
+                if (r) {
+                    return r;
+                }
+            }
+            if (hi < this.mid) {
+                return reportLeftRange(this.leftPoints, hi, cb);
+            } else if (lo > this.mid) {
+                return reportRightRange(this.rightPoints, lo, cb);
+            } else {
+                return reportRange(this.leftPoints, cb);
+            }
+        };
+
+        function compareNumbers(a7, b) {
+            return a7 - b;
+        }
+
+        function compareBegin(a7, b) {
+            var d = a7[0] - b[0];
+            if (d) {
+                return d;
+            }
+            return a7[1] - b[1];
+        }
+
+        function compareEnd(a7, b) {
+            var d = a7[1] - b[1];
+            if (d) {
+                return d;
+            }
+            return a7[0] - b[0];
+        }
+
+        function createIntervalTree(intervals) {
+            if (intervals.length === 0) {
+                return null;
+            }
+            var pts = [];
+            for (var i = 0; i < intervals.length; ++i) {
+                pts.push(intervals[i][0], intervals[i][1]);
+            }
+            pts.sort(compareNumbers);
+            var mid3 = pts[pts.length >> 1];
+            var leftIntervals = [];
+            var rightIntervals = [];
+            var centerIntervals = [];
+            for (var i = 0; i < intervals.length; ++i) {
+                var s3 = intervals[i];
+                if (s3[1] < mid3) {
+                    leftIntervals.push(s3);
+                } else if (mid3 < s3[0]) {
+                    rightIntervals.push(s3);
+                } else {
+                    centerIntervals.push(s3);
+                }
+            }
+            var leftPoints = centerIntervals;
+            var rightPoints = centerIntervals.slice();
+            leftPoints.sort(compareBegin);
+            rightPoints.sort(compareEnd);
+            return new IntervalTreeNode(
+                mid3,
+                createIntervalTree(leftIntervals),
+                createIntervalTree(rightIntervals),
+                leftPoints,
+                rightPoints
+            );
+        }
+
+        function IntervalTree3(root5) {
+            this.root = root5;
+        }
+        var tproto = IntervalTree3.prototype;
+        tproto.insert = function(interval3) {
+            if (this.root) {
+                this.root.insert(interval3);
+            } else {
+                this.root = new IntervalTreeNode(interval3[0], null, null, [interval3], [interval3]);
+            }
+        };
+        tproto.remove = function(interval3) {
+            if (this.root) {
+                var r = this.root.remove(interval3);
+                if (r === EMPTY) {
+                    this.root = null;
+                }
+                return r !== NOT_FOUND;
+            }
+            return false;
+        };
+        tproto.queryPoint = function(p, cb) {
+            if (this.root) {
+                return this.root.queryPoint(p, cb);
+            }
+        };
+        tproto.queryInterval = function(lo, hi, cb) {
+            if (lo <= hi && this.root) {
+                return this.root.queryInterval(lo, hi, cb);
+            }
+        };
+        Object.defineProperty(tproto, "count", {
+            get: function() {
+                if (this.root) {
+                    return this.root.count;
+                }
+                return 0;
+            }
+        });
+        Object.defineProperty(tproto, "intervals", {
+            get: function() {
+                if (this.root) {
+                    return this.root.intervals([]);
+                }
+                return [];
+            }
+        });
+
+        function createWrapper(intervals) {
+            if (!intervals || intervals.length === 0) {
+                return new IntervalTree3(null);
+            }
+            return new IntervalTree3(createIntervalTree(intervals));
         }
     }
 });
 
 // node_modules/@observablehq/plot/src/index.js
 var src_exports2 = {};
 __export(src_exports2, {
@@ -1244,439 +1725,439 @@
     zip: () => zip,
     zoom: () => zoom_default2,
     zoomIdentity: () => identity5,
     zoomTransform: () => transform
 });
 
 // node_modules/d3-array/src/ascending.js
-function ascending(a4, b) {
-    return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
+function ascending(a7, b) {
+    return a7 == null || b == null ? NaN : a7 < b ? -1 : a7 > b ? 1 : a7 >= b ? 0 : NaN;
 }
 
 // node_modules/d3-array/src/descending.js
-function descending(a4, b) {
-    return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
+function descending(a7, b) {
+    return a7 == null || b == null ? NaN : b < a7 ? -1 : b > a7 ? 1 : b >= a7 ? 0 : NaN;
 }
 
 // node_modules/d3-array/src/bisector.js
 function bisector(f) {
     let compare1, compare2, delta;
     if (f.length !== 2) {
         compare1 = ascending;
-        compare2 = (d, x4) => ascending(f(d), x4);
-        delta = (d, x4) => f(d) - x4;
+        compare2 = (d, x7) => ascending(f(d), x7);
+        delta = (d, x7) => f(d) - x7;
     } else {
         compare1 = f === ascending || f === descending ? f : zero;
         compare2 = f;
         delta = f;
     }
 
-    function left2(a4, x4, lo = 0, hi = a4.length) {
+    function left3(a7, x7, lo = 0, hi = a7.length) {
         if (lo < hi) {
-            if (compare1(x4, x4) !== 0)
+            if (compare1(x7, x7) !== 0)
                 return hi;
             do {
-                const mid2 = lo + hi >>> 1;
-                if (compare2(a4[mid2], x4) < 0)
-                    lo = mid2 + 1;
+                const mid3 = lo + hi >>> 1;
+                if (compare2(a7[mid3], x7) < 0)
+                    lo = mid3 + 1;
                 else
-                    hi = mid2;
+                    hi = mid3;
             } while (lo < hi);
         }
         return lo;
     }
 
-    function right2(a4, x4, lo = 0, hi = a4.length) {
+    function right3(a7, x7, lo = 0, hi = a7.length) {
         if (lo < hi) {
-            if (compare1(x4, x4) !== 0)
+            if (compare1(x7, x7) !== 0)
                 return hi;
             do {
-                const mid2 = lo + hi >>> 1;
-                if (compare2(a4[mid2], x4) <= 0)
-                    lo = mid2 + 1;
+                const mid3 = lo + hi >>> 1;
+                if (compare2(a7[mid3], x7) <= 0)
+                    lo = mid3 + 1;
                 else
-                    hi = mid2;
+                    hi = mid3;
             } while (lo < hi);
         }
         return lo;
     }
 
-    function center2(a4, x4, lo = 0, hi = a4.length) {
-        const i = left2(a4, x4, lo, hi - 1);
-        return i > lo && delta(a4[i - 1], x4) > -delta(a4[i], x4) ? i - 1 : i;
+    function center3(a7, x7, lo = 0, hi = a7.length) {
+        const i = left3(a7, x7, lo, hi - 1);
+        return i > lo && delta(a7[i - 1], x7) > -delta(a7[i], x7) ? i - 1 : i;
     }
     return {
-        left: left2,
-        center: center2,
-        right: right2
+        left: left3,
+        center: center3,
+        right: right3
     };
 }
 
 function zero() {
     return 0;
 }
 
 // node_modules/d3-array/src/number.js
-function number(x4) {
-    return x4 === null ? NaN : +x4;
+function number(x7) {
+    return x7 === null ? NaN : +x7;
 }
 
-function* numbers(values2, valueof2) {
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+function* numbers(values3, valueof3) {
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value != null && (value = +value) >= value) {
                 yield value;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
                 yield value;
             }
         }
     }
 }
 
 // node_modules/d3-array/src/bisect.js
 var ascendingBisect = bisector(ascending);
 var bisectRight = ascendingBisect.right;
 var bisectLeft = ascendingBisect.left;
 var bisectCenter = bisector(number).center;
 var bisect_default = bisectRight;
 
 // node_modules/d3-array/src/blur.js
-function blur(values2, r) {
+function blur(values3, r) {
     if (!((r = +r) >= 0))
         throw new RangeError("invalid r");
-    let length4 = values2.length;
-    if (!((length4 = Math.floor(length4)) >= 0))
+    let length7 = values3.length;
+    if (!((length7 = Math.floor(length7)) >= 0))
         throw new RangeError("invalid length");
-    if (!length4 || !r)
-        return values2;
-    const blur3 = blurf(r);
-    const temp = values2.slice();
-    blur3(values2, temp, 0, length4, 1);
-    blur3(temp, values2, 0, length4, 1);
-    blur3(values2, temp, 0, length4, 1);
-    return values2;
+    if (!length7 || !r)
+        return values3;
+    const blur4 = blurf(r);
+    const temp = values3.slice();
+    blur4(values3, temp, 0, length7, 1);
+    blur4(temp, values3, 0, length7, 1);
+    blur4(values3, temp, 0, length7, 1);
+    return values3;
 }
 var blur2 = Blur2(blurf);
 var blurImage = Blur2(blurfImage);
 
-function Blur2(blur3) {
+function Blur2(blur4) {
     return function(data, rx, ry = rx) {
         if (!((rx = +rx) >= 0))
             throw new RangeError("invalid rx");
         if (!((ry = +ry) >= 0))
             throw new RangeError("invalid ry");
         let {
-            data: values2,
+            data: values3,
             width,
             height
         } = data;
         if (!((width = Math.floor(width)) >= 0))
             throw new RangeError("invalid width");
-        if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0))
+        if (!((height = Math.floor(height !== void 0 ? height : values3.length / width)) >= 0))
             throw new RangeError("invalid height");
         if (!width || !height || !rx && !ry)
             return data;
-        const blurx = rx && blur3(rx);
-        const blury = ry && blur3(ry);
-        const temp = values2.slice();
+        const blurx = rx && blur4(rx);
+        const blury = ry && blur4(ry);
+        const temp = values3.slice();
         if (blurx && blury) {
-            blurh(blurx, temp, values2, width, height);
-            blurh(blurx, values2, temp, width, height);
-            blurh(blurx, temp, values2, width, height);
-            blurv(blury, values2, temp, width, height);
-            blurv(blury, temp, values2, width, height);
-            blurv(blury, values2, temp, width, height);
+            blurh(blurx, temp, values3, width, height);
+            blurh(blurx, values3, temp, width, height);
+            blurh(blurx, temp, values3, width, height);
+            blurv(blury, values3, temp, width, height);
+            blurv(blury, temp, values3, width, height);
+            blurv(blury, values3, temp, width, height);
         } else if (blurx) {
-            blurh(blurx, values2, temp, width, height);
-            blurh(blurx, temp, values2, width, height);
-            blurh(blurx, values2, temp, width, height);
+            blurh(blurx, values3, temp, width, height);
+            blurh(blurx, temp, values3, width, height);
+            blurh(blurx, values3, temp, width, height);
         } else if (blury) {
-            blurv(blury, values2, temp, width, height);
-            blurv(blury, temp, values2, width, height);
-            blurv(blury, values2, temp, width, height);
+            blurv(blury, values3, temp, width, height);
+            blurv(blury, temp, values3, width, height);
+            blurv(blury, values3, temp, width, height);
         }
         return data;
     };
 }
 
-function blurh(blur3, T, S, w, h) {
-    for (let y4 = 0, n = w * h; y4 < n;) {
-        blur3(T, S, y4, y4 += w, 1);
+function blurh(blur4, T, S, w, h) {
+    for (let y7 = 0, n = w * h; y7 < n;) {
+        blur4(T, S, y7, y7 += w, 1);
     }
 }
 
-function blurv(blur3, T, S, w, h) {
-    for (let x4 = 0, n = w * h; x4 < w; ++x4) {
-        blur3(T, S, x4, x4 + n, w);
+function blurv(blur4, T, S, w, h) {
+    for (let x7 = 0, n = w * h; x7 < w; ++x7) {
+        blur4(T, S, x7, x7 + n, w);
     }
 }
 
-function blurfImage(radius2) {
-    const blur3 = blurf(radius2);
-    return (T, S, start2, stop, step) => {
-        start2 <<= 2, stop <<= 2, step <<= 2;
-        blur3(T, S, start2 + 0, stop + 0, step);
-        blur3(T, S, start2 + 1, stop + 1, step);
-        blur3(T, S, start2 + 2, stop + 2, step);
-        blur3(T, S, start2 + 3, stop + 3, step);
+function blurfImage(radius3) {
+    const blur4 = blurf(radius3);
+    return (T, S, start3, stop, step) => {
+        start3 <<= 2, stop <<= 2, step <<= 2;
+        blur4(T, S, start3 + 0, stop + 0, step);
+        blur4(T, S, start3 + 1, stop + 1, step);
+        blur4(T, S, start3 + 2, stop + 2, step);
+        blur4(T, S, start3 + 3, stop + 3, step);
     };
 }
 
-function blurf(radius2) {
-    const radius0 = Math.floor(radius2);
-    if (radius0 === radius2)
-        return bluri(radius2);
-    const t = radius2 - radius0;
-    const w = 2 * radius2 + 1;
-    return (T, S, start2, stop, step) => {
-        if (!((stop -= step) >= start2))
+function blurf(radius3) {
+    const radius0 = Math.floor(radius3);
+    if (radius0 === radius3)
+        return bluri(radius3);
+    const t = radius3 - radius0;
+    const w = 2 * radius3 + 1;
+    return (T, S, start3, stop, step) => {
+        if (!((stop -= step) >= start3))
             return;
-        let sum5 = radius0 * S[start2];
+        let sum8 = radius0 * S[start3];
         const s0 = step * radius0;
         const s1 = s0 + step;
-        for (let i = start2, j = start2 + s0; i < j; i += step) {
-            sum5 += S[Math.min(stop, i)];
+        for (let i = start3, j = start3 + s0; i < j; i += step) {
+            sum8 += S[Math.min(stop, i)];
         }
-        for (let i = start2, j = stop; i <= j; i += step) {
-            sum5 += S[Math.min(stop, i + s0)];
-            T[i] = (sum5 + t * (S[Math.max(start2, i - s1)] + S[Math.min(stop, i + s1)])) / w;
-            sum5 -= S[Math.max(start2, i - s0)];
+        for (let i = start3, j = stop; i <= j; i += step) {
+            sum8 += S[Math.min(stop, i + s0)];
+            T[i] = (sum8 + t * (S[Math.max(start3, i - s1)] + S[Math.min(stop, i + s1)])) / w;
+            sum8 -= S[Math.max(start3, i - s0)];
         }
     };
 }
 
-function bluri(radius2) {
-    const w = 2 * radius2 + 1;
-    return (T, S, start2, stop, step) => {
-        if (!((stop -= step) >= start2))
+function bluri(radius3) {
+    const w = 2 * radius3 + 1;
+    return (T, S, start3, stop, step) => {
+        if (!((stop -= step) >= start3))
             return;
-        let sum5 = radius2 * S[start2];
-        const s2 = step * radius2;
-        for (let i = start2, j = start2 + s2; i < j; i += step) {
-            sum5 += S[Math.min(stop, i)];
-        }
-        for (let i = start2, j = stop; i <= j; i += step) {
-            sum5 += S[Math.min(stop, i + s2)];
-            T[i] = sum5 / w;
-            sum5 -= S[Math.max(start2, i - s2)];
+        let sum8 = radius3 * S[start3];
+        const s3 = step * radius3;
+        for (let i = start3, j = start3 + s3; i < j; i += step) {
+            sum8 += S[Math.min(stop, i)];
+        }
+        for (let i = start3, j = stop; i <= j; i += step) {
+            sum8 += S[Math.min(stop, i + s3)];
+            T[i] = sum8 / w;
+            sum8 -= S[Math.max(start3, i - s3)];
         }
     };
 }
 
 // node_modules/d3-array/src/count.js
-function count(values2, valueof2) {
-    let count3 = 0;
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+function count(values3, valueof3) {
+    let count5 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value != null && (value = +value) >= value) {
-                ++count3;
+                ++count5;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {
-                ++count3;
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                ++count5;
             }
         }
     }
-    return count3;
+    return count5;
 }
 
 // node_modules/d3-array/src/cross.js
-function length(array4) {
-    return array4.length | 0;
+function length(array7) {
+    return array7.length | 0;
 }
 
-function empty(length4) {
-    return !(length4 > 0);
+function empty(length7) {
+    return !(length7 > 0);
 }
 
-function arrayify(values2) {
-    return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
+function arrayify(values3) {
+    return typeof values3 !== "object" || "length" in values3 ? values3 : Array.from(values3);
 }
 
-function reducer(reduce2) {
-    return (values2) => reduce2(...values2);
+function reducer(reduce3) {
+    return (values3) => reduce3(...values3);
 }
 
-function cross(...values2) {
-    const reduce2 = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
-    values2 = values2.map(arrayify);
-    const lengths = values2.map(length);
-    const j = values2.length - 1;
-    const index3 = new Array(j + 1).fill(0);
+function cross(...values3) {
+    const reduce3 = typeof values3[values3.length - 1] === "function" && reducer(values3.pop());
+    values3 = values3.map(arrayify);
+    const lengths = values3.map(length);
+    const j = values3.length - 1;
+    const index5 = new Array(j + 1).fill(0);
     const product = [];
     if (j < 0 || lengths.some(empty))
         return product;
     while (true) {
-        product.push(index3.map((j2, i2) => values2[i2][j2]));
+        product.push(index5.map((j2, i2) => values3[i2][j2]));
         let i = j;
-        while (++index3[i] === lengths[i]) {
+        while (++index5[i] === lengths[i]) {
             if (i === 0)
-                return reduce2 ? product.map(reduce2) : product;
-            index3[i--] = 0;
+                return reduce3 ? product.map(reduce3) : product;
+            index5[i--] = 0;
         }
     }
 }
 
 // node_modules/d3-array/src/cumsum.js
-function cumsum(values2, valueof2) {
-    var sum5 = 0,
-        index3 = 0;
-    return Float64Array.from(values2, valueof2 === void 0 ? (v2) => sum5 += +v2 || 0 : (v2) => sum5 += +valueof2(v2, index3++, values2) || 0);
+function cumsum(values3, valueof3) {
+    var sum8 = 0,
+        index5 = 0;
+    return Float64Array.from(values3, valueof3 === void 0 ? (v3) => sum8 += +v3 || 0 : (v3) => sum8 += +valueof3(v3, index5++, values3) || 0);
 }
 
 // node_modules/d3-array/src/variance.js
-function variance(values2, valueof2) {
-    let count3 = 0;
+function variance(values3, valueof3) {
+    let count5 = 0;
     let delta;
-    let mean2 = 0;
-    let sum5 = 0;
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+    let mean3 = 0;
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value != null && (value = +value) >= value) {
-                delta = value - mean2;
-                mean2 += delta / ++count3;
-                sum5 += delta * (value - mean2);
+                delta = value - mean3;
+                mean3 += delta / ++count5;
+                sum8 += delta * (value - mean3);
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {
-                delta = value - mean2;
-                mean2 += delta / ++count3;
-                sum5 += delta * (value - mean2);
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                delta = value - mean3;
+                mean3 += delta / ++count5;
+                sum8 += delta * (value - mean3);
             }
         }
     }
-    if (count3 > 1)
-        return sum5 / (count3 - 1);
+    if (count5 > 1)
+        return sum8 / (count5 - 1);
 }
 
 // node_modules/d3-array/src/deviation.js
-function deviation(values2, valueof2) {
-    const v2 = variance(values2, valueof2);
-    return v2 ? Math.sqrt(v2) : v2;
+function deviation(values3, valueof3) {
+    const v3 = variance(values3, valueof3);
+    return v3 ? Math.sqrt(v3) : v3;
 }
 
 // node_modules/d3-array/src/extent.js
-function extent(values2, valueof2) {
-    let min4;
-    let max5;
-    if (valueof2 === void 0) {
-        for (const value of values2) {
+function extent(values3, valueof3) {
+    let min7;
+    let max9;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
             if (value != null) {
-                if (min4 === void 0) {
+                if (min7 === void 0) {
                     if (value >= value)
-                        min4 = max5 = value;
+                        min7 = max9 = value;
                 } else {
-                    if (min4 > value)
-                        min4 = value;
-                    if (max5 < value)
-                        max5 = value;
+                    if (min7 > value)
+                        min7 = value;
+                    if (max9 < value)
+                        max9 = value;
                 }
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null) {
-                if (min4 === void 0) {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null) {
+                if (min7 === void 0) {
                     if (value >= value)
-                        min4 = max5 = value;
+                        min7 = max9 = value;
                 } else {
-                    if (min4 > value)
-                        min4 = value;
-                    if (max5 < value)
-                        max5 = value;
+                    if (min7 > value)
+                        min7 = value;
+                    if (max9 < value)
+                        max9 = value;
                 }
             }
         }
     }
-    return [min4, max5];
+    return [min7, max9];
 }
 
 // node_modules/d3-array/src/fsum.js
 var Adder = class {
     constructor() {
         this._partials = new Float64Array(32);
         this._n = 0;
     }
-    add(x4) {
+    add(x7) {
         const p = this._partials;
         let i = 0;
         for (let j = 0; j < this._n && j < 32; j++) {
-            const y4 = p[j],
-                hi = x4 + y4,
-                lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
+            const y7 = p[j],
+                hi = x7 + y7,
+                lo = Math.abs(x7) < Math.abs(y7) ? x7 - (hi - y7) : y7 - (hi - x7);
             if (lo)
                 p[i++] = lo;
-            x4 = hi;
+            x7 = hi;
         }
-        p[i] = x4;
+        p[i] = x7;
         this._n = i + 1;
         return this;
     }
     valueOf() {
         const p = this._partials;
         let n = this._n,
-            x4, y4, lo, hi = 0;
+            x7, y7, lo, hi = 0;
         if (n > 0) {
             hi = p[--n];
             while (n > 0) {
-                x4 = hi;
-                y4 = p[--n];
-                hi = x4 + y4;
-                lo = y4 - (hi - x4);
+                x7 = hi;
+                y7 = p[--n];
+                hi = x7 + y7;
+                lo = y7 - (hi - x7);
                 if (lo)
                     break;
             }
             if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
-                y4 = lo * 2;
-                x4 = hi + y4;
-                if (y4 == x4 - hi)
-                    hi = x4;
+                y7 = lo * 2;
+                x7 = hi + y7;
+                if (y7 == x7 - hi)
+                    hi = x7;
             }
         }
         return hi;
     }
 };
 
-function fsum(values2, valueof2) {
+function fsum(values3, valueof3) {
     const adder = new Adder();
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value = +value) {
                 adder.add(value);
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if (value = +valueof2(value, ++index3, values2)) {
+        let index5 = -1;
+        for (let value of values3) {
+            if (value = +valueof3(value, ++index5, values3)) {
                 adder.add(value);
             }
         }
     }
     return +adder;
 }
 
-function fcumsum(values2, valueof2) {
+function fcumsum(values3, valueof3) {
     const adder = new Adder();
-    let index3 = -1;
+    let index5 = -1;
     return Float64Array.from(
-        values2,
-        valueof2 === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof2(v2, ++index3, values2) || 0)
+        values3,
+        valueof3 === void 0 ? (v3) => adder.add(+v3 || 0) : (v3) => adder.add(+valueof3(v3, ++index5, values3) || 0)
     );
 }
 
 // node_modules/internmap/src/index.js
 var InternMap = class extends Map {
     constructor(entries, key = keyof) {
         super();
@@ -1702,26 +2183,26 @@
         return super.set(intern_set(this, key), value);
     }
     delete(key) {
         return super.delete(intern_delete(this, key));
     }
 };
 var InternSet = class extends Set {
-    constructor(values2, key = keyof) {
+    constructor(values3, key = keyof) {
         super();
         Object.defineProperties(this, {
             _intern: {
                 value: /* @__PURE__ */ new Map()
             },
             _key: {
                 value: key
             }
         });
-        if (values2 != null)
-            for (const value of values2)
+        if (values3 != null)
+            for (const value of values3)
                 this.add(value);
     }
     has(value) {
         return super.has(intern_get(this, value));
     }
     add(value) {
         return super.add(intern_set(this, value));
@@ -1763,1121 +2244,1121 @@
 }
 
 function keyof(value) {
     return value !== null && typeof value === "object" ? value.valueOf() : value;
 }
 
 // node_modules/d3-array/src/identity.js
-function identity(x4) {
-    return x4;
+function identity(x7) {
+    return x7;
 }
 
 // node_modules/d3-array/src/group.js
-function group(values2, ...keys) {
-    return nest(values2, identity, identity, keys);
+function group(values3, ...keys) {
+    return nest(values3, identity, identity, keys);
 }
 
-function groups(values2, ...keys) {
-    return nest(values2, Array.from, identity, keys);
+function groups(values3, ...keys) {
+    return nest(values3, Array.from, identity, keys);
 }
 
-function flatten(groups2, keys) {
+function flatten(groups3, keys) {
     for (let i = 1, n = keys.length; i < n; ++i) {
-        groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
+        groups3 = groups3.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
     }
-    return groups2;
+    return groups3;
 }
 
-function flatGroup(values2, ...keys) {
-    return flatten(groups(values2, ...keys), keys);
+function flatGroup(values3, ...keys) {
+    return flatten(groups(values3, ...keys), keys);
 }
 
-function flatRollup(values2, reduce2, ...keys) {
-    return flatten(rollups(values2, reduce2, ...keys), keys);
+function flatRollup(values3, reduce3, ...keys) {
+    return flatten(rollups(values3, reduce3, ...keys), keys);
 }
 
-function rollup(values2, reduce2, ...keys) {
-    return nest(values2, identity, reduce2, keys);
+function rollup(values3, reduce3, ...keys) {
+    return nest(values3, identity, reduce3, keys);
 }
 
-function rollups(values2, reduce2, ...keys) {
-    return nest(values2, Array.from, reduce2, keys);
+function rollups(values3, reduce3, ...keys) {
+    return nest(values3, Array.from, reduce3, keys);
 }
 
-function index(values2, ...keys) {
-    return nest(values2, identity, unique, keys);
+function index(values3, ...keys) {
+    return nest(values3, identity, unique, keys);
 }
 
-function indexes(values2, ...keys) {
-    return nest(values2, Array.from, unique, keys);
+function indexes(values3, ...keys) {
+    return nest(values3, Array.from, unique, keys);
 }
 
-function unique(values2) {
-    if (values2.length !== 1)
+function unique(values3) {
+    if (values3.length !== 1)
         throw new Error("duplicate key");
-    return values2[0];
+    return values3[0];
 }
 
-function nest(values2, map6, reduce2, keys) {
-    return function regroup(values3, i) {
+function nest(values3, map11, reduce3, keys) {
+    return function regroup(values4, i) {
         if (i >= keys.length)
-            return reduce2(values3);
-        const groups2 = new InternMap();
-        const keyof3 = keys[i++];
-        let index3 = -1;
-        for (const value of values3) {
-            const key = keyof3(value, ++index3, values3);
-            const group3 = groups2.get(key);
-            if (group3)
-                group3.push(value);
+            return reduce3(values4);
+        const groups3 = new InternMap();
+        const keyof5 = keys[i++];
+        let index5 = -1;
+        for (const value of values4) {
+            const key = keyof5(value, ++index5, values4);
+            const group5 = groups3.get(key);
+            if (group5)
+                group5.push(value);
             else
-                groups2.set(key, [value]);
+                groups3.set(key, [value]);
         }
-        for (const [key, values4] of groups2) {
-            groups2.set(key, regroup(values4, i));
+        for (const [key, values5] of groups3) {
+            groups3.set(key, regroup(values5, i));
         }
-        return map6(groups2);
-    }(values2, 0);
+        return map11(groups3);
+    }(values3, 0);
 }
 
 // node_modules/d3-array/src/permute.js
 function permute(source, keys) {
     return Array.from(keys, (key) => source[key]);
 }
 
 // node_modules/d3-array/src/sort.js
-function sort(values2, ...F) {
-    if (typeof values2[Symbol.iterator] !== "function")
+function sort(values3, ...F) {
+    if (typeof values3[Symbol.iterator] !== "function")
         throw new TypeError("values is not iterable");
-    values2 = Array.from(values2);
+    values3 = Array.from(values3);
     let [f] = F;
     if (f && f.length !== 2 || F.length > 1) {
-        const index3 = Uint32Array.from(values2, (d, i) => i);
+        const index5 = Uint32Array.from(values3, (d, i) => i);
         if (F.length > 1) {
-            F = F.map((f2) => values2.map(f2));
-            index3.sort((i, j) => {
+            F = F.map((f2) => values3.map(f2));
+            index5.sort((i, j) => {
                 for (const f2 of F) {
-                    const c6 = ascendingDefined(f2[i], f2[j]);
-                    if (c6)
-                        return c6;
+                    const c11 = ascendingDefined(f2[i], f2[j]);
+                    if (c11)
+                        return c11;
                 }
             });
         } else {
-            f = values2.map(f);
-            index3.sort((i, j) => ascendingDefined(f[i], f[j]));
+            f = values3.map(f);
+            index5.sort((i, j) => ascendingDefined(f[i], f[j]));
         }
-        return permute(values2, index3);
+        return permute(values3, index5);
     }
-    return values2.sort(compareDefined(f));
+    return values3.sort(compareDefined(f));
 }
 
 function compareDefined(compare = ascending) {
     if (compare === ascending)
         return ascendingDefined;
     if (typeof compare !== "function")
         throw new TypeError("compare is not a function");
-    return (a4, b) => {
-        const x4 = compare(a4, b);
-        if (x4 || x4 === 0)
-            return x4;
-        return (compare(b, b) === 0) - (compare(a4, a4) === 0);
+    return (a7, b) => {
+        const x7 = compare(a7, b);
+        if (x7 || x7 === 0)
+            return x7;
+        return (compare(b, b) === 0) - (compare(a7, a7) === 0);
     };
 }
 
-function ascendingDefined(a4, b) {
-    return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);
+function ascendingDefined(a7, b) {
+    return (a7 == null || !(a7 >= a7)) - (b == null || !(b >= b)) || (a7 < b ? -1 : a7 > b ? 1 : 0);
 }
 
 // node_modules/d3-array/src/groupSort.js
-function groupSort(values2, reduce2, key) {
-    return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
+function groupSort(values3, reduce3, key) {
+    return (reduce3.length !== 2 ? sort(rollup(values3, reduce3, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values3, key), ([ak, av], [bk, bv]) => reduce3(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
 }
 
 // node_modules/d3-array/src/array.js
 var array = Array.prototype;
 var slice = array.slice;
 var map = array.map;
 
 // node_modules/d3-array/src/constant.js
-function constant(x4) {
-    return () => x4;
+function constant(x7) {
+    return () => x7;
 }
 
 // node_modules/d3-array/src/ticks.js
 var e10 = Math.sqrt(50);
 var e5 = Math.sqrt(10);
 var e2 = Math.sqrt(2);
 
-function tickSpec(start2, stop, count3) {
-    const step = (stop - start2) / Math.max(0, count3),
+function tickSpec(start3, stop, count5) {
+    const step = (stop - start3) / Math.max(0, count5),
         power = Math.floor(Math.log10(step)),
         error = step / Math.pow(10, power),
         factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
-    let i1, i2, inc2;
+    let i1, i2, inc3;
     if (power < 0) {
-        inc2 = Math.pow(10, -power) / factor;
-        i1 = Math.round(start2 * inc2);
-        i2 = Math.round(stop * inc2);
-        if (i1 / inc2 < start2)
+        inc3 = Math.pow(10, -power) / factor;
+        i1 = Math.round(start3 * inc3);
+        i2 = Math.round(stop * inc3);
+        if (i1 / inc3 < start3)
             ++i1;
-        if (i2 / inc2 > stop)
+        if (i2 / inc3 > stop)
             --i2;
-        inc2 = -inc2;
+        inc3 = -inc3;
     } else {
-        inc2 = Math.pow(10, power) * factor;
-        i1 = Math.round(start2 / inc2);
-        i2 = Math.round(stop / inc2);
-        if (i1 * inc2 < start2)
+        inc3 = Math.pow(10, power) * factor;
+        i1 = Math.round(start3 / inc3);
+        i2 = Math.round(stop / inc3);
+        if (i1 * inc3 < start3)
             ++i1;
-        if (i2 * inc2 > stop)
+        if (i2 * inc3 > stop)
             --i2;
     }
-    if (i2 < i1 && 0.5 <= count3 && count3 < 2)
-        return tickSpec(start2, stop, count3 * 2);
-    return [i1, i2, inc2];
+    if (i2 < i1 && 0.5 <= count5 && count5 < 2)
+        return tickSpec(start3, stop, count5 * 2);
+    return [i1, i2, inc3];
 }
 
-function ticks(start2, stop, count3) {
-    stop = +stop, start2 = +start2, count3 = +count3;
-    if (!(count3 > 0))
+function ticks(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    if (!(count5 > 0))
         return [];
-    if (start2 === stop)
-        return [start2];
-    const reverse3 = stop < start2,
-        [i1, i2, inc2] = reverse3 ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);
+    if (start3 === stop)
+        return [start3];
+    const reverse5 = stop < start3,
+        [i1, i2, inc3] = reverse5 ? tickSpec(stop, start3, count5) : tickSpec(start3, stop, count5);
     if (!(i2 >= i1))
         return [];
     const n = i2 - i1 + 1,
-        ticks2 = new Array(n);
-    if (reverse3) {
-        if (inc2 < 0)
+        ticks3 = new Array(n);
+    if (reverse5) {
+        if (inc3 < 0)
             for (let i = 0; i < n; ++i)
-                ticks2[i] = (i2 - i) / -inc2;
+                ticks3[i] = (i2 - i) / -inc3;
         else
             for (let i = 0; i < n; ++i)
-                ticks2[i] = (i2 - i) * inc2;
+                ticks3[i] = (i2 - i) * inc3;
     } else {
-        if (inc2 < 0)
+        if (inc3 < 0)
             for (let i = 0; i < n; ++i)
-                ticks2[i] = (i1 + i) / -inc2;
+                ticks3[i] = (i1 + i) / -inc3;
         else
             for (let i = 0; i < n; ++i)
-                ticks2[i] = (i1 + i) * inc2;
+                ticks3[i] = (i1 + i) * inc3;
     }
-    return ticks2;
+    return ticks3;
 }
 
-function tickIncrement(start2, stop, count3) {
-    stop = +stop, start2 = +start2, count3 = +count3;
-    return tickSpec(start2, stop, count3)[2];
+function tickIncrement(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    return tickSpec(start3, stop, count5)[2];
 }
 
-function tickStep(start2, stop, count3) {
-    stop = +stop, start2 = +start2, count3 = +count3;
-    const reverse3 = stop < start2,
-        inc2 = reverse3 ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);
-    return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
+function tickStep(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    const reverse5 = stop < start3,
+        inc3 = reverse5 ? tickIncrement(stop, start3, count5) : tickIncrement(start3, stop, count5);
+    return (reverse5 ? -1 : 1) * (inc3 < 0 ? 1 / -inc3 : inc3);
 }
 
 // node_modules/d3-array/src/nice.js
-function nice(start2, stop, count3) {
+function nice(start3, stop, count5) {
     let prestep;
     while (true) {
-        const step = tickIncrement(start2, stop, count3);
+        const step = tickIncrement(start3, stop, count5);
         if (step === prestep || step === 0 || !isFinite(step)) {
-            return [start2, stop];
+            return [start3, stop];
         } else if (step > 0) {
-            start2 = Math.floor(start2 / step) * step;
+            start3 = Math.floor(start3 / step) * step;
             stop = Math.ceil(stop / step) * step;
         } else if (step < 0) {
-            start2 = Math.ceil(start2 * step) / step;
+            start3 = Math.ceil(start3 * step) / step;
             stop = Math.floor(stop * step) / step;
         }
         prestep = step;
     }
 }
 
 // node_modules/d3-array/src/threshold/sturges.js
-function thresholdSturges(values2) {
-    return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);
+function thresholdSturges(values3) {
+    return Math.max(1, Math.ceil(Math.log(count(values3)) / Math.LN2) + 1);
 }
 
 // node_modules/d3-array/src/bin.js
 function bin() {
     var value = identity,
         domain = extent,
-        threshold2 = thresholdSturges;
+        threshold3 = thresholdSturges;
 
     function histogram(data) {
         if (!Array.isArray(data))
             data = Array.from(data);
         var i, n = data.length,
-            x4, step, values2 = new Array(n);
+            x7, step, values3 = new Array(n);
         for (i = 0; i < n; ++i) {
-            values2[i] = value(data[i], i, data);
+            values3[i] = value(data[i], i, data);
         }
-        var xz = domain(values2),
-            x06 = xz[0],
-            x12 = xz[1],
-            tz = threshold2(values2, x06, x12);
+        var xz = domain(values3),
+            x011 = xz[0],
+            x13 = xz[1],
+            tz = threshold3(values3, x011, x13);
         if (!Array.isArray(tz)) {
-            const max5 = x12,
+            const max9 = x13,
                 tn = +tz;
             if (domain === extent)
-                [x06, x12] = nice(x06, x12, tn);
-            tz = ticks(x06, x12, tn);
-            if (tz[0] <= x06)
-                step = tickIncrement(x06, x12, tn);
-            if (tz[tz.length - 1] >= x12) {
-                if (max5 >= x12 && domain === extent) {
-                    const step2 = tickIncrement(x06, x12, tn);
+                [x011, x13] = nice(x011, x13, tn);
+            tz = ticks(x011, x13, tn);
+            if (tz[0] <= x011)
+                step = tickIncrement(x011, x13, tn);
+            if (tz[tz.length - 1] >= x13) {
+                if (max9 >= x13 && domain === extent) {
+                    const step2 = tickIncrement(x011, x13, tn);
                     if (isFinite(step2)) {
                         if (step2 > 0) {
-                            x12 = (Math.floor(x12 / step2) + 1) * step2;
+                            x13 = (Math.floor(x13 / step2) + 1) * step2;
                         } else if (step2 < 0) {
-                            x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
+                            x13 = (Math.ceil(x13 * -step2) + 1) / -step2;
                         }
                     }
                 } else {
                     tz.pop();
                 }
             }
         }
-        var m3 = tz.length,
-            a4 = 0,
-            b = m3;
-        while (tz[a4] <= x06)
-            ++a4;
-        while (tz[b - 1] > x12)
+        var m5 = tz.length,
+            a7 = 0,
+            b = m5;
+        while (tz[a7] <= x011)
+            ++a7;
+        while (tz[b - 1] > x13)
             --b;
-        if (a4 || b < m3)
-            tz = tz.slice(a4, b), m3 = b - a4;
-        var bins = new Array(m3 + 1),
-            bin3;
-        for (i = 0; i <= m3; ++i) {
-            bin3 = bins[i] = [];
-            bin3.x0 = i > 0 ? tz[i - 1] : x06;
-            bin3.x1 = i < m3 ? tz[i] : x12;
+        if (a7 || b < m5)
+            tz = tz.slice(a7, b), m5 = b - a7;
+        var bins = new Array(m5 + 1),
+            bin5;
+        for (i = 0; i <= m5; ++i) {
+            bin5 = bins[i] = [];
+            bin5.x0 = i > 0 ? tz[i - 1] : x011;
+            bin5.x1 = i < m5 ? tz[i] : x13;
         }
         if (isFinite(step)) {
             if (step > 0) {
                 for (i = 0; i < n; ++i) {
-                    if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {
-                        bins[Math.min(m3, Math.floor((x4 - x06) / step))].push(data[i]);
+                    if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                        bins[Math.min(m5, Math.floor((x7 - x011) / step))].push(data[i]);
                     }
                 }
             } else if (step < 0) {
                 for (i = 0; i < n; ++i) {
-                    if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {
-                        const j = Math.floor((x06 - x4) * step);
-                        bins[Math.min(m3, j + (tz[j] <= x4))].push(data[i]);
+                    if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                        const j = Math.floor((x011 - x7) * step);
+                        bins[Math.min(m5, j + (tz[j] <= x7))].push(data[i]);
                     }
                 }
             }
         } else {
             for (i = 0; i < n; ++i) {
-                if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {
-                    bins[bisect_default(tz, x4, 0, m3)].push(data[i]);
+                if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                    bins[bisect_default(tz, x7, 0, m5)].push(data[i]);
                 }
             }
         }
         return bins;
     }
     histogram.value = function(_) {
         return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
     };
     histogram.domain = function(_) {
         return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
     };
     histogram.thresholds = function(_) {
-        return arguments.length ? (threshold2 = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold3;
     };
     return histogram;
 }
 
 // node_modules/d3-array/src/max.js
-function max(values2, valueof2) {
-    let max5;
-    if (valueof2 === void 0) {
-        for (const value of values2) {
-            if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
-                max5 = value;
+function max(values3, valueof3) {
+    let max9;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            if (value != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {
-                max5 = value;
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value;
             }
         }
     }
-    return max5;
+    return max9;
 }
 
 // node_modules/d3-array/src/maxIndex.js
-function maxIndex(values2, valueof2) {
-    let max5;
-    let maxIndex2 = -1;
-    let index3 = -1;
-    if (valueof2 === void 0) {
-        for (const value of values2) {
-            ++index3;
-            if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
-                max5 = value, maxIndex2 = index3;
+function maxIndex(values3, valueof3) {
+    let max9;
+    let maxIndex3 = -1;
+    let index5 = -1;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            ++index5;
+            if (value != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value, maxIndex3 = index5;
             }
         }
     } else {
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {
-                max5 = value, maxIndex2 = index3;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value, maxIndex3 = index5;
             }
         }
     }
-    return maxIndex2;
+    return maxIndex3;
 }
 
 // node_modules/d3-array/src/min.js
-function min(values2, valueof2) {
-    let min4;
-    if (valueof2 === void 0) {
-        for (const value of values2) {
-            if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
-                min4 = value;
+function min(values3, valueof3) {
+    let min7;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            if (value != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
-                min4 = value;
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value;
             }
         }
     }
-    return min4;
+    return min7;
 }
 
 // node_modules/d3-array/src/minIndex.js
-function minIndex(values2, valueof2) {
-    let min4;
-    let minIndex2 = -1;
-    let index3 = -1;
-    if (valueof2 === void 0) {
-        for (const value of values2) {
-            ++index3;
-            if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
-                min4 = value, minIndex2 = index3;
+function minIndex(values3, valueof3) {
+    let min7;
+    let minIndex3 = -1;
+    let index5 = -1;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            ++index5;
+            if (value != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value, minIndex3 = index5;
             }
         }
     } else {
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
-                min4 = value, minIndex2 = index3;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value, minIndex3 = index5;
             }
         }
     }
-    return minIndex2;
+    return minIndex3;
 }
 
 // node_modules/d3-array/src/quickselect.js
-function quickselect(array4, k2, left2 = 0, right2 = Infinity, compare) {
-    k2 = Math.floor(k2);
-    left2 = Math.floor(Math.max(0, left2));
-    right2 = Math.floor(Math.min(array4.length - 1, right2));
-    if (!(left2 <= k2 && k2 <= right2))
-        return array4;
+function quickselect(array7, k3, left3 = 0, right3 = Infinity, compare) {
+    k3 = Math.floor(k3);
+    left3 = Math.floor(Math.max(0, left3));
+    right3 = Math.floor(Math.min(array7.length - 1, right3));
+    if (!(left3 <= k3 && k3 <= right3))
+        return array7;
     compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
-    while (right2 > left2) {
-        if (right2 - left2 > 600) {
-            const n = right2 - left2 + 1;
-            const m3 = k2 - left2 + 1;
+    while (right3 > left3) {
+        if (right3 - left3 > 600) {
+            const n = right3 - left3 + 1;
+            const m5 = k3 - left3 + 1;
             const z = Math.log(n);
-            const s2 = 0.5 * Math.exp(2 * z / 3);
-            const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);
-            const newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));
-            const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));
-            quickselect(array4, k2, newLeft, newRight, compare);
-        }
-        const t = array4[k2];
-        let i = left2;
-        let j = right2;
-        swap(array4, left2, k2);
-        if (compare(array4[right2], t) > 0)
-            swap(array4, left2, right2);
+            const s3 = 0.5 * Math.exp(2 * z / 3);
+            const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m5 - n / 2 < 0 ? -1 : 1);
+            const newLeft = Math.max(left3, Math.floor(k3 - m5 * s3 / n + sd));
+            const newRight = Math.min(right3, Math.floor(k3 + (n - m5) * s3 / n + sd));
+            quickselect(array7, k3, newLeft, newRight, compare);
+        }
+        const t = array7[k3];
+        let i = left3;
+        let j = right3;
+        swap(array7, left3, k3);
+        if (compare(array7[right3], t) > 0)
+            swap(array7, left3, right3);
         while (i < j) {
-            swap(array4, i, j), ++i, --j;
-            while (compare(array4[i], t) < 0)
+            swap(array7, i, j), ++i, --j;
+            while (compare(array7[i], t) < 0)
                 ++i;
-            while (compare(array4[j], t) > 0)
+            while (compare(array7[j], t) > 0)
                 --j;
         }
-        if (compare(array4[left2], t) === 0)
-            swap(array4, left2, j);
+        if (compare(array7[left3], t) === 0)
+            swap(array7, left3, j);
         else
 
-        ++j, swap(array4, j, right2);
-        if (j <= k2)
-            left2 = j + 1;
-        if (k2 <= j)
-            right2 = j - 1;
-    }
-    return array4;
+        ++j, swap(array7, j, right3);
+        if (j <= k3)
+            left3 = j + 1;
+        if (k3 <= j)
+            right3 = j - 1;
+    }
+    return array7;
 }
 
-function swap(array4, i, j) {
-    const t = array4[i];
-    array4[i] = array4[j];
-    array4[j] = t;
+function swap(array7, i, j) {
+    const t = array7[i];
+    array7[i] = array7[j];
+    array7[j] = t;
 }
 
 // node_modules/d3-array/src/greatest.js
-function greatest(values2, compare = ascending) {
-    let max5;
-    let defined2 = false;
+function greatest(values3, compare = ascending) {
+    let max9;
+    let defined3 = false;
     if (compare.length === 1) {
         let maxValue;
-        for (const element of values2) {
+        for (const element of values3) {
             const value = compare(element);
-            if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
-                max5 = element;
+            if (defined3 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
+                max9 = element;
                 maxValue = value;
-                defined2 = true;
+                defined3 = true;
             }
         }
     } else {
-        for (const value of values2) {
-            if (defined2 ? compare(value, max5) > 0 : compare(value, value) === 0) {
-                max5 = value;
-                defined2 = true;
+        for (const value of values3) {
+            if (defined3 ? compare(value, max9) > 0 : compare(value, value) === 0) {
+                max9 = value;
+                defined3 = true;
             }
         }
     }
-    return max5;
+    return max9;
 }
 
 // node_modules/d3-array/src/quantile.js
-function quantile(values2, p, valueof2) {
-    values2 = Float64Array.from(numbers(values2, valueof2));
-    if (!(n = values2.length) || isNaN(p = +p))
+function quantile(values3, p, valueof3) {
+    values3 = Float64Array.from(numbers(values3, valueof3));
+    if (!(n = values3.length) || isNaN(p = +p))
         return;
     if (p <= 0 || n < 2)
-        return min(values2);
+        return min(values3);
     if (p >= 1)
-        return max(values2);
+        return max(values3);
     var n, i = (n - 1) * p,
         i0 = Math.floor(i),
-        value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)),
-        value1 = min(values2.subarray(i0 + 1));
+        value0 = max(quickselect(values3, i0).subarray(0, i0 + 1)),
+        value1 = min(values3.subarray(i0 + 1));
     return value0 + (value1 - value0) * (i - i0);
 }
 
-function quantileSorted(values2, p, valueof2 = number) {
-    if (!(n = values2.length) || isNaN(p = +p))
+function quantileSorted(values3, p, valueof3 = number) {
+    if (!(n = values3.length) || isNaN(p = +p))
         return;
     if (p <= 0 || n < 2)
-        return +valueof2(values2[0], 0, values2);
+        return +valueof3(values3[0], 0, values3);
     if (p >= 1)
-        return +valueof2(values2[n - 1], n - 1, values2);
+        return +valueof3(values3[n - 1], n - 1, values3);
     var n, i = (n - 1) * p,
         i0 = Math.floor(i),
-        value0 = +valueof2(values2[i0], i0, values2),
-        value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
+        value0 = +valueof3(values3[i0], i0, values3),
+        value1 = +valueof3(values3[i0 + 1], i0 + 1, values3);
     return value0 + (value1 - value0) * (i - i0);
 }
 
-function quantileIndex(values2, p, valueof2) {
-    values2 = Float64Array.from(numbers(values2, valueof2));
-    if (!(n = values2.length) || isNaN(p = +p))
+function quantileIndex(values3, p, valueof3) {
+    values3 = Float64Array.from(numbers(values3, valueof3));
+    if (!(n = values3.length) || isNaN(p = +p))
         return;
     if (p <= 0 || n < 2)
-        return minIndex(values2);
+        return minIndex(values3);
     if (p >= 1)
-        return maxIndex(values2);
+        return maxIndex(values3);
     var n, i = Math.floor((n - 1) * p),
-        order = (i2, j) => ascendingDefined(values2[i2], values2[j]),
-        index3 = quickselect(Uint32Array.from(values2, (_, i2) => i2), i, 0, n - 1, order);
-    return greatest(index3.subarray(0, i + 1), (i2) => values2[i2]);
+        order = (i2, j) => ascendingDefined(values3[i2], values3[j]),
+        index5 = quickselect(Uint32Array.from(values3, (_, i2) => i2), i, 0, n - 1, order);
+    return greatest(index5.subarray(0, i + 1), (i2) => values3[i2]);
 }
 
 // node_modules/d3-array/src/threshold/freedmanDiaconis.js
-function thresholdFreedmanDiaconis(values2, min4, max5) {
-    const c6 = count(values2),
-        d = quantile(values2, 0.75) - quantile(values2, 0.25);
-    return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;
+function thresholdFreedmanDiaconis(values3, min7, max9) {
+    const c11 = count(values3),
+        d = quantile(values3, 0.75) - quantile(values3, 0.25);
+    return c11 && d ? Math.ceil((max9 - min7) / (2 * d * Math.pow(c11, -1 / 3))) : 1;
 }
 
 // node_modules/d3-array/src/threshold/scott.js
-function thresholdScott(values2, min4, max5) {
-    const c6 = count(values2),
-        d = deviation(values2);
-    return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;
+function thresholdScott(values3, min7, max9) {
+    const c11 = count(values3),
+        d = deviation(values3);
+    return c11 && d ? Math.ceil((max9 - min7) * Math.cbrt(c11) / (3.49 * d)) : 1;
 }
 
 // node_modules/d3-array/src/mean.js
-function mean(values2, valueof2) {
-    let count3 = 0;
-    let sum5 = 0;
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+function mean(values3, valueof3) {
+    let count5 = 0;
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value != null && (value = +value) >= value) {
-                ++count3, sum5 += value;
+                ++count5, sum8 += value;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {
-                ++count3, sum5 += value;
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                ++count5, sum8 += value;
             }
         }
     }
-    if (count3)
-        return sum5 / count3;
+    if (count5)
+        return sum8 / count5;
 }
 
 // node_modules/d3-array/src/median.js
-function median(values2, valueof2) {
-    return quantile(values2, 0.5, valueof2);
+function median(values3, valueof3) {
+    return quantile(values3, 0.5, valueof3);
 }
 
-function medianIndex(values2, valueof2) {
-    return quantileIndex(values2, 0.5, valueof2);
+function medianIndex(values3, valueof3) {
+    return quantileIndex(values3, 0.5, valueof3);
 }
 
 // node_modules/d3-array/src/merge.js
 function* flatten2(arrays) {
-    for (const array4 of arrays) {
-        yield* array4;
+    for (const array7 of arrays) {
+        yield* array7;
     }
 }
 
 function merge(arrays) {
     return Array.from(flatten2(arrays));
 }
 
 // node_modules/d3-array/src/mode.js
-function mode(values2, valueof2) {
+function mode(values3, valueof3) {
     const counts = new InternMap();
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value != null && value >= value) {
                 counts.set(value, (counts.get(value) || 0) + 1);
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if ((value = valueof2(value, ++index3, values2)) != null && value >= value) {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && value >= value) {
                 counts.set(value, (counts.get(value) || 0) + 1);
             }
         }
     }
     let modeValue;
     let modeCount = 0;
-    for (const [value, count3] of counts) {
-        if (count3 > modeCount) {
-            modeCount = count3;
+    for (const [value, count5] of counts) {
+        if (count5 > modeCount) {
+            modeCount = count5;
             modeValue = value;
         }
     }
     return modeValue;
 }
 
 // node_modules/d3-array/src/pairs.js
-function pairs(values2, pairof = pair) {
-    const pairs2 = [];
+function pairs(values3, pairof = pair) {
+    const pairs3 = [];
     let previous;
-    let first2 = false;
-    for (const value of values2) {
-        if (first2)
-            pairs2.push(pairof(previous, value));
+    let first3 = false;
+    for (const value of values3) {
+        if (first3)
+            pairs3.push(pairof(previous, value));
         previous = value;
-        first2 = true;
+        first3 = true;
     }
-    return pairs2;
+    return pairs3;
 }
 
-function pair(a4, b) {
-    return [a4, b];
+function pair(a7, b) {
+    return [a7, b];
 }
 
 // node_modules/d3-array/src/range.js
-function range(start2, stop, step) {
-    start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
+function range(start3, stop, step) {
+    start3 = +start3, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start3, start3 = 0, 1) : n < 3 ? 1 : +step;
     var i = -1,
-        n = Math.max(0, Math.ceil((stop - start2) / step)) | 0,
-        range5 = new Array(n);
+        n = Math.max(0, Math.ceil((stop - start3) / step)) | 0,
+        range9 = new Array(n);
     while (++i < n) {
-        range5[i] = start2 + i * step;
+        range9[i] = start3 + i * step;
     }
-    return range5;
+    return range9;
 }
 
 // node_modules/d3-array/src/rank.js
-function rank(values2, valueof2 = ascending) {
-    if (typeof values2[Symbol.iterator] !== "function")
+function rank(values3, valueof3 = ascending) {
+    if (typeof values3[Symbol.iterator] !== "function")
         throw new TypeError("values is not iterable");
-    let V = Array.from(values2);
+    let V = Array.from(values3);
     const R = new Float64Array(V.length);
-    if (valueof2.length !== 2)
-        V = V.map(valueof2), valueof2 = ascending;
-    const compareIndex = (i, j) => valueof2(V[i], V[j]);
-    let k2, r;
-    values2 = Uint32Array.from(V, (_, i) => i);
-    values2.sort(valueof2 === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
-    values2.forEach((j, i) => {
-        const c6 = compareIndex(j, k2 === void 0 ? j : k2);
-        if (c6 >= 0) {
-            if (k2 === void 0 || c6 > 0)
-                k2 = j, r = i;
+    if (valueof3.length !== 2)
+        V = V.map(valueof3), valueof3 = ascending;
+    const compareIndex = (i, j) => valueof3(V[i], V[j]);
+    let k3, r;
+    values3 = Uint32Array.from(V, (_, i) => i);
+    values3.sort(valueof3 === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
+    values3.forEach((j, i) => {
+        const c11 = compareIndex(j, k3 === void 0 ? j : k3);
+        if (c11 >= 0) {
+            if (k3 === void 0 || c11 > 0)
+                k3 = j, r = i;
             R[j] = r;
         } else {
             R[j] = NaN;
         }
     });
     return R;
 }
 
 // node_modules/d3-array/src/least.js
-function least(values2, compare = ascending) {
-    let min4;
-    let defined2 = false;
+function least(values3, compare = ascending) {
+    let min7;
+    let defined3 = false;
     if (compare.length === 1) {
         let minValue;
-        for (const element of values2) {
+        for (const element of values3) {
             const value = compare(element);
-            if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
-                min4 = element;
+            if (defined3 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
+                min7 = element;
                 minValue = value;
-                defined2 = true;
+                defined3 = true;
             }
         }
     } else {
-        for (const value of values2) {
-            if (defined2 ? compare(value, min4) < 0 : compare(value, value) === 0) {
-                min4 = value;
-                defined2 = true;
+        for (const value of values3) {
+            if (defined3 ? compare(value, min7) < 0 : compare(value, value) === 0) {
+                min7 = value;
+                defined3 = true;
             }
         }
     }
-    return min4;
+    return min7;
 }
 
 // node_modules/d3-array/src/leastIndex.js
-function leastIndex(values2, compare = ascending) {
+function leastIndex(values3, compare = ascending) {
     if (compare.length === 1)
-        return minIndex(values2, compare);
+        return minIndex(values3, compare);
     let minValue;
-    let min4 = -1;
-    let index3 = -1;
-    for (const value of values2) {
-        ++index3;
-        if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
+    let min7 = -1;
+    let index5 = -1;
+    for (const value of values3) {
+        ++index5;
+        if (min7 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
             minValue = value;
-            min4 = index3;
+            min7 = index5;
         }
     }
-    return min4;
+    return min7;
 }
 
 // node_modules/d3-array/src/greatestIndex.js
-function greatestIndex(values2, compare = ascending) {
+function greatestIndex(values3, compare = ascending) {
     if (compare.length === 1)
-        return maxIndex(values2, compare);
+        return maxIndex(values3, compare);
     let maxValue;
-    let max5 = -1;
-    let index3 = -1;
-    for (const value of values2) {
-        ++index3;
-        if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
+    let max9 = -1;
+    let index5 = -1;
+    for (const value of values3) {
+        ++index5;
+        if (max9 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
             maxValue = value;
-            max5 = index3;
+            max9 = index5;
         }
     }
-    return max5;
+    return max9;
 }
 
 // node_modules/d3-array/src/scan.js
-function scan(values2, compare) {
-    const index3 = leastIndex(values2, compare);
-    return index3 < 0 ? void 0 : index3;
+function scan(values3, compare) {
+    const index5 = leastIndex(values3, compare);
+    return index5 < 0 ? void 0 : index5;
 }
 
 // node_modules/d3-array/src/shuffle.js
 var shuffle_default = shuffler(Math.random);
 
 function shuffler(random) {
-    return function shuffle3(array4, i0 = 0, i1 = array4.length) {
-        let m3 = i1 - (i0 = +i0);
-        while (m3) {
-            const i = random() * m3-- | 0,
-                t = array4[m3 + i0];
-            array4[m3 + i0] = array4[i + i0];
-            array4[i + i0] = t;
+    return function shuffle5(array7, i0 = 0, i1 = array7.length) {
+        let m5 = i1 - (i0 = +i0);
+        while (m5) {
+            const i = random() * m5-- | 0,
+                t = array7[m5 + i0];
+            array7[m5 + i0] = array7[i + i0];
+            array7[i + i0] = t;
         }
-        return array4;
+        return array7;
     };
 }
 
 // node_modules/d3-array/src/sum.js
-function sum(values2, valueof2) {
-    let sum5 = 0;
-    if (valueof2 === void 0) {
-        for (let value of values2) {
+function sum(values3, valueof3) {
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
             if (value = +value) {
-                sum5 += value;
+                sum8 += value;
             }
         }
     } else {
-        let index3 = -1;
-        for (let value of values2) {
-            if (value = +valueof2(value, ++index3, values2)) {
-                sum5 += value;
+        let index5 = -1;
+        for (let value of values3) {
+            if (value = +valueof3(value, ++index5, values3)) {
+                sum8 += value;
             }
         }
     }
-    return sum5;
+    return sum8;
 }
 
 // node_modules/d3-array/src/transpose.js
 function transpose(matrix) {
     if (!(n = matrix.length))
         return [];
-    for (var i = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i < m3;) {
-        for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n;) {
+    for (var i = -1, m5 = min(matrix, length2), transpose3 = new Array(m5); ++i < m5;) {
+        for (var j = -1, n, row = transpose3[i] = new Array(n); ++j < n;) {
             row[j] = matrix[j][i];
         }
     }
-    return transpose2;
+    return transpose3;
 }
 
 function length2(d) {
     return d.length;
 }
 
 // node_modules/d3-array/src/zip.js
 function zip() {
     return transpose(arguments);
 }
 
 // node_modules/d3-array/src/every.js
-function every(values2, test) {
+function every(values3, test) {
     if (typeof test !== "function")
         throw new TypeError("test is not a function");
-    let index3 = -1;
-    for (const value of values2) {
-        if (!test(value, ++index3, values2)) {
+    let index5 = -1;
+    for (const value of values3) {
+        if (!test(value, ++index5, values3)) {
             return false;
         }
     }
     return true;
 }
 
 // node_modules/d3-array/src/some.js
-function some(values2, test) {
+function some(values3, test) {
     if (typeof test !== "function")
         throw new TypeError("test is not a function");
-    let index3 = -1;
-    for (const value of values2) {
-        if (test(value, ++index3, values2)) {
+    let index5 = -1;
+    for (const value of values3) {
+        if (test(value, ++index5, values3)) {
             return true;
         }
     }
     return false;
 }
 
 // node_modules/d3-array/src/filter.js
-function filter(values2, test) {
+function filter(values3, test) {
     if (typeof test !== "function")
         throw new TypeError("test is not a function");
-    const array4 = [];
-    let index3 = -1;
-    for (const value of values2) {
-        if (test(value, ++index3, values2)) {
-            array4.push(value);
+    const array7 = [];
+    let index5 = -1;
+    for (const value of values3) {
+        if (test(value, ++index5, values3)) {
+            array7.push(value);
         }
     }
-    return array4;
+    return array7;
 }
 
 // node_modules/d3-array/src/map.js
-function map2(values2, mapper) {
-    if (typeof values2[Symbol.iterator] !== "function")
+function map2(values3, mapper) {
+    if (typeof values3[Symbol.iterator] !== "function")
         throw new TypeError("values is not iterable");
     if (typeof mapper !== "function")
         throw new TypeError("mapper is not a function");
-    return Array.from(values2, (value, index3) => mapper(value, index3, values2));
+    return Array.from(values3, (value, index5) => mapper(value, index5, values3));
 }
 
 // node_modules/d3-array/src/reduce.js
-function reduce(values2, reducer2, value) {
-    if (typeof reducer2 !== "function")
+function reduce(values3, reducer3, value) {
+    if (typeof reducer3 !== "function")
         throw new TypeError("reducer is not a function");
-    const iterator = values2[Symbol.iterator]();
-    let done, next, index3 = -1;
+    const iterator = values3[Symbol.iterator]();
+    let done, next, index5 = -1;
     if (arguments.length < 3) {
         ({
             done,
             value
         } = iterator.next());
         if (done)
             return;
-        ++index3;
+        ++index5;
     }
     while ({
             done,
             value: next
         } = iterator.next(), !done) {
-        value = reducer2(value, next, ++index3, values2);
+        value = reducer3(value, next, ++index5, values3);
     }
     return value;
 }
 
 // node_modules/d3-array/src/reverse.js
-function reverse(values2) {
-    if (typeof values2[Symbol.iterator] !== "function")
+function reverse(values3) {
+    if (typeof values3[Symbol.iterator] !== "function")
         throw new TypeError("values is not iterable");
-    return Array.from(values2).reverse();
+    return Array.from(values3).reverse();
 }
 
 // node_modules/d3-array/src/difference.js
-function difference(values2, ...others) {
-    values2 = new InternSet(values2);
+function difference(values3, ...others) {
+    values3 = new InternSet(values3);
     for (const other of others) {
         for (const value of other) {
-            values2.delete(value);
+            values3.delete(value);
         }
     }
-    return values2;
+    return values3;
 }
 
 // node_modules/d3-array/src/disjoint.js
-function disjoint(values2, other) {
+function disjoint(values3, other) {
     const iterator = other[Symbol.iterator](),
-        set4 = new InternSet();
-    for (const v2 of values2) {
-        if (set4.has(v2))
+        set7 = new InternSet();
+    for (const v3 of values3) {
+        if (set7.has(v3))
             return false;
         let value, done;
         while ({
                 value,
                 done
             } = iterator.next()) {
             if (done)
                 break;
-            if (Object.is(v2, value))
+            if (Object.is(v3, value))
                 return false;
-            set4.add(value);
+            set7.add(value);
         }
     }
     return true;
 }
 
 // node_modules/d3-array/src/intersection.js
-function intersection(values2, ...others) {
-    values2 = new InternSet(values2);
+function intersection(values3, ...others) {
+    values3 = new InternSet(values3);
     others = others.map(set);
     out:
-        for (const value of values2) {
+        for (const value of values3) {
             for (const other of others) {
                 if (!other.has(value)) {
-                    values2.delete(value);
+                    values3.delete(value);
                     continue out;
                 }
             }
         }
-    return values2;
+    return values3;
 }
 
-function set(values2) {
-    return values2 instanceof InternSet ? values2 : new InternSet(values2);
+function set(values3) {
+    return values3 instanceof InternSet ? values3 : new InternSet(values3);
 }
 
 // node_modules/d3-array/src/superset.js
-function superset(values2, other) {
-    const iterator = values2[Symbol.iterator](),
-        set4 = /* @__PURE__ */ new Set();
+function superset(values3, other) {
+    const iterator = values3[Symbol.iterator](),
+        set7 = /* @__PURE__ */ new Set();
     for (const o of other) {
         const io = intern(o);
-        if (set4.has(io))
+        if (set7.has(io))
             continue;
         let value, done;
         while ({
                 value,
                 done
             } = iterator.next()) {
             if (done)
                 return false;
             const ivalue = intern(value);
-            set4.add(ivalue);
+            set7.add(ivalue);
             if (Object.is(io, ivalue))
                 break;
         }
     }
     return true;
 }
 
 function intern(value) {
     return value !== null && typeof value === "object" ? value.valueOf() : value;
 }
 
 // node_modules/d3-array/src/subset.js
-function subset(values2, other) {
-    return superset(other, values2);
+function subset(values3, other) {
+    return superset(other, values3);
 }
 
 // node_modules/d3-array/src/union.js
 function union(...others) {
-    const set4 = new InternSet();
+    const set7 = new InternSet();
     for (const other of others) {
         for (const o of other) {
-            set4.add(o);
+            set7.add(o);
         }
     }
-    return set4;
+    return set7;
 }
 
 // node_modules/d3-axis/src/identity.js
-function identity_default(x4) {
-    return x4;
+function identity_default(x7) {
+    return x7;
 }
 
 // node_modules/d3-axis/src/axis.js
 var top = 1;
 var right = 2;
 var bottom = 3;
 var left = 4;
 var epsilon = 1e-6;
 
-function translateX(x4) {
-    return "translate(" + x4 + ",0)";
+function translateX(x7) {
+    return "translate(" + x7 + ",0)";
 }
 
-function translateY(y4) {
-    return "translate(0," + y4 + ")";
+function translateY(y7) {
+    return "translate(0," + y7 + ")";
 }
 
-function number2(scale3) {
-    return (d) => +scale3(d);
+function number2(scale5) {
+    return (d) => +scale5(d);
 }
 
-function center(scale3, offset2) {
-    offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;
-    if (scale3.round())
-        offset2 = Math.round(offset2);
-    return (d) => +scale3(d) + offset2;
+function center(scale5, offset3) {
+    offset3 = Math.max(0, scale5.bandwidth() - offset3 * 2) / 2;
+    if (scale5.round())
+        offset3 = Math.round(offset3);
+    return (d) => +scale5(d) + offset3;
 }
 
 function entering() {
     return !this.__axis;
 }
 
-function axis(orient, scale3) {
+function axis(orient, scale5) {
     var tickArguments = [],
         tickValues = null,
-        tickFormat2 = null,
+        tickFormat3 = null,
         tickSizeInner = 6,
         tickSizeOuter = 6,
         tickPadding = 3,
-        offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
-        k2 = orient === top || orient === left ? -1 : 1,
-        x4 = orient === left || orient === right ? "x" : "y",
-        transform2 = orient === top || orient === bottom ? translateX : translateY;
-
-    function axis2(context) {
-        var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues,
-            format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2,
+        offset3 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
+        k3 = orient === top || orient === left ? -1 : 1,
+        x7 = orient === left || orient === right ? "x" : "y",
+        transform3 = orient === top || orient === bottom ? translateX : translateY;
+
+    function axis3(context) {
+        var values3 = tickValues == null ? scale5.ticks ? scale5.ticks.apply(scale5, tickArguments) : scale5.domain() : tickValues,
+            format5 = tickFormat3 == null ? scale5.tickFormat ? scale5.tickFormat.apply(scale5, tickArguments) : identity_default : tickFormat3,
             spacing = Math.max(tickSizeInner, 0) + tickPadding,
-            range5 = scale3.range(),
-            range0 = +range5[0] + offset2,
-            range1 = +range5[range5.length - 1] + offset2,
-            position2 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2),
-            selection2 = context.selection ? context.selection() : context,
-            path2 = selection2.selectAll(".domain").data([null]),
-            tick = selection2.selectAll(".tick").data(values2, scale3).order(),
+            range9 = scale5.range(),
+            range0 = +range9[0] + offset3,
+            range1 = +range9[range9.length - 1] + offset3,
+            position3 = (scale5.bandwidth ? center : number2)(scale5.copy(), offset3),
+            selection3 = context.selection ? context.selection() : context,
+            path3 = selection3.selectAll(".domain").data([null]),
+            tick = selection3.selectAll(".tick").data(values3, scale5).order(),
             tickExit = tick.exit(),
             tickEnter = tick.enter().append("g").attr("class", "tick"),
-            line2 = tick.select("line"),
-            text2 = tick.select("text");
-        path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
+            line3 = tick.select("line"),
+            text3 = tick.select("text");
+        path3 = path3.merge(path3.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
         tick = tick.merge(tickEnter);
-        line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x4 + "2", k2 * tickSizeInner));
-        text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x4, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
-        if (context !== selection2) {
-            path2 = path2.transition(context);
+        line3 = line3.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x7 + "2", k3 * tickSizeInner));
+        text3 = text3.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x7, k3 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
+        if (context !== selection3) {
+            path3 = path3.transition(context);
             tick = tick.transition(context);
-            line2 = line2.transition(context);
-            text2 = text2.transition(context);
+            line3 = line3.transition(context);
+            text3 = text3.transition(context);
             tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
-                return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute("transform");
+                return isFinite(d = position3(d)) ? transform3(d + offset3) : this.getAttribute("transform");
             });
             tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
                 var p = this.parentNode.__axis;
-                return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);
+                return transform3((p && isFinite(p = p(d)) ? p : position3(d)) + offset3);
             });
         }
         tickExit.remove();
-        path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
+        path3.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k3 * tickSizeOuter + "," + range0 + "H" + offset3 + "V" + range1 + "H" + k3 * tickSizeOuter : "M" + offset3 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k3 * tickSizeOuter + "V" + offset3 + "H" + range1 + "V" + k3 * tickSizeOuter : "M" + range0 + "," + offset3 + "H" + range1);
         tick.attr("opacity", 1).attr("transform", function(d) {
-            return transform2(position2(d) + offset2);
+            return transform3(position3(d) + offset3);
         });
-        line2.attr(x4 + "2", k2 * tickSizeInner);
-        text2.attr(x4, k2 * spacing).text(format3);
-        selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
-        selection2.each(function() {
-            this.__axis = position2;
+        line3.attr(x7 + "2", k3 * tickSizeInner);
+        text3.attr(x7, k3 * spacing).text(format5);
+        selection3.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
+        selection3.each(function() {
+            this.__axis = position3;
         });
     }
-    axis2.scale = function(_) {
-        return arguments.length ? (scale3 = _, axis2) : scale3;
+    axis3.scale = function(_) {
+        return arguments.length ? (scale5 = _, axis3) : scale5;
     };
-    axis2.ticks = function() {
-        return tickArguments = Array.from(arguments), axis2;
+    axis3.ticks = function() {
+        return tickArguments = Array.from(arguments), axis3;
     };
-    axis2.tickArguments = function(_) {
-        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
+    axis3.tickArguments = function(_) {
+        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis3) : tickArguments.slice();
     };
-    axis2.tickValues = function(_) {
-        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
+    axis3.tickValues = function(_) {
+        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis3) : tickValues && tickValues.slice();
     };
-    axis2.tickFormat = function(_) {
-        return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
+    axis3.tickFormat = function(_) {
+        return arguments.length ? (tickFormat3 = _, axis3) : tickFormat3;
     };
-    axis2.tickSize = function(_) {
-        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
+    axis3.tickSize = function(_) {
+        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis3) : tickSizeInner;
     };
-    axis2.tickSizeInner = function(_) {
-        return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
+    axis3.tickSizeInner = function(_) {
+        return arguments.length ? (tickSizeInner = +_, axis3) : tickSizeInner;
     };
-    axis2.tickSizeOuter = function(_) {
-        return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
+    axis3.tickSizeOuter = function(_) {
+        return arguments.length ? (tickSizeOuter = +_, axis3) : tickSizeOuter;
     };
-    axis2.tickPadding = function(_) {
-        return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
+    axis3.tickPadding = function(_) {
+        return arguments.length ? (tickPadding = +_, axis3) : tickPadding;
     };
-    axis2.offset = function(_) {
-        return arguments.length ? (offset2 = +_, axis2) : offset2;
+    axis3.offset = function(_) {
+        return arguments.length ? (offset3 = +_, axis3) : offset3;
     };
-    return axis2;
+    return axis3;
 }
 
-function axisTop(scale3) {
-    return axis(top, scale3);
+function axisTop(scale5) {
+    return axis(top, scale5);
 }
 
-function axisRight(scale3) {
-    return axis(right, scale3);
+function axisRight(scale5) {
+    return axis(right, scale5);
 }
 
-function axisBottom(scale3) {
-    return axis(bottom, scale3);
+function axisBottom(scale5) {
+    return axis(bottom, scale5);
 }
 
-function axisLeft(scale3) {
-    return axis(left, scale3);
+function axisLeft(scale5) {
+    return axis(left, scale5);
 }
 
 // node_modules/d3-dispatch/src/dispatch.js
 var noop = {
     value: () => {}
 };
 
@@ -2929,58 +3410,58 @@
             else if (callback == null)
                 for (t in _)
                     _[t] = set2(_[t], typename.name, null);
         }
         return this;
     },
     copy: function() {
-        var copy3 = {},
+        var copy5 = {},
             _ = this._;
         for (var t in _)
-            copy3[t] = _[t].slice();
-        return new Dispatch(copy3);
+            copy5[t] = _[t].slice();
+        return new Dispatch(copy5);
     },
-    call: function(type2, that) {
+    call: function(type3, that) {
         if ((n = arguments.length - 2) > 0)
             for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                 args[i] = arguments[i + 2];
-        if (!this._.hasOwnProperty(type2))
-            throw new Error("unknown type: " + type2);
-        for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
+        if (!this._.hasOwnProperty(type3))
+            throw new Error("unknown type: " + type3);
+        for (t = this._[type3], i = 0, n = t.length; i < n; ++i)
             t[i].value.apply(that, args);
     },
-    apply: function(type2, that, args) {
-        if (!this._.hasOwnProperty(type2))
-            throw new Error("unknown type: " + type2);
-        for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
+    apply: function(type3, that, args) {
+        if (!this._.hasOwnProperty(type3))
+            throw new Error("unknown type: " + type3);
+        for (var t = this._[type3], i = 0, n = t.length; i < n; ++i)
             t[i].value.apply(that, args);
     }
 };
 
-function get(type2, name) {
-    for (var i = 0, n = type2.length, c6; i < n; ++i) {
-        if ((c6 = type2[i]).name === name) {
-            return c6.value;
+function get(type3, name) {
+    for (var i = 0, n = type3.length, c11; i < n; ++i) {
+        if ((c11 = type3[i]).name === name) {
+            return c11.value;
         }
     }
 }
 
-function set2(type2, name, callback) {
-    for (var i = 0, n = type2.length; i < n; ++i) {
-        if (type2[i].name === name) {
-            type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
+function set2(type3, name, callback) {
+    for (var i = 0, n = type3.length; i < n; ++i) {
+        if (type3[i].name === name) {
+            type3[i] = noop, type3 = type3.slice(0, i).concat(type3.slice(i + 1));
             break;
         }
     }
     if (callback != null)
-        type2.push({
+        type3.push({
             name,
             value: callback
         });
-    return type2;
+    return type3;
 }
 var dispatch_default = dispatch;
 
 // node_modules/d3-selection/src/namespaces.js
 var xhtml = "http://www.w3.org/1999/xhtml";
 var namespaces_default = {
     svg: "http://www.w3.org/2000/svg",
@@ -3028,61 +3509,61 @@
 function selector_default(selector) {
     return selector == null ? none : function() {
         return this.querySelector(selector);
     };
 }
 
 // node_modules/d3-selection/src/selection/select.js
-function select_default(select2) {
-    if (typeof select2 !== "function")
-        select2 = selector_default(select2);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
-            if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
+function select_default(select3) {
+    if (typeof select3 !== "function")
+        select3 = selector_default(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && (subnode = select3.call(node, node.__data__, i, group5))) {
                 if ("__data__" in node)
                     subnode.__data__ = node.__data__;
                 subgroup[i] = subnode;
             }
         }
     }
     return new Selection(subgroups, this._parents);
 }
 
 // node_modules/d3-selection/src/array.js
-function array2(x4) {
-    return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);
+function array2(x7) {
+    return x7 == null ? [] : Array.isArray(x7) ? x7 : Array.from(x7);
 }
 
 // node_modules/d3-selection/src/selectorAll.js
 function empty2() {
     return [];
 }
 
 function selectorAll_default(selector) {
     return selector == null ? empty2 : function() {
         return this.querySelectorAll(selector);
     };
 }
 
 // node_modules/d3-selection/src/selection/selectAll.js
-function arrayAll(select2) {
+function arrayAll(select3) {
     return function() {
-        return array2(select2.apply(this, arguments));
+        return array2(select3.apply(this, arguments));
     };
 }
 
-function selectAll_default(select2) {
-    if (typeof select2 === "function")
-        select2 = arrayAll(select2);
+function selectAll_default(select3) {
+    if (typeof select3 === "function")
+        select3 = arrayAll(select3);
     else
-        select2 = selectorAll_default(select2);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
-            if (node = group3[i]) {
-                subgroups.push(select2.call(node, node.__data__, i, group3));
+        select3 = selectorAll_default(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = [], parents = [], j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                subgroups.push(select3.call(node, node.__data__, i, group5));
                 parents.push(node);
             }
         }
     }
     return new Selection(subgroups, parents);
 }
 
@@ -3133,17 +3614,17 @@
     return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
 }
 
 // node_modules/d3-selection/src/selection/filter.js
 function filter_default(match) {
     if (typeof match !== "function")
         match = matcher_default(match);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
-            if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && match.call(node, node.__data__, i, group5)) {
                 subgroup.push(node);
             }
         }
     }
     return new Selection(subgroups, this._parents);
 }
 
@@ -3153,20 +3634,20 @@
 }
 
 // node_modules/d3-selection/src/selection/enter.js
 function enter_default() {
     return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
 }
 
-function EnterNode(parent, datum2) {
+function EnterNode(parent, datum3) {
     this.ownerDocument = parent.ownerDocument;
     this.namespaceURI = parent.namespaceURI;
     this._next = null;
     this._parent = parent;
-    this.__data__ = datum2;
+    this.__data__ = datum3;
 }
 EnterNode.prototype = {
     constructor: EnterNode,
     appendChild: function(child) {
         return this._parent.insertBefore(child, this._next);
     },
     insertBefore: function(child, next) {
@@ -3177,49 +3658,49 @@
     },
     querySelectorAll: function(selector) {
         return this._parent.querySelectorAll(selector);
     }
 };
 
 // node_modules/d3-selection/src/constant.js
-function constant_default(x4) {
+function constant_default(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
 // node_modules/d3-selection/src/selection/data.js
-function bindIndex(parent, group3, enter, update, exit, data) {
+function bindIndex(parent, group5, enter, update, exit, data) {
     var i = 0,
-        node, groupLength = group3.length,
+        node, groupLength = group5.length,
         dataLength = data.length;
     for (; i < dataLength; ++i) {
-        if (node = group3[i]) {
+        if (node = group5[i]) {
             node.__data__ = data[i];
             update[i] = node;
         } else {
             enter[i] = new EnterNode(parent, data[i]);
         }
     }
     for (; i < groupLength; ++i) {
-        if (node = group3[i]) {
+        if (node = group5[i]) {
             exit[i] = node;
         }
     }
 }
 
-function bindKey(parent, group3, enter, update, exit, data, key) {
+function bindKey(parent, group5, enter, update, exit, data, key) {
     var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(),
-        groupLength = group3.length,
+        groupLength = group5.length,
         dataLength = data.length,
         keyValues = new Array(groupLength),
         keyValue;
     for (i = 0; i < groupLength; ++i) {
-        if (node = group3[i]) {
-            keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + "";
+        if (node = group5[i]) {
+            keyValues[i] = keyValue = key.call(node, node.__data__, i, group5) + "";
             if (nodeByKeyValue.has(keyValue)) {
                 exit[i] = node;
             } else {
                 nodeByKeyValue.set(keyValue, node);
             }
         }
     }
@@ -3230,42 +3711,42 @@
             node.__data__ = data[i];
             nodeByKeyValue.delete(keyValue);
         } else {
             enter[i] = new EnterNode(parent, data[i]);
         }
     }
     for (i = 0; i < groupLength; ++i) {
-        if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
+        if ((node = group5[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
             exit[i] = node;
         }
     }
 }
 
 function datum(node) {
     return node.__data__;
 }
 
 function data_default(value, key) {
     if (!arguments.length)
         return Array.from(this, datum);
     var bind = key ? bindKey : bindIndex,
         parents = this._parents,
-        groups2 = this._groups;
+        groups3 = this._groups;
     if (typeof value !== "function")
         value = constant_default(value);
-    for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {
+    for (var m5 = groups3.length, update = new Array(m5), enter = new Array(m5), exit = new Array(m5), j = 0; j < m5; ++j) {
         var parent = parents[j],
-            group3 = groups2[j],
-            groupLength = group3.length,
+            group5 = groups3[j],
+            groupLength = group5.length,
             data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
             dataLength = data.length,
             enterGroup = enter[j] = new Array(dataLength),
             updateGroup = update[j] = new Array(dataLength),
             exitGroup = exit[j] = new Array(groupLength);
-        bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
+        bind(parent, group5, enterGroup, updateGroup, exitGroup, data, key);
         for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
             if (previous = enterGroup[i0]) {
                 if (i0 >= i1)
                     i1 = i0 + 1;
                 while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                 ;
                 previous._next = next || null;
@@ -3309,63 +3790,63 @@
     else
         onexit(exit);
     return enter && update ? enter.merge(update).order() : update;
 }
 
 // node_modules/d3-selection/src/selection/merge.js
 function merge_default(context) {
-    var selection2 = context.selection ? context.selection() : context;
-    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
-        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+    var selection3 = context.selection ? context.selection() : context;
+    for (var groups0 = this._groups, groups1 = selection3._groups, m0 = groups0.length, m1 = groups1.length, m5 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m5; ++j) {
+        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
             if (node = group0[i] || group1[i]) {
-                merge2[i] = node;
+                merge3[i] = node;
             }
         }
     }
     for (; j < m0; ++j) {
         merges[j] = groups0[j];
     }
     return new Selection(merges, this._parents);
 }
 
 // node_modules/d3-selection/src/selection/order.js
 function order_default() {
-    for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3;) {
-        for (var group3 = groups2[j], i = group3.length - 1, next = group3[i], node; --i >= 0;) {
-            if (node = group3[i]) {
+    for (var groups3 = this._groups, j = -1, m5 = groups3.length; ++j < m5;) {
+        for (var group5 = groups3[j], i = group5.length - 1, next = group5[i], node; --i >= 0;) {
+            if (node = group5[i]) {
                 if (next && node.compareDocumentPosition(next) ^ 4)
                     next.parentNode.insertBefore(node, next);
                 next = node;
             }
         }
     }
     return this;
 }
 
 // node_modules/d3-selection/src/selection/sort.js
 function sort_default(compare) {
     if (!compare)
         compare = ascending2;
 
-    function compareNode(a4, b) {
-        return a4 && b ? compare(a4.__data__, b.__data__) : !a4 - !b;
+    function compareNode(a7, b) {
+        return a7 && b ? compare(a7.__data__, b.__data__) : !a7 - !b;
     }
-    for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
-            if (node = group3[i]) {
+    for (var groups3 = this._groups, m5 = groups3.length, sortgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
                 sortgroup[i] = node;
             }
         }
         sortgroup.sort(compareNode);
     }
     return new Selection(sortgroups, this._parents).order();
 }
 
-function ascending2(a4, b) {
-    return a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
+function ascending2(a7, b) {
+    return a7 < b ? -1 : a7 > b ? 1 : a7 >= b ? 0 : NaN;
 }
 
 // node_modules/d3-selection/src/selection/call.js
 function call_default() {
     var callback = arguments[0];
     arguments[0] = this;
     callback.apply(null, arguments);
@@ -3375,17 +3856,17 @@
 // node_modules/d3-selection/src/selection/nodes.js
 function nodes_default() {
     return Array.from(this);
 }
 
 // node_modules/d3-selection/src/selection/node.js
 function node_default() {
-    for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
-        for (var group3 = groups2[j], i = 0, n = group3.length; i < n; ++i) {
-            var node = group3[i];
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length; i < n; ++i) {
+            var node = group5[i];
             if (node)
                 return node;
         }
     }
     return null;
 }
 
@@ -3400,18 +3881,18 @@
 // node_modules/d3-selection/src/selection/empty.js
 function empty_default() {
     return !this.node();
 }
 
 // node_modules/d3-selection/src/selection/each.js
 function each_default(callback) {
-    for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
-        for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {
-            if (node = group3[i])
-                callback.call(node, node.__data__, i, group3);
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length, node; i < n; ++i) {
+            if (node = group5[i])
+                callback.call(node, node.__data__, i, group5);
         }
     }
     return this;
 }
 
 // node_modules/d3-selection/src/selection/attr.js
 function attrRemove(name) {
@@ -3436,29 +3917,29 @@
     return function() {
         this.setAttributeNS(fullname.space, fullname.local, value);
     };
 }
 
 function attrFunction(name, value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        if (v2 == null)
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
             this.removeAttribute(name);
         else
-            this.setAttribute(name, v2);
+            this.setAttribute(name, v3);
     };
 }
 
 function attrFunctionNS(fullname, value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        if (v2 == null)
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
             this.removeAttributeNS(fullname.space, fullname.local);
         else
-            this.setAttributeNS(fullname.space, fullname.local, v2);
+            this.setAttributeNS(fullname.space, fullname.local, v3);
     };
 }
 
 function attr_default(name, value) {
     var fullname = namespace_default(name);
     if (arguments.length < 2) {
         var node = this.node();
@@ -3483,19 +3964,19 @@
     return function() {
         this.style.setProperty(name, value, priority);
     };
 }
 
 function styleFunction(name, value, priority) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        if (v2 == null)
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
             this.style.removeProperty(name);
         else
-            this.style.setProperty(name, v2, priority);
+            this.style.setProperty(name, v3, priority);
     };
 }
 
 function style_default(name, value, priority) {
     return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
 }
 
@@ -3514,29 +3995,29 @@
     return function() {
         this[name] = value;
     };
 }
 
 function propertyFunction(name, value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        if (v2 == null)
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
             delete this[name];
         else
-            this[name] = v2;
+            this[name] = v3;
     };
 }
 
 function property_default(name, value) {
     return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
 }
 
 // node_modules/d3-selection/src/selection/classed.js
-function classArray(string2) {
-    return string2.trim().split(/^|\s+/);
+function classArray(string3) {
+    return string3.trim().split(/^|\s+/);
 }
 
 function classList(node) {
     return node.classList || new ClassList(node);
 }
 
 function ClassList(node) {
@@ -3620,16 +4101,16 @@
     return function() {
         this.textContent = value;
     };
 }
 
 function textFunction(value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        this.textContent = v2 == null ? "" : v2;
+        var v3 = value.apply(this, arguments);
+        this.textContent = v3 == null ? "" : v3;
     };
 }
 
 function text_default(value) {
     return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
 }
 
@@ -3642,16 +4123,16 @@
     return function() {
         this.innerHTML = value;
     };
 }
 
 function htmlFunction(value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        this.innerHTML = v2 == null ? "" : v2;
+        var v3 = value.apply(this, arguments);
+        this.innerHTML = v3 == null ? "" : v3;
     };
 }
 
 function html_default(value) {
     return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
 }
 
@@ -3673,30 +4154,30 @@
 
 function lower_default() {
     return this.each(lower);
 }
 
 // node_modules/d3-selection/src/selection/append.js
 function append_default(name) {
-    var create3 = typeof name === "function" ? name : creator_default(name);
+    var create5 = typeof name === "function" ? name : creator_default(name);
     return this.select(function() {
-        return this.appendChild(create3.apply(this, arguments));
+        return this.appendChild(create5.apply(this, arguments));
     });
 }
 
 // node_modules/d3-selection/src/selection/insert.js
 function constantNull() {
     return null;
 }
 
 function insert_default(name, before) {
-    var create3 = typeof name === "function" ? name : creator_default(name),
-        select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
+    var create5 = typeof name === "function" ? name : creator_default(name),
+        select3 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
     return this.select(function() {
-        return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);
+        return this.insertBefore(create5.apply(this, arguments), select3.apply(this, arguments) || null);
     });
 }
 
 // node_modules/d3-selection/src/selection/remove.js
 function remove() {
     var parent = this.parentNode;
     if (parent)
@@ -3750,15 +4231,15 @@
 }
 
 function onRemove(typename) {
     return function() {
         var on = this.__on;
         if (!on)
             return;
-        for (var j = 0, i = -1, m3 = on.length, o; j < m3; ++j) {
+        for (var j = 0, i = -1, m5 = on.length, o; j < m5; ++j) {
             if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                 this.removeEventListener(o.type, o.listener, o.options);
             } else {
                 on[++i] = o;
             }
         }
         if (++i)
@@ -3769,15 +4250,15 @@
 }
 
 function onAdd(typename, value, options) {
     return function() {
         var on = this.__on,
             o, listener = contextListener(value);
         if (on)
-            for (var j = 0, m3 = on.length; j < m3; ++j) {
+            for (var j = 0, m5 = on.length; j < m5; ++j) {
                 if ((o = on[j]).type === typename.type && o.name === typename.name) {
                     this.removeEventListener(o.type, o.listener, o.options);
                     this.addEventListener(o.type, o.listener = listener, o.options = options);
                     o.value = value;
                     return;
                 }
             }
@@ -3799,15 +4280,15 @@
 function on_default(typename, value, options) {
     var typenames = parseTypenames2(typename + ""),
         i, n = typenames.length,
         t;
     if (arguments.length < 2) {
         var on = this.node().__on;
         if (on)
-            for (var j = 0, m3 = on.length, o; j < m3; ++j) {
+            for (var j = 0, m5 = on.length, o; j < m5; ++j) {
                 for (i = 0, o = on[j]; i < n; ++i) {
                     if ((t = typenames[i]).type === o.type && t.name === o.name) {
                         return o.value;
                     }
                 }
             }
         return;
@@ -3815,60 +4296,60 @@
     on = value ? onAdd : onRemove;
     for (i = 0; i < n; ++i)
         this.each(on(typenames[i], value, options));
     return this;
 }
 
 // node_modules/d3-selection/src/selection/dispatch.js
-function dispatchEvent(node, type2, params) {
-    var window3 = window_default(node),
-        event = window3.CustomEvent;
+function dispatchEvent(node, type3, params) {
+    var window4 = window_default(node),
+        event = window4.CustomEvent;
     if (typeof event === "function") {
-        event = new event(type2, params);
+        event = new event(type3, params);
     } else {
-        event = window3.document.createEvent("Event");
+        event = window4.document.createEvent("Event");
         if (params)
-            event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
+            event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
         else
-            event.initEvent(type2, false, false);
+            event.initEvent(type3, false, false);
     }
     node.dispatchEvent(event);
 }
 
-function dispatchConstant(type2, params) {
+function dispatchConstant(type3, params) {
     return function() {
-        return dispatchEvent(this, type2, params);
+        return dispatchEvent(this, type3, params);
     };
 }
 
-function dispatchFunction(type2, params) {
+function dispatchFunction(type3, params) {
     return function() {
-        return dispatchEvent(this, type2, params.apply(this, arguments));
+        return dispatchEvent(this, type3, params.apply(this, arguments));
     };
 }
 
-function dispatch_default2(type2, params) {
-    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
+function dispatch_default2(type3, params) {
+    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
 }
 
 // node_modules/d3-selection/src/selection/iterator.js
 function* iterator_default() {
-    for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
-        for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {
-            if (node = group3[i])
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length, node; i < n; ++i) {
+            if (node = group5[i])
                 yield node;
         }
     }
 }
 
 // node_modules/d3-selection/src/selection/index.js
 var root = [null];
 
-function Selection(groups2, parents) {
-    this._groups = groups2;
+function Selection(groups3, parents) {
+    this._groups = groups3;
     this._parents = parents;
 }
 
 function selection() {
     return new Selection([
         [document.documentElement]
     ], root);
@@ -3940,19 +4421,19 @@
 
 function Local() {
     this._ = "@" + (++nextId).toString(36);
 }
 Local.prototype = local.prototype = {
     constructor: Local,
     get: function(node) {
-        var id2 = this._;
-        while (!(id2 in node))
+        var id3 = this._;
+        while (!(id3 in node))
             if (!(node = node.parentNode))
                 return;
-        return node[id2];
+        return node[id3];
     },
     set: function(node, value) {
         return node[this._] = value;
     },
     remove: function(node) {
         return this._ in node && delete node[this._];
     },
@@ -3971,24 +4452,24 @@
 
 // node_modules/d3-selection/src/pointer.js
 function pointer_default(event, node) {
     event = sourceEvent_default(event);
     if (node === void 0)
         node = event.currentTarget;
     if (node) {
-        var svg2 = node.ownerSVGElement || node;
-        if (svg2.createSVGPoint) {
-            var point6 = svg2.createSVGPoint();
-            point6.x = event.clientX, point6.y = event.clientY;
-            point6 = point6.matrixTransform(node.getScreenCTM().inverse());
-            return [point6.x, point6.y];
+        var svg3 = node.ownerSVGElement || node;
+        if (svg3.createSVGPoint) {
+            var point11 = svg3.createSVGPoint();
+            point11.x = event.clientX, point11.y = event.clientY;
+            point11 = point11.matrixTransform(node.getScreenCTM().inverse());
+            return [point11.x, point11.y];
         }
         if (node.getBoundingClientRect) {
-            var rect2 = node.getBoundingClientRect();
-            return [event.clientX - rect2.left - node.clientLeft, event.clientY - rect2.top - node.clientTop];
+            var rect3 = node.getBoundingClientRect();
+            return [event.clientX - rect3.left - node.clientLeft, event.clientY - rect3.top - node.clientTop];
         }
     }
     return [event.pageX, event.pageY];
 }
 
 // node_modules/d3-selection/src/pointers.js
 function pointers_default(events, node) {
@@ -4022,60 +4503,60 @@
 function noevent_default(event) {
     event.preventDefault();
     event.stopImmediatePropagation();
 }
 
 // node_modules/d3-drag/src/nodrag.js
 function nodrag_default(view) {
-    var root3 = view.document.documentElement,
-        selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
-    if ("onselectstart" in root3) {
-        selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
+    var root5 = view.document.documentElement,
+        selection3 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
+    if ("onselectstart" in root5) {
+        selection3.on("selectstart.drag", noevent_default, nonpassivecapture);
     } else {
-        root3.__noselect = root3.style.MozUserSelect;
-        root3.style.MozUserSelect = "none";
+        root5.__noselect = root5.style.MozUserSelect;
+        root5.style.MozUserSelect = "none";
     }
 }
 
 function yesdrag(view, noclick) {
-    var root3 = view.document.documentElement,
-        selection2 = select_default2(view).on("dragstart.drag", null);
+    var root5 = view.document.documentElement,
+        selection3 = select_default2(view).on("dragstart.drag", null);
     if (noclick) {
-        selection2.on("click.drag", noevent_default, nonpassivecapture);
+        selection3.on("click.drag", noevent_default, nonpassivecapture);
         setTimeout(function() {
-            selection2.on("click.drag", null);
+            selection3.on("click.drag", null);
         }, 0);
     }
-    if ("onselectstart" in root3) {
-        selection2.on("selectstart.drag", null);
+    if ("onselectstart" in root5) {
+        selection3.on("selectstart.drag", null);
     } else {
-        root3.style.MozUserSelect = root3.__noselect;
-        delete root3.__noselect;
+        root5.style.MozUserSelect = root5.__noselect;
+        delete root5.__noselect;
     }
 }
 
 // node_modules/d3-drag/src/constant.js
-var constant_default2 = (x4) => () => x4;
+var constant_default2 = (x7) => () => x7;
 
 // node_modules/d3-drag/src/event.js
-function DragEvent(type2, {
+function DragEvent(type3, {
     sourceEvent,
     subject,
     target,
     identifier,
     active,
-    x: x4,
-    y: y4,
+    x: x7,
+    y: y7,
     dx,
     dy,
-    dispatch: dispatch2
+    dispatch: dispatch3
 }) {
     Object.defineProperties(this, {
         type: {
-            value: type2,
+            value: type3,
             enumerable: true,
             configurable: true
         },
         sourceEvent: {
             value: sourceEvent,
             enumerable: true,
             configurable: true
@@ -4097,35 +4578,35 @@
         },
         active: {
             value: active,
             enumerable: true,
             configurable: true
         },
         x: {
-            value: x4,
+            value: x7,
             enumerable: true,
             configurable: true
         },
         y: {
-            value: y4,
+            value: y7,
             enumerable: true,
             configurable: true
         },
         dx: {
             value: dx,
             enumerable: true,
             configurable: true
         },
         dy: {
             value: dy,
             enumerable: true,
             configurable: true
         },
         _: {
-            value: dispatch2
+            value: dispatch3
         }
     });
 }
 DragEvent.prototype.on = function() {
     var value = this._.on.apply(this._, arguments);
     return value === this._ ? this : value;
 };
@@ -4147,29 +4628,29 @@
 }
 
 function defaultTouchable() {
     return navigator.maxTouchPoints || "ontouchstart" in this;
 }
 
 function drag_default() {
-    var filter4 = defaultFilter,
+    var filter7 = defaultFilter,
         container = defaultContainer,
         subject = defaultSubject,
         touchable = defaultTouchable,
         gestures = {},
         listeners = dispatch_default("start", "drag", "end"),
         active = 0,
         mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
 
-    function drag(selection2) {
-        selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+    function drag(selection3) {
+        selection3.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
     }
 
     function mousedowned(event, d) {
-        if (touchending || !filter4.call(this, event, d))
+        if (touchending || !filter7.call(this, event, d))
             return;
         var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
         if (!gesture)
             return;
         select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
         nodrag_default(event.view);
         nopropagation(event);
@@ -4193,22 +4674,22 @@
         select_default2(event.view).on("mousemove.drag mouseup.drag", null);
         yesdrag(event.view, mousemoving);
         noevent_default(event);
         gestures.mouse("end", event);
     }
 
     function touchstarted(event, d) {
-        if (!filter4.call(this, event, d))
+        if (!filter7.call(this, event, d))
             return;
         var touches = event.changedTouches,
-            c6 = container.call(this, event, d),
+            c11 = container.call(this, event, d),
             n = touches.length,
             i, gesture;
         for (i = 0; i < n; ++i) {
-            if (gesture = beforestart(this, c6, event, d, touches[i].identifier, touches[i])) {
+            if (gesture = beforestart(this, c11, event, d, touches[i].identifier, touches[i])) {
                 nopropagation(event);
                 gesture("start", event, touches[i]);
             }
         }
     }
 
     function touchmoved(event) {
@@ -4237,65 +4718,65 @@
                 nopropagation(event);
                 gesture("end", event, touches[i]);
             }
         }
     }
 
     function beforestart(that, container2, event, d, identifier, touch) {
-        var dispatch2 = listeners.copy(),
+        var dispatch3 = listeners.copy(),
             p = pointer_default(touch || event, container2),
-            dx, dy, s2;
-        if ((s2 = subject.call(that, new DragEvent("beforestart", {
+            dx, dy, s3;
+        if ((s3 = subject.call(that, new DragEvent("beforestart", {
                 sourceEvent: event,
                 target: drag,
                 identifier,
                 active,
                 x: p[0],
                 y: p[1],
                 dx: 0,
                 dy: 0,
-                dispatch: dispatch2
+                dispatch: dispatch3
             }), d)) == null)
             return;
-        dx = s2.x - p[0] || 0;
-        dy = s2.y - p[1] || 0;
-        return function gesture(type2, event2, touch2) {
-            var p02 = p,
+        dx = s3.x - p[0] || 0;
+        dy = s3.y - p[1] || 0;
+        return function gesture(type3, event2, touch2) {
+            var p03 = p,
                 n;
-            switch (type2) {
+            switch (type3) {
                 case "start":
                     gestures[identifier] = gesture, n = active++;
                     break;
                 case "end":
                     delete gestures[identifier], --active;
                 case "drag":
                     p = pointer_default(touch2 || event2, container2), n = active;
                     break;
             }
-            dispatch2.call(
-                type2,
+            dispatch3.call(
+                type3,
                 that,
-                new DragEvent(type2, {
+                new DragEvent(type3, {
                     sourceEvent: event2,
-                    subject: s2,
+                    subject: s3,
                     target: drag,
                     identifier,
                     active: n,
                     x: p[0] + dx,
                     y: p[1] + dy,
-                    dx: p[0] - p02[0],
-                    dy: p[1] - p02[1],
-                    dispatch: dispatch2
+                    dx: p[0] - p03[0],
+                    dy: p[1] - p03[1],
+                    dispatch: dispatch3
                 }),
                 d
             );
         };
     }
     drag.filter = function(_) {
-        return arguments.length ? (filter4 = typeof _ === "function" ? _ : constant_default2(!!_), drag) : filter4;
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default2(!!_), drag) : filter7;
     };
     drag.container = function(_) {
         return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag) : container;
     };
     drag.subject = function(_) {
         return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag) : subject;
     };
@@ -4517,57 +4998,57 @@
     return hslConvert(this).formatHsl();
 }
 
 function color_formatRgb() {
     return this.rgb().formatRgb();
 }
 
-function color(format3) {
-    var m3, l;
-    format3 = (format3 + "").trim().toLowerCase();
-    return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
+function color(format5) {
+    var m5, l;
+    format5 = (format5 + "").trim().toLowerCase();
+    return (m5 = reHex.exec(format5)) ? (l = m5[1].length, m5 = parseInt(m5[1], 16), l === 6 ? rgbn(m5) : l === 3 ? new Rgb(m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, (m5 & 15) << 4 | m5 & 15, 1) : l === 8 ? rgba(m5 >> 24 & 255, m5 >> 16 & 255, m5 >> 8 & 255, (m5 & 255) / 255) : l === 4 ? rgba(m5 >> 12 & 15 | m5 >> 8 & 240, m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, ((m5 & 15) << 4 | m5 & 15) / 255) : null) : (m5 = reRgbInteger.exec(format5)) ? new Rgb(m5[1], m5[2], m5[3], 1) : (m5 = reRgbPercent.exec(format5)) ? new Rgb(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, 1) : (m5 = reRgbaInteger.exec(format5)) ? rgba(m5[1], m5[2], m5[3], m5[4]) : (m5 = reRgbaPercent.exec(format5)) ? rgba(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, m5[4]) : (m5 = reHslPercent.exec(format5)) ? hsla(m5[1], m5[2] / 100, m5[3] / 100, 1) : (m5 = reHslaPercent.exec(format5)) ? hsla(m5[1], m5[2] / 100, m5[3] / 100, m5[4]) : named.hasOwnProperty(format5) ? rgbn(named[format5]) : format5 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
 }
 
 function rgbn(n) {
     return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
 }
 
-function rgba(r, g, b, a4) {
-    if (a4 <= 0)
+function rgba(r, g, b, a7) {
+    if (a7 <= 0)
         r = g = b = NaN;
-    return new Rgb(r, g, b, a4);
+    return new Rgb(r, g, b, a7);
 }
 
 function rgbConvert(o) {
     if (!(o instanceof Color))
         o = color(o);
     if (!o)
         return new Rgb();
     o = o.rgb();
     return new Rgb(o.r, o.g, o.b, o.opacity);
 }
 
-function rgb(r, g, b, opacity2) {
-    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);
+function rgb(r, g, b, opacity3) {
+    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity3 == null ? 1 : opacity3);
 }
 
-function Rgb(r, g, b, opacity2) {
+function Rgb(r, g, b, opacity3) {
     this.r = +r;
     this.g = +g;
     this.b = +b;
-    this.opacity = +opacity2;
+    this.opacity = +opacity3;
 }
 define_default(Rgb, rgb, extend(Color, {
-    brighter(k2) {
-        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
-        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
-    },
-    darker(k2) {
-        k2 = k2 == null ? darker : Math.pow(darker, k2);
-        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
+    brighter(k3) {
+        k3 = k3 == null ? brighter : Math.pow(brighter, k3);
+        return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker : Math.pow(darker, k3);
+        return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
     },
     rgb() {
         return this;
     },
     clamp() {
         return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
     },
@@ -4587,39 +5068,39 @@
 }
 
 function rgb_formatHex8() {
     return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
 }
 
 function rgb_formatRgb() {
-    const a4 = clampa(this.opacity);
-    return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
+    const a7 = clampa(this.opacity);
+    return `${a7 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a7 === 1 ? ")" : `, ${a7})`}`;
 }
 
-function clampa(opacity2) {
-    return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
+function clampa(opacity3) {
+    return isNaN(opacity3) ? 1 : Math.max(0, Math.min(1, opacity3));
 }
 
 function clampi(value) {
     return Math.max(0, Math.min(255, Math.round(value) || 0));
 }
 
 function hex(value) {
     value = clampi(value);
     return (value < 16 ? "0" : "") + value.toString(16);
 }
 
-function hsla(h, s2, l, a4) {
-    if (a4 <= 0)
-        h = s2 = l = NaN;
+function hsla(h, s3, l, a7) {
+    if (a7 <= 0)
+        h = s3 = l = NaN;
     else if (l <= 0 || l >= 1)
-        h = s2 = NaN;
-    else if (s2 <= 0)
+        h = s3 = NaN;
+    else if (s3 <= 0)
         h = NaN;
-    return new Hsl(h, s2, l, a4);
+    return new Hsl(h, s3, l, a7);
 }
 
 function hslConvert(o) {
     if (o instanceof Hsl)
         return new Hsl(o.h, o.s, o.l, o.opacity);
     if (!(o instanceof Color))
         o = color(o);
@@ -4627,58 +5108,58 @@
         return new Hsl();
     if (o instanceof Hsl)
         return o;
     o = o.rgb();
     var r = o.r / 255,
         g = o.g / 255,
         b = o.b / 255,
-        min4 = Math.min(r, g, b),
-        max5 = Math.max(r, g, b),
+        min7 = Math.min(r, g, b),
+        max9 = Math.max(r, g, b),
         h = NaN,
-        s2 = max5 - min4,
-        l = (max5 + min4) / 2;
-    if (s2) {
-        if (r === max5)
-            h = (g - b) / s2 + (g < b) * 6;
-        else if (g === max5)
-            h = (b - r) / s2 + 2;
+        s3 = max9 - min7,
+        l = (max9 + min7) / 2;
+    if (s3) {
+        if (r === max9)
+            h = (g - b) / s3 + (g < b) * 6;
+        else if (g === max9)
+            h = (b - r) / s3 + 2;
         else
-            h = (r - g) / s2 + 4;
-        s2 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;
+            h = (r - g) / s3 + 4;
+        s3 /= l < 0.5 ? max9 + min7 : 2 - max9 - min7;
         h *= 60;
     } else {
-        s2 = l > 0 && l < 1 ? 0 : h;
+        s3 = l > 0 && l < 1 ? 0 : h;
     }
-    return new Hsl(h, s2, l, o.opacity);
+    return new Hsl(h, s3, l, o.opacity);
 }
 
-function hsl(h, s2, l, opacity2) {
-    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity2 == null ? 1 : opacity2);
+function hsl(h, s3, l, opacity3) {
+    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s3, l, opacity3 == null ? 1 : opacity3);
 }
 
-function Hsl(h, s2, l, opacity2) {
+function Hsl(h, s3, l, opacity3) {
     this.h = +h;
-    this.s = +s2;
+    this.s = +s3;
     this.l = +l;
-    this.opacity = +opacity2;
+    this.opacity = +opacity3;
 }
 define_default(Hsl, hsl, extend(Color, {
-    brighter(k2) {
-        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
-        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
-    },
-    darker(k2) {
-        k2 = k2 == null ? darker : Math.pow(darker, k2);
-        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
+    brighter(k3) {
+        k3 = k3 == null ? brighter : Math.pow(brighter, k3);
+        return new Hsl(this.h, this.s, this.l * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker : Math.pow(darker, k3);
+        return new Hsl(this.h, this.s, this.l * k3, this.opacity);
     },
     rgb() {
         var h = this.h % 360 + (this.h < 0) * 360,
-            s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s,
+            s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s,
             l = this.l,
-            m22 = l + (l < 0.5 ? l : 1 - l) * s2,
+            m22 = l + (l < 0.5 ? l : 1 - l) * s3,
             m1 = 2 * l - m22;
         return new Rgb(
             hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
             hsl2rgb(h, m1, m22),
             hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
             this.opacity
         );
@@ -4686,16 +5167,16 @@
     clamp() {
         return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
     },
     displayable() {
         return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
     },
     formatHsl() {
-        const a4 = clampa(this.opacity);
-        return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
+        const a7 = clampa(this.opacity);
+        return `${a7 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a7 === 1 ? ")" : `, ${a7})`}`;
     }
 }));
 
 function clamph(value) {
     value = (value || 0) % 360;
     return value < 0 ? value + 360 : value;
 }
@@ -4728,116 +5209,116 @@
     if (o instanceof Hcl)
         return hcl2lab(o);
     if (!(o instanceof Rgb))
         o = rgbConvert(o);
     var r = rgb2lrgb(o.r),
         g = rgb2lrgb(o.g),
         b = rgb2lrgb(o.b),
-        y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
-        x4, z;
+        y7 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
+        x7, z;
     if (r === g && g === b)
-        x4 = z = y4;
+        x7 = z = y7;
     else {
-        x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
+        x7 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
         z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
     }
-    return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);
+    return new Lab(116 * y7 - 16, 500 * (x7 - y7), 200 * (y7 - z), o.opacity);
 }
 
-function gray(l, opacity2) {
-    return new Lab(l, 0, 0, opacity2 == null ? 1 : opacity2);
+function gray(l, opacity3) {
+    return new Lab(l, 0, 0, opacity3 == null ? 1 : opacity3);
 }
 
-function lab(l, a4, b, opacity2) {
-    return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity2 == null ? 1 : opacity2);
+function lab(l, a7, b, opacity3) {
+    return arguments.length === 1 ? labConvert(l) : new Lab(l, a7, b, opacity3 == null ? 1 : opacity3);
 }
 
-function Lab(l, a4, b, opacity2) {
+function Lab(l, a7, b, opacity3) {
     this.l = +l;
-    this.a = +a4;
+    this.a = +a7;
     this.b = +b;
-    this.opacity = +opacity2;
+    this.opacity = +opacity3;
 }
 define_default(Lab, lab, extend(Color, {
-    brighter(k2) {
-        return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
+    brighter(k3) {
+        return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
     },
-    darker(k2) {
-        return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
+    darker(k3) {
+        return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
     },
     rgb() {
-        var y4 = (this.l + 16) / 116,
-            x4 = isNaN(this.a) ? y4 : y4 + this.a / 500,
-            z = isNaN(this.b) ? y4 : y4 - this.b / 200;
-        x4 = Xn * lab2xyz(x4);
-        y4 = Yn * lab2xyz(y4);
+        var y7 = (this.l + 16) / 116,
+            x7 = isNaN(this.a) ? y7 : y7 + this.a / 500,
+            z = isNaN(this.b) ? y7 : y7 - this.b / 200;
+        x7 = Xn * lab2xyz(x7);
+        y7 = Yn * lab2xyz(y7);
         z = Zn * lab2xyz(z);
         return new Rgb(
-            lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),
-            lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),
-            lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),
+            lrgb2rgb(3.1338561 * x7 - 1.6168667 * y7 - 0.4906146 * z),
+            lrgb2rgb(-0.9787684 * x7 + 1.9161415 * y7 + 0.033454 * z),
+            lrgb2rgb(0.0719453 * x7 - 0.2289914 * y7 + 1.4052427 * z),
             this.opacity
         );
     }
 }));
 
 function xyz2lab(t) {
     return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
 }
 
 function lab2xyz(t) {
     return t > t1 ? t * t * t : t2 * (t - t0);
 }
 
-function lrgb2rgb(x4) {
-    return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);
+function lrgb2rgb(x7) {
+    return 255 * (x7 <= 31308e-7 ? 12.92 * x7 : 1.055 * Math.pow(x7, 1 / 2.4) - 0.055);
 }
 
-function rgb2lrgb(x4) {
-    return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);
+function rgb2lrgb(x7) {
+    return (x7 /= 255) <= 0.04045 ? x7 / 12.92 : Math.pow((x7 + 0.055) / 1.055, 2.4);
 }
 
 function hclConvert(o) {
     if (o instanceof Hcl)
         return new Hcl(o.h, o.c, o.l, o.opacity);
     if (!(o instanceof Lab))
         o = labConvert(o);
     if (o.a === 0 && o.b === 0)
         return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
     var h = Math.atan2(o.b, o.a) * degrees;
     return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
 }
 
-function lch(l, c6, h, opacity2) {
-    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);
+function lch(l, c11, h, opacity3) {
+    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c11, l, opacity3 == null ? 1 : opacity3);
 }
 
-function hcl(h, c6, l, opacity2) {
-    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);
+function hcl(h, c11, l, opacity3) {
+    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c11, l, opacity3 == null ? 1 : opacity3);
 }
 
-function Hcl(h, c6, l, opacity2) {
+function Hcl(h, c11, l, opacity3) {
     this.h = +h;
-    this.c = +c6;
+    this.c = +c11;
     this.l = +l;
-    this.opacity = +opacity2;
+    this.opacity = +opacity3;
 }
 
 function hcl2lab(o) {
     if (isNaN(o.h))
         return new Lab(o.l, 0, 0, o.opacity);
     var h = o.h * radians;
     return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
 }
 define_default(Hcl, hcl, extend(Color, {
-    brighter(k2) {
-        return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
+    brighter(k3) {
+        return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
     },
-    darker(k2) {
-        return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
+    darker(k3) {
+        return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
     },
     rgb() {
         return hcl2lab(this).rgb();
     }
 }));
 
 // node_modules/d3-color/src/cubehelix.js
@@ -4856,245 +5337,245 @@
     if (!(o instanceof Rgb))
         o = rgbConvert(o);
     var r = o.r / 255,
         g = o.g / 255,
         b = o.b / 255,
         l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
         bl = b - l,
-        k2 = (E * (g - l) - C * bl) / D,
-        s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)),
-        h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
-    return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
+        k3 = (E * (g - l) - C * bl) / D,
+        s3 = Math.sqrt(k3 * k3 + bl * bl) / (E * l * (1 - l)),
+        h = s3 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
+    return new Cubehelix(h < 0 ? h + 360 : h, s3, l, o.opacity);
 }
 
-function cubehelix(h, s2, l, opacity2) {
-    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity2 == null ? 1 : opacity2);
+function cubehelix(h, s3, l, opacity3) {
+    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s3, l, opacity3 == null ? 1 : opacity3);
 }
 
-function Cubehelix(h, s2, l, opacity2) {
+function Cubehelix(h, s3, l, opacity3) {
     this.h = +h;
-    this.s = +s2;
+    this.s = +s3;
     this.l = +l;
-    this.opacity = +opacity2;
+    this.opacity = +opacity3;
 }
 define_default(Cubehelix, cubehelix, extend(Color, {
-    brighter(k2) {
-        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
-        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
-    },
-    darker(k2) {
-        k2 = k2 == null ? darker : Math.pow(darker, k2);
-        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
+    brighter(k3) {
+        k3 = k3 == null ? brighter : Math.pow(brighter, k3);
+        return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker : Math.pow(darker, k3);
+        return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
     },
     rgb() {
         var h = isNaN(this.h) ? 0 : (this.h + 120) * radians,
             l = +this.l,
-            a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l),
-            cosh2 = Math.cos(h),
-            sinh2 = Math.sin(h);
+            a7 = isNaN(this.s) ? 0 : this.s * l * (1 - l),
+            cosh3 = Math.cos(h),
+            sinh3 = Math.sin(h);
         return new Rgb(
-            255 * (l + a4 * (A * cosh2 + B * sinh2)),
-            255 * (l + a4 * (C * cosh2 + D * sinh2)),
-            255 * (l + a4 * (E * cosh2)),
+            255 * (l + a7 * (A * cosh3 + B * sinh3)),
+            255 * (l + a7 * (C * cosh3 + D * sinh3)),
+            255 * (l + a7 * (E * cosh3)),
             this.opacity
         );
     }
 }));
 
 // node_modules/d3-interpolate/src/basis.js
-function basis(t13, v0, v1, v2, v3) {
-    var t22 = t13 * t13,
-        t32 = t22 * t13;
-    return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
+function basis(t15, v0, v1, v22, v3) {
+    var t23 = t15 * t15,
+        t33 = t23 * t15;
+    return ((1 - 3 * t15 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t15 + 3 * t23 - 3 * t33) * v22 + t33 * v3) / 6;
 }
 
-function basis_default(values2) {
-    var n = values2.length - 1;
+function basis_default(values3) {
+    var n = values3.length - 1;
     return function(t) {
         var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
-            v1 = values2[i],
-            v2 = values2[i + 1],
-            v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2,
-            v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
-        return basis((t - i / n) * n, v0, v1, v2, v3);
+            v1 = values3[i],
+            v22 = values3[i + 1],
+            v0 = i > 0 ? values3[i - 1] : 2 * v1 - v22,
+            v3 = i < n - 1 ? values3[i + 2] : 2 * v22 - v1;
+        return basis((t - i / n) * n, v0, v1, v22, v3);
     };
 }
 
 // node_modules/d3-interpolate/src/basisClosed.js
-function basisClosed_default(values2) {
-    var n = values2.length;
+function basisClosed_default(values3) {
+    var n = values3.length;
     return function(t) {
         var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
-            v0 = values2[(i + n - 1) % n],
-            v1 = values2[i % n],
-            v2 = values2[(i + 1) % n],
-            v3 = values2[(i + 2) % n];
-        return basis((t - i / n) * n, v0, v1, v2, v3);
+            v0 = values3[(i + n - 1) % n],
+            v1 = values3[i % n],
+            v22 = values3[(i + 1) % n],
+            v3 = values3[(i + 2) % n];
+        return basis((t - i / n) * n, v0, v1, v22, v3);
     };
 }
 
 // node_modules/d3-interpolate/src/constant.js
-var constant_default3 = (x4) => () => x4;
+var constant_default3 = (x7) => () => x7;
 
 // node_modules/d3-interpolate/src/color.js
-function linear(a4, d) {
+function linear(a7, d) {
     return function(t) {
-        return a4 + t * d;
+        return a7 + t * d;
     };
 }
 
-function exponential(a4, b, y4) {
-    return a4 = Math.pow(a4, y4), b = Math.pow(b, y4) - a4, y4 = 1 / y4,
+function exponential(a7, b, y7) {
+    return a7 = Math.pow(a7, y7), b = Math.pow(b, y7) - a7, y7 = 1 / y7,
         function(t) {
-            return Math.pow(a4 + t * b, y4);
+            return Math.pow(a7 + t * b, y7);
         };
 }
 
-function hue(a4, b) {
-    var d = b - a4;
-    return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b : a4);
+function hue(a7, b) {
+    var d = b - a7;
+    return d ? linear(a7, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a7) ? b : a7);
 }
 
-function gamma(y4) {
-    return (y4 = +y4) === 1 ? nogamma : function(a4, b) {
-        return b - a4 ? exponential(a4, b, y4) : constant_default3(isNaN(a4) ? b : a4);
+function gamma(y7) {
+    return (y7 = +y7) === 1 ? nogamma : function(a7, b) {
+        return b - a7 ? exponential(a7, b, y7) : constant_default3(isNaN(a7) ? b : a7);
     };
 }
 
-function nogamma(a4, b) {
-    var d = b - a4;
-    return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b : a4);
+function nogamma(a7, b) {
+    var d = b - a7;
+    return d ? linear(a7, d) : constant_default3(isNaN(a7) ? b : a7);
 }
 
 // node_modules/d3-interpolate/src/rgb.js
-var rgb_default = function rgbGamma(y4) {
-    var color3 = gamma(y4);
+var rgb_default = function rgbGamma(y7) {
+    var color5 = gamma(y7);
 
-    function rgb2(start2, end) {
-        var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r),
-            g = color3(start2.g, end.g),
-            b = color3(start2.b, end.b),
-            opacity2 = nogamma(start2.opacity, end.opacity);
+    function rgb3(start3, end) {
+        var r = color5((start3 = rgb(start3)).r, (end = rgb(end)).r),
+            g = color5(start3.g, end.g),
+            b = color5(start3.b, end.b),
+            opacity3 = nogamma(start3.opacity, end.opacity);
         return function(t) {
-            start2.r = r(t);
-            start2.g = g(t);
-            start2.b = b(t);
-            start2.opacity = opacity2(t);
-            return start2 + "";
+            start3.r = r(t);
+            start3.g = g(t);
+            start3.b = b(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
         };
     }
-    rgb2.gamma = rgbGamma;
-    return rgb2;
+    rgb3.gamma = rgbGamma;
+    return rgb3;
 }(1);
 
 function rgbSpline(spline) {
     return function(colors) {
         var n = colors.length,
             r = new Array(n),
             g = new Array(n),
             b = new Array(n),
-            i, color3;
+            i, color5;
         for (i = 0; i < n; ++i) {
-            color3 = rgb(colors[i]);
-            r[i] = color3.r || 0;
-            g[i] = color3.g || 0;
-            b[i] = color3.b || 0;
+            color5 = rgb(colors[i]);
+            r[i] = color5.r || 0;
+            g[i] = color5.g || 0;
+            b[i] = color5.b || 0;
         }
         r = spline(r);
         g = spline(g);
         b = spline(b);
-        color3.opacity = 1;
+        color5.opacity = 1;
         return function(t) {
-            color3.r = r(t);
-            color3.g = g(t);
-            color3.b = b(t);
-            return color3 + "";
+            color5.r = r(t);
+            color5.g = g(t);
+            color5.b = b(t);
+            return color5 + "";
         };
     };
 }
 var rgbBasis = rgbSpline(basis_default);
 var rgbBasisClosed = rgbSpline(basisClosed_default);
 
 // node_modules/d3-interpolate/src/numberArray.js
-function numberArray_default(a4, b) {
+function numberArray_default(a7, b) {
     if (!b)
         b = [];
-    var n = a4 ? Math.min(b.length, a4.length) : 0,
-        c6 = b.slice(),
+    var n = a7 ? Math.min(b.length, a7.length) : 0,
+        c11 = b.slice(),
         i;
     return function(t) {
         for (i = 0; i < n; ++i)
-            c6[i] = a4[i] * (1 - t) + b[i] * t;
-        return c6;
+            c11[i] = a7[i] * (1 - t) + b[i] * t;
+        return c11;
     };
 }
 
-function isNumberArray(x4) {
-    return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
+function isNumberArray(x7) {
+    return ArrayBuffer.isView(x7) && !(x7 instanceof DataView);
 }
 
 // node_modules/d3-interpolate/src/array.js
-function array_default(a4, b) {
-    return (isNumberArray(b) ? numberArray_default : genericArray)(a4, b);
+function array_default(a7, b) {
+    return (isNumberArray(b) ? numberArray_default : genericArray)(a7, b);
 }
 
-function genericArray(a4, b) {
+function genericArray(a7, b) {
     var nb = b ? b.length : 0,
-        na = a4 ? Math.min(nb, a4.length) : 0,
-        x4 = new Array(na),
-        c6 = new Array(nb),
+        na = a7 ? Math.min(nb, a7.length) : 0,
+        x7 = new Array(na),
+        c11 = new Array(nb),
         i;
     for (i = 0; i < na; ++i)
-        x4[i] = value_default(a4[i], b[i]);
+        x7[i] = value_default(a7[i], b[i]);
     for (; i < nb; ++i)
-        c6[i] = b[i];
+        c11[i] = b[i];
     return function(t) {
         for (i = 0; i < na; ++i)
-            c6[i] = x4[i](t);
-        return c6;
+            c11[i] = x7[i](t);
+        return c11;
     };
 }
 
 // node_modules/d3-interpolate/src/date.js
-function date_default(a4, b) {
+function date_default(a7, b) {
     var d = /* @__PURE__ */ new Date();
-    return a4 = +a4, b = +b,
+    return a7 = +a7, b = +b,
         function(t) {
-            return d.setTime(a4 * (1 - t) + b * t), d;
+            return d.setTime(a7 * (1 - t) + b * t), d;
         };
 }
 
 // node_modules/d3-interpolate/src/number.js
-function number_default(a4, b) {
-    return a4 = +a4, b = +b,
+function number_default(a7, b) {
+    return a7 = +a7, b = +b,
         function(t) {
-            return a4 * (1 - t) + b * t;
+            return a7 * (1 - t) + b * t;
         };
 }
 
 // node_modules/d3-interpolate/src/object.js
-function object_default(a4, b) {
+function object_default(a7, b) {
     var i = {},
-        c6 = {},
-        k2;
-    if (a4 === null || typeof a4 !== "object")
-        a4 = {};
+        c11 = {},
+        k3;
+    if (a7 === null || typeof a7 !== "object")
+        a7 = {};
     if (b === null || typeof b !== "object")
         b = {};
-    for (k2 in b) {
-        if (k2 in a4) {
-            i[k2] = value_default(a4[k2], b[k2]);
+    for (k3 in b) {
+        if (k3 in a7) {
+            i[k3] = value_default(a7[k3], b[k3]);
         } else {
-            c6[k2] = b[k2];
+            c11[k3] = b[k3];
         }
     }
     return function(t) {
-        for (k2 in i)
-            c6[k2] = i[k2](t);
-        return c6;
+        for (k3 in i)
+            c11[k3] = i[k3](t);
+        return c11;
     };
 }
 
 // node_modules/d3-interpolate/src/string.js
 var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
 var reB = new RegExp(reA.source, "g");
 
@@ -5106,125 +5587,125 @@
 
 function one(b) {
     return function(t) {
         return b(t) + "";
     };
 }
 
-function string_default(a4, b) {
+function string_default(a7, b) {
     var bi = reA.lastIndex = reB.lastIndex = 0,
         am, bm, bs, i = -1,
-        s2 = [],
+        s3 = [],
         q = [];
-    a4 = a4 + "", b = b + "";
-    while ((am = reA.exec(a4)) && (bm = reB.exec(b))) {
+    a7 = a7 + "", b = b + "";
+    while ((am = reA.exec(a7)) && (bm = reB.exec(b))) {
         if ((bs = bm.index) > bi) {
             bs = b.slice(bi, bs);
-            if (s2[i])
-                s2[i] += bs;
+            if (s3[i])
+                s3[i] += bs;
             else
-                s2[++i] = bs;
+                s3[++i] = bs;
         }
         if ((am = am[0]) === (bm = bm[0])) {
-            if (s2[i])
-                s2[i] += bm;
+            if (s3[i])
+                s3[i] += bm;
             else
-                s2[++i] = bm;
+                s3[++i] = bm;
         } else {
-            s2[++i] = null;
+            s3[++i] = null;
             q.push({
                 i,
                 x: number_default(am, bm)
             });
         }
         bi = reB.lastIndex;
     }
     if (bi < b.length) {
         bs = b.slice(bi);
-        if (s2[i])
-            s2[i] += bs;
+        if (s3[i])
+            s3[i] += bs;
         else
-            s2[++i] = bs;
+            s3[++i] = bs;
     }
-    return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
+    return s3.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
         for (var i2 = 0, o; i2 < b; ++i2)
-            s2[(o = q[i2]).i] = o.x(t);
-        return s2.join("");
+            s3[(o = q[i2]).i] = o.x(t);
+        return s3.join("");
     });
 }
 
 // node_modules/d3-interpolate/src/value.js
-function value_default(a4, b) {
+function value_default(a7, b) {
     var t = typeof b,
-        c6;
-    return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c6 = color(b)) ? (b = c6, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a4, b);
+        c11;
+    return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c11 = color(b)) ? (b = c11, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a7, b);
 }
 
 // node_modules/d3-interpolate/src/discrete.js
-function discrete_default(range5) {
-    var n = range5.length;
+function discrete_default(range9) {
+    var n = range9.length;
     return function(t) {
-        return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
+        return range9[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
     };
 }
 
 // node_modules/d3-interpolate/src/hue.js
-function hue_default(a4, b) {
-    var i = hue(+a4, +b);
+function hue_default(a7, b) {
+    var i = hue(+a7, +b);
     return function(t) {
-        var x4 = i(t);
-        return x4 - 360 * Math.floor(x4 / 360);
+        var x7 = i(t);
+        return x7 - 360 * Math.floor(x7 / 360);
     };
 }
 
 // node_modules/d3-interpolate/src/round.js
-function round_default(a4, b) {
-    return a4 = +a4, b = +b,
+function round_default(a7, b) {
+    return a7 = +a7, b = +b,
         function(t) {
-            return Math.round(a4 * (1 - t) + b * t);
+            return Math.round(a7 * (1 - t) + b * t);
         };
 }
 
 // node_modules/d3-interpolate/src/transform/decompose.js
 var degrees2 = 180 / Math.PI;
 var identity2 = {
     translateX: 0,
     translateY: 0,
     rotate: 0,
     skewX: 0,
     scaleX: 1,
     scaleY: 1
 };
 
-function decompose_default(a4, b, c6, d, e, f) {
+function decompose_default(a7, b, c11, d, e, f) {
     var scaleX, scaleY, skewX;
-    if (scaleX = Math.sqrt(a4 * a4 + b * b))
-        a4 /= scaleX, b /= scaleX;
-    if (skewX = a4 * c6 + b * d)
-        c6 -= a4 * skewX, d -= b * skewX;
-    if (scaleY = Math.sqrt(c6 * c6 + d * d))
-        c6 /= scaleY, d /= scaleY, skewX /= scaleY;
-    if (a4 * d < b * c6)
-        a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;
+    if (scaleX = Math.sqrt(a7 * a7 + b * b))
+        a7 /= scaleX, b /= scaleX;
+    if (skewX = a7 * c11 + b * d)
+        c11 -= a7 * skewX, d -= b * skewX;
+    if (scaleY = Math.sqrt(c11 * c11 + d * d))
+        c11 /= scaleY, d /= scaleY, skewX /= scaleY;
+    if (a7 * d < b * c11)
+        a7 = -a7, b = -b, skewX = -skewX, scaleX = -scaleX;
     return {
         translateX: e,
         translateY: f,
-        rotate: Math.atan2(b, a4) * degrees2,
+        rotate: Math.atan2(b, a7) * degrees2,
         skewX: Math.atan(skewX) * degrees2,
         scaleX,
         scaleY
     };
 }
 
 // node_modules/d3-interpolate/src/transform/parse.js
 var svgNode;
 
 function parseCss(value) {
-    const m3 = new(typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
-    return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
+    const m5 = new(typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
+    return m5.isIdentity ? identity2 : decompose_default(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f);
 }
 
 function parseSvg(value) {
     if (value == null)
         return identity2;
     if (!svgNode)
         svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
@@ -5232,115 +5713,115 @@
     if (!(value = svgNode.transform.baseVal.consolidate()))
         return identity2;
     value = value.matrix;
     return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
 }
 
 // node_modules/d3-interpolate/src/transform/index.js
-function interpolateTransform(parse2, pxComma, pxParen, degParen) {
-    function pop(s2) {
-        return s2.length ? s2.pop() + " " : "";
+function interpolateTransform(parse3, pxComma, pxParen, degParen) {
+    function pop(s3) {
+        return s3.length ? s3.pop() + " " : "";
     }
 
-    function translate(xa, ya, xb, yb, s2, q) {
+    function translate(xa, ya, xb, yb, s3, q) {
         if (xa !== xb || ya !== yb) {
-            var i = s2.push("translate(", null, pxComma, null, pxParen);
+            var i = s3.push("translate(", null, pxComma, null, pxParen);
             q.push({
                 i: i - 4,
                 x: number_default(xa, xb)
             }, {
                 i: i - 2,
                 x: number_default(ya, yb)
             });
         } else if (xb || yb) {
-            s2.push("translate(" + xb + pxComma + yb + pxParen);
+            s3.push("translate(" + xb + pxComma + yb + pxParen);
         }
     }
 
-    function rotate(a4, b, s2, q) {
-        if (a4 !== b) {
-            if (a4 - b > 180)
+    function rotate(a7, b, s3, q) {
+        if (a7 !== b) {
+            if (a7 - b > 180)
                 b += 360;
-            else if (b - a4 > 180)
-                a4 += 360;
+            else if (b - a7 > 180)
+                a7 += 360;
             q.push({
-                i: s2.push(pop(s2) + "rotate(", null, degParen) - 2,
-                x: number_default(a4, b)
+                i: s3.push(pop(s3) + "rotate(", null, degParen) - 2,
+                x: number_default(a7, b)
             });
         } else if (b) {
-            s2.push(pop(s2) + "rotate(" + b + degParen);
+            s3.push(pop(s3) + "rotate(" + b + degParen);
         }
     }
 
-    function skewX(a4, b, s2, q) {
-        if (a4 !== b) {
+    function skewX(a7, b, s3, q) {
+        if (a7 !== b) {
             q.push({
-                i: s2.push(pop(s2) + "skewX(", null, degParen) - 2,
-                x: number_default(a4, b)
+                i: s3.push(pop(s3) + "skewX(", null, degParen) - 2,
+                x: number_default(a7, b)
             });
         } else if (b) {
-            s2.push(pop(s2) + "skewX(" + b + degParen);
+            s3.push(pop(s3) + "skewX(" + b + degParen);
         }
     }
 
-    function scale3(xa, ya, xb, yb, s2, q) {
+    function scale5(xa, ya, xb, yb, s3, q) {
         if (xa !== xb || ya !== yb) {
-            var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
+            var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
             q.push({
                 i: i - 4,
                 x: number_default(xa, xb)
             }, {
                 i: i - 2,
                 x: number_default(ya, yb)
             });
         } else if (xb !== 1 || yb !== 1) {
-            s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
+            s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
         }
     }
-    return function(a4, b) {
-        var s2 = [],
+    return function(a7, b) {
+        var s3 = [],
             q = [];
-        a4 = parse2(a4), b = parse2(b);
-        translate(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);
-        rotate(a4.rotate, b.rotate, s2, q);
-        skewX(a4.skewX, b.skewX, s2, q);
-        scale3(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);
-        a4 = b = null;
+        a7 = parse3(a7), b = parse3(b);
+        translate(a7.translateX, a7.translateY, b.translateX, b.translateY, s3, q);
+        rotate(a7.rotate, b.rotate, s3, q);
+        skewX(a7.skewX, b.skewX, s3, q);
+        scale5(a7.scaleX, a7.scaleY, b.scaleX, b.scaleY, s3, q);
+        a7 = b = null;
         return function(t) {
             var i = -1,
                 n = q.length,
                 o;
             while (++i < n)
-                s2[(o = q[i]).i] = o.x(t);
-            return s2.join("");
+                s3[(o = q[i]).i] = o.x(t);
+            return s3.join("");
         };
     };
 }
 var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
 var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
 
 // node_modules/d3-interpolate/src/zoom.js
 var epsilon2 = 1e-12;
 
-function cosh(x4) {
-    return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
+function cosh(x7) {
+    return ((x7 = Math.exp(x7)) + 1 / x7) / 2;
 }
 
-function sinh(x4) {
-    return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
+function sinh(x7) {
+    return ((x7 = Math.exp(x7)) - 1 / x7) / 2;
 }
 
-function tanh(x4) {
-    return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
+function tanh(x7) {
+    return ((x7 = Math.exp(2 * x7)) - 1) / (x7 + 1);
 }
 var zoom_default = function zoomRho(rho, rho2, rho4) {
-    function zoom(p02, p1) {
-        var ux0 = p02[0],
-            uy0 = p02[1],
-            w0 = p02[2],
+    function zoom(p03, p1) {
+        var ux0 = p03[0],
+            uy0 = p03[1],
+            w0 = p03[2],
             ux1 = p1[0],
             uy1 = p1[1],
             w1 = p1[2],
             dx = ux1 - ux0,
             dy = uy1 - uy0,
             d2 = dx * dx + dy * dy,
             i, S;
@@ -5351,27 +5832,27 @@
                     ux0 + t * dx,
                     uy0 + t * dy,
                     w0 * Math.exp(rho * t * S)
                 ];
             };
         } else {
             var d1 = Math.sqrt(d2),
-                b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
-                b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
-                r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02),
-                r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
+                b03 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
+                b13 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
+                r0 = Math.log(Math.sqrt(b03 * b03 + 1) - b03),
+                r1 = Math.log(Math.sqrt(b13 * b13 + 1) - b13);
             S = (r1 - r0) / rho;
             i = function(t) {
-                var s2 = t * S,
+                var s3 = t * S,
                     coshr0 = cosh(r0),
-                    u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
+                    u7 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
                 return [
-                    ux0 + u4 * dx,
-                    uy0 + u4 * dy,
-                    w0 * coshr0 / cosh(rho * s2 + r0)
+                    ux0 + u7 * dx,
+                    uy0 + u7 * dy,
+                    w0 * coshr0 / cosh(rho * s3 + r0)
                 ];
             };
         }
         i.duration = S * 1e3 * rho / Math.SQRT2;
         return i;
     }
     zoom.rho = function(_) {
@@ -5380,101 +5861,101 @@
             _4 = _2 * _2;
         return zoomRho(_1, _2, _4);
     };
     return zoom;
 }(Math.SQRT2, 2, 4);
 
 // node_modules/d3-interpolate/src/hsl.js
-function hsl2(hue2) {
-    return function(start2, end) {
-        var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h),
-            s2 = nogamma(start2.s, end.s),
-            l = nogamma(start2.l, end.l),
-            opacity2 = nogamma(start2.opacity, end.opacity);
+function hsl2(hue3) {
+    return function(start3, end) {
+        var h = hue3((start3 = hsl(start3)).h, (end = hsl(end)).h),
+            s3 = nogamma(start3.s, end.s),
+            l = nogamma(start3.l, end.l),
+            opacity3 = nogamma(start3.opacity, end.opacity);
         return function(t) {
-            start2.h = h(t);
-            start2.s = s2(t);
-            start2.l = l(t);
-            start2.opacity = opacity2(t);
-            return start2 + "";
+            start3.h = h(t);
+            start3.s = s3(t);
+            start3.l = l(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
         };
     };
 }
 var hsl_default = hsl2(hue);
 var hslLong = hsl2(nogamma);
 
 // node_modules/d3-interpolate/src/lab.js
-function lab2(start2, end) {
-    var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l),
-        a4 = nogamma(start2.a, end.a),
-        b = nogamma(start2.b, end.b),
-        opacity2 = nogamma(start2.opacity, end.opacity);
+function lab2(start3, end) {
+    var l = nogamma((start3 = lab(start3)).l, (end = lab(end)).l),
+        a7 = nogamma(start3.a, end.a),
+        b = nogamma(start3.b, end.b),
+        opacity3 = nogamma(start3.opacity, end.opacity);
     return function(t) {
-        start2.l = l(t);
-        start2.a = a4(t);
-        start2.b = b(t);
-        start2.opacity = opacity2(t);
-        return start2 + "";
+        start3.l = l(t);
+        start3.a = a7(t);
+        start3.b = b(t);
+        start3.opacity = opacity3(t);
+        return start3 + "";
     };
 }
 
 // node_modules/d3-interpolate/src/hcl.js
-function hcl2(hue2) {
-    return function(start2, end) {
-        var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h),
-            c6 = nogamma(start2.c, end.c),
-            l = nogamma(start2.l, end.l),
-            opacity2 = nogamma(start2.opacity, end.opacity);
+function hcl2(hue3) {
+    return function(start3, end) {
+        var h = hue3((start3 = hcl(start3)).h, (end = hcl(end)).h),
+            c11 = nogamma(start3.c, end.c),
+            l = nogamma(start3.l, end.l),
+            opacity3 = nogamma(start3.opacity, end.opacity);
         return function(t) {
-            start2.h = h(t);
-            start2.c = c6(t);
-            start2.l = l(t);
-            start2.opacity = opacity2(t);
-            return start2 + "";
+            start3.h = h(t);
+            start3.c = c11(t);
+            start3.l = l(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
         };
     };
 }
 var hcl_default = hcl2(hue);
 var hclLong = hcl2(nogamma);
 
 // node_modules/d3-interpolate/src/cubehelix.js
-function cubehelix2(hue2) {
-    return function cubehelixGamma(y4) {
-        y4 = +y4;
-
-        function cubehelix3(start2, end) {
-            var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h),
-                s2 = nogamma(start2.s, end.s),
-                l = nogamma(start2.l, end.l),
-                opacity2 = nogamma(start2.opacity, end.opacity);
+function cubehelix2(hue3) {
+    return function cubehelixGamma(y7) {
+        y7 = +y7;
+
+        function cubehelix5(start3, end) {
+            var h = hue3((start3 = cubehelix(start3)).h, (end = cubehelix(end)).h),
+                s3 = nogamma(start3.s, end.s),
+                l = nogamma(start3.l, end.l),
+                opacity3 = nogamma(start3.opacity, end.opacity);
             return function(t) {
-                start2.h = h(t);
-                start2.s = s2(t);
-                start2.l = l(Math.pow(t, y4));
-                start2.opacity = opacity2(t);
-                return start2 + "";
+                start3.h = h(t);
+                start3.s = s3(t);
+                start3.l = l(Math.pow(t, y7));
+                start3.opacity = opacity3(t);
+                return start3 + "";
             };
         }
-        cubehelix3.gamma = cubehelixGamma;
-        return cubehelix3;
+        cubehelix5.gamma = cubehelixGamma;
+        return cubehelix5;
     }(1);
 }
 var cubehelix_default = cubehelix2(hue);
 var cubehelixLong = cubehelix2(nogamma);
 
 // node_modules/d3-interpolate/src/piecewise.js
-function piecewise(interpolate, values2) {
-    if (values2 === void 0)
-        values2 = interpolate, interpolate = value_default;
+function piecewise(interpolate, values3) {
+    if (values3 === void 0)
+        values3 = interpolate, interpolate = value_default;
     var i = 0,
-        n = values2.length - 1,
-        v2 = values2[0],
+        n = values3.length - 1,
+        v3 = values3[0],
         I = new Array(n < 0 ? 0 : n);
     while (i < n)
-        I[i] = interpolate(v2, v2 = values2[++i]);
+        I[i] = interpolate(v3, v3 = values3[++i]);
     return function(t) {
         var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
         return I[i2](t - i2);
     };
 }
 
 // node_modules/d3-interpolate/src/quantize.js
@@ -5509,41 +5990,41 @@
 }
 
 function Timer() {
     this._call = this._time = this._next = null;
 }
 Timer.prototype = timer.prototype = {
     constructor: Timer,
-    restart: function(callback, delay, time2) {
+    restart: function(callback, delay, time3) {
         if (typeof callback !== "function")
             throw new TypeError("callback is not a function");
-        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
+        time3 = (time3 == null ? now() : +time3) + (delay == null ? 0 : +delay);
         if (!this._next && taskTail !== this) {
             if (taskTail)
                 taskTail._next = this;
             else
                 taskHead = this;
             taskTail = this;
         }
         this._call = callback;
-        this._time = time2;
+        this._time = time3;
         sleep();
     },
     stop: function() {
         if (this._call) {
             this._call = null;
             this._time = Infinity;
             sleep();
         }
     }
 };
 
-function timer(callback, delay, time2) {
+function timer(callback, delay, time3) {
     var t = new Timer();
-    t.restart(callback, delay, time2);
+    t.restart(callback, delay, time3);
     return t;
 }
 
 function timerFlush() {
     now();
     ++frame;
     var t = taskHead,
@@ -5565,169 +6046,169 @@
         frame = 0;
         nap();
         clockNow = 0;
     }
 }
 
 function poke() {
-    var now2 = clock.now(),
-        delay = now2 - clockLast;
+    var now3 = clock.now(),
+        delay = now3 - clockLast;
     if (delay > pokeDelay)
-        clockSkew -= delay, clockLast = now2;
+        clockSkew -= delay, clockLast = now3;
 }
 
 function nap() {
-    var t03, t13 = taskHead,
-        t22, time2 = Infinity;
-    while (t13) {
-        if (t13._call) {
-            if (time2 > t13._time)
-                time2 = t13._time;
-            t03 = t13, t13 = t13._next;
+    var t05, t15 = taskHead,
+        t23, time3 = Infinity;
+    while (t15) {
+        if (t15._call) {
+            if (time3 > t15._time)
+                time3 = t15._time;
+            t05 = t15, t15 = t15._next;
         } else {
-            t22 = t13._next, t13._next = null;
-            t13 = t03 ? t03._next = t22 : taskHead = t22;
+            t23 = t15._next, t15._next = null;
+            t15 = t05 ? t05._next = t23 : taskHead = t23;
         }
     }
-    taskTail = t03;
-    sleep(time2);
+    taskTail = t05;
+    sleep(time3);
 }
 
-function sleep(time2) {
+function sleep(time3) {
     if (frame)
         return;
     if (timeout)
         timeout = clearTimeout(timeout);
-    var delay = time2 - clockNow;
+    var delay = time3 - clockNow;
     if (delay > 24) {
-        if (time2 < Infinity)
-            timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
+        if (time3 < Infinity)
+            timeout = setTimeout(wake, time3 - clock.now() - clockSkew);
         if (interval)
             interval = clearInterval(interval);
     } else {
         if (!interval)
             clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
         frame = 1, setFrame(wake);
     }
 }
 
 // node_modules/d3-timer/src/timeout.js
-function timeout_default(callback, delay, time2) {
+function timeout_default(callback, delay, time3) {
     var t = new Timer();
     delay = delay == null ? 0 : +delay;
     t.restart((elapsed) => {
         t.stop();
         callback(elapsed + delay);
-    }, delay, time2);
+    }, delay, time3);
     return t;
 }
 
 // node_modules/d3-timer/src/interval.js
-function interval_default(callback, delay, time2) {
+function interval_default(callback, delay, time3) {
     var t = new Timer(),
         total = delay;
     if (delay == null)
-        return t.restart(callback, delay, time2), t;
+        return t.restart(callback, delay, time3), t;
     t._restart = t.restart;
-    t.restart = function(callback2, delay2, time3) {
-        delay2 = +delay2, time3 = time3 == null ? now() : +time3;
+    t.restart = function(callback2, delay2, time4) {
+        delay2 = +delay2, time4 = time4 == null ? now() : +time4;
         t._restart(function tick(elapsed) {
             elapsed += total;
-            t._restart(tick, total += delay2, time3);
+            t._restart(tick, total += delay2, time4);
             callback2(elapsed);
-        }, delay2, time3);
+        }, delay2, time4);
     };
-    t.restart(callback, delay, time2);
+    t.restart(callback, delay, time3);
     return t;
 }
 
 // node_modules/d3-transition/src/transition/schedule.js
 var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
 var emptyTween = [];
 var CREATED = 0;
 var SCHEDULED = 1;
 var STARTING = 2;
 var STARTED = 3;
 var RUNNING = 4;
 var ENDING = 5;
 var ENDED = 6;
 
-function schedule_default(node, name, id2, index3, group3, timing) {
+function schedule_default(node, name, id3, index5, group5, timing) {
     var schedules = node.__transition;
     if (!schedules)
         node.__transition = {};
-    else if (id2 in schedules)
+    else if (id3 in schedules)
         return;
-    create(node, id2, {
+    create(node, id3, {
         name,
-        index: index3,
+        index: index5,
         // For context during callback.
-        group: group3,
+        group: group5,
         // For context during callback.
         on: emptyOn,
         tween: emptyTween,
         time: timing.time,
         delay: timing.delay,
         duration: timing.duration,
         ease: timing.ease,
         timer: null,
         state: CREATED
     });
 }
 
-function init(node, id2) {
-    var schedule = get2(node, id2);
+function init(node, id3) {
+    var schedule = get2(node, id3);
     if (schedule.state > CREATED)
         throw new Error("too late; already scheduled");
     return schedule;
 }
 
-function set3(node, id2) {
-    var schedule = get2(node, id2);
+function set3(node, id3) {
+    var schedule = get2(node, id3);
     if (schedule.state > STARTED)
         throw new Error("too late; already running");
     return schedule;
 }
 
-function get2(node, id2) {
+function get2(node, id3) {
     var schedule = node.__transition;
-    if (!schedule || !(schedule = schedule[id2]))
+    if (!schedule || !(schedule = schedule[id3]))
         throw new Error("transition not found");
     return schedule;
 }
 
-function create(node, id2, self) {
+function create(node, id3, self) {
     var schedules = node.__transition,
         tween;
-    schedules[id2] = self;
+    schedules[id3] = self;
     self.timer = timer(schedule, 0, self.time);
 
     function schedule(elapsed) {
         self.state = SCHEDULED;
-        self.timer.restart(start2, self.delay, self.time);
+        self.timer.restart(start3, self.delay, self.time);
         if (self.delay <= elapsed)
-            start2(elapsed - self.delay);
+            start3(elapsed - self.delay);
     }
 
-    function start2(elapsed) {
+    function start3(elapsed) {
         var i, j, n, o;
         if (self.state !== SCHEDULED)
             return stop();
         for (i in schedules) {
             o = schedules[i];
             if (o.name !== self.name)
                 continue;
             if (o.state === STARTED)
-                return timeout_default(start2);
+                return timeout_default(start3);
             if (o.state === RUNNING) {
                 o.state = ENDED;
                 o.timer.stop();
                 o.on.call("interrupt", node, node.__data__, o.index, o.group);
                 delete schedules[i];
-            } else if (+i < id2) {
+            } else if (+i < id3) {
                 o.state = ENDED;
                 o.timer.stop();
                 o.on.call("cancel", node, node.__data__, o.index, o.group);
                 delete schedules[i];
             }
         }
         timeout_default(function() {
@@ -5763,56 +6244,56 @@
             stop();
         }
     }
 
     function stop() {
         self.state = ENDED;
         self.timer.stop();
-        delete schedules[id2];
+        delete schedules[id3];
         for (var i in schedules)
             return;
         delete node.__transition;
     }
 }
 
 // node_modules/d3-transition/src/interrupt.js
 function interrupt_default(node, name) {
     var schedules = node.__transition,
-        schedule, active, empty4 = true,
+        schedule, active, empty7 = true,
         i;
     if (!schedules)
         return;
     name = name == null ? null : name + "";
     for (i in schedules) {
         if ((schedule = schedules[i]).name !== name) {
-            empty4 = false;
+            empty7 = false;
             continue;
         }
         active = schedule.state > STARTING && schedule.state < ENDING;
         schedule.state = ENDED;
         schedule.timer.stop();
         schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
         delete schedules[i];
     }
-    if (empty4)
+    if (empty7)
         delete node.__transition;
 }
 
 // node_modules/d3-transition/src/selection/interrupt.js
 function interrupt_default2(name) {
     return this.each(function() {
         interrupt_default(this, name);
     });
 }
 
 // node_modules/d3-transition/src/transition/tween.js
-function tweenRemove(id2, name) {
+function tweenRemove(id3, name) {
     var tween0, tween1;
     return function() {
-        var schedule = set3(this, id2),
+        var schedule = set3(this, id3),
             tween = schedule.tween;
         if (tween !== tween0) {
             tween1 = tween0 = tween;
             for (var i = 0, n = tween1.length; i < n; ++i) {
                 if (tween1[i].name === name) {
                     tween1 = tween1.slice();
                     tween1.splice(i, 1);
@@ -5820,20 +6301,20 @@
                 }
             }
         }
         schedule.tween = tween1;
     };
 }
 
-function tweenFunction(id2, name, value) {
+function tweenFunction(id3, name, value) {
     var tween0, tween1;
     if (typeof value !== "function")
         throw new Error();
     return function() {
-        var schedule = set3(this, id2),
+        var schedule = set3(this, id3),
             tween = schedule.tween;
         if (tween !== tween0) {
             tween1 = (tween0 = tween).slice();
             for (var t = {
                     name,
                     value
                 }, i = 0, n = tween1.length; i < n; ++i) {
@@ -5846,43 +6327,43 @@
                 tween1.push(t);
         }
         schedule.tween = tween1;
     };
 }
 
 function tween_default(name, value) {
-    var id2 = this._id;
+    var id3 = this._id;
     name += "";
     if (arguments.length < 2) {
-        var tween = get2(this.node(), id2).tween;
+        var tween = get2(this.node(), id3).tween;
         for (var i = 0, n = tween.length, t; i < n; ++i) {
             if ((t = tween[i]).name === name) {
                 return t.value;
             }
         }
         return null;
     }
-    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
+    return this.each((value == null ? tweenRemove : tweenFunction)(id3, name, value));
 }
 
-function tweenValue(transition2, name, value) {
-    var id2 = transition2._id;
-    transition2.each(function() {
-        var schedule = set3(this, id2);
+function tweenValue(transition3, name, value) {
+    var id3 = transition3._id;
+    transition3.each(function() {
+        var schedule = set3(this, id3);
         (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
     });
     return function(node) {
-        return get2(node, id2).value[name];
+        return get2(node, id3).value[name];
     };
 }
 
 // node_modules/d3-transition/src/transition/interpolate.js
-function interpolate_default(a4, b) {
-    var c6;
-    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c6 = color(b)) ? (b = c6, rgb_default) : string_default)(a4, b);
+function interpolate_default(a7, b) {
+    var c11;
+    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c11 = color(b)) ? (b = c11, rgb_default) : string_default)(a7, b);
 }
 
 // node_modules/d3-transition/src/transition/attr.js
 function attrRemove2(name) {
     return function() {
         this.removeAttribute(name);
     };
@@ -5954,34 +6435,34 @@
 function attrInterpolateNS(fullname, i) {
     return function(t) {
         this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
     };
 }
 
 function attrTweenNS(fullname, value) {
-    var t03, i0;
+    var t05, i0;
 
     function tween() {
         var i = value.apply(this, arguments);
         if (i !== i0)
-            t03 = (i0 = i) && attrInterpolateNS(fullname, i);
-        return t03;
+            t05 = (i0 = i) && attrInterpolateNS(fullname, i);
+        return t05;
     }
     tween._value = value;
     return tween;
 }
 
 function attrTween(name, value) {
-    var t03, i0;
+    var t05, i0;
 
     function tween() {
         var i = value.apply(this, arguments);
         if (i !== i0)
-            t03 = (i0 = i) && attrInterpolate(name, i);
-        return t03;
+            t05 = (i0 = i) && attrInterpolate(name, i);
+        return t05;
     }
     tween._value = value;
     return tween;
 }
 
 function attrTween_default(name, value) {
     var key = "attr." + name;
@@ -5992,103 +6473,103 @@
     if (typeof value !== "function")
         throw new Error();
     var fullname = namespace_default(name);
     return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
 }
 
 // node_modules/d3-transition/src/transition/delay.js
-function delayFunction(id2, value) {
+function delayFunction(id3, value) {
     return function() {
-        init(this, id2).delay = +value.apply(this, arguments);
+        init(this, id3).delay = +value.apply(this, arguments);
     };
 }
 
-function delayConstant(id2, value) {
+function delayConstant(id3, value) {
     return value = +value,
         function() {
-            init(this, id2).delay = value;
+            init(this, id3).delay = value;
         };
 }
 
 function delay_default(value) {
-    var id2 = this._id;
-    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
+    var id3 = this._id;
+    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id3, value)) : get2(this.node(), id3).delay;
 }
 
 // node_modules/d3-transition/src/transition/duration.js
-function durationFunction(id2, value) {
+function durationFunction(id3, value) {
     return function() {
-        set3(this, id2).duration = +value.apply(this, arguments);
+        set3(this, id3).duration = +value.apply(this, arguments);
     };
 }
 
-function durationConstant(id2, value) {
+function durationConstant(id3, value) {
     return value = +value,
         function() {
-            set3(this, id2).duration = value;
+            set3(this, id3).duration = value;
         };
 }
 
 function duration_default(value) {
-    var id2 = this._id;
-    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
+    var id3 = this._id;
+    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id3, value)) : get2(this.node(), id3).duration;
 }
 
 // node_modules/d3-transition/src/transition/ease.js
-function easeConstant(id2, value) {
+function easeConstant(id3, value) {
     if (typeof value !== "function")
         throw new Error();
     return function() {
-        set3(this, id2).ease = value;
+        set3(this, id3).ease = value;
     };
 }
 
 function ease_default(value) {
-    var id2 = this._id;
-    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
+    var id3 = this._id;
+    return arguments.length ? this.each(easeConstant(id3, value)) : get2(this.node(), id3).ease;
 }
 
 // node_modules/d3-transition/src/transition/easeVarying.js
-function easeVarying(id2, value) {
+function easeVarying(id3, value) {
     return function() {
-        var v2 = value.apply(this, arguments);
-        if (typeof v2 !== "function")
+        var v3 = value.apply(this, arguments);
+        if (typeof v3 !== "function")
             throw new Error();
-        set3(this, id2).ease = v2;
+        set3(this, id3).ease = v3;
     };
 }
 
 function easeVarying_default(value) {
     if (typeof value !== "function")
         throw new Error();
     return this.each(easeVarying(this._id, value));
 }
 
 // node_modules/d3-transition/src/transition/filter.js
 function filter_default2(match) {
     if (typeof match !== "function")
         match = matcher_default(match);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
-            if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && match.call(node, node.__data__, i, group5)) {
                 subgroup.push(node);
             }
         }
     }
     return new Transition(subgroups, this._parents, this._name, this._id);
 }
 
 // node_modules/d3-transition/src/transition/merge.js
-function merge_default2(transition2) {
-    if (transition2._id !== this._id)
+function merge_default2(transition3) {
+    if (transition3._id !== this._id)
         throw new Error();
-    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
-        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+    for (var groups0 = this._groups, groups1 = transition3._groups, m0 = groups0.length, m1 = groups1.length, m5 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m5; ++j) {
+        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
             if (node = group0[i] || group1[i]) {
-                merge2[i] = node;
+                merge3[i] = node;
             }
         }
     }
     for (; j < m0; ++j) {
         merges[j] = groups0[j];
     }
     return new Transition(merges, this._parents, this._name, this._id);
@@ -6100,85 +6581,85 @@
         var i = t.indexOf(".");
         if (i >= 0)
             t = t.slice(0, i);
         return !t || t === "start";
     });
 }
 
-function onFunction(id2, name, listener) {
+function onFunction(id3, name, listener) {
     var on0, on1, sit = start(name) ? init : set3;
     return function() {
-        var schedule = sit(this, id2),
+        var schedule = sit(this, id3),
             on = schedule.on;
         if (on !== on0)
             (on1 = (on0 = on).copy()).on(name, listener);
         schedule.on = on1;
     };
 }
 
 function on_default2(name, listener) {
-    var id2 = this._id;
-    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
+    var id3 = this._id;
+    return arguments.length < 2 ? get2(this.node(), id3).on.on(name) : this.each(onFunction(id3, name, listener));
 }
 
 // node_modules/d3-transition/src/transition/remove.js
-function removeFunction(id2) {
+function removeFunction(id3) {
     return function() {
         var parent = this.parentNode;
         for (var i in this.__transition)
-            if (+i !== id2)
+            if (+i !== id3)
                 return;
         if (parent)
             parent.removeChild(this);
     };
 }
 
 function remove_default2() {
     return this.on("end.remove", removeFunction(this._id));
 }
 
 // node_modules/d3-transition/src/transition/select.js
-function select_default3(select2) {
+function select_default3(select3) {
     var name = this._name,
-        id2 = this._id;
-    if (typeof select2 !== "function")
-        select2 = selector_default(select2);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
-            if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
+        id3 = this._id;
+    if (typeof select3 !== "function")
+        select3 = selector_default(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && (subnode = select3.call(node, node.__data__, i, group5))) {
                 if ("__data__" in node)
                     subnode.__data__ = node.__data__;
                 subgroup[i] = subnode;
-                schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
+                schedule_default(subgroup[i], name, id3, i, subgroup, get2(node, id3));
             }
         }
     }
-    return new Transition(subgroups, this._parents, name, id2);
+    return new Transition(subgroups, this._parents, name, id3);
 }
 
 // node_modules/d3-transition/src/transition/selectAll.js
-function selectAll_default3(select2) {
+function selectAll_default3(select3) {
     var name = this._name,
-        id2 = this._id;
-    if (typeof select2 !== "function")
-        select2 = selectorAll_default(select2);
-    for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
-            if (node = group3[i]) {
-                for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
-                    if (child = children2[k2]) {
-                        schedule_default(child, name, id2, k2, children2, inherit3);
+        id3 = this._id;
+    if (typeof select3 !== "function")
+        select3 = selectorAll_default(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = [], parents = [], j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                for (var children3 = select3.call(node, node.__data__, i, group5), child, inherit5 = get2(node, id3), k3 = 0, l = children3.length; k3 < l; ++k3) {
+                    if (child = children3[k3]) {
+                        schedule_default(child, name, id3, k3, children3, inherit5);
                     }
                 }
-                subgroups.push(children2);
+                subgroups.push(children3);
                 parents.push(node);
             }
         }
     }
-    return new Transition(subgroups, parents, name, id2);
+    return new Transition(subgroups, parents, name, id3);
 }
 
 // node_modules/d3-transition/src/transition/selection.js
 var Selection2 = selection_default.prototype.constructor;
 
 function selection_default2() {
     return new Selection2(this._groups, this._parents);
@@ -6217,22 +6698,22 @@
             string1 = value1 + "";
         if (value1 == null)
             string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
         return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
     };
 }
 
-function styleMaybeRemove(id2, name) {
+function styleMaybeRemove(id3, name) {
     var on0, on1, listener0, key = "style." + name,
         event = "end." + key,
-        remove2;
+        remove3;
     return function() {
-        var schedule = set3(this, id2),
+        var schedule = set3(this, id3),
             on = schedule.on,
-            listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
+            listener = schedule.value[key] == null ? remove3 || (remove3 = styleRemove2(name)) : void 0;
         if (on !== on0 || listener0 !== listener)
             (on1 = (on0 = on).copy()).on(event, listener0 = listener);
         schedule.on = on1;
     };
 }
 
 function style_default2(name, value, priority) {
@@ -6293,21 +6774,21 @@
 function textInterpolate(i) {
     return function(t) {
         this.textContent = i.call(this, t);
     };
 }
 
 function textTween(value) {
-    var t03, i0;
+    var t05, i0;
 
     function tween() {
         var i = value.apply(this, arguments);
         if (i !== i0)
-            t03 = (i0 = i) && textInterpolate(i);
-        return t03;
+            t05 = (i0 = i) && textInterpolate(i);
+        return t05;
     }
     tween._value = value;
     return tween;
 }
 
 function textTween_default(value) {
     var key = "text";
@@ -6321,47 +6802,47 @@
 }
 
 // node_modules/d3-transition/src/transition/transition.js
 function transition_default() {
     var name = this._name,
         id0 = this._id,
         id1 = newId();
-    for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
-            if (node = group3[i]) {
-                var inherit3 = get2(node, id0);
-                schedule_default(node, name, id1, i, group3, {
-                    time: inherit3.time + inherit3.delay + inherit3.duration,
+    for (var groups3 = this._groups, m5 = groups3.length, j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                var inherit5 = get2(node, id0);
+                schedule_default(node, name, id1, i, group5, {
+                    time: inherit5.time + inherit5.delay + inherit5.duration,
                     delay: 0,
-                    duration: inherit3.duration,
-                    ease: inherit3.ease
+                    duration: inherit5.duration,
+                    ease: inherit5.ease
                 });
             }
         }
     }
-    return new Transition(groups2, this._parents, name, id1);
+    return new Transition(groups3, this._parents, name, id1);
 }
 
 // node_modules/d3-transition/src/transition/end.js
 function end_default() {
     var on0, on1, that = this,
-        id2 = that._id,
+        id3 = that._id,
         size = that.size();
     return new Promise(function(resolve, reject) {
         var cancel = {
                 value: reject
             },
             end = {
                 value: function() {
                     if (--size === 0)
                         resolve();
                 }
             };
         that.each(function() {
-            var schedule = set3(this, id2),
+            var schedule = set3(this, id3),
                 on = schedule.on;
             if (on !== on0) {
                 on1 = (on0 = on).copy();
                 on1._.cancel.push(cancel);
                 on1._.interrupt.push(cancel);
                 on1._.end.push(end);
             }
@@ -6371,19 +6852,19 @@
             resolve();
     });
 }
 
 // node_modules/d3-transition/src/transition/index.js
 var id = 0;
 
-function Transition(groups2, parents, name, id2) {
-    this._groups = groups2;
+function Transition(groups3, parents, name, id3) {
+    this._groups = groups3;
     this._parents = parents;
     this._name = name;
-    this._id = id2;
+    this._id = id3;
 }
 
 function transition(name) {
     return selection_default().transition(name);
 }
 
 function newId() {
@@ -6453,37 +6934,37 @@
 }
 
 // node_modules/d3-ease/src/poly.js
 var exponent = 3;
 var polyIn = function custom(e) {
     e = +e;
 
-    function polyIn2(t) {
+    function polyIn3(t) {
         return Math.pow(t, e);
     }
-    polyIn2.exponent = custom;
-    return polyIn2;
+    polyIn3.exponent = custom;
+    return polyIn3;
 }(exponent);
 var polyOut = function custom2(e) {
     e = +e;
 
-    function polyOut2(t) {
+    function polyOut3(t) {
         return 1 - Math.pow(1 - t, e);
     }
-    polyOut2.exponent = custom2;
-    return polyOut2;
+    polyOut3.exponent = custom2;
+    return polyOut3;
 }(exponent);
 var polyInOut = function custom3(e) {
     e = +e;
 
-    function polyInOut2(t) {
+    function polyInOut3(t) {
         return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
     }
-    polyInOut2.exponent = custom3;
-    return polyInOut2;
+    polyInOut3.exponent = custom3;
+    return polyInOut3;
 }(exponent);
 
 // node_modules/d3-ease/src/sin.js
 var pi = Math.PI;
 var halfPi = pi / 2;
 
 function sinIn(t) {
@@ -6495,16 +6976,16 @@
 }
 
 function sinInOut(t) {
     return (1 - Math.cos(pi * t)) / 2;
 }
 
 // node_modules/d3-ease/src/math.js
-function tpmt(x4) {
-    return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;
+function tpmt(x7) {
+    return (Math.pow(2, -10 * x7) - 9765625e-10) * 1.0009775171065494;
 }
 
 // node_modules/d3-ease/src/exp.js
 function expIn(t) {
     return tpmt(1 - +t);
 }
 
@@ -6551,123 +7032,123 @@
 
 function bounceInOut(t) {
     return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
 }
 
 // node_modules/d3-ease/src/back.js
 var overshoot = 1.70158;
-var backIn = function custom4(s2) {
-    s2 = +s2;
+var backIn = function custom4(s3) {
+    s3 = +s3;
 
-    function backIn2(t) {
-        return (t = +t) * t * (s2 * (t - 1) + t);
+    function backIn3(t) {
+        return (t = +t) * t * (s3 * (t - 1) + t);
     }
-    backIn2.overshoot = custom4;
-    return backIn2;
+    backIn3.overshoot = custom4;
+    return backIn3;
 }(overshoot);
-var backOut = function custom5(s2) {
-    s2 = +s2;
+var backOut = function custom5(s3) {
+    s3 = +s3;
 
-    function backOut2(t) {
-        return --t * t * ((t + 1) * s2 + t) + 1;
+    function backOut3(t) {
+        return --t * t * ((t + 1) * s3 + t) + 1;
     }
-    backOut2.overshoot = custom5;
-    return backOut2;
+    backOut3.overshoot = custom5;
+    return backOut3;
 }(overshoot);
-var backInOut = function custom6(s2) {
-    s2 = +s2;
+var backInOut = function custom6(s3) {
+    s3 = +s3;
 
-    function backInOut2(t) {
-        return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;
+    function backInOut3(t) {
+        return ((t *= 2) < 1 ? t * t * ((s3 + 1) * t - s3) : (t -= 2) * t * ((s3 + 1) * t + s3) + 2) / 2;
     }
-    backInOut2.overshoot = custom6;
-    return backInOut2;
+    backInOut3.overshoot = custom6;
+    return backInOut3;
 }(overshoot);
 
 // node_modules/d3-ease/src/elastic.js
 var tau = 2 * Math.PI;
 var amplitude = 1;
 var period = 0.3;
-var elasticIn = function custom7(a4, p) {
-    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
+var elasticIn = function custom7(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau);
 
-    function elasticIn2(t) {
-        return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);
+    function elasticIn3(t) {
+        return a7 * tpmt(- --t) * Math.sin((s3 - t) / p);
     }
-    elasticIn2.amplitude = function(a5) {
-        return custom7(a5, p * tau);
+    elasticIn3.amplitude = function(a8) {
+        return custom7(a8, p * tau);
     };
-    elasticIn2.period = function(p2) {
-        return custom7(a4, p2);
+    elasticIn3.period = function(p2) {
+        return custom7(a7, p2);
     };
-    return elasticIn2;
+    return elasticIn3;
 }(amplitude, period);
-var elasticOut = function custom8(a4, p) {
-    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
+var elasticOut = function custom8(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau);
 
-    function elasticOut2(t) {
-        return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);
+    function elasticOut3(t) {
+        return 1 - a7 * tpmt(t = +t) * Math.sin((t + s3) / p);
     }
-    elasticOut2.amplitude = function(a5) {
-        return custom8(a5, p * tau);
+    elasticOut3.amplitude = function(a8) {
+        return custom8(a8, p * tau);
     };
-    elasticOut2.period = function(p2) {
-        return custom8(a4, p2);
+    elasticOut3.period = function(p2) {
+        return custom8(a7, p2);
     };
-    return elasticOut2;
+    return elasticOut3;
 }(amplitude, period);
-var elasticInOut = function custom9(a4, p) {
-    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
+var elasticInOut = function custom9(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau);
 
-    function elasticInOut2(t) {
-        return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;
+    function elasticInOut3(t) {
+        return ((t = t * 2 - 1) < 0 ? a7 * tpmt(-t) * Math.sin((s3 - t) / p) : 2 - a7 * tpmt(t) * Math.sin((s3 + t) / p)) / 2;
     }
-    elasticInOut2.amplitude = function(a5) {
-        return custom9(a5, p * tau);
+    elasticInOut3.amplitude = function(a8) {
+        return custom9(a8, p * tau);
     };
-    elasticInOut2.period = function(p2) {
-        return custom9(a4, p2);
+    elasticInOut3.period = function(p2) {
+        return custom9(a7, p2);
     };
-    return elasticInOut2;
+    return elasticInOut3;
 }(amplitude, period);
 
 // node_modules/d3-transition/src/selection/transition.js
 var defaultTiming = {
     time: null,
     // Set on use.
     delay: 0,
     duration: 250,
     ease: cubicInOut
 };
 
-function inherit(node, id2) {
+function inherit(node, id3) {
     var timing;
-    while (!(timing = node.__transition) || !(timing = timing[id2])) {
+    while (!(timing = node.__transition) || !(timing = timing[id3])) {
         if (!(node = node.parentNode)) {
-            throw new Error(`transition ${id2} not found`);
+            throw new Error(`transition ${id3} not found`);
         }
     }
     return timing;
 }
 
 function transition_default2(name) {
-    var id2, timing;
+    var id3, timing;
     if (name instanceof Transition) {
-        id2 = name._id, name = name._name;
+        id3 = name._id, name = name._name;
     } else {
-        id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
+        id3 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
     }
-    for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
-        for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
-            if (node = group3[i]) {
-                schedule_default(node, name, id2, i, group3, timing || inherit(node, id2));
+    for (var groups3 = this._groups, m5 = groups3.length, j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                schedule_default(node, name, id3, i, group5, timing || inherit(node, id3));
             }
         }
     }
-    return new Transition(groups2, this._parents, name, id2);
+    return new Transition(groups3, this._parents, name, id3);
 }
 
 // node_modules/d3-transition/src/selection/index.js
 selection_default.prototype.interrupt = interrupt_default2;
 selection_default.prototype.transition = transition_default2;
 
 // node_modules/d3-transition/src/active.js
@@ -6686,52 +7167,52 @@
             }
         }
     }
     return null;
 }
 
 // node_modules/d3-brush/src/constant.js
-var constant_default4 = (x4) => () => x4;
+var constant_default4 = (x7) => () => x7;
 
 // node_modules/d3-brush/src/event.js
-function BrushEvent(type2, {
+function BrushEvent(type3, {
     sourceEvent,
     target,
-    selection: selection2,
-    mode: mode2,
-    dispatch: dispatch2
+    selection: selection3,
+    mode: mode3,
+    dispatch: dispatch3
 }) {
     Object.defineProperties(this, {
         type: {
-            value: type2,
+            value: type3,
             enumerable: true,
             configurable: true
         },
         sourceEvent: {
             value: sourceEvent,
             enumerable: true,
             configurable: true
         },
         target: {
             value: target,
             enumerable: true,
             configurable: true
         },
         selection: {
-            value: selection2,
+            value: selection3,
             enumerable: true,
             configurable: true
         },
         mode: {
-            value: mode2,
+            value: mode3,
             enumerable: true,
             configurable: true
         },
         _: {
-            value: dispatch2
+            value: dispatch3
         }
     });
 }
 
 // node_modules/d3-brush/src/noevent.js
 function nopropagation2(event) {
     event.stopImmediatePropagation();
@@ -6767,31 +7248,31 @@
 
 function number22(e) {
     return [number1(e[0]), number1(e[1])];
 }
 var X = {
     name: "x",
     handles: ["w", "e"].map(type),
-    input: function(x4, e) {
-        return x4 == null ? null : [
-            [+x4[0], e[0][1]],
-            [+x4[1], e[1][1]]
+    input: function(x7, e) {
+        return x7 == null ? null : [
+            [+x7[0], e[0][1]],
+            [+x7[1], e[1][1]]
         ];
     },
     output: function(xy) {
         return xy && [xy[0][0], xy[1][0]];
     }
 };
 var Y = {
     name: "y",
     handles: ["n", "s"].map(type),
-    input: function(y4, e) {
-        return y4 == null ? null : [
-            [e[0][0], +y4[0]],
-            [e[1][0], +y4[1]]
+    input: function(y7, e) {
+        return y7 == null ? null : [
+            [e[0][0], +y7[0]],
+            [e[1][0], +y7[1]]
         ];
     },
     output: function(xy) {
         return xy && [xy[0][1], xy[1][1]];
     }
 };
 var XY = {
@@ -6864,41 +7345,41 @@
 }
 
 function defaultFilter2(event) {
     return !event.ctrlKey && !event.button;
 }
 
 function defaultExtent() {
-    var svg2 = this.ownerSVGElement || this;
-    if (svg2.hasAttribute("viewBox")) {
-        svg2 = svg2.viewBox.baseVal;
+    var svg3 = this.ownerSVGElement || this;
+    if (svg3.hasAttribute("viewBox")) {
+        svg3 = svg3.viewBox.baseVal;
         return [
-            [svg2.x, svg2.y],
-            [svg2.x + svg2.width, svg2.y + svg2.height]
+            [svg3.x, svg3.y],
+            [svg3.x + svg3.width, svg3.y + svg3.height]
         ];
     }
     return [
         [0, 0],
-        [svg2.width.baseVal.value, svg2.height.baseVal.value]
+        [svg3.width.baseVal.value, svg3.height.baseVal.value]
     ];
 }
 
 function defaultTouchable2() {
     return navigator.maxTouchPoints || "ontouchstart" in this;
 }
 
 function local2(node) {
     while (!node.__brush)
         if (!(node = node.parentNode))
             return;
     return node.__brush;
 }
 
-function empty3(extent3) {
-    return extent3[0][0] === extent3[1][0] || extent3[0][1] === extent3[1][1];
+function empty3(extent5) {
+    return extent5[0][0] === extent5[1][0] || extent5[0][1] === extent5[1][1];
 }
 
 function brushSelection(node) {
     var state = node.__brush;
     return state ? state.dim.output(state.selection) : null;
 }
 
@@ -6911,95 +7392,95 @@
 }
 
 function brush_default() {
     return brush(XY);
 }
 
 function brush(dim) {
-    var extent3 = defaultExtent,
-        filter4 = defaultFilter2,
+    var extent5 = defaultExtent,
+        filter7 = defaultFilter2,
         touchable = defaultTouchable2,
         keys = true,
         listeners = dispatch_default("start", "brush", "end"),
         handleSize = 6,
         touchending;
 
-    function brush2(group3) {
-        var overlay = group3.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
+    function brush3(group5) {
+        var overlay = group5.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
         overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
-            var extent4 = local2(this).extent;
-            select_default2(this).attr("x", extent4[0][0]).attr("y", extent4[0][1]).attr("width", extent4[1][0] - extent4[0][0]).attr("height", extent4[1][1] - extent4[0][1]);
+            var extent6 = local2(this).extent;
+            select_default2(this).attr("x", extent6[0][0]).attr("y", extent6[0][1]).attr("width", extent6[1][0] - extent6[0][0]).attr("height", extent6[1][1] - extent6[0][1]);
         });
-        group3.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
-        var handle = group3.selectAll(".handle").data(dim.handles, function(d) {
+        group5.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
+        var handle = group5.selectAll(".handle").data(dim.handles, function(d) {
             return d.type;
         });
         handle.exit().remove();
         handle.enter().append("rect").attr("class", function(d) {
             return "handle handle--" + d.type;
         }).attr("cursor", function(d) {
             return cursors[d.type];
         });
-        group3.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+        group5.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
     }
-    brush2.move = function(group3, selection2, event) {
-        if (group3.tween) {
-            group3.on("start.brush", function(event2) {
+    brush3.move = function(group5, selection3, event) {
+        if (group5.tween) {
+            group5.on("start.brush", function(event2) {
                 emitter(this, arguments).beforestart().start(event2);
             }).on("interrupt.brush end.brush", function(event2) {
                 emitter(this, arguments).end(event2);
             }).tween("brush", function() {
                 var that = this,
                     state = that.__brush,
                     emit = emitter(that, arguments),
                     selection0 = state.selection,
-                    selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent),
+                    selection1 = dim.input(typeof selection3 === "function" ? selection3.apply(this, arguments) : selection3, state.extent),
                     i = value_default(selection0, selection1);
 
                 function tween(t) {
                     state.selection = t === 1 && selection1 === null ? null : i(t);
                     redraw.call(that);
                     emit.brush();
                 }
                 return selection0 !== null && selection1 !== null ? tween : tween(1);
             });
         } else {
-            group3.each(function() {
+            group5.each(function() {
                 var that = this,
                     args = arguments,
                     state = that.__brush,
-                    selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent),
+                    selection1 = dim.input(typeof selection3 === "function" ? selection3.apply(that, args) : selection3, state.extent),
                     emit = emitter(that, args).beforestart();
                 interrupt_default(that);
                 state.selection = selection1 === null ? null : selection1;
                 redraw.call(that);
                 emit.start(event).brush(event).end(event);
             });
         }
     };
-    brush2.clear = function(group3, event) {
-        brush2.move(group3, null, event);
+    brush3.clear = function(group5, event) {
+        brush3.move(group5, null, event);
     };
 
     function redraw() {
-        var group3 = select_default2(this),
-            selection2 = local2(this).selection;
-        if (selection2) {
-            group3.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
-            group3.selectAll(".handle").style("display", null).attr("x", function(d) {
-                return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
+        var group5 = select_default2(this),
+            selection3 = local2(this).selection;
+        if (selection3) {
+            group5.selectAll(".selection").style("display", null).attr("x", selection3[0][0]).attr("y", selection3[0][1]).attr("width", selection3[1][0] - selection3[0][0]).attr("height", selection3[1][1] - selection3[0][1]);
+            group5.selectAll(".handle").style("display", null).attr("x", function(d) {
+                return d.type[d.type.length - 1] === "e" ? selection3[1][0] - handleSize / 2 : selection3[0][0] - handleSize / 2;
             }).attr("y", function(d) {
-                return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
+                return d.type[0] === "s" ? selection3[1][1] - handleSize / 2 : selection3[0][1] - handleSize / 2;
             }).attr("width", function(d) {
-                return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
+                return d.type === "n" || d.type === "s" ? selection3[1][0] - selection3[0][0] + handleSize : handleSize;
             }).attr("height", function(d) {
-                return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
+                return d.type === "e" || d.type === "w" ? selection3[1][1] - selection3[0][1] + handleSize : handleSize;
             });
         } else {
-            group3.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
+            group5.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
         }
     }
 
     function emitter(that, args, clean) {
         var emit = that.__brush.emitter;
         return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
     }
@@ -7013,205 +7494,205 @@
     }
     Emitter.prototype = {
         beforestart: function() {
             if (++this.active === 1)
                 this.state.emitter = this, this.starting = true;
             return this;
         },
-        start: function(event, mode2) {
+        start: function(event, mode3) {
             if (this.starting)
-                this.starting = false, this.emit("start", event, mode2);
+                this.starting = false, this.emit("start", event, mode3);
             else
                 this.emit("brush", event);
             return this;
         },
-        brush: function(event, mode2) {
-            this.emit("brush", event, mode2);
+        brush: function(event, mode3) {
+            this.emit("brush", event, mode3);
             return this;
         },
-        end: function(event, mode2) {
+        end: function(event, mode3) {
             if (--this.active === 0)
-                delete this.state.emitter, this.emit("end", event, mode2);
+                delete this.state.emitter, this.emit("end", event, mode3);
             return this;
         },
-        emit: function(type2, event, mode2) {
+        emit: function(type3, event, mode3) {
             var d = select_default2(this.that).datum();
             listeners.call(
-                type2,
+                type3,
                 this.that,
-                new BrushEvent(type2, {
+                new BrushEvent(type3, {
                     sourceEvent: event,
-                    target: brush2,
+                    target: brush3,
                     selection: dim.output(this.state.selection),
-                    mode: mode2,
+                    mode: mode3,
                     dispatch: listeners
                 }),
                 d
             );
         }
     };
 
     function started(event) {
         if (touchending && !event.touches)
             return;
-        if (!filter4.apply(this, arguments))
+        if (!filter7.apply(this, arguments))
             return;
         var that = this,
-            type2 = event.target.__data__.type,
-            mode2 = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE,
-            signX = dim === Y ? null : signsX[type2],
-            signY = dim === X ? null : signsY[type2],
+            type3 = event.target.__data__.type,
+            mode3 = (keys && event.metaKey ? type3 = "overlay" : type3) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE,
+            signX = dim === Y ? null : signsX[type3],
+            signY = dim === X ? null : signsY[type3],
             state = local2(that),
-            extent4 = state.extent,
-            selection2 = state.selection,
-            W = extent4[0][0],
-            w0, w1, N = extent4[0][1],
-            n0, n1, E2 = extent4[1][0],
-            e0, e1, S = extent4[1][1],
+            extent6 = state.extent,
+            selection3 = state.selection,
+            W = extent6[0][0],
+            w0, w1, N = extent6[0][1],
+            n0, n1, E3 = extent6[1][0],
+            e0, e1, S = extent6[1][1],
             s0, s1, dx = 0,
             dy = 0,
             moving, shifting = signX && signY && keys && event.shiftKey,
             lockX, lockY, points = Array.from(event.touches || [event], (t) => {
                 const i = t.identifier;
                 t = pointer_default(t, that);
                 t.point0 = t.slice();
                 t.identifier = i;
                 return t;
             });
         interrupt_default(that);
         var emit = emitter(that, arguments, true).beforestart();
-        if (type2 === "overlay") {
-            if (selection2)
+        if (type3 === "overlay") {
+            if (selection3)
                 moving = true;
             const pts = [points[0], points[1] || points[0]];
-            state.selection = selection2 = [
+            state.selection = selection3 = [
                 [
                     w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),
                     n0 = dim === X ? N : min2(pts[0][1], pts[1][1])
                 ],
                 [
-                    e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),
+                    e0 = dim === Y ? E3 : max2(pts[0][0], pts[1][0]),
                     s0 = dim === X ? S : max2(pts[0][1], pts[1][1])
                 ]
             ];
             if (points.length > 1)
                 move(event);
         } else {
-            w0 = selection2[0][0];
-            n0 = selection2[0][1];
-            e0 = selection2[1][0];
-            s0 = selection2[1][1];
+            w0 = selection3[0][0];
+            n0 = selection3[0][1];
+            e0 = selection3[1][0];
+            s0 = selection3[1][1];
         }
         w1 = w0;
         n1 = n0;
         e1 = e0;
         s1 = s0;
-        var group3 = select_default2(that).attr("pointer-events", "none");
-        var overlay = group3.selectAll(".overlay").attr("cursor", cursors[type2]);
+        var group5 = select_default2(that).attr("pointer-events", "none");
+        var overlay = group5.selectAll(".overlay").attr("cursor", cursors[type3]);
         if (event.touches) {
             emit.moved = moved;
             emit.ended = ended;
         } else {
             var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
             if (keys)
                 view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
             nodrag_default(event.view);
         }
         redraw.call(that);
-        emit.start(event, mode2.name);
+        emit.start(event, mode3.name);
 
         function moved(event2) {
             for (const p of event2.changedTouches || [event2]) {
                 for (const d of points)
                     if (d.identifier === p.identifier)
                         d.cur = pointer_default(p, that);
             }
             if (shifting && !lockX && !lockY && points.length === 1) {
-                const point6 = points[0];
-                if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))
+                const point11 = points[0];
+                if (abs(point11.cur[0] - point11[0]) > abs(point11.cur[1] - point11[1]))
                     lockY = true;
                 else
                     lockX = true;
             }
-            for (const point6 of points)
-                if (point6.cur)
-                    point6[0] = point6.cur[0], point6[1] = point6.cur[1];
+            for (const point11 of points)
+                if (point11.cur)
+                    point11[0] = point11.cur[0], point11[1] = point11.cur[1];
             moving = true;
             noevent_default2(event2);
             move(event2);
         }
 
         function move(event2) {
-            const point6 = points[0],
-                point0 = point6.point0;
+            const point11 = points[0],
+                point0 = point11.point0;
             var t;
-            dx = point6[0] - point0[0];
-            dy = point6[1] - point0[1];
-            switch (mode2) {
+            dx = point11[0] - point0[0];
+            dy = point11[1] - point0[1];
+            switch (mode3) {
                 case MODE_SPACE:
                 case MODE_DRAG: {
                     if (signX)
-                        dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
+                        dx = max2(W - w0, min2(E3 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                     if (signY)
                         dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                     break;
                 }
                 case MODE_HANDLE: {
                     if (points[1]) {
                         if (signX)
-                            w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;
+                            w1 = max2(W, min2(E3, points[0][0])), e1 = max2(W, min2(E3, points[1][0])), signX = 1;
                         if (signY)
                             n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;
                     } else {
                         if (signX < 0)
-                            dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
+                            dx = max2(W - w0, min2(E3 - w0, dx)), w1 = w0 + dx, e1 = e0;
                         else if (signX > 0)
-                            dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
+                            dx = max2(W - e0, min2(E3 - e0, dx)), w1 = w0, e1 = e0 + dx;
                         if (signY < 0)
                             dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                         else if (signY > 0)
                             dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                     }
                     break;
                 }
                 case MODE_CENTER: {
                     if (signX)
-                        w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));
+                        w1 = max2(W, min2(E3, w0 - dx * signX)), e1 = max2(W, min2(E3, e0 + dx * signX));
                     if (signY)
                         n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));
                     break;
                 }
             }
             if (e1 < w1) {
                 signX *= -1;
                 t = w0, w0 = e0, e0 = t;
                 t = w1, w1 = e1, e1 = t;
-                if (type2 in flipX)
-                    overlay.attr("cursor", cursors[type2 = flipX[type2]]);
+                if (type3 in flipX)
+                    overlay.attr("cursor", cursors[type3 = flipX[type3]]);
             }
             if (s1 < n1) {
                 signY *= -1;
                 t = n0, n0 = s0, s0 = t;
                 t = n1, n1 = s1, s1 = t;
-                if (type2 in flipY)
-                    overlay.attr("cursor", cursors[type2 = flipY[type2]]);
+                if (type3 in flipY)
+                    overlay.attr("cursor", cursors[type3 = flipY[type3]]);
             }
             if (state.selection)
-                selection2 = state.selection;
+                selection3 = state.selection;
             if (lockX)
-                w1 = selection2[0][0], e1 = selection2[1][0];
+                w1 = selection3[0][0], e1 = selection3[1][0];
             if (lockY)
-                n1 = selection2[0][1], s1 = selection2[1][1];
-            if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
+                n1 = selection3[0][1], s1 = selection3[1][1];
+            if (selection3[0][0] !== w1 || selection3[0][1] !== n1 || selection3[1][0] !== e1 || selection3[1][1] !== s1) {
                 state.selection = [
                     [w1, n1],
                     [e1, s1]
                 ];
                 redraw.call(that);
-                emit.brush(event2, mode2.name);
+                emit.brush(event2, mode3.name);
             }
         }
 
         function ended(event2) {
             nopropagation2(event2);
             if (event2.touches) {
                 if (event2.touches.length)
@@ -7221,51 +7702,51 @@
                 touchending = setTimeout(function() {
                     touchending = null;
                 }, 500);
             } else {
                 yesdrag(event2.view, moving);
                 view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
             }
-            group3.attr("pointer-events", "all");
+            group5.attr("pointer-events", "all");
             overlay.attr("cursor", cursors.overlay);
             if (state.selection)
-                selection2 = state.selection;
-            if (empty3(selection2))
+                selection3 = state.selection;
+            if (empty3(selection3))
                 state.selection = null, redraw.call(that);
-            emit.end(event2, mode2.name);
+            emit.end(event2, mode3.name);
         }
 
         function keydowned(event2) {
             switch (event2.keyCode) {
                 case 16: {
                     shifting = signX && signY;
                     break;
                 }
                 case 18: {
-                    if (mode2 === MODE_HANDLE) {
+                    if (mode3 === MODE_HANDLE) {
                         if (signX)
                             e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                         if (signY)
                             s0 = s1 - dy * signY, n0 = n1 + dy * signY;
-                        mode2 = MODE_CENTER;
+                        mode3 = MODE_CENTER;
                         move(event2);
                     }
                     break;
                 }
                 case 32: {
-                    if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {
+                    if (mode3 === MODE_HANDLE || mode3 === MODE_CENTER) {
                         if (signX < 0)
                             e0 = e1 - dx;
                         else if (signX > 0)
                             w0 = w1 - dx;
                         if (signY < 0)
                             s0 = s1 - dy;
                         else if (signY > 0)
                             n0 = n1 - dy;
-                        mode2 = MODE_SPACE;
+                        mode3 = MODE_SPACE;
                         overlay.attr("cursor", cursors.selection);
                         move(event2);
                     }
                     break;
                 }
                 default:
                     return;
@@ -7279,48 +7760,48 @@
                     if (shifting) {
                         lockX = lockY = shifting = false;
                         move(event2);
                     }
                     break;
                 }
                 case 18: {
-                    if (mode2 === MODE_CENTER) {
+                    if (mode3 === MODE_CENTER) {
                         if (signX < 0)
                             e0 = e1;
                         else if (signX > 0)
                             w0 = w1;
                         if (signY < 0)
                             s0 = s1;
                         else if (signY > 0)
                             n0 = n1;
-                        mode2 = MODE_HANDLE;
+                        mode3 = MODE_HANDLE;
                         move(event2);
                     }
                     break;
                 }
                 case 32: {
-                    if (mode2 === MODE_SPACE) {
+                    if (mode3 === MODE_SPACE) {
                         if (event2.altKey) {
                             if (signX)
                                 e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                             if (signY)
                                 s0 = s1 - dy * signY, n0 = n1 + dy * signY;
-                            mode2 = MODE_CENTER;
+                            mode3 = MODE_CENTER;
                         } else {
                             if (signX < 0)
                                 e0 = e1;
                             else if (signX > 0)
                                 w0 = w1;
                             if (signY < 0)
                                 s0 = s1;
                             else if (signY > 0)
                                 n0 = n1;
-                            mode2 = MODE_HANDLE;
+                            mode3 = MODE_HANDLE;
                         }
-                        overlay.attr("cursor", cursors[type2]);
+                        overlay.attr("cursor", cursors[type3]);
                         move(event2);
                     }
                     break;
                 }
                 default:
                     return;
             }
@@ -7336,38 +7817,38 @@
         emitter(this, arguments).ended(event);
     }
 
     function initialize() {
         var state = this.__brush || {
             selection: null
         };
-        state.extent = number22(extent3.apply(this, arguments));
+        state.extent = number22(extent5.apply(this, arguments));
         state.dim = dim;
         return state;
     }
-    brush2.extent = function(_) {
-        return arguments.length ? (extent3 = typeof _ === "function" ? _ : constant_default4(number22(_)), brush2) : extent3;
+    brush3.extent = function(_) {
+        return arguments.length ? (extent5 = typeof _ === "function" ? _ : constant_default4(number22(_)), brush3) : extent5;
     };
-    brush2.filter = function(_) {
-        return arguments.length ? (filter4 = typeof _ === "function" ? _ : constant_default4(!!_), brush2) : filter4;
+    brush3.filter = function(_) {
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default4(!!_), brush3) : filter7;
     };
-    brush2.touchable = function(_) {
-        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), brush2) : touchable;
+    brush3.touchable = function(_) {
+        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), brush3) : touchable;
     };
-    brush2.handleSize = function(_) {
-        return arguments.length ? (handleSize = +_, brush2) : handleSize;
+    brush3.handleSize = function(_) {
+        return arguments.length ? (handleSize = +_, brush3) : handleSize;
     };
-    brush2.keyModifiers = function(_) {
-        return arguments.length ? (keys = !!_, brush2) : keys;
+    brush3.keyModifiers = function(_) {
+        return arguments.length ? (keys = !!_, brush3) : keys;
     };
-    brush2.on = function() {
+    brush3.on = function() {
         var value = listeners.on.apply(listeners, arguments);
-        return value === listeners ? brush2 : value;
+        return value === listeners ? brush3 : value;
     };
-    return brush2;
+    return brush3;
 }
 
 // node_modules/d3-chord/src/math.js
 var abs2 = Math.abs;
 var cos = Math.cos;
 var sin = Math.sin;
 var pi2 = Math.PI;
@@ -7376,21 +7857,21 @@
 var max3 = Math.max;
 var epsilon3 = 1e-12;
 
 // node_modules/d3-chord/src/chord.js
 function range2(i, j) {
     return Array.from({
         length: j - i
-    }, (_, k2) => i + k2);
+    }, (_, k3) => i + k3);
 }
 
 function compareValue(compare) {
-    return function(a4, b) {
+    return function(a7, b) {
         return compare(
-            a4.source.value + a4.target.value,
+            a7.source.value + a7.target.value,
             b.source.value + b.target.value
         );
     };
 }
 
 function chord_default() {
     return chord(false, false);
@@ -7400,143 +7881,143 @@
     return chord(false, true);
 }
 
 function chordDirected() {
     return chord(true, false);
 }
 
-function chord(directed, transpose2) {
+function chord(directed, transpose3) {
     var padAngle = 0,
         sortGroups = null,
         sortSubgroups = null,
         sortChords = null;
 
-    function chord2(matrix) {
+    function chord3(matrix) {
         var n = matrix.length,
             groupSums = new Array(n),
-            groupIndex2 = range2(0, n),
+            groupIndex3 = range2(0, n),
             chords = new Array(n * n),
-            groups2 = new Array(n),
-            k2 = 0,
+            groups3 = new Array(n),
+            k3 = 0,
             dx;
         matrix = Float64Array.from({
             length: n * n
-        }, transpose2 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);
+        }, transpose3 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);
         for (let i = 0; i < n; ++i) {
-            let x4 = 0;
+            let x7 = 0;
             for (let j = 0; j < n; ++j)
-                x4 += matrix[i * n + j] + directed * matrix[j * n + i];
-            k2 += groupSums[i] = x4;
+                x7 += matrix[i * n + j] + directed * matrix[j * n + i];
+            k3 += groupSums[i] = x7;
         }
-        k2 = max3(0, tau2 - padAngle * n) / k2;
-        dx = k2 ? padAngle : tau2 / n; {
-            let x4 = 0;
+        k3 = max3(0, tau2 - padAngle * n) / k3;
+        dx = k3 ? padAngle : tau2 / n; {
+            let x7 = 0;
             if (sortGroups)
-                groupIndex2.sort((a4, b) => sortGroups(groupSums[a4], groupSums[b]));
-            for (const i of groupIndex2) {
-                const x06 = x4;
+                groupIndex3.sort((a7, b) => sortGroups(groupSums[a7], groupSums[b]));
+            for (const i of groupIndex3) {
+                const x011 = x7;
                 if (directed) {
                     const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
                     if (sortSubgroups)
-                        subgroupIndex.sort((a4, b) => sortSubgroups(a4 < 0 ? -matrix[~a4 * n + i] : matrix[i * n + a4], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
+                        subgroupIndex.sort((a7, b) => sortSubgroups(a7 < 0 ? -matrix[~a7 * n + i] : matrix[i * n + a7], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
                     for (const j of subgroupIndex) {
                         if (j < 0) {
-                            const chord3 = chords[~j * n + i] || (chords[~j * n + i] = {
+                            const chord4 = chords[~j * n + i] || (chords[~j * n + i] = {
                                 source: null,
                                 target: null
                             });
-                            chord3.target = {
+                            chord4.target = {
                                 index: i,
-                                startAngle: x4,
-                                endAngle: x4 += matrix[~j * n + i] * k2,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[~j * n + i] * k3,
                                 value: matrix[~j * n + i]
                             };
                         } else {
-                            const chord3 = chords[i * n + j] || (chords[i * n + j] = {
+                            const chord4 = chords[i * n + j] || (chords[i * n + j] = {
                                 source: null,
                                 target: null
                             });
-                            chord3.source = {
+                            chord4.source = {
                                 index: i,
-                                startAngle: x4,
-                                endAngle: x4 += matrix[i * n + j] * k2,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
                                 value: matrix[i * n + j]
                             };
                         }
                     }
-                    groups2[i] = {
+                    groups3[i] = {
                         index: i,
-                        startAngle: x06,
-                        endAngle: x4,
+                        startAngle: x011,
+                        endAngle: x7,
                         value: groupSums[i]
                     };
                 } else {
                     const subgroupIndex = range2(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);
                     if (sortSubgroups)
-                        subgroupIndex.sort((a4, b) => sortSubgroups(matrix[i * n + a4], matrix[i * n + b]));
+                        subgroupIndex.sort((a7, b) => sortSubgroups(matrix[i * n + a7], matrix[i * n + b]));
                     for (const j of subgroupIndex) {
-                        let chord3;
+                        let chord4;
                         if (i < j) {
-                            chord3 = chords[i * n + j] || (chords[i * n + j] = {
+                            chord4 = chords[i * n + j] || (chords[i * n + j] = {
                                 source: null,
                                 target: null
                             });
-                            chord3.source = {
+                            chord4.source = {
                                 index: i,
-                                startAngle: x4,
-                                endAngle: x4 += matrix[i * n + j] * k2,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
                                 value: matrix[i * n + j]
                             };
                         } else {
-                            chord3 = chords[j * n + i] || (chords[j * n + i] = {
+                            chord4 = chords[j * n + i] || (chords[j * n + i] = {
                                 source: null,
                                 target: null
                             });
-                            chord3.target = {
+                            chord4.target = {
                                 index: i,
-                                startAngle: x4,
-                                endAngle: x4 += matrix[i * n + j] * k2,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
                                 value: matrix[i * n + j]
                             };
                             if (i === j)
-                                chord3.source = chord3.target;
+                                chord4.source = chord4.target;
                         }
-                        if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {
-                            const source = chord3.source;
-                            chord3.source = chord3.target;
-                            chord3.target = source;
+                        if (chord4.source && chord4.target && chord4.source.value < chord4.target.value) {
+                            const source = chord4.source;
+                            chord4.source = chord4.target;
+                            chord4.target = source;
                         }
                     }
-                    groups2[i] = {
+                    groups3[i] = {
                         index: i,
-                        startAngle: x06,
-                        endAngle: x4,
+                        startAngle: x011,
+                        endAngle: x7,
                         value: groupSums[i]
                     };
                 }
-                x4 += dx;
+                x7 += dx;
             }
         }
         chords = Object.values(chords);
-        chords.groups = groups2;
+        chords.groups = groups3;
         return sortChords ? chords.sort(sortChords) : chords;
     }
-    chord2.padAngle = function(_) {
-        return arguments.length ? (padAngle = max3(0, _), chord2) : padAngle;
+    chord3.padAngle = function(_) {
+        return arguments.length ? (padAngle = max3(0, _), chord3) : padAngle;
     };
-    chord2.sortGroups = function(_) {
-        return arguments.length ? (sortGroups = _, chord2) : sortGroups;
+    chord3.sortGroups = function(_) {
+        return arguments.length ? (sortGroups = _, chord3) : sortGroups;
     };
-    chord2.sortSubgroups = function(_) {
-        return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;
+    chord3.sortSubgroups = function(_) {
+        return arguments.length ? (sortSubgroups = _, chord3) : sortSubgroups;
     };
-    chord2.sortChords = function(_) {
-        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;
+    chord3.sortChords = function(_) {
+        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord3) : sortChords && sortChords._;
     };
-    return chord2;
+    return chord3;
 }
 
 // node_modules/d3-path/src/path.js
 var pi3 = Math.PI;
 var tau3 = 2 * pi3;
 var epsilon4 = 1e-6;
 var tauEpsilon = tau3 - epsilon4;
@@ -7550,107 +8031,107 @@
 
 function appendRound(digits) {
     let d = Math.floor(digits);
     if (!(d >= 0))
         throw new Error(`invalid digits: ${digits}`);
     if (d > 15)
         return append;
-    const k2 = 10 ** d;
+    const k3 = 10 ** d;
     return function(strings) {
         this._ += strings[0];
         for (let i = 1, n = strings.length; i < n; ++i) {
-            this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
+            this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
         }
     };
 }
 var Path = class {
     constructor(digits) {
         this._x0 = this._y0 = // start of current subpath
             this._x1 = this._y1 = null;
         this._ = "";
         this._append = digits == null ? append : appendRound(digits);
     }
-    moveTo(x4, y4) {
-        this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
+    moveTo(x7, y7) {
+        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
     }
     closePath() {
         if (this._x1 !== null) {
             this._x1 = this._x0, this._y1 = this._y0;
             this._append`Z`;
         }
     }
-    lineTo(x4, y4) {
-        this._append`L${this._x1 = +x4},${this._y1 = +y4}`;
+    lineTo(x7, y7) {
+        this._append`L${this._x1 = +x7},${this._y1 = +y7}`;
     }
-    quadraticCurveTo(x12, y12, x4, y4) {
-        this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;
+    quadraticCurveTo(x13, y13, x7, y7) {
+        this._append`Q${+x13},${+y13},${this._x1 = +x7},${this._y1 = +y7}`;
     }
-    bezierCurveTo(x12, y12, x22, y22, x4, y4) {
-        this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;
+    bezierCurveTo(x13, y13, x22, y22, x7, y7) {
+        this._append`C${+x13},${+y13},${+x22},${+y22},${this._x1 = +x7},${this._y1 = +y7}`;
     }
-    arcTo(x12, y12, x22, y22, r) {
-        x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
+    arcTo(x13, y13, x22, y22, r) {
+        x13 = +x13, y13 = +y13, x22 = +x22, y22 = +y22, r = +r;
         if (r < 0)
             throw new Error(`negative radius: ${r}`);
-        let x06 = this._x1,
-            y06 = this._y1,
-            x21 = x22 - x12,
-            y21 = y22 - y12,
-            x01 = x06 - x12,
-            y01 = y06 - y12,
+        let x011 = this._x1,
+            y011 = this._y1,
+            x21 = x22 - x13,
+            y21 = y22 - y13,
+            x01 = x011 - x13,
+            y01 = y011 - y13,
             l01_2 = x01 * x01 + y01 * y01;
         if (this._x1 === null) {
-            this._append`M${this._x1 = x12},${this._y1 = y12}`;
+            this._append`M${this._x1 = x13},${this._y1 = y13}`;
         } else if (!(l01_2 > epsilon4))
         ;
         else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {
-            this._append`L${this._x1 = x12},${this._y1 = y12}`;
+            this._append`L${this._x1 = x13},${this._y1 = y13}`;
         } else {
-            let x20 = x22 - x06,
-                y20 = y22 - y06,
+            let x20 = x22 - x011,
+                y20 = y22 - y011,
                 l21_2 = x21 * x21 + y21 * y21,
                 l20_2 = x20 * x20 + y20 * y20,
                 l21 = Math.sqrt(l21_2),
                 l01 = Math.sqrt(l01_2),
                 l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                 t01 = l / l01,
                 t21 = l / l21;
             if (Math.abs(t01 - 1) > epsilon4) {
-                this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
+                this._append`L${x13 + t01 * x01},${y13 + t01 * y01}`;
             }
-            this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
+            this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x13 + t21 * x21},${this._y1 = y13 + t21 * y21}`;
         }
     }
-    arc(x4, y4, r, a0, a1, ccw) {
-        x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
+    arc(x7, y7, r, a0, a1, ccw) {
+        x7 = +x7, y7 = +y7, r = +r, ccw = !!ccw;
         if (r < 0)
             throw new Error(`negative radius: ${r}`);
         let dx = r * Math.cos(a0),
             dy = r * Math.sin(a0),
-            x06 = x4 + dx,
-            y06 = y4 + dy,
+            x011 = x7 + dx,
+            y011 = y7 + dy,
             cw = 1 ^ ccw,
-            da2 = ccw ? a0 - a1 : a1 - a0;
+            da3 = ccw ? a0 - a1 : a1 - a0;
         if (this._x1 === null) {
-            this._append`M${x06},${y06}`;
-        } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {
-            this._append`L${x06},${y06}`;
+            this._append`M${x011},${y011}`;
+        } else if (Math.abs(this._x1 - x011) > epsilon4 || Math.abs(this._y1 - y011) > epsilon4) {
+            this._append`L${x011},${y011}`;
         }
         if (!r)
             return;
-        if (da2 < 0)
-            da2 = da2 % tau3 + tau3;
-        if (da2 > tauEpsilon) {
-            this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
-        } else if (da2 > epsilon4) {
-            this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;
+        if (da3 < 0)
+            da3 = da3 % tau3 + tau3;
+        if (da3 > tauEpsilon) {
+            this._append`A${r},${r},0,1,${cw},${x7 - dx},${y7 - dy}A${r},${r},0,1,${cw},${this._x1 = x011},${this._y1 = y011}`;
+        } else if (da3 > epsilon4) {
+            this._append`A${r},${r},0,${+(da3 >= pi3)},${cw},${this._x1 = x7 + r * Math.cos(a1)},${this._y1 = y7 + r * Math.sin(a1)}`;
         }
     }
-    rect(x4, y4, w, h) {
-        this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;
+    rect(x7, y7, w, h) {
+        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${w = +w}v${+h}h${-w}Z`;
     }
     toString() {
         return this._;
     }
 };
 
 function path() {
@@ -7662,17 +8143,17 @@
     return new Path(+digits);
 }
 
 // node_modules/d3-chord/src/array.js
 var slice2 = Array.prototype.slice;
 
 // node_modules/d3-chord/src/constant.js
-function constant_default5(x4) {
+function constant_default5(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
 // node_modules/d3-chord/src/ribbon.js
 function defaultSource(d) {
     return d.source;
 }
@@ -7707,20 +8188,20 @@
         sourceRadius = defaultRadius,
         targetRadius = defaultRadius,
         startAngle = defaultStartAngle,
         endAngle = defaultEndAngle,
         padAngle = defaultPadAngle,
         context = null;
 
-    function ribbon2() {
-        var buffer, s2 = source.apply(this, arguments),
+    function ribbon3() {
+        var buffer, s3 = source.apply(this, arguments),
             t = target.apply(this, arguments),
             ap = padAngle.apply(this, arguments) / 2,
             argv = slice2.call(arguments),
-            sr = +sourceRadius.apply(this, (argv[0] = s2, argv)),
+            sr = +sourceRadius.apply(this, (argv[0] = s3, argv)),
             sa0 = startAngle.apply(this, argv) - halfPi2,
             sa1 = endAngle.apply(this, argv) - halfPi2,
             tr = +targetRadius.apply(this, (argv[0] = t, argv)),
             ta0 = startAngle.apply(this, argv) - halfPi2,
             ta1 = endAngle.apply(this, argv) - halfPi2;
         if (!context)
             context = buffer = path();
@@ -7751,45 +8232,45 @@
         }
         context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));
         context.closePath();
         if (buffer)
             return context = null, buffer + "" || null;
     }
     if (headRadius)
-        ribbon2.headRadius = function(_) {
-            return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : headRadius;
+        ribbon3.headRadius = function(_) {
+            return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : headRadius;
         };
-    ribbon2.radius = function(_) {
-        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : sourceRadius;
+    ribbon3.radius = function(_) {
+        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : sourceRadius;
     };
-    ribbon2.sourceRadius = function(_) {
-        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : sourceRadius;
+    ribbon3.sourceRadius = function(_) {
+        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : sourceRadius;
     };
-    ribbon2.targetRadius = function(_) {
-        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : targetRadius;
+    ribbon3.targetRadius = function(_) {
+        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : targetRadius;
     };
-    ribbon2.startAngle = function(_) {
-        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : startAngle;
+    ribbon3.startAngle = function(_) {
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : startAngle;
     };
-    ribbon2.endAngle = function(_) {
-        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : endAngle;
+    ribbon3.endAngle = function(_) {
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : endAngle;
     };
-    ribbon2.padAngle = function(_) {
-        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : padAngle;
+    ribbon3.padAngle = function(_) {
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon3) : padAngle;
     };
-    ribbon2.source = function(_) {
-        return arguments.length ? (source = _, ribbon2) : source;
+    ribbon3.source = function(_) {
+        return arguments.length ? (source = _, ribbon3) : source;
     };
-    ribbon2.target = function(_) {
-        return arguments.length ? (target = _, ribbon2) : target;
+    ribbon3.target = function(_) {
+        return arguments.length ? (target = _, ribbon3) : target;
     };
-    ribbon2.context = function(_) {
-        return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;
+    ribbon3.context = function(_) {
+        return arguments.length ? (context = _ == null ? null : _, ribbon3) : context;
     };
-    return ribbon2;
+    return ribbon3;
 }
 
 function ribbon_default() {
     return ribbon();
 }
 
 function ribbonArrow() {
@@ -7797,68 +8278,68 @@
 }
 
 // node_modules/d3-contour/src/array.js
 var array3 = Array.prototype;
 var slice3 = array3.slice;
 
 // node_modules/d3-contour/src/ascending.js
-function ascending_default(a4, b) {
-    return a4 - b;
+function ascending_default(a7, b) {
+    return a7 - b;
 }
 
 // node_modules/d3-contour/src/area.js
 function area_default(ring) {
     var i = 0,
         n = ring.length,
-        area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
+        area3 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
     while (++i < n)
-        area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
-    return area2;
+        area3 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
+    return area3;
 }
 
 // node_modules/d3-contour/src/constant.js
-var constant_default6 = (x4) => () => x4;
+var constant_default6 = (x7) => () => x7;
 
 // node_modules/d3-contour/src/contains.js
 function contains_default(ring, hole) {
     var i = -1,
         n = hole.length,
-        c6;
+        c11;
     while (++i < n)
-        if (c6 = ringContains(ring, hole[i]))
-            return c6;
+        if (c11 = ringContains(ring, hole[i]))
+            return c11;
     return 0;
 }
 
-function ringContains(ring, point6) {
-    var x4 = point6[0],
-        y4 = point6[1],
+function ringContains(ring, point11) {
+    var x7 = point11[0],
+        y7 = point11[1],
         contains = -1;
     for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
-        var pi7 = ring[i],
-            xi = pi7[0],
-            yi = pi7[1],
+        var pi13 = ring[i],
+            xi = pi13[0],
+            yi = pi13[1],
             pj = ring[j],
             xj = pj[0],
             yj = pj[1];
-        if (segmentContains(pi7, pj, point6))
+        if (segmentContains(pi13, pj, point11))
             return 0;
-        if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)
+        if (yi > y7 !== yj > y7 && x7 < (xj - xi) * (y7 - yi) / (yj - yi) + xi)
             contains = -contains;
     }
     return contains;
 }
 
-function segmentContains(a4, b, c6) {
+function segmentContains(a7, b, c11) {
     var i;
-    return collinear(a4, b, c6) && within(a4[i = +(a4[0] === b[0])], c6[i], b[i]);
+    return collinear(a7, b, c11) && within(a7[i = +(a7[0] === b[0])], c11[i], b[i]);
 }
 
-function collinear(a4, b, c6) {
-    return (b[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b[1] - a4[1]);
+function collinear(a7, b, c11) {
+    return (b[0] - a7[0]) * (c11[1] - a7[1]) === (c11[0] - a7[0]) * (b[1] - a7[1]);
 }
 
 function within(p, q, r) {
     return p <= q && q <= r || r <= q && q <= p;
 }
 
 // node_modules/d3-contour/src/noop.js
@@ -7961,40 +8442,40 @@
     ],
     []
 ];
 
 function contours_default() {
     var dx = 1,
         dy = 1,
-        threshold2 = thresholdSturges,
+        threshold3 = thresholdSturges,
         smooth = smoothLinear;
 
-    function contours(values2) {
-        var tz = threshold2(values2);
+    function contours(values3) {
+        var tz = threshold3(values3);
         if (!Array.isArray(tz)) {
-            const e = extent(values2, finite);
+            const e = extent(values3, finite);
             tz = ticks(...nice(e[0], e[1], tz), tz);
             while (tz[tz.length - 1] >= e[1])
                 tz.pop();
             while (tz[1] < e[0])
                 tz.shift();
         } else {
             tz = tz.slice().sort(ascending_default);
         }
-        return tz.map((value) => contour2(values2, value));
+        return tz.map((value) => contour3(values3, value));
     }
 
-    function contour2(values2, value) {
-        const v2 = value == null ? NaN : +value;
-        if (isNaN(v2))
+    function contour3(values3, value) {
+        const v3 = value == null ? NaN : +value;
+        if (isNaN(v3))
             throw new Error(`invalid value: ${value}`);
         var polygons = [],
             holes = [];
-        isorings(values2, v2, function(ring) {
-            smooth(ring, values2, v2);
+        isorings(values3, v3, function(ring) {
+            smooth(ring, values3, v3);
             if (area_default(ring) > 0)
                 polygons.push([ring]);
             else
                 holes.push(ring);
         });
         holes.forEach(function(hole) {
             for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
@@ -8007,52 +8488,52 @@
         return {
             type: "MultiPolygon",
             value,
             coordinates: polygons
         };
     }
 
-    function isorings(values2, value, callback) {
+    function isorings(values3, value, callback) {
         var fragmentByStart = new Array(),
             fragmentByEnd = new Array(),
-            x4, y4, t03, t13, t22, t32;
-        x4 = y4 = -1;
-        t13 = above(values2[0], value);
-        cases[t13 << 1].forEach(stitch);
-        while (++x4 < dx - 1) {
-            t03 = t13, t13 = above(values2[x4 + 1], value);
-            cases[t03 | t13 << 1].forEach(stitch);
-        }
-        cases[t13 << 0].forEach(stitch);
-        while (++y4 < dy - 1) {
-            x4 = -1;
-            t13 = above(values2[y4 * dx + dx], value);
-            t22 = above(values2[y4 * dx], value);
-            cases[t13 << 1 | t22 << 2].forEach(stitch);
-            while (++x4 < dx - 1) {
-                t03 = t13, t13 = above(values2[y4 * dx + dx + x4 + 1], value);
-                t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);
-                cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
-            }
-            cases[t13 | t22 << 3].forEach(stitch);
-        }
-        x4 = -1;
-        t22 = values2[y4 * dx] >= value;
-        cases[t22 << 2].forEach(stitch);
-        while (++x4 < dx - 1) {
-            t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);
-            cases[t22 << 2 | t32 << 3].forEach(stitch);
-        }
-        cases[t22 << 3].forEach(stitch);
-
-        function stitch(line2) {
-            var start2 = [line2[0][0] + x4, line2[0][1] + y4],
-                end = [line2[1][0] + x4, line2[1][1] + y4],
-                startIndex = index3(start2),
-                endIndex = index3(end),
+            x7, y7, t05, t15, t23, t33;
+        x7 = y7 = -1;
+        t15 = above(values3[0], value);
+        cases[t15 << 1].forEach(stitch);
+        while (++x7 < dx - 1) {
+            t05 = t15, t15 = above(values3[x7 + 1], value);
+            cases[t05 | t15 << 1].forEach(stitch);
+        }
+        cases[t15 << 0].forEach(stitch);
+        while (++y7 < dy - 1) {
+            x7 = -1;
+            t15 = above(values3[y7 * dx + dx], value);
+            t23 = above(values3[y7 * dx], value);
+            cases[t15 << 1 | t23 << 2].forEach(stitch);
+            while (++x7 < dx - 1) {
+                t05 = t15, t15 = above(values3[y7 * dx + dx + x7 + 1], value);
+                t33 = t23, t23 = above(values3[y7 * dx + x7 + 1], value);
+                cases[t05 | t15 << 1 | t23 << 2 | t33 << 3].forEach(stitch);
+            }
+            cases[t15 | t23 << 3].forEach(stitch);
+        }
+        x7 = -1;
+        t23 = values3[y7 * dx] >= value;
+        cases[t23 << 2].forEach(stitch);
+        while (++x7 < dx - 1) {
+            t33 = t23, t23 = above(values3[y7 * dx + x7 + 1], value);
+            cases[t23 << 2 | t33 << 3].forEach(stitch);
+        }
+        cases[t23 << 3].forEach(stitch);
+
+        function stitch(line3) {
+            var start3 = [line3[0][0] + x7, line3[0][1] + y7],
+                end = [line3[1][0] + x7, line3[1][1] + y7],
+                startIndex = index5(start3),
+                endIndex = index5(end),
                 f, g;
             if (f = fragmentByEnd[startIndex]) {
                 if (g = fragmentByStart[endIndex]) {
                     delete fragmentByEnd[f.end];
                     delete fragmentByStart[g.start];
                     if (f === g) {
                         f.ring.push(end);
@@ -8081,82 +8562,82 @@
                             start: g.start,
                             end: f.end,
                             ring: g.ring.concat(f.ring)
                         };
                     }
                 } else {
                     delete fragmentByStart[f.start];
-                    f.ring.unshift(start2);
+                    f.ring.unshift(start3);
                     fragmentByStart[f.start = startIndex] = f;
                 }
             } else {
                 fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
                     start: startIndex,
                     end: endIndex,
-                    ring: [start2, end]
+                    ring: [start3, end]
                 };
             }
         }
     }
 
-    function index3(point6) {
-        return point6[0] * 2 + point6[1] * (dx + 1) * 4;
+    function index5(point11) {
+        return point11[0] * 2 + point11[1] * (dx + 1) * 4;
     }
 
-    function smoothLinear(ring, values2, value) {
-        ring.forEach(function(point6) {
-            var x4 = point6[0],
-                y4 = point6[1],
-                xt = x4 | 0,
-                yt = y4 | 0,
-                v1 = valid(values2[yt * dx + xt]);
-            if (x4 > 0 && x4 < dx && xt === x4) {
-                point6[0] = smooth1(x4, valid(values2[yt * dx + xt - 1]), v1, value);
+    function smoothLinear(ring, values3, value) {
+        ring.forEach(function(point11) {
+            var x7 = point11[0],
+                y7 = point11[1],
+                xt = x7 | 0,
+                yt = y7 | 0,
+                v1 = valid(values3[yt * dx + xt]);
+            if (x7 > 0 && x7 < dx && xt === x7) {
+                point11[0] = smooth1(x7, valid(values3[yt * dx + xt - 1]), v1, value);
             }
-            if (y4 > 0 && y4 < dy && yt === y4) {
-                point6[1] = smooth1(y4, valid(values2[(yt - 1) * dx + xt]), v1, value);
+            if (y7 > 0 && y7 < dy && yt === y7) {
+                point11[1] = smooth1(y7, valid(values3[(yt - 1) * dx + xt]), v1, value);
             }
         });
     }
-    contours.contour = contour2;
+    contours.contour = contour3;
     contours.size = function(_) {
         if (!arguments.length)
             return [dx, dy];
         var _0 = Math.floor(_[0]),
             _1 = Math.floor(_[1]);
         if (!(_0 >= 0 && _1 >= 0))
             throw new Error("invalid size");
         return dx = _0, dy = _1, contours;
     };
     contours.thresholds = function(_) {
-        return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold2;
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold3;
     };
     contours.smooth = function(_) {
         return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
     };
     return contours;
 }
 
-function finite(x4) {
-    return isFinite(x4) ? x4 : NaN;
+function finite(x7) {
+    return isFinite(x7) ? x7 : NaN;
 }
 
-function above(x4, value) {
-    return x4 == null ? false : +x4 >= value;
+function above(x7, value) {
+    return x7 == null ? false : +x7 >= value;
 }
 
-function valid(v2) {
-    return v2 == null || isNaN(v2 = +v2) ? -Infinity : v2;
+function valid(v3) {
+    return v3 == null || isNaN(v3 = +v3) ? -Infinity : v3;
 }
 
-function smooth1(x4, v0, v1, value) {
-    const a4 = value - v0;
+function smooth1(x7, v0, v1, value) {
+    const a7 = value - v0;
     const b = v1 - v0;
-    const d = isFinite(a4) || isFinite(b) ? a4 / b : Math.sign(a4) / Math.sign(b);
-    return isNaN(d) ? x4 : x4 + d - 0.5;
+    const d = isFinite(a7) || isFinite(b) ? a7 / b : Math.sign(a7) / Math.sign(b);
+    return isNaN(d) ? x7 : x7 + d - 0.5;
 }
 
 // node_modules/d3-contour/src/density.js
 function defaultX(d) {
     return d[0];
 }
 
@@ -8165,138 +8646,138 @@
 }
 
 function defaultWeight() {
     return 1;
 }
 
 function density_default() {
-    var x4 = defaultX,
-        y4 = defaultY,
+    var x7 = defaultX,
+        y7 = defaultY,
         weight = defaultWeight,
         dx = 960,
         dy = 500,
         r = 20,
-        k2 = 2,
+        k3 = 2,
         o = r * 3,
-        n = dx + o * 2 >> k2,
-        m3 = dy + o * 2 >> k2,
-        threshold2 = constant_default6(20);
+        n = dx + o * 2 >> k3,
+        m5 = dy + o * 2 >> k3,
+        threshold3 = constant_default6(20);
 
     function grid(data) {
-        var values2 = new Float32Array(n * m3),
-            pow2k = Math.pow(2, -k2),
+        var values3 = new Float32Array(n * m5),
+            pow2k = Math.pow(2, -k3),
             i = -1;
         for (const d of data) {
-            var xi = (x4(d, ++i, data) + o) * pow2k,
-                yi = (y4(d, i, data) + o) * pow2k,
+            var xi = (x7(d, ++i, data) + o) * pow2k,
+                yi = (y7(d, i, data) + o) * pow2k,
                 wi = +weight(d, i, data);
-            if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m3) {
-                var x06 = Math.floor(xi),
-                    y06 = Math.floor(yi),
-                    xt = xi - x06 - 0.5,
-                    yt = yi - y06 - 0.5;
-                values2[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;
-                values2[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;
-                values2[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;
-                values2[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;
+            if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m5) {
+                var x011 = Math.floor(xi),
+                    y011 = Math.floor(yi),
+                    xt = xi - x011 - 0.5,
+                    yt = yi - y011 - 0.5;
+                values3[x011 + y011 * n] += (1 - xt) * (1 - yt) * wi;
+                values3[x011 + 1 + y011 * n] += xt * (1 - yt) * wi;
+                values3[x011 + 1 + (y011 + 1) * n] += xt * yt * wi;
+                values3[x011 + (y011 + 1) * n] += (1 - xt) * yt * wi;
             }
         }
         blur2({
-            data: values2,
+            data: values3,
             width: n,
-            height: m3
+            height: m5
         }, r * pow2k);
-        return values2;
+        return values3;
     }
 
-    function density2(data) {
-        var values2 = grid(data),
-            tz = threshold2(values2),
-            pow4k = Math.pow(2, 2 * k2);
+    function density3(data) {
+        var values3 = grid(data),
+            tz = threshold3(values3),
+            pow4k = Math.pow(2, 2 * k3);
         if (!Array.isArray(tz)) {
-            tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);
+            tz = ticks(Number.MIN_VALUE, max(values3) / pow4k, tz);
         }
-        return contours_default().size([n, m3]).thresholds(tz.map((d) => d * pow4k))(values2).map((c6, i) => (c6.value = +tz[i], transform2(c6)));
+        return contours_default().size([n, m5]).thresholds(tz.map((d) => d * pow4k))(values3).map((c11, i) => (c11.value = +tz[i], transform3(c11)));
     }
-    density2.contours = function(data) {
-        var values2 = grid(data),
-            contours = contours_default().size([n, m3]),
-            pow4k = Math.pow(2, 2 * k2),
-            contour2 = (value) => {
+    density3.contours = function(data) {
+        var values3 = grid(data),
+            contours = contours_default().size([n, m5]),
+            pow4k = Math.pow(2, 2 * k3),
+            contour3 = (value) => {
                 value = +value;
-                var c6 = transform2(contours.contour(values2, value * pow4k));
-                c6.value = value;
-                return c6;
+                var c11 = transform3(contours.contour(values3, value * pow4k));
+                c11.value = value;
+                return c11;
             };
-        Object.defineProperty(contour2, "max", {
-            get: () => max(values2) / pow4k
+        Object.defineProperty(contour3, "max", {
+            get: () => max(values3) / pow4k
         });
-        return contour2;
+        return contour3;
     };
 
-    function transform2(geometry) {
+    function transform3(geometry) {
         geometry.coordinates.forEach(transformPolygon);
         return geometry;
     }
 
-    function transformPolygon(coordinates2) {
-        coordinates2.forEach(transformRing);
+    function transformPolygon(coordinates3) {
+        coordinates3.forEach(transformRing);
     }
 
-    function transformRing(coordinates2) {
-        coordinates2.forEach(transformPoint);
+    function transformRing(coordinates3) {
+        coordinates3.forEach(transformPoint);
     }
 
-    function transformPoint(coordinates2) {
-        coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
-        coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
+    function transformPoint(coordinates3) {
+        coordinates3[0] = coordinates3[0] * Math.pow(2, k3) - o;
+        coordinates3[1] = coordinates3[1] * Math.pow(2, k3) - o;
     }
 
     function resize() {
         o = r * 3;
-        n = dx + o * 2 >> k2;
-        m3 = dy + o * 2 >> k2;
-        return density2;
+        n = dx + o * 2 >> k3;
+        m5 = dy + o * 2 >> k3;
+        return density3;
     }
-    density2.x = function(_) {
-        return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default6(+_), density2) : x4;
+    density3.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default6(+_), density3) : x7;
     };
-    density2.y = function(_) {
-        return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default6(+_), density2) : y4;
+    density3.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default6(+_), density3) : y7;
     };
-    density2.weight = function(_) {
-        return arguments.length ? (weight = typeof _ === "function" ? _ : constant_default6(+_), density2) : weight;
+    density3.weight = function(_) {
+        return arguments.length ? (weight = typeof _ === "function" ? _ : constant_default6(+_), density3) : weight;
     };
-    density2.size = function(_) {
+    density3.size = function(_) {
         if (!arguments.length)
             return [dx, dy];
         var _0 = +_[0],
             _1 = +_[1];
         if (!(_0 >= 0 && _1 >= 0))
             throw new Error("invalid size");
         return dx = _0, dy = _1, resize();
     };
-    density2.cellSize = function(_) {
+    density3.cellSize = function(_) {
         if (!arguments.length)
-            return 1 << k2;
+            return 1 << k3;
         if (!((_ = +_) >= 1))
             throw new Error("invalid cell size");
-        return k2 = Math.floor(Math.log(_) / Math.LN2), resize();
+        return k3 = Math.floor(Math.log(_) / Math.LN2), resize();
     };
-    density2.thresholds = function(_) {
-        return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density2) : threshold2;
+    density3.thresholds = function(_) {
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density3) : threshold3;
     };
-    density2.bandwidth = function(_) {
+    density3.bandwidth = function(_) {
         if (!arguments.length)
             return Math.sqrt(r * (r + 1));
         if (!((_ = +_) >= 0))
             throw new Error("invalid bandwidth");
         return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
     };
-    return density2;
+    return density3;
 }
 
 // node_modules/robust-predicates/esm/util.js
 var epsilon5 = 11102230246251565e-32;
 var splitter = 134217729;
 var resulterrbound = (3 + 8 * epsilon5) * epsilon5;
 
@@ -8391,44 +8872,44 @@
 var C1 = vec(8);
 var C2 = vec(12);
 var D2 = vec(16);
 var u = vec(4);
 
 function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
     let acxtail, acytail, bcxtail, bcytail;
-    let bvirt, c6, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t13, t03, u33;
+    let bvirt, c11, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t15, t05, u33;
     const acx = ax - cx;
     const bcx = bx - cx;
     const acy = ay - cy;
     const bcy = by - cy;
     s1 = acx * bcy;
-    c6 = splitter * acx;
-    ahi = c6 - (c6 - acx);
+    c11 = splitter * acx;
+    ahi = c11 - (c11 - acx);
     alo = acx - ahi;
-    c6 = splitter * bcy;
-    bhi = c6 - (c6 - bcy);
+    c11 = splitter * bcy;
+    bhi = c11 - (c11 - bcy);
     blo = bcy - bhi;
     s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
-    t13 = acy * bcx;
-    c6 = splitter * acy;
-    ahi = c6 - (c6 - acy);
+    t15 = acy * bcx;
+    c11 = splitter * acy;
+    ahi = c11 - (c11 - acy);
     alo = acy - ahi;
-    c6 = splitter * bcx;
-    bhi = c6 - (c6 - bcx);
+    c11 = splitter * bcx;
+    bhi = c11 - (c11 - bcx);
     blo = bcx - bhi;
-    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
-    _i = s0 - t03;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
     bvirt = s0 - _i;
-    B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
+    B2[0] = s0 - (_i + bvirt) + (bvirt - t05);
     _j2 = s1 + _i;
     bvirt = _j2 - s1;
     _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
-    _i = _0 - t13;
+    _i = _0 - t15;
     bvirt = _0 - _i;
-    B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
+    B2[1] = _0 - (_i + bvirt) + (bvirt - t15);
     u33 = _j2 + _i;
     bvirt = u33 - _j2;
     B2[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
     B2[3] = u33;
     let det = estimate(4, B2);
     let errbound = ccwerrboundB * detsum;
     if (det >= errbound || -det >= errbound) {
@@ -8446,98 +8927,98 @@
         return det;
     }
     errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
     det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
     if (det >= errbound || -det >= errbound)
         return det;
     s1 = acxtail * bcy;
-    c6 = splitter * acxtail;
-    ahi = c6 - (c6 - acxtail);
+    c11 = splitter * acxtail;
+    ahi = c11 - (c11 - acxtail);
     alo = acxtail - ahi;
-    c6 = splitter * bcy;
-    bhi = c6 - (c6 - bcy);
+    c11 = splitter * bcy;
+    bhi = c11 - (c11 - bcy);
     blo = bcy - bhi;
     s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
-    t13 = acytail * bcx;
-    c6 = splitter * acytail;
-    ahi = c6 - (c6 - acytail);
+    t15 = acytail * bcx;
+    c11 = splitter * acytail;
+    ahi = c11 - (c11 - acytail);
     alo = acytail - ahi;
-    c6 = splitter * bcx;
-    bhi = c6 - (c6 - bcx);
+    c11 = splitter * bcx;
+    bhi = c11 - (c11 - bcx);
     blo = bcx - bhi;
-    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
-    _i = s0 - t03;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
     bvirt = s0 - _i;
-    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
+    u[0] = s0 - (_i + bvirt) + (bvirt - t05);
     _j2 = s1 + _i;
     bvirt = _j2 - s1;
     _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
-    _i = _0 - t13;
+    _i = _0 - t15;
     bvirt = _0 - _i;
-    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
+    u[1] = _0 - (_i + bvirt) + (bvirt - t15);
     u33 = _j2 + _i;
     bvirt = u33 - _j2;
     u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
     u[3] = u33;
     const C1len = sum2(4, B2, 4, u, C1);
     s1 = acx * bcytail;
-    c6 = splitter * acx;
-    ahi = c6 - (c6 - acx);
+    c11 = splitter * acx;
+    ahi = c11 - (c11 - acx);
     alo = acx - ahi;
-    c6 = splitter * bcytail;
-    bhi = c6 - (c6 - bcytail);
+    c11 = splitter * bcytail;
+    bhi = c11 - (c11 - bcytail);
     blo = bcytail - bhi;
     s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
-    t13 = acy * bcxtail;
-    c6 = splitter * acy;
-    ahi = c6 - (c6 - acy);
+    t15 = acy * bcxtail;
+    c11 = splitter * acy;
+    ahi = c11 - (c11 - acy);
     alo = acy - ahi;
-    c6 = splitter * bcxtail;
-    bhi = c6 - (c6 - bcxtail);
+    c11 = splitter * bcxtail;
+    bhi = c11 - (c11 - bcxtail);
     blo = bcxtail - bhi;
-    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
-    _i = s0 - t03;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
     bvirt = s0 - _i;
-    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
+    u[0] = s0 - (_i + bvirt) + (bvirt - t05);
     _j2 = s1 + _i;
     bvirt = _j2 - s1;
     _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
-    _i = _0 - t13;
+    _i = _0 - t15;
     bvirt = _0 - _i;
-    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
+    u[1] = _0 - (_i + bvirt) + (bvirt - t15);
     u33 = _j2 + _i;
     bvirt = u33 - _j2;
     u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
     u[3] = u33;
     const C2len = sum2(C1len, C1, 4, u, C2);
     s1 = acxtail * bcytail;
-    c6 = splitter * acxtail;
-    ahi = c6 - (c6 - acxtail);
+    c11 = splitter * acxtail;
+    ahi = c11 - (c11 - acxtail);
     alo = acxtail - ahi;
-    c6 = splitter * bcytail;
-    bhi = c6 - (c6 - bcytail);
+    c11 = splitter * bcytail;
+    bhi = c11 - (c11 - bcytail);
     blo = bcytail - bhi;
     s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
-    t13 = acytail * bcxtail;
-    c6 = splitter * acytail;
-    ahi = c6 - (c6 - acytail);
+    t15 = acytail * bcxtail;
+    c11 = splitter * acytail;
+    ahi = c11 - (c11 - acytail);
     alo = acytail - ahi;
-    c6 = splitter * bcxtail;
-    bhi = c6 - (c6 - bcxtail);
+    c11 = splitter * bcxtail;
+    bhi = c11 - (c11 - bcxtail);
     blo = bcxtail - bhi;
-    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
-    _i = s0 - t03;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
     bvirt = s0 - _i;
-    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
+    u[0] = s0 - (_i + bvirt) + (bvirt - t05);
     _j2 = s1 + _i;
     bvirt = _j2 - s1;
     _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
-    _i = _0 - t13;
+    _i = _0 - t15;
     bvirt = _0 - _i;
-    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
+    u[1] = _0 - (_i + bvirt) + (bvirt - t15);
     u33 = _j2 + _i;
     bvirt = u33 - _j2;
     u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
     u[3] = u33;
     const Dlen = sum2(C2len, C2, 4, u, D2);
     return D2[Dlen - 1];
 }
@@ -8547,140 +9028,34351 @@
     const detright = (ax - cx) * (by - cy);
     const det = detleft - detright;
     if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)
         return det;
     const detsum = Math.abs(detleft + detright);
     if (Math.abs(det) >= ccwerrboundA * detsum)
         return det;
-    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
+    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
+}
+
+// node_modules/robust-predicates/esm/orient3d.js
+var o3derrboundA = (7 + 56 * epsilon5) * epsilon5;
+var o3derrboundB = (3 + 28 * epsilon5) * epsilon5;
+var o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;
+var bc = vec(4);
+var ca = vec(4);
+var ab = vec(4);
+var at_b = vec(4);
+var at_c = vec(4);
+var bt_c = vec(4);
+var bt_a = vec(4);
+var ct_a = vec(4);
+var ct_b = vec(4);
+var bct = vec(8);
+var cat = vec(8);
+var abt = vec(8);
+var u2 = vec(4);
+var _8 = vec(8);
+var _8b = vec(8);
+var _16 = vec(8);
+var _12 = vec(12);
+var fin = vec(192);
+var fin2 = vec(192);
+
+// node_modules/robust-predicates/esm/incircle.js
+var iccerrboundA = (10 + 96 * epsilon5) * epsilon5;
+var iccerrboundB = (4 + 48 * epsilon5) * epsilon5;
+var iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;
+var bc2 = vec(4);
+var ca2 = vec(4);
+var ab2 = vec(4);
+var aa = vec(4);
+var bb = vec(4);
+var cc = vec(4);
+var u3 = vec(4);
+var v = vec(4);
+var axtbc = vec(8);
+var aytbc = vec(8);
+var bxtca = vec(8);
+var bytca = vec(8);
+var cxtab = vec(8);
+var cytab = vec(8);
+var abt2 = vec(8);
+var bct2 = vec(8);
+var cat2 = vec(8);
+var abtt = vec(4);
+var bctt = vec(4);
+var catt = vec(4);
+var _82 = vec(8);
+var _162 = vec(16);
+var _16b = vec(16);
+var _16c = vec(16);
+var _32 = vec(32);
+var _32b = vec(32);
+var _48 = vec(48);
+var _64 = vec(64);
+var fin3 = vec(1152);
+var fin22 = vec(1152);
+
+// node_modules/robust-predicates/esm/insphere.js
+var isperrboundA = (16 + 224 * epsilon5) * epsilon5;
+var isperrboundB = (5 + 72 * epsilon5) * epsilon5;
+var isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;
+var ab3 = vec(4);
+var bc3 = vec(4);
+var cd = vec(4);
+var de = vec(4);
+var ea = vec(4);
+var ac = vec(4);
+var bd = vec(4);
+var ce = vec(4);
+var da = vec(4);
+var eb = vec(4);
+var abc = vec(24);
+var bcd = vec(24);
+var cde = vec(24);
+var dea = vec(24);
+var eab = vec(24);
+var abd = vec(24);
+var bce = vec(24);
+var cda = vec(24);
+var deb = vec(24);
+var eac = vec(24);
+var adet = vec(1152);
+var bdet = vec(1152);
+var cdet = vec(1152);
+var ddet = vec(1152);
+var edet = vec(1152);
+var abdet = vec(2304);
+var cddet = vec(2304);
+var cdedet = vec(3456);
+var deter = vec(5760);
+var _83 = vec(8);
+var _8b2 = vec(8);
+var _8c = vec(8);
+var _163 = vec(16);
+var _24 = vec(24);
+var _482 = vec(48);
+var _48b = vec(48);
+var _96 = vec(96);
+var _192 = vec(192);
+var _384x = vec(384);
+var _384y = vec(384);
+var _384z = vec(384);
+var _768 = vec(768);
+var xdet = vec(96);
+var ydet = vec(96);
+var zdet = vec(96);
+var fin4 = vec(1152);
+
+// node_modules/delaunator/index.js
+var EPSILON = Math.pow(2, -52);
+var EDGE_STACK = new Uint32Array(512);
+var Delaunator = class {
+    static from(points, getX = defaultGetX, getY = defaultGetY) {
+        const n = points.length;
+        const coords = new Float64Array(n * 2);
+        for (let i = 0; i < n; i++) {
+            const p = points[i];
+            coords[2 * i] = getX(p);
+            coords[2 * i + 1] = getY(p);
+        }
+        return new Delaunator(coords);
+    }
+    constructor(coords) {
+        const n = coords.length >> 1;
+        if (n > 0 && typeof coords[0] !== "number")
+            throw new Error("Expected coords to contain numbers.");
+        this.coords = coords;
+        const maxTriangles = Math.max(2 * n - 5, 0);
+        this._triangles = new Uint32Array(maxTriangles * 3);
+        this._halfedges = new Int32Array(maxTriangles * 3);
+        this._hashSize = Math.ceil(Math.sqrt(n));
+        this._hullPrev = new Uint32Array(n);
+        this._hullNext = new Uint32Array(n);
+        this._hullTri = new Uint32Array(n);
+        this._hullHash = new Int32Array(this._hashSize).fill(-1);
+        this._ids = new Uint32Array(n);
+        this._dists = new Float64Array(n);
+        this.update();
+    }
+    update() {
+        const {
+            coords,
+            _hullPrev: hullPrev,
+            _hullNext: hullNext,
+            _hullTri: hullTri,
+            _hullHash: hullHash
+        } = this;
+        const n = coords.length >> 1;
+        let minX = Infinity;
+        let minY = Infinity;
+        let maxX = -Infinity;
+        let maxY3 = -Infinity;
+        for (let i = 0; i < n; i++) {
+            const x7 = coords[2 * i];
+            const y7 = coords[2 * i + 1];
+            if (x7 < minX)
+                minX = x7;
+            if (y7 < minY)
+                minY = y7;
+            if (x7 > maxX)
+                maxX = x7;
+            if (y7 > maxY3)
+                maxY3 = y7;
+            this._ids[i] = i;
+        }
+        const cx = (minX + maxX) / 2;
+        const cy = (minY + maxY3) / 2;
+        let minDist = Infinity;
+        let i0, i1, i2;
+        for (let i = 0; i < n; i++) {
+            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
+            if (d < minDist) {
+                i0 = i;
+                minDist = d;
+            }
+        }
+        const i0x = coords[2 * i0];
+        const i0y = coords[2 * i0 + 1];
+        minDist = Infinity;
+        for (let i = 0; i < n; i++) {
+            if (i === i0)
+                continue;
+            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
+            if (d < minDist && d > 0) {
+                i1 = i;
+                minDist = d;
+            }
+        }
+        let i1x = coords[2 * i1];
+        let i1y = coords[2 * i1 + 1];
+        let minRadius = Infinity;
+        for (let i = 0; i < n; i++) {
+            if (i === i0 || i === i1)
+                continue;
+            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
+            if (r < minRadius) {
+                i2 = i;
+                minRadius = r;
+            }
+        }
+        let i2x = coords[2 * i2];
+        let i2y = coords[2 * i2 + 1];
+        if (minRadius === Infinity) {
+            for (let i = 0; i < n; i++) {
+                this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
+            }
+            quicksort(this._ids, this._dists, 0, n - 1);
+            const hull3 = new Uint32Array(n);
+            let j = 0;
+            for (let i = 0, d0 = -Infinity; i < n; i++) {
+                const id3 = this._ids[i];
+                if (this._dists[id3] > d0) {
+                    hull3[j++] = id3;
+                    d0 = this._dists[id3];
+                }
+            }
+            this.hull = hull3.subarray(0, j);
+            this.triangles = new Uint32Array(0);
+            this.halfedges = new Uint32Array(0);
+            return;
+        }
+        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
+            const i = i1;
+            const x7 = i1x;
+            const y7 = i1y;
+            i1 = i2;
+            i1x = i2x;
+            i1y = i2y;
+            i2 = i;
+            i2x = x7;
+            i2y = y7;
+        }
+        const center3 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
+        this._cx = center3.x;
+        this._cy = center3.y;
+        for (let i = 0; i < n; i++) {
+            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center3.x, center3.y);
+        }
+        quicksort(this._ids, this._dists, 0, n - 1);
+        this._hullStart = i0;
+        let hullSize = 3;
+        hullNext[i0] = hullPrev[i2] = i1;
+        hullNext[i1] = hullPrev[i0] = i2;
+        hullNext[i2] = hullPrev[i1] = i0;
+        hullTri[i0] = 0;
+        hullTri[i1] = 1;
+        hullTri[i2] = 2;
+        hullHash.fill(-1);
+        hullHash[this._hashKey(i0x, i0y)] = i0;
+        hullHash[this._hashKey(i1x, i1y)] = i1;
+        hullHash[this._hashKey(i2x, i2y)] = i2;
+        this.trianglesLen = 0;
+        this._addTriangle(i0, i1, i2, -1, -1, -1);
+        for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
+            const i = this._ids[k3];
+            const x7 = coords[2 * i];
+            const y7 = coords[2 * i + 1];
+            if (k3 > 0 && Math.abs(x7 - xp) <= EPSILON && Math.abs(y7 - yp) <= EPSILON)
+                continue;
+            xp = x7;
+            yp = y7;
+            if (i === i0 || i === i1 || i === i2)
+                continue;
+            let start3 = 0;
+            for (let j = 0, key = this._hashKey(x7, y7); j < this._hashSize; j++) {
+                start3 = hullHash[(key + j) % this._hashSize];
+                if (start3 !== -1 && start3 !== hullNext[start3])
+                    break;
+            }
+            start3 = hullPrev[start3];
+            let e = start3,
+                q;
+            while (q = hullNext[e], orient2d(x7, y7, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
+                e = q;
+                if (e === start3) {
+                    e = -1;
+                    break;
+                }
+            }
+            if (e === -1)
+                continue;
+            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
+            hullTri[i] = this._legalize(t + 2);
+            hullTri[e] = t;
+            hullSize++;
+            let n2 = hullNext[e];
+            while (q = hullNext[n2], orient2d(x7, y7, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
+                t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
+                hullTri[i] = this._legalize(t + 2);
+                hullNext[n2] = n2;
+                hullSize--;
+                n2 = q;
+            }
+            if (e === start3) {
+                while (q = hullPrev[e], orient2d(x7, y7, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
+                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
+                    this._legalize(t + 2);
+                    hullTri[q] = t;
+                    hullNext[e] = e;
+                    hullSize--;
+                    e = q;
+                }
+            }
+            this._hullStart = hullPrev[i] = e;
+            hullNext[e] = hullPrev[n2] = i;
+            hullNext[i] = n2;
+            hullHash[this._hashKey(x7, y7)] = i;
+            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
+        }
+        this.hull = new Uint32Array(hullSize);
+        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
+            this.hull[i] = e;
+            e = hullNext[e];
+        }
+        this.triangles = this._triangles.subarray(0, this.trianglesLen);
+        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
+    }
+    _hashKey(x7, y7) {
+        return Math.floor(pseudoAngle(x7 - this._cx, y7 - this._cy) * this._hashSize) % this._hashSize;
+    }
+    _legalize(a7) {
+        const {
+            _triangles: triangles,
+            _halfedges: halfedges,
+            coords
+        } = this;
+        let i = 0;
+        let ar = 0;
+        while (true) {
+            const b = halfedges[a7];
+            const a0 = a7 - a7 % 3;
+            ar = a0 + (a7 + 2) % 3;
+            if (b === -1) {
+                if (i === 0)
+                    break;
+                a7 = EDGE_STACK[--i];
+                continue;
+            }
+            const b03 = b - b % 3;
+            const al = a0 + (a7 + 1) % 3;
+            const bl = b03 + (b + 2) % 3;
+            const p03 = triangles[ar];
+            const pr = triangles[a7];
+            const pl = triangles[al];
+            const p1 = triangles[bl];
+            const illegal = inCircle(
+                coords[2 * p03],
+                coords[2 * p03 + 1],
+                coords[2 * pr],
+                coords[2 * pr + 1],
+                coords[2 * pl],
+                coords[2 * pl + 1],
+                coords[2 * p1],
+                coords[2 * p1 + 1]
+            );
+            if (illegal) {
+                triangles[a7] = p1;
+                triangles[b] = p03;
+                const hbl = halfedges[bl];
+                if (hbl === -1) {
+                    let e = this._hullStart;
+                    do {
+                        if (this._hullTri[e] === bl) {
+                            this._hullTri[e] = a7;
+                            break;
+                        }
+                        e = this._hullPrev[e];
+                    } while (e !== this._hullStart);
+                }
+                this._link(a7, hbl);
+                this._link(b, halfedges[ar]);
+                this._link(ar, bl);
+                const br = b03 + (b + 1) % 3;
+                if (i < EDGE_STACK.length) {
+                    EDGE_STACK[i++] = br;
+                }
+            } else {
+                if (i === 0)
+                    break;
+                a7 = EDGE_STACK[--i];
+            }
+        }
+        return ar;
+    }
+    _link(a7, b) {
+        this._halfedges[a7] = b;
+        if (b !== -1)
+            this._halfedges[b] = a7;
+    }
+    // add a new triangle given vertex indices and adjacent half-edge ids
+    _addTriangle(i0, i1, i2, a7, b, c11) {
+        const t = this.trianglesLen;
+        this._triangles[t] = i0;
+        this._triangles[t + 1] = i1;
+        this._triangles[t + 2] = i2;
+        this._link(t, a7);
+        this._link(t + 1, b);
+        this._link(t + 2, c11);
+        this.trianglesLen += 3;
+        return t;
+    }
+};
+
+function pseudoAngle(dx, dy) {
+    const p = dx / (Math.abs(dx) + Math.abs(dy));
+    return (dy > 0 ? 3 - p : 1 + p) / 4;
+}
+
+function dist(ax, ay, bx, by) {
+    const dx = ax - bx;
+    const dy = ay - by;
+    return dx * dx + dy * dy;
+}
+
+function inCircle(ax, ay, bx, by, cx, cy, px, py) {
+    const dx = ax - px;
+    const dy = ay - py;
+    const ex = bx - px;
+    const ey = by - py;
+    const fx = cx - px;
+    const fy = cy - py;
+    const ap = dx * dx + dy * dy;
+    const bp = ex * ex + ey * ey;
+    const cp = fx * fx + fy * fy;
+    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
+}
+
+function circumradius(ax, ay, bx, by, cx, cy) {
+    const dx = bx - ax;
+    const dy = by - ay;
+    const ex = cx - ax;
+    const ey = cy - ay;
+    const bl = dx * dx + dy * dy;
+    const cl = ex * ex + ey * ey;
+    const d = 0.5 / (dx * ey - dy * ex);
+    const x7 = (ey * bl - dy * cl) * d;
+    const y7 = (dx * cl - ex * bl) * d;
+    return x7 * x7 + y7 * y7;
+}
+
+function circumcenter(ax, ay, bx, by, cx, cy) {
+    const dx = bx - ax;
+    const dy = by - ay;
+    const ex = cx - ax;
+    const ey = cy - ay;
+    const bl = dx * dx + dy * dy;
+    const cl = ex * ex + ey * ey;
+    const d = 0.5 / (dx * ey - dy * ex);
+    const x7 = ax + (ey * bl - dy * cl) * d;
+    const y7 = ay + (dx * cl - ex * bl) * d;
+    return {
+        x: x7,
+        y: y7
+    };
+}
+
+function quicksort(ids, dists, left3, right3) {
+    if (right3 - left3 <= 20) {
+        for (let i = left3 + 1; i <= right3; i++) {
+            const temp = ids[i];
+            const tempDist = dists[temp];
+            let j = i - 1;
+            while (j >= left3 && dists[ids[j]] > tempDist)
+                ids[j + 1] = ids[j--];
+            ids[j + 1] = temp;
+        }
+    } else {
+        const median3 = left3 + right3 >> 1;
+        let i = left3 + 1;
+        let j = right3;
+        swap2(ids, median3, i);
+        if (dists[ids[left3]] > dists[ids[right3]])
+            swap2(ids, left3, right3);
+        if (dists[ids[i]] > dists[ids[right3]])
+            swap2(ids, i, right3);
+        if (dists[ids[left3]] > dists[ids[i]])
+            swap2(ids, left3, i);
+        const temp = ids[i];
+        const tempDist = dists[temp];
+        while (true) {
+            do
+                i++;
+            while (dists[ids[i]] < tempDist);
+            do
+                j--;
+            while (dists[ids[j]] > tempDist);
+            if (j < i)
+                break;
+            swap2(ids, i, j);
+        }
+        ids[left3 + 1] = ids[j];
+        ids[j] = temp;
+        if (right3 - i + 1 >= j - left3) {
+            quicksort(ids, dists, i, right3);
+            quicksort(ids, dists, left3, j - 1);
+        } else {
+            quicksort(ids, dists, left3, j - 1);
+            quicksort(ids, dists, i, right3);
+        }
+    }
+}
+
+function swap2(arr, i, j) {
+    const tmp2 = arr[i];
+    arr[i] = arr[j];
+    arr[j] = tmp2;
+}
+
+function defaultGetX(p) {
+    return p[0];
+}
+
+function defaultGetY(p) {
+    return p[1];
+}
+
+// node_modules/d3-delaunay/src/path.js
+var epsilon6 = 1e-6;
+var Path2 = class {
+    constructor() {
+        this._x0 = this._y0 = // start of current subpath
+            this._x1 = this._y1 = null;
+        this._ = "";
+    }
+    moveTo(x7, y7) {
+        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
+    }
+    closePath() {
+        if (this._x1 !== null) {
+            this._x1 = this._x0, this._y1 = this._y0;
+            this._ += "Z";
+        }
+    }
+    lineTo(x7, y7) {
+        this._ += `L${this._x1 = +x7},${this._y1 = +y7}`;
+    }
+    arc(x7, y7, r) {
+        x7 = +x7, y7 = +y7, r = +r;
+        const x011 = x7 + r;
+        const y011 = y7;
+        if (r < 0)
+            throw new Error("negative radius");
+        if (this._x1 === null)
+            this._ += `M${x011},${y011}`;
+        else if (Math.abs(this._x1 - x011) > epsilon6 || Math.abs(this._y1 - y011) > epsilon6)
+            this._ += "L" + x011 + "," + y011;
+        if (!r)
+            return;
+        this._ += `A${r},${r},0,1,1,${x7 - r},${y7}A${r},${r},0,1,1,${this._x1 = x011},${this._y1 = y011}`;
+    }
+    rect(x7, y7, w, h) {
+        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${+w}v${+h}h${-w}Z`;
+    }
+    value() {
+        return this._ || null;
+    }
+};
+
+// node_modules/d3-delaunay/src/polygon.js
+var Polygon = class {
+    constructor() {
+        this._ = [];
+    }
+    moveTo(x7, y7) {
+        this._.push([x7, y7]);
+    }
+    closePath() {
+        this._.push(this._[0].slice());
+    }
+    lineTo(x7, y7) {
+        this._.push([x7, y7]);
+    }
+    value() {
+        return this._.length ? this._ : null;
+    }
+};
+
+// node_modules/d3-delaunay/src/voronoi.js
+var Voronoi = class {
+    constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
+        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
+            throw new Error("invalid bounds");
+        this.delaunay = delaunay;
+        this._circumcenters = new Float64Array(delaunay.points.length * 2);
+        this.vectors = new Float64Array(delaunay.points.length * 2);
+        this.xmax = xmax, this.xmin = xmin;
+        this.ymax = ymax, this.ymin = ymin;
+        this._init();
+    }
+    update() {
+        this.delaunay.update();
+        this._init();
+        return this;
+    }
+    _init() {
+        const {
+            delaunay: {
+                points,
+                hull: hull3,
+                triangles
+            },
+            vectors
+        } = this;
+        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
+        for (let i = 0, j = 0, n = triangles.length, x7, y7; i < n; i += 3, j += 2) {
+            const t15 = triangles[i] * 2;
+            const t23 = triangles[i + 1] * 2;
+            const t33 = triangles[i + 2] * 2;
+            const x14 = points[t15];
+            const y14 = points[t15 + 1];
+            const x22 = points[t23];
+            const y22 = points[t23 + 1];
+            const x32 = points[t33];
+            const y32 = points[t33 + 1];
+            const dx = x22 - x14;
+            const dy = y22 - y14;
+            const ex = x32 - x14;
+            const ey = y32 - y14;
+            const ab7 = (dx * ey - dy * ex) * 2;
+            if (Math.abs(ab7) < 1e-9) {
+                let a7 = 1e9;
+                const r = triangles[0] * 2;
+                a7 *= Math.sign((points[r] - x14) * ey - (points[r + 1] - y14) * ex);
+                x7 = (x14 + x32) / 2 - a7 * ey;
+                y7 = (y14 + y32) / 2 + a7 * ex;
+            } else {
+                const d = 1 / ab7;
+                const bl = dx * dx + dy * dy;
+                const cl = ex * ex + ey * ey;
+                x7 = x14 + (ey * bl - dy * cl) * d;
+                y7 = y14 + (dx * cl - ex * bl) * d;
+            }
+            circumcenters[j] = x7;
+            circumcenters[j + 1] = y7;
+        }
+        let h = hull3[hull3.length - 1];
+        let p03, p1 = h * 4;
+        let x011, x13 = points[2 * h];
+        let y011, y13 = points[2 * h + 1];
+        vectors.fill(0);
+        for (let i = 0; i < hull3.length; ++i) {
+            h = hull3[i];
+            p03 = p1, x011 = x13, y011 = y13;
+            p1 = h * 4, x13 = points[2 * h], y13 = points[2 * h + 1];
+            vectors[p03 + 2] = vectors[p1] = y011 - y13;
+            vectors[p03 + 3] = vectors[p1 + 1] = x13 - x011;
+        }
+    }
+    render(context) {
+        const buffer = context == null ? context = new Path2() : void 0;
+        const {
+            delaunay: {
+                halfedges,
+                inedges,
+                hull: hull3
+            },
+            circumcenters,
+            vectors
+        } = this;
+        if (hull3.length <= 1)
+            return null;
+        for (let i = 0, n = halfedges.length; i < n; ++i) {
+            const j = halfedges[i];
+            if (j < i)
+                continue;
+            const ti = Math.floor(i / 3) * 2;
+            const tj = Math.floor(j / 3) * 2;
+            const xi = circumcenters[ti];
+            const yi = circumcenters[ti + 1];
+            const xj = circumcenters[tj];
+            const yj = circumcenters[tj + 1];
+            this._renderSegment(xi, yi, xj, yj, context);
+        }
+        let h0, h1 = hull3[hull3.length - 1];
+        for (let i = 0; i < hull3.length; ++i) {
+            h0 = h1, h1 = hull3[i];
+            const t = Math.floor(inedges[h1] / 3) * 2;
+            const x7 = circumcenters[t];
+            const y7 = circumcenters[t + 1];
+            const v3 = h0 * 4;
+            const p = this._project(x7, y7, vectors[v3 + 2], vectors[v3 + 3]);
+            if (p)
+                this._renderSegment(x7, y7, p[0], p[1], context);
+        }
+        return buffer && buffer.value();
+    }
+    renderBounds(context) {
+        const buffer = context == null ? context = new Path2() : void 0;
+        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
+        return buffer && buffer.value();
+    }
+    renderCell(i, context) {
+            const buffer = context == null ? context = new Path2() : void 0;
+            const points = this._clip(i);
+            if (points === null || !points.length)
+                return;
+            context.moveTo(points[0], points[1]);
+            let n = points.length;
+            while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)
+                n -= 2;
+            for (let i2 = 2; i2 < n; i2 += 2) {
+                if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
+                    context.lineTo(points[i2], points[i2 + 1]);
+            }
+            context.closePath();
+            return buffer && buffer.value();
+        }
+        * cellPolygons() {
+            const {
+                delaunay: {
+                    points
+                }
+            } = this;
+            for (let i = 0, n = points.length / 2; i < n; ++i) {
+                const cell3 = this.cellPolygon(i);
+                if (cell3)
+                    cell3.index = i, yield cell3;
+            }
+        }
+    cellPolygon(i) {
+        const polygon = new Polygon();
+        this.renderCell(i, polygon);
+        return polygon.value();
+    }
+    _renderSegment(x011, y011, x13, y13, context) {
+        let S;
+        const c0 = this._regioncode(x011, y011);
+        const c1 = this._regioncode(x13, y13);
+        if (c0 === 0 && c1 === 0) {
+            context.moveTo(x011, y011);
+            context.lineTo(x13, y13);
+        } else if (S = this._clipSegment(x011, y011, x13, y13, c0, c1)) {
+            context.moveTo(S[0], S[1]);
+            context.lineTo(S[2], S[3]);
+        }
+    }
+    contains(i, x7, y7) {
+            if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
+                return false;
+            return this.delaunay._step(i, x7, y7) === i;
+        }
+        * neighbors(i) {
+            const ci = this._clip(i);
+            if (ci)
+                for (const j of this.delaunay.neighbors(i)) {
+                    const cj = this._clip(j);
+                    if (cj)
+                        loop:
+                        for (let ai = 0, li = ci.length; ai < li; ai += 2) {
+                            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
+                                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
+                                    yield j;
+                                    break loop;
+                                }
+                            }
+                        }
+                }
+        }
+    _cell(i) {
+        const {
+            circumcenters,
+            delaunay: {
+                inedges,
+                halfedges,
+                triangles
+            }
+        } = this;
+        const e0 = inedges[i];
+        if (e0 === -1)
+            return null;
+        const points = [];
+        let e = e0;
+        do {
+            const t = Math.floor(e / 3);
+            points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
+            e = e % 3 === 2 ? e - 2 : e + 1;
+            if (triangles[e] !== i)
+                break;
+            e = halfedges[e];
+        } while (e !== e0 && e !== -1);
+        return points;
+    }
+    _clip(i) {
+        if (i === 0 && this.delaunay.hull.length === 1) {
+            return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
+        }
+        const points = this._cell(i);
+        if (points === null)
+            return null;
+        const {
+            vectors: V
+        } = this;
+        const v3 = i * 4;
+        return V[v3] || V[v3 + 1] ? this._clipInfinite(i, points, V[v3], V[v3 + 1], V[v3 + 2], V[v3 + 3]) : this._clipFinite(i, points);
+    }
+    _clipFinite(i, points) {
+        const n = points.length;
+        let P = null;
+        let x011, y011, x13 = points[n - 2],
+            y13 = points[n - 1];
+        let c0, c1 = this._regioncode(x13, y13);
+        let e0, e1 = 0;
+        for (let j = 0; j < n; j += 2) {
+            x011 = x13, y011 = y13, x13 = points[j], y13 = points[j + 1];
+            c0 = c1, c1 = this._regioncode(x13, y13);
+            if (c0 === 0 && c1 === 0) {
+                e0 = e1, e1 = 0;
+                if (P)
+                    P.push(x13, y13);
+                else
+                    P = [x13, y13];
+            } else {
+                let S, sx0, sy0, sx1, sy1;
+                if (c0 === 0) {
+                    if ((S = this._clipSegment(x011, y011, x13, y13, c0, c1)) === null)
+                        continue;
+                    [sx0, sy0, sx1, sy1] = S;
+                } else {
+                    if ((S = this._clipSegment(x13, y13, x011, y011, c1, c0)) === null)
+                        continue;
+                    [sx1, sy1, sx0, sy0] = S;
+                    e0 = e1, e1 = this._edgecode(sx0, sy0);
+                    if (e0 && e1)
+                        this._edge(i, e0, e1, P, P.length);
+                    if (P)
+                        P.push(sx0, sy0);
+                    else
+                        P = [sx0, sy0];
+                }
+                e0 = e1, e1 = this._edgecode(sx1, sy1);
+                if (e0 && e1)
+                    this._edge(i, e0, e1, P, P.length);
+                if (P)
+                    P.push(sx1, sy1);
+                else
+                    P = [sx1, sy1];
+            }
+        }
+        if (P) {
+            e0 = e1, e1 = this._edgecode(P[0], P[1]);
+            if (e0 && e1)
+                this._edge(i, e0, e1, P, P.length);
+        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
+            return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
+        }
+        return P;
+    }
+    _clipSegment(x011, y011, x13, y13, c0, c1) {
+        while (true) {
+            if (c0 === 0 && c1 === 0)
+                return [x011, y011, x13, y13];
+            if (c0 & c1)
+                return null;
+            let x7, y7, c11 = c0 || c1;
+            if (c11 & 8)
+                x7 = x011 + (x13 - x011) * (this.ymax - y011) / (y13 - y011), y7 = this.ymax;
+            else if (c11 & 4)
+                x7 = x011 + (x13 - x011) * (this.ymin - y011) / (y13 - y011), y7 = this.ymin;
+            else if (c11 & 2)
+                y7 = y011 + (y13 - y011) * (this.xmax - x011) / (x13 - x011), x7 = this.xmax;
+            else
+                y7 = y011 + (y13 - y011) * (this.xmin - x011) / (x13 - x011), x7 = this.xmin;
+            if (c0)
+                x011 = x7, y011 = y7, c0 = this._regioncode(x011, y011);
+            else
+                x13 = x7, y13 = y7, c1 = this._regioncode(x13, y13);
+        }
+    }
+    _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
+        let P = Array.from(points),
+            p;
+        if (p = this._project(P[0], P[1], vx0, vy0))
+            P.unshift(p[0], p[1]);
+        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
+            P.push(p[0], p[1]);
+        if (P = this._clipFinite(i, P)) {
+            for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
+                c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
+                if (c0 && c1)
+                    j = this._edge(i, c0, c1, P, j), n = P.length;
+            }
+        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
+            P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
+        }
+        return P;
+    }
+    _edge(i, e0, e1, P, j) {
+        while (e0 !== e1) {
+            let x7, y7;
+            switch (e0) {
+                case 5:
+                    e0 = 4;
+                    continue;
+                case 4:
+                    e0 = 6, x7 = this.xmax, y7 = this.ymin;
+                    break;
+                case 6:
+                    e0 = 2;
+                    continue;
+                case 2:
+                    e0 = 10, x7 = this.xmax, y7 = this.ymax;
+                    break;
+                case 10:
+                    e0 = 8;
+                    continue;
+                case 8:
+                    e0 = 9, x7 = this.xmin, y7 = this.ymax;
+                    break;
+                case 9:
+                    e0 = 1;
+                    continue;
+                case 1:
+                    e0 = 5, x7 = this.xmin, y7 = this.ymin;
+                    break;
+            }
+            if ((P[j] !== x7 || P[j + 1] !== y7) && this.contains(i, x7, y7)) {
+                P.splice(j, 0, x7, y7), j += 2;
+            }
+        }
+        if (P.length > 4) {
+            for (let i2 = 0; i2 < P.length; i2 += 2) {
+                const j2 = (i2 + 2) % P.length,
+                    k3 = (i2 + 4) % P.length;
+                if (P[i2] === P[j2] && P[j2] === P[k3] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k3 + 1])
+                    P.splice(j2, 2), i2 -= 2;
+            }
+        }
+        return j;
+    }
+    _project(x011, y011, vx, vy) {
+        let t = Infinity,
+            c11, x7, y7;
+        if (vy < 0) {
+            if (y011 <= this.ymin)
+                return null;
+            if ((c11 = (this.ymin - y011) / vy) < t)
+                y7 = this.ymin, x7 = x011 + (t = c11) * vx;
+        } else if (vy > 0) {
+            if (y011 >= this.ymax)
+                return null;
+            if ((c11 = (this.ymax - y011) / vy) < t)
+                y7 = this.ymax, x7 = x011 + (t = c11) * vx;
+        }
+        if (vx > 0) {
+            if (x011 >= this.xmax)
+                return null;
+            if ((c11 = (this.xmax - x011) / vx) < t)
+                x7 = this.xmax, y7 = y011 + (t = c11) * vy;
+        } else if (vx < 0) {
+            if (x011 <= this.xmin)
+                return null;
+            if ((c11 = (this.xmin - x011) / vx) < t)
+                x7 = this.xmin, y7 = y011 + (t = c11) * vy;
+        }
+        return [x7, y7];
+    }
+    _edgecode(x7, y7) {
+        return (x7 === this.xmin ? 1 : x7 === this.xmax ? 2 : 0) | (y7 === this.ymin ? 4 : y7 === this.ymax ? 8 : 0);
+    }
+    _regioncode(x7, y7) {
+        return (x7 < this.xmin ? 1 : x7 > this.xmax ? 2 : 0) | (y7 < this.ymin ? 4 : y7 > this.ymax ? 8 : 0);
+    }
+};
+
+// node_modules/d3-delaunay/src/delaunay.js
+var tau4 = 2 * Math.PI;
+var pow = Math.pow;
+
+function pointX(p) {
+    return p[0];
+}
+
+function pointY(p) {
+    return p[1];
+}
+
+function collinear2(d) {
+    const {
+        triangles,
+        coords
+    } = d;
+    for (let i = 0; i < triangles.length; i += 3) {
+        const a7 = 2 * triangles[i],
+            b = 2 * triangles[i + 1],
+            c11 = 2 * triangles[i + 2],
+            cross3 = (coords[c11] - coords[a7]) * (coords[b + 1] - coords[a7 + 1]) - (coords[b] - coords[a7]) * (coords[c11 + 1] - coords[a7 + 1]);
+        if (cross3 > 1e-10)
+            return false;
+    }
+    return true;
+}
+
+function jitter(x7, y7, r) {
+    return [x7 + Math.sin(x7 + y7) * r, y7 + Math.cos(x7 - y7) * r];
+}
+var Delaunay = class {
+    static from(points, fx = pointX, fy = pointY, that) {
+        return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
+    }
+    constructor(points) {
+        this._delaunator = new Delaunator(points);
+        this.inedges = new Int32Array(points.length / 2);
+        this._hullIndex = new Int32Array(points.length / 2);
+        this.points = this._delaunator.coords;
+        this._init();
+    }
+    update() {
+        this._delaunator.update();
+        this._init();
+        return this;
+    }
+    _init() {
+        const d = this._delaunator,
+            points = this.points;
+        if (d.hull && d.hull.length > 2 && collinear2(d)) {
+            this.collinear = Int32Array.from({
+                length: points.length / 2
+            }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
+            const e = this.collinear[0],
+                f = this.collinear[this.collinear.length - 1],
+                bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]],
+                r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
+            for (let i = 0, n = points.length / 2; i < n; ++i) {
+                const p = jitter(points[2 * i], points[2 * i + 1], r);
+                points[2 * i] = p[0];
+                points[2 * i + 1] = p[1];
+            }
+            this._delaunator = new Delaunator(points);
+        } else {
+            delete this.collinear;
+        }
+        const halfedges = this.halfedges = this._delaunator.halfedges;
+        const hull3 = this.hull = this._delaunator.hull;
+        const triangles = this.triangles = this._delaunator.triangles;
+        const inedges = this.inedges.fill(-1);
+        const hullIndex = this._hullIndex.fill(-1);
+        for (let e = 0, n = halfedges.length; e < n; ++e) {
+            const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
+            if (halfedges[e] === -1 || inedges[p] === -1)
+                inedges[p] = e;
+        }
+        for (let i = 0, n = hull3.length; i < n; ++i) {
+            hullIndex[hull3[i]] = i;
+        }
+        if (hull3.length <= 2 && hull3.length > 0) {
+            this.triangles = new Int32Array(3).fill(-1);
+            this.halfedges = new Int32Array(3).fill(-1);
+            this.triangles[0] = hull3[0];
+            inedges[hull3[0]] = 1;
+            if (hull3.length === 2) {
+                inedges[hull3[1]] = 0;
+                this.triangles[1] = hull3[1];
+                this.triangles[2] = hull3[1];
+            }
+        }
+    }
+    voronoi(bounds) {
+            return new Voronoi(this, bounds);
+        }
+        * neighbors(i) {
+            const {
+                inedges,
+                hull: hull3,
+                _hullIndex,
+                halfedges,
+                triangles,
+                collinear: collinear5
+            } = this;
+            if (collinear5) {
+                const l = collinear5.indexOf(i);
+                if (l > 0)
+                    yield collinear5[l - 1];
+                if (l < collinear5.length - 1)
+                    yield collinear5[l + 1];
+                return;
+            }
+            const e0 = inedges[i];
+            if (e0 === -1)
+                return;
+            let e = e0,
+                p03 = -1;
+            do {
+                yield p03 = triangles[e];
+                e = e % 3 === 2 ? e - 2 : e + 1;
+                if (triangles[e] !== i)
+                    return;
+                e = halfedges[e];
+                if (e === -1) {
+                    const p = hull3[(_hullIndex[i] + 1) % hull3.length];
+                    if (p !== p03)
+                        yield p;
+                    return;
+                }
+            } while (e !== e0);
+        }
+    find(x7, y7, i = 0) {
+        if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
+            return -1;
+        const i0 = i;
+        let c11;
+        while ((c11 = this._step(i, x7, y7)) >= 0 && c11 !== i && c11 !== i0)
+            i = c11;
+        return c11;
+    }
+    _step(i, x7, y7) {
+        const {
+            inedges,
+            hull: hull3,
+            _hullIndex,
+            halfedges,
+            triangles,
+            points
+        } = this;
+        if (inedges[i] === -1 || !points.length)
+            return (i + 1) % (points.length >> 1);
+        let c11 = i;
+        let dc = pow(x7 - points[i * 2], 2) + pow(y7 - points[i * 2 + 1], 2);
+        const e0 = inedges[i];
+        let e = e0;
+        do {
+            let t = triangles[e];
+            const dt = pow(x7 - points[t * 2], 2) + pow(y7 - points[t * 2 + 1], 2);
+            if (dt < dc)
+                dc = dt, c11 = t;
+            e = e % 3 === 2 ? e - 2 : e + 1;
+            if (triangles[e] !== i)
+                break;
+            e = halfedges[e];
+            if (e === -1) {
+                e = hull3[(_hullIndex[i] + 1) % hull3.length];
+                if (e !== t) {
+                    if (pow(x7 - points[e * 2], 2) + pow(y7 - points[e * 2 + 1], 2) < dc)
+                        return e;
+                }
+                break;
+            }
+        } while (e !== e0);
+        return c11;
+    }
+    render(context) {
+        const buffer = context == null ? context = new Path2() : void 0;
+        const {
+            points,
+            halfedges,
+            triangles
+        } = this;
+        for (let i = 0, n = halfedges.length; i < n; ++i) {
+            const j = halfedges[i];
+            if (j < i)
+                continue;
+            const ti = triangles[i] * 2;
+            const tj = triangles[j] * 2;
+            context.moveTo(points[ti], points[ti + 1]);
+            context.lineTo(points[tj], points[tj + 1]);
+        }
+        this.renderHull(context);
+        return buffer && buffer.value();
+    }
+    renderPoints(context, r) {
+        if (r === void 0 && (!context || typeof context.moveTo !== "function"))
+            r = context, context = null;
+        r = r == void 0 ? 2 : +r;
+        const buffer = context == null ? context = new Path2() : void 0;
+        const {
+            points
+        } = this;
+        for (let i = 0, n = points.length; i < n; i += 2) {
+            const x7 = points[i],
+                y7 = points[i + 1];
+            context.moveTo(x7 + r, y7);
+            context.arc(x7, y7, r, 0, tau4);
+        }
+        return buffer && buffer.value();
+    }
+    renderHull(context) {
+        const buffer = context == null ? context = new Path2() : void 0;
+        const {
+            hull: hull3,
+            points
+        } = this;
+        const h = hull3[0] * 2,
+            n = hull3.length;
+        context.moveTo(points[h], points[h + 1]);
+        for (let i = 1; i < n; ++i) {
+            const h2 = 2 * hull3[i];
+            context.lineTo(points[h2], points[h2 + 1]);
+        }
+        context.closePath();
+        return buffer && buffer.value();
+    }
+    hullPolygon() {
+        const polygon = new Polygon();
+        this.renderHull(polygon);
+        return polygon.value();
+    }
+    renderTriangle(i, context) {
+            const buffer = context == null ? context = new Path2() : void 0;
+            const {
+                points,
+                triangles
+            } = this;
+            const t05 = triangles[i *= 3] * 2;
+            const t15 = triangles[i + 1] * 2;
+            const t23 = triangles[i + 2] * 2;
+            context.moveTo(points[t05], points[t05 + 1]);
+            context.lineTo(points[t15], points[t15 + 1]);
+            context.lineTo(points[t23], points[t23 + 1]);
+            context.closePath();
+            return buffer && buffer.value();
+        }
+        * trianglePolygons() {
+            const {
+                triangles
+            } = this;
+            for (let i = 0, n = triangles.length / 3; i < n; ++i) {
+                yield this.trianglePolygon(i);
+            }
+        }
+    trianglePolygon(i) {
+        const polygon = new Polygon();
+        this.renderTriangle(i, polygon);
+        return polygon.value();
+    }
+};
+
+function flatArray(points, fx, fy, that) {
+    const n = points.length;
+    const array7 = new Float64Array(n * 2);
+    for (let i = 0; i < n; ++i) {
+        const p = points[i];
+        array7[i * 2] = fx.call(that, p, i, points);
+        array7[i * 2 + 1] = fy.call(that, p, i, points);
+    }
+    return array7;
+}
+
+function* flatIterable(points, fx, fy, that) {
+    let i = 0;
+    for (const p of points) {
+        yield fx.call(that, p, i, points);
+        yield fy.call(that, p, i, points);
+        ++i;
+    }
+}
+
+// node_modules/d3-dsv/src/dsv.js
+var EOL = {};
+var EOF = {};
+var QUOTE = 34;
+var NEWLINE = 10;
+var RETURN = 13;
+
+function objectConverter(columns) {
+    return new Function("d", "return {" + columns.map(function(name, i) {
+        return JSON.stringify(name) + ": d[" + i + '] || ""';
+    }).join(",") + "}");
+}
+
+function customConverter(columns, f) {
+    var object3 = objectConverter(columns);
+    return function(row, i) {
+        return f(object3(row), i, columns);
+    };
+}
+
+function inferColumns(rows) {
+    var columnSet = /* @__PURE__ */ Object.create(null),
+        columns = [];
+    rows.forEach(function(row) {
+        for (var column3 in row) {
+            if (!(column3 in columnSet)) {
+                columns.push(columnSet[column3] = column3);
+            }
+        }
+    });
+    return columns;
+}
+
+function pad(value, width) {
+    var s3 = value + "",
+        length7 = s3.length;
+    return length7 < width ? new Array(width - length7 + 1).join(0) + s3 : s3;
+}
+
+function formatYear(year) {
+    return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
+}
+
+function formatDate(date3) {
+    var hours = date3.getUTCHours(),
+        minutes = date3.getUTCMinutes(),
+        seconds3 = date3.getUTCSeconds(),
+        milliseconds3 = date3.getUTCMilliseconds();
+    return isNaN(date3) ? "Invalid Date" : formatYear(date3.getUTCFullYear(), 4) + "-" + pad(date3.getUTCMonth() + 1, 2) + "-" + pad(date3.getUTCDate(), 2) + (milliseconds3 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds3, 2) + "." + pad(milliseconds3, 3) + "Z" : seconds3 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds3, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
+}
+
+function dsv_default(delimiter) {
+    var reFormat = new RegExp('["' + delimiter + "\n\r]"),
+        DELIMITER = delimiter.charCodeAt(0);
+
+    function parse3(text3, f) {
+        var convert, columns, rows = parseRows(text3, function(row, i) {
+            if (convert)
+                return convert(row, i - 1);
+            columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
+        });
+        rows.columns = columns || [];
+        return rows;
+    }
+
+    function parseRows(text3, f) {
+        var rows = [],
+            N = text3.length,
+            I = 0,
+            n = 0,
+            t, eof = N <= 0,
+            eol = false;
+        if (text3.charCodeAt(N - 1) === NEWLINE)
+            --N;
+        if (text3.charCodeAt(N - 1) === RETURN)
+            --N;
+
+        function token() {
+            if (eof)
+                return EOF;
+            if (eol)
+                return eol = false, EOL;
+            var i, j = I,
+                c11;
+            if (text3.charCodeAt(j) === QUOTE) {
+                while (I++ < N && text3.charCodeAt(I) !== QUOTE || text3.charCodeAt(++I) === QUOTE)
+                ;
+                if ((i = I) >= N)
+                    eof = true;
+                else if ((c11 = text3.charCodeAt(I++)) === NEWLINE)
+                    eol = true;
+                else if (c11 === RETURN) {
+                    eol = true;
+                    if (text3.charCodeAt(I) === NEWLINE)
+                        ++I;
+                }
+                return text3.slice(j + 1, i - 1).replace(/""/g, '"');
+            }
+            while (I < N) {
+                if ((c11 = text3.charCodeAt(i = I++)) === NEWLINE)
+                    eol = true;
+                else if (c11 === RETURN) {
+                    eol = true;
+                    if (text3.charCodeAt(I) === NEWLINE)
+                        ++I;
+                } else if (c11 !== DELIMITER)
+                    continue;
+                return text3.slice(j, i);
+            }
+            return eof = true, text3.slice(j, N);
+        }
+        while ((t = token()) !== EOF) {
+            var row = [];
+            while (t !== EOL && t !== EOF)
+                row.push(t), t = token();
+            if (f && (row = f(row, n++)) == null)
+                continue;
+            rows.push(row);
+        }
+        return rows;
+    }
+
+    function preformatBody(rows, columns) {
+        return rows.map(function(row) {
+            return columns.map(function(column3) {
+                return formatValue(row[column3]);
+            }).join(delimiter);
+        });
+    }
+
+    function format5(rows, columns) {
+        if (columns == null)
+            columns = inferColumns(rows);
+        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
+    }
+
+    function formatBody(rows, columns) {
+        if (columns == null)
+            columns = inferColumns(rows);
+        return preformatBody(rows, columns).join("\n");
+    }
+
+    function formatRows(rows) {
+        return rows.map(formatRow).join("\n");
+    }
+
+    function formatRow(row) {
+        return row.map(formatValue).join(delimiter);
+    }
+
+    function formatValue(value) {
+        return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
+    }
+    return {
+        parse: parse3,
+        parseRows,
+        format: format5,
+        formatBody,
+        formatRows,
+        formatRow,
+        formatValue
+    };
+}
+
+// node_modules/d3-dsv/src/csv.js
+var csv = dsv_default(",");
+var csvParse = csv.parse;
+var csvParseRows = csv.parseRows;
+var csvFormat = csv.format;
+var csvFormatBody = csv.formatBody;
+var csvFormatRows = csv.formatRows;
+var csvFormatRow = csv.formatRow;
+var csvFormatValue = csv.formatValue;
+
+// node_modules/d3-dsv/src/tsv.js
+var tsv = dsv_default("	");
+var tsvParse = tsv.parse;
+var tsvParseRows = tsv.parseRows;
+var tsvFormat = tsv.format;
+var tsvFormatBody = tsv.formatBody;
+var tsvFormatRows = tsv.formatRows;
+var tsvFormatRow = tsv.formatRow;
+var tsvFormatValue = tsv.formatValue;
+
+// node_modules/d3-dsv/src/autoType.js
+function autoType(object3) {
+    for (var key in object3) {
+        var value = object3[key].trim(),
+            number14, m5;
+        if (!value)
+            value = null;
+        else if (value === "true")
+            value = true;
+        else if (value === "false")
+            value = false;
+        else if (value === "NaN")
+            value = NaN;
+        else if (!isNaN(number14 = +value))
+            value = number14;
+        else if (m5 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
+            if (fixtz && !!m5[4] && !m5[7])
+                value = value.replace(/-/g, "/").replace(/T/, " ");
+            value = new Date(value);
+        } else
+            continue;
+        object3[key] = value;
+    }
+    return object3;
+}
+var fixtz = ( /* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || ( /* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();
+
+// node_modules/d3-fetch/src/blob.js
+function responseBlob(response) {
+    if (!response.ok)
+        throw new Error(response.status + " " + response.statusText);
+    return response.blob();
+}
+
+function blob_default(input, init3) {
+    return fetch(input, init3).then(responseBlob);
+}
+
+// node_modules/d3-fetch/src/buffer.js
+function responseArrayBuffer(response) {
+    if (!response.ok)
+        throw new Error(response.status + " " + response.statusText);
+    return response.arrayBuffer();
+}
+
+function buffer_default(input, init3) {
+    return fetch(input, init3).then(responseArrayBuffer);
+}
+
+// node_modules/d3-fetch/src/text.js
+function responseText(response) {
+    if (!response.ok)
+        throw new Error(response.status + " " + response.statusText);
+    return response.text();
+}
+
+function text_default3(input, init3) {
+    return fetch(input, init3).then(responseText);
+}
+
+// node_modules/d3-fetch/src/dsv.js
+function dsvParse(parse3) {
+    return function(input, init3, row) {
+        if (arguments.length === 2 && typeof init3 === "function")
+            row = init3, init3 = void 0;
+        return text_default3(input, init3).then(function(response) {
+            return parse3(response, row);
+        });
+    };
+}
+
+function dsv(delimiter, input, init3, row) {
+    if (arguments.length === 3 && typeof init3 === "function")
+        row = init3, init3 = void 0;
+    var format5 = dsv_default(delimiter);
+    return text_default3(input, init3).then(function(response) {
+        return format5.parse(response, row);
+    });
+}
+var csv2 = dsvParse(csvParse);
+var tsv2 = dsvParse(tsvParse);
+
+// node_modules/d3-fetch/src/image.js
+function image_default(input, init3) {
+    return new Promise(function(resolve, reject) {
+        var image3 = new Image();
+        for (var key in init3)
+            image3[key] = init3[key];
+        image3.onerror = reject;
+        image3.onload = function() {
+            resolve(image3);
+        };
+        image3.src = input;
+    });
+}
+
+// node_modules/d3-fetch/src/json.js
+function responseJson(response) {
+    if (!response.ok)
+        throw new Error(response.status + " " + response.statusText);
+    if (response.status === 204 || response.status === 205)
+        return;
+    return response.json();
+}
+
+function json_default(input, init3) {
+    return fetch(input, init3).then(responseJson);
+}
+
+// node_modules/d3-fetch/src/xml.js
+function parser(type3) {
+    return (input, init3) => text_default3(input, init3).then((text3) => new DOMParser().parseFromString(text3, type3));
+}
+var xml_default = parser("application/xml");
+var html = parser("text/html");
+var svg = parser("image/svg+xml");
+
+// node_modules/d3-force/src/center.js
+function center_default(x7, y7) {
+    var nodes, strength = 1;
+    if (x7 == null)
+        x7 = 0;
+    if (y7 == null)
+        y7 = 0;
+
+    function force() {
+        var i, n = nodes.length,
+            node, sx = 0,
+            sy = 0;
+        for (i = 0; i < n; ++i) {
+            node = nodes[i], sx += node.x, sy += node.y;
+        }
+        for (sx = (sx / n - x7) * strength, sy = (sy / n - y7) * strength, i = 0; i < n; ++i) {
+            node = nodes[i], node.x -= sx, node.y -= sy;
+        }
+    }
+    force.initialize = function(_) {
+        nodes = _;
+    };
+    force.x = function(_) {
+        return arguments.length ? (x7 = +_, force) : x7;
+    };
+    force.y = function(_) {
+        return arguments.length ? (y7 = +_, force) : y7;
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = +_, force) : strength;
+    };
+    return force;
+}
+
+// node_modules/d3-quadtree/src/add.js
+function add_default(d) {
+    const x7 = +this._x.call(null, d),
+        y7 = +this._y.call(null, d);
+    return add(this.cover(x7, y7), x7, y7, d);
+}
+
+function add(tree3, x7, y7, d) {
+    if (isNaN(x7) || isNaN(y7))
+        return tree3;
+    var parent, node = tree3._root,
+        leaf = {
+            data: d
+        },
+        x011 = tree3._x0,
+        y011 = tree3._y0,
+        x13 = tree3._x1,
+        y13 = tree3._y1,
+        xm, ym, xp, yp, right3, bottom3, i, j;
+    if (!node)
+        return tree3._root = leaf, tree3;
+    while (node.length) {
+        if (right3 = x7 >= (xm = (x011 + x13) / 2))
+            x011 = xm;
+        else
+            x13 = xm;
+        if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+            y011 = ym;
+        else
+            y13 = ym;
+        if (parent = node, !(node = node[i = bottom3 << 1 | right3]))
+            return parent[i] = leaf, tree3;
+    }
+    xp = +tree3._x.call(null, node.data);
+    yp = +tree3._y.call(null, node.data);
+    if (x7 === xp && y7 === yp)
+        return leaf.next = node, parent ? parent[i] = leaf : tree3._root = leaf, tree3;
+    do {
+        parent = parent ? parent[i] = new Array(4) : tree3._root = new Array(4);
+        if (right3 = x7 >= (xm = (x011 + x13) / 2))
+            x011 = xm;
+        else
+            x13 = xm;
+        if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+            y011 = ym;
+        else
+            y13 = ym;
+    } while ((i = bottom3 << 1 | right3) === (j = (yp >= ym) << 1 | xp >= xm));
+    return parent[j] = node, parent[i] = leaf, tree3;
+}
+
+function addAll(data) {
+    var d, i, n = data.length,
+        x7, y7, xz = new Array(n),
+        yz = new Array(n),
+        x011 = Infinity,
+        y011 = Infinity,
+        x13 = -Infinity,
+        y13 = -Infinity;
+    for (i = 0; i < n; ++i) {
+        if (isNaN(x7 = +this._x.call(null, d = data[i])) || isNaN(y7 = +this._y.call(null, d)))
+            continue;
+        xz[i] = x7;
+        yz[i] = y7;
+        if (x7 < x011)
+            x011 = x7;
+        if (x7 > x13)
+            x13 = x7;
+        if (y7 < y011)
+            y011 = y7;
+        if (y7 > y13)
+            y13 = y7;
+    }
+    if (x011 > x13 || y011 > y13)
+        return this;
+    this.cover(x011, y011).cover(x13, y13);
+    for (i = 0; i < n; ++i) {
+        add(this, xz[i], yz[i], data[i]);
+    }
+    return this;
+}
+
+// node_modules/d3-quadtree/src/cover.js
+function cover_default(x7, y7) {
+    if (isNaN(x7 = +x7) || isNaN(y7 = +y7))
+        return this;
+    var x011 = this._x0,
+        y011 = this._y0,
+        x13 = this._x1,
+        y13 = this._y1;
+    if (isNaN(x011)) {
+        x13 = (x011 = Math.floor(x7)) + 1;
+        y13 = (y011 = Math.floor(y7)) + 1;
+    } else {
+        var z = x13 - x011 || 1,
+            node = this._root,
+            parent, i;
+        while (x011 > x7 || x7 >= x13 || y011 > y7 || y7 >= y13) {
+            i = (y7 < y011) << 1 | x7 < x011;
+            parent = new Array(4), parent[i] = node, node = parent, z *= 2;
+            switch (i) {
+                case 0:
+                    x13 = x011 + z, y13 = y011 + z;
+                    break;
+                case 1:
+                    x011 = x13 - z, y13 = y011 + z;
+                    break;
+                case 2:
+                    x13 = x011 + z, y011 = y13 - z;
+                    break;
+                case 3:
+                    x011 = x13 - z, y011 = y13 - z;
+                    break;
+            }
+        }
+        if (this._root && this._root.length)
+            this._root = node;
+    }
+    this._x0 = x011;
+    this._y0 = y011;
+    this._x1 = x13;
+    this._y1 = y13;
+    return this;
+}
+
+// node_modules/d3-quadtree/src/data.js
+function data_default2() {
+    var data = [];
+    this.visit(function(node) {
+        if (!node.length)
+            do
+                data.push(node.data);
+            while (node = node.next);
+    });
+    return data;
+}
+
+// node_modules/d3-quadtree/src/extent.js
+function extent_default(_) {
+    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [
+        [this._x0, this._y0],
+        [this._x1, this._y1]
+    ];
+}
+
+// node_modules/d3-quadtree/src/quad.js
+function quad_default(node, x011, y011, x13, y13) {
+    this.node = node;
+    this.x0 = x011;
+    this.y0 = y011;
+    this.x1 = x13;
+    this.y1 = y13;
+}
+
+// node_modules/d3-quadtree/src/find.js
+function find_default(x7, y7, radius3) {
+    var data, x011 = this._x0,
+        y011 = this._y0,
+        x13, y13, x22, y22, x32 = this._x1,
+        y32 = this._y1,
+        quads = [],
+        node = this._root,
+        q, i;
+    if (node)
+        quads.push(new quad_default(node, x011, y011, x32, y32));
+    if (radius3 == null)
+        radius3 = Infinity;
+    else {
+        x011 = x7 - radius3, y011 = y7 - radius3;
+        x32 = x7 + radius3, y32 = y7 + radius3;
+        radius3 *= radius3;
+    }
+    while (q = quads.pop()) {
+        if (!(node = q.node) || (x13 = q.x0) > x32 || (y13 = q.y0) > y32 || (x22 = q.x1) < x011 || (y22 = q.y1) < y011)
+            continue;
+        if (node.length) {
+            var xm = (x13 + x22) / 2,
+                ym = (y13 + y22) / 2;
+            quads.push(
+                new quad_default(node[3], xm, ym, x22, y22),
+                new quad_default(node[2], x13, ym, xm, y22),
+                new quad_default(node[1], xm, y13, x22, ym),
+                new quad_default(node[0], x13, y13, xm, ym)
+            );
+            if (i = (y7 >= ym) << 1 | x7 >= xm) {
+                q = quads[quads.length - 1];
+                quads[quads.length - 1] = quads[quads.length - 1 - i];
+                quads[quads.length - 1 - i] = q;
+            }
+        } else {
+            var dx = x7 - +this._x.call(null, node.data),
+                dy = y7 - +this._y.call(null, node.data),
+                d2 = dx * dx + dy * dy;
+            if (d2 < radius3) {
+                var d = Math.sqrt(radius3 = d2);
+                x011 = x7 - d, y011 = y7 - d;
+                x32 = x7 + d, y32 = y7 + d;
+                data = node.data;
+            }
+        }
+    }
+    return data;
+}
+
+// node_modules/d3-quadtree/src/remove.js
+function remove_default3(d) {
+    if (isNaN(x7 = +this._x.call(null, d)) || isNaN(y7 = +this._y.call(null, d)))
+        return this;
+    var parent, node = this._root,
+        retainer, previous, next, x011 = this._x0,
+        y011 = this._y0,
+        x13 = this._x1,
+        y13 = this._y1,
+        x7, y7, xm, ym, right3, bottom3, i, j;
+    if (!node)
+        return this;
+    if (node.length)
+        while (true) {
+            if (right3 = x7 >= (xm = (x011 + x13) / 2))
+                x011 = xm;
+            else
+                x13 = xm;
+            if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+                y011 = ym;
+            else
+                y13 = ym;
+            if (!(parent = node, node = node[i = bottom3 << 1 | right3]))
+                return this;
+            if (!node.length)
+                break;
+            if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
+                retainer = parent, j = i;
+        }
+    while (node.data !== d)
+        if (!(previous = node, node = node.next))
+            return this;
+    if (next = node.next)
+        delete node.next;
+    if (previous)
+        return next ? previous.next = next : delete previous.next, this;
+    if (!parent)
+        return this._root = next, this;
+    next ? parent[i] = next : delete parent[i];
+    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
+        if (retainer)
+            retainer[j] = node;
+        else
+            this._root = node;
+    }
+    return this;
+}
+
+function removeAll(data) {
+    for (var i = 0, n = data.length; i < n; ++i)
+        this.remove(data[i]);
+    return this;
+}
+
+// node_modules/d3-quadtree/src/root.js
+function root_default() {
+    return this._root;
+}
+
+// node_modules/d3-quadtree/src/size.js
+function size_default2() {
+    var size = 0;
+    this.visit(function(node) {
+        if (!node.length)
+            do
+
+                ++size;
+            while (node = node.next);
+    });
+    return size;
+}
+
+// node_modules/d3-quadtree/src/visit.js
+function visit_default(callback) {
+    var quads = [],
+        q, node = this._root,
+        child, x011, y011, x13, y13;
+    if (node)
+        quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
+    while (q = quads.pop()) {
+        if (!callback(node = q.node, x011 = q.x0, y011 = q.y0, x13 = q.x1, y13 = q.y1) && node.length) {
+            var xm = (x011 + x13) / 2,
+                ym = (y011 + y13) / 2;
+            if (child = node[3])
+                quads.push(new quad_default(child, xm, ym, x13, y13));
+            if (child = node[2])
+                quads.push(new quad_default(child, x011, ym, xm, y13));
+            if (child = node[1])
+                quads.push(new quad_default(child, xm, y011, x13, ym));
+            if (child = node[0])
+                quads.push(new quad_default(child, x011, y011, xm, ym));
+        }
+    }
+    return this;
+}
+
+// node_modules/d3-quadtree/src/visitAfter.js
+function visitAfter_default(callback) {
+    var quads = [],
+        next = [],
+        q;
+    if (this._root)
+        quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
+    while (q = quads.pop()) {
+        var node = q.node;
+        if (node.length) {
+            var child, x011 = q.x0,
+                y011 = q.y0,
+                x13 = q.x1,
+                y13 = q.y1,
+                xm = (x011 + x13) / 2,
+                ym = (y011 + y13) / 2;
+            if (child = node[0])
+                quads.push(new quad_default(child, x011, y011, xm, ym));
+            if (child = node[1])
+                quads.push(new quad_default(child, xm, y011, x13, ym));
+            if (child = node[2])
+                quads.push(new quad_default(child, x011, ym, xm, y13));
+            if (child = node[3])
+                quads.push(new quad_default(child, xm, ym, x13, y13));
+        }
+        next.push(q);
+    }
+    while (q = next.pop()) {
+        callback(q.node, q.x0, q.y0, q.x1, q.y1);
+    }
+    return this;
+}
+
+// node_modules/d3-quadtree/src/x.js
+function defaultX2(d) {
+    return d[0];
+}
+
+function x_default(_) {
+    return arguments.length ? (this._x = _, this) : this._x;
+}
+
+// node_modules/d3-quadtree/src/y.js
+function defaultY2(d) {
+    return d[1];
+}
+
+function y_default(_) {
+    return arguments.length ? (this._y = _, this) : this._y;
+}
+
+// node_modules/d3-quadtree/src/quadtree.js
+function quadtree(nodes, x7, y7) {
+    var tree3 = new Quadtree(x7 == null ? defaultX2 : x7, y7 == null ? defaultY2 : y7, NaN, NaN, NaN, NaN);
+    return nodes == null ? tree3 : tree3.addAll(nodes);
+}
+
+function Quadtree(x7, y7, x011, y011, x13, y13) {
+    this._x = x7;
+    this._y = y7;
+    this._x0 = x011;
+    this._y0 = y011;
+    this._x1 = x13;
+    this._y1 = y13;
+    this._root = void 0;
+}
+
+function leaf_copy(leaf) {
+    var copy5 = {
+            data: leaf.data
+        },
+        next = copy5;
+    while (leaf = leaf.next)
+        next = next.next = {
+            data: leaf.data
+        };
+    return copy5;
+}
+var treeProto = quadtree.prototype = Quadtree.prototype;
+treeProto.copy = function() {
+    var copy5 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
+        node = this._root,
+        nodes, child;
+    if (!node)
+        return copy5;
+    if (!node.length)
+        return copy5._root = leaf_copy(node), copy5;
+    nodes = [{
+        source: node,
+        target: copy5._root = new Array(4)
+    }];
+    while (node = nodes.pop()) {
+        for (var i = 0; i < 4; ++i) {
+            if (child = node.source[i]) {
+                if (child.length)
+                    nodes.push({
+                        source: child,
+                        target: node.target[i] = new Array(4)
+                    });
+                else
+                    node.target[i] = leaf_copy(child);
+            }
+        }
+    }
+    return copy5;
+};
+treeProto.add = add_default;
+treeProto.addAll = addAll;
+treeProto.cover = cover_default;
+treeProto.data = data_default2;
+treeProto.extent = extent_default;
+treeProto.find = find_default;
+treeProto.remove = remove_default3;
+treeProto.removeAll = removeAll;
+treeProto.root = root_default;
+treeProto.size = size_default2;
+treeProto.visit = visit_default;
+treeProto.visitAfter = visitAfter_default;
+treeProto.x = x_default;
+treeProto.y = y_default;
+
+// node_modules/d3-force/src/constant.js
+function constant_default7(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// node_modules/d3-force/src/jiggle.js
+function jiggle_default(random) {
+    return (random() - 0.5) * 1e-6;
+}
+
+// node_modules/d3-force/src/collide.js
+function x(d) {
+    return d.x + d.vx;
+}
+
+function y(d) {
+    return d.y + d.vy;
+}
+
+function collide_default(radius3) {
+    var nodes, radii, random, strength = 1,
+        iterations3 = 1;
+    if (typeof radius3 !== "function")
+        radius3 = constant_default7(radius3 == null ? 1 : +radius3);
+
+    function force() {
+        var i, n = nodes.length,
+            tree3, node, xi, yi, ri, ri2;
+        for (var k3 = 0; k3 < iterations3; ++k3) {
+            tree3 = quadtree(nodes, x, y).visitAfter(prepare);
+            for (i = 0; i < n; ++i) {
+                node = nodes[i];
+                ri = radii[node.index], ri2 = ri * ri;
+                xi = node.x + node.vx;
+                yi = node.y + node.vy;
+                tree3.visit(apply3);
+            }
+        }
+
+        function apply3(quad, x011, y011, x13, y13) {
+            var data = quad.data,
+                rj = quad.r,
+                r = ri + rj;
+            if (data) {
+                if (data.index > node.index) {
+                    var x7 = xi - data.x - data.vx,
+                        y7 = yi - data.y - data.vy,
+                        l = x7 * x7 + y7 * y7;
+                    if (l < r * r) {
+                        if (x7 === 0)
+                            x7 = jiggle_default(random), l += x7 * x7;
+                        if (y7 === 0)
+                            y7 = jiggle_default(random), l += y7 * y7;
+                        l = (r - (l = Math.sqrt(l))) / l * strength;
+                        node.vx += (x7 *= l) * (r = (rj *= rj) / (ri2 + rj));
+                        node.vy += (y7 *= l) * r;
+                        data.vx -= x7 * (r = 1 - r);
+                        data.vy -= y7 * r;
+                    }
+                }
+                return;
+            }
+            return x011 > xi + r || x13 < xi - r || y011 > yi + r || y13 < yi - r;
+        }
+    }
+
+    function prepare(quad) {
+        if (quad.data)
+            return quad.r = radii[quad.data.index];
+        for (var i = quad.r = 0; i < 4; ++i) {
+            if (quad[i] && quad[i].r > quad.r) {
+                quad.r = quad[i].r;
+            }
+        }
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length,
+            node;
+        radii = new Array(n);
+        for (i = 0; i < n; ++i)
+            node = nodes[i], radii[node.index] = +radius3(node, i, nodes);
+    }
+    force.initialize = function(_nodes, _random) {
+        nodes = _nodes;
+        random = _random;
+        initialize();
+    };
+    force.iterations = function(_) {
+        return arguments.length ? (iterations3 = +_, force) : iterations3;
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = +_, force) : strength;
+    };
+    force.radius = function(_) {
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius3;
+    };
+    return force;
+}
+
+// node_modules/d3-force/src/link.js
+function index2(d) {
+    return d.index;
+}
+
+function find2(nodeById, nodeId) {
+    var node = nodeById.get(nodeId);
+    if (!node)
+        throw new Error("node not found: " + nodeId);
+    return node;
+}
+
+function link_default(links) {
+    var id3 = index2,
+        strength = defaultStrength,
+        strengths, distance = constant_default7(30),
+        distances, nodes, count5, bias, random, iterations3 = 1;
+    if (links == null)
+        links = [];
+
+    function defaultStrength(link7) {
+        return 1 / Math.min(count5[link7.source.index], count5[link7.target.index]);
+    }
+
+    function force(alpha) {
+        for (var k3 = 0, n = links.length; k3 < iterations3; ++k3) {
+            for (var i = 0, link7, source, target, x7, y7, l, b; i < n; ++i) {
+                link7 = links[i], source = link7.source, target = link7.target;
+                x7 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
+                y7 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
+                l = Math.sqrt(x7 * x7 + y7 * y7);
+                l = (l - distances[i]) / l * alpha * strengths[i];
+                x7 *= l, y7 *= l;
+                target.vx -= x7 * (b = bias[i]);
+                target.vy -= y7 * b;
+                source.vx += x7 * (b = 1 - b);
+                source.vy += y7 * b;
+            }
+        }
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length,
+            m5 = links.length,
+            nodeById = new Map(nodes.map((d, i2) => [id3(d, i2, nodes), d])),
+            link7;
+        for (i = 0, count5 = new Array(n); i < m5; ++i) {
+            link7 = links[i], link7.index = i;
+            if (typeof link7.source !== "object")
+                link7.source = find2(nodeById, link7.source);
+            if (typeof link7.target !== "object")
+                link7.target = find2(nodeById, link7.target);
+            count5[link7.source.index] = (count5[link7.source.index] || 0) + 1;
+            count5[link7.target.index] = (count5[link7.target.index] || 0) + 1;
+        }
+        for (i = 0, bias = new Array(m5); i < m5; ++i) {
+            link7 = links[i], bias[i] = count5[link7.source.index] / (count5[link7.source.index] + count5[link7.target.index]);
+        }
+        strengths = new Array(m5), initializeStrength();
+        distances = new Array(m5), initializeDistance();
+    }
+
+    function initializeStrength() {
+        if (!nodes)
+            return;
+        for (var i = 0, n = links.length; i < n; ++i) {
+            strengths[i] = +strength(links[i], i, links);
+        }
+    }
+
+    function initializeDistance() {
+        if (!nodes)
+            return;
+        for (var i = 0, n = links.length; i < n; ++i) {
+            distances[i] = +distance(links[i], i, links);
+        }
+    }
+    force.initialize = function(_nodes, _random) {
+        nodes = _nodes;
+        random = _random;
+        initialize();
+    };
+    force.links = function(_) {
+        return arguments.length ? (links = _, initialize(), force) : links;
+    };
+    force.id = function(_) {
+        return arguments.length ? (id3 = _, force) : id3;
+    };
+    force.iterations = function(_) {
+        return arguments.length ? (iterations3 = +_, force) : iterations3;
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initializeStrength(), force) : strength;
+    };
+    force.distance = function(_) {
+        return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default7(+_), initializeDistance(), force) : distance;
+    };
+    return force;
+}
+
+// node_modules/d3-force/src/lcg.js
+var a = 1664525;
+var c = 1013904223;
+var m = 4294967296;
+
+function lcg_default() {
+    let s3 = 1;
+    return () => (s3 = (a * s3 + c) % m) / m;
+}
+
+// node_modules/d3-force/src/simulation.js
+function x2(d) {
+    return d.x;
+}
+
+function y2(d) {
+    return d.y;
+}
+var initialRadius = 10;
+var initialAngle = Math.PI * (3 - Math.sqrt(5));
+
+function simulation_default(nodes) {
+    var simulation, alpha = 1,
+        alphaMin = 1e-3,
+        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
+        alphaTarget = 0,
+        velocityDecay = 0.6,
+        forces = /* @__PURE__ */ new Map(),
+        stepper = timer(step),
+        event = dispatch_default("tick", "end"),
+        random = lcg_default();
+    if (nodes == null)
+        nodes = [];
+
+    function step() {
+        tick();
+        event.call("tick", simulation);
+        if (alpha < alphaMin) {
+            stepper.stop();
+            event.call("end", simulation);
+        }
+    }
+
+    function tick(iterations3) {
+        var i, n = nodes.length,
+            node;
+        if (iterations3 === void 0)
+            iterations3 = 1;
+        for (var k3 = 0; k3 < iterations3; ++k3) {
+            alpha += (alphaTarget - alpha) * alphaDecay;
+            forces.forEach(function(force) {
+                force(alpha);
+            });
+            for (i = 0; i < n; ++i) {
+                node = nodes[i];
+                if (node.fx == null)
+                    node.x += node.vx *= velocityDecay;
+                else
+                    node.x = node.fx, node.vx = 0;
+                if (node.fy == null)
+                    node.y += node.vy *= velocityDecay;
+                else
+                    node.y = node.fy, node.vy = 0;
+            }
+        }
+        return simulation;
+    }
+
+    function initializeNodes() {
+        for (var i = 0, n = nodes.length, node; i < n; ++i) {
+            node = nodes[i], node.index = i;
+            if (node.fx != null)
+                node.x = node.fx;
+            if (node.fy != null)
+                node.y = node.fy;
+            if (isNaN(node.x) || isNaN(node.y)) {
+                var radius3 = initialRadius * Math.sqrt(0.5 + i),
+                    angle3 = i * initialAngle;
+                node.x = radius3 * Math.cos(angle3);
+                node.y = radius3 * Math.sin(angle3);
+            }
+            if (isNaN(node.vx) || isNaN(node.vy)) {
+                node.vx = node.vy = 0;
+            }
+        }
+    }
+
+    function initializeForce(force) {
+        if (force.initialize)
+            force.initialize(nodes, random);
+        return force;
+    }
+    initializeNodes();
+    return simulation = {
+        tick,
+        restart: function() {
+            return stepper.restart(step), simulation;
+        },
+        stop: function() {
+            return stepper.stop(), simulation;
+        },
+        nodes: function(_) {
+            return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
+        },
+        alpha: function(_) {
+            return arguments.length ? (alpha = +_, simulation) : alpha;
+        },
+        alphaMin: function(_) {
+            return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
+        },
+        alphaDecay: function(_) {
+            return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
+        },
+        alphaTarget: function(_) {
+            return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
+        },
+        velocityDecay: function(_) {
+            return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
+        },
+        randomSource: function(_) {
+            return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
+        },
+        force: function(name, _) {
+            return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
+        },
+        find: function(x7, y7, radius3) {
+            var i = 0,
+                n = nodes.length,
+                dx, dy, d2, node, closest;
+            if (radius3 == null)
+                radius3 = Infinity;
+            else
+                radius3 *= radius3;
+            for (i = 0; i < n; ++i) {
+                node = nodes[i];
+                dx = x7 - node.x;
+                dy = y7 - node.y;
+                d2 = dx * dx + dy * dy;
+                if (d2 < radius3)
+                    closest = node, radius3 = d2;
+            }
+            return closest;
+        },
+        on: function(name, _) {
+            return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
+        }
+    };
+}
+
+// node_modules/d3-force/src/manyBody.js
+function manyBody_default() {
+    var nodes, node, random, alpha, strength = constant_default7(-30),
+        strengths, distanceMin2 = 1,
+        distanceMax2 = Infinity,
+        theta2 = 0.81;
+
+    function force(_) {
+        var i, n = nodes.length,
+            tree3 = quadtree(nodes, x2, y2).visitAfter(accumulate);
+        for (alpha = _, i = 0; i < n; ++i)
+            node = nodes[i], tree3.visit(apply3);
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length,
+            node2;
+        strengths = new Array(n);
+        for (i = 0; i < n; ++i)
+            node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
+    }
+
+    function accumulate(quad) {
+        var strength2 = 0,
+            q, c11, weight = 0,
+            x7, y7, i;
+        if (quad.length) {
+            for (x7 = y7 = i = 0; i < 4; ++i) {
+                if ((q = quad[i]) && (c11 = Math.abs(q.value))) {
+                    strength2 += q.value, weight += c11, x7 += c11 * q.x, y7 += c11 * q.y;
+                }
+            }
+            quad.x = x7 / weight;
+            quad.y = y7 / weight;
+        } else {
+            q = quad;
+            q.x = q.data.x;
+            q.y = q.data.y;
+            do
+                strength2 += strengths[q.data.index];
+            while (q = q.next);
+        }
+        quad.value = strength2;
+    }
+
+    function apply3(quad, x13, _, x22) {
+        if (!quad.value)
+            return true;
+        var x7 = quad.x - node.x,
+            y7 = quad.y - node.y,
+            w = x22 - x13,
+            l = x7 * x7 + y7 * y7;
+        if (w * w / theta2 < l) {
+            if (l < distanceMax2) {
+                if (x7 === 0)
+                    x7 = jiggle_default(random), l += x7 * x7;
+                if (y7 === 0)
+                    y7 = jiggle_default(random), l += y7 * y7;
+                if (l < distanceMin2)
+                    l = Math.sqrt(distanceMin2 * l);
+                node.vx += x7 * quad.value * alpha / l;
+                node.vy += y7 * quad.value * alpha / l;
+            }
+            return true;
+        } else if (quad.length || l >= distanceMax2)
+            return;
+        if (quad.data !== node || quad.next) {
+            if (x7 === 0)
+                x7 = jiggle_default(random), l += x7 * x7;
+            if (y7 === 0)
+                y7 = jiggle_default(random), l += y7 * y7;
+            if (l < distanceMin2)
+                l = Math.sqrt(distanceMin2 * l);
+        }
+        do
+            if (quad.data !== node) {
+                w = strengths[quad.data.index] * alpha / l;
+                node.vx += x7 * w;
+                node.vy += y7 * w;
+            }
+        while (quad = quad.next);
+    }
+    force.initialize = function(_nodes, _random) {
+        nodes = _nodes;
+        random = _random;
+        initialize();
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+    };
+    force.distanceMin = function(_) {
+        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
+    };
+    force.distanceMax = function(_) {
+        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
+    };
+    force.theta = function(_) {
+        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
+    };
+    return force;
+}
+
+// node_modules/d3-force/src/radial.js
+function radial_default(radius3, x7, y7) {
+    var nodes, strength = constant_default7(0.1),
+        strengths, radiuses;
+    if (typeof radius3 !== "function")
+        radius3 = constant_default7(+radius3);
+    if (x7 == null)
+        x7 = 0;
+    if (y7 == null)
+        y7 = 0;
+
+    function force(alpha) {
+        for (var i = 0, n = nodes.length; i < n; ++i) {
+            var node = nodes[i],
+                dx = node.x - x7 || 1e-6,
+                dy = node.y - y7 || 1e-6,
+                r = Math.sqrt(dx * dx + dy * dy),
+                k3 = (radiuses[i] - r) * strengths[i] * alpha / r;
+            node.vx += dx * k3;
+            node.vy += dy * k3;
+        }
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length;
+        strengths = new Array(n);
+        radiuses = new Array(n);
+        for (i = 0; i < n; ++i) {
+            radiuses[i] = +radius3(nodes[i], i, nodes);
+            strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
+        }
+    }
+    force.initialize = function(_) {
+        nodes = _, initialize();
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+    };
+    force.radius = function(_) {
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius3;
+    };
+    force.x = function(_) {
+        return arguments.length ? (x7 = +_, force) : x7;
+    };
+    force.y = function(_) {
+        return arguments.length ? (y7 = +_, force) : y7;
+    };
+    return force;
+}
+
+// node_modules/d3-force/src/x.js
+function x_default2(x7) {
+    var strength = constant_default7(0.1),
+        nodes, strengths, xz;
+    if (typeof x7 !== "function")
+        x7 = constant_default7(x7 == null ? 0 : +x7);
+
+    function force(alpha) {
+        for (var i = 0, n = nodes.length, node; i < n; ++i) {
+            node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
+        }
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length;
+        strengths = new Array(n);
+        xz = new Array(n);
+        for (i = 0; i < n; ++i) {
+            strengths[i] = isNaN(xz[i] = +x7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
+        }
+    }
+    force.initialize = function(_) {
+        nodes = _;
+        initialize();
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+    };
+    force.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : x7;
+    };
+    return force;
+}
+
+// node_modules/d3-force/src/y.js
+function y_default2(y7) {
+    var strength = constant_default7(0.1),
+        nodes, strengths, yz;
+    if (typeof y7 !== "function")
+        y7 = constant_default7(y7 == null ? 0 : +y7);
+
+    function force(alpha) {
+        for (var i = 0, n = nodes.length, node; i < n; ++i) {
+            node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
+        }
+    }
+
+    function initialize() {
+        if (!nodes)
+            return;
+        var i, n = nodes.length;
+        strengths = new Array(n);
+        yz = new Array(n);
+        for (i = 0; i < n; ++i) {
+            strengths[i] = isNaN(yz[i] = +y7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
+        }
+    }
+    force.initialize = function(_) {
+        nodes = _;
+        initialize();
+    };
+    force.strength = function(_) {
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+    };
+    force.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : y7;
+    };
+    return force;
+}
+
+// node_modules/d3-format/src/formatDecimal.js
+function formatDecimal_default(x7) {
+    return Math.abs(x7 = Math.round(x7)) >= 1e21 ? x7.toLocaleString("en").replace(/,/g, "") : x7.toString(10);
+}
+
+function formatDecimalParts(x7, p) {
+    if ((i = (x7 = p ? x7.toExponential(p - 1) : x7.toExponential()).indexOf("e")) < 0)
+        return null;
+    var i, coefficient = x7.slice(0, i);
+    return [
+        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
+        +x7.slice(i + 1)
+    ];
+}
+
+// node_modules/d3-format/src/exponent.js
+function exponent_default(x7) {
+    return x7 = formatDecimalParts(Math.abs(x7)), x7 ? x7[1] : NaN;
+}
+
+// node_modules/d3-format/src/formatGroup.js
+function formatGroup_default(grouping, thousands) {
+    return function(value, width) {
+        var i = value.length,
+            t = [],
+            j = 0,
+            g = grouping[0],
+            length7 = 0;
+        while (i > 0 && g > 0) {
+            if (length7 + g + 1 > width)
+                g = Math.max(1, width - length7);
+            t.push(value.substring(i -= g, i + g));
+            if ((length7 += g + 1) > width)
+                break;
+            g = grouping[j = (j + 1) % grouping.length];
+        }
+        return t.reverse().join(thousands);
+    };
+}
+
+// node_modules/d3-format/src/formatNumerals.js
+function formatNumerals_default(numerals) {
+    return function(value) {
+        return value.replace(/[0-9]/g, function(i) {
+            return numerals[+i];
+        });
+    };
+}
+
+// node_modules/d3-format/src/formatSpecifier.js
+var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+
+function formatSpecifier(specifier) {
+    if (!(match = re.exec(specifier)))
+        throw new Error("invalid format: " + specifier);
+    var match;
+    return new FormatSpecifier({
+        fill: match[1],
+        align: match[2],
+        sign: match[3],
+        symbol: match[4],
+        zero: match[5],
+        width: match[6],
+        comma: match[7],
+        precision: match[8] && match[8].slice(1),
+        trim: match[9],
+        type: match[10]
+    });
+}
+formatSpecifier.prototype = FormatSpecifier.prototype;
+
+function FormatSpecifier(specifier) {
+    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
+    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
+    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
+    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
+    this.zero = !!specifier.zero;
+    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
+    this.comma = !!specifier.comma;
+    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
+    this.trim = !!specifier.trim;
+    this.type = specifier.type === void 0 ? "" : specifier.type + "";
+}
+FormatSpecifier.prototype.toString = function() {
+    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
+};
+
+// node_modules/d3-format/src/formatTrim.js
+function formatTrim_default(s3) {
+    out: for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
+        switch (s3[i]) {
+            case ".":
+                i0 = i1 = i;
+                break;
+            case "0":
+                if (i0 === 0)
+                    i0 = i;
+                i1 = i;
+                break;
+            default:
+                if (!+s3[i])
+                    break out;
+                if (i0 > 0)
+                    i0 = 0;
+                break;
+        }
+    }
+    return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
+}
+
+// node_modules/d3-format/src/formatPrefixAuto.js
+var prefixExponent;
+
+function formatPrefixAuto_default(x7, p) {
+    var d = formatDecimalParts(x7, p);
+    if (!d)
+        return x7 + "";
+    var coefficient = d[0],
+        exponent3 = d[1],
+        i = exponent3 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent3 / 3))) * 3) + 1,
+        n = coefficient.length;
+    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x7, Math.max(0, p + i - 1))[0];
+}
+
+// node_modules/d3-format/src/formatRounded.js
+function formatRounded_default(x7, p) {
+    var d = formatDecimalParts(x7, p);
+    if (!d)
+        return x7 + "";
+    var coefficient = d[0],
+        exponent3 = d[1];
+    return exponent3 < 0 ? "0." + new Array(-exponent3).join("0") + coefficient : coefficient.length > exponent3 + 1 ? coefficient.slice(0, exponent3 + 1) + "." + coefficient.slice(exponent3 + 1) : coefficient + new Array(exponent3 - coefficient.length + 2).join("0");
+}
+
+// node_modules/d3-format/src/formatTypes.js
+var formatTypes_default = {
+    "%": (x7, p) => (x7 * 100).toFixed(p),
+    "b": (x7) => Math.round(x7).toString(2),
+    "c": (x7) => x7 + "",
+    "d": formatDecimal_default,
+    "e": (x7, p) => x7.toExponential(p),
+    "f": (x7, p) => x7.toFixed(p),
+    "g": (x7, p) => x7.toPrecision(p),
+    "o": (x7) => Math.round(x7).toString(8),
+    "p": (x7, p) => formatRounded_default(x7 * 100, p),
+    "r": formatRounded_default,
+    "s": formatPrefixAuto_default,
+    "X": (x7) => Math.round(x7).toString(16).toUpperCase(),
+    "x": (x7) => Math.round(x7).toString(16)
+};
+
+// node_modules/d3-format/src/identity.js
+function identity_default2(x7) {
+    return x7;
+}
+
+// node_modules/d3-format/src/locale.js
+var map3 = Array.prototype.map;
+var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
+
+function locale_default(locale5) {
+    var group5 = locale5.grouping === void 0 || locale5.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale5.grouping, Number), locale5.thousands + ""),
+        currencyPrefix = locale5.currency === void 0 ? "" : locale5.currency[0] + "",
+        currencySuffix = locale5.currency === void 0 ? "" : locale5.currency[1] + "",
+        decimal = locale5.decimal === void 0 ? "." : locale5.decimal + "",
+        numerals = locale5.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale5.numerals, String)),
+        percent = locale5.percent === void 0 ? "%" : locale5.percent + "",
+        minus = locale5.minus === void 0 ? "\u2212" : locale5.minus + "",
+        nan = locale5.nan === void 0 ? "NaN" : locale5.nan + "";
+
+    function newFormat(specifier) {
+        specifier = formatSpecifier(specifier);
+        var fill = specifier.fill,
+            align = specifier.align,
+            sign5 = specifier.sign,
+            symbol3 = specifier.symbol,
+            zero5 = specifier.zero,
+            width = specifier.width,
+            comma = specifier.comma,
+            precision = specifier.precision,
+            trim = specifier.trim,
+            type3 = specifier.type;
+        if (type3 === "n")
+            comma = true, type3 = "g";
+        else if (!formatTypes_default[type3])
+            precision === void 0 && (precision = 12), trim = true, type3 = "g";
+        if (zero5 || fill === "0" && align === "=")
+            zero5 = true, fill = "0", align = "=";
+        var prefix = symbol3 === "$" ? currencyPrefix : symbol3 === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "",
+            suffix = symbol3 === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
+        var formatType = formatTypes_default[type3],
+            maybeSuffix = /[defgprs%]/.test(type3);
+        precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
+
+        function format5(value) {
+            var valuePrefix = prefix,
+                valueSuffix = suffix,
+                i, n, c11;
+            if (type3 === "c") {
+                valueSuffix = formatType(value) + valueSuffix;
+                value = "";
+            } else {
+                value = +value;
+                var valueNegative = value < 0 || 1 / value < 0;
+                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
+                if (trim)
+                    value = formatTrim_default(value);
+                if (valueNegative && +value === 0 && sign5 !== "+")
+                    valueNegative = false;
+                valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
+                valueSuffix = (type3 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
+                if (maybeSuffix) {
+                    i = -1, n = value.length;
+                    while (++i < n) {
+                        if (c11 = value.charCodeAt(i), 48 > c11 || c11 > 57) {
+                            valueSuffix = (c11 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
+                            value = value.slice(0, i);
+                            break;
+                        }
+                    }
+                }
+            }
+            if (comma && !zero5)
+                value = group5(value, Infinity);
+            var length7 = valuePrefix.length + value.length + valueSuffix.length,
+                padding = length7 < width ? new Array(width - length7 + 1).join(fill) : "";
+            if (comma && zero5)
+                value = group5(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
+            switch (align) {
+                case "<":
+                    value = valuePrefix + value + valueSuffix + padding;
+                    break;
+                case "=":
+                    value = valuePrefix + padding + value + valueSuffix;
+                    break;
+                case "^":
+                    value = padding.slice(0, length7 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length7);
+                    break;
+                default:
+                    value = padding + valuePrefix + value + valueSuffix;
+                    break;
+            }
+            return numerals(value);
+        }
+        format5.toString = function() {
+            return specifier + "";
+        };
+        return format5;
+    }
+
+    function formatPrefix3(specifier, value) {
+        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
+            e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3,
+            k3 = Math.pow(10, -e),
+            prefix = prefixes[8 + e / 3];
+        return function(value2) {
+            return f(k3 * value2) + prefix;
+        };
+    }
+    return {
+        format: newFormat,
+        formatPrefix: formatPrefix3
+    };
+}
+
+// node_modules/d3-format/src/defaultLocale.js
+var locale;
+var format;
+var formatPrefix;
+defaultLocale({
+    thousands: ",",
+    grouping: [3],
+    currency: ["$", ""]
+});
+
+function defaultLocale(definition) {
+    locale = locale_default(definition);
+    format = locale.format;
+    formatPrefix = locale.formatPrefix;
+    return locale;
+}
+
+// node_modules/d3-format/src/precisionFixed.js
+function precisionFixed_default(step) {
+    return Math.max(0, -exponent_default(Math.abs(step)));
+}
+
+// node_modules/d3-format/src/precisionPrefix.js
+function precisionPrefix_default(step, value) {
+    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
+}
+
+// node_modules/d3-format/src/precisionRound.js
+function precisionRound_default(step, max9) {
+    step = Math.abs(step), max9 = Math.abs(max9) - step;
+    return Math.max(0, exponent_default(max9) - exponent_default(step)) + 1;
+}
+
+// node_modules/d3-geo/src/math.js
+var epsilon7 = 1e-6;
+var epsilon22 = 1e-12;
+var pi4 = Math.PI;
+var halfPi3 = pi4 / 2;
+var quarterPi = pi4 / 4;
+var tau5 = pi4 * 2;
+var degrees3 = 180 / pi4;
+var radians2 = pi4 / 180;
+var abs3 = Math.abs;
+var atan = Math.atan;
+var atan2 = Math.atan2;
+var cos2 = Math.cos;
+var ceil = Math.ceil;
+var exp = Math.exp;
+var hypot = Math.hypot;
+var log = Math.log;
+var pow2 = Math.pow;
+var sin2 = Math.sin;
+var sign = Math.sign || function(x7) {
+    return x7 > 0 ? 1 : x7 < 0 ? -1 : 0;
+};
+var sqrt = Math.sqrt;
+var tan = Math.tan;
+
+function acos(x7) {
+    return x7 > 1 ? 0 : x7 < -1 ? pi4 : Math.acos(x7);
+}
+
+function asin(x7) {
+    return x7 > 1 ? halfPi3 : x7 < -1 ? -halfPi3 : Math.asin(x7);
+}
+
+function haversin(x7) {
+    return (x7 = sin2(x7 / 2)) * x7;
+}
+
+// node_modules/d3-geo/src/noop.js
+function noop2() {}
+
+// node_modules/d3-geo/src/stream.js
+function streamGeometry(geometry, stream) {
+    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
+        streamGeometryType[geometry.type](geometry, stream);
+    }
+}
+var streamObjectType = {
+    Feature: function(object3, stream) {
+        streamGeometry(object3.geometry, stream);
+    },
+    FeatureCollection: function(object3, stream) {
+        var features = object3.features,
+            i = -1,
+            n = features.length;
+        while (++i < n)
+            streamGeometry(features[i].geometry, stream);
+    }
+};
+var streamGeometryType = {
+    Sphere: function(object3, stream) {
+        stream.sphere();
+    },
+    Point: function(object3, stream) {
+        object3 = object3.coordinates;
+        stream.point(object3[0], object3[1], object3[2]);
+    },
+    MultiPoint: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            object3 = coordinates3[i], stream.point(object3[0], object3[1], object3[2]);
+    },
+    LineString: function(object3, stream) {
+        streamLine(object3.coordinates, stream, 0);
+    },
+    MultiLineString: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            streamLine(coordinates3[i], stream, 0);
+    },
+    Polygon: function(object3, stream) {
+        streamPolygon(object3.coordinates, stream);
+    },
+    MultiPolygon: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            streamPolygon(coordinates3[i], stream);
+    },
+    GeometryCollection: function(object3, stream) {
+        var geometries = object3.geometries,
+            i = -1,
+            n = geometries.length;
+        while (++i < n)
+            streamGeometry(geometries[i], stream);
+    }
+};
+
+function streamLine(coordinates3, stream, closed) {
+    var i = -1,
+        n = coordinates3.length - closed,
+        coordinate;
+    stream.lineStart();
+    while (++i < n)
+        coordinate = coordinates3[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
+    stream.lineEnd();
+}
+
+function streamPolygon(coordinates3, stream) {
+    var i = -1,
+        n = coordinates3.length;
+    stream.polygonStart();
+    while (++i < n)
+        streamLine(coordinates3[i], stream, 1);
+    stream.polygonEnd();
+}
+
+function stream_default(object3, stream) {
+    if (object3 && streamObjectType.hasOwnProperty(object3.type)) {
+        streamObjectType[object3.type](object3, stream);
+    } else {
+        streamGeometry(object3, stream);
+    }
+}
+
+// node_modules/d3-geo/src/area.js
+var areaRingSum = new Adder();
+var areaSum = new Adder();
+var lambda00;
+var phi00;
+var lambda0;
+var cosPhi0;
+var sinPhi0;
+var areaStream = {
+    point: noop2,
+    lineStart: noop2,
+    lineEnd: noop2,
+    polygonStart: function() {
+        areaRingSum = new Adder();
+        areaStream.lineStart = areaRingStart;
+        areaStream.lineEnd = areaRingEnd;
+    },
+    polygonEnd: function() {
+        var areaRing = +areaRingSum;
+        areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);
+        this.lineStart = this.lineEnd = this.point = noop2;
+    },
+    sphere: function() {
+        areaSum.add(tau5);
+    }
+};
+
+function areaRingStart() {
+    areaStream.point = areaPointFirst;
+}
+
+function areaRingEnd() {
+    areaPoint(lambda00, phi00);
+}
+
+function areaPointFirst(lambda, phi3) {
+    areaStream.point = areaPoint;
+    lambda00 = lambda, phi00 = phi3;
+    lambda *= radians2, phi3 *= radians2;
+    lambda0 = lambda, cosPhi0 = cos2(phi3 = phi3 / 2 + quarterPi), sinPhi0 = sin2(phi3);
+}
+
+function areaPoint(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    phi3 = phi3 / 2 + quarterPi;
+    var dLambda = lambda - lambda0,
+        sdLambda = dLambda >= 0 ? 1 : -1,
+        adLambda = sdLambda * dLambda,
+        cosPhi = cos2(phi3),
+        sinPhi = sin2(phi3),
+        k3 = sinPhi0 * sinPhi,
+        u7 = cosPhi0 * cosPhi + k3 * cos2(adLambda),
+        v3 = k3 * sdLambda * sin2(adLambda);
+    areaRingSum.add(atan2(v3, u7));
+    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
+}
+
+function area_default2(object3) {
+    areaSum = new Adder();
+    stream_default(object3, areaStream);
+    return areaSum * 2;
+}
+
+// node_modules/d3-geo/src/cartesian.js
+function spherical(cartesian3) {
+    return [atan2(cartesian3[1], cartesian3[0]), asin(cartesian3[2])];
+}
+
+function cartesian(spherical3) {
+    var lambda = spherical3[0],
+        phi3 = spherical3[1],
+        cosPhi = cos2(phi3);
+    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi3)];
+}
+
+function cartesianDot(a7, b) {
+    return a7[0] * b[0] + a7[1] * b[1] + a7[2] * b[2];
+}
+
+function cartesianCross(a7, b) {
+    return [a7[1] * b[2] - a7[2] * b[1], a7[2] * b[0] - a7[0] * b[2], a7[0] * b[1] - a7[1] * b[0]];
+}
+
+function cartesianAddInPlace(a7, b) {
+    a7[0] += b[0], a7[1] += b[1], a7[2] += b[2];
+}
+
+function cartesianScale(vector3, k3) {
+    return [vector3[0] * k3, vector3[1] * k3, vector3[2] * k3];
+}
+
+function cartesianNormalizeInPlace(d) {
+    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
+    d[0] /= l, d[1] /= l, d[2] /= l;
+}
+
+// node_modules/d3-geo/src/bounds.js
+var lambda02;
+var phi0;
+var lambda1;
+var phi1;
+var lambda2;
+var lambda002;
+var phi002;
+var p0;
+var deltaSum;
+var ranges;
+var range3;
+var boundsStream = {
+    point: boundsPoint,
+    lineStart: boundsLineStart,
+    lineEnd: boundsLineEnd,
+    polygonStart: function() {
+        boundsStream.point = boundsRingPoint;
+        boundsStream.lineStart = boundsRingStart;
+        boundsStream.lineEnd = boundsRingEnd;
+        deltaSum = new Adder();
+        areaStream.polygonStart();
+    },
+    polygonEnd: function() {
+        areaStream.polygonEnd();
+        boundsStream.point = boundsPoint;
+        boundsStream.lineStart = boundsLineStart;
+        boundsStream.lineEnd = boundsLineEnd;
+        if (areaRingSum < 0)
+            lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
+        else if (deltaSum > epsilon7)
+            phi1 = 90;
+        else if (deltaSum < -epsilon7)
+            phi0 = -90;
+        range3[0] = lambda02, range3[1] = lambda1;
+    },
+    sphere: function() {
+        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
+    }
+};
+
+function boundsPoint(lambda, phi3) {
+    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
+    if (phi3 < phi0)
+        phi0 = phi3;
+    if (phi3 > phi1)
+        phi1 = phi3;
+}
+
+function linePoint(lambda, phi3) {
+    var p = cartesian([lambda * radians2, phi3 * radians2]);
+    if (p0) {
+        var normal = cartesianCross(p0, p),
+            equatorial = [normal[1], -normal[0], 0],
+            inflection = cartesianCross(equatorial, normal);
+        cartesianNormalizeInPlace(inflection);
+        inflection = spherical(inflection);
+        var delta = lambda - lambda2,
+            sign5 = delta > 0 ? 1 : -1,
+            lambdai = inflection[0] * degrees3 * sign5,
+            phii, antimeridian = abs3(delta) > 180;
+        if (antimeridian ^ (sign5 * lambda2 < lambdai && lambdai < sign5 * lambda)) {
+            phii = inflection[1] * degrees3;
+            if (phii > phi1)
+                phi1 = phii;
+        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign5 * lambda2 < lambdai && lambdai < sign5 * lambda)) {
+            phii = -inflection[1] * degrees3;
+            if (phii < phi0)
+                phi0 = phii;
+        } else {
+            if (phi3 < phi0)
+                phi0 = phi3;
+            if (phi3 > phi1)
+                phi1 = phi3;
+        }
+        if (antimeridian) {
+            if (lambda < lambda2) {
+                if (angle(lambda02, lambda) > angle(lambda02, lambda1))
+                    lambda1 = lambda;
+            } else {
+                if (angle(lambda, lambda1) > angle(lambda02, lambda1))
+                    lambda02 = lambda;
+            }
+        } else {
+            if (lambda1 >= lambda02) {
+                if (lambda < lambda02)
+                    lambda02 = lambda;
+                if (lambda > lambda1)
+                    lambda1 = lambda;
+            } else {
+                if (lambda > lambda2) {
+                    if (angle(lambda02, lambda) > angle(lambda02, lambda1))
+                        lambda1 = lambda;
+                } else {
+                    if (angle(lambda, lambda1) > angle(lambda02, lambda1))
+                        lambda02 = lambda;
+                }
+            }
+        }
+    } else {
+        ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
+    }
+    if (phi3 < phi0)
+        phi0 = phi3;
+    if (phi3 > phi1)
+        phi1 = phi3;
+    p0 = p, lambda2 = lambda;
+}
+
+function boundsLineStart() {
+    boundsStream.point = linePoint;
+}
+
+function boundsLineEnd() {
+    range3[0] = lambda02, range3[1] = lambda1;
+    boundsStream.point = boundsPoint;
+    p0 = null;
+}
+
+function boundsRingPoint(lambda, phi3) {
+    if (p0) {
+        var delta = lambda - lambda2;
+        deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
+    } else {
+        lambda002 = lambda, phi002 = phi3;
+    }
+    areaStream.point(lambda, phi3);
+    linePoint(lambda, phi3);
+}
+
+function boundsRingStart() {
+    areaStream.lineStart();
+}
+
+function boundsRingEnd() {
+    boundsRingPoint(lambda002, phi002);
+    areaStream.lineEnd();
+    if (abs3(deltaSum) > epsilon7)
+        lambda02 = -(lambda1 = 180);
+    range3[0] = lambda02, range3[1] = lambda1;
+    p0 = null;
+}
+
+function angle(lambda07, lambda13) {
+    return (lambda13 -= lambda07) < 0 ? lambda13 + 360 : lambda13;
+}
+
+function rangeCompare(a7, b) {
+    return a7[0] - b[0];
+}
+
+function rangeContains(range9, x7) {
+    return range9[0] <= range9[1] ? range9[0] <= x7 && x7 <= range9[1] : x7 < range9[0] || range9[1] < x7;
+}
+
+function bounds_default(feature) {
+    var i, n, a7, b, merged, deltaMax, delta;
+    phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
+    ranges = [];
+    stream_default(feature, boundsStream);
+    if (n = ranges.length) {
+        ranges.sort(rangeCompare);
+        for (i = 1, a7 = ranges[0], merged = [a7]; i < n; ++i) {
+            b = ranges[i];
+            if (rangeContains(a7, b[0]) || rangeContains(a7, b[1])) {
+                if (angle(a7[0], b[1]) > angle(a7[0], a7[1]))
+                    a7[1] = b[1];
+                if (angle(b[0], a7[1]) > angle(a7[0], a7[1]))
+                    a7[0] = b[0];
+            } else {
+                merged.push(a7 = b);
+            }
+        }
+        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a7 = merged[n]; i <= n; a7 = b, ++i) {
+            b = merged[i];
+            if ((delta = angle(a7[1], b[0])) > deltaMax)
+                deltaMax = delta, lambda02 = b[0], lambda1 = a7[1];
+        }
+    }
+    ranges = range3 = null;
+    return lambda02 === Infinity || phi0 === Infinity ? [
+        [NaN, NaN],
+        [NaN, NaN]
+    ] : [
+        [lambda02, phi0],
+        [lambda1, phi1]
+    ];
+}
+
+// node_modules/d3-geo/src/centroid.js
+var W0;
+var W1;
+var X0;
+var Y0;
+var Z0;
+var X1;
+var Y1;
+var Z1;
+var X2;
+var Y2;
+var Z2;
+var lambda003;
+var phi003;
+var x0;
+var y0;
+var z0;
+var centroidStream = {
+    sphere: noop2,
+    point: centroidPoint,
+    lineStart: centroidLineStart,
+    lineEnd: centroidLineEnd,
+    polygonStart: function() {
+        centroidStream.lineStart = centroidRingStart;
+        centroidStream.lineEnd = centroidRingEnd;
+    },
+    polygonEnd: function() {
+        centroidStream.lineStart = centroidLineStart;
+        centroidStream.lineEnd = centroidLineEnd;
+    }
+};
+
+function centroidPoint(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    var cosPhi = cos2(phi3);
+    centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi3));
+}
+
+function centroidPointCartesian(x7, y7, z) {
+    ++W0;
+    X0 += (x7 - X0) / W0;
+    Y0 += (y7 - Y0) / W0;
+    Z0 += (z - Z0) / W0;
+}
+
+function centroidLineStart() {
+    centroidStream.point = centroidLinePointFirst;
+}
+
+function centroidLinePointFirst(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    var cosPhi = cos2(phi3);
+    x0 = cosPhi * cos2(lambda);
+    y0 = cosPhi * sin2(lambda);
+    z0 = sin2(phi3);
+    centroidStream.point = centroidLinePoint;
+    centroidPointCartesian(x0, y0, z0);
+}
+
+function centroidLinePoint(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    var cosPhi = cos2(phi3),
+        x7 = cosPhi * cos2(lambda),
+        y7 = cosPhi * sin2(lambda),
+        z = sin2(phi3),
+        w = atan2(sqrt((w = y0 * z - z0 * y7) * w + (w = z0 * x7 - x0 * z) * w + (w = x0 * y7 - y0 * x7) * w), x0 * x7 + y0 * y7 + z0 * z);
+    W1 += w;
+    X1 += w * (x0 + (x0 = x7));
+    Y1 += w * (y0 + (y0 = y7));
+    Z1 += w * (z0 + (z0 = z));
+    centroidPointCartesian(x0, y0, z0);
+}
+
+function centroidLineEnd() {
+    centroidStream.point = centroidPoint;
+}
+
+function centroidRingStart() {
+    centroidStream.point = centroidRingPointFirst;
+}
+
+function centroidRingEnd() {
+    centroidRingPoint(lambda003, phi003);
+    centroidStream.point = centroidPoint;
+}
+
+function centroidRingPointFirst(lambda, phi3) {
+    lambda003 = lambda, phi003 = phi3;
+    lambda *= radians2, phi3 *= radians2;
+    centroidStream.point = centroidRingPoint;
+    var cosPhi = cos2(phi3);
+    x0 = cosPhi * cos2(lambda);
+    y0 = cosPhi * sin2(lambda);
+    z0 = sin2(phi3);
+    centroidPointCartesian(x0, y0, z0);
+}
+
+function centroidRingPoint(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    var cosPhi = cos2(phi3),
+        x7 = cosPhi * cos2(lambda),
+        y7 = cosPhi * sin2(lambda),
+        z = sin2(phi3),
+        cx = y0 * z - z0 * y7,
+        cy = z0 * x7 - x0 * z,
+        cz = x0 * y7 - y0 * x7,
+        m5 = hypot(cx, cy, cz),
+        w = asin(m5),
+        v3 = m5 && -w / m5;
+    X2.add(v3 * cx);
+    Y2.add(v3 * cy);
+    Z2.add(v3 * cz);
+    W1 += w;
+    X1 += w * (x0 + (x0 = x7));
+    Y1 += w * (y0 + (y0 = y7));
+    Z1 += w * (z0 + (z0 = z));
+    centroidPointCartesian(x0, y0, z0);
+}
+
+function centroid_default(object3) {
+    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
+    X2 = new Adder();
+    Y2 = new Adder();
+    Z2 = new Adder();
+    stream_default(object3, centroidStream);
+    var x7 = +X2,
+        y7 = +Y2,
+        z = +Z2,
+        m5 = hypot(x7, y7, z);
+    if (m5 < epsilon22) {
+        x7 = X1, y7 = Y1, z = Z1;
+        if (W1 < epsilon7)
+            x7 = X0, y7 = Y0, z = Z0;
+        m5 = hypot(x7, y7, z);
+        if (m5 < epsilon22)
+            return [NaN, NaN];
+    }
+    return [atan2(y7, x7) * degrees3, asin(z / m5) * degrees3];
+}
+
+// node_modules/d3-geo/src/constant.js
+function constant_default8(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// node_modules/d3-geo/src/compose.js
+function compose_default(a7, b) {
+    function compose(x7, y7) {
+        return x7 = a7(x7, y7), b(x7[0], x7[1]);
+    }
+    if (a7.invert && b.invert)
+        compose.invert = function(x7, y7) {
+            return x7 = b.invert(x7, y7), x7 && a7.invert(x7[0], x7[1]);
+        };
+    return compose;
+}
+
+// node_modules/d3-geo/src/rotation.js
+function rotationIdentity(lambda, phi3) {
+    if (abs3(lambda) > pi4)
+        lambda -= Math.round(lambda / tau5) * tau5;
+    return [lambda, phi3];
+}
+rotationIdentity.invert = rotationIdentity;
+
+function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
+    return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
+}
+
+function forwardRotationLambda(deltaLambda) {
+    return function(lambda, phi3) {
+        lambda += deltaLambda;
+        if (abs3(lambda) > pi4)
+            lambda -= Math.round(lambda / tau5) * tau5;
+        return [lambda, phi3];
+    };
+}
+
+function rotationLambda(deltaLambda) {
+    var rotation = forwardRotationLambda(deltaLambda);
+    rotation.invert = forwardRotationLambda(-deltaLambda);
+    return rotation;
+}
+
+function rotationPhiGamma(deltaPhi, deltaGamma) {
+    var cosDeltaPhi = cos2(deltaPhi),
+        sinDeltaPhi = sin2(deltaPhi),
+        cosDeltaGamma = cos2(deltaGamma),
+        sinDeltaGamma = sin2(deltaGamma);
+
+    function rotation(lambda, phi3) {
+        var cosPhi = cos2(phi3),
+            x7 = cos2(lambda) * cosPhi,
+            y7 = sin2(lambda) * cosPhi,
+            z = sin2(phi3),
+            k3 = z * cosDeltaPhi + x7 * sinDeltaPhi;
+        return [
+            atan2(y7 * cosDeltaGamma - k3 * sinDeltaGamma, x7 * cosDeltaPhi - z * sinDeltaPhi),
+            asin(k3 * cosDeltaGamma + y7 * sinDeltaGamma)
+        ];
+    }
+    rotation.invert = function(lambda, phi3) {
+        var cosPhi = cos2(phi3),
+            x7 = cos2(lambda) * cosPhi,
+            y7 = sin2(lambda) * cosPhi,
+            z = sin2(phi3),
+            k3 = z * cosDeltaGamma - y7 * sinDeltaGamma;
+        return [
+            atan2(y7 * cosDeltaGamma + z * sinDeltaGamma, x7 * cosDeltaPhi + k3 * sinDeltaPhi),
+            asin(k3 * cosDeltaPhi - x7 * sinDeltaPhi)
+        ];
+    };
+    return rotation;
+}
+
+function rotation_default(rotate) {
+    rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
+
+    function forward(coordinates3) {
+        coordinates3 = rotate(coordinates3[0] * radians2, coordinates3[1] * radians2);
+        return coordinates3[0] *= degrees3, coordinates3[1] *= degrees3, coordinates3;
+    }
+    forward.invert = function(coordinates3) {
+        coordinates3 = rotate.invert(coordinates3[0] * radians2, coordinates3[1] * radians2);
+        return coordinates3[0] *= degrees3, coordinates3[1] *= degrees3, coordinates3;
+    };
+    return forward;
+}
+
+// node_modules/d3-geo/src/circle.js
+function circleStream(stream, radius3, delta, direction, t05, t15) {
+    if (!delta)
+        return;
+    var cosRadius = cos2(radius3),
+        sinRadius = sin2(radius3),
+        step = direction * delta;
+    if (t05 == null) {
+        t05 = radius3 + direction * tau5;
+        t15 = radius3 - step / 2;
+    } else {
+        t05 = circleRadius(cosRadius, t05);
+        t15 = circleRadius(cosRadius, t15);
+        if (direction > 0 ? t05 < t15 : t05 > t15)
+            t05 += direction * tau5;
+    }
+    for (var point11, t = t05; direction > 0 ? t > t15 : t < t15; t -= step) {
+        point11 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
+        stream.point(point11[0], point11[1]);
+    }
+}
+
+function circleRadius(cosRadius, point11) {
+    point11 = cartesian(point11), point11[0] -= cosRadius;
+    cartesianNormalizeInPlace(point11);
+    var radius3 = acos(-point11[1]);
+    return ((-point11[2] < 0 ? -radius3 : radius3) + tau5 - epsilon7) % tau5;
+}
+
+function circle_default() {
+    var center3 = constant_default8([0, 0]),
+        radius3 = constant_default8(90),
+        precision = constant_default8(6),
+        ring, rotate, stream = {
+            point: point11
+        };
+
+    function point11(x7, y7) {
+        ring.push(x7 = rotate(x7, y7));
+        x7[0] *= degrees3, x7[1] *= degrees3;
+    }
+
+    function circle3() {
+        var c11 = center3.apply(this, arguments),
+            r = radius3.apply(this, arguments) * radians2,
+            p = precision.apply(this, arguments) * radians2;
+        ring = [];
+        rotate = rotateRadians(-c11[0] * radians2, -c11[1] * radians2, 0).invert;
+        circleStream(stream, r, p, 1);
+        c11 = {
+            type: "Polygon",
+            coordinates: [ring]
+        };
+        ring = rotate = null;
+        return c11;
+    }
+    circle3.center = function(_) {
+        return arguments.length ? (center3 = typeof _ === "function" ? _ : constant_default8([+_[0], +_[1]]), circle3) : center3;
+    };
+    circle3.radius = function(_) {
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default8(+_), circle3) : radius3;
+    };
+    circle3.precision = function(_) {
+        return arguments.length ? (precision = typeof _ === "function" ? _ : constant_default8(+_), circle3) : precision;
+    };
+    return circle3;
+}
+
+// node_modules/d3-geo/src/clip/buffer.js
+function buffer_default2() {
+    var lines = [],
+        line3;
+    return {
+        point: function(x7, y7, m5) {
+            line3.push([x7, y7, m5]);
+        },
+        lineStart: function() {
+            lines.push(line3 = []);
+        },
+        lineEnd: noop2,
+        rejoin: function() {
+            if (lines.length > 1)
+                lines.push(lines.pop().concat(lines.shift()));
+        },
+        result: function() {
+            var result = lines;
+            lines = [];
+            line3 = null;
+            return result;
+        }
+    };
+}
+
+// node_modules/d3-geo/src/pointEqual.js
+function pointEqual_default(a7, b) {
+    return abs3(a7[0] - b[0]) < epsilon7 && abs3(a7[1] - b[1]) < epsilon7;
+}
+
+// node_modules/d3-geo/src/clip/rejoin.js
+function Intersection(point11, points, other, entry) {
+    this.x = point11;
+    this.z = points;
+    this.o = other;
+    this.e = entry;
+    this.v = false;
+    this.n = this.p = null;
+}
+
+function rejoin_default(segments, compareIntersection3, startInside, interpolate, stream) {
+    var subject = [],
+        clip = [],
+        i, n;
+    segments.forEach(function(segment) {
+        if ((n2 = segment.length - 1) <= 0)
+            return;
+        var n2, p03 = segment[0],
+            p1 = segment[n2],
+            x7;
+        if (pointEqual_default(p03, p1)) {
+            if (!p03[2] && !p1[2]) {
+                stream.lineStart();
+                for (i = 0; i < n2; ++i)
+                    stream.point((p03 = segment[i])[0], p03[1]);
+                stream.lineEnd();
+                return;
+            }
+            p1[0] += 2 * epsilon7;
+        }
+        subject.push(x7 = new Intersection(p03, segment, null, true));
+        clip.push(x7.o = new Intersection(p03, null, x7, false));
+        subject.push(x7 = new Intersection(p1, segment, null, false));
+        clip.push(x7.o = new Intersection(p1, null, x7, true));
+    });
+    if (!subject.length)
+        return;
+    clip.sort(compareIntersection3);
+    link(subject);
+    link(clip);
+    for (i = 0, n = clip.length; i < n; ++i) {
+        clip[i].e = startInside = !startInside;
+    }
+    var start3 = subject[0],
+        points, point11;
+    while (1) {
+        var current = start3,
+            isSubject = true;
+        while (current.v)
+            if ((current = current.n) === start3)
+                return;
+        points = current.z;
+        stream.lineStart();
+        do {
+            current.v = current.o.v = true;
+            if (current.e) {
+                if (isSubject) {
+                    for (i = 0, n = points.length; i < n; ++i)
+                        stream.point((point11 = points[i])[0], point11[1]);
+                } else {
+                    interpolate(current.x, current.n.x, 1, stream);
+                }
+                current = current.n;
+            } else {
+                if (isSubject) {
+                    points = current.p.z;
+                    for (i = points.length - 1; i >= 0; --i)
+                        stream.point((point11 = points[i])[0], point11[1]);
+                } else {
+                    interpolate(current.x, current.p.x, -1, stream);
+                }
+                current = current.p;
+            }
+            current = current.o;
+            points = current.z;
+            isSubject = !isSubject;
+        } while (!current.v);
+        stream.lineEnd();
+    }
+}
+
+function link(array7) {
+    if (!(n = array7.length))
+        return;
+    var n, i = 0,
+        a7 = array7[0],
+        b;
+    while (++i < n) {
+        a7.n = b = array7[i];
+        b.p = a7;
+        a7 = b;
+    }
+    a7.n = b = array7[0];
+    b.p = a7;
+}
+
+// node_modules/d3-geo/src/polygonContains.js
+function longitude(point11) {
+    return abs3(point11[0]) <= pi4 ? point11[0] : sign(point11[0]) * ((abs3(point11[0]) + pi4) % tau5 - pi4);
+}
+
+function polygonContains_default(polygon, point11) {
+    var lambda = longitude(point11),
+        phi3 = point11[1],
+        sinPhi = sin2(phi3),
+        normal = [sin2(lambda), -cos2(lambda), 0],
+        angle3 = 0,
+        winding = 0;
+    var sum8 = new Adder();
+    if (sinPhi === 1)
+        phi3 = halfPi3 + epsilon7;
+    else if (sinPhi === -1)
+        phi3 = -halfPi3 - epsilon7;
+    for (var i = 0, n = polygon.length; i < n; ++i) {
+        if (!(m5 = (ring = polygon[i]).length))
+            continue;
+        var ring, m5, point0 = ring[m5 - 1],
+            lambda07 = longitude(point0),
+            phi03 = point0[1] / 2 + quarterPi,
+            sinPhi05 = sin2(phi03),
+            cosPhi05 = cos2(phi03);
+        for (var j = 0; j < m5; ++j, lambda07 = lambda13, sinPhi05 = sinPhi1, cosPhi05 = cosPhi1, point0 = point1) {
+            var point1 = ring[j],
+                lambda13 = longitude(point1),
+                phi13 = point1[1] / 2 + quarterPi,
+                sinPhi1 = sin2(phi13),
+                cosPhi1 = cos2(phi13),
+                delta = lambda13 - lambda07,
+                sign5 = delta >= 0 ? 1 : -1,
+                absDelta = sign5 * delta,
+                antimeridian = absDelta > pi4,
+                k3 = sinPhi05 * sinPhi1;
+            sum8.add(atan2(k3 * sign5 * sin2(absDelta), cosPhi05 * cosPhi1 + k3 * cos2(absDelta)));
+            angle3 += antimeridian ? delta + sign5 * tau5 : delta;
+            if (antimeridian ^ lambda07 >= lambda ^ lambda13 >= lambda) {
+                var arc = cartesianCross(cartesian(point0), cartesian(point1));
+                cartesianNormalizeInPlace(arc);
+                var intersection3 = cartesianCross(normal, arc);
+                cartesianNormalizeInPlace(intersection3);
+                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection3[2]);
+                if (phi3 > phiArc || phi3 === phiArc && (arc[0] || arc[1])) {
+                    winding += antimeridian ^ delta >= 0 ? 1 : -1;
+                }
+            }
+        }
+    }
+    return (angle3 < -epsilon7 || angle3 < epsilon7 && sum8 < -epsilon22) ^ winding & 1;
+}
+
+// node_modules/d3-geo/src/clip/index.js
+function clip_default(pointVisible, clipLine, interpolate, start3) {
+    return function(sink) {
+        var line3 = clipLine(sink),
+            ringBuffer = buffer_default2(),
+            ringSink = clipLine(ringBuffer),
+            polygonStarted = false,
+            polygon, segments, ring;
+        var clip = {
+            point: point11,
+            lineStart,
+            lineEnd,
+            polygonStart: function() {
+                clip.point = pointRing;
+                clip.lineStart = ringStart;
+                clip.lineEnd = ringEnd;
+                segments = [];
+                polygon = [];
+            },
+            polygonEnd: function() {
+                clip.point = point11;
+                clip.lineStart = lineStart;
+                clip.lineEnd = lineEnd;
+                segments = merge(segments);
+                var startInside = polygonContains_default(polygon, start3);
+                if (segments.length) {
+                    if (!polygonStarted)
+                        sink.polygonStart(), polygonStarted = true;
+                    rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
+                } else if (startInside) {
+                    if (!polygonStarted)
+                        sink.polygonStart(), polygonStarted = true;
+                    sink.lineStart();
+                    interpolate(null, null, 1, sink);
+                    sink.lineEnd();
+                }
+                if (polygonStarted)
+                    sink.polygonEnd(), polygonStarted = false;
+                segments = polygon = null;
+            },
+            sphere: function() {
+                sink.polygonStart();
+                sink.lineStart();
+                interpolate(null, null, 1, sink);
+                sink.lineEnd();
+                sink.polygonEnd();
+            }
+        };
+
+        function point11(lambda, phi3) {
+            if (pointVisible(lambda, phi3))
+                sink.point(lambda, phi3);
+        }
+
+        function pointLine(lambda, phi3) {
+            line3.point(lambda, phi3);
+        }
+
+        function lineStart() {
+            clip.point = pointLine;
+            line3.lineStart();
+        }
+
+        function lineEnd() {
+            clip.point = point11;
+            line3.lineEnd();
+        }
+
+        function pointRing(lambda, phi3) {
+            ring.push([lambda, phi3]);
+            ringSink.point(lambda, phi3);
+        }
+
+        function ringStart() {
+            ringSink.lineStart();
+            ring = [];
+        }
+
+        function ringEnd() {
+            pointRing(ring[0][0], ring[0][1]);
+            ringSink.lineEnd();
+            var clean = ringSink.clean(),
+                ringSegments = ringBuffer.result(),
+                i, n = ringSegments.length,
+                m5, segment, point12;
+            ring.pop();
+            polygon.push(ring);
+            ring = null;
+            if (!n)
+                return;
+            if (clean & 1) {
+                segment = ringSegments[0];
+                if ((m5 = segment.length - 1) > 0) {
+                    if (!polygonStarted)
+                        sink.polygonStart(), polygonStarted = true;
+                    sink.lineStart();
+                    for (i = 0; i < m5; ++i)
+                        sink.point((point12 = segment[i])[0], point12[1]);
+                    sink.lineEnd();
+                }
+                return;
+            }
+            if (n > 1 && clean & 2)
+                ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
+            segments.push(ringSegments.filter(validSegment));
+        }
+        return clip;
+    };
+}
+
+function validSegment(segment) {
+    return segment.length > 1;
+}
+
+function compareIntersection(a7, b) {
+    return ((a7 = a7.x)[0] < 0 ? a7[1] - halfPi3 - epsilon7 : halfPi3 - a7[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);
+}
+
+// node_modules/d3-geo/src/clip/antimeridian.js
+var antimeridian_default = clip_default(
+    function() {
+        return true;
+    },
+    clipAntimeridianLine,
+    clipAntimeridianInterpolate,
+    [-pi4, -halfPi3]
+);
+
+function clipAntimeridianLine(stream) {
+    var lambda07 = NaN,
+        phi03 = NaN,
+        sign0 = NaN,
+        clean;
+    return {
+        lineStart: function() {
+            stream.lineStart();
+            clean = 1;
+        },
+        point: function(lambda13, phi13) {
+            var sign1 = lambda13 > 0 ? pi4 : -pi4,
+                delta = abs3(lambda13 - lambda07);
+            if (abs3(delta - pi4) < epsilon7) {
+                stream.point(lambda07, phi03 = (phi03 + phi13) / 2 > 0 ? halfPi3 : -halfPi3);
+                stream.point(sign0, phi03);
+                stream.lineEnd();
+                stream.lineStart();
+                stream.point(sign1, phi03);
+                stream.point(lambda13, phi03);
+                clean = 0;
+            } else if (sign0 !== sign1 && delta >= pi4) {
+                if (abs3(lambda07 - sign0) < epsilon7)
+                    lambda07 -= sign0 * epsilon7;
+                if (abs3(lambda13 - sign1) < epsilon7)
+                    lambda13 -= sign1 * epsilon7;
+                phi03 = clipAntimeridianIntersect(lambda07, phi03, lambda13, phi13);
+                stream.point(sign0, phi03);
+                stream.lineEnd();
+                stream.lineStart();
+                stream.point(sign1, phi03);
+                clean = 0;
+            }
+            stream.point(lambda07 = lambda13, phi03 = phi13);
+            sign0 = sign1;
+        },
+        lineEnd: function() {
+            stream.lineEnd();
+            lambda07 = phi03 = NaN;
+        },
+        clean: function() {
+            return 2 - clean;
+        }
+    };
+}
+
+function clipAntimeridianIntersect(lambda07, phi03, lambda13, phi13) {
+    var cosPhi05, cosPhi1, sinLambda0Lambda1 = sin2(lambda07 - lambda13);
+    return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi03) * (cosPhi1 = cos2(phi13)) * sin2(lambda13) - sin2(phi13) * (cosPhi05 = cos2(phi03)) * sin2(lambda07)) / (cosPhi05 * cosPhi1 * sinLambda0Lambda1)) : (phi03 + phi13) / 2;
+}
+
+function clipAntimeridianInterpolate(from, to, direction, stream) {
+    var phi3;
+    if (from == null) {
+        phi3 = direction * halfPi3;
+        stream.point(-pi4, phi3);
+        stream.point(0, phi3);
+        stream.point(pi4, phi3);
+        stream.point(pi4, 0);
+        stream.point(pi4, -phi3);
+        stream.point(0, -phi3);
+        stream.point(-pi4, -phi3);
+        stream.point(-pi4, 0);
+        stream.point(-pi4, phi3);
+    } else if (abs3(from[0] - to[0]) > epsilon7) {
+        var lambda = from[0] < to[0] ? pi4 : -pi4;
+        phi3 = direction * lambda / 2;
+        stream.point(-lambda, phi3);
+        stream.point(0, phi3);
+        stream.point(lambda, phi3);
+    } else {
+        stream.point(to[0], to[1]);
+    }
+}
+
+// node_modules/d3-geo/src/clip/circle.js
+function circle_default2(radius3) {
+    var cr = cos2(radius3),
+        delta = 6 * radians2,
+        smallRadius = cr > 0,
+        notHemisphere = abs3(cr) > epsilon7;
+
+    function interpolate(from, to, direction, stream) {
+        circleStream(stream, radius3, delta, direction, from, to);
+    }
+
+    function visible(lambda, phi3) {
+        return cos2(lambda) * cos2(phi3) > cr;
+    }
+
+    function clipLine(stream) {
+        var point0, c0, v0, v00, clean;
+        return {
+            lineStart: function() {
+                v00 = v0 = false;
+                clean = 1;
+            },
+            point: function(lambda, phi3) {
+                var point1 = [lambda, phi3],
+                    point22, v3 = visible(lambda, phi3),
+                    c11 = smallRadius ? v3 ? 0 : code(lambda, phi3) : v3 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi3) : 0;
+                if (!point0 && (v00 = v0 = v3))
+                    stream.lineStart();
+                if (v3 !== v0) {
+                    point22 = intersect3(point0, point1);
+                    if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
+                        point1[2] = 1;
+                }
+                if (v3 !== v0) {
+                    clean = 0;
+                    if (v3) {
+                        stream.lineStart();
+                        point22 = intersect3(point1, point0);
+                        stream.point(point22[0], point22[1]);
+                    } else {
+                        point22 = intersect3(point0, point1);
+                        stream.point(point22[0], point22[1], 2);
+                        stream.lineEnd();
+                    }
+                    point0 = point22;
+                } else if (notHemisphere && point0 && smallRadius ^ v3) {
+                    var t;
+                    if (!(c11 & c0) && (t = intersect3(point1, point0, true))) {
+                        clean = 0;
+                        if (smallRadius) {
+                            stream.lineStart();
+                            stream.point(t[0][0], t[0][1]);
+                            stream.point(t[1][0], t[1][1]);
+                            stream.lineEnd();
+                        } else {
+                            stream.point(t[1][0], t[1][1]);
+                            stream.lineEnd();
+                            stream.lineStart();
+                            stream.point(t[0][0], t[0][1], 3);
+                        }
+                    }
+                }
+                if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
+                    stream.point(point1[0], point1[1]);
+                }
+                point0 = point1, v0 = v3, c0 = c11;
+            },
+            lineEnd: function() {
+                if (v0)
+                    stream.lineEnd();
+                point0 = null;
+            },
+            // Rejoin first and last segments if there were intersections and the first
+            // and last points were visible.
+            clean: function() {
+                return clean | (v00 && v0) << 1;
+            }
+        };
+    }
+
+    function intersect3(a7, b, two) {
+        var pa = cartesian(a7),
+            pb = cartesian(b);
+        var n1 = [1, 0, 0],
+            n2 = cartesianCross(pa, pb),
+            n2n2 = cartesianDot(n2, n2),
+            n1n2 = n2[0],
+            determinant = n2n2 - n1n2 * n1n2;
+        if (!determinant)
+            return !two && a7;
+        var c1 = cr * n2n2 / determinant,
+            c22 = -cr * n1n2 / determinant,
+            n1xn2 = cartesianCross(n1, n2),
+            A6 = cartesianScale(n1, c1),
+            B5 = cartesianScale(n2, c22);
+        cartesianAddInPlace(A6, B5);
+        var u7 = n1xn2,
+            w = cartesianDot(A6, u7),
+            uu = cartesianDot(u7, u7),
+            t23 = w * w - uu * (cartesianDot(A6, A6) - 1);
+        if (t23 < 0)
+            return;
+        var t = sqrt(t23),
+            q = cartesianScale(u7, (-w - t) / uu);
+        cartesianAddInPlace(q, A6);
+        q = spherical(q);
+        if (!two)
+            return q;
+        var lambda07 = a7[0],
+            lambda13 = b[0],
+            phi03 = a7[1],
+            phi13 = b[1],
+            z;
+        if (lambda13 < lambda07)
+            z = lambda07, lambda07 = lambda13, lambda13 = z;
+        var delta2 = lambda13 - lambda07,
+            polar = abs3(delta2 - pi4) < epsilon7,
+            meridian = polar || delta2 < epsilon7;
+        if (!polar && phi13 < phi03)
+            z = phi03, phi03 = phi13, phi13 = z;
+        if (meridian ? polar ? phi03 + phi13 > 0 ^ q[1] < (abs3(q[0] - lambda07) < epsilon7 ? phi03 : phi13) : phi03 <= q[1] && q[1] <= phi13 : delta2 > pi4 ^ (lambda07 <= q[0] && q[0] <= lambda13)) {
+            var q1 = cartesianScale(u7, (-w + t) / uu);
+            cartesianAddInPlace(q1, A6);
+            return [q, spherical(q1)];
+        }
+    }
+
+    function code(lambda, phi3) {
+        var r = smallRadius ? radius3 : pi4 - radius3,
+            code2 = 0;
+        if (lambda < -r)
+            code2 |= 1;
+        else if (lambda > r)
+            code2 |= 2;
+        if (phi3 < -r)
+            code2 |= 4;
+        else if (phi3 > r)
+            code2 |= 8;
+        return code2;
+    }
+    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius3] : [-pi4, radius3 - pi4]);
+}
+
+// node_modules/d3-geo/src/clip/line.js
+function line_default(a7, b, x011, y011, x13, y13) {
+    var ax = a7[0],
+        ay = a7[1],
+        bx = b[0],
+        by = b[1],
+        t05 = 0,
+        t15 = 1,
+        dx = bx - ax,
+        dy = by - ay,
+        r;
+    r = x011 - ax;
+    if (!dx && r > 0)
+        return;
+    r /= dx;
+    if (dx < 0) {
+        if (r < t05)
+            return;
+        if (r < t15)
+            t15 = r;
+    } else if (dx > 0) {
+        if (r > t15)
+            return;
+        if (r > t05)
+            t05 = r;
+    }
+    r = x13 - ax;
+    if (!dx && r < 0)
+        return;
+    r /= dx;
+    if (dx < 0) {
+        if (r > t15)
+            return;
+        if (r > t05)
+            t05 = r;
+    } else if (dx > 0) {
+        if (r < t05)
+            return;
+        if (r < t15)
+            t15 = r;
+    }
+    r = y011 - ay;
+    if (!dy && r > 0)
+        return;
+    r /= dy;
+    if (dy < 0) {
+        if (r < t05)
+            return;
+        if (r < t15)
+            t15 = r;
+    } else if (dy > 0) {
+        if (r > t15)
+            return;
+        if (r > t05)
+            t05 = r;
+    }
+    r = y13 - ay;
+    if (!dy && r < 0)
+        return;
+    r /= dy;
+    if (dy < 0) {
+        if (r > t15)
+            return;
+        if (r > t05)
+            t05 = r;
+    } else if (dy > 0) {
+        if (r < t05)
+            return;
+        if (r < t15)
+            t15 = r;
+    }
+    if (t05 > 0)
+        a7[0] = ax + t05 * dx, a7[1] = ay + t05 * dy;
+    if (t15 < 1)
+        b[0] = ax + t15 * dx, b[1] = ay + t15 * dy;
+    return true;
+}
+
+// node_modules/d3-geo/src/clip/rectangle.js
+var clipMax = 1e9;
+var clipMin = -clipMax;
+
+function clipRectangle(x011, y011, x13, y13) {
+    function visible(x7, y7) {
+        return x011 <= x7 && x7 <= x13 && y011 <= y7 && y7 <= y13;
+    }
+
+    function interpolate(from, to, direction, stream) {
+        var a7 = 0,
+            a1 = 0;
+        if (from == null || (a7 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
+            do
+                stream.point(a7 === 0 || a7 === 3 ? x011 : x13, a7 > 1 ? y13 : y011);
+            while ((a7 = (a7 + direction + 4) % 4) !== a1);
+        } else {
+            stream.point(to[0], to[1]);
+        }
+    }
+
+    function corner(p, direction) {
+        return abs3(p[0] - x011) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x13) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y011) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
+    }
+
+    function compareIntersection3(a7, b) {
+        return comparePoint(a7.x, b.x);
+    }
+
+    function comparePoint(a7, b) {
+        var ca5 = corner(a7, 1),
+            cb = corner(b, 1);
+        return ca5 !== cb ? ca5 - cb : ca5 === 0 ? b[1] - a7[1] : ca5 === 1 ? a7[0] - b[0] : ca5 === 2 ? a7[1] - b[1] : b[0] - a7[0];
+    }
+    return function(stream) {
+        var activeStream = stream,
+            bufferStream = buffer_default2(),
+            segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
+        var clipStream = {
+            point: point11,
+            lineStart,
+            lineEnd,
+            polygonStart,
+            polygonEnd
+        };
+
+        function point11(x7, y7) {
+            if (visible(x7, y7))
+                activeStream.point(x7, y7);
+        }
+
+        function polygonInside() {
+            var winding = 0;
+            for (var i = 0, n = polygon.length; i < n; ++i) {
+                for (var ring2 = polygon[i], j = 1, m5 = ring2.length, point12 = ring2[0], a0, a1, b03 = point12[0], b13 = point12[1]; j < m5; ++j) {
+                    a0 = b03, a1 = b13, point12 = ring2[j], b03 = point12[0], b13 = point12[1];
+                    if (a1 <= y13) {
+                        if (b13 > y13 && (b03 - a0) * (y13 - a1) > (b13 - a1) * (x011 - a0))
+                            ++winding;
+                    } else {
+                        if (b13 <= y13 && (b03 - a0) * (y13 - a1) < (b13 - a1) * (x011 - a0))
+                            --winding;
+                    }
+                }
+            }
+            return winding;
+        }
+
+        function polygonStart() {
+            activeStream = bufferStream, segments = [], polygon = [], clean = true;
+        }
+
+        function polygonEnd() {
+            var startInside = polygonInside(),
+                cleanInside = clean && startInside,
+                visible2 = (segments = merge(segments)).length;
+            if (cleanInside || visible2) {
+                stream.polygonStart();
+                if (cleanInside) {
+                    stream.lineStart();
+                    interpolate(null, null, 1, stream);
+                    stream.lineEnd();
+                }
+                if (visible2) {
+                    rejoin_default(segments, compareIntersection3, startInside, interpolate, stream);
+                }
+                stream.polygonEnd();
+            }
+            activeStream = stream, segments = polygon = ring = null;
+        }
+
+        function lineStart() {
+            clipStream.point = linePoint3;
+            if (polygon)
+                polygon.push(ring = []);
+            first3 = true;
+            v_ = false;
+            x_ = y_ = NaN;
+        }
+
+        function lineEnd() {
+            if (segments) {
+                linePoint3(x__, y__);
+                if (v__ && v_)
+                    bufferStream.rejoin();
+                segments.push(bufferStream.result());
+            }
+            clipStream.point = point11;
+            if (v_)
+                activeStream.lineEnd();
+        }
+
+        function linePoint3(x7, y7) {
+            var v3 = visible(x7, y7);
+            if (polygon)
+                ring.push([x7, y7]);
+            if (first3) {
+                x__ = x7, y__ = y7, v__ = v3;
+                first3 = false;
+                if (v3) {
+                    activeStream.lineStart();
+                    activeStream.point(x7, y7);
+                }
+            } else {
+                if (v3 && v_)
+                    activeStream.point(x7, y7);
+                else {
+                    var a7 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
+                        b = [x7 = Math.max(clipMin, Math.min(clipMax, x7)), y7 = Math.max(clipMin, Math.min(clipMax, y7))];
+                    if (line_default(a7, b, x011, y011, x13, y13)) {
+                        if (!v_) {
+                            activeStream.lineStart();
+                            activeStream.point(a7[0], a7[1]);
+                        }
+                        activeStream.point(b[0], b[1]);
+                        if (!v3)
+                            activeStream.lineEnd();
+                        clean = false;
+                    } else if (v3) {
+                        activeStream.lineStart();
+                        activeStream.point(x7, y7);
+                        clean = false;
+                    }
+                }
+            }
+            x_ = x7, y_ = y7, v_ = v3;
+        }
+        return clipStream;
+    };
+}
+
+// node_modules/d3-geo/src/clip/extent.js
+function extent_default2() {
+    var x011 = 0,
+        y011 = 0,
+        x13 = 960,
+        y13 = 500,
+        cache, cacheStream, clip;
+    return clip = {
+        stream: function(stream) {
+            return cache && cacheStream === stream ? cache : cache = clipRectangle(x011, y011, x13, y13)(cacheStream = stream);
+        },
+        extent: function(_) {
+            return arguments.length ? (x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1], cache = cacheStream = null, clip) : [
+                [x011, y011],
+                [x13, y13]
+            ];
+        }
+    };
+}
+
+// node_modules/d3-geo/src/length.js
+var lengthSum;
+var lambda03;
+var sinPhi02;
+var cosPhi02;
+var lengthStream = {
+    sphere: noop2,
+    point: noop2,
+    lineStart: lengthLineStart,
+    lineEnd: noop2,
+    polygonStart: noop2,
+    polygonEnd: noop2
+};
+
+function lengthLineStart() {
+    lengthStream.point = lengthPointFirst;
+    lengthStream.lineEnd = lengthLineEnd;
+}
+
+function lengthLineEnd() {
+    lengthStream.point = lengthStream.lineEnd = noop2;
+}
+
+function lengthPointFirst(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    lambda03 = lambda, sinPhi02 = sin2(phi3), cosPhi02 = cos2(phi3);
+    lengthStream.point = lengthPoint;
+}
+
+function lengthPoint(lambda, phi3) {
+    lambda *= radians2, phi3 *= radians2;
+    var sinPhi = sin2(phi3),
+        cosPhi = cos2(phi3),
+        delta = abs3(lambda - lambda03),
+        cosDelta = cos2(delta),
+        sinDelta = sin2(delta),
+        x7 = cosPhi * sinDelta,
+        y7 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta,
+        z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
+    lengthSum.add(atan2(sqrt(x7 * x7 + y7 * y7), z));
+    lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
+}
+
+function length_default(object3) {
+    lengthSum = new Adder();
+    stream_default(object3, lengthStream);
+    return +lengthSum;
+}
+
+// node_modules/d3-geo/src/distance.js
+var coordinates = [null, null];
+var object = {
+    type: "LineString",
+    coordinates
+};
+
+function distance_default(a7, b) {
+    coordinates[0] = a7;
+    coordinates[1] = b;
+    return length_default(object);
+}
+
+// node_modules/d3-geo/src/contains.js
+var containsObjectType = {
+    Feature: function(object3, point11) {
+        return containsGeometry(object3.geometry, point11);
+    },
+    FeatureCollection: function(object3, point11) {
+        var features = object3.features,
+            i = -1,
+            n = features.length;
+        while (++i < n)
+            if (containsGeometry(features[i].geometry, point11))
+                return true;
+        return false;
+    }
+};
+var containsGeometryType = {
+    Sphere: function() {
+        return true;
+    },
+    Point: function(object3, point11) {
+        return containsPoint(object3.coordinates, point11);
+    },
+    MultiPoint: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            if (containsPoint(coordinates3[i], point11))
+                return true;
+        return false;
+    },
+    LineString: function(object3, point11) {
+        return containsLine(object3.coordinates, point11);
+    },
+    MultiLineString: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            if (containsLine(coordinates3[i], point11))
+                return true;
+        return false;
+    },
+    Polygon: function(object3, point11) {
+        return containsPolygon(object3.coordinates, point11);
+    },
+    MultiPolygon: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
+            i = -1,
+            n = coordinates3.length;
+        while (++i < n)
+            if (containsPolygon(coordinates3[i], point11))
+                return true;
+        return false;
+    },
+    GeometryCollection: function(object3, point11) {
+        var geometries = object3.geometries,
+            i = -1,
+            n = geometries.length;
+        while (++i < n)
+            if (containsGeometry(geometries[i], point11))
+                return true;
+        return false;
+    }
+};
+
+function containsGeometry(geometry, point11) {
+    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point11) : false;
+}
+
+function containsPoint(coordinates3, point11) {
+    return distance_default(coordinates3, point11) === 0;
+}
+
+function containsLine(coordinates3, point11) {
+    var ao, bo, ab7;
+    for (var i = 0, n = coordinates3.length; i < n; i++) {
+        bo = distance_default(coordinates3[i], point11);
+        if (bo === 0)
+            return true;
+        if (i > 0) {
+            ab7 = distance_default(coordinates3[i], coordinates3[i - 1]);
+            if (ab7 > 0 && ao <= ab7 && bo <= ab7 && (ao + bo - ab7) * (1 - Math.pow((ao - bo) / ab7, 2)) < epsilon22 * ab7)
+                return true;
+        }
+        ao = bo;
+    }
+    return false;
+}
+
+function containsPolygon(coordinates3, point11) {
+    return !!polygonContains_default(coordinates3.map(ringRadians), pointRadians(point11));
+}
+
+function ringRadians(ring) {
+    return ring = ring.map(pointRadians), ring.pop(), ring;
+}
+
+function pointRadians(point11) {
+    return [point11[0] * radians2, point11[1] * radians2];
+}
+
+function contains_default2(object3, point11) {
+    return (object3 && containsObjectType.hasOwnProperty(object3.type) ? containsObjectType[object3.type] : containsGeometry)(object3, point11);
+}
+
+// node_modules/d3-geo/src/graticule.js
+function graticuleX(y011, y13, dy) {
+    var y7 = range(y011, y13 - epsilon7, dy).concat(y13);
+    return function(x7) {
+        return y7.map(function(y8) {
+            return [x7, y8];
+        });
+    };
+}
+
+function graticuleY(x011, x13, dx) {
+    var x7 = range(x011, x13 - epsilon7, dx).concat(x13);
+    return function(y7) {
+        return x7.map(function(x8) {
+            return [x8, y7];
+        });
+    };
+}
+
+function graticule() {
+    var x13, x011, X15, X05, y13, y011, Y15, Y05, dx = 10,
+        dy = dx,
+        DX = 90,
+        DY = 360,
+        x7, y7, X4, Y4, precision = 2.5;
+
+    function graticule5() {
+        return {
+            type: "MultiLineString",
+            coordinates: lines()
+        };
+    }
+
+    function lines() {
+        return range(ceil(X05 / DX) * DX, X15, DX).map(X4).concat(range(ceil(Y05 / DY) * DY, Y15, DY).map(Y4)).concat(range(ceil(x011 / dx) * dx, x13, dx).filter(function(x8) {
+            return abs3(x8 % DX) > epsilon7;
+        }).map(x7)).concat(range(ceil(y011 / dy) * dy, y13, dy).filter(function(y8) {
+            return abs3(y8 % DY) > epsilon7;
+        }).map(y7));
+    }
+    graticule5.lines = function() {
+        return lines().map(function(coordinates3) {
+            return {
+                type: "LineString",
+                coordinates: coordinates3
+            };
+        });
+    };
+    graticule5.outline = function() {
+        return {
+            type: "Polygon",
+            coordinates: [
+                X4(X05).concat(
+                    Y4(Y15).slice(1),
+                    X4(X15).reverse().slice(1),
+                    Y4(Y05).reverse().slice(1)
+                )
+            ]
+        };
+    };
+    graticule5.extent = function(_) {
+        if (!arguments.length)
+            return graticule5.extentMinor();
+        return graticule5.extentMajor(_).extentMinor(_);
+    };
+    graticule5.extentMajor = function(_) {
+        if (!arguments.length)
+            return [
+                [X05, Y05],
+                [X15, Y15]
+            ];
+        X05 = +_[0][0], X15 = +_[1][0];
+        Y05 = +_[0][1], Y15 = +_[1][1];
+        if (X05 > X15)
+            _ = X05, X05 = X15, X15 = _;
+        if (Y05 > Y15)
+            _ = Y05, Y05 = Y15, Y15 = _;
+        return graticule5.precision(precision);
+    };
+    graticule5.extentMinor = function(_) {
+        if (!arguments.length)
+            return [
+                [x011, y011],
+                [x13, y13]
+            ];
+        x011 = +_[0][0], x13 = +_[1][0];
+        y011 = +_[0][1], y13 = +_[1][1];
+        if (x011 > x13)
+            _ = x011, x011 = x13, x13 = _;
+        if (y011 > y13)
+            _ = y011, y011 = y13, y13 = _;
+        return graticule5.precision(precision);
+    };
+    graticule5.step = function(_) {
+        if (!arguments.length)
+            return graticule5.stepMinor();
+        return graticule5.stepMajor(_).stepMinor(_);
+    };
+    graticule5.stepMajor = function(_) {
+        if (!arguments.length)
+            return [DX, DY];
+        DX = +_[0], DY = +_[1];
+        return graticule5;
+    };
+    graticule5.stepMinor = function(_) {
+        if (!arguments.length)
+            return [dx, dy];
+        dx = +_[0], dy = +_[1];
+        return graticule5;
+    };
+    graticule5.precision = function(_) {
+        if (!arguments.length)
+            return precision;
+        precision = +_;
+        x7 = graticuleX(y011, y13, 90);
+        y7 = graticuleY(x011, x13, precision);
+        X4 = graticuleX(Y05, Y15, 90);
+        Y4 = graticuleY(X05, X15, precision);
+        return graticule5;
+    };
+    return graticule5.extentMajor([
+        [-180, -90 + epsilon7],
+        [180, 90 - epsilon7]
+    ]).extentMinor([
+        [-180, -80 - epsilon7],
+        [180, 80 + epsilon7]
+    ]);
+}
+
+function graticule10() {
+    return graticule()();
+}
+
+// node_modules/d3-geo/src/interpolate.js
+function interpolate_default2(a7, b) {
+    var x011 = a7[0] * radians2,
+        y011 = a7[1] * radians2,
+        x13 = b[0] * radians2,
+        y13 = b[1] * radians2,
+        cy0 = cos2(y011),
+        sy0 = sin2(y011),
+        cy1 = cos2(y13),
+        sy1 = sin2(y13),
+        kx0 = cy0 * cos2(x011),
+        ky0 = cy0 * sin2(x011),
+        kx1 = cy1 * cos2(x13),
+        ky1 = cy1 * sin2(x13),
+        d = 2 * asin(sqrt(haversin(y13 - y011) + cy0 * cy1 * haversin(x13 - x011))),
+        k3 = sin2(d);
+    var interpolate = d ? function(t) {
+        var B5 = sin2(t *= d) / k3,
+            A6 = sin2(d - t) / k3,
+            x7 = A6 * kx0 + B5 * kx1,
+            y7 = A6 * ky0 + B5 * ky1,
+            z = A6 * sy0 + B5 * sy1;
+        return [
+            atan2(y7, x7) * degrees3,
+            atan2(z, sqrt(x7 * x7 + y7 * y7)) * degrees3
+        ];
+    } : function() {
+        return [x011 * degrees3, y011 * degrees3];
+    };
+    interpolate.distance = d;
+    return interpolate;
+}
+
+// node_modules/d3-geo/src/identity.js
+var identity_default3 = (x7) => x7;
+
+// node_modules/d3-geo/src/path/area.js
+var areaSum2 = new Adder();
+var areaRingSum2 = new Adder();
+var x00;
+var y00;
+var x02;
+var y02;
+var areaStream2 = {
+    point: noop2,
+    lineStart: noop2,
+    lineEnd: noop2,
+    polygonStart: function() {
+        areaStream2.lineStart = areaRingStart2;
+        areaStream2.lineEnd = areaRingEnd2;
+    },
+    polygonEnd: function() {
+        areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
+        areaSum2.add(abs3(areaRingSum2));
+        areaRingSum2 = new Adder();
+    },
+    result: function() {
+        var area3 = areaSum2 / 2;
+        areaSum2 = new Adder();
+        return area3;
+    }
+};
+
+function areaRingStart2() {
+    areaStream2.point = areaPointFirst2;
+}
+
+function areaPointFirst2(x7, y7) {
+    areaStream2.point = areaPoint2;
+    x00 = x02 = x7, y00 = y02 = y7;
+}
+
+function areaPoint2(x7, y7) {
+    areaRingSum2.add(y02 * x7 - x02 * y7);
+    x02 = x7, y02 = y7;
+}
+
+function areaRingEnd2() {
+    areaPoint2(x00, y00);
+}
+var area_default3 = areaStream2;
+
+// node_modules/d3-geo/src/path/bounds.js
+var x03 = Infinity;
+var y03 = x03;
+var x1 = -x03;
+var y1 = x1;
+var boundsStream2 = {
+    point: boundsPoint2,
+    lineStart: noop2,
+    lineEnd: noop2,
+    polygonStart: noop2,
+    polygonEnd: noop2,
+    result: function() {
+        var bounds = [
+            [x03, y03],
+            [x1, y1]
+        ];
+        x1 = y1 = -(y03 = x03 = Infinity);
+        return bounds;
+    }
+};
+
+function boundsPoint2(x7, y7) {
+    if (x7 < x03)
+        x03 = x7;
+    if (x7 > x1)
+        x1 = x7;
+    if (y7 < y03)
+        y03 = y7;
+    if (y7 > y1)
+        y1 = y7;
+}
+var bounds_default2 = boundsStream2;
+
+// node_modules/d3-geo/src/path/centroid.js
+var X02 = 0;
+var Y02 = 0;
+var Z02 = 0;
+var X12 = 0;
+var Y12 = 0;
+var Z12 = 0;
+var X22 = 0;
+var Y22 = 0;
+var Z22 = 0;
+var x002;
+var y002;
+var x04;
+var y04;
+var centroidStream2 = {
+    point: centroidPoint2,
+    lineStart: centroidLineStart2,
+    lineEnd: centroidLineEnd2,
+    polygonStart: function() {
+        centroidStream2.lineStart = centroidRingStart2;
+        centroidStream2.lineEnd = centroidRingEnd2;
+    },
+    polygonEnd: function() {
+        centroidStream2.point = centroidPoint2;
+        centroidStream2.lineStart = centroidLineStart2;
+        centroidStream2.lineEnd = centroidLineEnd2;
+    },
+    result: function() {
+        var centroid3 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
+        X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
+        return centroid3;
+    }
+};
+
+function centroidPoint2(x7, y7) {
+    X02 += x7;
+    Y02 += y7;
+    ++Z02;
+}
+
+function centroidLineStart2() {
+    centroidStream2.point = centroidPointFirstLine;
+}
+
+function centroidPointFirstLine(x7, y7) {
+    centroidStream2.point = centroidPointLine;
+    centroidPoint2(x04 = x7, y04 = y7);
+}
+
+function centroidPointLine(x7, y7) {
+    var dx = x7 - x04,
+        dy = y7 - y04,
+        z = sqrt(dx * dx + dy * dy);
+    X12 += z * (x04 + x7) / 2;
+    Y12 += z * (y04 + y7) / 2;
+    Z12 += z;
+    centroidPoint2(x04 = x7, y04 = y7);
+}
+
+function centroidLineEnd2() {
+    centroidStream2.point = centroidPoint2;
+}
+
+function centroidRingStart2() {
+    centroidStream2.point = centroidPointFirstRing;
+}
+
+function centroidRingEnd2() {
+    centroidPointRing(x002, y002);
+}
+
+function centroidPointFirstRing(x7, y7) {
+    centroidStream2.point = centroidPointRing;
+    centroidPoint2(x002 = x04 = x7, y002 = y04 = y7);
+}
+
+function centroidPointRing(x7, y7) {
+    var dx = x7 - x04,
+        dy = y7 - y04,
+        z = sqrt(dx * dx + dy * dy);
+    X12 += z * (x04 + x7) / 2;
+    Y12 += z * (y04 + y7) / 2;
+    Z12 += z;
+    z = y04 * x7 - x04 * y7;
+    X22 += z * (x04 + x7);
+    Y22 += z * (y04 + y7);
+    Z22 += z * 3;
+    centroidPoint2(x04 = x7, y04 = y7);
+}
+var centroid_default2 = centroidStream2;
+
+// node_modules/d3-geo/src/path/context.js
+function PathContext(context) {
+    this._context = context;
+}
+PathContext.prototype = {
+    _radius: 4.5,
+    pointRadius: function(_) {
+        return this._radius = _, this;
+    },
+    polygonStart: function() {
+        this._line = 0;
+    },
+    polygonEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._line === 0)
+            this._context.closePath();
+        this._point = NaN;
+    },
+    point: function(x7, y7) {
+        switch (this._point) {
+            case 0: {
+                this._context.moveTo(x7, y7);
+                this._point = 1;
+                break;
+            }
+            case 1: {
+                this._context.lineTo(x7, y7);
+                break;
+            }
+            default: {
+                this._context.moveTo(x7 + this._radius, y7);
+                this._context.arc(x7, y7, this._radius, 0, tau5);
+                break;
+            }
+        }
+    },
+    result: noop2
+};
+
+// node_modules/d3-geo/src/path/measure.js
+var lengthSum2 = new Adder();
+var lengthRing;
+var x003;
+var y003;
+var x05;
+var y05;
+var lengthStream2 = {
+    point: noop2,
+    lineStart: function() {
+        lengthStream2.point = lengthPointFirst2;
+    },
+    lineEnd: function() {
+        if (lengthRing)
+            lengthPoint2(x003, y003);
+        lengthStream2.point = noop2;
+    },
+    polygonStart: function() {
+        lengthRing = true;
+    },
+    polygonEnd: function() {
+        lengthRing = null;
+    },
+    result: function() {
+        var length7 = +lengthSum2;
+        lengthSum2 = new Adder();
+        return length7;
+    }
+};
+
+function lengthPointFirst2(x7, y7) {
+    lengthStream2.point = lengthPoint2;
+    x003 = x05 = x7, y003 = y05 = y7;
+}
+
+function lengthPoint2(x7, y7) {
+    x05 -= x7, y05 -= y7;
+    lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
+    x05 = x7, y05 = y7;
+}
+var measure_default = lengthStream2;
+
+// node_modules/d3-geo/src/path/string.js
+var cacheDigits;
+var cacheAppend;
+var cacheRadius;
+var cacheCircle;
+var PathString = class {
+    constructor(digits) {
+        this._append = digits == null ? append2 : appendRound2(digits);
+        this._radius = 4.5;
+        this._ = "";
+    }
+    pointRadius(_) {
+        this._radius = +_;
+        return this;
+    }
+    polygonStart() {
+        this._line = 0;
+    }
+    polygonEnd() {
+        this._line = NaN;
+    }
+    lineStart() {
+        this._point = 0;
+    }
+    lineEnd() {
+        if (this._line === 0)
+            this._ += "Z";
+        this._point = NaN;
+    }
+    point(x7, y7) {
+        switch (this._point) {
+            case 0: {
+                this._append`M${x7},${y7}`;
+                this._point = 1;
+                break;
+            }
+            case 1: {
+                this._append`L${x7},${y7}`;
+                break;
+            }
+            default: {
+                this._append`M${x7},${y7}`;
+                if (this._radius !== cacheRadius || this._append !== cacheAppend) {
+                    const r = this._radius;
+                    const s3 = this._;
+                    this._ = "";
+                    this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
+                    cacheRadius = r;
+                    cacheAppend = this._append;
+                    cacheCircle = this._;
+                    this._ = s3;
+                }
+                this._ += cacheCircle;
+                break;
+            }
+        }
+    }
+    result() {
+        const result = this._;
+        this._ = "";
+        return result.length ? result : null;
+    }
+};
+
+function append2(strings) {
+    let i = 1;
+    this._ += strings[0];
+    for (const j = strings.length; i < j; ++i) {
+        this._ += arguments[i] + strings[i];
+    }
+}
+
+function appendRound2(digits) {
+    const d = Math.floor(digits);
+    if (!(d >= 0))
+        throw new RangeError(`invalid digits: ${digits}`);
+    if (d > 15)
+        return append2;
+    if (d !== cacheDigits) {
+        const k3 = 10 ** d;
+        cacheDigits = d;
+        cacheAppend = function append5(strings) {
+            let i = 1;
+            this._ += strings[0];
+            for (const j = strings.length; i < j; ++i) {
+                this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
+            }
+        };
+    }
+    return cacheAppend;
+}
+
+// node_modules/d3-geo/src/path/index.js
+function path_default(projection3, context) {
+    let digits = 3,
+        pointRadius = 4.5,
+        projectionStream, contextStream;
+
+    function path3(object3) {
+        if (object3) {
+            if (typeof pointRadius === "function")
+                contextStream.pointRadius(+pointRadius.apply(this, arguments));
+            stream_default(object3, projectionStream(contextStream));
+        }
+        return contextStream.result();
+    }
+    path3.area = function(object3) {
+        stream_default(object3, projectionStream(area_default3));
+        return area_default3.result();
+    };
+    path3.measure = function(object3) {
+        stream_default(object3, projectionStream(measure_default));
+        return measure_default.result();
+    };
+    path3.bounds = function(object3) {
+        stream_default(object3, projectionStream(bounds_default2));
+        return bounds_default2.result();
+    };
+    path3.centroid = function(object3) {
+        stream_default(object3, projectionStream(centroid_default2));
+        return centroid_default2.result();
+    };
+    path3.projection = function(_) {
+        if (!arguments.length)
+            return projection3;
+        projectionStream = _ == null ? (projection3 = null, identity_default3) : (projection3 = _).stream;
+        return path3;
+    };
+    path3.context = function(_) {
+        if (!arguments.length)
+            return context;
+        contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
+        if (typeof pointRadius !== "function")
+            contextStream.pointRadius(pointRadius);
+        return path3;
+    };
+    path3.pointRadius = function(_) {
+        if (!arguments.length)
+            return pointRadius;
+        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
+        return path3;
+    };
+    path3.digits = function(_) {
+        if (!arguments.length)
+            return digits;
+        if (_ == null)
+            digits = null;
+        else {
+            const d = Math.floor(_);
+            if (!(d >= 0))
+                throw new RangeError(`invalid digits: ${_}`);
+            digits = d;
+        }
+        if (context === null)
+            contextStream = new PathString(digits);
+        return path3;
+    };
+    return path3.projection(projection3).digits(digits).context(context);
+}
+
+// node_modules/d3-geo/src/transform.js
+function transform_default(methods) {
+    return {
+        stream: transformer(methods)
+    };
+}
+
+function transformer(methods) {
+    return function(stream) {
+        var s3 = new TransformStream();
+        for (var key in methods)
+            s3[key] = methods[key];
+        s3.stream = stream;
+        return s3;
+    };
+}
+
+function TransformStream() {}
+TransformStream.prototype = {
+    constructor: TransformStream,
+    point: function(x7, y7) {
+        this.stream.point(x7, y7);
+    },
+    sphere: function() {
+        this.stream.sphere();
+    },
+    lineStart: function() {
+        this.stream.lineStart();
+    },
+    lineEnd: function() {
+        this.stream.lineEnd();
+    },
+    polygonStart: function() {
+        this.stream.polygonStart();
+    },
+    polygonEnd: function() {
+        this.stream.polygonEnd();
+    }
+};
+
+// node_modules/d3-geo/src/projection/fit.js
+function fit(projection3, fitBounds, object3) {
+    var clip = projection3.clipExtent && projection3.clipExtent();
+    projection3.scale(150).translate([0, 0]);
+    if (clip != null)
+        projection3.clipExtent(null);
+    stream_default(object3, projection3.stream(bounds_default2));
+    fitBounds(bounds_default2.result());
+    if (clip != null)
+        projection3.clipExtent(clip);
+    return projection3;
+}
+
+function fitExtent(projection3, extent5, object3) {
+    return fit(projection3, function(b) {
+        var w = extent5[1][0] - extent5[0][0],
+            h = extent5[1][1] - extent5[0][1],
+            k3 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
+            x7 = +extent5[0][0] + (w - k3 * (b[1][0] + b[0][0])) / 2,
+            y7 = +extent5[0][1] + (h - k3 * (b[1][1] + b[0][1])) / 2;
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
+}
+
+function fitSize(projection3, size, object3) {
+    return fitExtent(projection3, [
+        [0, 0], size
+    ], object3);
+}
+
+function fitWidth(projection3, width, object3) {
+    return fit(projection3, function(b) {
+        var w = +width,
+            k3 = w / (b[1][0] - b[0][0]),
+            x7 = (w - k3 * (b[1][0] + b[0][0])) / 2,
+            y7 = -k3 * b[0][1];
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
+}
+
+function fitHeight(projection3, height, object3) {
+    return fit(projection3, function(b) {
+        var h = +height,
+            k3 = h / (b[1][1] - b[0][1]),
+            x7 = -k3 * b[0][0],
+            y7 = (h - k3 * (b[1][1] + b[0][1])) / 2;
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
+}
+
+// node_modules/d3-geo/src/projection/resample.js
+var maxDepth = 16;
+var cosMinDistance = cos2(30 * radians2);
+
+function resample_default(project3, delta2) {
+    return +delta2 ? resample(project3, delta2) : resampleNone(project3);
+}
+
+function resampleNone(project3) {
+    return transformer({
+        point: function(x7, y7) {
+            x7 = project3(x7, y7);
+            this.stream.point(x7[0], x7[1]);
+        }
+    });
+}
+
+function resample(project3, delta2) {
+    function resampleLineTo(x011, y011, lambda07, a0, b03, c0, x13, y13, lambda13, a1, b13, c1, depth, stream) {
+        var dx = x13 - x011,
+            dy = y13 - y011,
+            d2 = dx * dx + dy * dy;
+        if (d2 > 4 * delta2 && depth--) {
+            var a7 = a0 + a1,
+                b = b03 + b13,
+                c11 = c0 + c1,
+                m5 = sqrt(a7 * a7 + b * b + c11 * c11),
+                phi22 = asin(c11 /= m5),
+                lambda23 = abs3(abs3(c11) - 1) < epsilon7 || abs3(lambda07 - lambda13) < epsilon7 ? (lambda07 + lambda13) / 2 : atan2(b, a7),
+                p = project3(lambda23, phi22),
+                x22 = p[0],
+                y22 = p[1],
+                dx2 = x22 - x011,
+                dy2 = y22 - y011,
+                dz = dy * dx2 - dx * dy2;
+            if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b03 * b13 + c0 * c1 < cosMinDistance) {
+                resampleLineTo(x011, y011, lambda07, a0, b03, c0, x22, y22, lambda23, a7 /= m5, b /= m5, c11, depth, stream);
+                stream.point(x22, y22);
+                resampleLineTo(x22, y22, lambda23, a7, b, c11, x13, y13, lambda13, a1, b13, c1, depth, stream);
+            }
+        }
+    }
+    return function(stream) {
+        var lambda007, x007, y007, a00, b00, c00, lambda07, x011, y011, a0, b03, c0;
+        var resampleStream = {
+            point: point11,
+            lineStart,
+            lineEnd,
+            polygonStart: function() {
+                stream.polygonStart();
+                resampleStream.lineStart = ringStart;
+            },
+            polygonEnd: function() {
+                stream.polygonEnd();
+                resampleStream.lineStart = lineStart;
+            }
+        };
+
+        function point11(x7, y7) {
+            x7 = project3(x7, y7);
+            stream.point(x7[0], x7[1]);
+        }
+
+        function lineStart() {
+            x011 = NaN;
+            resampleStream.point = linePoint3;
+            stream.lineStart();
+        }
+
+        function linePoint3(lambda, phi3) {
+            var c11 = cartesian([lambda, phi3]),
+                p = project3(lambda, phi3);
+            resampleLineTo(x011, y011, lambda07, a0, b03, c0, x011 = p[0], y011 = p[1], lambda07 = lambda, a0 = c11[0], b03 = c11[1], c0 = c11[2], maxDepth, stream);
+            stream.point(x011, y011);
+        }
+
+        function lineEnd() {
+            resampleStream.point = point11;
+            stream.lineEnd();
+        }
+
+        function ringStart() {
+            lineStart();
+            resampleStream.point = ringPoint;
+            resampleStream.lineEnd = ringEnd;
+        }
+
+        function ringPoint(lambda, phi3) {
+            linePoint3(lambda007 = lambda, phi3), x007 = x011, y007 = y011, a00 = a0, b00 = b03, c00 = c0;
+            resampleStream.point = linePoint3;
+        }
+
+        function ringEnd() {
+            resampleLineTo(x011, y011, lambda07, a0, b03, c0, x007, y007, lambda007, a00, b00, c00, maxDepth, stream);
+            resampleStream.lineEnd = lineEnd;
+            lineEnd();
+        }
+        return resampleStream;
+    };
+}
+
+// node_modules/d3-geo/src/projection/index.js
+var transformRadians = transformer({
+    point: function(x7, y7) {
+        this.stream.point(x7 * radians2, y7 * radians2);
+    }
+});
+
+function transformRotate(rotate) {
+    return transformer({
+        point: function(x7, y7) {
+            var r = rotate(x7, y7);
+            return this.stream.point(r[0], r[1]);
+        }
+    });
+}
+
+function scaleTranslate(k3, dx, dy, sx, sy) {
+    function transform3(x7, y7) {
+        x7 *= sx;
+        y7 *= sy;
+        return [dx + k3 * x7, dy - k3 * y7];
+    }
+    transform3.invert = function(x7, y7) {
+        return [(x7 - dx) / k3 * sx, (dy - y7) / k3 * sy];
+    };
+    return transform3;
+}
+
+function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
+    if (!alpha)
+        return scaleTranslate(k3, dx, dy, sx, sy);
+    var cosAlpha = cos2(alpha),
+        sinAlpha = sin2(alpha),
+        a7 = cosAlpha * k3,
+        b = sinAlpha * k3,
+        ai = cosAlpha / k3,
+        bi = sinAlpha / k3,
+        ci = (sinAlpha * dy - cosAlpha * dx) / k3,
+        fi = (sinAlpha * dx + cosAlpha * dy) / k3;
+
+    function transform3(x7, y7) {
+        x7 *= sx;
+        y7 *= sy;
+        return [a7 * x7 - b * y7 + dx, dy - b * x7 - a7 * y7];
+    }
+    transform3.invert = function(x7, y7) {
+        return [sx * (ai * x7 - bi * y7 + ci), sy * (fi - bi * x7 - ai * y7)];
+    };
+    return transform3;
+}
+
+function projection(project3) {
+    return projectionMutator(function() {
+        return project3;
+    })();
+}
+
+function projectionMutator(projectAt) {
+    var project3, k3 = 150,
+        x7 = 480,
+        y7 = 250,
+        lambda = 0,
+        phi3 = 0,
+        deltaLambda = 0,
+        deltaPhi = 0,
+        deltaGamma = 0,
+        rotate, alpha = 0,
+        sx = 1,
+        sy = 1,
+        theta = null,
+        preclip = antimeridian_default,
+        x011 = null,
+        y011, x13, y13, postclip = identity_default3,
+        delta2 = 0.5,
+        projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
+
+    function projection3(point11) {
+        return projectRotateTransform(point11[0] * radians2, point11[1] * radians2);
+    }
+
+    function invert(point11) {
+        point11 = projectRotateTransform.invert(point11[0], point11[1]);
+        return point11 && [point11[0] * degrees3, point11[1] * degrees3];
+    }
+    projection3.stream = function(stream) {
+        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
+    };
+    projection3.preclip = function(_) {
+        return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
+    };
+    projection3.postclip = function(_) {
+        return arguments.length ? (postclip = _, x011 = y011 = x13 = y13 = null, reset()) : postclip;
+    };
+    projection3.clipAngle = function(_) {
+        return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
+    };
+    projection3.clipExtent = function(_) {
+        return arguments.length ? (postclip = _ == null ? (x011 = y011 = x13 = y13 = null, identity_default3) : clipRectangle(x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
+        ];
+    };
+    projection3.scale = function(_) {
+        return arguments.length ? (k3 = +_, recenter()) : k3;
+    };
+    projection3.translate = function(_) {
+        return arguments.length ? (x7 = +_[0], y7 = +_[1], recenter()) : [x7, y7];
+    };
+    projection3.center = function(_) {
+        return arguments.length ? (lambda = _[0] % 360 * radians2, phi3 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi3 * degrees3];
+    };
+    projection3.rotate = function(_) {
+        return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
+    };
+    projection3.angle = function(_) {
+        return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
+    };
+    projection3.reflectX = function(_) {
+        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
+    };
+    projection3.reflectY = function(_) {
+        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
+    };
+    projection3.precision = function(_) {
+        return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
+    };
+    projection3.fitExtent = function(extent5, object3) {
+        return fitExtent(projection3, extent5, object3);
+    };
+    projection3.fitSize = function(size, object3) {
+        return fitSize(projection3, size, object3);
+    };
+    projection3.fitWidth = function(width, object3) {
+        return fitWidth(projection3, width, object3);
+    };
+    projection3.fitHeight = function(height, object3) {
+        return fitHeight(projection3, height, object3);
+    };
+
+    function recenter() {
+        var center3 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project3(lambda, phi3)),
+            transform3 = scaleTranslateRotate(k3, x7 - center3[0], y7 - center3[1], sx, sy, alpha);
+        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
+        projectTransform = compose_default(project3, transform3);
+        projectRotateTransform = compose_default(rotate, projectTransform);
+        projectResample = resample_default(projectTransform, delta2);
+        return reset();
+    }
+
+    function reset() {
+        cache = cacheStream = null;
+        return projection3;
+    }
+    return function() {
+        project3 = projectAt.apply(this, arguments);
+        projection3.invert = project3.invert && invert;
+        return recenter();
+    };
+}
+
+// node_modules/d3-geo/src/projection/conic.js
+function conicProjection(projectAt) {
+    var phi03 = 0,
+        phi13 = pi4 / 3,
+        m5 = projectionMutator(projectAt),
+        p = m5(phi03, phi13);
+    p.parallels = function(_) {
+        return arguments.length ? m5(phi03 = _[0] * radians2, phi13 = _[1] * radians2) : [phi03 * degrees3, phi13 * degrees3];
+    };
+    return p;
+}
+
+// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
+function cylindricalEqualAreaRaw(phi03) {
+    var cosPhi05 = cos2(phi03);
+
+    function forward(lambda, phi3) {
+        return [lambda * cosPhi05, sin2(phi3) / cosPhi05];
+    }
+    forward.invert = function(x7, y7) {
+        return [x7 / cosPhi05, asin(y7 * cosPhi05)];
+    };
+    return forward;
+}
+
+// node_modules/d3-geo/src/projection/conicEqualArea.js
+function conicEqualAreaRaw(y011, y13) {
+    var sy0 = sin2(y011),
+        n = (sy0 + sin2(y13)) / 2;
+    if (abs3(n) < epsilon7)
+        return cylindricalEqualAreaRaw(y011);
+    var c11 = 1 + sy0 * (2 * n - sy0),
+        r0 = sqrt(c11) / n;
+
+    function project3(x7, y7) {
+        var r = sqrt(c11 - 2 * n * sin2(y7)) / n;
+        return [r * sin2(x7 *= n), r0 - r * cos2(x7)];
+    }
+    project3.invert = function(x7, y7) {
+        var r0y = r0 - y7,
+            l = atan2(x7, abs3(r0y)) * sign(r0y);
+        if (r0y * n < 0)
+            l -= pi4 * sign(x7) * sign(r0y);
+        return [l / n, asin((c11 - (x7 * x7 + r0y * r0y) * n * n) / (2 * n))];
+    };
+    return project3;
+}
+
+function conicEqualArea_default() {
+    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
+}
+
+// node_modules/d3-geo/src/projection/albers.js
+function albers_default() {
+    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
+}
+
+// node_modules/d3-geo/src/projection/albersUsa.js
+function multiplex(streams) {
+    var n = streams.length;
+    return {
+        point: function(x7, y7) {
+            var i = -1;
+            while (++i < n)
+                streams[i].point(x7, y7);
+        },
+        sphere: function() {
+            var i = -1;
+            while (++i < n)
+                streams[i].sphere();
+        },
+        lineStart: function() {
+            var i = -1;
+            while (++i < n)
+                streams[i].lineStart();
+        },
+        lineEnd: function() {
+            var i = -1;
+            while (++i < n)
+                streams[i].lineEnd();
+        },
+        polygonStart: function() {
+            var i = -1;
+            while (++i < n)
+                streams[i].polygonStart();
+        },
+        polygonEnd: function() {
+            var i = -1;
+            while (++i < n)
+                streams[i].polygonEnd();
+        }
+    };
+}
+
+function albersUsa_default() {
+    var cache, cacheStream, lower48 = albers_default(),
+        lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+        alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+        hawaiiPoint, point11, pointStream = {
+            point: function(x7, y7) {
+                point11 = [x7, y7];
+            }
+        };
+
+    function albersUsa(coordinates3) {
+        var x7 = coordinates3[0],
+            y7 = coordinates3[1];
+        return point11 = null, (lower48Point.point(x7, y7), point11) || (alaskaPoint.point(x7, y7), point11) || (hawaiiPoint.point(x7, y7), point11);
+    }
+    albersUsa.invert = function(coordinates3) {
+        var k3 = lower48.scale(),
+            t = lower48.translate(),
+            x7 = (coordinates3[0] - t[0]) / k3,
+            y7 = (coordinates3[1] - t[1]) / k3;
+        return (y7 >= 0.12 && y7 < 0.234 && x7 >= -0.425 && x7 < -0.214 ? alaska : y7 >= 0.166 && y7 < 0.234 && x7 >= -0.214 && x7 < -0.115 ? hawaii : lower48).invert(coordinates3);
+    };
+    albersUsa.stream = function(stream) {
+        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
+    };
+    albersUsa.precision = function(_) {
+        if (!arguments.length)
+            return lower48.precision();
+        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
+        return reset();
+    };
+    albersUsa.scale = function(_) {
+        if (!arguments.length)
+            return lower48.scale();
+        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
+        return albersUsa.translate(lower48.translate());
+    };
+    albersUsa.translate = function(_) {
+        if (!arguments.length)
+            return lower48.translate();
+        var k3 = lower48.scale(),
+            x7 = +_[0],
+            y7 = +_[1];
+        lower48Point = lower48.translate(_).clipExtent([
+            [x7 - 0.455 * k3, y7 - 0.238 * k3],
+            [x7 + 0.455 * k3, y7 + 0.238 * k3]
+        ]).stream(pointStream);
+        alaskaPoint = alaska.translate([x7 - 0.307 * k3, y7 + 0.201 * k3]).clipExtent([
+            [x7 - 0.425 * k3 + epsilon7, y7 + 0.12 * k3 + epsilon7],
+            [x7 - 0.214 * k3 - epsilon7, y7 + 0.234 * k3 - epsilon7]
+        ]).stream(pointStream);
+        hawaiiPoint = hawaii.translate([x7 - 0.205 * k3, y7 + 0.212 * k3]).clipExtent([
+            [x7 - 0.214 * k3 + epsilon7, y7 + 0.166 * k3 + epsilon7],
+            [x7 - 0.115 * k3 - epsilon7, y7 + 0.234 * k3 - epsilon7]
+        ]).stream(pointStream);
+        return reset();
+    };
+    albersUsa.fitExtent = function(extent5, object3) {
+        return fitExtent(albersUsa, extent5, object3);
+    };
+    albersUsa.fitSize = function(size, object3) {
+        return fitSize(albersUsa, size, object3);
+    };
+    albersUsa.fitWidth = function(width, object3) {
+        return fitWidth(albersUsa, width, object3);
+    };
+    albersUsa.fitHeight = function(height, object3) {
+        return fitHeight(albersUsa, height, object3);
+    };
+
+    function reset() {
+        cache = cacheStream = null;
+        return albersUsa;
+    }
+    return albersUsa.scale(1070);
+}
+
+// node_modules/d3-geo/src/projection/azimuthal.js
+function azimuthalRaw(scale5) {
+    return function(x7, y7) {
+        var cx = cos2(x7),
+            cy = cos2(y7),
+            k3 = scale5(cx * cy);
+        if (k3 === Infinity)
+            return [2, 0];
+        return [
+            k3 * cy * sin2(x7),
+            k3 * sin2(y7)
+        ];
+    };
+}
+
+function azimuthalInvert(angle3) {
+    return function(x7, y7) {
+        var z = sqrt(x7 * x7 + y7 * y7),
+            c11 = angle3(z),
+            sc = sin2(c11),
+            cc3 = cos2(c11);
+        return [
+            atan2(x7 * sc, z * cc3),
+            asin(z && y7 * sc / z)
+        ];
+    };
+}
+
+// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
+var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
+    return sqrt(2 / (1 + cxcy));
+});
+azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
+    return 2 * asin(z / 2);
+});
+
+function azimuthalEqualArea_default() {
+    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
+}
+
+// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
+var azimuthalEquidistantRaw = azimuthalRaw(function(c11) {
+    return (c11 = acos(c11)) && c11 / sin2(c11);
+});
+azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
+    return z;
+});
+
+function azimuthalEquidistant_default() {
+    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
+}
+
+// node_modules/d3-geo/src/projection/mercator.js
+function mercatorRaw(lambda, phi3) {
+    return [lambda, log(tan((halfPi3 + phi3) / 2))];
+}
+mercatorRaw.invert = function(x7, y7) {
+    return [x7, 2 * atan(exp(y7)) - halfPi3];
+};
+
+function mercator_default() {
+    return mercatorProjection(mercatorRaw).scale(961 / tau5);
+}
+
+function mercatorProjection(project3) {
+    var m5 = projection(project3),
+        center3 = m5.center,
+        scale5 = m5.scale,
+        translate = m5.translate,
+        clipExtent = m5.clipExtent,
+        x011 = null,
+        y011, x13, y13;
+    m5.scale = function(_) {
+        return arguments.length ? (scale5(_), reclip()) : scale5();
+    };
+    m5.translate = function(_) {
+        return arguments.length ? (translate(_), reclip()) : translate();
+    };
+    m5.center = function(_) {
+        return arguments.length ? (center3(_), reclip()) : center3();
+    };
+    m5.clipExtent = function(_) {
+        return arguments.length ? (_ == null ? x011 = y011 = x13 = y13 = null : (x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reclip()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
+        ];
+    };
+
+    function reclip() {
+        var k3 = pi4 * scale5(),
+            t = m5(rotation_default(m5.rotate()).invert([0, 0]));
+        return clipExtent(x011 == null ? [
+            [t[0] - k3, t[1] - k3],
+            [t[0] + k3, t[1] + k3]
+        ] : project3 === mercatorRaw ? [
+            [Math.max(t[0] - k3, x011), y011],
+            [Math.min(t[0] + k3, x13), y13]
+        ] : [
+            [x011, Math.max(t[1] - k3, y011)],
+            [x13, Math.min(t[1] + k3, y13)]
+        ]);
+    }
+    return reclip();
+}
+
+// node_modules/d3-geo/src/projection/conicConformal.js
+function tany(y7) {
+    return tan((halfPi3 + y7) / 2);
+}
+
+function conicConformalRaw(y011, y13) {
+    var cy0 = cos2(y011),
+        n = y011 === y13 ? sin2(y011) : log(cy0 / cos2(y13)) / log(tany(y13) / tany(y011)),
+        f = cy0 * pow2(tany(y011), n) / n;
+    if (!n)
+        return mercatorRaw;
+
+    function project3(x7, y7) {
+        if (f > 0) {
+            if (y7 < -halfPi3 + epsilon7)
+                y7 = -halfPi3 + epsilon7;
+        } else {
+            if (y7 > halfPi3 - epsilon7)
+                y7 = halfPi3 - epsilon7;
+        }
+        var r = f / pow2(tany(y7), n);
+        return [r * sin2(n * x7), f - r * cos2(n * x7)];
+    }
+    project3.invert = function(x7, y7) {
+        var fy = f - y7,
+            r = sign(n) * sqrt(x7 * x7 + fy * fy),
+            l = atan2(x7, abs3(fy)) * sign(fy);
+        if (fy * n < 0)
+            l -= pi4 * sign(x7) * sign(fy);
+        return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];
+    };
+    return project3;
+}
+
+function conicConformal_default() {
+    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
+}
+
+// node_modules/d3-geo/src/projection/equirectangular.js
+function equirectangularRaw(lambda, phi3) {
+    return [lambda, phi3];
+}
+equirectangularRaw.invert = equirectangularRaw;
+
+function equirectangular_default() {
+    return projection(equirectangularRaw).scale(152.63);
+}
+
+// node_modules/d3-geo/src/projection/conicEquidistant.js
+function conicEquidistantRaw(y011, y13) {
+    var cy0 = cos2(y011),
+        n = y011 === y13 ? sin2(y011) : (cy0 - cos2(y13)) / (y13 - y011),
+        g = cy0 / n + y011;
+    if (abs3(n) < epsilon7)
+        return equirectangularRaw;
+
+    function project3(x7, y7) {
+        var gy = g - y7,
+            nx = n * x7;
+        return [gy * sin2(nx), g - gy * cos2(nx)];
+    }
+    project3.invert = function(x7, y7) {
+        var gy = g - y7,
+            l = atan2(x7, abs3(gy)) * sign(gy);
+        if (gy * n < 0)
+            l -= pi4 * sign(x7) * sign(gy);
+        return [l / n, g - sign(n) * sqrt(x7 * x7 + gy * gy)];
+    };
+    return project3;
+}
+
+function conicEquidistant_default() {
+    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
+}
+
+// node_modules/d3-geo/src/projection/equalEarth.js
+var A1 = 1.340264;
+var A2 = -0.081106;
+var A3 = 893e-6;
+var A4 = 3796e-6;
+var M = sqrt(3) / 2;
+var iterations = 12;
+
+function equalEarthRaw(lambda, phi3) {
+    var l = asin(M * sin2(phi3)),
+        l2 = l * l,
+        l6 = l2 * l2 * l2;
+    return [
+        lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
+        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
+    ];
+}
+equalEarthRaw.invert = function(x7, y7) {
+    var l = y7,
+        l2 = l * l,
+        l6 = l2 * l2 * l2;
+    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
+        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y7;
+        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
+        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
+        if (abs3(delta) < epsilon22)
+            break;
+    }
+    return [
+        M * x7 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
+        asin(sin2(l) / M)
+    ];
+};
+
+function equalEarth_default() {
+    return projection(equalEarthRaw).scale(177.158);
+}
+
+// node_modules/d3-geo/src/projection/gnomonic.js
+function gnomonicRaw(x7, y7) {
+    var cy = cos2(y7),
+        k3 = cos2(x7) * cy;
+    return [cy * sin2(x7) / k3, sin2(y7) / k3];
+}
+gnomonicRaw.invert = azimuthalInvert(atan);
+
+function gnomonic_default() {
+    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
+}
+
+// node_modules/d3-geo/src/projection/identity.js
+function identity_default4() {
+    var k3 = 1,
+        tx = 0,
+        ty = 0,
+        sx = 1,
+        sy = 1,
+        alpha = 0,
+        ca5, sa, x011 = null,
+        y011, x13, y13, kx3 = 1,
+        ky3 = 1,
+        transform3 = transformer({
+            point: function(x7, y7) {
+                var p = projection3([x7, y7]);
+                this.stream.point(p[0], p[1]);
+            }
+        }),
+        postclip = identity_default3,
+        cache, cacheStream;
+
+    function reset() {
+        kx3 = k3 * sx;
+        ky3 = k3 * sy;
+        cache = cacheStream = null;
+        return projection3;
+    }
+
+    function projection3(p) {
+        var x7 = p[0] * kx3,
+            y7 = p[1] * ky3;
+        if (alpha) {
+            var t = y7 * ca5 - x7 * sa;
+            x7 = x7 * ca5 + y7 * sa;
+            y7 = t;
+        }
+        return [x7 + tx, y7 + ty];
+    }
+    projection3.invert = function(p) {
+        var x7 = p[0] - tx,
+            y7 = p[1] - ty;
+        if (alpha) {
+            var t = y7 * ca5 + x7 * sa;
+            x7 = x7 * ca5 - y7 * sa;
+            y7 = t;
+        }
+        return [x7 / kx3, y7 / ky3];
+    };
+    projection3.stream = function(stream) {
+        return cache && cacheStream === stream ? cache : cache = transform3(postclip(cacheStream = stream));
+    };
+    projection3.postclip = function(_) {
+        return arguments.length ? (postclip = _, x011 = y011 = x13 = y13 = null, reset()) : postclip;
+    };
+    projection3.clipExtent = function(_) {
+        return arguments.length ? (postclip = _ == null ? (x011 = y011 = x13 = y13 = null, identity_default3) : clipRectangle(x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
+        ];
+    };
+    projection3.scale = function(_) {
+        return arguments.length ? (k3 = +_, reset()) : k3;
+    };
+    projection3.translate = function(_) {
+        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
+    };
+    projection3.angle = function(_) {
+        return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca5 = cos2(alpha), reset()) : alpha * degrees3;
+    };
+    projection3.reflectX = function(_) {
+        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
+    };
+    projection3.reflectY = function(_) {
+        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
+    };
+    projection3.fitExtent = function(extent5, object3) {
+        return fitExtent(projection3, extent5, object3);
+    };
+    projection3.fitSize = function(size, object3) {
+        return fitSize(projection3, size, object3);
+    };
+    projection3.fitWidth = function(width, object3) {
+        return fitWidth(projection3, width, object3);
+    };
+    projection3.fitHeight = function(height, object3) {
+        return fitHeight(projection3, height, object3);
+    };
+    return projection3;
+}
+
+// node_modules/d3-geo/src/projection/naturalEarth1.js
+function naturalEarth1Raw(lambda, phi3) {
+    var phi22 = phi3 * phi3,
+        phi4 = phi22 * phi22;
+    return [
+        lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
+        phi3 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
+    ];
+}
+naturalEarth1Raw.invert = function(x7, y7) {
+    var phi3 = y7,
+        i = 25,
+        delta;
+    do {
+        var phi22 = phi3 * phi3,
+            phi4 = phi22 * phi22;
+        phi3 -= delta = (phi3 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y7) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
+    } while (abs3(delta) > epsilon7 && --i > 0);
+    return [
+        x7 / (0.8707 + (phi22 = phi3 * phi3) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
+        phi3
+    ];
+};
+
+function naturalEarth1_default() {
+    return projection(naturalEarth1Raw).scale(175.295);
+}
+
+// node_modules/d3-geo/src/projection/orthographic.js
+function orthographicRaw(x7, y7) {
+    return [cos2(y7) * sin2(x7), sin2(y7)];
+}
+orthographicRaw.invert = azimuthalInvert(asin);
+
+function orthographic_default() {
+    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);
+}
+
+// node_modules/d3-geo/src/projection/stereographic.js
+function stereographicRaw(x7, y7) {
+    var cy = cos2(y7),
+        k3 = 1 + cos2(x7) * cy;
+    return [cy * sin2(x7) / k3, sin2(y7) / k3];
+}
+stereographicRaw.invert = azimuthalInvert(function(z) {
+    return 2 * atan(z);
+});
+
+function stereographic_default() {
+    return projection(stereographicRaw).scale(250).clipAngle(142);
+}
+
+// node_modules/d3-geo/src/projection/transverseMercator.js
+function transverseMercatorRaw(lambda, phi3) {
+    return [log(tan((halfPi3 + phi3) / 2)), -lambda];
+}
+transverseMercatorRaw.invert = function(x7, y7) {
+    return [-y7, 2 * atan(exp(x7)) - halfPi3];
+};
+
+function transverseMercator_default() {
+    var m5 = mercatorProjection(transverseMercatorRaw),
+        center3 = m5.center,
+        rotate = m5.rotate;
+    m5.center = function(_) {
+        return arguments.length ? center3([-_[1], _[0]]) : (_ = center3(), [_[1], -_[0]]);
+    };
+    m5.rotate = function(_) {
+        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
+    };
+    return rotate([0, 0, 90]).scale(159.155);
+}
+
+// node_modules/d3-hierarchy/src/cluster.js
+function defaultSeparation(a7, b) {
+    return a7.parent === b.parent ? 1 : 2;
+}
+
+function meanX(children3) {
+    return children3.reduce(meanXReduce, 0) / children3.length;
+}
+
+function meanXReduce(x7, c11) {
+    return x7 + c11.x;
+}
+
+function maxY(children3) {
+    return 1 + children3.reduce(maxYReduce, 0);
+}
+
+function maxYReduce(y7, c11) {
+    return Math.max(y7, c11.y);
+}
+
+function leafLeft(node) {
+    var children3;
+    while (children3 = node.children)
+        node = children3[0];
+    return node;
+}
+
+function leafRight(node) {
+    var children3;
+    while (children3 = node.children)
+        node = children3[children3.length - 1];
+    return node;
+}
+
+function cluster_default() {
+    var separation = defaultSeparation,
+        dx = 1,
+        dy = 1,
+        nodeSize = false;
+
+    function cluster3(root5) {
+        var previousNode, x7 = 0;
+        root5.eachAfter(function(node) {
+            var children3 = node.children;
+            if (children3) {
+                node.x = meanX(children3);
+                node.y = maxY(children3);
+            } else {
+                node.x = previousNode ? x7 += separation(node, previousNode) : 0;
+                node.y = 0;
+                previousNode = node;
+            }
+        });
+        var left3 = leafLeft(root5),
+            right3 = leafRight(root5),
+            x011 = left3.x - separation(left3, right3) / 2,
+            x13 = right3.x + separation(right3, left3) / 2;
+        return root5.eachAfter(nodeSize ? function(node) {
+            node.x = (node.x - root5.x) * dx;
+            node.y = (root5.y - node.y) * dy;
+        } : function(node) {
+            node.x = (node.x - x011) / (x13 - x011) * dx;
+            node.y = (1 - (root5.y ? node.y / root5.y : 1)) * dy;
+        });
+    }
+    cluster3.separation = function(x7) {
+        return arguments.length ? (separation = x7, cluster3) : separation;
+    };
+    cluster3.size = function(x7) {
+        return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], cluster3) : nodeSize ? null : [dx, dy];
+    };
+    cluster3.nodeSize = function(x7) {
+        return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], cluster3) : nodeSize ? [dx, dy] : null;
+    };
+    return cluster3;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/count.js
+function count2(node) {
+    var sum8 = 0,
+        children3 = node.children,
+        i = children3 && children3.length;
+    if (!i)
+        sum8 = 1;
+    else
+        while (--i >= 0)
+            sum8 += children3[i].value;
+    node.value = sum8;
+}
+
+function count_default() {
+    return this.eachAfter(count2);
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/each.js
+function each_default2(callback, that) {
+    let index5 = -1;
+    for (const node of this) {
+        callback.call(that, node, ++index5, this);
+    }
+    return this;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
+function eachBefore_default(callback, that) {
+    var node = this,
+        nodes = [node],
+        children3, i, index5 = -1;
+    while (node = nodes.pop()) {
+        callback.call(that, node, ++index5, this);
+        if (children3 = node.children) {
+            for (i = children3.length - 1; i >= 0; --i) {
+                nodes.push(children3[i]);
+            }
+        }
+    }
+    return this;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
+function eachAfter_default(callback, that) {
+    var node = this,
+        nodes = [node],
+        next = [],
+        children3, i, n, index5 = -1;
+    while (node = nodes.pop()) {
+        next.push(node);
+        if (children3 = node.children) {
+            for (i = 0, n = children3.length; i < n; ++i) {
+                nodes.push(children3[i]);
+            }
+        }
+    }
+    while (node = next.pop()) {
+        callback.call(that, node, ++index5, this);
+    }
+    return this;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/find.js
+function find_default2(callback, that) {
+    let index5 = -1;
+    for (const node of this) {
+        if (callback.call(that, node, ++index5, this)) {
+            return node;
+        }
+    }
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/sum.js
+function sum_default(value) {
+    return this.eachAfter(function(node) {
+        var sum8 = +value(node.data) || 0,
+            children3 = node.children,
+            i = children3 && children3.length;
+        while (--i >= 0)
+            sum8 += children3[i].value;
+        node.value = sum8;
+    });
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/sort.js
+function sort_default2(compare) {
+    return this.eachBefore(function(node) {
+        if (node.children) {
+            node.children.sort(compare);
+        }
+    });
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/path.js
+function path_default2(end) {
+    var start3 = this,
+        ancestor = leastCommonAncestor(start3, end),
+        nodes = [start3];
+    while (start3 !== ancestor) {
+        start3 = start3.parent;
+        nodes.push(start3);
+    }
+    var k3 = nodes.length;
+    while (end !== ancestor) {
+        nodes.splice(k3, 0, end);
+        end = end.parent;
+    }
+    return nodes;
+}
+
+function leastCommonAncestor(a7, b) {
+    if (a7 === b)
+        return a7;
+    var aNodes = a7.ancestors(),
+        bNodes = b.ancestors(),
+        c11 = null;
+    a7 = aNodes.pop();
+    b = bNodes.pop();
+    while (a7 === b) {
+        c11 = a7;
+        a7 = aNodes.pop();
+        b = bNodes.pop();
+    }
+    return c11;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
+function ancestors_default() {
+    var node = this,
+        nodes = [node];
+    while (node = node.parent) {
+        nodes.push(node);
+    }
+    return nodes;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/descendants.js
+function descendants_default() {
+    return Array.from(this);
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/leaves.js
+function leaves_default() {
+    var leaves = [];
+    this.eachBefore(function(node) {
+        if (!node.children) {
+            leaves.push(node);
+        }
+    });
+    return leaves;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/links.js
+function links_default() {
+    var root5 = this,
+        links = [];
+    root5.each(function(node) {
+        if (node !== root5) {
+            links.push({
+                source: node.parent,
+                target: node
+            });
+        }
+    });
+    return links;
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/iterator.js
+function* iterator_default2() {
+    var node = this,
+        current, next = [node],
+        children3, i, n;
+    do {
+        current = next.reverse(), next = [];
+        while (node = current.pop()) {
+            yield node;
+            if (children3 = node.children) {
+                for (i = 0, n = children3.length; i < n; ++i) {
+                    next.push(children3[i]);
+                }
+            }
+        }
+    } while (next.length);
+}
+
+// node_modules/d3-hierarchy/src/hierarchy/index.js
+function hierarchy(data, children3) {
+    if (data instanceof Map) {
+        data = [void 0, data];
+        if (children3 === void 0)
+            children3 = mapChildren;
+    } else if (children3 === void 0) {
+        children3 = objectChildren;
+    }
+    var root5 = new Node2(data),
+        node, nodes = [root5],
+        child, childs, i, n;
+    while (node = nodes.pop()) {
+        if ((childs = children3(node.data)) && (n = (childs = Array.from(childs)).length)) {
+            node.children = childs;
+            for (i = n - 1; i >= 0; --i) {
+                nodes.push(child = childs[i] = new Node2(childs[i]));
+                child.parent = node;
+                child.depth = node.depth + 1;
+            }
+        }
+    }
+    return root5.eachBefore(computeHeight);
+}
+
+function node_copy() {
+    return hierarchy(this).eachBefore(copyData);
+}
+
+function objectChildren(d) {
+    return d.children;
+}
+
+function mapChildren(d) {
+    return Array.isArray(d) ? d[1] : null;
+}
+
+function copyData(node) {
+    if (node.data.value !== void 0)
+        node.value = node.data.value;
+    node.data = node.data.data;
+}
+
+function computeHeight(node) {
+    var height = 0;
+    do
+        node.height = height;
+    while ((node = node.parent) && node.height < ++height);
+}
+
+function Node2(data) {
+    this.data = data;
+    this.depth = this.height = 0;
+    this.parent = null;
+}
+Node2.prototype = hierarchy.prototype = {
+    constructor: Node2,
+    count: count_default,
+    each: each_default2,
+    eachAfter: eachAfter_default,
+    eachBefore: eachBefore_default,
+    find: find_default2,
+    sum: sum_default,
+    sort: sort_default2,
+    path: path_default2,
+    ancestors: ancestors_default,
+    descendants: descendants_default,
+    leaves: leaves_default,
+    links: links_default,
+    copy: node_copy,
+    [Symbol.iterator]: iterator_default2
+};
+
+// node_modules/d3-hierarchy/src/accessors.js
+function optional(f) {
+    return f == null ? null : required(f);
+}
+
+function required(f) {
+    if (typeof f !== "function")
+        throw new Error();
+    return f;
+}
+
+// node_modules/d3-hierarchy/src/constant.js
+function constantZero() {
+    return 0;
+}
+
+function constant_default9(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// node_modules/d3-hierarchy/src/lcg.js
+var a2 = 1664525;
+var c2 = 1013904223;
+var m2 = 4294967296;
+
+function lcg_default2() {
+    let s3 = 1;
+    return () => (s3 = (a2 * s3 + c2) % m2) / m2;
+}
+
+// node_modules/d3-hierarchy/src/array.js
+function array_default2(x7) {
+    return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
+}
+
+function shuffle(array7, random) {
+    let m5 = array7.length,
+        t, i;
+    while (m5) {
+        i = random() * m5-- | 0;
+        t = array7[m5];
+        array7[m5] = array7[i];
+        array7[i] = t;
+    }
+    return array7;
+}
+
+// node_modules/d3-hierarchy/src/pack/enclose.js
+function enclose_default(circles) {
+    return packEncloseRandom(circles, lcg_default2());
+}
+
+function packEncloseRandom(circles, random) {
+    var i = 0,
+        n = (circles = shuffle(Array.from(circles), random)).length,
+        B5 = [],
+        p, e;
+    while (i < n) {
+        p = circles[i];
+        if (e && enclosesWeak(e, p))
+            ++i;
+        else
+            e = encloseBasis(B5 = extendBasis(B5, p)), i = 0;
+    }
+    return e;
+}
+
+function extendBasis(B5, p) {
+    var i, j;
+    if (enclosesWeakAll(p, B5))
+        return [p];
+    for (i = 0; i < B5.length; ++i) {
+        if (enclosesNot(p, B5[i]) && enclosesWeakAll(encloseBasis2(B5[i], p), B5)) {
+            return [B5[i], p];
+        }
+    }
+    for (i = 0; i < B5.length - 1; ++i) {
+        for (j = i + 1; j < B5.length; ++j) {
+            if (enclosesNot(encloseBasis2(B5[i], B5[j]), p) && enclosesNot(encloseBasis2(B5[i], p), B5[j]) && enclosesNot(encloseBasis2(B5[j], p), B5[i]) && enclosesWeakAll(encloseBasis3(B5[i], B5[j], p), B5)) {
+                return [B5[i], B5[j], p];
+            }
+        }
+    }
+    throw new Error();
+}
+
+function enclosesNot(a7, b) {
+    var dr = a7.r - b.r,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
+    return dr < 0 || dr * dr < dx * dx + dy * dy;
+}
+
+function enclosesWeak(a7, b) {
+    var dr = a7.r - b.r + Math.max(a7.r, b.r, 1) * 1e-9,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
+    return dr > 0 && dr * dr > dx * dx + dy * dy;
+}
+
+function enclosesWeakAll(a7, B5) {
+    for (var i = 0; i < B5.length; ++i) {
+        if (!enclosesWeak(a7, B5[i])) {
+            return false;
+        }
+    }
+    return true;
+}
+
+function encloseBasis(B5) {
+    switch (B5.length) {
+        case 1:
+            return encloseBasis1(B5[0]);
+        case 2:
+            return encloseBasis2(B5[0], B5[1]);
+        case 3:
+            return encloseBasis3(B5[0], B5[1], B5[2]);
+    }
+}
+
+function encloseBasis1(a7) {
+    return {
+        x: a7.x,
+        y: a7.y,
+        r: a7.r
+    };
+}
+
+function encloseBasis2(a7, b) {
+    var x13 = a7.x,
+        y13 = a7.y,
+        r1 = a7.r,
+        x22 = b.x,
+        y22 = b.y,
+        r2 = b.r,
+        x21 = x22 - x13,
+        y21 = y22 - y13,
+        r21 = r2 - r1,
+        l = Math.sqrt(x21 * x21 + y21 * y21);
+    return {
+        x: (x13 + x22 + x21 / l * r21) / 2,
+        y: (y13 + y22 + y21 / l * r21) / 2,
+        r: (l + r1 + r2) / 2
+    };
+}
+
+function encloseBasis3(a7, b, c11) {
+    var x13 = a7.x,
+        y13 = a7.y,
+        r1 = a7.r,
+        x22 = b.x,
+        y22 = b.y,
+        r2 = b.r,
+        x32 = c11.x,
+        y32 = c11.y,
+        r3 = c11.r,
+        a22 = x13 - x22,
+        a32 = x13 - x32,
+        b23 = y13 - y22,
+        b33 = y13 - y32,
+        c22 = r2 - r1,
+        c32 = r3 - r1,
+        d1 = x13 * x13 + y13 * y13 - r1 * r1,
+        d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2,
+        d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3,
+        ab7 = a32 * b23 - a22 * b33,
+        xa = (b23 * d3 - b33 * d2) / (ab7 * 2) - x13,
+        xb = (b33 * c22 - b23 * c32) / ab7,
+        ya = (a32 * d2 - a22 * d3) / (ab7 * 2) - y13,
+        yb = (a22 * c32 - a32 * c22) / ab7,
+        A6 = xb * xb + yb * yb - 1,
+        B5 = 2 * (r1 + xa * xb + ya * yb),
+        C4 = xa * xa + ya * ya - r1 * r1,
+        r = -(Math.abs(A6) > 1e-6 ? (B5 + Math.sqrt(B5 * B5 - 4 * A6 * C4)) / (2 * A6) : C4 / B5);
+    return {
+        x: x13 + xa + xb * r,
+        y: y13 + ya + yb * r,
+        r
+    };
+}
+
+// node_modules/d3-hierarchy/src/pack/siblings.js
+function place(b, a7, c11) {
+    var dx = b.x - a7.x,
+        x7, a22, dy = b.y - a7.y,
+        y7, b23, d2 = dx * dx + dy * dy;
+    if (d2) {
+        a22 = a7.r + c11.r, a22 *= a22;
+        b23 = b.r + c11.r, b23 *= b23;
+        if (a22 > b23) {
+            x7 = (d2 + b23 - a22) / (2 * d2);
+            y7 = Math.sqrt(Math.max(0, b23 / d2 - x7 * x7));
+            c11.x = b.x - x7 * dx - y7 * dy;
+            c11.y = b.y - x7 * dy + y7 * dx;
+        } else {
+            x7 = (d2 + a22 - b23) / (2 * d2);
+            y7 = Math.sqrt(Math.max(0, a22 / d2 - x7 * x7));
+            c11.x = a7.x + x7 * dx - y7 * dy;
+            c11.y = a7.y + x7 * dy + y7 * dx;
+        }
+    } else {
+        c11.x = a7.x + c11.r;
+        c11.y = a7.y;
+    }
+}
+
+function intersects(a7, b) {
+    var dr = a7.r + b.r - 1e-6,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
+    return dr > 0 && dr * dr > dx * dx + dy * dy;
+}
+
+function score(node) {
+    var a7 = node._,
+        b = node.next._,
+        ab7 = a7.r + b.r,
+        dx = (a7.x * b.r + b.x * a7.r) / ab7,
+        dy = (a7.y * b.r + b.y * a7.r) / ab7;
+    return dx * dx + dy * dy;
+}
+
+function Node3(circle3) {
+    this._ = circle3;
+    this.next = null;
+    this.previous = null;
+}
+
+function packSiblingsRandom(circles, random) {
+    if (!(n = (circles = array_default2(circles)).length))
+        return 0;
+    var a7, b, c11, n, aa3, ca5, i, j, k3, sj, sk;
+    a7 = circles[0], a7.x = 0, a7.y = 0;
+    if (!(n > 1))
+        return a7.r;
+    b = circles[1], a7.x = -b.r, b.x = a7.r, b.y = 0;
+    if (!(n > 2))
+        return a7.r + b.r;
+    place(b, a7, c11 = circles[2]);
+    a7 = new Node3(a7), b = new Node3(b), c11 = new Node3(c11);
+    a7.next = c11.previous = b;
+    b.next = a7.previous = c11;
+    c11.next = b.previous = a7;
+    pack:
+        for (i = 3; i < n; ++i) {
+            place(a7._, b._, c11 = circles[i]), c11 = new Node3(c11);
+            j = b.next, k3 = a7.previous, sj = b._.r, sk = a7._.r;
+            do {
+                if (sj <= sk) {
+                    if (intersects(j._, c11._)) {
+                        b = j, a7.next = b, b.previous = a7, --i;
+                        continue pack;
+                    }
+                    sj += j._.r, j = j.next;
+                } else {
+                    if (intersects(k3._, c11._)) {
+                        a7 = k3, a7.next = b, b.previous = a7, --i;
+                        continue pack;
+                    }
+                    sk += k3._.r, k3 = k3.previous;
+                }
+            } while (j !== k3.next);
+            c11.previous = a7, c11.next = b, a7.next = b.previous = b = c11;
+            aa3 = score(a7);
+            while ((c11 = c11.next) !== b) {
+                if ((ca5 = score(c11)) < aa3) {
+                    a7 = c11, aa3 = ca5;
+                }
+            }
+            b = a7.next;
+        }
+    a7 = [b._], c11 = b;
+    while ((c11 = c11.next) !== b)
+        a7.push(c11._);
+    c11 = packEncloseRandom(a7, random);
+    for (i = 0; i < n; ++i)
+        a7 = circles[i], a7.x -= c11.x, a7.y -= c11.y;
+    return c11.r;
+}
+
+function siblings_default(circles) {
+    packSiblingsRandom(circles, lcg_default2());
+    return circles;
+}
+
+// node_modules/d3-hierarchy/src/pack/index.js
+function defaultRadius2(d) {
+    return Math.sqrt(d.value);
+}
+
+function pack_default() {
+    var radius3 = null,
+        dx = 1,
+        dy = 1,
+        padding = constantZero;
+
+    function pack(root5) {
+        const random = lcg_default2();
+        root5.x = dx / 2, root5.y = dy / 2;
+        if (radius3) {
+            root5.eachBefore(radiusLeaf(radius3)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
+        } else {
+            root5.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root5.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root5.r)));
+        }
+        return root5;
+    }
+    pack.radius = function(x7) {
+        return arguments.length ? (radius3 = optional(x7), pack) : radius3;
+    };
+    pack.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], pack) : [dx, dy];
+    };
+    pack.padding = function(x7) {
+        return arguments.length ? (padding = typeof x7 === "function" ? x7 : constant_default9(+x7), pack) : padding;
+    };
+    return pack;
+}
+
+function radiusLeaf(radius3) {
+    return function(node) {
+        if (!node.children) {
+            node.r = Math.max(0, +radius3(node) || 0);
+        }
+    };
+}
+
+function packChildrenRandom(padding, k3, random) {
+    return function(node) {
+        if (children3 = node.children) {
+            var children3, i, n = children3.length,
+                r = padding(node) * k3 || 0,
+                e;
+            if (r)
+                for (i = 0; i < n; ++i)
+                    children3[i].r += r;
+            e = packSiblingsRandom(children3, random);
+            if (r)
+                for (i = 0; i < n; ++i)
+                    children3[i].r -= r;
+            node.r = e + r;
+        }
+    };
+}
+
+function translateChild(k3) {
+    return function(node) {
+        var parent = node.parent;
+        node.r *= k3;
+        if (parent) {
+            node.x = parent.x + k3 * node.x;
+            node.y = parent.y + k3 * node.y;
+        }
+    };
+}
+
+// node_modules/d3-hierarchy/src/treemap/round.js
+function round_default2(node) {
+    node.x0 = Math.round(node.x0);
+    node.y0 = Math.round(node.y0);
+    node.x1 = Math.round(node.x1);
+    node.y1 = Math.round(node.y1);
+}
+
+// node_modules/d3-hierarchy/src/treemap/dice.js
+function dice_default(parent, x011, y011, x13, y13) {
+    var nodes = parent.children,
+        node, i = -1,
+        n = nodes.length,
+        k3 = parent.value && (x13 - x011) / parent.value;
+    while (++i < n) {
+        node = nodes[i], node.y0 = y011, node.y1 = y13;
+        node.x0 = x011, node.x1 = x011 += node.value * k3;
+    }
+}
+
+// node_modules/d3-hierarchy/src/partition.js
+function partition_default() {
+    var dx = 1,
+        dy = 1,
+        padding = 0,
+        round3 = false;
+
+    function partition(root5) {
+        var n = root5.height + 1;
+        root5.x0 = root5.y0 = padding;
+        root5.x1 = dx;
+        root5.y1 = dy / n;
+        root5.eachBefore(positionNode(dy, n));
+        if (round3)
+            root5.eachBefore(round_default2);
+        return root5;
+    }
+
+    function positionNode(dy2, n) {
+        return function(node) {
+            if (node.children) {
+                dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
+            }
+            var x011 = node.x0,
+                y011 = node.y0,
+                x13 = node.x1 - padding,
+                y13 = node.y1 - padding;
+            if (x13 < x011)
+                x011 = x13 = (x011 + x13) / 2;
+            if (y13 < y011)
+                y011 = y13 = (y011 + y13) / 2;
+            node.x0 = x011;
+            node.y0 = y011;
+            node.x1 = x13;
+            node.y1 = y13;
+        };
+    }
+    partition.round = function(x7) {
+        return arguments.length ? (round3 = !!x7, partition) : round3;
+    };
+    partition.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], partition) : [dx, dy];
+    };
+    partition.padding = function(x7) {
+        return arguments.length ? (padding = +x7, partition) : padding;
+    };
+    return partition;
+}
+
+// node_modules/d3-hierarchy/src/stratify.js
+var preroot = {
+    depth: -1
+};
+var ambiguous = {};
+var imputed = {};
+
+function defaultId(d) {
+    return d.id;
+}
+
+function defaultParentId(d) {
+    return d.parentId;
+}
+
+function stratify_default() {
+    var id3 = defaultId,
+        parentId = defaultParentId,
+        path3;
+
+    function stratify(data) {
+        var nodes = Array.from(data),
+            currentId = id3,
+            currentParentId = parentId,
+            n, d, i, root5, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
+        if (path3 != null) {
+            const I = nodes.map((d2, i2) => normalize(path3(d2, i2, data)));
+            const P = I.map(parentof);
+            const S = new Set(I).add("");
+            for (const i2 of P) {
+                if (!S.has(i2)) {
+                    S.add(i2);
+                    I.push(i2);
+                    P.push(parentof(i2));
+                    nodes.push(imputed);
+                }
+            }
+            currentId = (_, i2) => I[i2];
+            currentParentId = (_, i2) => P[i2];
+        }
+        for (i = 0, n = nodes.length; i < n; ++i) {
+            d = nodes[i], node = nodes[i] = new Node2(d);
+            if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
+                nodeKey = node.id = nodeId;
+                nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
+            }
+            if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
+                node.parent = nodeId;
+            }
+        }
+        for (i = 0; i < n; ++i) {
+            node = nodes[i];
+            if (nodeId = node.parent) {
+                parent = nodeByKey.get(nodeId);
+                if (!parent)
+                    throw new Error("missing: " + nodeId);
+                if (parent === ambiguous)
+                    throw new Error("ambiguous: " + nodeId);
+                if (parent.children)
+                    parent.children.push(node);
+                else
+                    parent.children = [node];
+                node.parent = parent;
+            } else {
+                if (root5)
+                    throw new Error("multiple roots");
+                root5 = node;
+            }
+        }
+        if (!root5)
+            throw new Error("no root");
+        if (path3 != null) {
+            while (root5.data === imputed && root5.children.length === 1) {
+                root5 = root5.children[0], --n;
+            }
+            for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
+                node = nodes[i2];
+                if (node.data !== imputed)
+                    break;
+                node.data = null;
+            }
+        }
+        root5.parent = preroot;
+        root5.eachBefore(function(node2) {
+            node2.depth = node2.parent.depth + 1;
+            --n;
+        }).eachBefore(computeHeight);
+        root5.parent = null;
+        if (n > 0)
+            throw new Error("cycle");
+        return root5;
+    }
+    stratify.id = function(x7) {
+        return arguments.length ? (id3 = optional(x7), stratify) : id3;
+    };
+    stratify.parentId = function(x7) {
+        return arguments.length ? (parentId = optional(x7), stratify) : parentId;
+    };
+    stratify.path = function(x7) {
+        return arguments.length ? (path3 = optional(x7), stratify) : path3;
+    };
+    return stratify;
+}
+
+function normalize(path3) {
+    path3 = `${path3}`;
+    let i = path3.length;
+    if (slash(path3, i - 1) && !slash(path3, i - 2))
+        path3 = path3.slice(0, -1);
+    return path3[0] === "/" ? path3 : `/${path3}`;
+}
+
+function parentof(path3) {
+    let i = path3.length;
+    if (i < 2)
+        return "";
+    while (--i > 1)
+        if (slash(path3, i))
+            break;
+    return path3.slice(0, i);
+}
+
+function slash(path3, i) {
+    if (path3[i] === "/") {
+        let k3 = 0;
+        while (i > 0 && path3[--i] === "\\")
+            ++k3;
+        if ((k3 & 1) === 0)
+            return true;
+    }
+    return false;
+}
+
+// node_modules/d3-hierarchy/src/tree.js
+function defaultSeparation2(a7, b) {
+    return a7.parent === b.parent ? 1 : 2;
+}
+
+function nextLeft(v3) {
+    var children3 = v3.children;
+    return children3 ? children3[0] : v3.t;
+}
+
+function nextRight(v3) {
+    var children3 = v3.children;
+    return children3 ? children3[children3.length - 1] : v3.t;
+}
+
+function moveSubtree(wm, wp, shift) {
+    var change = shift / (wp.i - wm.i);
+    wp.c -= change;
+    wp.s += shift;
+    wm.c += change;
+    wp.z += shift;
+    wp.m += shift;
+}
+
+function executeShifts(v3) {
+    var shift = 0,
+        change = 0,
+        children3 = v3.children,
+        i = children3.length,
+        w;
+    while (--i >= 0) {
+        w = children3[i];
+        w.z += shift;
+        w.m += shift;
+        shift += w.s + (change += w.c);
+    }
+}
+
+function nextAncestor(vim, v3, ancestor) {
+    return vim.a.parent === v3.parent ? vim.a : ancestor;
+}
+
+function TreeNode(node, i) {
+    this._ = node;
+    this.parent = null;
+    this.children = null;
+    this.A = null;
+    this.a = this;
+    this.z = 0;
+    this.m = 0;
+    this.c = 0;
+    this.s = 0;
+    this.t = null;
+    this.i = i;
+}
+TreeNode.prototype = Object.create(Node2.prototype);
+
+function treeRoot(root5) {
+    var tree3 = new TreeNode(root5, 0),
+        node, nodes = [tree3],
+        child, children3, i, n;
+    while (node = nodes.pop()) {
+        if (children3 = node._.children) {
+            node.children = new Array(n = children3.length);
+            for (i = n - 1; i >= 0; --i) {
+                nodes.push(child = node.children[i] = new TreeNode(children3[i], i));
+                child.parent = node;
+            }
+        }
+    }
+    (tree3.parent = new TreeNode(null, 0)).children = [tree3];
+    return tree3;
+}
+
+function tree_default() {
+    var separation = defaultSeparation2,
+        dx = 1,
+        dy = 1,
+        nodeSize = null;
+
+    function tree3(root5) {
+        var t = treeRoot(root5);
+        t.eachAfter(firstWalk), t.parent.m = -t.z;
+        t.eachBefore(secondWalk);
+        if (nodeSize)
+            root5.eachBefore(sizeNode);
+        else {
+            var left3 = root5,
+                right3 = root5,
+                bottom3 = root5;
+            root5.eachBefore(function(node) {
+                if (node.x < left3.x)
+                    left3 = node;
+                if (node.x > right3.x)
+                    right3 = node;
+                if (node.depth > bottom3.depth)
+                    bottom3 = node;
+            });
+            var s3 = left3 === right3 ? 1 : separation(left3, right3) / 2,
+                tx = s3 - left3.x,
+                kx3 = dx / (right3.x + s3 + tx),
+                ky3 = dy / (bottom3.depth || 1);
+            root5.eachBefore(function(node) {
+                node.x = (node.x + tx) * kx3;
+                node.y = node.depth * ky3;
+            });
+        }
+        return root5;
+    }
+
+    function firstWalk(v3) {
+        var children3 = v3.children,
+            siblings = v3.parent.children,
+            w = v3.i ? siblings[v3.i - 1] : null;
+        if (children3) {
+            executeShifts(v3);
+            var midpoint = (children3[0].z + children3[children3.length - 1].z) / 2;
+            if (w) {
+                v3.z = w.z + separation(v3._, w._);
+                v3.m = v3.z - midpoint;
+            } else {
+                v3.z = midpoint;
+            }
+        } else if (w) {
+            v3.z = w.z + separation(v3._, w._);
+        }
+        v3.parent.A = apportion(v3, w, v3.parent.A || siblings[0]);
+    }
+
+    function secondWalk(v3) {
+        v3._.x = v3.z + v3.parent.m;
+        v3.m += v3.parent.m;
+    }
+
+    function apportion(v3, w, ancestor) {
+        if (w) {
+            var vip = v3,
+                vop = v3,
+                vim = w,
+                vom = vip.parent.children[0],
+                sip = vip.m,
+                sop = vop.m,
+                sim = vim.m,
+                som = vom.m,
+                shift;
+            while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
+                vom = nextLeft(vom);
+                vop = nextRight(vop);
+                vop.a = v3;
+                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
+                if (shift > 0) {
+                    moveSubtree(nextAncestor(vim, v3, ancestor), v3, shift);
+                    sip += shift;
+                    sop += shift;
+                }
+                sim += vim.m;
+                sip += vip.m;
+                som += vom.m;
+                sop += vop.m;
+            }
+            if (vim && !nextRight(vop)) {
+                vop.t = vim;
+                vop.m += sim - sop;
+            }
+            if (vip && !nextLeft(vom)) {
+                vom.t = vip;
+                vom.m += sip - som;
+                ancestor = v3;
+            }
+        }
+        return ancestor;
+    }
+
+    function sizeNode(node) {
+        node.x *= dx;
+        node.y = node.depth * dy;
+    }
+    tree3.separation = function(x7) {
+        return arguments.length ? (separation = x7, tree3) : separation;
+    };
+    tree3.size = function(x7) {
+        return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], tree3) : nodeSize ? null : [dx, dy];
+    };
+    tree3.nodeSize = function(x7) {
+        return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], tree3) : nodeSize ? [dx, dy] : null;
+    };
+    return tree3;
+}
+
+// node_modules/d3-hierarchy/src/treemap/slice.js
+function slice_default(parent, x011, y011, x13, y13) {
+    var nodes = parent.children,
+        node, i = -1,
+        n = nodes.length,
+        k3 = parent.value && (y13 - y011) / parent.value;
+    while (++i < n) {
+        node = nodes[i], node.x0 = x011, node.x1 = x13;
+        node.y0 = y011, node.y1 = y011 += node.value * k3;
+    }
+}
+
+// node_modules/d3-hierarchy/src/treemap/squarify.js
+var phi = (1 + Math.sqrt(5)) / 2;
+
+function squarifyRatio(ratio, parent, x011, y011, x13, y13) {
+    var rows = [],
+        nodes = parent.children,
+        row, nodeValue, i0 = 0,
+        i1 = 0,
+        n = nodes.length,
+        dx, dy, value = parent.value,
+        sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
+    while (i0 < n) {
+        dx = x13 - x011, dy = y13 - y011;
+        do
+            sumValue = nodes[i1++].value;
+        while (!sumValue && i1 < n);
+        minValue = maxValue = sumValue;
+        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
+        beta = sumValue * sumValue * alpha;
+        minRatio = Math.max(maxValue / beta, beta / minValue);
+        for (; i1 < n; ++i1) {
+            sumValue += nodeValue = nodes[i1].value;
+            if (nodeValue < minValue)
+                minValue = nodeValue;
+            if (nodeValue > maxValue)
+                maxValue = nodeValue;
+            beta = sumValue * sumValue * alpha;
+            newRatio = Math.max(maxValue / beta, beta / minValue);
+            if (newRatio > minRatio) {
+                sumValue -= nodeValue;
+                break;
+            }
+            minRatio = newRatio;
+        }
+        rows.push(row = {
+            value: sumValue,
+            dice: dx < dy,
+            children: nodes.slice(i0, i1)
+        });
+        if (row.dice)
+            dice_default(row, x011, y011, x13, value ? y011 += dy * sumValue / value : y13);
+        else
+            slice_default(row, x011, y011, value ? x011 += dx * sumValue / value : x13, y13);
+        value -= sumValue, i0 = i1;
+    }
+    return rows;
+}
+var squarify_default = function custom10(ratio) {
+    function squarify(parent, x011, y011, x13, y13) {
+        squarifyRatio(ratio, parent, x011, y011, x13, y13);
+    }
+    squarify.ratio = function(x7) {
+        return custom10((x7 = +x7) > 1 ? x7 : 1);
+    };
+    return squarify;
+}(phi);
+
+// node_modules/d3-hierarchy/src/treemap/index.js
+function treemap_default() {
+    var tile = squarify_default,
+        round3 = false,
+        dx = 1,
+        dy = 1,
+        paddingStack = [0],
+        paddingInner = constantZero,
+        paddingTop = constantZero,
+        paddingRight = constantZero,
+        paddingBottom = constantZero,
+        paddingLeft = constantZero;
+
+    function treemap(root5) {
+        root5.x0 = root5.y0 = 0;
+        root5.x1 = dx;
+        root5.y1 = dy;
+        root5.eachBefore(positionNode);
+        paddingStack = [0];
+        if (round3)
+            root5.eachBefore(round_default2);
+        return root5;
+    }
+
+    function positionNode(node) {
+        var p = paddingStack[node.depth],
+            x011 = node.x0 + p,
+            y011 = node.y0 + p,
+            x13 = node.x1 - p,
+            y13 = node.y1 - p;
+        if (x13 < x011)
+            x011 = x13 = (x011 + x13) / 2;
+        if (y13 < y011)
+            y011 = y13 = (y011 + y13) / 2;
+        node.x0 = x011;
+        node.y0 = y011;
+        node.x1 = x13;
+        node.y1 = y13;
+        if (node.children) {
+            p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
+            x011 += paddingLeft(node) - p;
+            y011 += paddingTop(node) - p;
+            x13 -= paddingRight(node) - p;
+            y13 -= paddingBottom(node) - p;
+            if (x13 < x011)
+                x011 = x13 = (x011 + x13) / 2;
+            if (y13 < y011)
+                y011 = y13 = (y011 + y13) / 2;
+            tile(node, x011, y011, x13, y13);
+        }
+    }
+    treemap.round = function(x7) {
+        return arguments.length ? (round3 = !!x7, treemap) : round3;
+    };
+    treemap.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], treemap) : [dx, dy];
+    };
+    treemap.tile = function(x7) {
+        return arguments.length ? (tile = required(x7), treemap) : tile;
+    };
+    treemap.padding = function(x7) {
+        return arguments.length ? treemap.paddingInner(x7).paddingOuter(x7) : treemap.paddingInner();
+    };
+    treemap.paddingInner = function(x7) {
+        return arguments.length ? (paddingInner = typeof x7 === "function" ? x7 : constant_default9(+x7), treemap) : paddingInner;
+    };
+    treemap.paddingOuter = function(x7) {
+        return arguments.length ? treemap.paddingTop(x7).paddingRight(x7).paddingBottom(x7).paddingLeft(x7) : treemap.paddingTop();
+    };
+    treemap.paddingTop = function(x7) {
+        return arguments.length ? (paddingTop = typeof x7 === "function" ? x7 : constant_default9(+x7), treemap) : paddingTop;
+    };
+    treemap.paddingRight = function(x7) {
+        return arguments.length ? (paddingRight = typeof x7 === "function" ? x7 : constant_default9(+x7), treemap) : paddingRight;
+    };
+    treemap.paddingBottom = function(x7) {
+        return arguments.length ? (paddingBottom = typeof x7 === "function" ? x7 : constant_default9(+x7), treemap) : paddingBottom;
+    };
+    treemap.paddingLeft = function(x7) {
+        return arguments.length ? (paddingLeft = typeof x7 === "function" ? x7 : constant_default9(+x7), treemap) : paddingLeft;
+    };
+    return treemap;
+}
+
+// node_modules/d3-hierarchy/src/treemap/binary.js
+function binary_default(parent, x011, y011, x13, y13) {
+    var nodes = parent.children,
+        i, n = nodes.length,
+        sum8, sums = new Array(n + 1);
+    for (sums[0] = sum8 = i = 0; i < n; ++i) {
+        sums[i + 1] = sum8 += nodes[i].value;
+    }
+    partition(0, n, parent.value, x011, y011, x13, y13);
+
+    function partition(i2, j, value, x012, y012, x14, y14) {
+        if (i2 >= j - 1) {
+            var node = nodes[i2];
+            node.x0 = x012, node.y0 = y012;
+            node.x1 = x14, node.y1 = y14;
+            return;
+        }
+        var valueOffset = sums[i2],
+            valueTarget = value / 2 + valueOffset,
+            k3 = i2 + 1,
+            hi = j - 1;
+        while (k3 < hi) {
+            var mid3 = k3 + hi >>> 1;
+            if (sums[mid3] < valueTarget)
+                k3 = mid3 + 1;
+            else
+                hi = mid3;
+        }
+        if (valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3)
+            --k3;
+        var valueLeft = sums[k3] - valueOffset,
+            valueRight = value - valueLeft;
+        if (x14 - x012 > y14 - y012) {
+            var xk = value ? (x012 * valueRight + x14 * valueLeft) / value : x14;
+            partition(i2, k3, valueLeft, x012, y012, xk, y14);
+            partition(k3, j, valueRight, xk, y012, x14, y14);
+        } else {
+            var yk = value ? (y012 * valueRight + y14 * valueLeft) / value : y14;
+            partition(i2, k3, valueLeft, x012, y012, x14, yk);
+            partition(k3, j, valueRight, x012, yk, x14, y14);
+        }
+    }
+}
+
+// node_modules/d3-hierarchy/src/treemap/sliceDice.js
+function sliceDice_default(parent, x011, y011, x13, y13) {
+    (parent.depth & 1 ? slice_default : dice_default)(parent, x011, y011, x13, y13);
+}
+
+// node_modules/d3-hierarchy/src/treemap/resquarify.js
+var resquarify_default = function custom11(ratio) {
+    function resquarify(parent, x011, y011, x13, y13) {
+        if ((rows = parent._squarify) && rows.ratio === ratio) {
+            var rows, row, nodes, i, j = -1,
+                n, m5 = rows.length,
+                value = parent.value;
+            while (++j < m5) {
+                row = rows[j], nodes = row.children;
+                for (i = row.value = 0, n = nodes.length; i < n; ++i)
+                    row.value += nodes[i].value;
+                if (row.dice)
+                    dice_default(row, x011, y011, x13, value ? y011 += (y13 - y011) * row.value / value : y13);
+                else
+                    slice_default(row, x011, y011, value ? x011 += (x13 - x011) * row.value / value : x13, y13);
+                value -= row.value;
+            }
+        } else {
+            parent._squarify = rows = squarifyRatio(ratio, parent, x011, y011, x13, y13);
+            rows.ratio = ratio;
+        }
+    }
+    resquarify.ratio = function(x7) {
+        return custom11((x7 = +x7) > 1 ? x7 : 1);
+    };
+    return resquarify;
+}(phi);
+
+// node_modules/d3-polygon/src/area.js
+function area_default4(polygon) {
+    var i = -1,
+        n = polygon.length,
+        a7, b = polygon[n - 1],
+        area3 = 0;
+    while (++i < n) {
+        a7 = b;
+        b = polygon[i];
+        area3 += a7[1] * b[0] - a7[0] * b[1];
+    }
+    return area3 / 2;
+}
+
+// node_modules/d3-polygon/src/centroid.js
+function centroid_default3(polygon) {
+    var i = -1,
+        n = polygon.length,
+        x7 = 0,
+        y7 = 0,
+        a7, b = polygon[n - 1],
+        c11, k3 = 0;
+    while (++i < n) {
+        a7 = b;
+        b = polygon[i];
+        k3 += c11 = a7[0] * b[1] - b[0] * a7[1];
+        x7 += (a7[0] + b[0]) * c11;
+        y7 += (a7[1] + b[1]) * c11;
+    }
+    return k3 *= 3, [x7 / k3, y7 / k3];
+}
+
+// node_modules/d3-polygon/src/cross.js
+function cross_default(a7, b, c11) {
+    return (b[0] - a7[0]) * (c11[1] - a7[1]) - (b[1] - a7[1]) * (c11[0] - a7[0]);
+}
+
+// node_modules/d3-polygon/src/hull.js
+function lexicographicOrder(a7, b) {
+    return a7[0] - b[0] || a7[1] - b[1];
+}
+
+function computeUpperHullIndexes(points) {
+    const n = points.length,
+        indexes3 = [0, 1];
+    let size = 2,
+        i;
+    for (i = 2; i < n; ++i) {
+        while (size > 1 && cross_default(points[indexes3[size - 2]], points[indexes3[size - 1]], points[i]) <= 0)
+            --size;
+        indexes3[size++] = i;
+    }
+    return indexes3.slice(0, size);
+}
+
+function hull_default(points) {
+    if ((n = points.length) < 3)
+        return null;
+    var i, n, sortedPoints = new Array(n),
+        flippedPoints = new Array(n);
+    for (i = 0; i < n; ++i)
+        sortedPoints[i] = [+points[i][0], +points[i][1], i];
+    sortedPoints.sort(lexicographicOrder);
+    for (i = 0; i < n; ++i)
+        flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
+    var upperIndexes = computeUpperHullIndexes(sortedPoints),
+        lowerIndexes = computeUpperHullIndexes(flippedPoints);
+    var skipLeft = lowerIndexes[0] === upperIndexes[0],
+        skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
+        hull3 = [];
+    for (i = upperIndexes.length - 1; i >= 0; --i)
+        hull3.push(points[sortedPoints[upperIndexes[i]][2]]);
+    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
+        hull3.push(points[sortedPoints[lowerIndexes[i]][2]]);
+    return hull3;
+}
+
+// node_modules/d3-polygon/src/contains.js
+function contains_default3(polygon, point11) {
+    var n = polygon.length,
+        p = polygon[n - 1],
+        x7 = point11[0],
+        y7 = point11[1],
+        x011 = p[0],
+        y011 = p[1],
+        x13, y13, inside = false;
+    for (var i = 0; i < n; ++i) {
+        p = polygon[i], x13 = p[0], y13 = p[1];
+        if (y13 > y7 !== y011 > y7 && x7 < (x011 - x13) * (y7 - y13) / (y011 - y13) + x13)
+            inside = !inside;
+        x011 = x13, y011 = y13;
+    }
+    return inside;
+}
+
+// node_modules/d3-polygon/src/length.js
+function length_default2(polygon) {
+    var i = -1,
+        n = polygon.length,
+        b = polygon[n - 1],
+        xa, ya, xb = b[0],
+        yb = b[1],
+        perimeter = 0;
+    while (++i < n) {
+        xa = xb;
+        ya = yb;
+        b = polygon[i];
+        xb = b[0];
+        yb = b[1];
+        xa -= xb;
+        ya -= yb;
+        perimeter += Math.hypot(xa, ya);
+    }
+    return perimeter;
+}
+
+// node_modules/d3-random/src/defaultSource.js
+var defaultSource_default = Math.random;
+
+// node_modules/d3-random/src/uniform.js
+var uniform_default = function sourceRandomUniform(source) {
+    function randomUniform(min7, max9) {
+        min7 = min7 == null ? 0 : +min7;
+        max9 = max9 == null ? 1 : +max9;
+        if (arguments.length === 1)
+            max9 = min7, min7 = 0;
+        else
+            max9 -= min7;
+        return function() {
+            return source() * max9 + min7;
+        };
+    }
+    randomUniform.source = sourceRandomUniform;
+    return randomUniform;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/int.js
+var int_default = function sourceRandomInt(source) {
+    function randomInt(min7, max9) {
+        if (arguments.length < 2)
+            max9 = min7, min7 = 0;
+        min7 = Math.floor(min7);
+        max9 = Math.floor(max9) - min7;
+        return function() {
+            return Math.floor(source() * max9 + min7);
+        };
+    }
+    randomInt.source = sourceRandomInt;
+    return randomInt;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/normal.js
+var normal_default = function sourceRandomNormal(source) {
+    function randomNormal(mu, sigma) {
+        var x7, r;
+        mu = mu == null ? 0 : +mu;
+        sigma = sigma == null ? 1 : +sigma;
+        return function() {
+            var y7;
+            if (x7 != null)
+                y7 = x7, x7 = null;
+            else
+                do {
+                    x7 = source() * 2 - 1;
+                    y7 = source() * 2 - 1;
+                    r = x7 * x7 + y7 * y7;
+                } while (!r || r > 1);
+            return mu + sigma * y7 * Math.sqrt(-2 * Math.log(r) / r);
+        };
+    }
+    randomNormal.source = sourceRandomNormal;
+    return randomNormal;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/logNormal.js
+var logNormal_default = function sourceRandomLogNormal(source) {
+    var N = normal_default.source(source);
+
+    function randomLogNormal() {
+        var randomNormal = N.apply(this, arguments);
+        return function() {
+            return Math.exp(randomNormal());
+        };
+    }
+    randomLogNormal.source = sourceRandomLogNormal;
+    return randomLogNormal;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/irwinHall.js
+var irwinHall_default = function sourceRandomIrwinHall(source) {
+    function randomIrwinHall(n) {
+        if ((n = +n) <= 0)
+            return () => 0;
+        return function() {
+            for (var sum8 = 0, i = n; i > 1; --i)
+                sum8 += source();
+            return sum8 + i * source();
+        };
+    }
+    randomIrwinHall.source = sourceRandomIrwinHall;
+    return randomIrwinHall;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/bates.js
+var bates_default = function sourceRandomBates(source) {
+    var I = irwinHall_default.source(source);
+
+    function randomBates(n) {
+        if ((n = +n) === 0)
+            return source;
+        var randomIrwinHall = I(n);
+        return function() {
+            return randomIrwinHall() / n;
+        };
+    }
+    randomBates.source = sourceRandomBates;
+    return randomBates;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/exponential.js
+var exponential_default = function sourceRandomExponential(source) {
+    function randomExponential(lambda) {
+        return function() {
+            return -Math.log1p(-source()) / lambda;
+        };
+    }
+    randomExponential.source = sourceRandomExponential;
+    return randomExponential;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/pareto.js
+var pareto_default = function sourceRandomPareto(source) {
+    function randomPareto(alpha) {
+        if ((alpha = +alpha) < 0)
+            throw new RangeError("invalid alpha");
+        alpha = 1 / -alpha;
+        return function() {
+            return Math.pow(1 - source(), alpha);
+        };
+    }
+    randomPareto.source = sourceRandomPareto;
+    return randomPareto;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/bernoulli.js
+var bernoulli_default = function sourceRandomBernoulli(source) {
+    function randomBernoulli(p) {
+        if ((p = +p) < 0 || p > 1)
+            throw new RangeError("invalid p");
+        return function() {
+            return Math.floor(source() + p);
+        };
+    }
+    randomBernoulli.source = sourceRandomBernoulli;
+    return randomBernoulli;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/geometric.js
+var geometric_default = function sourceRandomGeometric(source) {
+    function randomGeometric(p) {
+        if ((p = +p) < 0 || p > 1)
+            throw new RangeError("invalid p");
+        if (p === 0)
+            return () => Infinity;
+        if (p === 1)
+            return () => 1;
+        p = Math.log1p(-p);
+        return function() {
+            return 1 + Math.floor(Math.log1p(-source()) / p);
+        };
+    }
+    randomGeometric.source = sourceRandomGeometric;
+    return randomGeometric;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/gamma.js
+var gamma_default = function sourceRandomGamma(source) {
+    var randomNormal = normal_default.source(source)();
+
+    function randomGamma(k3, theta) {
+        if ((k3 = +k3) < 0)
+            throw new RangeError("invalid k");
+        if (k3 === 0)
+            return () => 0;
+        theta = theta == null ? 1 : +theta;
+        if (k3 === 1)
+            return () => -Math.log1p(-source()) * theta;
+        var d = (k3 < 1 ? k3 + 1 : k3) - 1 / 3,
+            c11 = 1 / (3 * Math.sqrt(d)),
+            multiplier = k3 < 1 ? () => Math.pow(source(), 1 / k3) : () => 1;
+        return function() {
+            do {
+                do {
+                    var x7 = randomNormal(),
+                        v3 = 1 + c11 * x7;
+                } while (v3 <= 0);
+                v3 *= v3 * v3;
+                var u7 = 1 - source();
+            } while (u7 >= 1 - 0.0331 * x7 * x7 * x7 * x7 && Math.log(u7) >= 0.5 * x7 * x7 + d * (1 - v3 + Math.log(v3)));
+            return d * v3 * multiplier() * theta;
+        };
+    }
+    randomGamma.source = sourceRandomGamma;
+    return randomGamma;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/beta.js
+var beta_default = function sourceRandomBeta(source) {
+    var G = gamma_default.source(source);
+
+    function randomBeta(alpha, beta) {
+        var X4 = G(alpha),
+            Y4 = G(beta);
+        return function() {
+            var x7 = X4();
+            return x7 === 0 ? 0 : x7 / (x7 + Y4());
+        };
+    }
+    randomBeta.source = sourceRandomBeta;
+    return randomBeta;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/binomial.js
+var binomial_default = function sourceRandomBinomial(source) {
+    var G = geometric_default.source(source),
+        B5 = beta_default.source(source);
+
+    function randomBinomial(n, p) {
+        n = +n;
+        if ((p = +p) >= 1)
+            return () => n;
+        if (p <= 0)
+            return () => 0;
+        return function() {
+            var acc = 0,
+                nn = n,
+                pp = p;
+            while (nn * pp > 16 && nn * (1 - pp) > 16) {
+                var i = Math.floor((nn + 1) * pp),
+                    y7 = B5(i, nn - i + 1)();
+                if (y7 <= pp) {
+                    acc += i;
+                    nn -= i;
+                    pp = (pp - y7) / (1 - y7);
+                } else {
+                    nn = i - 1;
+                    pp /= y7;
+                }
+            }
+            var sign5 = pp < 0.5,
+                pFinal = sign5 ? pp : 1 - pp,
+                g = G(pFinal);
+            for (var s3 = g(), k3 = 0; s3 <= nn; ++k3)
+                s3 += g();
+            return acc + (sign5 ? k3 : nn - k3);
+        };
+    }
+    randomBinomial.source = sourceRandomBinomial;
+    return randomBinomial;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/weibull.js
+var weibull_default = function sourceRandomWeibull(source) {
+    function randomWeibull(k3, a7, b) {
+        var outerFunc;
+        if ((k3 = +k3) === 0) {
+            outerFunc = (x7) => -Math.log(x7);
+        } else {
+            k3 = 1 / k3;
+            outerFunc = (x7) => Math.pow(x7, k3);
+        }
+        a7 = a7 == null ? 0 : +a7;
+        b = b == null ? 1 : +b;
+        return function() {
+            return a7 + b * outerFunc(-Math.log1p(-source()));
+        };
+    }
+    randomWeibull.source = sourceRandomWeibull;
+    return randomWeibull;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/cauchy.js
+var cauchy_default = function sourceRandomCauchy(source) {
+    function randomCauchy(a7, b) {
+        a7 = a7 == null ? 0 : +a7;
+        b = b == null ? 1 : +b;
+        return function() {
+            return a7 + b * Math.tan(Math.PI * source());
+        };
+    }
+    randomCauchy.source = sourceRandomCauchy;
+    return randomCauchy;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/logistic.js
+var logistic_default = function sourceRandomLogistic(source) {
+    function randomLogistic(a7, b) {
+        a7 = a7 == null ? 0 : +a7;
+        b = b == null ? 1 : +b;
+        return function() {
+            var u7 = source();
+            return a7 + b * Math.log(u7 / (1 - u7));
+        };
+    }
+    randomLogistic.source = sourceRandomLogistic;
+    return randomLogistic;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/poisson.js
+var poisson_default = function sourceRandomPoisson(source) {
+    var G = gamma_default.source(source),
+        B5 = binomial_default.source(source);
+
+    function randomPoisson(lambda) {
+        return function() {
+            var acc = 0,
+                l = lambda;
+            while (l > 16) {
+                var n = Math.floor(0.875 * l),
+                    t = G(n)();
+                if (t > l)
+                    return acc + B5(n - 1, l / t)();
+                acc += n;
+                l -= t;
+            }
+            for (var s3 = -Math.log1p(-source()), k3 = 0; s3 <= l; ++k3)
+                s3 -= Math.log1p(-source());
+            return acc + k3;
+        };
+    }
+    randomPoisson.source = sourceRandomPoisson;
+    return randomPoisson;
+}(defaultSource_default);
+
+// node_modules/d3-random/src/lcg.js
+var mul = 1664525;
+var inc = 1013904223;
+var eps = 1 / 4294967296;
+
+function lcg(seed = Math.random()) {
+    let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
+    return () => (state = mul * state + inc | 0, eps * (state >>> 0));
+}
+
+// node_modules/d3-scale/src/init.js
+function initRange(domain, range9) {
+    switch (arguments.length) {
+        case 0:
+            break;
+        case 1:
+            this.range(domain);
+            break;
+        default:
+            this.range(range9).domain(domain);
+            break;
+    }
+    return this;
+}
+
+function initInterpolator(domain, interpolator) {
+    switch (arguments.length) {
+        case 0:
+            break;
+        case 1: {
+            if (typeof domain === "function")
+                this.interpolator(domain);
+            else
+                this.range(domain);
+            break;
+        }
+        default: {
+            this.domain(domain);
+            if (typeof interpolator === "function")
+                this.interpolator(interpolator);
+            else
+                this.range(interpolator);
+            break;
+        }
+    }
+    return this;
+}
+
+// node_modules/d3-scale/src/ordinal.js
+var implicit = Symbol("implicit");
+
+function ordinal() {
+    var index5 = new InternMap(),
+        domain = [],
+        range9 = [],
+        unknown = implicit;
+
+    function scale5(d) {
+        let i = index5.get(d);
+        if (i === void 0) {
+            if (unknown !== implicit)
+                return unknown;
+            index5.set(d, i = domain.push(d) - 1);
+        }
+        return range9[i % range9.length];
+    }
+    scale5.domain = function(_) {
+        if (!arguments.length)
+            return domain.slice();
+        domain = [], index5 = new InternMap();
+        for (const value of _) {
+            if (index5.has(value))
+                continue;
+            index5.set(value, domain.push(value) - 1);
+        }
+        return scale5;
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), scale5) : range9.slice();
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    scale5.copy = function() {
+        return ordinal(domain, range9).unknown(unknown);
+    };
+    initRange.apply(scale5, arguments);
+    return scale5;
+}
+
+// node_modules/d3-scale/src/band.js
+function band() {
+    var scale5 = ordinal().unknown(void 0),
+        domain = scale5.domain,
+        ordinalRange3 = scale5.range,
+        r0 = 0,
+        r1 = 1,
+        step, bandwidth, round3 = false,
+        paddingInner = 0,
+        paddingOuter = 0,
+        align = 0.5;
+    delete scale5.unknown;
+
+    function rescale() {
+        var n = domain().length,
+            reverse5 = r1 < r0,
+            start3 = reverse5 ? r1 : r0,
+            stop = reverse5 ? r0 : r1;
+        step = (stop - start3) / Math.max(1, n - paddingInner + paddingOuter * 2);
+        if (round3)
+            step = Math.floor(step);
+        start3 += (stop - start3 - step * (n - paddingInner)) * align;
+        bandwidth = step * (1 - paddingInner);
+        if (round3)
+            start3 = Math.round(start3), bandwidth = Math.round(bandwidth);
+        var values3 = range(n).map(function(i) {
+            return start3 + step * i;
+        });
+        return ordinalRange3(reverse5 ? values3.reverse() : values3);
+    }
+    scale5.domain = function(_) {
+        return arguments.length ? (domain(_), rescale()) : domain();
+    };
+    scale5.range = function(_) {
+        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
+    };
+    scale5.rangeRound = function(_) {
+        return [r0, r1] = _, r0 = +r0, r1 = +r1, round3 = true, rescale();
+    };
+    scale5.bandwidth = function() {
+        return bandwidth;
+    };
+    scale5.step = function() {
+        return step;
+    };
+    scale5.round = function(_) {
+        return arguments.length ? (round3 = !!_, rescale()) : round3;
+    };
+    scale5.padding = function(_) {
+        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
+    };
+    scale5.paddingInner = function(_) {
+        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
+    };
+    scale5.paddingOuter = function(_) {
+        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
+    };
+    scale5.align = function(_) {
+        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
+    };
+    scale5.copy = function() {
+        return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
+    };
+    return initRange.apply(rescale(), arguments);
+}
+
+function pointish(scale5) {
+    var copy5 = scale5.copy;
+    scale5.padding = scale5.paddingOuter;
+    delete scale5.paddingInner;
+    delete scale5.paddingOuter;
+    scale5.copy = function() {
+        return pointish(copy5());
+    };
+    return scale5;
+}
+
+function point() {
+    return pointish(band.apply(null, arguments).paddingInner(1));
+}
+
+// node_modules/d3-scale/src/constant.js
+function constants(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// node_modules/d3-scale/src/number.js
+function number3(x7) {
+    return +x7;
+}
+
+// node_modules/d3-scale/src/continuous.js
+var unit = [0, 1];
+
+function identity3(x7) {
+    return x7;
+}
+
+function normalize2(a7, b) {
+    return (b -= a7 = +a7) ? function(x7) {
+        return (x7 - a7) / b;
+    } : constants(isNaN(b) ? NaN : 0.5);
+}
+
+function clamper(a7, b) {
+    var t;
+    if (a7 > b)
+        t = a7, a7 = b, b = t;
+    return function(x7) {
+        return Math.max(a7, Math.min(b, x7));
+    };
+}
+
+function bimap(domain, range9, interpolate) {
+    var d0 = domain[0],
+        d1 = domain[1],
+        r0 = range9[0],
+        r1 = range9[1];
+    if (d1 < d0)
+        d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
+    else
+        d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
+    return function(x7) {
+        return r0(d0(x7));
+    };
+}
+
+function polymap(domain, range9, interpolate) {
+    var j = Math.min(domain.length, range9.length) - 1,
+        d = new Array(j),
+        r = new Array(j),
+        i = -1;
+    if (domain[j] < domain[0]) {
+        domain = domain.slice().reverse();
+        range9 = range9.slice().reverse();
+    }
+    while (++i < j) {
+        d[i] = normalize2(domain[i], domain[i + 1]);
+        r[i] = interpolate(range9[i], range9[i + 1]);
+    }
+    return function(x7) {
+        var i2 = bisect_default(domain, x7, 1, j) - 1;
+        return r[i2](d[i2](x7));
+    };
+}
+
+function copy(source, target) {
+    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
+}
+
+function transformer2() {
+    var domain = unit,
+        range9 = unit,
+        interpolate = value_default,
+        transform3, untransform, unknown, clamp = identity3,
+        piecewise3, output, input;
+
+    function rescale() {
+        var n = Math.min(domain.length, range9.length);
+        if (clamp !== identity3)
+            clamp = clamper(domain[0], domain[n - 1]);
+        piecewise3 = n > 2 ? polymap : bimap;
+        output = input = null;
+        return scale5;
+    }
+
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : (output || (output = piecewise3(domain.map(transform3), range9, interpolate)))(transform3(clamp(x7)));
+    }
+    scale5.invert = function(y7) {
+        return clamp(untransform((input || (input = piecewise3(range9, domain.map(transform3), number_default)))(y7)));
+    };
+    scale5.domain = function(_) {
+        return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), rescale()) : range9.slice();
+    };
+    scale5.rangeRound = function(_) {
+        return range9 = Array.from(_), interpolate = round_default, rescale();
+    };
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;
+    };
+    scale5.interpolate = function(_) {
+        return arguments.length ? (interpolate = _, rescale()) : interpolate;
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    return function(t, u7) {
+        transform3 = t, untransform = u7;
+        return rescale();
+    };
+}
+
+function continuous() {
+    return transformer2()(identity3, identity3);
+}
+
+// node_modules/d3-scale/src/tickFormat.js
+function tickFormat(start3, stop, count5, specifier) {
+    var step = tickStep(start3, stop, count5),
+        precision;
+    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
+    switch (specifier.type) {
+        case "s": {
+            var value = Math.max(Math.abs(start3), Math.abs(stop));
+            if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
+                specifier.precision = precision;
+            return formatPrefix(specifier, value);
+        }
+        case "":
+        case "e":
+        case "g":
+        case "p":
+        case "r": {
+            if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start3), Math.abs(stop)))))
+                specifier.precision = precision - (specifier.type === "e");
+            break;
+        }
+        case "f":
+        case "%": {
+            if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
+                specifier.precision = precision - (specifier.type === "%") * 2;
+            break;
+        }
+    }
+    return format(specifier);
+}
+
+// node_modules/d3-scale/src/linear.js
+function linearish(scale5) {
+    var domain = scale5.domain;
+    scale5.ticks = function(count5) {
+        var d = domain();
+        return ticks(d[0], d[d.length - 1], count5 == null ? 10 : count5);
+    };
+    scale5.tickFormat = function(count5, specifier) {
+        var d = domain();
+        return tickFormat(d[0], d[d.length - 1], count5 == null ? 10 : count5, specifier);
+    };
+    scale5.nice = function(count5) {
+        if (count5 == null)
+            count5 = 10;
+        var d = domain();
+        var i0 = 0;
+        var i1 = d.length - 1;
+        var start3 = d[i0];
+        var stop = d[i1];
+        var prestep;
+        var step;
+        var maxIter = 10;
+        if (stop < start3) {
+            step = start3, start3 = stop, stop = step;
+            step = i0, i0 = i1, i1 = step;
+        }
+        while (maxIter-- > 0) {
+            step = tickIncrement(start3, stop, count5);
+            if (step === prestep) {
+                d[i0] = start3;
+                d[i1] = stop;
+                return domain(d);
+            } else if (step > 0) {
+                start3 = Math.floor(start3 / step) * step;
+                stop = Math.ceil(stop / step) * step;
+            } else if (step < 0) {
+                start3 = Math.ceil(start3 * step) / step;
+                stop = Math.floor(stop * step) / step;
+            } else {
+                break;
+            }
+            prestep = step;
+        }
+        return scale5;
+    };
+    return scale5;
+}
+
+function linear3() {
+    var scale5 = continuous();
+    scale5.copy = function() {
+        return copy(scale5, linear3());
+    };
+    initRange.apply(scale5, arguments);
+    return linearish(scale5);
+}
+
+// node_modules/d3-scale/src/identity.js
+function identity4(domain) {
+    var unknown;
+
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : x7;
+    }
+    scale5.invert = scale5;
+    scale5.domain = scale5.range = function(_) {
+        return arguments.length ? (domain = Array.from(_, number3), scale5) : domain.slice();
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    scale5.copy = function() {
+        return identity4(domain).unknown(unknown);
+    };
+    domain = arguments.length ? Array.from(domain, number3) : [0, 1];
+    return linearish(scale5);
+}
+
+// node_modules/d3-scale/src/nice.js
+function nice2(domain, interval3) {
+    domain = domain.slice();
+    var i0 = 0,
+        i1 = domain.length - 1,
+        x011 = domain[i0],
+        x13 = domain[i1],
+        t;
+    if (x13 < x011) {
+        t = i0, i0 = i1, i1 = t;
+        t = x011, x011 = x13, x13 = t;
+    }
+    domain[i0] = interval3.floor(x011);
+    domain[i1] = interval3.ceil(x13);
+    return domain;
+}
+
+// node_modules/d3-scale/src/log.js
+function transformLog(x7) {
+    return Math.log(x7);
+}
+
+function transformExp(x7) {
+    return Math.exp(x7);
+}
+
+function transformLogn(x7) {
+    return -Math.log(-x7);
+}
+
+function transformExpn(x7) {
+    return -Math.exp(-x7);
+}
+
+function pow10(x7) {
+    return isFinite(x7) ? +("1e" + x7) : x7 < 0 ? 0 : x7;
+}
+
+function powp(base) {
+    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x7) => Math.pow(base, x7);
+}
+
+function logp(base) {
+    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x7) => Math.log(x7) / base);
+}
+
+function reflect(f) {
+    return (x7, k3) => -f(-x7, k3);
+}
+
+function loggish(transform3) {
+    const scale5 = transform3(transformLog, transformExp);
+    const domain = scale5.domain;
+    let base = 10;
+    let logs;
+    let pows;
+
+    function rescale() {
+        logs = logp(base), pows = powp(base);
+        if (domain()[0] < 0) {
+            logs = reflect(logs), pows = reflect(pows);
+            transform3(transformLogn, transformExpn);
+        } else {
+            transform3(transformLog, transformExp);
+        }
+        return scale5;
+    }
+    scale5.base = function(_) {
+        return arguments.length ? (base = +_, rescale()) : base;
+    };
+    scale5.domain = function(_) {
+        return arguments.length ? (domain(_), rescale()) : domain();
+    };
+    scale5.ticks = (count5) => {
+        const d = domain();
+        let u7 = d[0];
+        let v3 = d[d.length - 1];
+        const r = v3 < u7;
+        if (r)
+            [u7, v3] = [v3, u7];
+        let i = logs(u7);
+        let j = logs(v3);
+        let k3;
+        let t;
+        const n = count5 == null ? 10 : +count5;
+        let z = [];
+        if (!(base % 1) && j - i < n) {
+            i = Math.floor(i), j = Math.ceil(j);
+            if (u7 > 0)
+                for (; i <= j; ++i) {
+                    for (k3 = 1; k3 < base; ++k3) {
+                        t = i < 0 ? k3 / pows(-i) : k3 * pows(i);
+                        if (t < u7)
+                            continue;
+                        if (t > v3)
+                            break;
+                        z.push(t);
+                    }
+                }
+            else
+                for (; i <= j; ++i) {
+                    for (k3 = base - 1; k3 >= 1; --k3) {
+                        t = i > 0 ? k3 / pows(-i) : k3 * pows(i);
+                        if (t < u7)
+                            continue;
+                        if (t > v3)
+                            break;
+                        z.push(t);
+                    }
+                }
+            if (z.length * 2 < n)
+                z = ticks(u7, v3, n);
+        } else {
+            z = ticks(i, j, Math.min(j - i, n)).map(pows);
+        }
+        return r ? z.reverse() : z;
+    };
+    scale5.tickFormat = (count5, specifier) => {
+        if (count5 == null)
+            count5 = 10;
+        if (specifier == null)
+            specifier = base === 10 ? "s" : ",";
+        if (typeof specifier !== "function") {
+            if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
+                specifier.trim = true;
+            specifier = format(specifier);
+        }
+        if (count5 === Infinity)
+            return specifier;
+        const k3 = Math.max(1, base * count5 / scale5.ticks().length);
+        return (d) => {
+            let i = d / pows(Math.round(logs(d)));
+            if (i * base < base - 0.5)
+                i *= base;
+            return i <= k3 ? specifier(d) : "";
+        };
+    };
+    scale5.nice = () => {
+        return domain(nice2(domain(), {
+            floor: (x7) => pows(Math.floor(logs(x7))),
+            ceil: (x7) => pows(Math.ceil(logs(x7)))
+        }));
+    };
+    return scale5;
+}
+
+function log2() {
+    const scale5 = loggish(transformer2()).domain([1, 10]);
+    scale5.copy = () => copy(scale5, log2()).base(scale5.base());
+    initRange.apply(scale5, arguments);
+    return scale5;
+}
+
+// node_modules/d3-scale/src/symlog.js
+function transformSymlog(c11) {
+    return function(x7) {
+        return Math.sign(x7) * Math.log1p(Math.abs(x7 / c11));
+    };
+}
+
+function transformSymexp(c11) {
+    return function(x7) {
+        return Math.sign(x7) * Math.expm1(Math.abs(x7)) * c11;
+    };
+}
+
+function symlogish(transform3) {
+    var c11 = 1,
+        scale5 = transform3(transformSymlog(c11), transformSymexp(c11));
+    scale5.constant = function(_) {
+        return arguments.length ? transform3(transformSymlog(c11 = +_), transformSymexp(c11)) : c11;
+    };
+    return linearish(scale5);
+}
+
+function symlog() {
+    var scale5 = symlogish(transformer2());
+    scale5.copy = function() {
+        return copy(scale5, symlog()).constant(scale5.constant());
+    };
+    return initRange.apply(scale5, arguments);
+}
+
+// node_modules/d3-scale/src/pow.js
+function transformPow(exponent3) {
+    return function(x7) {
+        return x7 < 0 ? -Math.pow(-x7, exponent3) : Math.pow(x7, exponent3);
+    };
+}
+
+function transformSqrt(x7) {
+    return x7 < 0 ? -Math.sqrt(-x7) : Math.sqrt(x7);
+}
+
+function transformSquare(x7) {
+    return x7 < 0 ? -x7 * x7 : x7 * x7;
+}
+
+function powish(transform3) {
+    var scale5 = transform3(identity3, identity3),
+        exponent3 = 1;
+
+    function rescale() {
+        return exponent3 === 1 ? transform3(identity3, identity3) : exponent3 === 0.5 ? transform3(transformSqrt, transformSquare) : transform3(transformPow(exponent3), transformPow(1 / exponent3));
+    }
+    scale5.exponent = function(_) {
+        return arguments.length ? (exponent3 = +_, rescale()) : exponent3;
+    };
+    return linearish(scale5);
+}
+
+function pow3() {
+    var scale5 = powish(transformer2());
+    scale5.copy = function() {
+        return copy(scale5, pow3()).exponent(scale5.exponent());
+    };
+    initRange.apply(scale5, arguments);
+    return scale5;
+}
+
+function sqrt2() {
+    return pow3.apply(null, arguments).exponent(0.5);
+}
+
+// node_modules/d3-scale/src/radial.js
+function square(x7) {
+    return Math.sign(x7) * x7 * x7;
+}
+
+function unsquare(x7) {
+    return Math.sign(x7) * Math.sqrt(Math.abs(x7));
+}
+
+function radial() {
+    var squared = continuous(),
+        range9 = [0, 1],
+        round3 = false,
+        unknown;
+
+    function scale5(x7) {
+        var y7 = unsquare(squared(x7));
+        return isNaN(y7) ? unknown : round3 ? Math.round(y7) : y7;
+    }
+    scale5.invert = function(y7) {
+        return squared.invert(square(y7));
+    };
+    scale5.domain = function(_) {
+        return arguments.length ? (squared.domain(_), scale5) : squared.domain();
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (squared.range((range9 = Array.from(_, number3)).map(square)), scale5) : range9.slice();
+    };
+    scale5.rangeRound = function(_) {
+        return scale5.range(_).round(true);
+    };
+    scale5.round = function(_) {
+        return arguments.length ? (round3 = !!_, scale5) : round3;
+    };
+    scale5.clamp = function(_) {
+        return arguments.length ? (squared.clamp(_), scale5) : squared.clamp();
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    scale5.copy = function() {
+        return radial(squared.domain(), range9).round(round3).clamp(squared.clamp()).unknown(unknown);
+    };
+    initRange.apply(scale5, arguments);
+    return linearish(scale5);
+}
+
+// node_modules/d3-scale/src/quantile.js
+function quantile2() {
+    var domain = [],
+        range9 = [],
+        thresholds = [],
+        unknown;
+
+    function rescale() {
+        var i = 0,
+            n = Math.max(1, range9.length);
+        thresholds = new Array(n - 1);
+        while (++i < n)
+            thresholds[i - 1] = quantileSorted(domain, i / n);
+        return scale5;
+    }
+
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : range9[bisect_default(thresholds, x7)];
+    }
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
+        return i < 0 ? [NaN, NaN] : [
+            i > 0 ? thresholds[i - 1] : domain[0],
+            i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
+        ];
+    };
+    scale5.domain = function(_) {
+        if (!arguments.length)
+            return domain.slice();
+        domain = [];
+        for (let d of _)
+            if (d != null && !isNaN(d = +d))
+                domain.push(d);
+        domain.sort(ascending);
+        return rescale();
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), rescale()) : range9.slice();
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    scale5.quantiles = function() {
+        return thresholds.slice();
+    };
+    scale5.copy = function() {
+        return quantile2().domain(domain).range(range9).unknown(unknown);
+    };
+    return initRange.apply(scale5, arguments);
+}
+
+// node_modules/d3-scale/src/quantize.js
+function quantize() {
+    var x011 = 0,
+        x13 = 1,
+        n = 1,
+        domain = [0.5],
+        range9 = [0, 1],
+        unknown;
+
+    function scale5(x7) {
+        return x7 != null && x7 <= x7 ? range9[bisect_default(domain, x7, 0, n)] : unknown;
+    }
+
+    function rescale() {
+        var i = -1;
+        domain = new Array(n);
+        while (++i < n)
+            domain[i] = ((i + 1) * x13 - (i - n) * x011) / (n + 1);
+        return scale5;
+    }
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13] = _, x011 = +x011, x13 = +x13, rescale()) : [x011, x13];
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (n = (range9 = Array.from(_)).length - 1, rescale()) : range9.slice();
+    };
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
+        return i < 0 ? [NaN, NaN] : i < 1 ? [x011, domain[0]] : i >= n ? [domain[n - 1], x13] : [domain[i - 1], domain[i]];
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : scale5;
+    };
+    scale5.thresholds = function() {
+        return domain.slice();
+    };
+    scale5.copy = function() {
+        return quantize().domain([x011, x13]).range(range9).unknown(unknown);
+    };
+    return initRange.apply(linearish(scale5), arguments);
+}
+
+// node_modules/d3-scale/src/threshold.js
+function threshold() {
+    var domain = [0.5],
+        range9 = [0, 1],
+        unknown, n = 1;
+
+    function scale5(x7) {
+        return x7 != null && x7 <= x7 ? range9[bisect_default(domain, x7, 0, n)] : unknown;
+    }
+    scale5.domain = function(_) {
+        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range9.length - 1), scale5) : domain.slice();
+    };
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), n = Math.min(domain.length, range9.length - 1), scale5) : range9.slice();
+    };
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
+        return [domain[i - 1], domain[i]];
+    };
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    scale5.copy = function() {
+        return threshold().domain(domain).range(range9).unknown(unknown);
+    };
+    return initRange.apply(scale5, arguments);
+}
+
+// node_modules/d3-time/src/interval.js
+var t02 = /* @__PURE__ */ new Date();
+var t12 = /* @__PURE__ */ new Date();
+
+function timeInterval(floori, offseti, count5, field3) {
+    function interval3(date3) {
+        return floori(date3 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date3)), date3;
+    }
+    interval3.floor = (date3) => {
+        return floori(date3 = /* @__PURE__ */ new Date(+date3)), date3;
+    };
+    interval3.ceil = (date3) => {
+        return floori(date3 = new Date(date3 - 1)), offseti(date3, 1), floori(date3), date3;
+    };
+    interval3.round = (date3) => {
+        const d0 = interval3(date3),
+            d1 = interval3.ceil(date3);
+        return date3 - d0 < d1 - date3 ? d0 : d1;
+    };
+    interval3.offset = (date3, step) => {
+        return offseti(date3 = /* @__PURE__ */ new Date(+date3), step == null ? 1 : Math.floor(step)), date3;
+    };
+    interval3.range = (start3, stop, step) => {
+        const range9 = [];
+        start3 = interval3.ceil(start3);
+        step = step == null ? 1 : Math.floor(step);
+        if (!(start3 < stop) || !(step > 0))
+            return range9;
+        let previous;
+        do
+            range9.push(previous = /* @__PURE__ */ new Date(+start3)), offseti(start3, step), floori(start3);
+        while (previous < start3 && start3 < stop);
+        return range9;
+    };
+    interval3.filter = (test) => {
+        return timeInterval((date3) => {
+            if (date3 >= date3)
+                while (floori(date3), !test(date3))
+                    date3.setTime(date3 - 1);
+        }, (date3, step) => {
+            if (date3 >= date3) {
+                if (step < 0)
+                    while (++step <= 0) {
+                        while (offseti(date3, -1), !test(date3)) {}
+                    }
+                else
+                    while (--step >= 0) {
+                        while (offseti(date3, 1), !test(date3)) {}
+                    }
+            }
+        });
+    };
+    if (count5) {
+        interval3.count = (start3, end) => {
+            t02.setTime(+start3), t12.setTime(+end);
+            floori(t02), floori(t12);
+            return Math.floor(count5(t02, t12));
+        };
+        interval3.every = (step) => {
+            step = Math.floor(step);
+            return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field3 ? (d) => field3(d) % step === 0 : (d) => interval3.count(0, d) % step === 0);
+        };
+    }
+    return interval3;
+}
+
+// node_modules/d3-time/src/millisecond.js
+var millisecond = timeInterval(() => {}, (date3, step) => {
+    date3.setTime(+date3 + step);
+}, (start3, end) => {
+    return end - start3;
+});
+millisecond.every = (k3) => {
+    k3 = Math.floor(k3);
+    if (!isFinite(k3) || !(k3 > 0))
+        return null;
+    if (!(k3 > 1))
+        return millisecond;
+    return timeInterval((date3) => {
+        date3.setTime(Math.floor(date3 / k3) * k3);
+    }, (date3, step) => {
+        date3.setTime(+date3 + step * k3);
+    }, (start3, end) => {
+        return (end - start3) / k3;
+    });
+};
+var milliseconds = millisecond.range;
+
+// node_modules/d3-time/src/duration.js
+var durationSecond = 1e3;
+var durationMinute = durationSecond * 60;
+var durationHour = durationMinute * 60;
+var durationDay = durationHour * 24;
+var durationWeek = durationDay * 7;
+var durationMonth = durationDay * 30;
+var durationYear = durationDay * 365;
+
+// node_modules/d3-time/src/second.js
+var second = timeInterval((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds());
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationSecond);
+}, (start3, end) => {
+    return (end - start3) / durationSecond;
+}, (date3) => {
+    return date3.getUTCSeconds();
+});
+var seconds = second.range;
+
+// node_modules/d3-time/src/minute.js
+var timeMinute = timeInterval((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationMinute);
+}, (start3, end) => {
+    return (end - start3) / durationMinute;
+}, (date3) => {
+    return date3.getMinutes();
+});
+var timeMinutes = timeMinute.range;
+var utcMinute = timeInterval((date3) => {
+    date3.setUTCSeconds(0, 0);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationMinute);
+}, (start3, end) => {
+    return (end - start3) / durationMinute;
+}, (date3) => {
+    return date3.getUTCMinutes();
+});
+var utcMinutes = utcMinute.range;
+
+// node_modules/d3-time/src/hour.js
+var timeHour = timeInterval((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond - date3.getMinutes() * durationMinute);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationHour);
+}, (start3, end) => {
+    return (end - start3) / durationHour;
+}, (date3) => {
+    return date3.getHours();
+});
+var timeHours = timeHour.range;
+var utcHour = timeInterval((date3) => {
+    date3.setUTCMinutes(0, 0, 0);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationHour);
+}, (start3, end) => {
+    return (end - start3) / durationHour;
+}, (date3) => {
+    return date3.getUTCHours();
+});
+var utcHours = utcHour.range;
+
+// node_modules/d3-time/src/day.js
+var timeDay = timeInterval(
+    (date3) => date3.setHours(0, 0, 0, 0),
+    (date3, step) => date3.setDate(date3.getDate() + step),
+    (start3, end) => (end - start3 - (end.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationDay,
+    (date3) => date3.getDate() - 1
+);
+var timeDays = timeDay.range;
+var utcDay = timeInterval((date3) => {
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCDate(date3.getUTCDate() + step);
+}, (start3, end) => {
+    return (end - start3) / durationDay;
+}, (date3) => {
+    return date3.getUTCDate() - 1;
+});
+var utcDays = utcDay.range;
+var unixDay = timeInterval((date3) => {
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCDate(date3.getUTCDate() + step);
+}, (start3, end) => {
+    return (end - start3) / durationDay;
+}, (date3) => {
+    return Math.floor(date3 / durationDay);
+});
+var unixDays = unixDay.range;
+
+// node_modules/d3-time/src/week.js
+function timeWeekday(i) {
+    return timeInterval((date3) => {
+        date3.setDate(date3.getDate() - (date3.getDay() + 7 - i) % 7);
+        date3.setHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setDate(date3.getDate() + step * 7);
+    }, (start3, end) => {
+        return (end - start3 - (end.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationWeek;
+    });
+}
+var timeSunday = timeWeekday(0);
+var timeMonday = timeWeekday(1);
+var timeTuesday = timeWeekday(2);
+var timeWednesday = timeWeekday(3);
+var timeThursday = timeWeekday(4);
+var timeFriday = timeWeekday(5);
+var timeSaturday = timeWeekday(6);
+var timeSundays = timeSunday.range;
+var timeMondays = timeMonday.range;
+var timeTuesdays = timeTuesday.range;
+var timeWednesdays = timeWednesday.range;
+var timeThursdays = timeThursday.range;
+var timeFridays = timeFriday.range;
+var timeSaturdays = timeSaturday.range;
+
+function utcWeekday(i) {
+    return timeInterval((date3) => {
+        date3.setUTCDate(date3.getUTCDate() - (date3.getUTCDay() + 7 - i) % 7);
+        date3.setUTCHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setUTCDate(date3.getUTCDate() + step * 7);
+    }, (start3, end) => {
+        return (end - start3) / durationWeek;
+    });
+}
+var utcSunday = utcWeekday(0);
+var utcMonday = utcWeekday(1);
+var utcTuesday = utcWeekday(2);
+var utcWednesday = utcWeekday(3);
+var utcThursday = utcWeekday(4);
+var utcFriday = utcWeekday(5);
+var utcSaturday = utcWeekday(6);
+var utcSundays = utcSunday.range;
+var utcMondays = utcMonday.range;
+var utcTuesdays = utcTuesday.range;
+var utcWednesdays = utcWednesday.range;
+var utcThursdays = utcThursday.range;
+var utcFridays = utcFriday.range;
+var utcSaturdays = utcSaturday.range;
+
+// node_modules/d3-time/src/month.js
+var timeMonth = timeInterval((date3) => {
+    date3.setDate(1);
+    date3.setHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setMonth(date3.getMonth() + step);
+}, (start3, end) => {
+    return end.getMonth() - start3.getMonth() + (end.getFullYear() - start3.getFullYear()) * 12;
+}, (date3) => {
+    return date3.getMonth();
+});
+var timeMonths = timeMonth.range;
+var utcMonth = timeInterval((date3) => {
+    date3.setUTCDate(1);
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCMonth(date3.getUTCMonth() + step);
+}, (start3, end) => {
+    return end.getUTCMonth() - start3.getUTCMonth() + (end.getUTCFullYear() - start3.getUTCFullYear()) * 12;
+}, (date3) => {
+    return date3.getUTCMonth();
+});
+var utcMonths = utcMonth.range;
+
+// node_modules/d3-time/src/year.js
+var timeYear = timeInterval((date3) => {
+    date3.setMonth(0, 1);
+    date3.setHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setFullYear(date3.getFullYear() + step);
+}, (start3, end) => {
+    return end.getFullYear() - start3.getFullYear();
+}, (date3) => {
+    return date3.getFullYear();
+});
+timeYear.every = (k3) => {
+    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date3) => {
+        date3.setFullYear(Math.floor(date3.getFullYear() / k3) * k3);
+        date3.setMonth(0, 1);
+        date3.setHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setFullYear(date3.getFullYear() + step * k3);
+    });
+};
+var timeYears = timeYear.range;
+var utcYear = timeInterval((date3) => {
+    date3.setUTCMonth(0, 1);
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCFullYear(date3.getUTCFullYear() + step);
+}, (start3, end) => {
+    return end.getUTCFullYear() - start3.getUTCFullYear();
+}, (date3) => {
+    return date3.getUTCFullYear();
+});
+utcYear.every = (k3) => {
+    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date3) => {
+        date3.setUTCFullYear(Math.floor(date3.getUTCFullYear() / k3) * k3);
+        date3.setUTCMonth(0, 1);
+        date3.setUTCHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setUTCFullYear(date3.getUTCFullYear() + step * k3);
+    });
+};
+var utcYears = utcYear.range;
+
+// node_modules/d3-time/src/ticks.js
+function ticker(year, month, week, day, hour, minute) {
+    const tickIntervals = [
+        [second, 1, durationSecond],
+        [second, 5, 5 * durationSecond],
+        [second, 15, 15 * durationSecond],
+        [second, 30, 30 * durationSecond],
+        [minute, 1, durationMinute],
+        [minute, 5, 5 * durationMinute],
+        [minute, 15, 15 * durationMinute],
+        [minute, 30, 30 * durationMinute],
+        [hour, 1, durationHour],
+        [hour, 3, 3 * durationHour],
+        [hour, 6, 6 * durationHour],
+        [hour, 12, 12 * durationHour],
+        [day, 1, durationDay],
+        [day, 2, 2 * durationDay],
+        [week, 1, durationWeek],
+        [month, 1, durationMonth],
+        [month, 3, 3 * durationMonth],
+        [year, 1, durationYear]
+    ];
+
+    function ticks3(start3, stop, count5) {
+        const reverse5 = stop < start3;
+        if (reverse5)
+            [start3, stop] = [stop, start3];
+        const interval3 = count5 && typeof count5.range === "function" ? count5 : tickInterval(start3, stop, count5);
+        const ticks4 = interval3 ? interval3.range(start3, +stop + 1) : [];
+        return reverse5 ? ticks4.reverse() : ticks4;
+    }
+
+    function tickInterval(start3, stop, count5) {
+        const target = Math.abs(stop - start3) / count5;
+        const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
+        if (i === tickIntervals.length)
+            return year.every(tickStep(start3 / durationYear, stop / durationYear, count5));
+        if (i === 0)
+            return millisecond.every(Math.max(tickStep(start3, stop, count5), 1));
+        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
+        return t.every(step);
+    }
+    return [ticks3, tickInterval];
+}
+var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
+var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
+
+// node_modules/d3-time-format/src/locale.js
+function localDate(d) {
+    if (0 <= d.y && d.y < 100) {
+        var date3 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
+        date3.setFullYear(d.y);
+        return date3;
+    }
+    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
+}
+
+function utcDate(d) {
+    if (0 <= d.y && d.y < 100) {
+        var date3 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
+        date3.setUTCFullYear(d.y);
+        return date3;
+    }
+    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
+}
+
+function newDate(y7, m5, d) {
+    return {
+        y: y7,
+        m: m5,
+        d,
+        H: 0,
+        M: 0,
+        S: 0,
+        L: 0
+    };
+}
+
+function formatLocale(locale5) {
+    var locale_dateTime = locale5.dateTime,
+        locale_date = locale5.date,
+        locale_time = locale5.time,
+        locale_periods = locale5.periods,
+        locale_weekdays = locale5.days,
+        locale_shortWeekdays = locale5.shortDays,
+        locale_months = locale5.months,
+        locale_shortMonths = locale5.shortMonths;
+    var periodRe = formatRe(locale_periods),
+        periodLookup = formatLookup(locale_periods),
+        weekdayRe = formatRe(locale_weekdays),
+        weekdayLookup = formatLookup(locale_weekdays),
+        shortWeekdayRe = formatRe(locale_shortWeekdays),
+        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
+        monthRe = formatRe(locale_months),
+        monthLookup = formatLookup(locale_months),
+        shortMonthRe = formatRe(locale_shortMonths),
+        shortMonthLookup = formatLookup(locale_shortMonths);
+    var formats = {
+        "a": formatShortWeekday,
+        "A": formatWeekday3,
+        "b": formatShortMonth,
+        "B": formatMonth3,
+        "c": null,
+        "d": formatDayOfMonth,
+        "e": formatDayOfMonth,
+        "f": formatMicroseconds,
+        "g": formatYearISO,
+        "G": formatFullYearISO,
+        "H": formatHour24,
+        "I": formatHour12,
+        "j": formatDayOfYear,
+        "L": formatMilliseconds,
+        "m": formatMonthNumber,
+        "M": formatMinutes,
+        "p": formatPeriod,
+        "q": formatQuarter,
+        "Q": formatUnixTimestamp,
+        "s": formatUnixTimestampSeconds,
+        "S": formatSeconds,
+        "u": formatWeekdayNumberMonday,
+        "U": formatWeekNumberSunday,
+        "V": formatWeekNumberISO,
+        "w": formatWeekdayNumberSunday,
+        "W": formatWeekNumberMonday,
+        "x": null,
+        "X": null,
+        "y": formatYear2,
+        "Y": formatFullYear,
+        "Z": formatZone,
+        "%": formatLiteralPercent
+    };
+    var utcFormats = {
+        "a": formatUTCShortWeekday,
+        "A": formatUTCWeekday,
+        "b": formatUTCShortMonth,
+        "B": formatUTCMonth,
+        "c": null,
+        "d": formatUTCDayOfMonth,
+        "e": formatUTCDayOfMonth,
+        "f": formatUTCMicroseconds,
+        "g": formatUTCYearISO,
+        "G": formatUTCFullYearISO,
+        "H": formatUTCHour24,
+        "I": formatUTCHour12,
+        "j": formatUTCDayOfYear,
+        "L": formatUTCMilliseconds,
+        "m": formatUTCMonthNumber,
+        "M": formatUTCMinutes,
+        "p": formatUTCPeriod,
+        "q": formatUTCQuarter,
+        "Q": formatUnixTimestamp,
+        "s": formatUnixTimestampSeconds,
+        "S": formatUTCSeconds,
+        "u": formatUTCWeekdayNumberMonday,
+        "U": formatUTCWeekNumberSunday,
+        "V": formatUTCWeekNumberISO,
+        "w": formatUTCWeekdayNumberSunday,
+        "W": formatUTCWeekNumberMonday,
+        "x": null,
+        "X": null,
+        "y": formatUTCYear,
+        "Y": formatUTCFullYear,
+        "Z": formatUTCZone,
+        "%": formatLiteralPercent
+    };
+    var parses = {
+        "a": parseShortWeekday,
+        "A": parseWeekday,
+        "b": parseShortMonth,
+        "B": parseMonth,
+        "c": parseLocaleDateTime,
+        "d": parseDayOfMonth,
+        "e": parseDayOfMonth,
+        "f": parseMicroseconds,
+        "g": parseYear,
+        "G": parseFullYear,
+        "H": parseHour24,
+        "I": parseHour24,
+        "j": parseDayOfYear,
+        "L": parseMilliseconds,
+        "m": parseMonthNumber,
+        "M": parseMinutes,
+        "p": parsePeriod,
+        "q": parseQuarter,
+        "Q": parseUnixTimestamp,
+        "s": parseUnixTimestampSeconds,
+        "S": parseSeconds,
+        "u": parseWeekdayNumberMonday,
+        "U": parseWeekNumberSunday,
+        "V": parseWeekNumberISO,
+        "w": parseWeekdayNumberSunday,
+        "W": parseWeekNumberMonday,
+        "x": parseLocaleDate,
+        "X": parseLocaleTime,
+        "y": parseYear,
+        "Y": parseFullYear,
+        "Z": parseZone,
+        "%": parseLiteralPercent
+    };
+    formats.x = newFormat(locale_date, formats);
+    formats.X = newFormat(locale_time, formats);
+    formats.c = newFormat(locale_dateTime, formats);
+    utcFormats.x = newFormat(locale_date, utcFormats);
+    utcFormats.X = newFormat(locale_time, utcFormats);
+    utcFormats.c = newFormat(locale_dateTime, utcFormats);
+
+    function newFormat(specifier, formats2) {
+        return function(date3) {
+            var string3 = [],
+                i = -1,
+                j = 0,
+                n = specifier.length,
+                c11, pad7, format5;
+            if (!(date3 instanceof Date))
+                date3 = /* @__PURE__ */ new Date(+date3);
+            while (++i < n) {
+                if (specifier.charCodeAt(i) === 37) {
+                    string3.push(specifier.slice(j, i));
+                    if ((pad7 = pads[c11 = specifier.charAt(++i)]) != null)
+                        c11 = specifier.charAt(++i);
+                    else
+                        pad7 = c11 === "e" ? " " : "0";
+                    if (format5 = formats2[c11])
+                        c11 = format5(date3, pad7);
+                    string3.push(c11);
+                    j = i + 1;
+                }
+            }
+            string3.push(specifier.slice(j, i));
+            return string3.join("");
+        };
+    }
+
+    function newParse(specifier, Z) {
+        return function(string3) {
+            var d = newDate(1900, void 0, 1),
+                i = parseSpecifier(d, specifier, string3 += "", 0),
+                week, day;
+            if (i != string3.length)
+                return null;
+            if ("Q" in d)
+                return new Date(d.Q);
+            if ("s" in d)
+                return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
+            if (Z && !("Z" in d))
+                d.Z = 0;
+            if ("p" in d)
+                d.H = d.H % 12 + d.p * 12;
+            if (d.m === void 0)
+                d.m = "q" in d ? d.q : 0;
+            if ("V" in d) {
+                if (d.V < 1 || d.V > 53)
+                    return null;
+                if (!("w" in d))
+                    d.w = 1;
+                if ("Z" in d) {
+                    week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
+                    week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
+                    week = utcDay.offset(week, (d.V - 1) * 7);
+                    d.y = week.getUTCFullYear();
+                    d.m = week.getUTCMonth();
+                    d.d = week.getUTCDate() + (d.w + 6) % 7;
+                } else {
+                    week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
+                    week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
+                    week = timeDay.offset(week, (d.V - 1) * 7);
+                    d.y = week.getFullYear();
+                    d.m = week.getMonth();
+                    d.d = week.getDate() + (d.w + 6) % 7;
+                }
+            } else if ("W" in d || "U" in d) {
+                if (!("w" in d))
+                    d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
+                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
+                d.m = 0;
+                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
+            }
+            if ("Z" in d) {
+                d.H += d.Z / 100 | 0;
+                d.M += d.Z % 100;
+                return utcDate(d);
+            }
+            return localDate(d);
+        };
+    }
+
+    function parseSpecifier(d, specifier, string3, j) {
+        var i = 0,
+            n = specifier.length,
+            m5 = string3.length,
+            c11, parse3;
+        while (i < n) {
+            if (j >= m5)
+                return -1;
+            c11 = specifier.charCodeAt(i++);
+            if (c11 === 37) {
+                c11 = specifier.charAt(i++);
+                parse3 = parses[c11 in pads ? specifier.charAt(i++) : c11];
+                if (!parse3 || (j = parse3(d, string3, j)) < 0)
+                    return -1;
+            } else if (c11 != string3.charCodeAt(j++)) {
+                return -1;
+            }
+        }
+        return j;
+    }
+
+    function parsePeriod(d, string3, i) {
+        var n = periodRe.exec(string3.slice(i));
+        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
+    }
+
+    function parseShortWeekday(d, string3, i) {
+        var n = shortWeekdayRe.exec(string3.slice(i));
+        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
+    }
+
+    function parseWeekday(d, string3, i) {
+        var n = weekdayRe.exec(string3.slice(i));
+        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
+    }
+
+    function parseShortMonth(d, string3, i) {
+        var n = shortMonthRe.exec(string3.slice(i));
+        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
+    }
+
+    function parseMonth(d, string3, i) {
+        var n = monthRe.exec(string3.slice(i));
+        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
+    }
+
+    function parseLocaleDateTime(d, string3, i) {
+        return parseSpecifier(d, locale_dateTime, string3, i);
+    }
+
+    function parseLocaleDate(d, string3, i) {
+        return parseSpecifier(d, locale_date, string3, i);
+    }
+
+    function parseLocaleTime(d, string3, i) {
+        return parseSpecifier(d, locale_time, string3, i);
+    }
+
+    function formatShortWeekday(d) {
+        return locale_shortWeekdays[d.getDay()];
+    }
+
+    function formatWeekday3(d) {
+        return locale_weekdays[d.getDay()];
+    }
+
+    function formatShortMonth(d) {
+        return locale_shortMonths[d.getMonth()];
+    }
+
+    function formatMonth3(d) {
+        return locale_months[d.getMonth()];
+    }
+
+    function formatPeriod(d) {
+        return locale_periods[+(d.getHours() >= 12)];
+    }
+
+    function formatQuarter(d) {
+        return 1 + ~~(d.getMonth() / 3);
+    }
+
+    function formatUTCShortWeekday(d) {
+        return locale_shortWeekdays[d.getUTCDay()];
+    }
+
+    function formatUTCWeekday(d) {
+        return locale_weekdays[d.getUTCDay()];
+    }
+
+    function formatUTCShortMonth(d) {
+        return locale_shortMonths[d.getUTCMonth()];
+    }
+
+    function formatUTCMonth(d) {
+        return locale_months[d.getUTCMonth()];
+    }
+
+    function formatUTCPeriod(d) {
+        return locale_periods[+(d.getUTCHours() >= 12)];
+    }
+
+    function formatUTCQuarter(d) {
+        return 1 + ~~(d.getUTCMonth() / 3);
+    }
+    return {
+        format: function(specifier) {
+            var f = newFormat(specifier += "", formats);
+            f.toString = function() {
+                return specifier;
+            };
+            return f;
+        },
+        parse: function(specifier) {
+            var p = newParse(specifier += "", false);
+            p.toString = function() {
+                return specifier;
+            };
+            return p;
+        },
+        utcFormat: function(specifier) {
+            var f = newFormat(specifier += "", utcFormats);
+            f.toString = function() {
+                return specifier;
+            };
+            return f;
+        },
+        utcParse: function(specifier) {
+            var p = newParse(specifier += "", true);
+            p.toString = function() {
+                return specifier;
+            };
+            return p;
+        }
+    };
+}
+var pads = {
+    "-": "",
+    "_": " ",
+    "0": "0"
+};
+var numberRe = /^\s*\d+/;
+var percentRe = /^%/;
+var requoteRe = /[\\^$*+?|[\]().{}]/g;
+
+function pad2(value, fill, width) {
+    var sign5 = value < 0 ? "-" : "",
+        string3 = (sign5 ? -value : value) + "",
+        length7 = string3.length;
+    return sign5 + (length7 < width ? new Array(width - length7 + 1).join(fill) + string3 : string3);
+}
+
+function requote(s3) {
+    return s3.replace(requoteRe, "\\$&");
+}
+
+function formatRe(names) {
+    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
+}
+
+function formatLookup(names) {
+    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
+}
+
+function parseWeekdayNumberSunday(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 1));
+    return n ? (d.w = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekdayNumberMonday(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 1));
+    return n ? (d.u = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberSunday(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.U = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberISO(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.V = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberMonday(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.W = +n[0], i + n[0].length) : -1;
+}
+
+function parseFullYear(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 4));
+    return n ? (d.y = +n[0], i + n[0].length) : -1;
+}
+
+function parseYear(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
+}
+
+function parseZone(d, string3, i) {
+    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string3.slice(i, i + 6));
+    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
+}
+
+function parseQuarter(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 1));
+    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
+}
+
+function parseMonthNumber(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
+}
+
+function parseDayOfMonth(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.d = +n[0], i + n[0].length) : -1;
+}
+
+function parseDayOfYear(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 3));
+    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
+}
+
+function parseHour24(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.H = +n[0], i + n[0].length) : -1;
+}
+
+function parseMinutes(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.M = +n[0], i + n[0].length) : -1;
+}
+
+function parseSeconds(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 2));
+    return n ? (d.S = +n[0], i + n[0].length) : -1;
+}
+
+function parseMilliseconds(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 3));
+    return n ? (d.L = +n[0], i + n[0].length) : -1;
+}
+
+function parseMicroseconds(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i, i + 6));
+    return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
+}
+
+function parseLiteralPercent(d, string3, i) {
+    var n = percentRe.exec(string3.slice(i, i + 1));
+    return n ? i + n[0].length : -1;
+}
+
+function parseUnixTimestamp(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i));
+    return n ? (d.Q = +n[0], i + n[0].length) : -1;
+}
+
+function parseUnixTimestampSeconds(d, string3, i) {
+    var n = numberRe.exec(string3.slice(i));
+    return n ? (d.s = +n[0], i + n[0].length) : -1;
+}
+
+function formatDayOfMonth(d, p) {
+    return pad2(d.getDate(), p, 2);
+}
+
+function formatHour24(d, p) {
+    return pad2(d.getHours(), p, 2);
+}
+
+function formatHour12(d, p) {
+    return pad2(d.getHours() % 12 || 12, p, 2);
+}
+
+function formatDayOfYear(d, p) {
+    return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
+}
+
+function formatMilliseconds(d, p) {
+    return pad2(d.getMilliseconds(), p, 3);
+}
+
+function formatMicroseconds(d, p) {
+    return formatMilliseconds(d, p) + "000";
+}
+
+function formatMonthNumber(d, p) {
+    return pad2(d.getMonth() + 1, p, 2);
+}
+
+function formatMinutes(d, p) {
+    return pad2(d.getMinutes(), p, 2);
+}
+
+function formatSeconds(d, p) {
+    return pad2(d.getSeconds(), p, 2);
+}
+
+function formatWeekdayNumberMonday(d) {
+    var day = d.getDay();
+    return day === 0 ? 7 : day;
+}
+
+function formatWeekNumberSunday(d, p) {
+    return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
+}
+
+function dISO(d) {
+    var day = d.getDay();
+    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
+}
+
+function formatWeekNumberISO(d, p) {
+    d = dISO(d);
+    return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
+}
+
+function formatWeekdayNumberSunday(d) {
+    return d.getDay();
+}
+
+function formatWeekNumberMonday(d, p) {
+    return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
+}
+
+function formatYear2(d, p) {
+    return pad2(d.getFullYear() % 100, p, 2);
+}
+
+function formatYearISO(d, p) {
+    d = dISO(d);
+    return pad2(d.getFullYear() % 100, p, 2);
+}
+
+function formatFullYear(d, p) {
+    return pad2(d.getFullYear() % 1e4, p, 4);
+}
+
+function formatFullYearISO(d, p) {
+    var day = d.getDay();
+    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
+    return pad2(d.getFullYear() % 1e4, p, 4);
+}
+
+function formatZone(d) {
+    var z = d.getTimezoneOffset();
+    return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
+}
+
+function formatUTCDayOfMonth(d, p) {
+    return pad2(d.getUTCDate(), p, 2);
+}
+
+function formatUTCHour24(d, p) {
+    return pad2(d.getUTCHours(), p, 2);
+}
+
+function formatUTCHour12(d, p) {
+    return pad2(d.getUTCHours() % 12 || 12, p, 2);
+}
+
+function formatUTCDayOfYear(d, p) {
+    return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
+}
+
+function formatUTCMilliseconds(d, p) {
+    return pad2(d.getUTCMilliseconds(), p, 3);
+}
+
+function formatUTCMicroseconds(d, p) {
+    return formatUTCMilliseconds(d, p) + "000";
+}
+
+function formatUTCMonthNumber(d, p) {
+    return pad2(d.getUTCMonth() + 1, p, 2);
+}
+
+function formatUTCMinutes(d, p) {
+    return pad2(d.getUTCMinutes(), p, 2);
+}
+
+function formatUTCSeconds(d, p) {
+    return pad2(d.getUTCSeconds(), p, 2);
+}
+
+function formatUTCWeekdayNumberMonday(d) {
+    var dow = d.getUTCDay();
+    return dow === 0 ? 7 : dow;
+}
+
+function formatUTCWeekNumberSunday(d, p) {
+    return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
+}
+
+function UTCdISO(d) {
+    var day = d.getUTCDay();
+    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
+}
+
+function formatUTCWeekNumberISO(d, p) {
+    d = UTCdISO(d);
+    return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
+}
+
+function formatUTCWeekdayNumberSunday(d) {
+    return d.getUTCDay();
+}
+
+function formatUTCWeekNumberMonday(d, p) {
+    return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
+}
+
+function formatUTCYear(d, p) {
+    return pad2(d.getUTCFullYear() % 100, p, 2);
+}
+
+function formatUTCYearISO(d, p) {
+    d = UTCdISO(d);
+    return pad2(d.getUTCFullYear() % 100, p, 2);
+}
+
+function formatUTCFullYear(d, p) {
+    return pad2(d.getUTCFullYear() % 1e4, p, 4);
+}
+
+function formatUTCFullYearISO(d, p) {
+    var day = d.getUTCDay();
+    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
+    return pad2(d.getUTCFullYear() % 1e4, p, 4);
+}
+
+function formatUTCZone() {
+    return "+0000";
+}
+
+function formatLiteralPercent() {
+    return "%";
+}
+
+function formatUnixTimestamp(d) {
+    return +d;
+}
+
+function formatUnixTimestampSeconds(d) {
+    return Math.floor(+d / 1e3);
+}
+
+// node_modules/d3-time-format/src/defaultLocale.js
+var locale2;
+var timeFormat;
+var timeParse;
+var utcFormat;
+var utcParse;
+defaultLocale2({
+    dateTime: "%x, %X",
+    date: "%-m/%-d/%Y",
+    time: "%-I:%M:%S %p",
+    periods: ["AM", "PM"],
+    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
+    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
+    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
+    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
+});
+
+function defaultLocale2(definition) {
+    locale2 = formatLocale(definition);
+    timeFormat = locale2.format;
+    timeParse = locale2.parse;
+    utcFormat = locale2.utcFormat;
+    utcParse = locale2.utcParse;
+    return locale2;
+}
+
+// node_modules/d3-time-format/src/isoFormat.js
+var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
+
+function formatIsoNative(date3) {
+    return date3.toISOString();
+}
+var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
+var isoFormat_default = formatIso;
+
+// node_modules/d3-time-format/src/isoParse.js
+function parseIsoNative(string3) {
+    var date3 = new Date(string3);
+    return isNaN(date3) ? null : date3;
+}
+var parseIso = + /* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
+var isoParse_default = parseIso;
+
+// node_modules/d3-scale/src/time.js
+function date(t) {
+    return new Date(t);
+}
+
+function number4(t) {
+    return t instanceof Date ? +t : + /* @__PURE__ */ new Date(+t);
+}
+
+function calendar(ticks3, tickInterval, year, month, week, day, hour, minute, second5, format5) {
+    var scale5 = continuous(),
+        invert = scale5.invert,
+        domain = scale5.domain;
+    var formatMillisecond = format5(".%L"),
+        formatSecond = format5(":%S"),
+        formatMinute = format5("%I:%M"),
+        formatHour = format5("%I %p"),
+        formatDay = format5("%a %d"),
+        formatWeek = format5("%b %d"),
+        formatMonth3 = format5("%B"),
+        formatYear7 = format5("%Y");
+
+    function tickFormat3(date3) {
+        return (second5(date3) < date3 ? formatMillisecond : minute(date3) < date3 ? formatSecond : hour(date3) < date3 ? formatMinute : day(date3) < date3 ? formatHour : month(date3) < date3 ? week(date3) < date3 ? formatDay : formatWeek : year(date3) < date3 ? formatMonth3 : formatYear7)(date3);
+    }
+    scale5.invert = function(y7) {
+        return new Date(invert(y7));
+    };
+    scale5.domain = function(_) {
+        return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);
+    };
+    scale5.ticks = function(interval3) {
+        var d = domain();
+        return ticks3(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
+    };
+    scale5.tickFormat = function(count5, specifier) {
+        return specifier == null ? tickFormat3 : format5(specifier);
+    };
+    scale5.nice = function(interval3) {
+        var d = domain();
+        if (!interval3 || typeof interval3.range !== "function")
+            interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
+        return interval3 ? domain(nice2(d, interval3)) : scale5;
+    };
+    scale5.copy = function() {
+        return copy(scale5, calendar(ticks3, tickInterval, year, month, week, day, hour, minute, second5, format5));
+    };
+    return scale5;
+}
+
+function time() {
+    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
+}
+
+// node_modules/d3-scale/src/utcTime.js
+function utcTime() {
+    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
+}
+
+// node_modules/d3-scale/src/sequential.js
+function transformer3() {
+    var x011 = 0,
+        x13 = 1,
+        t05, t15, k10, transform3, interpolator = identity3,
+        clamp = false,
+        unknown;
+
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : interpolator(k10 === 0 ? 0.5 : (x7 = (transform3(x7) - t05) * k10, clamp ? Math.max(0, Math.min(1, x7)) : x7));
+    }
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13] = _, t05 = transform3(x011 = +x011), t15 = transform3(x13 = +x13), k10 = t05 === t15 ? 0 : 1 / (t15 - t05), scale5) : [x011, x13];
+    };
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = !!_, scale5) : clamp;
+    };
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
+    };
+
+    function range9(interpolate) {
+        return function(_) {
+            var r0, r1;
+            return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale5) : [interpolator(0), interpolator(1)];
+        };
+    }
+    scale5.range = range9(value_default);
+    scale5.rangeRound = range9(round_default);
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    return function(t) {
+        transform3 = t, t05 = t(x011), t15 = t(x13), k10 = t05 === t15 ? 0 : 1 / (t15 - t05);
+        return scale5;
+    };
+}
+
+function copy2(source, target) {
+    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
+}
+
+function sequential() {
+    var scale5 = linearish(transformer3()(identity3));
+    scale5.copy = function() {
+        return copy2(scale5, sequential());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function sequentialLog() {
+    var scale5 = loggish(transformer3()).domain([1, 10]);
+    scale5.copy = function() {
+        return copy2(scale5, sequentialLog()).base(scale5.base());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function sequentialSymlog() {
+    var scale5 = symlogish(transformer3());
+    scale5.copy = function() {
+        return copy2(scale5, sequentialSymlog()).constant(scale5.constant());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function sequentialPow() {
+    var scale5 = powish(transformer3());
+    scale5.copy = function() {
+        return copy2(scale5, sequentialPow()).exponent(scale5.exponent());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function sequentialSqrt() {
+    return sequentialPow.apply(null, arguments).exponent(0.5);
+}
+
+// node_modules/d3-scale/src/sequentialQuantile.js
+function sequentialQuantile() {
+    var domain = [],
+        interpolator = identity3;
+
+    function scale5(x7) {
+        if (x7 != null && !isNaN(x7 = +x7))
+            return interpolator((bisect_default(domain, x7, 1) - 1) / (domain.length - 1));
+    }
+    scale5.domain = function(_) {
+        if (!arguments.length)
+            return domain.slice();
+        domain = [];
+        for (let d of _)
+            if (d != null && !isNaN(d = +d))
+                domain.push(d);
+        domain.sort(ascending);
+        return scale5;
+    };
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
+    };
+    scale5.range = function() {
+        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
+    };
+    scale5.quantiles = function(n) {
+        return Array.from({
+            length: n + 1
+        }, (_, i) => quantile(domain, i / n));
+    };
+    scale5.copy = function() {
+        return sequentialQuantile(interpolator).domain(domain);
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+// node_modules/d3-scale/src/diverging.js
+function transformer4() {
+    var x011 = 0,
+        x13 = 0.5,
+        x22 = 1,
+        s3 = 1,
+        t05, t15, t23, k10, k21, interpolator = identity3,
+        transform3, clamp = false,
+        unknown;
+
+    function scale5(x7) {
+        return isNaN(x7 = +x7) ? unknown : (x7 = 0.5 + ((x7 = +transform3(x7)) - t15) * (s3 * x7 < s3 * t15 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x7)) : x7));
+    }
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13, x22] = _, t05 = transform3(x011 = +x011), t15 = transform3(x13 = +x13), t23 = transform3(x22 = +x22), k10 = t05 === t15 ? 0 : 0.5 / (t15 - t05), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t05 ? -1 : 1, scale5) : [x011, x13, x22];
+    };
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = !!_, scale5) : clamp;
+    };
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
+    };
+
+    function range9(interpolate) {
+        return function(_) {
+            var r0, r1, r2;
+            return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale5) : [interpolator(0), interpolator(0.5), interpolator(1)];
+        };
+    }
+    scale5.range = range9(value_default);
+    scale5.rangeRound = range9(round_default);
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
+    };
+    return function(t) {
+        transform3 = t, t05 = t(x011), t15 = t(x13), t23 = t(x22), k10 = t05 === t15 ? 0 : 0.5 / (t15 - t05), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t05 ? -1 : 1;
+        return scale5;
+    };
+}
+
+function diverging() {
+    var scale5 = linearish(transformer4()(identity3));
+    scale5.copy = function() {
+        return copy2(scale5, diverging());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function divergingLog() {
+    var scale5 = loggish(transformer4()).domain([0.1, 1, 10]);
+    scale5.copy = function() {
+        return copy2(scale5, divergingLog()).base(scale5.base());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function divergingSymlog() {
+    var scale5 = symlogish(transformer4());
+    scale5.copy = function() {
+        return copy2(scale5, divergingSymlog()).constant(scale5.constant());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function divergingPow() {
+    var scale5 = powish(transformer4());
+    scale5.copy = function() {
+        return copy2(scale5, divergingPow()).exponent(scale5.exponent());
+    };
+    return initInterpolator.apply(scale5, arguments);
+}
+
+function divergingSqrt() {
+    return divergingPow.apply(null, arguments).exponent(0.5);
+}
+
+// node_modules/d3-scale-chromatic/src/colors.js
+function colors_default(specifier) {
+    var n = specifier.length / 6 | 0,
+        colors = new Array(n),
+        i = 0;
+    while (i < n)
+        colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
+    return colors;
+}
+
+// node_modules/d3-scale-chromatic/src/categorical/category10.js
+var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
+
+// node_modules/d3-scale-chromatic/src/categorical/Accent.js
+var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
+
+// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
+var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
+
+// node_modules/d3-scale-chromatic/src/categorical/Paired.js
+var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
+
+// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
+var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
+
+// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
+var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
+
+// node_modules/d3-scale-chromatic/src/categorical/Set1.js
+var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
+
+// node_modules/d3-scale-chromatic/src/categorical/Set2.js
+var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
+
+// node_modules/d3-scale-chromatic/src/categorical/Set3.js
+var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
+
+// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
+var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
+
+// node_modules/d3-scale-chromatic/src/ramp.js
+var ramp_default = (scheme55) => rgbBasis(scheme55[scheme55.length - 1]);
+
+// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
+var scheme = new Array(3).concat(
+    "d8b365f5f5f55ab4ac",
+    "a6611adfc27d80cdc1018571",
+    "a6611adfc27df5f5f580cdc1018571",
+    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
+    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
+    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
+    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
+    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
+    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
+).map(colors_default);
+var BrBG_default = ramp_default(scheme);
+
+// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
+var scheme2 = new Array(3).concat(
+    "af8dc3f7f7f77fbf7b",
+    "7b3294c2a5cfa6dba0008837",
+    "7b3294c2a5cff7f7f7a6dba0008837",
+    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
+    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
+    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
+    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
+    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
+    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
+).map(colors_default);
+var PRGn_default = ramp_default(scheme2);
+
+// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
+var scheme3 = new Array(3).concat(
+    "e9a3c9f7f7f7a1d76a",
+    "d01c8bf1b6dab8e1864dac26",
+    "d01c8bf1b6daf7f7f7b8e1864dac26",
+    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
+    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
+    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
+    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
+    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
+    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
+).map(colors_default);
+var PiYG_default = ramp_default(scheme3);
+
+// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
+var scheme4 = new Array(3).concat(
+    "998ec3f7f7f7f1a340",
+    "5e3c99b2abd2fdb863e66101",
+    "5e3c99b2abd2f7f7f7fdb863e66101",
+    "542788998ec3d8daebfee0b6f1a340b35806",
+    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
+    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
+    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
+    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
+    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
+).map(colors_default);
+var PuOr_default = ramp_default(scheme4);
+
+// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
+var scheme5 = new Array(3).concat(
+    "ef8a62f7f7f767a9cf",
+    "ca0020f4a58292c5de0571b0",
+    "ca0020f4a582f7f7f792c5de0571b0",
+    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
+    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
+    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
+    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
+    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
+    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
+).map(colors_default);
+var RdBu_default = ramp_default(scheme5);
+
+// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
+var scheme6 = new Array(3).concat(
+    "ef8a62ffffff999999",
+    "ca0020f4a582bababa404040",
+    "ca0020f4a582ffffffbababa404040",
+    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
+    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
+    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
+    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
+    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
+    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
+).map(colors_default);
+var RdGy_default = ramp_default(scheme6);
+
+// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
+var scheme7 = new Array(3).concat(
+    "fc8d59ffffbf91bfdb",
+    "d7191cfdae61abd9e92c7bb6",
+    "d7191cfdae61ffffbfabd9e92c7bb6",
+    "d73027fc8d59fee090e0f3f891bfdb4575b4",
+    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
+    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
+    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
+    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
+    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
+).map(colors_default);
+var RdYlBu_default = ramp_default(scheme7);
+
+// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
+var scheme8 = new Array(3).concat(
+    "fc8d59ffffbf91cf60",
+    "d7191cfdae61a6d96a1a9641",
+    "d7191cfdae61ffffbfa6d96a1a9641",
+    "d73027fc8d59fee08bd9ef8b91cf601a9850",
+    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
+    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
+    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
+    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
+    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
+).map(colors_default);
+var RdYlGn_default = ramp_default(scheme8);
+
+// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
+var scheme9 = new Array(3).concat(
+    "fc8d59ffffbf99d594",
+    "d7191cfdae61abdda42b83ba",
+    "d7191cfdae61ffffbfabdda42b83ba",
+    "d53e4ffc8d59fee08be6f59899d5943288bd",
+    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
+    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
+    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
+    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
+    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
+).map(colors_default);
+var Spectral_default = ramp_default(scheme9);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
+var scheme10 = new Array(3).concat(
+    "e5f5f999d8c92ca25f",
+    "edf8fbb2e2e266c2a4238b45",
+    "edf8fbb2e2e266c2a42ca25f006d2c",
+    "edf8fbccece699d8c966c2a42ca25f006d2c",
+    "edf8fbccece699d8c966c2a441ae76238b45005824",
+    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
+    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
+).map(colors_default);
+var BuGn_default = ramp_default(scheme10);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
+var scheme11 = new Array(3).concat(
+    "e0ecf49ebcda8856a7",
+    "edf8fbb3cde38c96c688419d",
+    "edf8fbb3cde38c96c68856a7810f7c",
+    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
+    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
+    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
+    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
+).map(colors_default);
+var BuPu_default = ramp_default(scheme11);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
+var scheme12 = new Array(3).concat(
+    "e0f3dba8ddb543a2ca",
+    "f0f9e8bae4bc7bccc42b8cbe",
+    "f0f9e8bae4bc7bccc443a2ca0868ac",
+    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
+    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
+    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
+    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
+).map(colors_default);
+var GnBu_default = ramp_default(scheme12);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
+var scheme13 = new Array(3).concat(
+    "fee8c8fdbb84e34a33",
+    "fef0d9fdcc8afc8d59d7301f",
+    "fef0d9fdcc8afc8d59e34a33b30000",
+    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
+    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
+    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
+    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
+).map(colors_default);
+var OrRd_default = ramp_default(scheme13);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
+var scheme14 = new Array(3).concat(
+    "ece2f0a6bddb1c9099",
+    "f6eff7bdc9e167a9cf02818a",
+    "f6eff7bdc9e167a9cf1c9099016c59",
+    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
+    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
+    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
+    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
+).map(colors_default);
+var PuBuGn_default = ramp_default(scheme14);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
+var scheme15 = new Array(3).concat(
+    "ece7f2a6bddb2b8cbe",
+    "f1eef6bdc9e174a9cf0570b0",
+    "f1eef6bdc9e174a9cf2b8cbe045a8d",
+    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
+    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
+    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
+    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
+).map(colors_default);
+var PuBu_default = ramp_default(scheme15);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
+var scheme16 = new Array(3).concat(
+    "e7e1efc994c7dd1c77",
+    "f1eef6d7b5d8df65b0ce1256",
+    "f1eef6d7b5d8df65b0dd1c77980043",
+    "f1eef6d4b9dac994c7df65b0dd1c77980043",
+    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
+    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
+    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
+).map(colors_default);
+var PuRd_default = ramp_default(scheme16);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
+var scheme17 = new Array(3).concat(
+    "fde0ddfa9fb5c51b8a",
+    "feebe2fbb4b9f768a1ae017e",
+    "feebe2fbb4b9f768a1c51b8a7a0177",
+    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
+    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
+    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
+    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
+).map(colors_default);
+var RdPu_default = ramp_default(scheme17);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
+var scheme18 = new Array(3).concat(
+    "edf8b17fcdbb2c7fb8",
+    "ffffcca1dab441b6c4225ea8",
+    "ffffcca1dab441b6c42c7fb8253494",
+    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
+    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
+    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
+    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
+).map(colors_default);
+var YlGnBu_default = ramp_default(scheme18);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
+var scheme19 = new Array(3).concat(
+    "f7fcb9addd8e31a354",
+    "ffffccc2e69978c679238443",
+    "ffffccc2e69978c67931a354006837",
+    "ffffccd9f0a3addd8e78c67931a354006837",
+    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
+    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
+    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
+).map(colors_default);
+var YlGn_default = ramp_default(scheme19);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
+var scheme20 = new Array(3).concat(
+    "fff7bcfec44fd95f0e",
+    "ffffd4fed98efe9929cc4c02",
+    "ffffd4fed98efe9929d95f0e993404",
+    "ffffd4fee391fec44ffe9929d95f0e993404",
+    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
+    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
+    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
+).map(colors_default);
+var YlOrBr_default = ramp_default(scheme20);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
+var scheme21 = new Array(3).concat(
+    "ffeda0feb24cf03b20",
+    "ffffb2fecc5cfd8d3ce31a1c",
+    "ffffb2fecc5cfd8d3cf03b20bd0026",
+    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
+    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
+    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
+    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
+).map(colors_default);
+var YlOrRd_default = ramp_default(scheme21);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
+var scheme22 = new Array(3).concat(
+    "deebf79ecae13182bd",
+    "eff3ffbdd7e76baed62171b5",
+    "eff3ffbdd7e76baed63182bd08519c",
+    "eff3ffc6dbef9ecae16baed63182bd08519c",
+    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
+    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
+    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
+).map(colors_default);
+var Blues_default = ramp_default(scheme22);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
+var scheme23 = new Array(3).concat(
+    "e5f5e0a1d99b31a354",
+    "edf8e9bae4b374c476238b45",
+    "edf8e9bae4b374c47631a354006d2c",
+    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
+    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
+    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
+    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
+).map(colors_default);
+var Greens_default = ramp_default(scheme23);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
+var scheme24 = new Array(3).concat(
+    "f0f0f0bdbdbd636363",
+    "f7f7f7cccccc969696525252",
+    "f7f7f7cccccc969696636363252525",
+    "f7f7f7d9d9d9bdbdbd969696636363252525",
+    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
+    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
+    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
+).map(colors_default);
+var Greys_default = ramp_default(scheme24);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
+var scheme25 = new Array(3).concat(
+    "efedf5bcbddc756bb1",
+    "f2f0f7cbc9e29e9ac86a51a3",
+    "f2f0f7cbc9e29e9ac8756bb154278f",
+    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
+    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
+    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
+    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
+).map(colors_default);
+var Purples_default = ramp_default(scheme25);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
+var scheme26 = new Array(3).concat(
+    "fee0d2fc9272de2d26",
+    "fee5d9fcae91fb6a4acb181d",
+    "fee5d9fcae91fb6a4ade2d26a50f15",
+    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
+    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
+    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
+    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
+).map(colors_default);
+var Reds_default = ramp_default(scheme26);
+
+// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
+var scheme27 = new Array(3).concat(
+    "fee6cefdae6be6550d",
+    "feeddefdbe85fd8d3cd94701",
+    "feeddefdbe85fd8d3ce6550da63603",
+    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
+    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
+    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
+    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
+).map(colors_default);
+var Oranges_default = ramp_default(scheme27);
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
+function cividis_default(t) {
+    t = Math.max(0, Math.min(1, t));
+    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
+}
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
+var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
+var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
+var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
+var c3 = cubehelix();
+
+function rainbow_default(t) {
+    if (t < 0 || t > 1)
+        t -= Math.floor(t);
+    var ts = Math.abs(t - 0.5);
+    c3.h = 360 * t - 100;
+    c3.s = 1.5 - 1.5 * ts;
+    c3.l = 0.8 - 0.9 * ts;
+    return c3 + "";
+}
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
+var c4 = rgb();
+var pi_1_3 = Math.PI / 3;
+var pi_2_3 = Math.PI * 2 / 3;
+
+function sinebow_default(t) {
+    var x7;
+    t = (0.5 - t) * Math.PI;
+    c4.r = 255 * (x7 = Math.sin(t)) * x7;
+    c4.g = 255 * (x7 = Math.sin(t + pi_1_3)) * x7;
+    c4.b = 255 * (x7 = Math.sin(t + pi_2_3)) * x7;
+    return c4 + "";
+}
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
+function turbo_default(t) {
+    t = Math.max(0, Math.min(1, t));
+    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
+}
+
+// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
+function ramp(range9) {
+    var n = range9.length;
+    return function(t) {
+        return range9[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
+    };
+}
+var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
+var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
+var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
+var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
+
+// node_modules/d3-shape/src/constant.js
+function constant_default10(x7) {
+    return function constant5() {
+        return x7;
+    };
+}
+
+// node_modules/d3-shape/src/math.js
+var abs4 = Math.abs;
+var atan22 = Math.atan2;
+var cos3 = Math.cos;
+var max4 = Math.max;
+var min3 = Math.min;
+var sin3 = Math.sin;
+var sqrt3 = Math.sqrt;
+var epsilon8 = 1e-12;
+var pi5 = Math.PI;
+var halfPi4 = pi5 / 2;
+var tau6 = 2 * pi5;
+
+function acos2(x7) {
+    return x7 > 1 ? 0 : x7 < -1 ? pi5 : Math.acos(x7);
+}
+
+function asin2(x7) {
+    return x7 >= 1 ? halfPi4 : x7 <= -1 ? -halfPi4 : Math.asin(x7);
+}
+
+// node_modules/d3-shape/src/path.js
+function withPath(shape) {
+    let digits = 3;
+    shape.digits = function(_) {
+        if (!arguments.length)
+            return digits;
+        if (_ == null) {
+            digits = null;
+        } else {
+            const d = Math.floor(_);
+            if (!(d >= 0))
+                throw new RangeError(`invalid digits: ${_}`);
+            digits = d;
+        }
+        return shape;
+    };
+    return () => new Path(digits);
+}
+
+// node_modules/d3-shape/src/arc.js
+function arcInnerRadius(d) {
+    return d.innerRadius;
+}
+
+function arcOuterRadius(d) {
+    return d.outerRadius;
+}
+
+function arcStartAngle(d) {
+    return d.startAngle;
+}
+
+function arcEndAngle(d) {
+    return d.endAngle;
+}
+
+function arcPadAngle(d) {
+    return d && d.padAngle;
+}
+
+function intersect(x011, y011, x13, y13, x22, y22, x32, y32) {
+    var x10 = x13 - x011,
+        y10 = y13 - y011,
+        x322 = x32 - x22,
+        y322 = y32 - y22,
+        t = y322 * x10 - x322 * y10;
+    if (t * t < epsilon8)
+        return;
+    t = (x322 * (y011 - y22) - y322 * (x011 - x22)) / t;
+    return [x011 + t * x10, y011 + t * y10];
+}
+
+function cornerTangents(x011, y011, x13, y13, r1, rc, cw) {
+    var x01 = x011 - x13,
+        y01 = y011 - y13,
+        lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01),
+        ox3 = lo * y01,
+        oy3 = -lo * x01,
+        x11 = x011 + ox3,
+        y11 = y011 + oy3,
+        x10 = x13 + ox3,
+        y10 = y13 + oy3,
+        x007 = (x11 + x10) / 2,
+        y007 = (y11 + y10) / 2,
+        dx = x10 - x11,
+        dy = y10 - y11,
+        d2 = dx * dx + dy * dy,
+        r = r1 - rc,
+        D5 = x11 * y10 - x10 * y11,
+        d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D5 * D5)),
+        cx0 = (D5 * dy - dx * d) / d2,
+        cy0 = (-D5 * dx - dy * d) / d2,
+        cx1 = (D5 * dy + dx * d) / d2,
+        cy1 = (-D5 * dx + dy * d) / d2,
+        dx0 = cx0 - x007,
+        dy0 = cy0 - y007,
+        dx1 = cx1 - x007,
+        dy1 = cy1 - y007;
+    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
+        cx0 = cx1, cy0 = cy1;
+    return {
+        cx: cx0,
+        cy: cy0,
+        x01: -ox3,
+        y01: -oy3,
+        x11: cx0 * (r1 / r - 1),
+        y11: cy0 * (r1 / r - 1)
+    };
+}
+
+function arc_default() {
+    var innerRadius = arcInnerRadius,
+        outerRadius = arcOuterRadius,
+        cornerRadius = constant_default10(0),
+        padRadius = null,
+        startAngle = arcStartAngle,
+        endAngle = arcEndAngle,
+        padAngle = arcPadAngle,
+        context = null,
+        path3 = withPath(arc);
+
+    function arc() {
+        var buffer, r, r0 = +innerRadius.apply(this, arguments),
+            r1 = +outerRadius.apply(this, arguments),
+            a0 = startAngle.apply(this, arguments) - halfPi4,
+            a1 = endAngle.apply(this, arguments) - halfPi4,
+            da3 = abs4(a1 - a0),
+            cw = a1 > a0;
+        if (!context)
+            context = buffer = path3();
+        if (r1 < r0)
+            r = r1, r1 = r0, r0 = r;
+        if (!(r1 > epsilon8))
+            context.moveTo(0, 0);
+        else if (da3 > tau6 - epsilon8) {
+            context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
+            context.arc(0, 0, r1, a0, a1, !cw);
+            if (r0 > epsilon8) {
+                context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
+                context.arc(0, 0, r0, a1, a0, cw);
+            }
+        } else {
+            var a01 = a0,
+                a11 = a1,
+                a00 = a0,
+                a10 = a1,
+                da0 = da3,
+                da1 = da3,
+                ap = padAngle.apply(this, arguments) / 2,
+                rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)),
+                rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
+                rc0 = rc,
+                rc1 = rc,
+                t05, t15;
+            if (rp > epsilon8) {
+                var p03 = asin2(rp / r0 * sin3(ap)),
+                    p1 = asin2(rp / r1 * sin3(ap));
+                if ((da0 -= p03 * 2) > epsilon8)
+                    p03 *= cw ? 1 : -1, a00 += p03, a10 -= p03;
+                else
+                    da0 = 0, a00 = a10 = (a0 + a1) / 2;
+                if ((da1 -= p1 * 2) > epsilon8)
+                    p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
+                else
+                    da1 = 0, a01 = a11 = (a0 + a1) / 2;
+            }
+            var x01 = r1 * cos3(a01),
+                y01 = r1 * sin3(a01),
+                x10 = r0 * cos3(a10),
+                y10 = r0 * sin3(a10);
+            if (rc > epsilon8) {
+                var x11 = r1 * cos3(a11),
+                    y11 = r1 * sin3(a11),
+                    x007 = r0 * cos3(a00),
+                    y007 = r0 * sin3(a00),
+                    oc;
+                if (da3 < pi5) {
+                    if (oc = intersect(x01, y01, x007, y007, x11, y11, x10, y10)) {
+                        var ax = x01 - oc[0],
+                            ay = y01 - oc[1],
+                            bx = x11 - oc[0],
+                            by = y11 - oc[1],
+                            kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2),
+                            lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
+                        rc0 = min3(rc, (r0 - lc) / (kc - 1));
+                        rc1 = min3(rc, (r1 - lc) / (kc + 1));
+                    } else {
+                        rc0 = rc1 = 0;
+                    }
+                }
+            }
+            if (!(da1 > epsilon8))
+                context.moveTo(x01, y01);
+            else if (rc1 > epsilon8) {
+                t05 = cornerTangents(x007, y007, x01, y01, r1, rc1, cw);
+                t15 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
+                context.moveTo(t05.cx + t05.x01, t05.cy + t05.y01);
+                if (rc1 < rc)
+                    context.arc(t05.cx, t05.cy, rc1, atan22(t05.y01, t05.x01), atan22(t15.y01, t15.x01), !cw);
+                else {
+                    context.arc(t05.cx, t05.cy, rc1, atan22(t05.y01, t05.x01), atan22(t05.y11, t05.x11), !cw);
+                    context.arc(0, 0, r1, atan22(t05.cy + t05.y11, t05.cx + t05.x11), atan22(t15.cy + t15.y11, t15.cx + t15.x11), !cw);
+                    context.arc(t15.cx, t15.cy, rc1, atan22(t15.y11, t15.x11), atan22(t15.y01, t15.x01), !cw);
+                }
+            } else
+                context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
+            if (!(r0 > epsilon8) || !(da0 > epsilon8))
+                context.lineTo(x10, y10);
+            else if (rc0 > epsilon8) {
+                t05 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
+                t15 = cornerTangents(x01, y01, x007, y007, r0, -rc0, cw);
+                context.lineTo(t05.cx + t05.x01, t05.cy + t05.y01);
+                if (rc0 < rc)
+                    context.arc(t05.cx, t05.cy, rc0, atan22(t05.y01, t05.x01), atan22(t15.y01, t15.x01), !cw);
+                else {
+                    context.arc(t05.cx, t05.cy, rc0, atan22(t05.y01, t05.x01), atan22(t05.y11, t05.x11), !cw);
+                    context.arc(0, 0, r0, atan22(t05.cy + t05.y11, t05.cx + t05.x11), atan22(t15.cy + t15.y11, t15.cx + t15.x11), cw);
+                    context.arc(t15.cx, t15.cy, rc0, atan22(t15.y11, t15.x11), atan22(t15.y01, t15.x01), !cw);
+                }
+            } else
+                context.arc(0, 0, r0, a10, a00, cw);
+        }
+        context.closePath();
+        if (buffer)
+            return context = null, buffer + "" || null;
+    }
+    arc.centroid = function() {
+        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
+            a7 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;
+        return [cos3(a7) * r, sin3(a7) * r];
+    };
+    arc.innerRadius = function(_) {
+        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : innerRadius;
+    };
+    arc.outerRadius = function(_) {
+        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : outerRadius;
+    };
+    arc.cornerRadius = function(_) {
+        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : cornerRadius;
+    };
+    arc.padRadius = function(_) {
+        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), arc) : padRadius;
+    };
+    arc.startAngle = function(_) {
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : startAngle;
+    };
+    arc.endAngle = function(_) {
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : endAngle;
+    };
+    arc.padAngle = function(_) {
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : padAngle;
+    };
+    arc.context = function(_) {
+        return arguments.length ? (context = _ == null ? null : _, arc) : context;
+    };
+    return arc;
+}
+
+// node_modules/d3-shape/src/array.js
+var slice4 = Array.prototype.slice;
+
+function array_default3(x7) {
+    return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
+}
+
+// node_modules/d3-shape/src/curve/linear.js
+function Linear(context) {
+    this._context = context;
+}
+Linear.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+            default:
+                this._context.lineTo(x7, y7);
+                break;
+        }
+    }
+};
+
+function linear_default(context) {
+    return new Linear(context);
+}
+
+// node_modules/d3-shape/src/point.js
+function x3(p) {
+    return p[0];
+}
+
+function y3(p) {
+    return p[1];
+}
+
+// node_modules/d3-shape/src/line.js
+function line_default2(x7, y7) {
+    var defined3 = constant_default10(true),
+        context = null,
+        curve = linear_default,
+        output = null,
+        path3 = withPath(line3);
+    x7 = typeof x7 === "function" ? x7 : x7 === void 0 ? x3 : constant_default10(x7);
+    y7 = typeof y7 === "function" ? y7 : y7 === void 0 ? y3 : constant_default10(y7);
+
+    function line3(data) {
+        var i, n = (data = array_default3(data)).length,
+            d, defined0 = false,
+            buffer;
+        if (context == null)
+            output = curve(buffer = path3());
+        for (i = 0; i <= n; ++i) {
+            if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
+                if (defined0 = !defined0)
+                    output.lineStart();
+                else
+                    output.lineEnd();
+            }
+            if (defined0)
+                output.point(+x7(d, i, data), +y7(d, i, data));
+        }
+        if (buffer)
+            return output = null, buffer + "" || null;
+    }
+    line3.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default10(+_), line3) : x7;
+    };
+    line3.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default10(+_), line3) : y7;
+    };
+    line3.defined = function(_) {
+        return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default10(!!_), line3) : defined3;
+    };
+    line3.curve = function(_) {
+        return arguments.length ? (curve = _, context != null && (output = curve(context)), line3) : curve;
+    };
+    line3.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line3) : context;
+    };
+    return line3;
+}
+
+// node_modules/d3-shape/src/area.js
+function area_default5(x011, y011, y13) {
+    var x13 = null,
+        defined3 = constant_default10(true),
+        context = null,
+        curve = linear_default,
+        output = null,
+        path3 = withPath(area3);
+    x011 = typeof x011 === "function" ? x011 : x011 === void 0 ? x3 : constant_default10(+x011);
+    y011 = typeof y011 === "function" ? y011 : y011 === void 0 ? constant_default10(0) : constant_default10(+y011);
+    y13 = typeof y13 === "function" ? y13 : y13 === void 0 ? y3 : constant_default10(+y13);
+
+    function area3(data) {
+        var i, j, k3, n = (data = array_default3(data)).length,
+            d, defined0 = false,
+            buffer, x0z = new Array(n),
+            y0z = new Array(n);
+        if (context == null)
+            output = curve(buffer = path3());
+        for (i = 0; i <= n; ++i) {
+            if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
+                if (defined0 = !defined0) {
+                    j = i;
+                    output.areaStart();
+                    output.lineStart();
+                } else {
+                    output.lineEnd();
+                    output.lineStart();
+                    for (k3 = i - 1; k3 >= j; --k3) {
+                        output.point(x0z[k3], y0z[k3]);
+                    }
+                    output.lineEnd();
+                    output.areaEnd();
+                }
+            }
+            if (defined0) {
+                x0z[i] = +x011(d, i, data), y0z[i] = +y011(d, i, data);
+                output.point(x13 ? +x13(d, i, data) : x0z[i], y13 ? +y13(d, i, data) : y0z[i]);
+            }
+        }
+        if (buffer)
+            return output = null, buffer + "" || null;
+    }
+
+    function arealine() {
+        return line_default2().defined(defined3).curve(curve).context(context);
+    }
+    area3.x = function(_) {
+        return arguments.length ? (x011 = typeof _ === "function" ? _ : constant_default10(+_), x13 = null, area3) : x011;
+    };
+    area3.x0 = function(_) {
+        return arguments.length ? (x011 = typeof _ === "function" ? _ : constant_default10(+_), area3) : x011;
+    };
+    area3.x1 = function(_) {
+        return arguments.length ? (x13 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area3) : x13;
+    };
+    area3.y = function(_) {
+        return arguments.length ? (y011 = typeof _ === "function" ? _ : constant_default10(+_), y13 = null, area3) : y011;
+    };
+    area3.y0 = function(_) {
+        return arguments.length ? (y011 = typeof _ === "function" ? _ : constant_default10(+_), area3) : y011;
+    };
+    area3.y1 = function(_) {
+        return arguments.length ? (y13 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area3) : y13;
+    };
+    area3.lineX0 = area3.lineY0 = function() {
+        return arealine().x(x011).y(y011);
+    };
+    area3.lineY1 = function() {
+        return arealine().x(x011).y(y13);
+    };
+    area3.lineX1 = function() {
+        return arealine().x(x13).y(y011);
+    };
+    area3.defined = function(_) {
+        return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default10(!!_), area3) : defined3;
+    };
+    area3.curve = function(_) {
+        return arguments.length ? (curve = _, context != null && (output = curve(context)), area3) : curve;
+    };
+    area3.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area3) : context;
+    };
+    return area3;
+}
+
+// node_modules/d3-shape/src/descending.js
+function descending_default(a7, b) {
+    return b < a7 ? -1 : b > a7 ? 1 : b >= a7 ? 0 : NaN;
+}
+
+// node_modules/d3-shape/src/identity.js
+function identity_default5(d) {
+    return d;
+}
+
+// node_modules/d3-shape/src/pie.js
+function pie_default() {
+    var value = identity_default5,
+        sortValues = descending_default,
+        sort5 = null,
+        startAngle = constant_default10(0),
+        endAngle = constant_default10(tau6),
+        padAngle = constant_default10(0);
+
+    function pie(data) {
+        var i, n = (data = array_default3(data)).length,
+            j, k3, sum8 = 0,
+            index5 = new Array(n),
+            arcs = new Array(n),
+            a0 = +startAngle.apply(this, arguments),
+            da3 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)),
+            a1, p = Math.min(Math.abs(da3) / n, padAngle.apply(this, arguments)),
+            pa = p * (da3 < 0 ? -1 : 1),
+            v3;
+        for (i = 0; i < n; ++i) {
+            if ((v3 = arcs[index5[i] = i] = +value(data[i], i, data)) > 0) {
+                sum8 += v3;
+            }
+        }
+        if (sortValues != null)
+            index5.sort(function(i2, j2) {
+                return sortValues(arcs[i2], arcs[j2]);
+            });
+        else if (sort5 != null)
+            index5.sort(function(i2, j2) {
+                return sort5(data[i2], data[j2]);
+            });
+        for (i = 0, k3 = sum8 ? (da3 - n * pa) / sum8 : 0; i < n; ++i, a0 = a1) {
+            j = index5[i], v3 = arcs[j], a1 = a0 + (v3 > 0 ? v3 * k3 : 0) + pa, arcs[j] = {
+                data: data[j],
+                index: i,
+                value: v3,
+                startAngle: a0,
+                endAngle: a1,
+                padAngle: p
+            };
+        }
+        return arcs;
+    }
+    pie.value = function(_) {
+        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), pie) : value;
+    };
+    pie.sortValues = function(_) {
+        return arguments.length ? (sortValues = _, sort5 = null, pie) : sortValues;
+    };
+    pie.sort = function(_) {
+        return arguments.length ? (sort5 = _, sortValues = null, pie) : sort5;
+    };
+    pie.startAngle = function(_) {
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : startAngle;
+    };
+    pie.endAngle = function(_) {
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : endAngle;
+    };
+    pie.padAngle = function(_) {
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : padAngle;
+    };
+    return pie;
+}
+
+// node_modules/d3-shape/src/curve/radial.js
+var curveRadialLinear = curveRadial(linear_default);
+
+function Radial(curve) {
+    this._curve = curve;
+}
+Radial.prototype = {
+    areaStart: function() {
+        this._curve.areaStart();
+    },
+    areaEnd: function() {
+        this._curve.areaEnd();
+    },
+    lineStart: function() {
+        this._curve.lineStart();
+    },
+    lineEnd: function() {
+        this._curve.lineEnd();
+    },
+    point: function(a7, r) {
+        this._curve.point(r * Math.sin(a7), r * -Math.cos(a7));
+    }
+};
+
+function curveRadial(curve) {
+    function radial3(context) {
+        return new Radial(curve(context));
+    }
+    radial3._curve = curve;
+    return radial3;
+}
+
+// node_modules/d3-shape/src/lineRadial.js
+function lineRadial(l) {
+    var c11 = l.curve;
+    l.angle = l.x, delete l.x;
+    l.radius = l.y, delete l.y;
+    l.curve = function(_) {
+        return arguments.length ? c11(curveRadial(_)) : c11()._curve;
+    };
+    return l;
+}
+
+function lineRadial_default() {
+    return lineRadial(line_default2().curve(curveRadialLinear));
+}
+
+// node_modules/d3-shape/src/areaRadial.js
+function areaRadial_default() {
+    var a7 = area_default5().curve(curveRadialLinear),
+        c11 = a7.curve,
+        x011 = a7.lineX0,
+        x13 = a7.lineX1,
+        y011 = a7.lineY0,
+        y13 = a7.lineY1;
+    a7.angle = a7.x, delete a7.x;
+    a7.startAngle = a7.x0, delete a7.x0;
+    a7.endAngle = a7.x1, delete a7.x1;
+    a7.radius = a7.y, delete a7.y;
+    a7.innerRadius = a7.y0, delete a7.y0;
+    a7.outerRadius = a7.y1, delete a7.y1;
+    a7.lineStartAngle = function() {
+        return lineRadial(x011());
+    }, delete a7.lineX0;
+    a7.lineEndAngle = function() {
+        return lineRadial(x13());
+    }, delete a7.lineX1;
+    a7.lineInnerRadius = function() {
+        return lineRadial(y011());
+    }, delete a7.lineY0;
+    a7.lineOuterRadius = function() {
+        return lineRadial(y13());
+    }, delete a7.lineY1;
+    a7.curve = function(_) {
+        return arguments.length ? c11(curveRadial(_)) : c11()._curve;
+    };
+    return a7;
+}
+
+// node_modules/d3-shape/src/pointRadial.js
+function pointRadial_default(x7, y7) {
+    return [(y7 = +y7) * Math.cos(x7 -= Math.PI / 2), y7 * Math.sin(x7)];
+}
+
+// node_modules/d3-shape/src/curve/bump.js
+var Bump = class {
+    constructor(context, x7) {
+        this._context = context;
+        this._x = x7;
+    }
+    areaStart() {
+        this._line = 0;
+    }
+    areaEnd() {
+        this._line = NaN;
+    }
+    lineStart() {
+        this._point = 0;
+    }
+    lineEnd() {
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    }
+    point(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0: {
+                this._point = 1;
+                if (this._line)
+                    this._context.lineTo(x7, y7);
+                else
+                    this._context.moveTo(x7, y7);
+                break;
+            }
+            case 1:
+                this._point = 2;
+            default: {
+                if (this._x)
+                    this._context.bezierCurveTo(this._x0 = (this._x0 + x7) / 2, this._y0, this._x0, y7, x7, y7);
+                else
+                    this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y7) / 2, x7, this._y0, x7, y7);
+                break;
+            }
+        }
+        this._x0 = x7, this._y0 = y7;
+    }
+};
+var BumpRadial = class {
+    constructor(context) {
+        this._context = context;
+    }
+    lineStart() {
+        this._point = 0;
+    }
+    lineEnd() {}
+    point(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        if (this._point === 0) {
+            this._point = 1;
+        } else {
+            const p03 = pointRadial_default(this._x0, this._y0);
+            const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y7) / 2);
+            const p2 = pointRadial_default(x7, this._y0);
+            const p3 = pointRadial_default(x7, y7);
+            this._context.moveTo(...p03);
+            this._context.bezierCurveTo(...p1, ...p2, ...p3);
+        }
+        this._x0 = x7, this._y0 = y7;
+    }
+};
+
+function bumpX(context) {
+    return new Bump(context, true);
+}
+
+function bumpY(context) {
+    return new Bump(context, false);
+}
+
+function bumpRadial(context) {
+    return new BumpRadial(context);
+}
+
+// node_modules/d3-shape/src/link.js
+function linkSource(d) {
+    return d.source;
+}
+
+function linkTarget(d) {
+    return d.target;
+}
+
+function link2(curve) {
+    let source = linkSource,
+        target = linkTarget,
+        x7 = x3,
+        y7 = y3,
+        context = null,
+        output = null,
+        path3 = withPath(link7);
+
+    function link7() {
+        let buffer;
+        const argv = slice4.call(arguments);
+        const s3 = source.apply(this, argv);
+        const t = target.apply(this, argv);
+        if (context == null)
+            output = curve(buffer = path3());
+        output.lineStart();
+        argv[0] = s3, output.point(+x7.apply(this, argv), +y7.apply(this, argv));
+        argv[0] = t, output.point(+x7.apply(this, argv), +y7.apply(this, argv));
+        output.lineEnd();
+        if (buffer)
+            return output = null, buffer + "" || null;
+    }
+    link7.source = function(_) {
+        return arguments.length ? (source = _, link7) : source;
+    };
+    link7.target = function(_) {
+        return arguments.length ? (target = _, link7) : target;
+    };
+    link7.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default10(+_), link7) : x7;
+    };
+    link7.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default10(+_), link7) : y7;
+    };
+    link7.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link7) : context;
+    };
+    return link7;
+}
+
+function linkHorizontal() {
+    return link2(bumpX);
+}
+
+function linkVertical() {
+    return link2(bumpY);
+}
+
+function linkRadial() {
+    const l = link2(bumpRadial);
+    l.angle = l.x, delete l.x;
+    l.radius = l.y, delete l.y;
+    return l;
+}
+
+// node_modules/d3-shape/src/symbol/asterisk.js
+var sqrt32 = sqrt3(3);
+var asterisk_default = {
+    draw(context, size) {
+        const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
+        const t = r / 2;
+        const u7 = t * sqrt32;
+        context.moveTo(0, r);
+        context.lineTo(0, -r);
+        context.moveTo(-u7, -t);
+        context.lineTo(u7, t);
+        context.moveTo(-u7, t);
+        context.lineTo(u7, -t);
+    }
+};
+
+// node_modules/d3-shape/src/symbol/circle.js
+var circle_default3 = {
+    draw(context, size) {
+        const r = sqrt3(size / pi5);
+        context.moveTo(r, 0);
+        context.arc(0, 0, r, 0, tau6);
+    }
+};
+
+// node_modules/d3-shape/src/symbol/cross.js
+var cross_default2 = {
+    draw(context, size) {
+        const r = sqrt3(size / 5) / 2;
+        context.moveTo(-3 * r, -r);
+        context.lineTo(-r, -r);
+        context.lineTo(-r, -3 * r);
+        context.lineTo(r, -3 * r);
+        context.lineTo(r, -r);
+        context.lineTo(3 * r, -r);
+        context.lineTo(3 * r, r);
+        context.lineTo(r, r);
+        context.lineTo(r, 3 * r);
+        context.lineTo(-r, 3 * r);
+        context.lineTo(-r, r);
+        context.lineTo(-3 * r, r);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/diamond.js
+var tan30 = sqrt3(1 / 3);
+var tan30_2 = tan30 * 2;
+var diamond_default = {
+    draw(context, size) {
+        const y7 = sqrt3(size / tan30_2);
+        const x7 = y7 * tan30;
+        context.moveTo(0, -y7);
+        context.lineTo(x7, 0);
+        context.lineTo(0, y7);
+        context.lineTo(-x7, 0);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/diamond2.js
+var diamond2_default = {
+    draw(context, size) {
+        const r = sqrt3(size) * 0.62625;
+        context.moveTo(0, -r);
+        context.lineTo(r, 0);
+        context.lineTo(0, r);
+        context.lineTo(-r, 0);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/plus.js
+var plus_default = {
+    draw(context, size) {
+        const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;
+        context.moveTo(-r, 0);
+        context.lineTo(r, 0);
+        context.moveTo(0, r);
+        context.lineTo(0, -r);
+    }
+};
+
+// node_modules/d3-shape/src/symbol/square.js
+var square_default = {
+    draw(context, size) {
+        const w = sqrt3(size);
+        const x7 = -w / 2;
+        context.rect(x7, x7, w, w);
+    }
+};
+
+// node_modules/d3-shape/src/symbol/square2.js
+var square2_default = {
+    draw(context, size) {
+        const r = sqrt3(size) * 0.4431;
+        context.moveTo(r, r);
+        context.lineTo(r, -r);
+        context.lineTo(-r, -r);
+        context.lineTo(-r, r);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/star.js
+var ka = 0.8908130915292852;
+var kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);
+var kx = sin3(tau6 / 10) * kr;
+var ky = -cos3(tau6 / 10) * kr;
+var star_default = {
+    draw(context, size) {
+        const r = sqrt3(size * ka);
+        const x7 = kx * r;
+        const y7 = ky * r;
+        context.moveTo(0, -r);
+        context.lineTo(x7, y7);
+        for (let i = 1; i < 5; ++i) {
+            const a7 = tau6 * i / 5;
+            const c11 = cos3(a7);
+            const s3 = sin3(a7);
+            context.lineTo(s3 * r, -c11 * r);
+            context.lineTo(c11 * x7 - s3 * y7, s3 * x7 + c11 * y7);
+        }
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/triangle.js
+var sqrt33 = sqrt3(3);
+var triangle_default = {
+    draw(context, size) {
+        const y7 = -sqrt3(size / (sqrt33 * 3));
+        context.moveTo(0, y7 * 2);
+        context.lineTo(-sqrt33 * y7, -y7);
+        context.lineTo(sqrt33 * y7, -y7);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/triangle2.js
+var sqrt34 = sqrt3(3);
+var triangle2_default = {
+    draw(context, size) {
+        const s3 = sqrt3(size) * 0.6824;
+        const t = s3 / 2;
+        const u7 = s3 * sqrt34 / 2;
+        context.moveTo(0, -s3);
+        context.lineTo(u7, t);
+        context.lineTo(-u7, t);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/wye.js
+var c5 = -0.5;
+var s = sqrt3(3) / 2;
+var k = 1 / sqrt3(12);
+var a3 = (k / 2 + 1) * 3;
+var wye_default = {
+    draw(context, size) {
+        const r = sqrt3(size / a3);
+        const x011 = r / 2,
+            y011 = r * k;
+        const x13 = x011,
+            y13 = r * k + r;
+        const x22 = -x13,
+            y22 = y13;
+        context.moveTo(x011, y011);
+        context.lineTo(x13, y13);
+        context.lineTo(x22, y22);
+        context.lineTo(c5 * x011 - s * y011, s * x011 + c5 * y011);
+        context.lineTo(c5 * x13 - s * y13, s * x13 + c5 * y13);
+        context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);
+        context.lineTo(c5 * x011 + s * y011, c5 * y011 - s * x011);
+        context.lineTo(c5 * x13 + s * y13, c5 * y13 - s * x13);
+        context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);
+        context.closePath();
+    }
+};
+
+// node_modules/d3-shape/src/symbol/times.js
+var times_default = {
+    draw(context, size) {
+        const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
+        context.moveTo(-r, -r);
+        context.lineTo(r, r);
+        context.moveTo(-r, r);
+        context.lineTo(r, -r);
+    }
+};
+
+// node_modules/d3-shape/src/symbol.js
+var symbolsFill = [
+    circle_default3,
+    cross_default2,
+    diamond_default,
+    square_default,
+    star_default,
+    triangle_default,
+    wye_default
+];
+var symbolsStroke = [
+    circle_default3,
+    plus_default,
+    times_default,
+    triangle2_default,
+    asterisk_default,
+    square2_default,
+    diamond2_default
+];
+
+function Symbol2(type3, size) {
+    let context = null,
+        path3 = withPath(symbol3);
+    type3 = typeof type3 === "function" ? type3 : constant_default10(type3 || circle_default3);
+    size = typeof size === "function" ? size : constant_default10(size === void 0 ? 64 : +size);
+
+    function symbol3() {
+        let buffer;
+        if (!context)
+            context = buffer = path3();
+        type3.apply(this, arguments).draw(context, +size.apply(this, arguments));
+        if (buffer)
+            return context = null, buffer + "" || null;
+    }
+    symbol3.type = function(_) {
+        return arguments.length ? (type3 = typeof _ === "function" ? _ : constant_default10(_), symbol3) : type3;
+    };
+    symbol3.size = function(_) {
+        return arguments.length ? (size = typeof _ === "function" ? _ : constant_default10(+_), symbol3) : size;
+    };
+    symbol3.context = function(_) {
+        return arguments.length ? (context = _ == null ? null : _, symbol3) : context;
+    };
+    return symbol3;
+}
+
+// node_modules/d3-shape/src/noop.js
+function noop_default2() {}
+
+// node_modules/d3-shape/src/curve/basis.js
+function point2(that, x7, y7) {
+    that._context.bezierCurveTo(
+        (2 * that._x0 + that._x1) / 3,
+        (2 * that._y0 + that._y1) / 3,
+        (that._x0 + 2 * that._x1) / 3,
+        (that._y0 + 2 * that._y1) / 3,
+        (that._x0 + 4 * that._x1 + x7) / 6,
+        (that._y0 + 4 * that._y1 + y7) / 6
+    );
+}
+
+function Basis(context) {
+    this._context = context;
+}
+Basis.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 3:
+                point2(this, this._x1, this._y1);
+            case 2:
+                this._context.lineTo(this._x1, this._y1);
+                break;
+        }
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
+            default:
+                point2(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
+    }
+};
+
+function basis_default2(context) {
+    return new Basis(context);
+}
+
+// node_modules/d3-shape/src/curve/basisClosed.js
+function BasisClosed(context) {
+    this._context = context;
+}
+BasisClosed.prototype = {
+    areaStart: noop_default2,
+    areaEnd: noop_default2,
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 1: {
+                this._context.moveTo(this._x2, this._y2);
+                this._context.closePath();
+                break;
+            }
+            case 2: {
+                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
+                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
+                this._context.closePath();
+                break;
+            }
+            case 3: {
+                this.point(this._x2, this._y2);
+                this.point(this._x3, this._y3);
+                this.point(this._x4, this._y4);
+                break;
+            }
+        }
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._x2 = x7, this._y2 = y7;
+                break;
+            case 1:
+                this._point = 2;
+                this._x3 = x7, this._y3 = y7;
+                break;
+            case 2:
+                this._point = 3;
+                this._x4 = x7, this._y4 = y7;
+                this._context.moveTo((this._x0 + 4 * this._x1 + x7) / 6, (this._y0 + 4 * this._y1 + y7) / 6);
+                break;
+            default:
+                point2(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
+    }
+};
+
+function basisClosed_default2(context) {
+    return new BasisClosed(context);
+}
+
+// node_modules/d3-shape/src/curve/basisOpen.js
+function BasisOpen(context) {
+    this._context = context;
+}
+BasisOpen.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._line || this._line !== 0 && this._point === 3)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+                var x011 = (this._x0 + 4 * this._x1 + x7) / 6,
+                    y011 = (this._y0 + 4 * this._y1 + y7) / 6;
+                this._line ? this._context.lineTo(x011, y011) : this._context.moveTo(x011, y011);
+                break;
+            case 3:
+                this._point = 4;
+            default:
+                point2(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
+    }
+};
+
+function basisOpen_default(context) {
+    return new BasisOpen(context);
+}
+
+// node_modules/d3-shape/src/curve/bundle.js
+function Bundle(context, beta) {
+    this._basis = new Basis(context);
+    this._beta = beta;
+}
+Bundle.prototype = {
+    lineStart: function() {
+        this._x = [];
+        this._y = [];
+        this._basis.lineStart();
+    },
+    lineEnd: function() {
+        var x7 = this._x,
+            y7 = this._y,
+            j = x7.length - 1;
+        if (j > 0) {
+            var x011 = x7[0],
+                y011 = y7[0],
+                dx = x7[j] - x011,
+                dy = y7[j] - y011,
+                i = -1,
+                t;
+            while (++i <= j) {
+                t = i / j;
+                this._basis.point(
+                    this._beta * x7[i] + (1 - this._beta) * (x011 + t * dx),
+                    this._beta * y7[i] + (1 - this._beta) * (y011 + t * dy)
+                );
+            }
+        }
+        this._x = this._y = null;
+        this._basis.lineEnd();
+    },
+    point: function(x7, y7) {
+        this._x.push(+x7);
+        this._y.push(+y7);
+    }
+};
+var bundle_default = function custom12(beta) {
+    function bundle(context) {
+        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
+    }
+    bundle.beta = function(beta2) {
+        return custom12(+beta2);
+    };
+    return bundle;
+}(0.85);
+
+// node_modules/d3-shape/src/curve/cardinal.js
+function point3(that, x7, y7) {
+    that._context.bezierCurveTo(
+        that._x1 + that._k * (that._x2 - that._x0),
+        that._y1 + that._k * (that._y2 - that._y0),
+        that._x2 + that._k * (that._x1 - x7),
+        that._y2 + that._k * (that._y1 - y7),
+        that._x2,
+        that._y2
+    );
+}
+
+function Cardinal(context, tension) {
+    this._context = context;
+    this._k = (1 - tension) / 6;
+}
+Cardinal.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 2:
+                this._context.lineTo(this._x2, this._y2);
+                break;
+            case 3:
+                point3(this, this._x1, this._y1);
+                break;
+        }
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+                this._x1 = x7, this._y1 = y7;
+                break;
+            case 2:
+                this._point = 3;
+            default:
+                point3(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var cardinal_default = function custom13(tension) {
+    function cardinal(context) {
+        return new Cardinal(context, tension);
+    }
+    cardinal.tension = function(tension2) {
+        return custom13(+tension2);
+    };
+    return cardinal;
+}(0);
+
+// node_modules/d3-shape/src/curve/cardinalClosed.js
+function CardinalClosed(context, tension) {
+    this._context = context;
+    this._k = (1 - tension) / 6;
+}
+CardinalClosed.prototype = {
+    areaStart: noop_default2,
+    areaEnd: noop_default2,
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 1: {
+                this._context.moveTo(this._x3, this._y3);
+                this._context.closePath();
+                break;
+            }
+            case 2: {
+                this._context.lineTo(this._x3, this._y3);
+                this._context.closePath();
+                break;
+            }
+            case 3: {
+                this.point(this._x3, this._y3);
+                this.point(this._x4, this._y4);
+                this.point(this._x5, this._y5);
+                break;
+            }
+        }
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._x3 = x7, this._y3 = y7;
+                break;
+            case 1:
+                this._point = 2;
+                this._context.moveTo(this._x4 = x7, this._y4 = y7);
+                break;
+            case 2:
+                this._point = 3;
+                this._x5 = x7, this._y5 = y7;
+                break;
+            default:
+                point3(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var cardinalClosed_default = function custom14(tension) {
+    function cardinal(context) {
+        return new CardinalClosed(context, tension);
+    }
+    cardinal.tension = function(tension2) {
+        return custom14(+tension2);
+    };
+    return cardinal;
+}(0);
+
+// node_modules/d3-shape/src/curve/cardinalOpen.js
+function CardinalOpen(context, tension) {
+    this._context = context;
+    this._k = (1 - tension) / 6;
+}
+CardinalOpen.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._line || this._line !== 0 && this._point === 3)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
+                break;
+            case 3:
+                this._point = 4;
+            default:
+                point3(this, x7, y7);
+                break;
+        }
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var cardinalOpen_default = function custom15(tension) {
+    function cardinal(context) {
+        return new CardinalOpen(context, tension);
+    }
+    cardinal.tension = function(tension2) {
+        return custom15(+tension2);
+    };
+    return cardinal;
+}(0);
+
+// node_modules/d3-shape/src/curve/catmullRom.js
+function point4(that, x7, y7) {
+    var x13 = that._x1,
+        y13 = that._y1,
+        x22 = that._x2,
+        y22 = that._y2;
+    if (that._l01_a > epsilon8) {
+        var a7 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
+            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
+        x13 = (x13 * a7 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
+        y13 = (y13 * a7 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
+    }
+    if (that._l23_a > epsilon8) {
+        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
+            m5 = 3 * that._l23_a * (that._l23_a + that._l12_a);
+        x22 = (x22 * b + that._x1 * that._l23_2a - x7 * that._l12_2a) / m5;
+        y22 = (y22 * b + that._y1 * that._l23_2a - y7 * that._l12_2a) / m5;
+    }
+    that._context.bezierCurveTo(x13, y13, x22, y22, that._x2, that._y2);
+}
+
+function CatmullRom(context, alpha) {
+    this._context = context;
+    this._alpha = alpha;
+}
+CatmullRom.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
+        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 2:
+                this._context.lineTo(this._x2, this._y2);
+                break;
+            case 3:
+                this.point(this._x2, this._y2);
+                break;
+        }
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        if (this._point) {
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
+        }
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+            default:
+                point4(this, x7, y7);
+                break;
+        }
+        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
+        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var catmullRom_default = function custom16(alpha) {
+    function catmullRom(context) {
+        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
+    }
+    catmullRom.alpha = function(alpha2) {
+        return custom16(+alpha2);
+    };
+    return catmullRom;
+}(0.5);
+
+// node_modules/d3-shape/src/curve/catmullRomClosed.js
+function CatmullRomClosed(context, alpha) {
+    this._context = context;
+    this._alpha = alpha;
+}
+CatmullRomClosed.prototype = {
+    areaStart: noop_default2,
+    areaEnd: noop_default2,
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
+        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 1: {
+                this._context.moveTo(this._x3, this._y3);
+                this._context.closePath();
+                break;
+            }
+            case 2: {
+                this._context.lineTo(this._x3, this._y3);
+                this._context.closePath();
+                break;
+            }
+            case 3: {
+                this.point(this._x3, this._y3);
+                this.point(this._x4, this._y4);
+                this.point(this._x5, this._y5);
+                break;
+            }
+        }
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        if (this._point) {
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
+        }
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._x3 = x7, this._y3 = y7;
+                break;
+            case 1:
+                this._point = 2;
+                this._context.moveTo(this._x4 = x7, this._y4 = y7);
+                break;
+            case 2:
+                this._point = 3;
+                this._x5 = x7, this._y5 = y7;
+                break;
+            default:
+                point4(this, x7, y7);
+                break;
+        }
+        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
+        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var catmullRomClosed_default = function custom17(alpha) {
+    function catmullRom(context) {
+        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
+    }
+    catmullRom.alpha = function(alpha2) {
+        return custom17(+alpha2);
+    };
+    return catmullRom;
+}(0.5);
+
+// node_modules/d3-shape/src/curve/catmullRomOpen.js
+function CatmullRomOpen(context, alpha) {
+    this._context = context;
+    this._alpha = alpha;
+}
+CatmullRomOpen.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
+        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._line || this._line !== 0 && this._point === 3)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        if (this._point) {
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
+        }
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
+                break;
+            case 3:
+                this._point = 4;
+            default:
+                point4(this, x7, y7);
+                break;
+        }
+        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
+        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
+    }
+};
+var catmullRomOpen_default = function custom18(alpha) {
+    function catmullRom(context) {
+        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
+    }
+    catmullRom.alpha = function(alpha2) {
+        return custom18(+alpha2);
+    };
+    return catmullRom;
+}(0.5);
+
+// node_modules/d3-shape/src/curve/linearClosed.js
+function LinearClosed(context) {
+    this._context = context;
+}
+LinearClosed.prototype = {
+    areaStart: noop_default2,
+    areaEnd: noop_default2,
+    lineStart: function() {
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (this._point)
+            this._context.closePath();
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        if (this._point)
+            this._context.lineTo(x7, y7);
+        else
+            this._point = 1, this._context.moveTo(x7, y7);
+    }
+};
+
+function linearClosed_default(context) {
+    return new LinearClosed(context);
+}
+
+// node_modules/d3-shape/src/curve/monotone.js
+function sign2(x7) {
+    return x7 < 0 ? -1 : 1;
+}
+
+function slope3(that, x22, y22) {
+    var h0 = that._x1 - that._x0,
+        h1 = x22 - that._x1,
+        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
+        s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0),
+        p = (s0 * h1 + s1 * h0) / (h0 + h1);
+    return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
+}
+
+function slope2(that, t) {
+    var h = that._x1 - that._x0;
+    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
+}
+
+function point5(that, t05, t15) {
+    var x011 = that._x0,
+        y011 = that._y0,
+        x13 = that._x1,
+        y13 = that._y1,
+        dx = (x13 - x011) / 3;
+    that._context.bezierCurveTo(x011 + dx, y011 + dx * t05, x13 - dx, y13 - dx * t15, x13, y13);
+}
+
+function MonotoneX(context) {
+    this._context = context;
+}
+MonotoneX.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        switch (this._point) {
+            case 2:
+                this._context.lineTo(this._x1, this._y1);
+                break;
+            case 3:
+                point5(this, this._t0, slope2(this, this._t0));
+                break;
+        }
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        var t15 = NaN;
+        x7 = +x7, y7 = +y7;
+        if (x7 === this._x1 && y7 === this._y1)
+            return;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+                break;
+            case 2:
+                this._point = 3;
+                point5(this, slope2(this, t15 = slope3(this, x7, y7)), t15);
+                break;
+            default:
+                point5(this, this._t0, t15 = slope3(this, x7, y7));
+                break;
+        }
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
+        this._t0 = t15;
+    }
+};
+
+function MonotoneY(context) {
+    this._context = new ReflectContext(context);
+}
+(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x7, y7) {
+    MonotoneX.prototype.point.call(this, y7, x7);
+};
+
+function ReflectContext(context) {
+    this._context = context;
+}
+ReflectContext.prototype = {
+    moveTo: function(x7, y7) {
+        this._context.moveTo(y7, x7);
+    },
+    closePath: function() {
+        this._context.closePath();
+    },
+    lineTo: function(x7, y7) {
+        this._context.lineTo(y7, x7);
+    },
+    bezierCurveTo: function(x13, y13, x22, y22, x7, y7) {
+        this._context.bezierCurveTo(y13, x13, y22, x22, y7, x7);
+    }
+};
+
+function monotoneX(context) {
+    return new MonotoneX(context);
+}
+
+function monotoneY(context) {
+    return new MonotoneY(context);
+}
+
+// node_modules/d3-shape/src/curve/natural.js
+function Natural(context) {
+    this._context = context;
+}
+Natural.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x = [];
+        this._y = [];
+    },
+    lineEnd: function() {
+        var x7 = this._x,
+            y7 = this._y,
+            n = x7.length;
+        if (n) {
+            this._line ? this._context.lineTo(x7[0], y7[0]) : this._context.moveTo(x7[0], y7[0]);
+            if (n === 2) {
+                this._context.lineTo(x7[1], y7[1]);
+            } else {
+                var px = controlPoints(x7),
+                    py = controlPoints(y7);
+                for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
+                    this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x7[i1], y7[i1]);
+                }
+            }
+        }
+        if (this._line || this._line !== 0 && n === 1)
+            this._context.closePath();
+        this._line = 1 - this._line;
+        this._x = this._y = null;
+    },
+    point: function(x7, y7) {
+        this._x.push(+x7);
+        this._y.push(+y7);
+    }
+};
+
+function controlPoints(x7) {
+    var i, n = x7.length - 1,
+        m5, a7 = new Array(n),
+        b = new Array(n),
+        r = new Array(n);
+    a7[0] = 0, b[0] = 2, r[0] = x7[0] + 2 * x7[1];
+    for (i = 1; i < n - 1; ++i)
+        a7[i] = 1, b[i] = 4, r[i] = 4 * x7[i] + 2 * x7[i + 1];
+    a7[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x7[n - 1] + x7[n];
+    for (i = 1; i < n; ++i)
+        m5 = a7[i] / b[i - 1], b[i] -= m5, r[i] -= m5 * r[i - 1];
+    a7[n - 1] = r[n - 1] / b[n - 1];
+    for (i = n - 2; i >= 0; --i)
+        a7[i] = (r[i] - a7[i + 1]) / b[i];
+    b[n - 1] = (x7[n] + a7[n - 1]) / 2;
+    for (i = 0; i < n - 1; ++i)
+        b[i] = 2 * x7[i + 1] - a7[i + 1];
+    return [a7, b];
+}
+
+function natural_default(context) {
+    return new Natural(context);
+}
+
+// node_modules/d3-shape/src/curve/step.js
+function Step(context, t) {
+    this._context = context;
+    this._t = t;
+}
+Step.prototype = {
+    areaStart: function() {
+        this._line = 0;
+    },
+    areaEnd: function() {
+        this._line = NaN;
+    },
+    lineStart: function() {
+        this._x = this._y = NaN;
+        this._point = 0;
+    },
+    lineEnd: function() {
+        if (0 < this._t && this._t < 1 && this._point === 2)
+            this._context.lineTo(this._x, this._y);
+        if (this._line || this._line !== 0 && this._point === 1)
+            this._context.closePath();
+        if (this._line >= 0)
+            this._t = 1 - this._t, this._line = 1 - this._line;
+    },
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
+        switch (this._point) {
+            case 0:
+                this._point = 1;
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
+                break;
+            case 1:
+                this._point = 2;
+            default: {
+                if (this._t <= 0) {
+                    this._context.lineTo(this._x, y7);
+                    this._context.lineTo(x7, y7);
+                } else {
+                    var x13 = this._x * (1 - this._t) + x7 * this._t;
+                    this._context.lineTo(x13, this._y);
+                    this._context.lineTo(x13, y7);
+                }
+                break;
+            }
+        }
+        this._x = x7, this._y = y7;
+    }
+};
+
+function step_default(context) {
+    return new Step(context, 0.5);
+}
+
+function stepBefore(context) {
+    return new Step(context, 0);
+}
+
+function stepAfter(context) {
+    return new Step(context, 1);
+}
+
+// node_modules/d3-shape/src/offset/none.js
+function none_default(series, order) {
+    if (!((n = series.length) > 1))
+        return;
+    for (var i = 1, j, s0, s1 = series[order[0]], n, m5 = s1.length; i < n; ++i) {
+        s0 = s1, s1 = series[order[i]];
+        for (j = 0; j < m5; ++j) {
+            s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
+        }
+    }
+}
+
+// node_modules/d3-shape/src/order/none.js
+function none_default2(series) {
+    var n = series.length,
+        o = new Array(n);
+    while (--n >= 0)
+        o[n] = n;
+    return o;
+}
+
+// node_modules/d3-shape/src/stack.js
+function stackValue(d, key) {
+    return d[key];
+}
+
+function stackSeries(key) {
+    const series = [];
+    series.key = key;
+    return series;
+}
+
+function stack_default() {
+    var keys = constant_default10([]),
+        order = none_default2,
+        offset3 = none_default,
+        value = stackValue;
+
+    function stack3(data) {
+        var sz = Array.from(keys.apply(this, arguments), stackSeries),
+            i, n = sz.length,
+            j = -1,
+            oz;
+        for (const d of data) {
+            for (i = 0, ++j; i < n; ++i) {
+                (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
+            }
+        }
+        for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {
+            sz[oz[i]].index = i;
+        }
+        offset3(sz, oz);
+        return sz;
+    }
+    stack3.keys = function(_) {
+        return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack3) : keys;
+    };
+    stack3.value = function(_) {
+        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), stack3) : value;
+    };
+    stack3.order = function(_) {
+        return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack3) : order;
+    };
+    stack3.offset = function(_) {
+        return arguments.length ? (offset3 = _ == null ? none_default : _, stack3) : offset3;
+    };
+    return stack3;
+}
+
+// node_modules/d3-shape/src/offset/expand.js
+function expand_default(series, order) {
+    if (!((n = series.length) > 0))
+        return;
+    for (var i, n, j = 0, m5 = series[0].length, y7; j < m5; ++j) {
+        for (y7 = i = 0; i < n; ++i)
+            y7 += series[i][j][1] || 0;
+        if (y7)
+            for (i = 0; i < n; ++i)
+                series[i][j][1] /= y7;
+    }
+    none_default(series, order);
+}
+
+// node_modules/d3-shape/src/offset/diverging.js
+function diverging_default(series, order) {
+    if (!((n = series.length) > 0))
+        return;
+    for (var i, j = 0, d, dy, yp, yn, n, m5 = series[order[0]].length; j < m5; ++j) {
+        for (yp = yn = 0, i = 0; i < n; ++i) {
+            if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
+                d[0] = yp, d[1] = yp += dy;
+            } else if (dy < 0) {
+                d[1] = yn, d[0] = yn += dy;
+            } else {
+                d[0] = 0, d[1] = dy;
+            }
+        }
+    }
+}
+
+// node_modules/d3-shape/src/offset/silhouette.js
+function silhouette_default(series, order) {
+    if (!((n = series.length) > 0))
+        return;
+    for (var j = 0, s0 = series[order[0]], n, m5 = s0.length; j < m5; ++j) {
+        for (var i = 0, y7 = 0; i < n; ++i)
+            y7 += series[i][j][1] || 0;
+        s0[j][1] += s0[j][0] = -y7 / 2;
+    }
+    none_default(series, order);
+}
+
+// node_modules/d3-shape/src/offset/wiggle.js
+function wiggle_default(series, order) {
+    if (!((n = series.length) > 0) || !((m5 = (s0 = series[order[0]]).length) > 0))
+        return;
+    for (var y7 = 0, j = 1, s0, m5, n; j < m5; ++j) {
+        for (var i = 0, s1 = 0, s22 = 0; i < n; ++i) {
+            var si = series[order[i]],
+                sij0 = si[j][1] || 0,
+                sij1 = si[j - 1][1] || 0,
+                s3 = (sij0 - sij1) / 2;
+            for (var k3 = 0; k3 < i; ++k3) {
+                var sk = series[order[k3]],
+                    skj0 = sk[j][1] || 0,
+                    skj1 = sk[j - 1][1] || 0;
+                s3 += skj0 - skj1;
+            }
+            s1 += sij0, s22 += s3 * sij0;
+        }
+        s0[j - 1][1] += s0[j - 1][0] = y7;
+        if (s1)
+            y7 -= s22 / s1;
+    }
+    s0[j - 1][1] += s0[j - 1][0] = y7;
+    none_default(series, order);
+}
+
+// node_modules/d3-shape/src/order/appearance.js
+function appearance_default(series) {
+    var peaks = series.map(peak);
+    return none_default2(series).sort(function(a7, b) {
+        return peaks[a7] - peaks[b];
+    });
+}
+
+function peak(series) {
+    var i = -1,
+        j = 0,
+        n = series.length,
+        vi, vj = -Infinity;
+    while (++i < n)
+        if ((vi = +series[i][1]) > vj)
+            vj = vi, j = i;
+    return j;
+}
+
+// node_modules/d3-shape/src/order/ascending.js
+function ascending_default2(series) {
+    var sums = series.map(sum3);
+    return none_default2(series).sort(function(a7, b) {
+        return sums[a7] - sums[b];
+    });
+}
+
+function sum3(series) {
+    var s3 = 0,
+        i = -1,
+        n = series.length,
+        v3;
+    while (++i < n)
+        if (v3 = +series[i][1])
+            s3 += v3;
+    return s3;
+}
+
+// node_modules/d3-shape/src/order/descending.js
+function descending_default2(series) {
+    return ascending_default2(series).reverse();
+}
+
+// node_modules/d3-shape/src/order/insideOut.js
+function insideOut_default(series) {
+    var n = series.length,
+        i, j, sums = series.map(sum3),
+        order = appearance_default(series),
+        top3 = 0,
+        bottom3 = 0,
+        tops = [],
+        bottoms = [];
+    for (i = 0; i < n; ++i) {
+        j = order[i];
+        if (top3 < bottom3) {
+            top3 += sums[j];
+            tops.push(j);
+        } else {
+            bottom3 += sums[j];
+            bottoms.push(j);
+        }
+    }
+    return bottoms.reverse().concat(tops);
+}
+
+// node_modules/d3-shape/src/order/reverse.js
+function reverse_default(series) {
+    return none_default2(series).reverse();
+}
+
+// node_modules/d3-zoom/src/constant.js
+var constant_default11 = (x7) => () => x7;
+
+// node_modules/d3-zoom/src/event.js
+function ZoomEvent(type3, {
+    sourceEvent,
+    target,
+    transform: transform3,
+    dispatch: dispatch3
+}) {
+    Object.defineProperties(this, {
+        type: {
+            value: type3,
+            enumerable: true,
+            configurable: true
+        },
+        sourceEvent: {
+            value: sourceEvent,
+            enumerable: true,
+            configurable: true
+        },
+        target: {
+            value: target,
+            enumerable: true,
+            configurable: true
+        },
+        transform: {
+            value: transform3,
+            enumerable: true,
+            configurable: true
+        },
+        _: {
+            value: dispatch3
+        }
+    });
+}
+
+// node_modules/d3-zoom/src/transform.js
+function Transform(k3, x7, y7) {
+    this.k = k3;
+    this.x = x7;
+    this.y = y7;
+}
+Transform.prototype = {
+    constructor: Transform,
+    scale: function(k3) {
+        return k3 === 1 ? this : new Transform(this.k * k3, this.x, this.y);
+    },
+    translate: function(x7, y7) {
+        return x7 === 0 & y7 === 0 ? this : new Transform(this.k, this.x + this.k * x7, this.y + this.k * y7);
+    },
+    apply: function(point11) {
+        return [point11[0] * this.k + this.x, point11[1] * this.k + this.y];
+    },
+    applyX: function(x7) {
+        return x7 * this.k + this.x;
+    },
+    applyY: function(y7) {
+        return y7 * this.k + this.y;
+    },
+    invert: function(location) {
+        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
+    },
+    invertX: function(x7) {
+        return (x7 - this.x) / this.k;
+    },
+    invertY: function(y7) {
+        return (y7 - this.y) / this.k;
+    },
+    rescaleX: function(x7) {
+        return x7.copy().domain(x7.range().map(this.invertX, this).map(x7.invert, x7));
+    },
+    rescaleY: function(y7) {
+        return y7.copy().domain(y7.range().map(this.invertY, this).map(y7.invert, y7));
+    },
+    toString: function() {
+        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
+    }
+};
+var identity5 = new Transform(1, 0, 0);
+transform.prototype = Transform.prototype;
+
+function transform(node) {
+    while (!node.__zoom)
+        if (!(node = node.parentNode))
+            return identity5;
+    return node.__zoom;
+}
+
+// node_modules/d3-zoom/src/noevent.js
+function nopropagation3(event) {
+    event.stopImmediatePropagation();
+}
+
+function noevent_default3(event) {
+    event.preventDefault();
+    event.stopImmediatePropagation();
+}
+
+// node_modules/d3-zoom/src/zoom.js
+function defaultFilter3(event) {
+    return (!event.ctrlKey || event.type === "wheel") && !event.button;
+}
+
+function defaultExtent2() {
+    var e = this;
+    if (e instanceof SVGElement) {
+        e = e.ownerSVGElement || e;
+        if (e.hasAttribute("viewBox")) {
+            e = e.viewBox.baseVal;
+            return [
+                [e.x, e.y],
+                [e.x + e.width, e.y + e.height]
+            ];
+        }
+        return [
+            [0, 0],
+            [e.width.baseVal.value, e.height.baseVal.value]
+        ];
+    }
+    return [
+        [0, 0],
+        [e.clientWidth, e.clientHeight]
+    ];
+}
+
+function defaultTransform() {
+    return this.__zoom || identity5;
+}
+
+function defaultWheelDelta(event) {
+    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
+}
+
+function defaultTouchable3() {
+    return navigator.maxTouchPoints || "ontouchstart" in this;
+}
+
+function defaultConstrain(transform3, extent5, translateExtent) {
+    var dx0 = transform3.invertX(extent5[0][0]) - translateExtent[0][0],
+        dx1 = transform3.invertX(extent5[1][0]) - translateExtent[1][0],
+        dy0 = transform3.invertY(extent5[0][1]) - translateExtent[0][1],
+        dy1 = transform3.invertY(extent5[1][1]) - translateExtent[1][1];
+    return transform3.translate(
+        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
+        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
+    );
+}
+
+function zoom_default2() {
+    var filter7 = defaultFilter3,
+        extent5 = defaultExtent2,
+        constrain = defaultConstrain,
+        wheelDelta = defaultWheelDelta,
+        touchable = defaultTouchable3,
+        scaleExtent = [0, Infinity],
+        translateExtent = [
+            [-Infinity, -Infinity],
+            [Infinity, Infinity]
+        ],
+        duration = 250,
+        interpolate = zoom_default,
+        listeners = dispatch_default("start", "zoom", "end"),
+        touchstarting, touchfirst, touchending, touchDelay = 500,
+        wheelDelay = 150,
+        clickDistance2 = 0,
+        tapDistance = 10;
+
+    function zoom(selection3) {
+        selection3.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
+            passive: false
+        }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+    }
+    zoom.transform = function(collection, transform3, point11, event) {
+        var selection3 = collection.selection ? collection.selection() : collection;
+        selection3.property("__zoom", defaultTransform);
+        if (collection !== selection3) {
+            schedule(collection, transform3, point11, event);
+        } else {
+            selection3.interrupt().each(function() {
+                gesture(this, arguments).event(event).start().zoom(null, typeof transform3 === "function" ? transform3.apply(this, arguments) : transform3).end();
+            });
+        }
+    };
+    zoom.scaleBy = function(selection3, k3, p, event) {
+        zoom.scaleTo(selection3, function() {
+            var k0 = this.__zoom.k,
+                k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
+            return k0 * k1;
+        }, p, event);
+    };
+    zoom.scaleTo = function(selection3, k3, p, event) {
+        zoom.transform(selection3, function() {
+            var e = extent5.apply(this, arguments),
+                t05 = this.__zoom,
+                p03 = p == null ? centroid3(e) : typeof p === "function" ? p.apply(this, arguments) : p,
+                p1 = t05.invert(p03),
+                k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
+            return constrain(translate(scale5(t05, k1), p03, p1), e, translateExtent);
+        }, p, event);
+    };
+    zoom.translateBy = function(selection3, x7, y7, event) {
+        zoom.transform(selection3, function() {
+            return constrain(this.__zoom.translate(
+                typeof x7 === "function" ? x7.apply(this, arguments) : x7,
+                typeof y7 === "function" ? y7.apply(this, arguments) : y7
+            ), extent5.apply(this, arguments), translateExtent);
+        }, null, event);
+    };
+    zoom.translateTo = function(selection3, x7, y7, p, event) {
+        zoom.transform(selection3, function() {
+            var e = extent5.apply(this, arguments),
+                t = this.__zoom,
+                p03 = p == null ? centroid3(e) : typeof p === "function" ? p.apply(this, arguments) : p;
+            return constrain(identity5.translate(p03[0], p03[1]).scale(t.k).translate(
+                typeof x7 === "function" ? -x7.apply(this, arguments) : -x7,
+                typeof y7 === "function" ? -y7.apply(this, arguments) : -y7
+            ), e, translateExtent);
+        }, p, event);
+    };
+
+    function scale5(transform3, k3) {
+        k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k3));
+        return k3 === transform3.k ? transform3 : new Transform(k3, transform3.x, transform3.y);
+    }
+
+    function translate(transform3, p03, p1) {
+        var x7 = p03[0] - p1[0] * transform3.k,
+            y7 = p03[1] - p1[1] * transform3.k;
+        return x7 === transform3.x && y7 === transform3.y ? transform3 : new Transform(transform3.k, x7, y7);
+    }
+
+    function centroid3(extent6) {
+        return [(+extent6[0][0] + +extent6[1][0]) / 2, (+extent6[0][1] + +extent6[1][1]) / 2];
+    }
+
+    function schedule(transition3, transform3, point11, event) {
+        transition3.on("start.zoom", function() {
+            gesture(this, arguments).event(event).start();
+        }).on("interrupt.zoom end.zoom", function() {
+            gesture(this, arguments).event(event).end();
+        }).tween("zoom", function() {
+            var that = this,
+                args = arguments,
+                g = gesture(that, args).event(event),
+                e = extent5.apply(that, args),
+                p = point11 == null ? centroid3(e) : typeof point11 === "function" ? point11.apply(that, args) : point11,
+                w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
+                a7 = that.__zoom,
+                b = typeof transform3 === "function" ? transform3.apply(that, args) : transform3,
+                i = interpolate(a7.invert(p).concat(w / a7.k), b.invert(p).concat(w / b.k));
+            return function(t) {
+                if (t === 1)
+                    t = b;
+                else {
+                    var l = i(t),
+                        k3 = w / l[2];
+                    t = new Transform(k3, p[0] - l[0] * k3, p[1] - l[1] * k3);
+                }
+                g.zoom(null, t);
+            };
+        });
+    }
+
+    function gesture(that, args, clean) {
+        return !clean && that.__zooming || new Gesture(that, args);
+    }
+
+    function Gesture(that, args) {
+        this.that = that;
+        this.args = args;
+        this.active = 0;
+        this.sourceEvent = null;
+        this.extent = extent5.apply(that, args);
+        this.taps = 0;
+    }
+    Gesture.prototype = {
+        event: function(event) {
+            if (event)
+                this.sourceEvent = event;
+            return this;
+        },
+        start: function() {
+            if (++this.active === 1) {
+                this.that.__zooming = this;
+                this.emit("start");
+            }
+            return this;
+        },
+        zoom: function(key, transform3) {
+            if (this.mouse && key !== "mouse")
+                this.mouse[1] = transform3.invert(this.mouse[0]);
+            if (this.touch0 && key !== "touch")
+                this.touch0[1] = transform3.invert(this.touch0[0]);
+            if (this.touch1 && key !== "touch")
+                this.touch1[1] = transform3.invert(this.touch1[0]);
+            this.that.__zoom = transform3;
+            this.emit("zoom");
+            return this;
+        },
+        end: function() {
+            if (--this.active === 0) {
+                delete this.that.__zooming;
+                this.emit("end");
+            }
+            return this;
+        },
+        emit: function(type3) {
+            var d = select_default2(this.that).datum();
+            listeners.call(
+                type3,
+                this.that,
+                new ZoomEvent(type3, {
+                    sourceEvent: this.sourceEvent,
+                    target: zoom,
+                    type: type3,
+                    transform: this.that.__zoom,
+                    dispatch: listeners
+                }),
+                d
+            );
+        }
+    };
+
+    function wheeled(event, ...args) {
+        if (!filter7.apply(this, arguments))
+            return;
+        var g = gesture(this, args).event(event),
+            t = this.__zoom,
+            k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
+            p = pointer_default(event);
+        if (g.wheel) {
+            if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
+                g.mouse[1] = t.invert(g.mouse[0] = p);
+            }
+            clearTimeout(g.wheel);
+        } else if (t.k === k3)
+            return;
+        else {
+            g.mouse = [p, t.invert(p)];
+            interrupt_default(this);
+            g.start();
+        }
+        noevent_default3(event);
+        g.wheel = setTimeout(wheelidled, wheelDelay);
+        g.zoom("mouse", constrain(translate(scale5(t, k3), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
+
+        function wheelidled() {
+            g.wheel = null;
+            g.end();
+        }
+    }
+
+    function mousedowned(event, ...args) {
+        if (touchending || !filter7.apply(this, arguments))
+            return;
+        var currentTarget = event.currentTarget,
+            g = gesture(this, args, true).event(event),
+            v3 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
+            p = pointer_default(event, currentTarget),
+            x011 = event.clientX,
+            y011 = event.clientY;
+        nodrag_default(event.view);
+        nopropagation3(event);
+        g.mouse = [p, this.__zoom.invert(p)];
+        interrupt_default(this);
+        g.start();
+
+        function mousemoved(event2) {
+            noevent_default3(event2);
+            if (!g.moved) {
+                var dx = event2.clientX - x011,
+                    dy = event2.clientY - y011;
+                g.moved = dx * dx + dy * dy > clickDistance2;
+            }
+            g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
+        }
+
+        function mouseupped(event2) {
+            v3.on("mousemove.zoom mouseup.zoom", null);
+            yesdrag(event2.view, g.moved);
+            noevent_default3(event2);
+            g.event(event2).end();
+        }
+    }
+
+    function dblclicked(event, ...args) {
+        if (!filter7.apply(this, arguments))
+            return;
+        var t05 = this.__zoom,
+            p03 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this),
+            p1 = t05.invert(p03),
+            k1 = t05.k * (event.shiftKey ? 0.5 : 2),
+            t15 = constrain(translate(scale5(t05, k1), p03, p1), extent5.apply(this, args), translateExtent);
+        noevent_default3(event);
+        if (duration > 0)
+            select_default2(this).transition().duration(duration).call(schedule, t15, p03, event);
+        else
+            select_default2(this).call(zoom.transform, t15, p03, event);
+    }
+
+    function touchstarted(event, ...args) {
+        if (!filter7.apply(this, arguments))
+            return;
+        var touches = event.touches,
+            n = touches.length,
+            g = gesture(this, args, event.changedTouches.length === n).event(event),
+            started, i, t, p;
+        nopropagation3(event);
+        for (i = 0; i < n; ++i) {
+            t = touches[i], p = pointer_default(t, this);
+            p = [p, this.__zoom.invert(p), t.identifier];
+            if (!g.touch0)
+                g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
+            else if (!g.touch1 && g.touch0[2] !== p[2])
+                g.touch1 = p, g.taps = 0;
+        }
+        if (touchstarting)
+            touchstarting = clearTimeout(touchstarting);
+        if (started) {
+            if (g.taps < 2)
+                touchfirst = p[0], touchstarting = setTimeout(function() {
+                    touchstarting = null;
+                }, touchDelay);
+            interrupt_default(this);
+            g.start();
+        }
+    }
+
+    function touchmoved(event, ...args) {
+        if (!this.__zooming)
+            return;
+        var g = gesture(this, args).event(event),
+            touches = event.changedTouches,
+            n = touches.length,
+            i, t, p, l;
+        noevent_default3(event);
+        for (i = 0; i < n; ++i) {
+            t = touches[i], p = pointer_default(t, this);
+            if (g.touch0 && g.touch0[2] === t.identifier)
+                g.touch0[0] = p;
+            else if (g.touch1 && g.touch1[2] === t.identifier)
+                g.touch1[0] = p;
+        }
+        t = g.that.__zoom;
+        if (g.touch1) {
+            var p03 = g.touch0[0],
+                l0 = g.touch0[1],
+                p1 = g.touch1[0],
+                l1 = g.touch1[1],
+                dp = (dp = p1[0] - p03[0]) * dp + (dp = p1[1] - p03[1]) * dp,
+                dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
+            t = scale5(t, Math.sqrt(dp / dl));
+            p = [(p03[0] + p1[0]) / 2, (p03[1] + p1[1]) / 2];
+            l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
+        } else if (g.touch0)
+            p = g.touch0[0], l = g.touch0[1];
+        else
+            return;
+        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
+    }
+
+    function touchended(event, ...args) {
+        if (!this.__zooming)
+            return;
+        var g = gesture(this, args).event(event),
+            touches = event.changedTouches,
+            n = touches.length,
+            i, t;
+        nopropagation3(event);
+        if (touchending)
+            clearTimeout(touchending);
+        touchending = setTimeout(function() {
+            touchending = null;
+        }, touchDelay);
+        for (i = 0; i < n; ++i) {
+            t = touches[i];
+            if (g.touch0 && g.touch0[2] === t.identifier)
+                delete g.touch0;
+            else if (g.touch1 && g.touch1[2] === t.identifier)
+                delete g.touch1;
+        }
+        if (g.touch1 && !g.touch0)
+            g.touch0 = g.touch1, delete g.touch1;
+        if (g.touch0)
+            g.touch0[1] = this.__zoom.invert(g.touch0[0]);
+        else {
+            g.end();
+            if (g.taps === 2) {
+                t = pointer_default(t, this);
+                if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
+                    var p = select_default2(this).on("dblclick.zoom");
+                    if (p)
+                        p.apply(this, arguments);
+                }
+            }
+        }
+    }
+    zoom.wheelDelta = function(_) {
+        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default11(+_), zoom) : wheelDelta;
+    };
+    zoom.filter = function(_) {
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : filter7;
+    };
+    zoom.touchable = function(_) {
+        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : touchable;
+    };
+    zoom.extent = function(_) {
+        return arguments.length ? (extent5 = typeof _ === "function" ? _ : constant_default11([
+            [+_[0][0], +_[0][1]],
+            [+_[1][0], +_[1][1]]
+        ]), zoom) : extent5;
+    };
+    zoom.scaleExtent = function(_) {
+        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
+    };
+    zoom.translateExtent = function(_) {
+        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [
+            [translateExtent[0][0], translateExtent[0][1]],
+            [translateExtent[1][0], translateExtent[1][1]]
+        ];
+    };
+    zoom.constrain = function(_) {
+        return arguments.length ? (constrain = _, zoom) : constrain;
+    };
+    zoom.duration = function(_) {
+        return arguments.length ? (duration = +_, zoom) : duration;
+    };
+    zoom.interpolate = function(_) {
+        return arguments.length ? (interpolate = _, zoom) : interpolate;
+    };
+    zoom.on = function() {
+        var value = listeners.on.apply(listeners, arguments);
+        return value === listeners ? zoom : value;
+    };
+    zoom.clickDistance = function(_) {
+        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
+    };
+    zoom.tapDistance = function(_) {
+        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
+    };
+    return zoom;
+}
+
+// node_modules/@observablehq/plot/src/defined.js
+function defined(x7) {
+    return x7 != null && !Number.isNaN(x7);
+}
+
+function ascendingDefined2(a7, b) {
+    return +defined(b) - +defined(a7) || ascending(a7, b);
+}
+
+function descendingDefined(a7, b) {
+    return +defined(b) - +defined(a7) || descending(a7, b);
+}
+
+function nonempty(x7) {
+    return x7 != null && `${x7}` !== "";
+}
+
+function finite2(x7) {
+    return isFinite(x7) ? x7 : NaN;
+}
+
+function positive(x7) {
+    return x7 > 0 && isFinite(x7) ? x7 : NaN;
+}
+
+function negative(x7) {
+    return x7 < 0 && isFinite(x7) ? x7 : NaN;
+}
+
+// node_modules/isoformat/src/format.js
+function format2(date3, fallback) {
+    if (!(date3 instanceof Date))
+        date3 = /* @__PURE__ */ new Date(+date3);
+    if (isNaN(date3))
+        return typeof fallback === "function" ? fallback(date3) : fallback;
+    const hours = date3.getUTCHours();
+    const minutes = date3.getUTCMinutes();
+    const seconds3 = date3.getUTCSeconds();
+    const milliseconds3 = date3.getUTCMilliseconds();
+    return `${formatYear3(date3.getUTCFullYear(), 4)}-${pad3(date3.getUTCMonth() + 1, 2)}-${pad3(date3.getUTCDate(), 2)}${hours || minutes || seconds3 || milliseconds3 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds3 || milliseconds3 ? `:${pad3(seconds3, 2)}${milliseconds3 ? `.${pad3(milliseconds3, 3)}` : ``}` : ``}Z` : ``}`;
+}
+
+function formatYear3(year) {
+    return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);
+}
+
+function pad3(value, width) {
+    return `${value}`.padStart(width, "0");
+}
+
+// node_modules/isoformat/src/parse.js
+var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
+
+function parse(string3, fallback) {
+    if (!re2.test(string3 += ""))
+        return typeof fallback === "function" ? fallback(string3) : fallback;
+    return new Date(string3);
+}
+
+// node_modules/@observablehq/plot/src/time.js
+var timeIntervals = /* @__PURE__ */ new Map([
+    ["second", second],
+    ["minute", timeMinute],
+    ["hour", timeHour],
+    ["day", timeDay],
+    ["week", timeSunday],
+    ["month", timeMonth],
+    ["quarter", timeMonth.every(3)],
+    ["half", timeMonth.every(6)],
+    ["year", timeYear],
+    ["monday", timeMonday],
+    ["tuesday", timeTuesday],
+    ["wednesday", timeWednesday],
+    ["thursday", timeThursday],
+    ["friday", timeFriday],
+    ["saturday", timeSaturday],
+    ["sunday", timeSunday]
+]);
+var utcIntervals = /* @__PURE__ */ new Map([
+    ["second", second],
+    ["minute", utcMinute],
+    ["hour", utcHour],
+    ["day", utcDay],
+    ["week", utcSunday],
+    ["month", utcMonth],
+    ["quarter", utcMonth.every(3)],
+    ["half", utcMonth.every(6)],
+    ["year", utcYear],
+    ["monday", utcMonday],
+    ["tuesday", utcTuesday],
+    ["wednesday", utcWednesday],
+    ["thursday", utcThursday],
+    ["friday", utcFriday],
+    ["saturday", utcSaturday],
+    ["sunday", utcSunday]
+]);
+
+function maybeTimeInterval(interval3) {
+    const i = timeIntervals.get(`${interval3}`.toLowerCase());
+    if (!i)
+        throw new Error(`unknown interval: ${interval3}`);
+    return i;
+}
+
+function maybeUtcInterval(interval3) {
+    const i = utcIntervals.get(`${interval3}`.toLowerCase());
+    if (!i)
+        throw new Error(`unknown interval: ${interval3}`);
+    return i;
+}
+
+// node_modules/@observablehq/plot/src/options.js
+var TypedArray = Object.getPrototypeOf(Uint8Array);
+var objectToString = Object.prototype.toString;
+
+function valueof(data, value, type3) {
+    const valueType = typeof value;
+    return valueType === "string" ? maybeTypedMap(data, field(value), type3) : valueType === "function" ? maybeTypedMap(data, value, type3) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map4(data, constant2(value), type3) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type3) : maybeTypedArrayify(value, type3);
+}
+
+function maybeTypedMap(data, f, type3) {
+    return map4(data, type3?.prototype instanceof TypedArray ? floater(f) : f, type3);
+}
+
+function maybeTypedArrayify(data, type3) {
+    return type3 === void 0 ? arrayify2(data) : data instanceof type3 ? data : type3.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type3.from(data, coerceNumber) : type3.from(data);
+}
+
+function floater(f) {
+    return (d, i) => coerceNumber(f(d, i));
+}
+var field = (name) => (d) => d[name];
+var indexOf = (d, i) => i;
+var identity6 = {
+    transform: (d) => d
+};
+var one2 = () => 1;
+var yes = () => true;
+var string = (x7) => x7 == null ? x7 : `${x7}`;
+var number5 = (x7) => x7 == null ? x7 : +x7;
+var first = (x7) => x7 ? x7[0] : void 0;
+var second2 = (x7) => x7 ? x7[1] : void 0;
+var third = (x7) => x7 ? x7[2] : void 0;
+var constant2 = (x7) => () => x7;
+
+function percentile(reduce3) {
+    const p = +`${reduce3}`.slice(1) / 100;
+    return (I, f) => quantile(I, p, f);
+}
+
+function coerceNumbers(values3) {
+    return values3 instanceof TypedArray ? values3 : map4(values3, coerceNumber, Float64Array);
+}
+
+function coerceNumber(x7) {
+    return x7 == null ? NaN : Number(x7);
+}
+
+function coerceDates(values3) {
+    return map4(values3, coerceDate);
+}
+
+function coerceDate(x7) {
+    return x7 instanceof Date && !isNaN(x7) ? x7 : typeof x7 === "string" ? parse(x7) : x7 == null || isNaN(x7 = +x7) ? void 0 : new Date(x7);
+}
+
+function maybeColorChannel(value, defaultValue) {
+    if (value === void 0)
+        value = defaultValue;
+    return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
+}
+
+function maybeNumberChannel(value, defaultValue) {
+    if (value === void 0)
+        value = defaultValue;
+    return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
+}
+
+function maybeKeyword(input, name, allowed) {
+    if (input != null)
+        return keyword(input, name, allowed);
+}
+
+function keyword(input, name, allowed) {
+    const i = `${input}`.toLowerCase();
+    if (!allowed.includes(i))
+        throw new Error(`invalid ${name}: ${input}`);
+    return i;
+}
+
+function arrayify2(data) {
+    return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
+}
+
+function map4(values3, f, type3 = Array) {
+    return values3 == null ? values3 : values3 instanceof type3 ? values3.map(f) : type3.from(values3, f);
+}
+
+function slice5(values3, type3 = Array) {
+    return values3 instanceof type3 ? values3.slice() : type3.from(values3);
+}
+
+function isObject(option) {
+    return option?.toString === objectToString;
+}
+
+function isScaleOptions(option) {
+    return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
+}
+
+function isOptions(option) {
+    return isObject(option) && typeof option.transform !== "function";
+}
+
+function isDomainSort(sort5) {
+    return isOptions(sort5) && sort5.value === void 0 && sort5.channel === void 0;
+}
+
+function maybeZero(x7, x13, x22, x32 = identity6) {
+    if (x13 === void 0 && x22 === void 0) {
+        x13 = 0, x22 = x7 === void 0 ? x32 : x7;
+    } else if (x13 === void 0) {
+        x13 = x7 === void 0 ? 0 : x7;
+    } else if (x22 === void 0) {
+        x22 = x7 === void 0 ? 0 : x7;
+    }
+    return [x13, x22];
+}
+
+function maybeTuple(x7, y7) {
+    return x7 === void 0 && y7 === void 0 ? [first, second2] : [x7, y7];
+}
+
+function maybeZ({
+    z,
+    fill,
+    stroke
+} = {}) {
+    if (z === void 0)
+        [z] = maybeColorChannel(fill);
+    if (z === void 0)
+        [z] = maybeColorChannel(stroke);
+    return z;
+}
+
+function range4(data) {
+    const n = data.length;
+    const r = new Uint32Array(n);
+    for (let i = 0; i < n; ++i)
+        r[i] = i;
+    return r;
+}
+
+function take(values3, index5) {
+    return map4(index5, (i) => values3[i]);
+}
+
+function keyof2(value) {
+    return value !== null && typeof value === "object" ? value.valueOf() : value;
+}
+
+function maybeInput(key, options) {
+    if (options[key] !== void 0)
+        return options[key];
+    switch (key) {
+        case "x1":
+        case "x2":
+            key = "x";
+            break;
+        case "y1":
+        case "y2":
+            key = "y";
+            break;
+    }
+    return options[key];
+}
+
+function column(source) {
+    let value;
+    return [{
+            transform: () => value,
+            label: labelof(source)
+        },
+        (v3) => value = v3
+    ];
+}
+
+function maybeColumn(source) {
+    return source == null ? [source] : column(source);
+}
+
+function labelof(value, defaultValue) {
+    return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
+}
+
+function mid(x13, x22) {
+    return {
+        transform(data) {
+            const X15 = x13.transform(data);
+            const X25 = x22.transform(data);
+            return isTemporal(X15) || isTemporal(X25) ? map4(X15, (_, i) => new Date((+X15[i] + +X25[i]) / 2)) : map4(X15, (_, i) => (+X15[i] + +X25[i]) / 2, Float64Array);
+        },
+        label: x13.label
+    };
+}
+
+function maybeInterval(interval3, type3) {
+    if (interval3 == null)
+        return;
+    if (typeof interval3 === "number") {
+        const n = interval3;
+        return {
+            floor: (d) => n * Math.floor(d / n),
+            offset: (d) => d + n,
+            // note: no optional step for simplicity
+            range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x7) => n * x7)
+        };
+    }
+    if (typeof interval3 === "string")
+        return (type3 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval3);
+    if (typeof interval3.floor !== "function")
+        throw new Error("invalid interval; missing floor method");
+    if (typeof interval3.offset !== "function")
+        throw new Error("invalid interval; missing offset method");
+    return interval3;
+}
+
+function maybeRangeInterval(interval3, type3) {
+    interval3 = maybeInterval(interval3, type3);
+    if (interval3 && typeof interval3.range !== "function")
+        throw new Error("invalid interval: missing range method");
+    return interval3;
+}
+
+function maybeNiceInterval(interval3, type3) {
+    interval3 = maybeRangeInterval(interval3, type3);
+    if (interval3 && typeof interval3.ceil !== "function")
+        throw new Error("invalid interval: missing ceil method");
+    return interval3;
+}
+
+function maybeValue(value) {
+    return value === void 0 || isOptions(value) ? value : {
+        value
+    };
+}
+
+function numberChannel(source) {
+    return source == null ? null : {
+        transform: (data) => valueof(data, source, Float64Array),
+        label: labelof(source)
+    };
+}
+
+function isTuples(data) {
+    if (!isIterable(data))
+        return false;
+    for (const d of data) {
+        if (d == null)
+            continue;
+        return typeof d === "object" && "0" in d && "1" in d;
+    }
+}
+
+function isIterable(value) {
+    return value && typeof value[Symbol.iterator] === "function";
+}
+
+function isTextual(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        return typeof value !== "object" || value instanceof Date;
+    }
+}
+
+function isOrdinal(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        const type3 = typeof value;
+        return type3 === "string" || type3 === "boolean";
+    }
+}
+
+function isTemporal(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        return value instanceof Date;
+    }
+}
+
+function isTemporalString(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        return typeof value === "string" && isNaN(value) && parse(value);
+    }
+}
+
+function isNumericString(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        if (typeof value !== "string")
+            return false;
+        if (!value.trim())
+            continue;
+        return !isNaN(value);
+    }
+}
+
+function isNumeric(values3) {
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        return typeof value === "number";
+    }
+}
+
+function isEvery(values3, is) {
+    let every3;
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        if (!is(value))
+            return false;
+        every3 = true;
+    }
+    return every3;
+}
+
+function isColor(value) {
+    if (typeof value !== "string")
+        return false;
+    value = value.toLowerCase().trim();
+    return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || // <funciri>, e.g. pattern or gradient
+        value.startsWith("var(") && value.endsWith(")") || // CSS variable
+        color(value) !== null;
+}
+
+function isOpacity(value) {
+    return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
+}
+
+function isNoneish(value) {
+    return value == null || isNone(value);
+}
+
+function isNone(value) {
+    return /^\s*none\s*$/i.test(value);
+}
+
+function isRound(value) {
+    return /^\s*round\s*$/i.test(value);
+}
+
+function maybeFrameAnchor(value = "middle") {
+    return keyword(value, "frameAnchor", [
+        "middle",
+        "top-left",
+        "top",
+        "top-right",
+        "right",
+        "bottom-right",
+        "bottom",
+        "bottom-left",
+        "left"
+    ]);
+}
+
+function orderof(values3) {
+    if (values3 == null)
+        return;
+    const first3 = values3[0];
+    const last = values3[values3.length - 1];
+    return descending(first3, last);
+}
+
+function inherit2(options = {}, ...rest) {
+    let o = options;
+    for (const defaults41 of rest) {
+        for (const key in defaults41) {
+            if (o[key] === void 0) {
+                const value = defaults41[key];
+                if (o === options)
+                    o = {
+                        ...o,
+                        [key]: value
+                    };
+                else
+                    o[key] = value;
+            }
+        }
+    }
+    return o;
+}
+
+function named2(things) {
+    console.warn("named iterables are deprecated; please use an object instead");
+    const names = /* @__PURE__ */ new Set();
+    return Object.fromEntries(
+        Array.from(things, (thing) => {
+            const {
+                name
+            } = thing;
+            if (name == null)
+                throw new Error("missing name");
+            const key = `${name}`;
+            if (key === "__proto__")
+                throw new Error(`illegal name: ${key}`);
+            if (names.has(key))
+                throw new Error(`duplicate name: ${key}`);
+            names.add(key);
+            return [name, thing];
+        })
+    );
+}
+
+function maybeNamed(things) {
+    return isIterable(things) ? named2(things) : things;
+}
+
+// node_modules/@observablehq/plot/src/scales/index.js
+var position = Symbol("position");
+var color2 = Symbol("color");
+var radius = Symbol("radius");
+var length3 = Symbol("length");
+var opacity = Symbol("opacity");
+var symbol = Symbol("symbol");
+var registry = /* @__PURE__ */ new Map([
+    ["x", position],
+    ["y", position],
+    ["fx", position],
+    ["fy", position],
+    ["r", radius],
+    ["color", color2],
+    ["opacity", opacity],
+    ["symbol", symbol],
+    ["length", length3]
+]);
+
+// node_modules/@observablehq/plot/src/symbol.js
+var sqrt35 = Math.sqrt(3);
+var sqrt4_3 = 2 / sqrt35;
+var symbolHexagon = {
+    draw(context, size) {
+        const rx = Math.sqrt(size / Math.PI),
+            ry = rx * sqrt4_3,
+            hy = ry / 2;
+        context.moveTo(0, ry);
+        context.lineTo(rx, hy);
+        context.lineTo(rx, -hy);
+        context.lineTo(0, -ry);
+        context.lineTo(-rx, -hy);
+        context.lineTo(-rx, hy);
+        context.closePath();
+    }
+};
+var symbols = /* @__PURE__ */ new Map([
+    ["asterisk", asterisk_default],
+    ["circle", circle_default3],
+    ["cross", cross_default2],
+    ["diamond", diamond_default],
+    ["diamond2", diamond2_default],
+    ["hexagon", symbolHexagon],
+    ["plus", plus_default],
+    ["square", square_default],
+    ["square2", square2_default],
+    ["star", star_default],
+    ["times", times_default],
+    ["triangle", triangle_default],
+    ["triangle2", triangle2_default],
+    ["wye", wye_default]
+]);
+
+function isSymbolObject(value) {
+    return value && typeof value.draw === "function";
+}
+
+function isSymbol(value) {
+    if (isSymbolObject(value))
+        return true;
+    if (typeof value !== "string")
+        return false;
+    return symbols.has(value.toLowerCase());
+}
+
+function maybeSymbol(symbol3) {
+    if (symbol3 == null || isSymbolObject(symbol3))
+        return symbol3;
+    const value = symbols.get(`${symbol3}`.toLowerCase());
+    if (value)
+        return value;
+    throw new Error(`invalid symbol: ${symbol3}`);
+}
+
+function maybeSymbolChannel(symbol3) {
+    if (symbol3 == null || isSymbolObject(symbol3))
+        return [void 0, symbol3];
+    if (typeof symbol3 === "string") {
+        const value = symbols.get(`${symbol3}`.toLowerCase());
+        if (value)
+            return [void 0, value];
+    }
+    return [symbol3, void 0];
+}
+
+// node_modules/@observablehq/plot/src/transforms/basic.js
+function basic({
+    filter: f1,
+    sort: s1,
+    reverse: r1,
+    transform: t15,
+    initializer: i1,
+    ...options
+} = {}, transform3) {
+    if (t15 === void 0) {
+        if (f1 != null)
+            t15 = filterTransform(f1);
+        if (s1 != null && !isDomainSort(s1))
+            t15 = composeTransform(t15, sortTransform(s1));
+        if (r1)
+            t15 = composeTransform(t15, reverseTransform);
+    }
+    if (transform3 != null && i1 != null)
+        throw new Error("transforms cannot be applied after initializers");
+    return {
+        ...options,
+        ...(s1 === null || isDomainSort(s1)) && {
+            sort: s1
+        },
+        transform: composeTransform(t15, transform3)
+    };
+}
+
+function initializer({
+    filter: f1,
+    sort: s1,
+    reverse: r1,
+    initializer: i1,
+    ...options
+} = {}, initializer3) {
+    if (i1 === void 0) {
+        if (f1 != null)
+            i1 = filterTransform(f1);
+        if (s1 != null && !isDomainSort(s1))
+            i1 = composeInitializer(i1, sortTransform(s1));
+        if (r1)
+            i1 = composeInitializer(i1, reverseTransform);
+    }
+    return {
+        ...options,
+        ...(s1 === null || isDomainSort(s1)) && {
+            sort: s1
+        },
+        initializer: composeInitializer(i1, initializer3)
+    };
+}
+
+function composeTransform(t15, t23) {
+    if (t15 == null)
+        return t23 === null ? void 0 : t23;
+    if (t23 == null)
+        return t15 === null ? void 0 : t15;
+    return function(data, facets) {
+        ({
+            data,
+            facets
+        } = t15.call(this, data, facets));
+        return t23.call(this, arrayify2(data), facets);
+    };
+}
+
+function composeInitializer(i1, i2) {
+    if (i1 == null)
+        return i2 === null ? void 0 : i2;
+    if (i2 == null)
+        return i1 === null ? void 0 : i1;
+    return function(data, facets, channels, ...args) {
+        let c1, d1, f1, c22, d2, f2;
+        ({
+            data: d1 = data,
+            facets: f1 = facets,
+            channels: c1
+        } = i1.call(this, data, facets, channels, ...args));
+        ({
+            data: d2 = d1,
+            facets: f2 = f1,
+            channels: c22
+        } = i2.call(this, d1, f1, {
+            ...channels,
+            ...c1
+        }, ...args));
+        return {
+            data: d2,
+            facets: f2,
+            channels: {
+                ...c1,
+                ...c22
+            }
+        };
+    };
+}
+
+function apply(options, t) {
+    return (options.initializer != null ? initializer : basic)(options, t);
+}
+
+function filter3(test, options) {
+    return apply(options, filterTransform(test));
+}
+
+function filterTransform(value) {
+    return (data, facets) => {
+        const V = valueof(data, value);
+        return {
+            data,
+            facets: facets.map((I) => I.filter((i) => V[i]))
+        };
+    };
+}
+
+function reverse2({
+    sort: sort5,
+    ...options
+} = {}) {
+    return {
+        ...apply(options, reverseTransform),
+        sort: isDomainSort(sort5) ? sort5 : null
+    };
+}
+
+function reverseTransform(data, facets) {
+    return {
+        data,
+        facets: facets.map((I) => I.slice().reverse())
+    };
+}
+
+function shuffle2({
+    seed,
+    sort: sort5,
+    ...options
+} = {}) {
+    return {
+        ...apply(options, sortValue(seed == null ? Math.random : lcg(seed))),
+        sort: isDomainSort(sort5) ? sort5 : null
+    };
+}
+
+function sort2(order, {
+    sort: sort5,
+    ...options
+} = {}) {
+    return {
+        ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
+        sort: isDomainSort(sort5) ? sort5 : null
+    };
+}
+
+function sortTransform(value) {
+    return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
+}
+
+function sortData(compare) {
+    return (data, facets) => {
+        const compareData = (i, j) => compare(data[i], data[j]);
+        return {
+            data,
+            facets: facets.map((I) => I.slice().sort(compareData))
+        };
+    };
+}
+
+function sortValue(value) {
+    let channel, order;
+    ({
+        channel,
+        value,
+        order = ascendingDefined2
+    } = {
+        ...maybeValue(value)
+    });
+    if (typeof order !== "function") {
+        switch (`${order}`.toLowerCase()) {
+            case "ascending":
+                order = ascendingDefined2;
+                break;
+            case "descending":
+                order = descendingDefined;
+                break;
+            default:
+                throw new Error(`invalid order: ${order}`);
+        }
+    }
+    return (data, facets, channels) => {
+        let V;
+        if (channel === void 0) {
+            V = valueof(data, value);
+        } else {
+            if (channels === void 0)
+                throw new Error("channel sort requires an initializer");
+            V = channels[channel];
+            if (!V)
+                return {};
+            V = V.value;
+        }
+        const compareValue3 = (i, j) => order(V[i], V[j]);
+        return {
+            data,
+            facets: facets.map((I) => I.slice().sort(compareValue3))
+        };
+    };
+}
+
+// node_modules/@observablehq/plot/src/transforms/group.js
+function groupZ(outputs, options) {
+    return groupn(null, null, outputs, options);
+}
+
+function groupX(outputs = {
+    y: "count"
+}, options = {}) {
+    const {
+        x: x7 = identity6
+    } = options;
+    if (x7 == null)
+        throw new Error("missing channel: x");
+    return groupn(x7, null, outputs, options);
+}
+
+function groupY(outputs = {
+    x: "count"
+}, options = {}) {
+    const {
+        y: y7 = identity6
+    } = options;
+    if (y7 == null)
+        throw new Error("missing channel: y");
+    return groupn(null, y7, outputs, options);
+}
+
+function group2(outputs = {
+    fill: "count"
+}, options = {}) {
+    let {
+        x: x7,
+        y: y7
+    } = options;
+    [x7, y7] = maybeTuple(x7, y7);
+    if (x7 == null)
+        throw new Error("missing channel: x");
+    if (y7 == null)
+        throw new Error("missing channel: y");
+    return groupn(x7, y7, outputs, options);
+}
+
+function groupn(x7, y7, {
+    data: reduceData = reduceIdentity,
+    filter: filter7,
+    sort: sort5,
+    reverse: reverse5,
+    ...outputs
+    // output channel definitions
+} = {}, inputs = {}) {
+    outputs = maybeOutputs(outputs, inputs);
+    reduceData = maybeReduce(reduceData, identity6);
+    sort5 = sort5 == null ? void 0 : maybeOutput("sort", sort5, inputs);
+    filter7 = filter7 == null ? void 0 : maybeEvaluator("filter", filter7, inputs);
+    const [GX, setGX] = maybeColumn(x7);
+    const [GY, setGY] = maybeColumn(y7);
+    const {
+        z,
+        fill,
+        stroke,
+        x1: x13,
+        x2: x22,
+        // consumed if x is an output
+        y1: y13,
+        y2: y22,
+        // consumed if y is an output
+        ...options
+    } = inputs;
+    const [GZ, setGZ] = maybeColumn(z);
+    const [vfill] = maybeColorChannel(fill);
+    const [vstroke] = maybeColorChannel(stroke);
+    const [GF, setGF] = maybeColumn(vfill);
+    const [GS, setGS] = maybeColumn(vstroke);
+    return {
+        ..."z" in inputs && {
+            z: GZ || z
+        },
+        ..."fill" in inputs && {
+            fill: GF || fill
+        },
+        ..."stroke" in inputs && {
+            stroke: GS || stroke
+        },
+        ...basic(options, (data, facets) => {
+            const X4 = valueof(data, x7);
+            const Y4 = valueof(data, y7);
+            const Z = valueof(data, z);
+            const F = valueof(data, vfill);
+            const S = valueof(data, vstroke);
+            const G = maybeSubgroup(outputs, {
+                z: Z,
+                fill: F,
+                stroke: S
+            });
+            const groupFacets = [];
+            const groupData = [];
+            const GX2 = X4 && setGX([]);
+            const GY2 = Y4 && setGY([]);
+            const GZ2 = Z && setGZ([]);
+            const GF2 = F && setGF([]);
+            const GS2 = S && setGS([]);
+            let i = 0;
+            for (const o of outputs)
+                o.initialize(data);
+            if (sort5)
+                sort5.initialize(data);
+            if (filter7)
+                filter7.initialize(data);
+            for (const facet of facets) {
+                const groupFacet = [];
+                for (const o of outputs)
+                    o.scope("facet", facet);
+                if (sort5)
+                    sort5.scope("facet", facet);
+                if (filter7)
+                    filter7.scope("facet", facet);
+                for (const [f, I] of maybeGroup(facet, G)) {
+                    for (const [y8, gg] of maybeGroup(I, Y4)) {
+                        for (const [x8, g] of maybeGroup(gg, X4)) {
+                            if (filter7 && !filter7.reduce(g))
+                                continue;
+                            groupFacet.push(i++);
+                            groupData.push(reduceData.reduceIndex(g, data));
+                            if (X4)
+                                GX2.push(x8);
+                            if (Y4)
+                                GY2.push(y8);
+                            if (Z)
+                                GZ2.push(G === Z ? f : Z[g[0]]);
+                            if (F)
+                                GF2.push(G === F ? f : F[g[0]]);
+                            if (S)
+                                GS2.push(G === S ? f : S[g[0]]);
+                            for (const o of outputs)
+                                o.reduce(g);
+                            if (sort5)
+                                sort5.reduce(g);
+                        }
+                    }
+                }
+                groupFacets.push(groupFacet);
+            }
+            maybeSort(groupFacets, sort5, reverse5);
+            return {
+                data: groupData,
+                facets: groupFacets
+            };
+        }),
+        ...!hasOutput(outputs, "x") && (GX ? {
+            x: GX
+        } : {
+            x1: x13,
+            x2: x22
+        }),
+        ...!hasOutput(outputs, "y") && (GY ? {
+            y: GY
+        } : {
+            y1: y13,
+            y2: y22
+        }),
+        ...Object.fromEntries(outputs.map(({
+            name,
+            output
+        }) => [name, output]))
+    };
+}
+
+function hasOutput(outputs, ...names) {
+    for (const {
+            name
+        }
+        of outputs) {
+        if (names.includes(name)) {
+            return true;
+        }
+    }
+    return false;
+}
+
+function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
+    const entries = Object.entries(outputs);
+    if (inputs.title != null && outputs.title === void 0)
+        entries.push(["title", reduceTitle]);
+    if (inputs.href != null && outputs.href === void 0)
+        entries.push(["href", reduceFirst]);
+    return entries.filter(([, reduce3]) => reduce3 !== void 0).map(([name, reduce3]) => reduce3 === null ? nullOutput(name) : asOutput(name, reduce3, inputs));
+}
+
+function maybeOutput(name, reduce3, inputs, asEvaluator = maybeEvaluator) {
+    let scale5;
+    if (isObject(reduce3) && "reduce" in reduce3)
+        scale5 = reduce3.scale, reduce3 = reduce3.reduce;
+    const evaluator = asEvaluator(name, reduce3, inputs);
+    const [output, setOutput] = column(evaluator.label);
+    let O;
+    return {
+        name,
+        output: scale5 === void 0 ? output : {
+            value: output,
+            scale: scale5
+        },
+        initialize(data) {
+            evaluator.initialize(data);
+            O = setOutput([]);
+        },
+        scope(scope, I) {
+            evaluator.scope(scope, I);
+        },
+        reduce(I, extent5) {
+            O.push(evaluator.reduce(I, extent5));
+        }
+    };
+}
+
+function nullOutput(name) {
+    return {
+        name,
+        initialize() {},
+        scope() {},
+        reduce() {}
+    };
+}
+
+function maybeEvaluator(name, reduce3, inputs, asReduce = maybeReduce) {
+    const input = maybeInput(name, inputs);
+    const reducer3 = asReduce(reduce3, input);
+    let V, context;
+    return {
+        label: labelof(reducer3 === reduceCount ? null : input, reducer3.label),
+        initialize(data) {
+            V = input === void 0 ? data : valueof(data, input);
+            if (reducer3.scope === "data") {
+                context = reducer3.reduceIndex(range4(data), V);
+            }
+        },
+        scope(scope, I) {
+            if (reducer3.scope === scope) {
+                context = reducer3.reduceIndex(I, V);
+            }
+        },
+        reduce(I, extent5) {
+            return reducer3.scope == null ? reducer3.reduceIndex(I, V, extent5) : reducer3.reduceIndex(I, V, context, extent5);
+        }
+    };
+}
+
+function maybeGroup(I, X4) {
+    return X4 ? sort(
+        group(I, (i) => X4[i]),
+        first
+    ) : [
+        [, I]
+    ];
+}
+
+function maybeReduce(reduce3, value, fallback = invalidReduce) {
+    if (reduce3 == null)
+        return fallback(reduce3);
+    if (typeof reduce3.reduceIndex === "function")
+        return reduce3;
+    if (typeof reduce3.reduce === "function" && isObject(reduce3))
+        return reduceReduce(reduce3);
+    if (typeof reduce3 === "function")
+        return reduceFunction(reduce3);
+    if (/^p\d{2}$/i.test(reduce3))
+        return reduceAccessor(percentile(reduce3));
+    switch (`${reduce3}`.toLowerCase()) {
+        case "first":
+            return reduceFirst;
+        case "last":
+            return reduceLast;
+        case "identity":
+            return reduceIdentity;
+        case "count":
+            return reduceCount;
+        case "distinct":
+            return reduceDistinct;
+        case "sum":
+            return value == null ? reduceCount : reduceSum;
+        case "proportion":
+            return reduceProportion(value, "data");
+        case "proportion-facet":
+            return reduceProportion(value, "facet");
+        case "deviation":
+            return reduceAccessor(deviation);
+        case "min":
+            return reduceAccessor(min);
+        case "min-index":
+            return reduceAccessor(minIndex);
+        case "max":
+            return reduceAccessor(max);
+        case "max-index":
+            return reduceAccessor(maxIndex);
+        case "mean":
+            return reduceMaybeTemporalAccessor(mean);
+        case "median":
+            return reduceMaybeTemporalAccessor(median);
+        case "variance":
+            return reduceAccessor(variance);
+        case "mode":
+            return reduceAccessor(mode);
+    }
+    return fallback(reduce3);
+}
+
+function invalidReduce(reduce3) {
+    throw new Error(`invalid reduce: ${reduce3}`);
+}
+
+function maybeSubgroup(outputs, inputs) {
+    for (const name in inputs) {
+        const value = inputs[name];
+        if (value !== void 0 && !outputs.some((o) => o.name === name)) {
+            return value;
+        }
+    }
+}
+
+function maybeSort(facets, sort5, reverse5) {
+    if (sort5) {
+        const S = sort5.output.transform();
+        const compare = (i, j) => ascendingDefined2(S[i], S[j]);
+        facets.forEach((f) => f.sort(compare));
+    }
+    if (reverse5) {
+        facets.forEach((f) => f.reverse());
+    }
+}
+
+function reduceReduce(reduce3) {
+    console.warn("deprecated reduce interface; implement reduceIndex instead.");
+    return {
+        ...reduce3,
+        reduceIndex: reduce3.reduce.bind(reduce3)
+    };
+}
+
+function reduceFunction(f) {
+    return {
+        reduceIndex(I, X4, extent5) {
+            return f(take(X4, I), extent5);
+        }
+    };
+}
+
+function reduceAccessor(f) {
+    return {
+        reduceIndex(I, X4) {
+            return f(I, (i) => X4[i]);
+        }
+    };
+}
+
+function reduceMaybeTemporalAccessor(f) {
+    return {
+        reduceIndex(I, X4) {
+            const x7 = f(I, (i) => X4[i]);
+            return isTemporal(X4) ? new Date(x7) : x7;
+        }
+    };
+}
+var reduceIdentity = {
+    reduceIndex(I, X4) {
+        return take(X4, I);
+    }
+};
+var reduceFirst = {
+    reduceIndex(I, X4) {
+        return X4[I[0]];
+    }
+};
+var reduceTitle = {
+    reduceIndex(I, X4) {
+        const n = 5;
+        const groups3 = sort(
+            rollup(
+                I,
+                (V) => V.length,
+                (i) => X4[i]
+            ),
+            second2
+        );
+        const top3 = groups3.slice(-n).reverse();
+        if (top3.length < groups3.length) {
+            const bottom3 = groups3.slice(0, 1 - n);
+            top3[n - 1] = [`\u2026 ${bottom3.length.toLocaleString("en-US")} more`, sum(bottom3, second2)];
+        }
+        return top3.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
+    }
+};
+var reduceLast = {
+    reduceIndex(I, X4) {
+        return X4[I[I.length - 1]];
+    }
+};
+var reduceCount = {
+    label: "Frequency",
+    reduceIndex(I) {
+        return I.length;
+    }
+};
+var reduceDistinct = {
+    label: "Distinct",
+    reduceIndex(I, X4) {
+        const s3 = new InternSet();
+        for (const i of I)
+            s3.add(X4[i]);
+        return s3.size;
+    }
+};
+var reduceSum = reduceAccessor(sum);
+
+function reduceProportion(value, scope) {
+    return value == null ? {
+        scope,
+        label: "Frequency",
+        reduceIndex: (I, V, basis3 = 1) => I.length / basis3
+    } : {
+        scope,
+        reduceIndex: (I, V, basis3 = 1) => sum(I, (i) => V[i]) / basis3
+    };
+}
+
+// node_modules/@observablehq/plot/src/channel.js
+function createChannel(data, {
+    scale: scale5,
+    type: type3,
+    value,
+    filter: filter7,
+    hint
+}, name) {
+    return inferChannelScale(name, {
+        scale: scale5,
+        type: type3,
+        value: valueof(data, value),
+        label: labelof(value),
+        filter: filter7,
+        hint
+    });
+}
+
+function createChannels(channels, data) {
+    return Object.fromEntries(
+        Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
+    );
+}
+
+function valueObject(channels, scales) {
+    const values3 = Object.fromEntries(
+        Object.entries(channels).map(([name, {
+            scale: scaleName,
+            value
+        }]) => {
+            const scale5 = scaleName == null ? null : scales[scaleName];
+            return [name, scale5 == null ? value : map4(value, scale5)];
+        })
+    );
+    values3.channels = channels;
+    return values3;
+}
+
+function inferChannelScale(name, channel) {
+    const {
+        scale: scale5,
+        value
+    } = channel;
+    if (scale5 === true || scale5 === "auto") {
+        switch (name) {
+            case "fill":
+            case "stroke":
+            case "color":
+                channel.scale = scale5 !== true && isEvery(value, isColor) ? null : "color";
+                break;
+            case "fillOpacity":
+            case "strokeOpacity":
+                channel.scale = scale5 !== true && isEvery(value, isOpacity) ? null : "opacity";
+                break;
+            case "symbol":
+                if (scale5 !== true && isEvery(value, isSymbol)) {
+                    channel.scale = null;
+                    channel.value = map4(value, maybeSymbol);
+                } else {
+                    channel.scale = "symbol";
+                }
+                break;
+            default:
+                channel.scale = registry.has(name) ? name : null;
+                break;
+        }
+    } else if (scale5 === false) {
+        channel.scale = null;
+    } else if (scale5 != null && !registry.has(scale5)) {
+        throw new Error(`unknown scale: ${scale5}`);
+    }
+    return channel;
+}
+
+function channelDomain(data, facets, channels, facetChannels, options) {
+    const {
+        reverse: defaultReverse,
+        reduce: defaultReduce = true,
+        limit: defaultLimit
+    } = options;
+    for (const x7 in options) {
+        if (!registry.has(x7))
+            continue;
+        let {
+            value: y7,
+            reverse: reverse5 = defaultReverse,
+            reduce: reduce3 = defaultReduce,
+            limit = defaultLimit
+        } = maybeValue(options[x7]);
+        if (reverse5 === void 0)
+            reverse5 = y7 === "width" || y7 === "height";
+        if (reduce3 == null || reduce3 === false)
+            continue;
+        const X4 = x7 === "fx" || x7 === "fy" ? reindexFacetChannel(facets, facetChannels[x7]) : findScaleChannel(channels, x7);
+        if (!X4)
+            throw new Error(`missing channel for scale: ${x7}`);
+        const XV = X4.value;
+        const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
+        if (y7 == null) {
+            X4.domain = () => {
+                let domain = Array.from(new InternSet(XV));
+                if (reverse5)
+                    domain = domain.reverse();
+                if (lo !== 0 || hi !== Infinity)
+                    domain = domain.slice(lo, hi);
+                return domain;
+            };
+        } else {
+            const YV = y7 === "data" ? data : y7 === "height" ? difference2(channels, "y1", "y2") : y7 === "width" ? difference2(channels, "x1", "x2") : values(channels, y7, y7 === "y" ? "y2" : y7 === "x" ? "x2" : void 0);
+            const reducer3 = maybeReduce(reduce3 === true ? "max" : reduce3, YV);
+            X4.domain = () => {
+                let domain = rollup(
+                    range4(XV),
+                    (I) => reducer3.reduceIndex(I, YV),
+                    (i) => XV[i]
+                );
+                domain = sort(domain, reverse5 ? descendingGroup : ascendingGroup);
+                if (lo !== 0 || hi !== Infinity)
+                    domain = domain.slice(lo, hi);
+                return domain.map(first);
+            };
+        }
+    }
+}
+
+function findScaleChannel(channels, scale5) {
+    for (const name in channels) {
+        const channel = channels[name];
+        if (channel.scale === scale5)
+            return channel;
+    }
+}
+
+function reindexFacetChannel(facets, channel) {
+    const originalFacets = facets.original;
+    if (originalFacets === facets)
+        return channel;
+    const V1 = channel.value;
+    const V2 = channel.value = [];
+    for (let i = 0; i < originalFacets.length; ++i) {
+        const vi = V1[originalFacets[i][0]];
+        for (const j of facets[i])
+            V2[j] = vi;
+    }
+    return channel;
+}
+
+function difference2(channels, k1, k22) {
+    const X15 = values(channels, k1);
+    const X25 = values(channels, k22);
+    return map4(X25, (x22, i) => Math.abs(x22 - X15[i]), Float64Array);
+}
+
+function values(channels, name, alias) {
+    let channel = channels[name];
+    if (!channel && alias !== void 0)
+        channel = channels[alias];
+    if (channel)
+        return channel.value;
+    throw new Error(`missing channel: ${name}`);
+}
+
+function ascendingGroup([ak, av], [bk, bv]) {
+    return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
+}
+
+function descendingGroup([ak, av], [bk, bv]) {
+    return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
+}
+
+// node_modules/@observablehq/plot/src/warnings.js
+var warnings = 0;
+
+function consumeWarnings() {
+    const w = warnings;
+    warnings = 0;
+    return w;
+}
+
+function warn(message) {
+    console.warn(message);
+    ++warnings;
+}
+
+// node_modules/@observablehq/plot/src/projection.js
+var pi6 = Math.PI;
+var tau7 = 2 * pi6;
+var defaultAspectRatio = 0.618;
+
+function createProjection({
+    projection: projection3,
+    inset: globalInset = 0,
+    insetTop = globalInset,
+    insetRight = globalInset,
+    insetBottom = globalInset,
+    insetLeft = globalInset
+} = {}, dimensions) {
+    if (projection3 == null)
+        return;
+    if (typeof projection3.stream === "function")
+        return projection3;
+    let options;
+    let domain;
+    let clip = "frame";
+    if (isObject(projection3)) {
+        let inset;
+        ({
+            type: projection3,
+            domain,
+            inset,
+            insetTop = inset !== void 0 ? inset : insetTop,
+            insetRight = inset !== void 0 ? inset : insetRight,
+            insetBottom = inset !== void 0 ? inset : insetBottom,
+            insetLeft = inset !== void 0 ? inset : insetLeft,
+            clip = clip,
+            ...options
+        } = projection3);
+        if (projection3 == null)
+            return;
+    }
+    if (typeof projection3 !== "function")
+        ({
+            type: projection3
+        } = namedProjection(projection3));
+    const {
+        width,
+        height,
+        marginLeft,
+        marginRight,
+        marginTop,
+        marginBottom
+    } = dimensions;
+    const dx = width - marginLeft - marginRight - insetLeft - insetRight;
+    const dy = height - marginTop - marginBottom - insetTop - insetBottom;
+    projection3 = projection3?.({
+        width: dx,
+        height: dy,
+        clip,
+        ...options
+    });
+    if (projection3 == null)
+        return;
+    clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
+    let tx = marginLeft + insetLeft;
+    let ty = marginTop + insetTop;
+    let transform3;
+    if (domain != null) {
+        const [
+            [x011, y011],
+            [x13, y13]
+        ] = path_default(projection3).bounds(domain);
+        const k3 = Math.min(dx / (x13 - x011), dy / (y13 - y011));
+        if (k3 > 0) {
+            tx -= (k3 * (x011 + x13) - dx) / 2;
+            ty -= (k3 * (y011 + y13) - dy) / 2;
+            transform3 = transform_default({
+                point(x7, y7) {
+                    this.stream.point(x7 * k3 + tx, y7 * k3 + ty);
+                }
+            });
+        } else {
+            warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
+        }
+    }
+    transform3 ??= tx === 0 && ty === 0 ? identity7() : transform_default({
+        point(x7, y7) {
+            this.stream.point(x7 + tx, y7 + ty);
+        }
+    });
+    return {
+        stream: (s3) => projection3.stream(transform3.stream(clip(s3)))
+    };
+}
+
+function namedProjection(projection3) {
+    switch (`${projection3}`.toLowerCase()) {
+        case "albers-usa":
+            return scaleProjection(albersUsa_default, 0.7463, 0.4673);
+        case "albers":
+            return conicProjection2(albers_default, 0.7463, 0.4673);
+        case "azimuthal-equal-area":
+            return scaleProjection(azimuthalEqualArea_default, 4, 4);
+        case "azimuthal-equidistant":
+            return scaleProjection(azimuthalEquidistant_default, tau7, tau7);
+        case "conic-conformal":
+            return conicProjection2(conicConformal_default, tau7, tau7);
+        case "conic-equal-area":
+            return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
+        case "conic-equidistant":
+            return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
+        case "equal-earth":
+            return scaleProjection(equalEarth_default, 5.4133, 2.6347);
+        case "equirectangular":
+            return scaleProjection(equirectangular_default, tau7, pi6);
+        case "gnomonic":
+            return scaleProjection(gnomonic_default, 3.4641, 3.4641);
+        case "identity":
+            return {
+                type: identity7
+            };
+        case "reflect-y":
+            return {
+                type: reflectY
+            };
+        case "mercator":
+            return scaleProjection(mercator_default, tau7, tau7);
+        case "orthographic":
+            return scaleProjection(orthographic_default, 2, 2);
+        case "stereographic":
+            return scaleProjection(stereographic_default, 2, 2);
+        case "transverse-mercator":
+            return scaleProjection(transverseMercator_default, tau7, tau7);
+        default:
+            throw new Error(`unknown projection type: ${projection3}`);
+    }
+}
+
+function maybePostClip(clip, x13, y13, x22, y22) {
+    if (clip === false || clip == null || typeof clip === "number")
+        return (s3) => s3;
+    if (clip === true)
+        clip = "frame";
+    switch (`${clip}`.toLowerCase()) {
+        case "frame":
+            return clipRectangle(x13, y13, x22, y22);
+        default:
+            throw new Error(`unknown projection clip type: ${clip}`);
+    }
+}
+
+function scaleProjection(createProjection3, kx3, ky3) {
+    return {
+        type: ({
+            width,
+            height,
+            rotate,
+            precision = 0.15,
+            clip
+        }) => {
+            const projection3 = createProjection3();
+            if (precision != null)
+                projection3.precision?.(precision);
+            if (rotate != null)
+                projection3.rotate?.(rotate);
+            if (typeof clip === "number")
+                projection3.clipAngle?.(clip);
+            projection3.scale(Math.min(width / kx3, height / ky3));
+            projection3.translate([width / 2, height / 2]);
+            return projection3;
+        },
+        aspectRatio: ky3 / kx3
+    };
+}
+
+function conicProjection2(createProjection3, kx3, ky3) {
+    const {
+        type: type3,
+        aspectRatio
+    } = scaleProjection(createProjection3, kx3, ky3);
+    return {
+        type: (options) => {
+            const {
+                parallels,
+                domain,
+                width,
+                height
+            } = options;
+            const projection3 = type3(options);
+            if (parallels != null) {
+                projection3.parallels(parallels);
+                if (domain === void 0) {
+                    projection3.fitSize([width, height], {
+                        type: "Sphere"
+                    });
+                }
+            }
+            return projection3;
+        },
+        aspectRatio
+    };
+}
+var identity7 = constant2({
+    stream: (stream) => stream
+});
+var reflectY = constant2(
+    transform_default({
+        point(x7, y7) {
+            this.stream.point(x7, -y7);
+        }
+    })
+);
+
+function maybeProject(cx, cy, channels, values3, context) {
+    const x7 = channels[cx] && channels[cx].scale === "x";
+    const y7 = channels[cy] && channels[cy].scale === "y";
+    if (x7 && y7) {
+        project(cx, cy, values3, context.projection);
+    } else if (x7) {
+        throw new Error(`projection requires paired x and y channels; ${cx} is missing ${cy}`);
+    } else if (y7) {
+        throw new Error(`projection requires paired x and y channels; ${cy} is missing ${cx}`);
+    }
+}
+
+function project(cx, cy, values3, projection3) {
+    const x7 = values3[cx];
+    const y7 = values3[cy];
+    const n = x7.length;
+    const X4 = values3[cx] = new Float64Array(n).fill(NaN);
+    const Y4 = values3[cy] = new Float64Array(n).fill(NaN);
+    let i;
+    const stream = projection3.stream({
+        point(x8, y8) {
+            X4[i] = x8;
+            Y4[i] = y8;
+        }
+    });
+    for (i = 0; i < n; ++i) {
+        stream.point(x7[i], y7[i]);
+    }
+}
+
+function projectionAspectRatio(projection3, marks3) {
+    if (typeof projection3?.stream === "function")
+        return defaultAspectRatio;
+    if (isObject(projection3))
+        projection3 = projection3.type;
+    if (projection3 == null)
+        return hasGeometry(marks3) ? defaultAspectRatio : void 0;
+    if (typeof projection3 !== "function") {
+        const {
+            aspectRatio
+        } = namedProjection(projection3);
+        if (aspectRatio)
+            return aspectRatio;
+    }
+    return defaultAspectRatio;
+}
+
+function applyPosition(channels, scales, context) {
+    const {
+        x: x7,
+        y: y7
+    } = channels;
+    let position3 = {};
+    if (x7)
+        position3.x = x7;
+    if (y7)
+        position3.y = y7;
+    position3 = valueObject(position3, scales);
+    if (context.projection)
+        maybeProject("x", "y", channels, position3, context);
+    if (x7)
+        position3.x = coerceNumbers(position3.x);
+    if (y7)
+        position3.y = coerceNumbers(position3.y);
+    return position3;
+}
+
+function hasGeometry(marks3) {
+    for (const mark of marks3)
+        if (mark.channels.geometry)
+            return true;
+    return false;
+}
+
+// node_modules/@observablehq/plot/src/context.js
+function createContext(options = {}, dimensions) {
+    const {
+        document: document2 = typeof window !== "undefined" ? window.document : void 0
+    } = options;
+    return {
+        document: document2,
+        projection: createProjection(options, dimensions)
+    };
+}
+
+function create2(name, {
+    document: document2
+}) {
+    return select_default2(creator_default(name).call(document2.documentElement));
+}
+
+// node_modules/@observablehq/plot/src/scales/schemes.js
+var ordinalSchemes = /* @__PURE__ */ new Map([
+    // categorical
+    ["accent", Accent_default],
+    ["category10", category10_default],
+    ["dark2", Dark2_default],
+    ["paired", Paired_default],
+    ["pastel1", Pastel1_default],
+    ["pastel2", Pastel2_default],
+    ["set1", Set1_default],
+    ["set2", Set2_default],
+    ["set3", Set3_default],
+    ["tableau10", Tableau10_default],
+    // diverging
+    ["brbg", scheme112(scheme, BrBG_default)],
+    ["prgn", scheme112(scheme2, PRGn_default)],
+    ["piyg", scheme112(scheme3, PiYG_default)],
+    ["puor", scheme112(scheme4, PuOr_default)],
+    ["rdbu", scheme112(scheme5, RdBu_default)],
+    ["rdgy", scheme112(scheme6, RdGy_default)],
+    ["rdylbu", scheme112(scheme7, RdYlBu_default)],
+    ["rdylgn", scheme112(scheme8, RdYlGn_default)],
+    ["spectral", scheme112(scheme9, Spectral_default)],
+    // reversed diverging (for temperature data)
+    ["burd", scheme11r(scheme5, RdBu_default)],
+    ["buylrd", scheme11r(scheme7, RdYlBu_default)],
+    // sequential (single-hue)
+    ["blues", scheme92(scheme22, Blues_default)],
+    ["greens", scheme92(scheme23, Greens_default)],
+    ["greys", scheme92(scheme24, Greys_default)],
+    ["oranges", scheme92(scheme27, Oranges_default)],
+    ["purples", scheme92(scheme25, Purples_default)],
+    ["reds", scheme92(scheme26, Reds_default)],
+    // sequential (multi-hue)
+    ["turbo", schemei(turbo_default)],
+    ["viridis", schemei(viridis_default)],
+    ["magma", schemei(magma)],
+    ["inferno", schemei(inferno)],
+    ["plasma", schemei(plasma)],
+    ["cividis", schemei(cividis_default)],
+    ["cubehelix", schemei(cubehelix_default2)],
+    ["warm", schemei(warm)],
+    ["cool", schemei(cool)],
+    ["bugn", scheme92(scheme10, BuGn_default)],
+    ["bupu", scheme92(scheme11, BuPu_default)],
+    ["gnbu", scheme92(scheme12, GnBu_default)],
+    ["orrd", scheme92(scheme13, OrRd_default)],
+    ["pubu", scheme92(scheme15, PuBu_default)],
+    ["pubugn", scheme92(scheme14, PuBuGn_default)],
+    ["purd", scheme92(scheme16, PuRd_default)],
+    ["rdpu", scheme92(scheme17, RdPu_default)],
+    ["ylgn", scheme92(scheme19, YlGn_default)],
+    ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
+    ["ylorbr", scheme92(scheme20, YlOrBr_default)],
+    ["ylorrd", scheme92(scheme21, YlOrRd_default)],
+    // cyclical
+    ["rainbow", schemeicyclical(rainbow_default)],
+    ["sinebow", schemeicyclical(sinebow_default)]
+]);
+
+function scheme92(scheme55, interpolate) {
+    return ({
+        length: n
+    }) => {
+        if (n === 1)
+            return [scheme55[3][1]];
+        if (n === 2)
+            return [scheme55[3][1], scheme55[3][2]];
+        n = Math.max(3, Math.floor(n));
+        return n > 9 ? quantize_default(interpolate, n) : scheme55[n];
+    };
+}
+
+function scheme112(scheme55, interpolate) {
+    return ({
+        length: n
+    }) => {
+        if (n === 2)
+            return [scheme55[3][0], scheme55[3][2]];
+        n = Math.max(3, Math.floor(n));
+        return n > 11 ? quantize_default(interpolate, n) : scheme55[n];
+    };
+}
+
+function scheme11r(scheme55, interpolate) {
+    return ({
+        length: n
+    }) => {
+        if (n === 2)
+            return [scheme55[3][2], scheme55[3][0]];
+        n = Math.max(3, Math.floor(n));
+        return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme55[n].slice().reverse();
+    };
+}
+
+function schemei(interpolate) {
+    return ({
+        length: n
+    }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
+}
+
+function schemeicyclical(interpolate) {
+    return ({
+        length: n
+    }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
+}
+
+function ordinalScheme(scheme55) {
+    const s3 = `${scheme55}`.toLowerCase();
+    if (!ordinalSchemes.has(s3))
+        throw new Error(`unknown ordinal scheme: ${s3}`);
+    return ordinalSchemes.get(s3);
+}
+
+function ordinalRange(scheme55, length7) {
+    const s3 = ordinalScheme(scheme55);
+    const r = typeof s3 === "function" ? s3({
+        length: length7
+    }) : s3;
+    return r.length !== length7 ? r.slice(0, length7) : r;
+}
+
+function maybeBooleanRange(domain, scheme55 = "greys") {
+    const range9 = /* @__PURE__ */ new Set();
+    const [f, t] = ordinalRange(scheme55, 2);
+    for (const value of domain) {
+        if (value == null)
+            continue;
+        if (value === true)
+            range9.add(t);
+        else if (value === false)
+            range9.add(f);
+        else
+            return;
+    }
+    return [...range9];
+}
+var quantitativeSchemes = /* @__PURE__ */ new Map([
+    // diverging
+    ["brbg", BrBG_default],
+    ["prgn", PRGn_default],
+    ["piyg", PiYG_default],
+    ["puor", PuOr_default],
+    ["rdbu", RdBu_default],
+    ["rdgy", RdGy_default],
+    ["rdylbu", RdYlBu_default],
+    ["rdylgn", RdYlGn_default],
+    ["spectral", Spectral_default],
+    // reversed diverging (for temperature data)
+    ["burd", (t) => RdBu_default(1 - t)],
+    ["buylrd", (t) => RdYlBu_default(1 - t)],
+    // sequential (single-hue)
+    ["blues", Blues_default],
+    ["greens", Greens_default],
+    ["greys", Greys_default],
+    ["purples", Purples_default],
+    ["reds", Reds_default],
+    ["oranges", Oranges_default],
+    // sequential (multi-hue)
+    ["turbo", turbo_default],
+    ["viridis", viridis_default],
+    ["magma", magma],
+    ["inferno", inferno],
+    ["plasma", plasma],
+    ["cividis", cividis_default],
+    ["cubehelix", cubehelix_default2],
+    ["warm", warm],
+    ["cool", cool],
+    ["bugn", BuGn_default],
+    ["bupu", BuPu_default],
+    ["gnbu", GnBu_default],
+    ["orrd", OrRd_default],
+    ["pubugn", PuBuGn_default],
+    ["pubu", PuBu_default],
+    ["purd", PuRd_default],
+    ["rdpu", RdPu_default],
+    ["ylgnbu", YlGnBu_default],
+    ["ylgn", YlGn_default],
+    ["ylorbr", YlOrBr_default],
+    ["ylorrd", YlOrRd_default],
+    // cyclical
+    ["rainbow", rainbow_default],
+    ["sinebow", sinebow_default]
+]);
+
+function quantitativeScheme(scheme55) {
+    const s3 = `${scheme55}`.toLowerCase();
+    if (!quantitativeSchemes.has(s3))
+        throw new Error(`unknown quantitative scheme: ${s3}`);
+    return quantitativeSchemes.get(s3);
+}
+var divergingSchemes = /* @__PURE__ */ new Set([
+    "brbg",
+    "prgn",
+    "piyg",
+    "puor",
+    "rdbu",
+    "rdgy",
+    "rdylbu",
+    "rdylgn",
+    "spectral",
+    "burd",
+    "buylrd"
+]);
+
+function isDivergingScheme(scheme55) {
+    return scheme55 != null && divergingSchemes.has(`${scheme55}`.toLowerCase());
+}
+
+// node_modules/@observablehq/plot/src/scales/quantitative.js
+var flip = (i) => (t) => i(1 - t);
+var unit2 = [0, 1];
+var interpolators = /* @__PURE__ */ new Map([
+    // numbers
+    ["number", number_default],
+    // color spaces
+    ["rgb", rgb_default],
+    ["hsl", hsl_default],
+    ["hcl", hcl_default],
+    ["lab", lab2]
+]);
+
+function maybeInterpolator(interpolate) {
+    const i = `${interpolate}`.toLowerCase();
+    if (!interpolators.has(i))
+        throw new Error(`unknown interpolator: ${i}`);
+    return interpolators.get(i);
+}
+
+function createScaleQ(key, scale5, channels, {
+    type: type3,
+    nice: nice5,
+    clamp,
+    zero: zero5,
+    domain = inferAutoDomain(key, channels),
+    unknown,
+    round: round3,
+    scheme: scheme55,
+    interval: interval3,
+    range: range9 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
+    interpolate = registry.get(key) === color2 ? scheme55 == null && range9 !== void 0 ? rgb_default : quantitativeScheme(scheme55 !== void 0 ? scheme55 : type3 === "cyclical" ? "rainbow" : "turbo") : round3 ? round_default : number_default,
+    reverse: reverse5
+}) {
+    interval3 = maybeRangeInterval(interval3, type3);
+    if (type3 === "cyclical" || type3 === "sequential")
+        type3 = "linear";
+    reverse5 = !!reverse5;
+    if (typeof interpolate !== "function") {
+        interpolate = maybeInterpolator(interpolate);
+    }
+    if (interpolate.length === 1) {
+        if (reverse5) {
+            interpolate = flip(interpolate);
+            reverse5 = false;
+        }
+        if (range9 === void 0) {
+            range9 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
+            if (range9.length === 2)
+                range9 = unit2;
+        }
+        scale5.interpolate((range9 === unit2 ? constant2 : interpolatePiecewise)(interpolate));
+    } else {
+        scale5.interpolate(interpolate);
+    }
+    if (zero5) {
+        const [min7, max9] = extent(domain);
+        if (min7 > 0 || max9 < 0) {
+            domain = slice5(domain);
+            if (orderof(domain) !== Math.sign(min7))
+                domain[domain.length - 1] = 0;
+            else
+                domain[0] = 0;
+        }
+    }
+    if (reverse5)
+        domain = reverse(domain);
+    scale5.domain(domain).unknown(unknown);
+    if (nice5)
+        scale5.nice(maybeNice(nice5, type3)), domain = scale5.domain();
+    if (range9 !== void 0)
+        scale5.range(range9);
+    if (clamp)
+        scale5.clamp(clamp);
+    return {
+        type: type3,
+        domain,
+        range: range9,
+        scale: scale5,
+        interpolate,
+        interval: interval3
+    };
+}
+
+function maybeNice(nice5, type3) {
+    return nice5 === true ? void 0 : typeof nice5 === "number" ? nice5 : maybeNiceInterval(nice5, type3);
+}
+
+function createScaleLinear(key, channels, options) {
+    return createScaleQ(key, linear3(), channels, options);
+}
+
+function createScaleSqrt(key, channels, options) {
+    return createScalePow(key, channels, {
+        ...options,
+        exponent: 0.5
+    });
+}
+
+function createScalePow(key, channels, {
+    exponent: exponent3 = 1,
+    ...options
+}) {
+    return createScaleQ(key, pow3().exponent(exponent3), channels, {
+        ...options,
+        type: "pow"
+    });
+}
+
+function createScaleLog(key, channels, {
+    base = 10,
+    domain = inferLogDomain(channels),
+    ...options
+}) {
+    return createScaleQ(key, log2().base(base), channels, {
+        ...options,
+        domain
+    });
+}
+
+function createScaleSymlog(key, channels, {
+    constant: constant5 = 1,
+    ...options
+}) {
+    return createScaleQ(key, symlog().constant(constant5), channels, options);
+}
+
+function createScaleQuantile(key, channels, {
+    range: range9,
+    quantiles = range9 === void 0 ? 5 : (range9 = [...range9]).length,
+    // deprecated; use n instead
+    n = quantiles,
+    scheme: scheme55 = "rdylbu",
+    domain = inferQuantileDomain(channels),
+    unknown,
+    interpolate,
+    reverse: reverse5
+}) {
+    if (range9 === void 0) {
+        range9 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme55, n) : void 0;
+    }
+    if (domain.length > 0) {
+        domain = quantile2(domain, range9 === void 0 ? {
+            length: n
+        } : range9).quantiles();
+    }
+    return createScaleThreshold(key, channels, {
+        domain,
+        range: range9,
+        reverse: reverse5,
+        unknown
+    });
+}
+
+function createScaleQuantize(key, channels, {
+    range: range9,
+    n = range9 === void 0 ? 5 : (range9 = [...range9]).length,
+    scheme: scheme55 = "rdylbu",
+    domain = inferAutoDomain(key, channels),
+    unknown,
+    interpolate,
+    reverse: reverse5
+}) {
+    const [min7, max9] = extent(domain);
+    let thresholds;
+    if (range9 === void 0) {
+        thresholds = ticks(min7, max9, n);
+        if (thresholds[0] <= min7)
+            thresholds.splice(0, 1);
+        if (thresholds[thresholds.length - 1] >= max9)
+            thresholds.pop();
+        n = thresholds.length + 1;
+        range9 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme55, n) : void 0;
+    } else {
+        thresholds = quantize_default(number_default(min7, max9), n + 1).slice(1, -1);
+        if (min7 instanceof Date)
+            thresholds = thresholds.map((x7) => new Date(x7));
+    }
+    if (orderof(arrayify2(domain)) < 0)
+        thresholds.reverse();
+    return createScaleThreshold(key, channels, {
+        domain: thresholds,
+        range: range9,
+        reverse: reverse5,
+        unknown
+    });
+}
+
+function createScaleThreshold(key, channels, {
+    domain = [0],
+    // explicit thresholds in ascending order
+    unknown,
+    scheme: scheme55 = "rdylbu",
+    interpolate,
+    range: range9 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme55, domain.length + 1) : void 0,
+    reverse: reverse5
+}) {
+    domain = arrayify2(domain);
+    const sign5 = orderof(domain);
+    if (!isNaN(sign5) && !isOrdered(domain, sign5))
+        throw new Error(`the ${key} scale has a non-monotonic domain`);
+    if (reverse5)
+        range9 = reverse(range9);
+    return {
+        type: "threshold",
+        scale: threshold(sign5 < 0 ? reverse(domain) : domain, range9 === void 0 ? [] : range9).unknown(unknown),
+        domain,
+        range: range9
+    };
+}
+
+function isOrdered(domain, sign5) {
+    for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
+        const s3 = descending(d, d = domain[i]);
+        if (s3 !== 0 && s3 !== sign5)
+            return false;
+    }
+    return true;
+}
+
+function createScaleIdentity() {
+    return {
+        type: "identity",
+        scale: identity4()
+    };
+}
+
+function inferDomain(channels, f = finite2) {
+    return channels.length ? [
+        min(channels, ({
+            value
+        }) => value === void 0 ? value : min(value, f)),
+        max(channels, ({
+            value
+        }) => value === void 0 ? value : max(value, f))
+    ] : [0, 1];
+}
+
+function inferAutoDomain(key, channels) {
+    const type3 = registry.get(key);
+    return (type3 === radius || type3 === opacity || type3 === length3 ? inferZeroDomain : inferDomain)(channels);
+}
+
+function inferZeroDomain(channels) {
+    return [0, channels.length ? max(channels, ({
+        value
+    }) => value === void 0 ? value : max(value, finite2)) : 1];
+}
+
+function inferRadialRange(channels, domain) {
+    const hint = channels.find(({
+        radius: radius3
+    }) => radius3 !== void 0);
+    if (hint !== void 0)
+        return [0, hint.radius];
+    const h25 = quantile(channels, 0.5, ({
+        value
+    }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
+    const range9 = domain.map((d) => 3 * Math.sqrt(d / h25));
+    const k3 = 30 / max(range9);
+    return k3 < 1 ? range9.map((r) => r * k3) : range9;
+}
+
+function inferLengthRange(channels, domain) {
+    const h50 = median(channels, ({
+        value
+    }) => value === void 0 ? NaN : median(value, Math.abs));
+    const range9 = domain.map((d) => 12 * d / h50);
+    const k3 = 60 / max(range9);
+    return k3 < 1 ? range9.map((r) => r * k3) : range9;
+}
+
+function inferLogDomain(channels) {
+    for (const {
+            value
+        }
+        of channels) {
+        if (value !== void 0) {
+            for (let v3 of value) {
+                if (v3 > 0)
+                    return inferDomain(channels, positive);
+                if (v3 < 0)
+                    return inferDomain(channels, negative);
+            }
+        }
+    }
+    return [1, 10];
+}
+
+function inferQuantileDomain(channels) {
+    const domain = [];
+    for (const {
+            value
+        }
+        of channels) {
+        if (value === void 0)
+            continue;
+        for (const v3 of value)
+            domain.push(v3);
+    }
+    return domain;
+}
+
+function interpolatePiecewise(interpolate) {
+    return (i, j) => (t) => interpolate(i + t * (j - i));
+}
+
+// node_modules/@observablehq/plot/src/scales/diverging.js
+function createScaleD(key, scale5, transform3, channels, {
+    type: type3,
+    nice: nice5,
+    clamp,
+    domain = inferDomain(channels),
+    unknown,
+    pivot = 0,
+    scheme: scheme55,
+    range: range9,
+    symmetric = true,
+    interpolate = registry.get(key) === color2 ? scheme55 == null && range9 !== void 0 ? rgb_default : quantitativeScheme(scheme55 !== void 0 ? scheme55 : "rdbu") : number_default,
+    reverse: reverse5
+}) {
+    pivot = +pivot;
+    let [min7, max9] = domain;
+    if (descending(min7, max9) < 0)
+        [min7, max9] = [max9, min7], reverse5 = !reverse5;
+    min7 = Math.min(min7, pivot);
+    max9 = Math.max(max9, pivot);
+    if (typeof interpolate !== "function") {
+        interpolate = maybeInterpolator(interpolate);
+    }
+    if (range9 !== void 0) {
+        interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range9) : piecewise(interpolate, range9);
+    }
+    if (reverse5)
+        interpolate = flip(interpolate);
+    if (symmetric) {
+        const mid3 = transform3.apply(pivot);
+        const mindelta = mid3 - transform3.apply(min7);
+        const maxdelta = transform3.apply(max9) - mid3;
+        if (mindelta < maxdelta)
+            min7 = transform3.invert(mid3 - maxdelta);
+        else if (mindelta > maxdelta)
+            max9 = transform3.invert(mid3 + mindelta);
+    }
+    scale5.domain([min7, pivot, max9]).unknown(unknown).interpolator(interpolate);
+    if (clamp)
+        scale5.clamp(clamp);
+    if (nice5)
+        scale5.nice(nice5);
+    return {
+        type: type3,
+        domain: [min7, max9],
+        pivot,
+        interpolate,
+        scale: scale5
+    };
+}
+
+function createScaleDiverging(key, channels, options) {
+    return createScaleD(key, diverging(), transformIdentity, channels, options);
+}
+
+function createScaleDivergingSqrt(key, channels, options) {
+    return createScaleDivergingPow(key, channels, {
+        ...options,
+        exponent: 0.5
+    });
+}
+
+function createScaleDivergingPow(key, channels, {
+    exponent: exponent3 = 1,
+    ...options
+}) {
+    return createScaleD(key, divergingPow().exponent(exponent3 = +exponent3), transformPow2(exponent3), channels, {
+        ...options,
+        type: "diverging-pow"
+    });
+}
+
+function createScaleDivergingLog(key, channels, {
+    base = 10,
+    pivot = 1,
+    domain = inferDomain(channels, pivot < 0 ? negative : positive),
+    ...options
+}) {
+    return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
+        domain,
+        pivot,
+        ...options
+    });
+}
+
+function createScaleDivergingSymlog(key, channels, {
+    constant: constant5 = 1,
+    ...options
+}) {
+    return createScaleD(
+        key,
+        divergingSymlog().constant(constant5 = +constant5),
+        transformSymlog2(constant5),
+        channels,
+        options
+    );
+}
+var transformIdentity = {
+    apply(x7) {
+        return x7;
+    },
+    invert(x7) {
+        return x7;
+    }
+};
+var transformLog2 = {
+    apply: Math.log,
+    invert: Math.exp
+};
+var transformSqrt2 = {
+    apply(x7) {
+        return Math.sign(x7) * Math.sqrt(Math.abs(x7));
+    },
+    invert(x7) {
+        return Math.sign(x7) * (x7 * x7);
+    }
+};
+
+function transformPow2(exponent3) {
+    return exponent3 === 0.5 ? transformSqrt2 : {
+        apply(x7) {
+            return Math.sign(x7) * Math.pow(Math.abs(x7), exponent3);
+        },
+        invert(x7) {
+            return Math.sign(x7) * Math.pow(Math.abs(x7), 1 / exponent3);
+        }
+    };
+}
+
+function transformSymlog2(constant5) {
+    return {
+        apply(x7) {
+            return Math.sign(x7) * Math.log1p(Math.abs(x7 / constant5));
+        },
+        invert(x7) {
+            return Math.sign(x7) * Math.expm1(Math.abs(x7)) * constant5;
+        }
+    };
+}
+
+// node_modules/@observablehq/plot/src/scales/temporal.js
+function createScaleT(key, scale5, channels, options) {
+    return createScaleQ(key, scale5, channels, options);
+}
+
+function createScaleTime(key, channels, options) {
+    return createScaleT(key, time(), channels, options);
+}
+
+function createScaleUtc(key, channels, options) {
+    return createScaleT(key, utcTime(), channels, options);
+}
+
+// node_modules/@observablehq/plot/src/scales/ordinal.js
+var ordinalImplicit = Symbol("ordinal");
+
+function createScaleO(key, scale5, channels, {
+    type: type3,
+    interval: interval3,
+    domain,
+    range: range9,
+    reverse: reverse5,
+    hint
+}) {
+    interval3 = maybeRangeInterval(interval3, type3);
+    if (domain === void 0)
+        domain = inferDomain2(channels, interval3, key);
+    if (type3 === "categorical" || type3 === ordinalImplicit)
+        type3 = "ordinal";
+    if (reverse5)
+        domain = reverse(domain);
+    scale5.domain(domain);
+    if (range9 !== void 0) {
+        if (typeof range9 === "function")
+            range9 = range9(domain);
+        scale5.range(range9);
+    }
+    return {
+        type: type3,
+        domain,
+        range: range9,
+        scale: scale5,
+        hint,
+        interval: interval3
+    };
+}
+
+function createScaleOrdinal(key, channels, {
+    type: type3,
+    interval: interval3,
+    domain,
+    range: range9,
+    scheme: scheme55,
+    unknown,
+    ...options
+}) {
+    interval3 = maybeRangeInterval(interval3, type3);
+    if (domain === void 0)
+        domain = inferDomain2(channels, interval3, key);
+    let hint;
+    if (registry.get(key) === symbol) {
+        hint = inferSymbolHint(channels);
+        range9 = range9 === void 0 ? inferSymbolRange(hint) : map4(range9, maybeSymbol);
+    } else if (registry.get(key) === color2) {
+        if (range9 === void 0 && (type3 === "ordinal" || type3 === ordinalImplicit)) {
+            range9 = maybeBooleanRange(domain, scheme55);
+            if (range9 !== void 0)
+                scheme55 = void 0;
+        }
+        if (scheme55 === void 0 && range9 === void 0) {
+            scheme55 = type3 === "ordinal" ? "turbo" : "tableau10";
+        }
+        if (scheme55 !== void 0) {
+            if (range9 !== void 0) {
+                const interpolate = quantitativeScheme(scheme55);
+                const t05 = range9[0],
+                    d = range9[1] - range9[0];
+                range9 = ({
+                    length: n
+                }) => quantize_default((t) => interpolate(t05 + d * t), n);
+            } else {
+                range9 = ordinalScheme(scheme55);
+            }
+        }
+    }
+    if (unknown === implicit) {
+        throw new Error(`implicit unknown on ${key} scale is not supported`);
+    }
+    return createScaleO(key, ordinal().unknown(unknown), channels, {
+        ...options,
+        type: type3,
+        domain,
+        range: range9,
+        hint
+    });
+}
+
+function createScalePoint(key, channels, {
+    align = 0.5,
+    padding = 0.5,
+    ...options
+}) {
+    return maybeRound(point().align(align).padding(padding), channels, options, key);
+}
+
+function createScaleBand(key, channels, {
+    align = 0.5,
+    padding = 0.1,
+    paddingInner = padding,
+    paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
+    ...options
+}) {
+    return maybeRound(
+        band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
+        channels,
+        options,
+        key
+    );
+}
+
+function maybeRound(scale5, channels, options, key) {
+    let {
+        round: round3
+    } = options;
+    if (round3 !== void 0)
+        scale5.round(round3 = !!round3);
+    scale5 = createScaleO(key, scale5, channels, options);
+    scale5.round = round3;
+    return scale5;
+}
+
+function inferDomain2(channels, interval3, key) {
+    const values3 = new InternSet();
+    for (const {
+            value,
+            domain
+        }
+        of channels) {
+        if (domain !== void 0)
+            return domain();
+        if (value === void 0)
+            continue;
+        for (const v3 of value)
+            values3.add(v3);
+    }
+    if (interval3 !== void 0) {
+        const [min7, max9] = extent(values3).map(interval3.floor, interval3);
+        return interval3.range(min7, interval3.offset(max9));
+    }
+    if (values3.size > 1e4 && registry.get(key) === position) {
+        throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
+    }
+    return sort(values3, ascendingDefined2);
+}
+
+function inferHint(channels, key) {
+    let value;
+    for (const {
+            hint
+        }
+        of channels) {
+        const candidate = hint?.[key];
+        if (candidate === void 0)
+            continue;
+        if (value === void 0)
+            value = candidate;
+        else if (value !== candidate)
+            return;
+    }
+    return value;
+}
+
+function inferSymbolHint(channels) {
+    return {
+        fill: inferHint(channels, "fill"),
+        stroke: inferHint(channels, "stroke")
+    };
+}
+
+function inferSymbolRange(hint) {
+    return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
+}
+
+// node_modules/@observablehq/plot/src/scales.js
+function createScales(channelsByScale, {
+    label: globalLabel,
+    inset: globalInset = 0,
+    insetTop: globalInsetTop = globalInset,
+    insetRight: globalInsetRight = globalInset,
+    insetBottom: globalInsetBottom = globalInset,
+    insetLeft: globalInsetLeft = globalInset,
+    round: round3,
+    nice: nice5,
+    clamp,
+    zero: zero5,
+    align,
+    padding,
+    projection: projection3,
+    facet: {
+        label: facetLabel = globalLabel
+    } = {},
+    ...options
+} = {}) {
+    const scales = {};
+    for (const [key, channels] of channelsByScale) {
+        const scaleOptions = options[key];
+        const scale5 = createScale(key, channels, {
+            round: registry.get(key) === position ? round3 : void 0,
+            // only for position
+            nice: nice5,
+            clamp,
+            zero: zero5,
+            align,
+            padding,
+            projection: projection3,
+            ...scaleOptions
+        });
+        if (scale5) {
+            let {
+                label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
+                    percent,
+                    transform: transform3,
+                    inset,
+                    insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
+                    // not fy
+                    insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
+                    // not fx
+                    insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
+                    // not fy
+                    insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
+                // not fx
+            } = scaleOptions || {};
+            if (transform3 == null)
+                transform3 = void 0;
+            else if (typeof transform3 !== "function")
+                throw new Error("invalid scale transform; not a function");
+            scale5.percent = !!percent;
+            scale5.label = label === void 0 ? inferScaleLabel(channels, scale5) : label;
+            scale5.transform = transform3;
+            if (key === "x" || key === "fx") {
+                scale5.insetLeft = +insetLeft;
+                scale5.insetRight = +insetRight;
+            } else if (key === "y" || key === "fy") {
+                scale5.insetTop = +insetTop;
+                scale5.insetBottom = +insetBottom;
+            }
+            scales[key] = scale5;
+        }
+    }
+    return scales;
+}
+
+function createScaleFunctions(scales) {
+    return Object.fromEntries(
+        Object.entries(scales).filter(([, {
+            scale: scale5
+        }]) => scale5).map(([name, {
+            scale: scale5,
+            type: type3,
+            interval: interval3,
+            label
+        }]) => {
+            scale5.type = type3;
+            if (interval3 != null)
+                scale5.interval = interval3;
+            if (label != null)
+                scale5.label = label;
+            return [name, scale5];
+        })
+    );
+}
+
+function autoScaleRange(scales, dimensions) {
+    const {
+        x: x7,
+        y: y7,
+        fx,
+        fy
+    } = scales;
+    const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
+    if (fx)
+        autoScaleRangeX(fx, superdimensions);
+    if (fy)
+        autoScaleRangeY(fy, superdimensions);
+    const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
+    if (x7)
+        autoScaleRangeX(x7, subdimensions);
+    if (y7)
+        autoScaleRangeY(y7, subdimensions);
+}
+
+function inferScaleLabel(channels = [], scale5) {
+    let label;
+    for (const {
+            label: l
+        }
+        of channels) {
+        if (l === void 0)
+            continue;
+        if (label === void 0)
+            label = l;
+        else if (label !== l)
+            return;
+    }
+    if (label === void 0)
+        return;
+    if (isTemporalScale(scale5) && /^(date|time|year)$/i.test(label))
+        return;
+    if (!isOrdinalScale(scale5) && scale5.percent)
+        label = `${label} (%)`;
+    return {
+        inferred: true,
+        toString: () => label
+    };
+}
+
+function outerDimensions(dimensions) {
+    const {
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft,
+        width,
+        height,
+        facet: {
+            marginTop: facetMarginTop,
+            marginRight: facetMarginRight,
+            marginBottom: facetMarginBottom,
+            marginLeft: facetMarginLeft
+        }
+    } = dimensions;
+    return {
+        marginTop: Math.max(marginTop, facetMarginTop),
+        marginRight: Math.max(marginRight, facetMarginRight),
+        marginBottom: Math.max(marginBottom, facetMarginBottom),
+        marginLeft: Math.max(marginLeft, facetMarginLeft),
+        width,
+        height
+    };
+}
+
+function innerDimensions({
+    fx,
+    fy
+}, dimensions) {
+    const {
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft,
+        width,
+        height
+    } = outerDimensions(dimensions);
+    return {
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft,
+        width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
+        height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height
+    };
+}
+
+function autoScaleRangeX(scale5, dimensions) {
+    if (scale5.range === void 0) {
+        const {
+            insetLeft,
+            insetRight
+        } = scale5;
+        const {
+            width,
+            marginLeft = 0,
+            marginRight = 0
+        } = dimensions;
+        const left3 = marginLeft + insetLeft;
+        const right3 = width - marginRight - insetRight;
+        scale5.range = [left3, Math.max(left3, right3)];
+        if (!isOrdinalScale(scale5))
+            scale5.range = piecewiseRange(scale5);
+        scale5.scale.range(scale5.range);
+    }
+    autoScaleRound(scale5);
+}
+
+function autoScaleRangeY(scale5, dimensions) {
+    if (scale5.range === void 0) {
+        const {
+            insetTop,
+            insetBottom
+        } = scale5;
+        const {
+            height,
+            marginTop = 0,
+            marginBottom = 0
+        } = dimensions;
+        const top3 = marginTop + insetTop;
+        const bottom3 = height - marginBottom - insetBottom;
+        scale5.range = [Math.max(top3, bottom3), top3];
+        if (!isOrdinalScale(scale5))
+            scale5.range = piecewiseRange(scale5);
+        else
+            scale5.range.reverse();
+        scale5.scale.range(scale5.range);
+    }
+    autoScaleRound(scale5);
+}
+
+function autoScaleRound(scale5) {
+    if (scale5.round === void 0 && isBandScale(scale5) && roundError(scale5) <= 30) {
+        scale5.scale.round(true);
+    }
+}
+
+function roundError({
+    scale: scale5
+}) {
+    const n = scale5.domain().length;
+    const [start3, stop] = scale5.range();
+    const paddingInner = scale5.paddingInner ? scale5.paddingInner() : 1;
+    const paddingOuter = scale5.paddingOuter ? scale5.paddingOuter() : scale5.padding();
+    const m5 = n - paddingInner;
+    const step = Math.abs(stop - start3) / Math.max(1, m5 + paddingOuter * 2);
+    return (step - Math.floor(step)) * m5;
+}
+
+function piecewiseRange(scale5) {
+    const length7 = scale5.scale.domain().length + isThresholdScale(scale5);
+    if (!(length7 > 2))
+        return scale5.range;
+    const [start3, end] = scale5.range;
+    return Array.from({
+        length: length7
+    }, (_, i) => start3 + i / (length7 - 1) * (end - start3));
+}
+
+function normalizeScale(key, scale5, hint) {
+    return createScale(key, hint === void 0 ? void 0 : [{
+        hint
+    }], {
+        ...scale5
+    });
+}
+
+function createScale(key, channels = [], options = {}) {
+    const type3 = inferScaleType(key, channels, options);
+    if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({
+            type: type3
+        })) {
+        const values3 = channels.map(({
+            value
+        }) => value).filter((value) => value !== void 0);
+        if (values3.some(isTemporal))
+            warn(
+                `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
+          type3
+        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
+          type3
+        )}".`
+            );
+        else if (values3.some(isTemporalString))
+            warn(
+                `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
+          type3
+        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
+          type3
+        )}".`
+            );
+        else if (values3.some(isNumericString))
+            warn(
+                `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
+          type3
+        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
+          type3
+        )}".`
+            );
+    }
+    options.type = type3;
+    switch (type3) {
+        case "diverging":
+        case "diverging-sqrt":
+        case "diverging-pow":
+        case "diverging-log":
+        case "diverging-symlog":
+        case "cyclical":
+        case "sequential":
+        case "linear":
+        case "sqrt":
+        case "threshold":
+        case "quantile":
+        case "pow":
+        case "log":
+        case "symlog":
+            options = coerceType(channels, options, coerceNumbers);
+            break;
+        case "identity":
+            switch (registry.get(key)) {
+                case position:
+                    options = coerceType(channels, options, coerceNumbers);
+                    break;
+                case symbol:
+                    options = coerceType(channels, options, coerceSymbols);
+                    break;
+            }
+            break;
+        case "utc":
+        case "time":
+            options = coerceType(channels, options, coerceDates);
+            break;
+    }
+    switch (type3) {
+        case "diverging":
+            return createScaleDiverging(key, channels, options);
+        case "diverging-sqrt":
+            return createScaleDivergingSqrt(key, channels, options);
+        case "diverging-pow":
+            return createScaleDivergingPow(key, channels, options);
+        case "diverging-log":
+            return createScaleDivergingLog(key, channels, options);
+        case "diverging-symlog":
+            return createScaleDivergingSymlog(key, channels, options);
+        case "categorical":
+        case "ordinal":
+        case ordinalImplicit:
+            return createScaleOrdinal(key, channels, options);
+        case "cyclical":
+        case "sequential":
+        case "linear":
+            return createScaleLinear(key, channels, options);
+        case "sqrt":
+            return createScaleSqrt(key, channels, options);
+        case "threshold":
+            return createScaleThreshold(key, channels, options);
+        case "quantile":
+            return createScaleQuantile(key, channels, options);
+        case "quantize":
+            return createScaleQuantize(key, channels, options);
+        case "pow":
+            return createScalePow(key, channels, options);
+        case "log":
+            return createScaleLog(key, channels, options);
+        case "symlog":
+            return createScaleSymlog(key, channels, options);
+        case "utc":
+            return createScaleUtc(key, channels, options);
+        case "time":
+            return createScaleTime(key, channels, options);
+        case "point":
+            return createScalePoint(key, channels, options);
+        case "band":
+            return createScaleBand(key, channels, options);
+        case "identity":
+            return registry.get(key) === position ? createScaleIdentity() : {
+                type: "identity"
+            };
+        case void 0:
+            return;
+        default:
+            throw new Error(`unknown scale type: ${type3}`);
+    }
+}
+
+function formatScaleType(type3) {
+    return typeof type3 === "symbol" ? type3.description : type3;
+}
+var typeProjection = {
+    toString: () => "projection"
+};
+
+function inferScaleType(key, channels, {
+    type: type3,
+    domain,
+    range: range9,
+    scheme: scheme55,
+    pivot,
+    projection: projection3
+}) {
+    if (key === "fx" || key === "fy")
+        return "band";
+    if ((key === "x" || key === "y") && projection3 != null)
+        type3 = typeProjection;
+    for (const {
+            type: t
+        }
+        of channels) {
+        if (t === void 0)
+            continue;
+        else if (type3 === void 0)
+            type3 = t;
+        else if (type3 !== t)
+            throw new Error(`scale incompatible with channel: ${type3} !== ${t}`);
+    }
+    if (type3 === typeProjection)
+        return;
+    if (type3 !== void 0)
+        return type3;
+    if (domain === void 0 && !channels.some(({
+            value
+        }) => value !== void 0))
+        return;
+    const kind = registry.get(key);
+    if (kind === radius)
+        return "sqrt";
+    if (kind === opacity || kind === length3)
+        return "linear";
+    if (kind === symbol)
+        return "ordinal";
+    if ((domain || range9 || []).length > 2)
+        return asOrdinalType(kind);
+    if (domain !== void 0) {
+        if (isOrdinal(domain))
+            return asOrdinalType(kind);
+        if (isTemporal(domain))
+            return "utc";
+        if (kind === color2 && (pivot != null || isDivergingScheme(scheme55)))
+            return "diverging";
+        return "linear";
+    }
+    const values3 = channels.map(({
+        value
+    }) => value).filter((value) => value !== void 0);
+    if (values3.some(isOrdinal))
+        return asOrdinalType(kind);
+    if (values3.some(isTemporal))
+        return "utc";
+    if (kind === color2 && (pivot != null || isDivergingScheme(scheme55)))
+        return "diverging";
+    return "linear";
+}
+
+function asOrdinalType(kind) {
+    switch (kind) {
+        case position:
+            return "point";
+        case color2:
+            return ordinalImplicit;
+        default:
+            return "ordinal";
+    }
+}
+
+function isTemporalScale({
+    type: type3
+}) {
+    return type3 === "time" || type3 === "utc";
+}
+
+function isOrdinalScale({
+    type: type3
+}) {
+    return type3 === "ordinal" || type3 === "point" || type3 === "band" || type3 === ordinalImplicit;
+}
+
+function isThresholdScale({
+    type: type3
+}) {
+    return type3 === "threshold";
+}
+
+function isBandScale({
+    type: type3
+}) {
+    return type3 === "point" || type3 === "band";
+}
+
+function isCollapsed(scale5) {
+    if (scale5 === void 0)
+        return true;
+    const domain = scale5.domain();
+    const value = scale5(domain[0]);
+    for (let i = 1, n = domain.length; i < n; ++i) {
+        if (scale5(domain[i]) - value) {
+            return false;
+        }
+    }
+    return true;
+}
+
+function coerceType(channels, {
+    domain,
+    ...options
+}, coerceValues) {
+    for (const c11 of channels) {
+        if (c11.value !== void 0) {
+            c11.value = coerceValues(c11.value);
+        }
+    }
+    return {
+        domain: domain === void 0 ? domain : coerceValues(domain),
+        ...options
+    };
+}
+
+function coerceSymbols(values3) {
+    return map4(values3, maybeSymbol);
+}
+
+function scale2(options = {}) {
+    let scale5;
+    for (const key in options) {
+        if (!registry.has(key))
+            continue;
+        if (!isScaleOptions(options[key]))
+            continue;
+        if (scale5 !== void 0)
+            throw new Error("ambiguous scale definition; multiple scales found");
+        scale5 = exposeScale(normalizeScale(key, options[key]));
+    }
+    if (scale5 === void 0)
+        throw new Error("invalid scale definition; no scale found");
+    return scale5;
+}
+
+function exposeScales(scaleDescriptors) {
+    return (key) => {
+        if (!registry.has(key = `${key}`))
+            throw new Error(`unknown scale: ${key}`);
+        return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;
+    };
+}
+
+function exposeScale({
+    scale: scale5,
+    type: type3,
+    domain,
+    range: range9,
+    interpolate,
+    interval: interval3,
+    transform: transform3,
+    percent,
+    pivot
+}) {
+    if (type3 === "identity")
+        return {
+            type: "identity",
+            apply: (d) => d,
+            invert: (d) => d
+        };
+    const unknown = scale5.unknown ? scale5.unknown() : void 0;
+    return {
+        type: type3,
+        domain: slice5(domain),
+        // defensive copy
+        ...range9 !== void 0 && {
+            range: slice5(range9)
+        },
+        // defensive copy
+        ...transform3 !== void 0 && {
+            transform: transform3
+        },
+        ...percent && {
+            percent
+        },
+        // only exposed if truthy
+        ...unknown !== void 0 && {
+            unknown
+        },
+        ...interval3 !== void 0 && {
+            interval: interval3
+        },
+        // quantitative
+        ...interpolate !== void 0 && {
+            interpolate
+        },
+        ...scale5.clamp && {
+            clamp: scale5.clamp()
+        },
+        // diverging (always asymmetric; we never want to apply the symmetric transform twice)
+        ...pivot !== void 0 && {
+            pivot,
+            symmetric: false
+        },
+        // log, diverging-log
+        ...scale5.base && {
+            base: scale5.base()
+        },
+        // pow, diverging-pow
+        ...scale5.exponent && {
+            exponent: scale5.exponent()
+        },
+        // symlog, diverging-symlog
+        ...scale5.constant && {
+            constant: scale5.constant()
+        },
+        // band, point
+        ...scale5.align && {
+            align: scale5.align(),
+            round: scale5.round()
+        },
+        ...scale5.padding && (scale5.paddingInner ? {
+            paddingInner: scale5.paddingInner(),
+            paddingOuter: scale5.paddingOuter()
+        } : {
+            padding: scale5.padding()
+        }),
+        ...scale5.bandwidth && {
+            bandwidth: scale5.bandwidth(),
+            step: scale5.step()
+        },
+        // utilities
+        apply: (t) => scale5(t),
+        ...scale5.invert && {
+            invert: (t) => scale5.invert(t)
+        }
+    };
+}
+
+// node_modules/@observablehq/plot/src/memoize.js
+function memoize1(compute) {
+    let cacheValue, cacheKeys;
+    return (...keys) => {
+        if (cacheKeys?.length !== keys.length || cacheKeys.some((k3, i) => k3 !== keys[i])) {
+            cacheKeys = keys;
+            cacheValue = compute(...keys);
+        }
+        return cacheValue;
+    };
+}
+
+// node_modules/@observablehq/plot/src/format.js
+var numberFormat = memoize1((locale5) => {
+    return new Intl.NumberFormat(locale5);
+});
+var monthFormat = memoize1((locale5, month) => {
+    return new Intl.DateTimeFormat(locale5, {
+        timeZone: "UTC",
+        ...month && {
+            month
+        }
+    });
+});
+var weekdayFormat = memoize1((locale5, weekday) => {
+    return new Intl.DateTimeFormat(locale5, {
+        timeZone: "UTC",
+        ...weekday && {
+            weekday
+        }
+    });
+});
+
+function formatNumber(locale5 = "en-US") {
+    const format5 = numberFormat(locale5);
+    return (i) => i != null && !isNaN(i) ? format5.format(i) : void 0;
+}
+
+function formatMonth(locale5 = "en-US", format5 = "short") {
+    const fmt = monthFormat(locale5, format5);
+    return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;
+}
+
+function formatWeekday(locale5 = "en-US", format5 = "short") {
+    const fmt = weekdayFormat(locale5, format5);
+    return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;
+}
+
+function formatIsoDate(date3) {
+    return format2(date3, "Invalid Date");
+}
+
+function formatAuto(locale5 = "en-US") {
+    const number14 = formatNumber(locale5);
+    return (v3) => (v3 instanceof Date ? formatIsoDate : typeof v3 === "number" ? number14 : string)(v3);
+}
+var formatDefault = formatAuto();
+
+// node_modules/@observablehq/plot/src/style.js
+var offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5;
+var nextClipId = 0;
+
+function getClipId() {
+    return `plot-clip-${++nextClipId}`;
+}
+
+function styles(mark, {
+    title,
+    href,
+    ariaLabel: variaLabel,
+    ariaDescription,
+    ariaHidden,
+    target,
+    fill,
+    fillOpacity,
+    stroke,
+    strokeWidth,
+    strokeOpacity,
+    strokeLinejoin,
+    strokeLinecap,
+    strokeMiterlimit,
+    strokeDasharray,
+    strokeDashoffset,
+    opacity: opacity3,
+    mixBlendMode,
+    paintOrder,
+    pointerEvents,
+    shapeRendering
+}, {
+    ariaLabel: cariaLabel,
+    fill: defaultFill = "currentColor",
+    fillOpacity: defaultFillOpacity,
+    stroke: defaultStroke = "none",
+    strokeOpacity: defaultStrokeOpacity,
+    strokeWidth: defaultStrokeWidth,
+    strokeLinecap: defaultStrokeLinecap,
+    strokeLinejoin: defaultStrokeLinejoin,
+    strokeMiterlimit: defaultStrokeMiterlimit,
+    paintOrder: defaultPaintOrder
+}) {
+    if (defaultFill === null) {
+        fill = null;
+        fillOpacity = null;
+    }
+    if (defaultStroke === null) {
+        stroke = null;
+        strokeOpacity = null;
+    }
+    if (isNoneish(defaultFill)) {
+        if (!isNoneish(defaultStroke) && !isNoneish(fill))
+            defaultStroke = "none";
+    } else {
+        if (isNoneish(defaultStroke) && !isNoneish(stroke))
+            defaultFill = "none";
+    }
+    const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
+    const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
+    const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
+    const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
+    const [vopacity, copacity] = maybeNumberChannel(opacity3);
+    if (!isNone(cstroke)) {
+        if (strokeWidth === void 0)
+            strokeWidth = defaultStrokeWidth;
+        if (strokeLinecap === void 0)
+            strokeLinecap = defaultStrokeLinecap;
+        if (strokeLinejoin === void 0)
+            strokeLinejoin = defaultStrokeLinejoin;
+        if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
+            strokeMiterlimit = defaultStrokeMiterlimit;
+        if (!isNone(cfill) && paintOrder === void 0)
+            paintOrder = defaultPaintOrder;
+    }
+    const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
+    if (defaultFill !== null) {
+        mark.fill = impliedString(cfill, "currentColor");
+        mark.fillOpacity = impliedNumber(cfillOpacity, 1);
+    }
+    if (defaultStroke !== null) {
+        mark.stroke = impliedString(cstroke, "none");
+        mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
+        mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
+        mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
+        mark.strokeLinecap = impliedString(strokeLinecap, "butt");
+        mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
+        mark.strokeDasharray = impliedString(strokeDasharray, "none");
+        mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
+    }
+    mark.target = string(target);
+    mark.ariaLabel = string(cariaLabel);
+    mark.ariaDescription = string(ariaDescription);
+    mark.ariaHidden = string(ariaHidden);
+    mark.opacity = impliedNumber(copacity, 1);
+    mark.mixBlendMode = impliedString(mixBlendMode, "normal");
+    mark.paintOrder = impliedString(paintOrder, "normal");
+    mark.pointerEvents = impliedString(pointerEvents, "auto");
+    mark.shapeRendering = impliedString(shapeRendering, "auto");
+    return {
+        title: {
+            value: title,
+            optional: true
+        },
+        href: {
+            value: href,
+            optional: true
+        },
+        ariaLabel: {
+            value: variaLabel,
+            optional: true
+        },
+        fill: {
+            value: vfill,
+            scale: "auto",
+            optional: true
+        },
+        fillOpacity: {
+            value: vfillOpacity,
+            scale: "auto",
+            optional: true
+        },
+        stroke: {
+            value: vstroke,
+            scale: "auto",
+            optional: true
+        },
+        strokeOpacity: {
+            value: vstrokeOpacity,
+            scale: "auto",
+            optional: true
+        },
+        strokeWidth: {
+            value: vstrokeWidth,
+            optional: true
+        },
+        opacity: {
+            value: vopacity,
+            scale: "auto",
+            optional: true
+        }
+    };
+}
+
+function applyTitle(selection3, L) {
+    if (L)
+        selection3.filter((i) => nonempty(L[i])).append("title").call(applyText, L);
+}
+
+function applyTitleGroup(selection3, L) {
+    if (L)
+        selection3.filter(([i]) => nonempty(L[i])).append("title").call(applyTextGroup, L);
+}
+
+function applyText(selection3, T) {
+    if (T)
+        selection3.text((i) => formatDefault(T[i]));
+}
+
+function applyTextGroup(selection3, T) {
+    if (T)
+        selection3.text(([i]) => formatDefault(T[i]));
+}
+
+function applyChannelStyles(selection3, {
+    target
+}, {
+    ariaLabel: AL,
+    title: T,
+    fill: F,
+    fillOpacity: FO,
+    stroke: S,
+    strokeOpacity: SO,
+    strokeWidth: SW,
+    opacity: O,
+    href: H
+}) {
+    if (AL)
+        applyAttr(selection3, "aria-label", (i) => AL[i]);
+    if (F)
+        applyAttr(selection3, "fill", (i) => F[i]);
+    if (FO)
+        applyAttr(selection3, "fill-opacity", (i) => FO[i]);
+    if (S)
+        applyAttr(selection3, "stroke", (i) => S[i]);
+    if (SO)
+        applyAttr(selection3, "stroke-opacity", (i) => SO[i]);
+    if (SW)
+        applyAttr(selection3, "stroke-width", (i) => SW[i]);
+    if (O)
+        applyAttr(selection3, "opacity", (i) => O[i]);
+    if (H)
+        applyHref(selection3, (i) => H[i], target);
+    applyTitle(selection3, T);
+}
+
+function applyGroupedChannelStyles(selection3, {
+    target
+}, {
+    ariaLabel: AL,
+    title: T,
+    fill: F,
+    fillOpacity: FO,
+    stroke: S,
+    strokeOpacity: SO,
+    strokeWidth: SW,
+    opacity: O,
+    href: H
+}) {
+    if (AL)
+        applyAttr(selection3, "aria-label", ([i]) => AL[i]);
+    if (F)
+        applyAttr(selection3, "fill", ([i]) => F[i]);
+    if (FO)
+        applyAttr(selection3, "fill-opacity", ([i]) => FO[i]);
+    if (S)
+        applyAttr(selection3, "stroke", ([i]) => S[i]);
+    if (SO)
+        applyAttr(selection3, "stroke-opacity", ([i]) => SO[i]);
+    if (SW)
+        applyAttr(selection3, "stroke-width", ([i]) => SW[i]);
+    if (O)
+        applyAttr(selection3, "opacity", ([i]) => O[i]);
+    if (H)
+        applyHref(selection3, ([i]) => H[i], target);
+    applyTitleGroup(selection3, T);
+}
+
+function groupAesthetics({
+    ariaLabel: AL,
+    title: T,
+    fill: F,
+    fillOpacity: FO,
+    stroke: S,
+    strokeOpacity: SO,
+    strokeWidth: SW,
+    opacity: O,
+    href: H
+}) {
+    return [AL, T, F, FO, S, SO, SW, O, H].filter((c11) => c11 !== void 0);
+}
+
+function groupZ2(I, Z, z) {
+    const G = group(I, (i) => Z[i]);
+    if (z === void 0 && G.size > I.length >> 1) {
+        warn(
+            `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
+        );
+    }
+    return G.values();
+}
+
+function* groupIndex(I, position3, {
+    z
+}, channels) {
+    const {
+        z: Z
+    } = channels;
+    const A6 = groupAesthetics(channels);
+    const C4 = [...position3, ...A6];
+    for (const G of Z ? groupZ2(I, Z, z) : [I]) {
+        let Ag;
+        let Gg;
+        out:
+            for (const i of G) {
+                for (const c11 of C4) {
+                    if (!defined(c11[i])) {
+                        if (Gg)
+                            Gg.push(-1);
+                        continue out;
+                    }
+                }
+                if (Ag === void 0) {
+                    if (Gg)
+                        yield Gg;
+                    Ag = A6.map((c11) => keyof2(c11[i])), Gg = [i];
+                    continue;
+                }
+                Gg.push(i);
+                for (let j = 0; j < A6.length; ++j) {
+                    const k3 = keyof2(A6[j][i]);
+                    if (k3 !== Ag[j]) {
+                        yield Gg;
+                        Ag = A6.map((c11) => keyof2(c11[i])), Gg = [i];
+                        continue out;
+                    }
+                }
+            }
+        if (Gg)
+            yield Gg;
+    }
+}
+
+function maybeClip(clip) {
+    if (clip === true)
+        clip = "frame";
+    else if (clip === false)
+        clip = null;
+    return maybeKeyword(clip, "clip", ["frame", "sphere"]);
+}
+
+function applyClip(selection3, mark, dimensions, context) {
+    let clipUrl;
+    switch (mark.clip) {
+        case "frame": {
+            const {
+                width,
+                height,
+                marginLeft,
+                marginRight,
+                marginTop,
+                marginBottom
+            } = dimensions;
+            const id3 = getClipId();
+            clipUrl = `url(#${id3})`;
+            selection3 = create2("svg:g", context).call(
+                (g) => g.append("svg:clipPath").attr("id", id3).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
+            ).each(function() {
+                this.appendChild(selection3.node());
+                selection3.node = () => this;
+            });
+            break;
+        }
+        case "sphere": {
+            const {
+                projection: projection3
+            } = context;
+            if (!projection3)
+                throw new Error(`the "sphere" clip option requires a projection`);
+            const id3 = getClipId();
+            clipUrl = `url(#${id3})`;
+            selection3.append("clipPath").attr("id", id3).append("path").attr("d", path_default(projection3)({
+                type: "Sphere"
+            }));
+            break;
+        }
+    }
+    applyAttr(selection3, "aria-label", mark.ariaLabel);
+    applyAttr(selection3, "aria-description", mark.ariaDescription);
+    applyAttr(selection3, "aria-hidden", mark.ariaHidden);
+    applyAttr(selection3, "clip-path", clipUrl);
+}
+
+function applyIndirectStyles(selection3, mark, dimensions, context) {
+    applyClip(selection3, mark, dimensions, context);
+    applyAttr(selection3, "fill", mark.fill);
+    applyAttr(selection3, "fill-opacity", mark.fillOpacity);
+    applyAttr(selection3, "stroke", mark.stroke);
+    applyAttr(selection3, "stroke-width", mark.strokeWidth);
+    applyAttr(selection3, "stroke-opacity", mark.strokeOpacity);
+    applyAttr(selection3, "stroke-linejoin", mark.strokeLinejoin);
+    applyAttr(selection3, "stroke-linecap", mark.strokeLinecap);
+    applyAttr(selection3, "stroke-miterlimit", mark.strokeMiterlimit);
+    applyAttr(selection3, "stroke-dasharray", mark.strokeDasharray);
+    applyAttr(selection3, "stroke-dashoffset", mark.strokeDashoffset);
+    applyAttr(selection3, "shape-rendering", mark.shapeRendering);
+    applyAttr(selection3, "paint-order", mark.paintOrder);
+    applyAttr(selection3, "pointer-events", mark.pointerEvents);
+}
+
+function applyDirectStyles(selection3, mark) {
+    applyStyle(selection3, "mix-blend-mode", mark.mixBlendMode);
+    applyAttr(selection3, "opacity", mark.opacity);
+}
+
+function applyHref(selection3, href, target) {
+    selection3.each(function(i) {
+        const h = href(i);
+        if (h != null) {
+            const a7 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
+            a7.setAttribute("fill", "inherit");
+            a7.setAttributeNS(namespaces_default.xlink, "href", h);
+            if (target != null)
+                a7.setAttribute("target", target);
+            this.parentNode.insertBefore(a7, this).appendChild(this);
+        }
+    });
+}
+
+function applyAttr(selection3, name, value) {
+    if (value != null)
+        selection3.attr(name, value);
+}
+
+function applyStyle(selection3, name, value) {
+    if (value != null)
+        selection3.style(name, value);
+}
+
+function applyTransform(selection3, mark, {
+    x: x7,
+    y: y7
+}, tx = offset, ty = offset) {
+    tx += mark.dx;
+    ty += mark.dy;
+    if (x7?.bandwidth)
+        tx += x7.bandwidth() / 2;
+    if (y7?.bandwidth)
+        ty += y7.bandwidth() / 2;
+    if (tx || ty)
+        selection3.attr("transform", `translate(${tx},${ty})`);
+}
+
+function impliedString(value, impliedValue) {
+    if ((value = string(value)) !== impliedValue)
+        return value;
+}
+
+function impliedNumber(value, impliedValue) {
+    if ((value = number5(value)) !== impliedValue)
+        return value;
+}
+var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
+
+function maybeClassName(name) {
+    if (name === void 0)
+        return `plot-${Math.random().toString(16).slice(2)}`;
+    name = `${name}`;
+    if (!validClassName.test(name))
+        throw new Error(`invalid class name: ${name}`);
+    return name;
+}
+
+function applyInlineStyles(selection3, style) {
+    if (typeof style === "string") {
+        selection3.property("style", style);
+    } else if (style != null) {
+        for (const element of selection3) {
+            Object.assign(element.style, style);
+        }
+    }
+}
+
+function applyFrameAnchor({
+    frameAnchor
+}, {
+    width,
+    height,
+    marginTop,
+    marginRight,
+    marginBottom,
+    marginLeft
+}) {
+    return [
+        /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
+        /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
+    ];
+}
+
+// node_modules/@observablehq/plot/src/dimensions.js
+function createDimensions(scales, marks3, options = {}) {
+    let marginTopDefault = 0.5 - offset,
+        marginRightDefault = 0.5 + offset,
+        marginBottomDefault = 0.5 + offset,
+        marginLeftDefault = 0.5 - offset;
+    for (const {
+            marginTop: marginTop2,
+            marginRight: marginRight2,
+            marginBottom: marginBottom2,
+            marginLeft: marginLeft2
+        }
+        of marks3) {
+        if (marginTop2 > marginTopDefault)
+            marginTopDefault = marginTop2;
+        if (marginRight2 > marginRightDefault)
+            marginRightDefault = marginRight2;
+        if (marginBottom2 > marginBottomDefault)
+            marginBottomDefault = marginBottom2;
+        if (marginLeft2 > marginLeftDefault)
+            marginLeftDefault = marginLeft2;
+    }
+    let {
+        margin,
+        marginTop = margin !== void 0 ? margin : marginTopDefault,
+        marginRight = margin !== void 0 ? margin : marginRightDefault,
+        marginBottom = margin !== void 0 ? margin : marginBottomDefault,
+        marginLeft = margin !== void 0 ? margin : marginLeftDefault
+    } = options;
+    marginTop = +marginTop;
+    marginRight = +marginRight;
+    marginBottom = +marginBottom;
+    marginLeft = +marginLeft;
+    let {
+        width = 640,
+            height = autoHeight(scales, marks3, options, {
+                width,
+                marginTopDefault,
+                marginRightDefault,
+                marginBottomDefault,
+                marginLeftDefault
+            }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
+    } = options;
+    width = +width;
+    height = +height;
+    const dimensions = {
+        width,
+        height,
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft
+    };
+    if (scales.fx || scales.fy) {
+        let {
+            margin: facetMargin,
+            marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
+            marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
+            marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
+            marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
+        } = options.facet ?? {};
+        facetMarginTop = +facetMarginTop;
+        facetMarginRight = +facetMarginRight;
+        facetMarginBottom = +facetMarginBottom;
+        facetMarginLeft = +facetMarginLeft;
+        dimensions.facet = {
+            marginTop: facetMarginTop,
+            marginRight: facetMarginRight,
+            marginBottom: facetMarginBottom,
+            marginLeft: facetMarginLeft
+        };
+    }
+    return dimensions;
+}
+
+function autoHeight({
+    x: x7,
+    y: y7,
+    fy,
+    fx
+}, marks3, {
+    projection: projection3,
+    aspectRatio
+}, {
+    width,
+    marginTopDefault,
+    marginRightDefault,
+    marginBottomDefault,
+    marginLeftDefault
+}) {
+    const nfy = fy ? fy.scale.domain().length : 1;
+    const ar = projectionAspectRatio(projection3, marks3);
+    if (ar) {
+        const nfx = fx ? fx.scale.domain().length : 1;
+        const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
+        const lar = Math.max(0.1, Math.min(10, far));
+        return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
+    }
+    const ny = y7 ? isOrdinalScale(y7) ? y7.scale.domain().length : Math.max(7, 17 / nfy) : 1;
+    if (aspectRatio != null) {
+        aspectRatio = +aspectRatio;
+        if (!(isFinite(aspectRatio) && aspectRatio > 0))
+            throw new Error(`invalid aspectRatio: ${aspectRatio}`);
+        const ratio = aspectRatioLength("y", y7) / (aspectRatioLength("x", x7) * aspectRatio);
+        const fxb = fx ? fx.scale.bandwidth() : 1;
+        const fyb = fy ? fy.scale.bandwidth() : 1;
+        const w = fxb * (width - marginLeftDefault - marginRightDefault) - x7.insetLeft - x7.insetRight;
+        return (ratio * w + y7.insetTop + y7.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
+    }
+    return !!(y7 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
+}
+
+function aspectRatioLength(k3, scale5) {
+    if (!scale5)
+        throw new Error(`aspectRatio requires ${k3} scale`);
+    const {
+        type: type3,
+        domain
+    } = scale5;
+    let transform3;
+    switch (type3) {
+        case "linear":
+        case "utc":
+        case "time":
+            transform3 = Number;
+            break;
+        case "pow": {
+            const exponent3 = scale5.scale.exponent();
+            transform3 = (x7) => Math.pow(x7, exponent3);
+            break;
+        }
+        case "log":
+            transform3 = Math.log;
+            break;
+        case "point":
+        case "band":
+            return domain.length;
+        default:
+            throw new Error(`unsupported ${k3} scale for aspectRatio: ${type3}`);
+    }
+    const [min7, max9] = extent(domain);
+    return Math.abs(transform3(max9) - transform3(min7));
+}
+
+// node_modules/@observablehq/plot/src/facet.js
+function createFacets(channelsByScale, options) {
+    const {
+        fx,
+        fy
+    } = createScales(channelsByScale, options);
+    const fxDomain = fx?.scale.domain();
+    const fyDomain = fy?.scale.domain();
+    return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x7, y7], i) => ({
+        x: x7,
+        y: y7,
+        i
+    })) : fxDomain ? fxDomain.map((x7, i) => ({
+        x: x7,
+        i
+    })) : fyDomain ? fyDomain.map((y7, i) => ({
+        y: y7,
+        i
+    })) : void 0;
+}
+
+function facetOrder({
+    x: X4,
+    y: Y4
+}) {
+    const xi = X4 && new Map(X4.map((v3, i) => [v3, i]));
+    const yi = Y4 && new Map(Y4.map((v3, i) => [v3, i]));
+    return X4 && Y4 ? (a7, b) => xi.get(a7.x) - xi.get(b.x) || yi.get(a7.y) - yi.get(b.y) : X4 ? (a7, b) => xi.get(a7.x) - xi.get(b.x) : (a7, b) => yi.get(a7.y) - yi.get(b.y);
+}
+
+function facetGroups(data, {
+    fx,
+    fy
+}) {
+    const I = range4(data);
+    const FX = fx?.value;
+    const FY = fy?.value;
+    return fx && fy ? rollup(
+        I,
+        (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
+        (i) => FX[i],
+        (i) => FY[i]
+    ) : fx ? rollup(
+        I,
+        (G) => (G.fx = FX[G[0]], G),
+        (i) => FX[i]
+    ) : rollup(
+        I,
+        (G) => (G.fy = FY[G[0]], G),
+        (i) => FY[i]
+    );
+}
+
+function facetTranslate(fx, fy, {
+    marginTop,
+    marginLeft
+}) {
+    return fx && fy ? ({
+        x: x7,
+        y: y7
+    }) => `translate(${fx(x7) - marginLeft},${fy(y7) - marginTop})` : fx ? ({
+        x: x7
+    }) => `translate(${fx(x7) - marginLeft},0)` : ({
+        y: y7
+    }) => `translate(0,${fy(y7) - marginTop})`;
+}
+
+function facetExclude(index5) {
+    const ex = [];
+    const e = new Uint32Array(sum(index5, (d) => d.length));
+    for (const i of index5) {
+        let n = 0;
+        for (const j of index5) {
+            if (i === j)
+                continue;
+            e.set(j, n);
+            n += j.length;
+        }
+        ex.push(e.slice(0, n));
+    }
+    return ex;
+}
+var facetAnchors = /* @__PURE__ */ new Map([
+    ["top", facetAnchorTop],
+    ["right", facetAnchorRight],
+    ["bottom", facetAnchorBottom],
+    ["left", facetAnchorLeft],
+    ["top-left", and(facetAnchorTop, facetAnchorLeft)],
+    ["top-right", and(facetAnchorTop, facetAnchorRight)],
+    ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
+    ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
+    ["top-empty", facetAnchorTopEmpty],
+    ["right-empty", facetAnchorRightEmpty],
+    ["bottom-empty", facetAnchorBottomEmpty],
+    ["left-empty", facetAnchorLeftEmpty],
+    ["empty", facetAnchorEmpty]
+]);
+
+function maybeFacetAnchor(facetAnchor) {
+    if (facetAnchor == null)
+        return null;
+    const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
+    if (anchor)
+        return anchor;
+    throw new Error(`invalid facet anchor: ${facetAnchor}`);
+}
+
+function facetAnchorTop(facets, {
+    y: Y4
+}, {
+    y: y7
+}) {
+    return Y4 ? Y4.indexOf(y7) === 0 : true;
+}
+
+function facetAnchorBottom(facets, {
+    y: Y4
+}, {
+    y: y7
+}) {
+    return Y4 ? Y4.indexOf(y7) === Y4.length - 1 : true;
+}
+
+function facetAnchorLeft(facets, {
+    x: X4
+}, {
+    x: x7
+}) {
+    return X4 ? X4.indexOf(x7) === 0 : true;
+}
+
+function facetAnchorRight(facets, {
+    x: X4
+}, {
+    x: x7
+}) {
+    return X4 ? X4.indexOf(x7) === X4.length - 1 : true;
+}
+
+function facetAnchorTopEmpty(facets, {
+    y: Y4
+}, {
+    x: x7,
+    y: y7,
+    empty: empty7
+}) {
+    if (empty7)
+        return false;
+    const i = Y4?.indexOf(y7);
+    if (i > 0) {
+        const y8 = Y4[i - 1];
+        return facets.find((f) => f.x === x7 && f.y === y8)?.empty;
+    }
+}
+
+function facetAnchorBottomEmpty(facets, {
+    y: Y4
+}, {
+    x: x7,
+    y: y7,
+    empty: empty7
+}) {
+    if (empty7)
+        return false;
+    const i = Y4?.indexOf(y7);
+    if (i < Y4?.length - 1) {
+        const y8 = Y4[i + 1];
+        return facets.find((f) => f.x === x7 && f.y === y8)?.empty;
+    }
+}
+
+function facetAnchorLeftEmpty(facets, {
+    x: X4
+}, {
+    x: x7,
+    y: y7,
+    empty: empty7
+}) {
+    if (empty7)
+        return false;
+    const i = X4?.indexOf(x7);
+    if (i > 0) {
+        const x8 = X4[i - 1];
+        return facets.find((f) => f.x === x8 && f.y === y7)?.empty;
+    }
+}
+
+function facetAnchorRightEmpty(facets, {
+    x: X4
+}, {
+    x: x7,
+    y: y7,
+    empty: empty7
+}) {
+    if (empty7)
+        return false;
+    const i = X4?.indexOf(x7);
+    if (i < X4?.length - 1) {
+        const x8 = X4[i + 1];
+        return facets.find((f) => f.x === x8 && f.y === y7)?.empty;
+    }
+}
+
+function facetAnchorEmpty(facets, channels, {
+    empty: empty7
+}) {
+    return empty7;
+}
+
+function and(a7, b) {
+    return function() {
+        return a7.apply(null, arguments) && b.apply(null, arguments);
+    };
+}
+
+function facetFilter(facets, {
+    channels: {
+        fx,
+        fy
+    },
+    groups: groups3
+}) {
+    return fx && fy ? facets.map(({
+        x: x7,
+        y: y7
+    }) => groups3.get(x7)?.get(y7) ?? []) : fx ? facets.map(({
+        x: x7
+    }) => groups3.get(x7) ?? []) : facets.map(({
+        y: y7
+    }) => groups3.get(y7) ?? []);
+}
+
+// node_modules/@observablehq/plot/src/axes.js
+function inferFontVariant(scale5) {
+    return isOrdinalScale(scale5) && scale5.interval === void 0 ? void 0 : "tabular-nums";
+}
+
+function maybeAutoTickFormat(tickFormat3, domain) {
+    return tickFormat3 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat3 === "function" ? tickFormat3 : (typeof tickFormat3 === "string" ? isTemporal(domain) ? utcFormat : format : constant2)(tickFormat3);
+}
+
+// node_modules/@observablehq/plot/src/legends/ramp.js
+function legendRamp(color5, options) {
+    let {
+        label = color5.label,
+            tickSize = 6,
+            width = 240,
+            height = 44 + tickSize,
+            marginTop = 18,
+            marginRight = 0,
+            marginBottom = 16 + tickSize,
+            marginLeft = 0,
+            style,
+            ticks: ticks3 = (width - marginLeft - marginRight) / 64,
+            tickFormat: tickFormat3,
+            fontVariant = inferFontVariant(color5),
+            round: round3 = true,
+            opacity: opacity3,
+            className
+    } = options;
+    const context = createContext(options);
+    className = maybeClassName(className);
+    opacity3 = maybeNumberChannel(opacity3)[1];
+    if (tickFormat3 === null)
+        tickFormat3 = () => null;
+    const svg3 = create2("svg", context).attr("class", className).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
+        (svg4) => svg4.append("style").text(`
+        .${className} {
+          display: block;
+          background: white;
+          height: auto;
+          height: intrinsic;
+          max-width: 100%;
+          overflow: visible;
+        }
+        .${className} text {
+          white-space: pre;
+        }
+      `)
+    ).call(applyInlineStyles, style);
+    let tickAdjust = (g) => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
+    let x7;
+    const applyRange = round3 ? (x8, range10) => x8.rangeRound(range10) : (x8, range10) => x8.range(range10);
+    const {
+        type: type3,
+        domain,
+        range: range9,
+        interpolate,
+        scale: scale5,
+        pivot
+    } = color5;
+    if (interpolate) {
+        const interpolator = range9 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range9);
+        x7 = applyRange(
+            scale5.copy(),
+            quantize_default(
+                number_default(marginLeft, width - marginRight),
+                Math.min(domain.length + (pivot !== void 0), range9 === void 0 ? Infinity : range9.length)
+            )
+        );
+        const n = 256;
+        const canvas = context.document.createElement("canvas");
+        canvas.width = n;
+        canvas.height = 1;
+        const context2 = canvas.getContext("2d");
+        for (let i = 0, j = n - 1; i < n; ++i) {
+            context2.fillStyle = interpolator(i / j);
+            context2.fillRect(i, 0, 1, 1);
+        }
+        svg3.append("image").attr("opacity", opacity3).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
+    } else if (type3 === "threshold") {
+        const thresholds = domain;
+        const thresholdFormat = tickFormat3 === void 0 ? (d) => d : typeof tickFormat3 === "string" ? format(tickFormat3) : tickFormat3;
+        x7 = applyRange(linear3().domain([-1, range9.length - 1]), [marginLeft, width - marginRight]);
+        svg3.append("g").attr("fill-opacity", opacity3).selectAll().data(range9).enter().append("rect").attr("x", (d, i) => x7(i - 1)).attr("y", marginTop).attr("width", (d, i) => x7(i) - x7(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
+        ticks3 = map4(thresholds, (_, i) => i);
+        tickFormat3 = (i) => thresholdFormat(thresholds[i], i);
+    } else {
+        x7 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
+        svg3.append("g").attr("fill-opacity", opacity3).selectAll().data(domain).enter().append("rect").attr("x", x7).attr("y", marginTop).attr("width", Math.max(0, x7.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale5);
+        tickAdjust = () => {};
+    }
+    svg3.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
+        axisBottom(x7).ticks(Array.isArray(ticks3) ? null : ticks3, typeof tickFormat3 === "string" ? tickFormat3 : void 0).tickFormat(typeof tickFormat3 === "function" ? tickFormat3 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks3) ? ticks3 : null)
+    ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
+    if (label !== void 0) {
+        svg3.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
+    }
+    return svg3.node();
+}
+
+// node_modules/@observablehq/plot/src/legends/swatches.js
+function maybeScale(scale5, key) {
+    if (key == null)
+        return key;
+    const s3 = scale5(key);
+    if (!s3)
+        throw new Error(`scale not found: ${key}`);
+    return s3;
+}
+
+function legendSwatches(color5, {
+    opacity: opacity3,
+    ...options
+} = {}) {
+    if (!isOrdinalScale(color5) && !isThresholdScale(color5))
+        throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color5.type})`);
+    return legendItems(
+        color5,
+        options,
+        (selection3, scale5) => selection3.append("svg").attr("fill", scale5.scale).attr("fill-opacity", maybeNumberChannel(opacity3)[1]).append("rect").attr("width", "100%").attr("height", "100%"),
+        (className) => `.${className}-swatch svg {
+        width: var(--swatchWidth);
+        height: var(--swatchHeight);
+        margin-right: 0.5em;
+      }`
+    );
+}
+
+function legendSymbols(symbol3, {
+    fill = symbol3.hint?.fill !== void 0 ? symbol3.hint.fill : "none",
+    fillOpacity = 1,
+    stroke = symbol3.hint?.stroke !== void 0 ? symbol3.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
+    strokeOpacity = 1,
+    strokeWidth = 1.5,
+    r = 4.5,
+    ...options
+} = {}, scale5) {
+    const [vf, cf] = maybeColorChannel(fill);
+    const [vs, cs] = maybeColorChannel(stroke);
+    const sf = maybeScale(scale5, vf);
+    const ss = maybeScale(scale5, vs);
+    const size = r * r * Math.PI;
+    fillOpacity = maybeNumberChannel(fillOpacity)[1];
+    strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
+    strokeWidth = maybeNumberChannel(strokeWidth)[1];
+    return legendItems(
+        symbol3,
+        options,
+        (selection3) => selection3.append("svg").attr("viewBox", "-8 -8 16 16").attr("fill", vf === "color" ? (d) => sf.scale(d) : null).attr("stroke", vs === "color" ? (d) => ss.scale(d) : null).append("path").attr("d", (d) => {
+            const p = pathRound();
+            symbol3.scale(d).draw(p, size);
+            return p;
+        }),
+        (className) => `.${className}-swatch > svg {
+        width: var(--swatchWidth);
+        height: var(--swatchHeight);
+        margin-right: 0.5em;
+        overflow: visible;
+        fill: ${cf};
+        fill-opacity: ${fillOpacity};
+        stroke: ${cs};
+        stroke-width: ${strokeWidth}px;
+        stroke-opacity: ${strokeOpacity};
+      }`
+    );
+}
+
+function legendItems(scale5, options = {}, swatch, swatchStyle) {
+    let {
+        columns,
+        tickFormat: tickFormat3,
+        fontVariant = inferFontVariant(scale5),
+        // TODO label,
+        swatchSize = 15,
+        swatchWidth = swatchSize,
+        swatchHeight = swatchSize,
+        marginLeft = 0,
+        className,
+        style,
+        width
+    } = options;
+    const context = createContext(options);
+    className = maybeClassName(className);
+    tickFormat3 = maybeAutoTickFormat(tickFormat3, scale5.domain);
+    const swatches = create2("div", context).attr("class", className).attr(
+        "style",
+        `
+        --swatchWidth: ${+swatchWidth}px;
+        --swatchHeight: ${+swatchHeight}px;
+      `
+    );
+    let extraStyle;
+    if (columns != null) {
+        extraStyle = `
+      .${className}-swatch {
+        display: flex;
+        align-items: center;
+        break-inside: avoid;
+        padding-bottom: 1px;
+      }
+      .${className}-swatch::before {
+        flex-shrink: 0;
+      }
+      .${className}-label {
+        white-space: nowrap;
+        overflow: hidden;
+        text-overflow: ellipsis;
+      }
+    `;
+        swatches.style("columns", columns).selectAll().data(scale5.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale5).call(
+            (item) => item.append("div").attr("class", `${className}-label`).attr("title", tickFormat3).text(tickFormat3)
+        );
+    } else {
+        extraStyle = `
+      .${className} {
+        display: flex;
+        align-items: center;
+        min-height: 33px;
+        flex-wrap: wrap;
+      }
+      .${className}-swatch {
+        display: inline-flex;
+        align-items: center;
+        margin-right: 1em;
+      }
+    `;
+        swatches.selectAll().data(scale5.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale5).append(function() {
+            return this.ownerDocument.createTextNode(tickFormat3.apply(this, arguments));
+        });
+    }
+    return swatches.call(
+        (div) => div.insert("style", "*").text(`
+        .${className} {
+          font-family: system-ui, sans-serif;
+          font-size: 10px;
+          margin-bottom: 0.5em;${marginLeft === void 0 ? "" : `
+          margin-left: ${+marginLeft}px;`}${width === void 0 ? "" : `
+          width: ${width}px;`}
+        }
+        ${swatchStyle(className)}
+        ${extraStyle}
+      `)
+    ).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
+}
+
+// node_modules/@observablehq/plot/src/legends.js
+var legendRegistry = /* @__PURE__ */ new Map([
+    ["symbol", legendSymbols],
+    ["color", legendColor],
+    ["opacity", legendOpacity]
+]);
+
+function legend(options = {}) {
+    for (const [key, value] of legendRegistry) {
+        const scale5 = options[key];
+        if (isScaleOptions(scale5)) {
+            const context = createContext(options);
+            let hint;
+            if (key === "symbol") {
+                const {
+                    fill,
+                    stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0
+                } = options;
+                hint = {
+                    fill,
+                    stroke
+                };
+            }
+            return value(
+                normalizeScale(key, scale5, hint),
+                legendOptions(context, scale5, options),
+                (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
+            );
+        }
+    }
+    throw new Error("unknown legend type; no scale found");
+}
+
+function exposeLegends(scales, context, defaults41 = {}) {
+    return (key, options) => {
+        if (!legendRegistry.has(key))
+            throw new Error(`unknown legend type: ${key}`);
+        if (!(key in scales))
+            return;
+        return legendRegistry.get(key)(scales[key], legendOptions(context, defaults41[key], options), (key2) => scales[key2]);
+    };
+}
+
+function legendOptions(context, {
+    label,
+    ticks: ticks3,
+    tickFormat: tickFormat3
+} = {}, options) {
+    return inherit2(options, context, {
+        label,
+        ticks: ticks3,
+        tickFormat: tickFormat3
+    });
+}
+
+function legendColor(color5, {
+    legend: legend3 = true,
+    ...options
+}) {
+    if (legend3 === true)
+        legend3 = color5.type === "ordinal" ? "swatches" : "ramp";
+    if (color5.domain === void 0)
+        return;
+    switch (`${legend3}`.toLowerCase()) {
+        case "swatches":
+            return legendSwatches(color5, options);
+        case "ramp":
+            return legendRamp(color5, options);
+        default:
+            throw new Error(`unknown legend type: ${legend3}`);
+    }
+}
+
+function legendOpacity({
+    type: type3,
+    interpolate,
+    ...scale5
+}, {
+    legend: legend3 = true,
+    color: color5 = rgb(0, 0, 0),
+    ...options
+}) {
+    if (!interpolate)
+        throw new Error(`${type3} opacity scales are not supported`);
+    if (legend3 === true)
+        legend3 = "ramp";
+    if (`${legend3}`.toLowerCase() !== "ramp")
+        throw new Error(`${legend3} opacity legends are not supported`);
+    return legendColor({
+        type: type3,
+        ...scale5,
+        interpolate: interpolateOpacity(color5)
+    }, {
+        legend: legend3,
+        ...options
+    });
+}
+
+function interpolateOpacity(color5) {
+    const {
+        r,
+        g,
+        b
+    } = rgb(color5) || rgb(0, 0, 0);
+    return (t) => `rgba(${r},${g},${b},${t})`;
+}
+
+function createLegends(scales, context, options) {
+    const legends = [];
+    for (const [key, value] of legendRegistry) {
+        const o = options[key];
+        if (o?.legend && key in scales) {
+            const legend3 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);
+            if (legend3 != null)
+                legends.push(legend3);
+        }
+    }
+    return legends;
+}
+
+// node_modules/@observablehq/plot/src/mark.js
+var Mark = class {
+    constructor(data, channels = {}, options = {}, defaults41) {
+        const {
+            facet = "auto",
+                facetAnchor,
+                fx,
+                fy,
+                sort: sort5,
+                dx = 0,
+                dy = 0,
+                margin = 0,
+                marginTop = margin,
+                marginRight = margin,
+                marginBottom = margin,
+                marginLeft = margin,
+                clip,
+                channels: extraChannels
+        } = options;
+        this.data = data;
+        this.sort = isDomainSort(sort5) ? sort5 : null;
+        this.initializer = initializer(options).initializer;
+        this.transform = this.initializer ? options.transform : basic(options).transform;
+        if (facet === null || facet === false) {
+            this.facet = null;
+        } else {
+            this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
+            this.fx = fx;
+            this.fy = fy;
+        }
+        this.facetAnchor = maybeFacetAnchor(facetAnchor);
+        channels = maybeNamed(channels);
+        if (extraChannels !== void 0)
+            channels = {
+                ...maybeNamed(extraChannels),
+                ...channels
+            };
+        if (defaults41 !== void 0)
+            channels = {
+                ...styles(this, options, defaults41),
+                ...channels
+            };
+        this.channels = Object.fromEntries(
+            Object.entries(channels).map(([name, channel]) => {
+                const {
+                    value
+                } = channel;
+                if (isOptions(value)) {
+                    channel = {
+                        ...channel,
+                        value: value.value
+                    };
+                    if (value.scale !== void 0)
+                        channel.scale = value.scale;
+                }
+                return [name, channel];
+            }).filter(([name, {
+                value,
+                optional: optional3
+            }]) => {
+                if (value != null)
+                    return true;
+                if (optional3)
+                    return false;
+                throw new Error(`missing channel value: ${name}`);
+            })
+        );
+        this.dx = +dx;
+        this.dy = +dy;
+        this.marginTop = +marginTop;
+        this.marginRight = +marginRight;
+        this.marginBottom = +marginBottom;
+        this.marginLeft = +marginLeft;
+        this.clip = maybeClip(clip);
+        if (this.facet === "super") {
+            if (fx || fy)
+                throw new Error(`super-faceting cannot use fx or fy`);
+            for (const name in this.channels) {
+                const {
+                    scale: scale5
+                } = channels[name];
+                if (scale5 !== "x" && scale5 !== "y")
+                    continue;
+                throw new Error(`super-faceting cannot use x or y`);
+            }
+        }
+    }
+    initialize(facets, facetChannels) {
+        let data = arrayify2(this.data);
+        if (facets === void 0 && data != null)
+            facets = [range4(data)];
+        const originalFacets = facets;
+        if (this.transform != null)
+            ({
+                facets,
+                data
+            } = this.transform(data, facets)), data = arrayify2(data);
+        if (facets !== void 0)
+            facets.original = originalFacets;
+        const channels = createChannels(this.channels, data);
+        if (this.sort != null)
+            channelDomain(data, facets, channels, facetChannels, this.sort);
+        return {
+            data,
+            facets,
+            channels
+        };
+    }
+    filter(index5, channels, values3) {
+        for (const name in channels) {
+            const {
+                filter: filter7 = defined
+            } = channels[name];
+            if (filter7 !== null) {
+                const value = values3[name];
+                index5 = index5.filter((i) => filter7(value[i]));
+            }
+        }
+        return index5;
+    }
+    // If there is a projection, and there are both x and y channels (or x1 and
+    // y1, or x2 and y2 channels), and those channels are associated with the x
+    // and y scale respectively (and not already in screen coordinates as with an
+    // initializer), then apply the projection, replacing the x and y values. Note
+    // that the x and y scales themselves don‚Äôt exist if there is a projection,
+    // but whether the channels are associated with scales still determines
+    // whether the projection should apply; think of the projection as a
+    // combination xy-scale.
+    project(channels, values3, context) {
+        maybeProject("x", "y", channels, values3, context);
+        maybeProject("x1", "y1", channels, values3, context);
+        maybeProject("x2", "y2", channels, values3, context);
+    }
+    scale(channels, scales, context) {
+        const values3 = valueObject(channels, scales);
+        if (context.projection)
+            this.project(channels, values3, context);
+        return values3;
+    }
+};
+
+function marks(...marks3) {
+    marks3.plot = Mark.prototype.plot;
+    return marks3;
+}
+
+// node_modules/@observablehq/plot/src/math.js
+var radians3 = Math.PI / 180;
+
+// node_modules/@observablehq/plot/src/transforms/inset.js
+function maybeInsetX({
+    inset,
+    insetLeft,
+    insetRight,
+    ...options
+} = {}) {
+    [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
+    return {
+        inset,
+        insetLeft,
+        insetRight,
+        ...options
+    };
+}
+
+function maybeInsetY({
+    inset,
+    insetTop,
+    insetBottom,
+    ...options
+} = {}) {
+    [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
+    return {
+        inset,
+        insetTop,
+        insetBottom,
+        ...options
+    };
+}
+
+function maybeInset(inset, inset1, inset2) {
+    return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
+}
+
+// node_modules/@observablehq/plot/src/transforms/interval.js
+function maybeIntervalValue(value, {
+    interval: interval3
+}) {
+    value = {
+        ...maybeValue(value)
+    };
+    value.interval = maybeInterval(value.interval === void 0 ? interval3 : value.interval);
+    return value;
+}
+
+function maybeIntervalK(k3, maybeInsetK, options, trivial) {
+    const {
+        [k3]: v3, [`${k3}1`]: v1, [`${k3}2`]: v22
+    } = options;
+    const {
+        value,
+        interval: interval3
+    } = maybeIntervalValue(v3, options);
+    if (value == null || interval3 == null && !trivial)
+        return options;
+    const label = labelof(v3);
+    if (interval3 == null) {
+        let V;
+        const kv = {
+            transform: (data) => V || (V = valueof(data, value)),
+            label
+        };
+        return {
+            ...options,
+            [k3]: void 0,
+            [`${k3}1`]: v1 === void 0 ? kv : v1,
+            [`${k3}2`]: v22 === void 0 ? kv : v22
+        };
+    }
+    let D1, V1;
+
+    function transform3(data) {
+        if (V1 !== void 0 && data === D1)
+            return V1;
+        return V1 = map4(valueof(D1 = data, value), (v4) => interval3.floor(v4));
+    }
+    return maybeInsetK({
+        ...options,
+        [k3]: void 0,
+        [`${k3}1`]: v1 === void 0 ? {
+            transform: transform3,
+            label
+        } : v1,
+        [`${k3}2`]: v22 === void 0 ? {
+            transform: (data) => transform3(data).map((v4) => interval3.offset(v4)),
+            label
+        } : v22
+    });
+}
+
+function maybeIntervalMidK(k3, maybeInsetK, options) {
+    const {
+        [k3]: v3
+    } = options;
+    const {
+        value,
+        interval: interval3
+    } = maybeIntervalValue(v3, options);
+    if (value == null || interval3 == null)
+        return options;
+    return maybeInsetK({
+        ...options,
+        [k3]: {
+            label: labelof(v3),
+            transform: (data) => {
+                const V1 = map4(valueof(data, value), (v4) => interval3.floor(v4));
+                const V2 = V1.map((v4) => interval3.offset(v4));
+                return V1.map(
+                    isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
+                );
+            }
+        }
+    });
+}
+
+function maybeTrivialIntervalX(options = {}) {
+    return maybeIntervalK("x", maybeInsetX, options, true);
+}
+
+function maybeTrivialIntervalY(options = {}) {
+    return maybeIntervalK("y", maybeInsetY, options, true);
+}
+
+function maybeIntervalX(options = {}) {
+    return maybeIntervalK("x", maybeInsetX, options);
+}
+
+function maybeIntervalY(options = {}) {
+    return maybeIntervalK("y", maybeInsetY, options);
+}
+
+function maybeIntervalMidX(options = {}) {
+    return maybeIntervalMidK("x", maybeInsetX, options);
+}
+
+function maybeIntervalMidY(options = {}) {
+    return maybeIntervalMidK("y", maybeInsetY, options);
+}
+
+// node_modules/@observablehq/plot/src/marks/rule.js
+var defaults = {
+    ariaLabel: "rule",
+    fill: null,
+    stroke: "currentColor"
+};
+var RuleX = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y1: y13,
+            y2: y22,
+            inset = 0,
+            insetTop = inset,
+            insetBottom = inset
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y1: {
+                    value: y13,
+                    scale: "y",
+                    optional: true
+                },
+                y2: {
+                    value: y22,
+                    scale: "y",
+                    optional: true
+                }
+            },
+            options,
+            defaults
+        );
+        this.insetTop = number5(insetTop);
+        this.insetBottom = number5(insetBottom);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y1: Y15,
+            y2: Y25
+        } = channels;
+        const {
+            width,
+            height,
+            marginTop,
+            marginRight,
+            marginLeft,
+            marginBottom
+        } = dimensions;
+        const {
+            insetTop,
+            insetBottom
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions).call(applyTransform, this, {
+            x: X4 && x7
+        }, offset, 0).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles, this).attr("x1", X4 ? (i) => X4[i] : (marginLeft + width - marginRight) / 2).attr("x2", X4 ? (i) => X4[i] : (marginLeft + width - marginRight) / 2).attr("y1", Y15 && !isCollapsed(y7) ? (i) => Y15[i] + insetTop : marginTop + insetTop).attr(
+                "y2",
+                Y25 && !isCollapsed(y7) ? y7.bandwidth ? (i) => Y25[i] + y7.bandwidth() - insetBottom : (i) => Y25[i] - insetBottom : height - marginBottom - insetBottom
+            ).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+var RuleY = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            x2: x22,
+            y: y7,
+            inset = 0,
+            insetRight = inset,
+            insetLeft = inset
+        } = options;
+        super(
+            data, {
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                x1: {
+                    value: x13,
+                    scale: "x",
+                    optional: true
+                },
+                x2: {
+                    value: x22,
+                    scale: "x",
+                    optional: true
+                }
+            },
+            options,
+            defaults
+        );
+        this.insetRight = number5(insetRight);
+        this.insetLeft = number5(insetLeft);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            y: Y4,
+            x1: X15,
+            x2: X25
+        } = channels;
+        const {
+            width,
+            height,
+            marginTop,
+            marginRight,
+            marginLeft,
+            marginBottom
+        } = dimensions;
+        const {
+            insetLeft,
+            insetRight
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            y: Y4 && y7
+        }, 0, offset).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles, this).attr("x1", X15 && !isCollapsed(x7) ? (i) => X15[i] + insetLeft : marginLeft + insetLeft).attr(
+                "x2",
+                X25 && !isCollapsed(x7) ? x7.bandwidth ? (i) => X25[i] + x7.bandwidth() - insetRight : (i) => X25[i] - insetRight : width - marginRight - insetRight
+            ).attr("y1", Y4 ? (i) => Y4[i] : (marginTop + height - marginBottom) / 2).attr("y2", Y4 ? (i) => Y4[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function ruleX(data, options) {
+    let {
+        x: x7 = identity6,
+        y: y7,
+        y1: y13,
+        y2: y22,
+        ...rest
+    } = maybeIntervalY(options);
+    [y13, y22] = maybeOptionalZero(y7, y13, y22);
+    return new RuleX(data, {
+        ...rest,
+        x: x7,
+        y1: y13,
+        y2: y22
+    });
+}
+
+function ruleY(data, options) {
+    let {
+        y: y7 = identity6,
+        x: x7,
+        x1: x13,
+        x2: x22,
+        ...rest
+    } = maybeIntervalX(options);
+    [x13, x22] = maybeOptionalZero(x7, x13, x22);
+    return new RuleY(data, {
+        ...rest,
+        y: y7,
+        x1: x13,
+        x2: x22
+    });
+}
+
+function maybeOptionalZero(x7, x13, x22) {
+    if (x7 === void 0) {
+        if (x13 === void 0) {
+            if (x22 !== void 0)
+                return [0, x22];
+        } else {
+            if (x22 === void 0)
+                return [0, x13];
+        }
+    } else if (x13 === void 0) {
+        return x22 === void 0 ? [0, x7] : [x7, x22];
+    } else if (x22 === void 0) {
+        return [x7, x13];
+    }
+    return [x13, x22];
+}
+
+// node_modules/@observablehq/plot/src/template.js
+function template(strings, ...parts) {
+    let n = parts.length;
+    for (let j = 0, copy5 = true; j < n; ++j) {
+        if (typeof parts[j] !== "function") {
+            if (copy5) {
+                strings = strings.slice();
+                copy5 = false;
+            }
+            strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);
+            parts.splice(j, 1);
+            --j, --n;
+        }
+    }
+    return (i) => {
+        let s3 = strings[0];
+        for (let j = 0; j < n; ++j) {
+            s3 += parts[j](i) + strings[j + 1];
+        }
+        return s3;
+    };
+}
+
+// node_modules/@observablehq/plot/src/marks/text.js
+var defaults2 = {
+    ariaLabel: "text",
+    strokeLinejoin: "round",
+    strokeWidth: 3,
+    paintOrder: "stroke"
+};
+var softHyphen = "\xAD";
+var Text = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            text: text3 = isIterable(data) && isTextual(data) ? identity6 : indexOf,
+            frameAnchor,
+            textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
+            lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
+            lineHeight = 1,
+            lineWidth = Infinity,
+            textOverflow,
+            monospace,
+            fontFamily = monospace ? "ui-monospace, monospace" : void 0,
+            fontSize,
+            fontStyle,
+            fontVariant,
+            fontWeight,
+            rotate
+        } = options;
+        const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
+        const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                fontSize: {
+                    value: vfontSize,
+                    optional: true
+                },
+                rotate: {
+                    value: numberChannel(vrotate),
+                    optional: true
+                },
+                text: {
+                    value: text3,
+                    filter: nonempty,
+                    optional: true
+                }
+            },
+            options,
+            defaults2
+        );
+        this.rotate = crotate;
+        this.textAnchor = impliedString(textAnchor, "middle");
+        this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
+        this.lineHeight = +lineHeight;
+        this.lineWidth = +lineWidth;
+        this.textOverflow = maybeTextOverflow(textOverflow);
+        this.monospace = !!monospace;
+        this.fontFamily = string(fontFamily);
+        this.fontSize = cfontSize;
+        this.fontStyle = string(fontStyle);
+        this.fontVariant = string(fontVariant);
+        this.fontWeight = string(fontWeight);
+        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        if (!(this.lineWidth >= 0))
+            throw new Error(`invalid lineWidth: ${lineWidth}`);
+        this.splitLines = splitter2(this);
+        this.clipLine = clipper(this);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            rotate: R,
+            text: T,
+            title: TL,
+            fontSize: FS
+        } = channels;
+        const {
+            rotate
+        } = this;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            (g) => g.selectAll().data(index5).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(
+                "transform",
+                template`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`
+            ).call(applyAttr, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function maybeTextOverflow(textOverflow) {
+    return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
+        "clip",
+        // shorthand for clip-end
+        "ellipsis",
+        // ‚Ä¶ ellipsis-end
+        "clip-start",
+        "clip-end",
+        "ellipsis-start",
+        "ellipsis-middle",
+        "ellipsis-end"
+    ]).replace(/^(clip|ellipsis)$/, "$1-end");
+}
+
+function applyMultilineText(selection3, mark, T, TL) {
+    if (!T)
+        return;
+    const {
+        lineAnchor,
+        lineHeight,
+        textOverflow,
+        splitLines,
+        clipLine
+    } = mark;
+    selection3.each(function(i) {
+        const lines = splitLines(formatDefault(T[i]) ?? "").map(clipLine);
+        const n = lines.length;
+        const y7 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
+        if (n > 1) {
+            for (let i2 = 0; i2 < n; ++i2) {
+                if (!lines[i2])
+                    continue;
+                const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
+                tspan.setAttribute("x", 0);
+                tspan.setAttribute("y", `${(y7 + i2) * lineHeight}em`);
+                tspan.textContent = lines[i2];
+                this.appendChild(tspan);
+            }
+        } else {
+            if (y7)
+                this.setAttribute("y", `${y7 * lineHeight}em`);
+            this.textContent = lines[0];
+        }
+        if (textOverflow && !TL && lines[0] !== T[i]) {
+            const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
+            title.textContent = T[i];
+            this.appendChild(title);
+        }
+    });
+}
+
+function text(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    if (options.frameAnchor === void 0)
+        [x7, y7] = maybeTuple(x7, y7);
+    return new Text(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+
+function textX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new Text(data, maybeIntervalMidY({
+        ...remainingOptions,
+        x: x7
+    }));
+}
+
+function textY(data, options = {}) {
+    const {
+        y: y7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new Text(data, maybeIntervalMidX({
+        ...remainingOptions,
+        y: y7
+    }));
+}
+
+function applyIndirectTextStyles(selection3, mark, T) {
+    applyAttr(selection3, "text-anchor", mark.textAnchor);
+    applyAttr(selection3, "font-family", mark.fontFamily);
+    applyAttr(selection3, "font-size", mark.fontSize);
+    applyAttr(selection3, "font-style", mark.fontStyle);
+    applyAttr(selection3, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);
+    applyAttr(selection3, "font-weight", mark.fontWeight);
+}
+
+function inferFontVariant2(T) {
+    return isNumeric(T) || isTemporal(T) ? "tabular-nums" : void 0;
+}
+var fontSizes = /* @__PURE__ */ new Set([
+    // global keywords
+    "inherit",
+    "initial",
+    "revert",
+    "unset",
+    // absolute keywords
+    "xx-small",
+    "x-small",
+    "small",
+    "medium",
+    "large",
+    "x-large",
+    "xx-large",
+    "xxx-large",
+    // relative keywords
+    "larger",
+    "smaller"
+]);
+
+function maybeFontSizeChannel(fontSize) {
+    if (fontSize == null || typeof fontSize === "number")
+        return [void 0, fontSize];
+    if (typeof fontSize !== "string")
+        return [fontSize, void 0];
+    fontSize = fontSize.trim().toLowerCase();
+    return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
+}
+
+function lineWrap(input, maxWidth, widthof) {
+    const lines = [];
+    let lineStart, lineEnd = 0;
+    for (const [wordStart, wordEnd, required3] of lineBreaks(input)) {
+        if (lineStart === void 0)
+            lineStart = wordStart;
+        if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
+            lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
+            lineStart = wordStart;
+        }
+        if (required3) {
+            lines.push(input.slice(lineStart, wordEnd));
+            lineStart = void 0;
+            continue;
+        }
+        lineEnd = wordEnd;
+    }
+    return lines;
+}
+
+function* lineBreaks(input) {
+    let i = 0,
+        j = 0;
+    const n = input.length;
+    while (j < n) {
+        let k3 = 1;
+        switch (input[j]) {
+            case softHyphen:
+            case "-":
+                ++j;
+                yield [i, j, false];
+                i = j;
+                break;
+            case " ":
+                yield [i, j, false];
+                while (input[++j] === " ")
+                ;
+                i = j;
+                break;
+            case "\r":
+                if (input[j + 1] === "\n")
+                    ++k3;
+            case "\n":
+                yield [i, j, true];
+                j += k3;
+                i = j;
+                break;
+            default:
+                ++j;
+                break;
+        }
+    }
+    yield [i, j, true];
+}
+var defaultWidthMap = {
+    a: 56,
+    b: 63,
+    c: 57,
+    d: 63,
+    e: 58,
+    f: 37,
+    g: 62,
+    h: 60,
+    i: 26,
+    j: 26,
+    k: 55,
+    l: 26,
+    m: 88,
+    n: 60,
+    o: 60,
+    p: 62,
+    q: 62,
+    r: 39,
+    s: 54,
+    t: 38,
+    u: 60,
+    v: 55,
+    w: 79,
+    x: 54,
+    y: 55,
+    z: 55,
+    A: 69,
+    B: 67,
+    C: 73,
+    D: 74,
+    E: 61,
+    F: 58,
+    G: 76,
+    H: 75,
+    I: 28,
+    J: 55,
+    K: 67,
+    L: 58,
+    M: 89,
+    N: 75,
+    O: 78,
+    P: 65,
+    Q: 78,
+    R: 67,
+    S: 65,
+    T: 65,
+    U: 75,
+    V: 69,
+    W: 98,
+    X: 69,
+    Y: 67,
+    Z: 67,
+    0: 64,
+    1: 48,
+    2: 62,
+    3: 64,
+    4: 66,
+    5: 63,
+    6: 65,
+    7: 58,
+    8: 65,
+    9: 65,
+    " ": 29,
+    "!": 32,
+    '"': 49,
+    "'": 31,
+    "(": 39,
+    ")": 39,
+    ",": 31,
+    "-": 48,
+    ".": 31,
+    "/": 32,
+    ":": 31,
+    ";": 31,
+    "?": 52,
+    "\u2018": 31,
+    "\u2019": 31,
+    "\u201C": 47,
+    "\u201D": 47,
+    "\u2026": 82
+};
+
+function defaultWidth(text3, start3 = 0, end = text3.length) {
+    let sum8 = 0;
+    for (let i = start3; i < end; i = readCharacter(text3, i)) {
+        sum8 += defaultWidthMap[text3[i]] ?? (isPictographic(text3, i) ? 120 : defaultWidthMap.e);
+    }
+    return sum8;
+}
+
+function monospaceWidth(text3, start3 = 0, end = text3.length) {
+    let sum8 = 0;
+    for (let i = start3; i < end; i = readCharacter(text3, i)) {
+        sum8 += isPictographic(text3, i) ? 200 : 100;
+    }
+    return sum8;
+}
+
+function splitter2({
+    monospace,
+    lineWidth,
+    textOverflow
+}) {
+    if (textOverflow != null || lineWidth == Infinity)
+        return (text3) => text3.split(/\r\n?|\n/g);
+    const widthof = monospace ? monospaceWidth : defaultWidth;
+    const maxWidth = lineWidth * 100;
+    return (text3) => lineWrap(text3, maxWidth, widthof);
+}
+
+function clipper({
+    monospace,
+    lineWidth,
+    textOverflow
+}) {
+    if (textOverflow == null || lineWidth == Infinity)
+        return (text3) => text3;
+    const widthof = monospace ? monospaceWidth : defaultWidth;
+    const maxWidth = lineWidth * 100;
+    switch (textOverflow) {
+        case "clip-start":
+            return (text3) => clipStart(text3, maxWidth, widthof, "");
+        case "clip-end":
+            return (text3) => clipEnd(text3, maxWidth, widthof, "");
+        case "ellipsis-start":
+            return (text3) => clipStart(text3, maxWidth, widthof, "\u2026");
+        case "ellipsis-middle":
+            return (text3) => clipMiddle(text3, maxWidth, widthof, "\u2026");
+        case "ellipsis-end":
+            return (text3) => clipEnd(text3, maxWidth, widthof, "\u2026");
+    }
+}
+
+function cut(text3, width, widthof, inset) {
+    const I = [];
+    let w = 0;
+    for (let i = 0, j = 0, n = text3.length; i < n; i = j) {
+        j = readCharacter(text3, i);
+        const l = widthof(text3, i, j);
+        if (w + l > width) {
+            w += inset;
+            while (w > width && i > 0)
+                j = i, i = I.pop(), w -= widthof(text3, i, j);
+            return [i, width - w];
+        }
+        w += l;
+        I.push(i);
+    }
+    return [-1, 0];
+}
+
+function clipEnd(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
+    const e = widthof(ellipsis);
+    const [i] = cut(text3, width, widthof, e);
+    return i < 0 ? text3 : text3.slice(0, i).trimEnd() + ellipsis;
+}
+
+function clipMiddle(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
+    const w = widthof(text3);
+    if (w <= width)
+        return text3;
+    const e = widthof(ellipsis) / 2;
+    const [i, ei] = cut(text3, width / 2, widthof, e);
+    const [j] = cut(text3, w - width / 2 - ei + e, widthof, -e);
+    return j < 0 ? ellipsis : text3.slice(0, i).trimEnd() + ellipsis + text3.slice(readCharacter(text3, j)).trimStart();
+}
+
+function clipStart(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
+    const w = widthof(text3);
+    if (w <= width)
+        return text3;
+    const e = widthof(ellipsis);
+    const [j] = cut(text3, w - width + e, widthof, -e);
+    return j < 0 ? ellipsis : ellipsis + text3.slice(readCharacter(text3, j)).trimStart();
+}
+var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
+var rePictographic = /\p{Extended_Pictographic}/uy;
+
+function readCharacter(text3, i) {
+    i += isSurrogatePair(text3, i) ? 2 : 1;
+    if (isCombiner(text3, i))
+        i = reCombiner.lastIndex;
+    if (isZeroWidthJoiner(text3, i))
+        return readCharacter(text3, i + 1);
+    return i;
+}
+
+function isAscii(text3, i) {
+    return text3.charCodeAt(i) < 128;
+}
+
+function isSurrogatePair(text3, i) {
+    const hi = text3.charCodeAt(i);
+    if (hi >= 55296 && hi < 56320) {
+        const lo = text3.charCodeAt(i + 1);
+        return lo >= 56320 && lo < 57344;
+    }
+    return false;
+}
+
+function isZeroWidthJoiner(text3, i) {
+    return text3.charCodeAt(i) === 8205;
+}
+
+function isCombiner(text3, i) {
+    return isAscii(text3, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text3));
+}
+
+function isPictographic(text3, i) {
+    return isAscii(text3, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text3));
+}
+
+// node_modules/@observablehq/plot/src/marks/vector.js
+var defaults3 = {
+    ariaLabel: "vector",
+    fill: "none",
+    stroke: "currentColor",
+    strokeWidth: 1.5,
+    strokeLinejoin: "round",
+    strokeLinecap: "round"
+};
+var defaultRadius3 = 3.5;
+var wingRatio = defaultRadius3 * 5;
+var shapeArrow = {
+    draw(context, l, r) {
+        const wing = l * r / wingRatio;
+        context.moveTo(0, 0);
+        context.lineTo(0, -l);
+        context.moveTo(-wing, wing - l);
+        context.lineTo(0, -l);
+        context.lineTo(wing, wing - l);
+    }
+};
+var shapeSpike = {
+    draw(context, l, r) {
+        context.moveTo(-r, 0);
+        context.lineTo(0, -l);
+        context.lineTo(r, 0);
+    }
+};
+var shapes = /* @__PURE__ */ new Map([
+    ["arrow", shapeArrow],
+    ["spike", shapeSpike]
+]);
+
+function isShapeObject(value) {
+    return value && typeof value.draw === "function";
+}
+
+function maybeShape(shape) {
+    if (isShapeObject(shape))
+        return shape;
+    const value = shapes.get(`${shape}`.toLowerCase());
+    if (value)
+        return value;
+    throw new Error(`invalid shape: ${shape}`);
+}
+var Vector = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            r = defaultRadius3,
+            length: length7,
+            rotate,
+            shape = shapeArrow,
+            anchor = "middle",
+            frameAnchor
+        } = options;
+        const [vl, cl] = maybeNumberChannel(length7, 12);
+        const [vr, cr] = maybeNumberChannel(rotate, 0);
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                length: {
+                    value: vl,
+                    scale: "length",
+                    optional: true
+                },
+                rotate: {
+                    value: vr,
+                    optional: true
+                }
+            },
+            options,
+            defaults3
+        );
+        this.r = +r;
+        this.length = cl;
+        this.rotate = cr;
+        this.shape = maybeShape(shape);
+        this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
+        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            length: L,
+            rotate: A6
+        } = channels;
+        const {
+            length: length7,
+            rotate,
+            anchor,
+            shape,
+            r
+        } = this;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).attr(
+                "transform",
+                template`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${A6 ? (i) => ` rotate(${A6[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length7})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length7 / 2})`}`
+            ).attr(
+                "d",
+                L ? (i) => {
+                    const p = pathRound();
+                    shape.draw(p, L[i], r);
+                    return p;
+                } : (() => {
+                    const p = pathRound();
+                    shape.draw(p, length7, r);
+                    return p;
+                })()
+            ).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function vector(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...rest
+    } = options;
+    if (options.frameAnchor === void 0)
+        [x7, y7] = maybeTuple(x7, y7);
+    return new Vector(data, {
+        ...rest,
+        x: x7,
+        y: y7
+    });
+}
+
+function vectorX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        ...rest
+    } = options;
+    return new Vector(data, {
+        ...rest,
+        x: x7
+    });
+}
+
+function vectorY(data, options = {}) {
+    const {
+        y: y7 = identity6,
+        ...rest
+    } = options;
+    return new Vector(data, {
+        ...rest,
+        y: y7
+    });
+}
+
+function spike(data, options = {}) {
+    const {
+        shape = shapeSpike,
+            stroke = defaults3.stroke,
+            strokeWidth = 1,
+            fill = stroke,
+            fillOpacity = 0.3,
+            anchor = "start",
+            ...rest
+    } = options;
+    return vector(data, {
+        ...rest,
+        shape,
+        stroke,
+        strokeWidth,
+        fill,
+        fillOpacity,
+        anchor
+    });
+}
+
+// node_modules/@observablehq/plot/src/marks/axis.js
+function maybeData(data, options) {
+    if (arguments.length < 2 && !isIterable(data))
+        options = data, data = null;
+    if (options === void 0)
+        options = {};
+    return [data, options];
+}
+
+function maybeAnchor({
+    anchor
+} = {}, anchors) {
+    return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
+}
+
+function anchorY(options) {
+    return maybeAnchor(options, ["left", "right"]);
+}
+
+function anchorFy(options) {
+    return maybeAnchor(options, ["right", "left"]);
+}
+
+function anchorX(options) {
+    return maybeAnchor(options, ["bottom", "top"]);
+}
+
+function anchorFx(options) {
+    return maybeAnchor(options, ["top", "bottom"]);
+}
+
+function axisY() {
+    const [data, options] = maybeData(...arguments);
+    return axisKy("y", anchorY(options), data, options);
+}
+
+function axisFy() {
+    const [data, options] = maybeData(...arguments);
+    return axisKy("fy", anchorFy(options), data, options);
+}
+
+function axisX() {
+    const [data, options] = maybeData(...arguments);
+    return axisKx("x", anchorX(options), data, options);
+}
+
+function axisFx() {
+    const [data, options] = maybeData(...arguments);
+    return axisKx("fx", anchorFx(options), data, options);
+}
+
+function axisKy(k3, anchor, data, {
+    color: color5 = "currentColor",
+    opacity: opacity3 = 1,
+    stroke = color5,
+    strokeOpacity = opacity3,
+    strokeWidth = 1,
+    fill = color5,
+    fillOpacity = opacity3,
+    textAnchor,
+    textStroke,
+    textStrokeOpacity,
+    textStrokeWidth,
+    tickSize = k3 === "y" ? 6 : 0,
+    tickPadding,
+    tickRotate,
+    x: x7,
+    marginTop = 20,
+    marginRight = anchor === "right" ? 40 : 0,
+    marginBottom = 20,
+    marginLeft = anchor === "left" ? 40 : 0,
+    label,
+    labelOffset,
+    labelAnchor,
+    ...options
+}) {
+    tickSize = number5(tickSize);
+    tickPadding = number5(tickPadding);
+    tickRotate = number5(tickRotate);
+    if (labelAnchor !== void 0)
+        labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
+    return marks(
+        tickSize && !isNoneish(stroke) ? axisTickKy(k3, anchor, data, {
+            stroke,
+            strokeOpacity,
+            strokeWidth,
+            tickSize,
+            tickPadding,
+            tickRotate,
+            x: x7,
+            ...options
+        }) : null,
+        !isNoneish(fill) ? axisTextKy(k3, anchor, data, {
+            fill,
+            fillOpacity,
+            stroke: textStroke,
+            strokeOpacity: textStrokeOpacity,
+            strokeWidth: textStrokeWidth,
+            textAnchor,
+            tickSize,
+            tickPadding,
+            tickRotate,
+            x: x7,
+            marginTop,
+            marginRight,
+            marginBottom,
+            marginLeft,
+            ...options
+        }) : null,
+        !isNoneish(fill) && label !== null ? text([], {
+            fill,
+            fillOpacity,
+            ...options,
+            lineWidth: void 0,
+            textOverflow: void 0,
+            facet: "super",
+            x: null,
+            y: null,
+            initializer: function(data2, facets, channels, scales, dimensions) {
+                const scale5 = scales[k3];
+                const {
+                    marginTop: marginTop2,
+                    marginRight: marginRight2,
+                    marginBottom: marginBottom2,
+                    marginLeft: marginLeft2
+                } = k3 === "y" && dimensions.inset || dimensions;
+                const cla = labelAnchor ?? (scale5.bandwidth ? "center" : "top");
+                const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
+                if (cla === "center") {
+                    this.textAnchor = void 0;
+                    this.lineAnchor = anchor === "right" ? "bottom" : "top";
+                    this.frameAnchor = anchor;
+                    this.rotate = -90;
+                } else {
+                    this.textAnchor = anchor === "right" ? "end" : "start";
+                    this.lineAnchor = cla;
+                    this.frameAnchor = `${cla}-${anchor}`;
+                    this.rotate = 0;
+                }
+                this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
+                this.dx = anchor === "right" ? clo : -clo;
+                this.ariaLabel = `${k3}-axis label`;
+                return {
+                    facets: [
+                        [0]
+                    ],
+                    channels: {
+                        text: {
+                            value: [label === void 0 ? inferAxisLabel(k3, scale5, cla) : label]
+                        }
+                    }
+                };
+            }
+        }) : null
+    );
+}
+
+function axisKx(k3, anchor, data, {
+    color: color5 = "currentColor",
+    opacity: opacity3 = 1,
+    stroke = color5,
+    strokeOpacity = opacity3,
+    strokeWidth = 1,
+    fill = color5,
+    fillOpacity = opacity3,
+    textAnchor,
+    textStroke,
+    textStrokeOpacity,
+    textStrokeWidth,
+    tickSize = k3 === "x" ? 6 : 0,
+    tickPadding,
+    tickRotate,
+    y: y7,
+    marginTop = anchor === "top" ? 30 : 0,
+    marginRight = 20,
+    marginBottom = anchor === "bottom" ? 30 : 0,
+    marginLeft = 20,
+    label,
+    labelAnchor,
+    labelOffset,
+    ...options
+}) {
+    tickSize = number5(tickSize);
+    tickPadding = number5(tickPadding);
+    tickRotate = number5(tickRotate);
+    if (labelAnchor !== void 0)
+        labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
+    return marks(
+        tickSize && !isNoneish(stroke) ? axisTickKx(k3, anchor, data, {
+            stroke,
+            strokeOpacity,
+            strokeWidth,
+            tickSize,
+            tickPadding,
+            tickRotate,
+            y: y7,
+            ...options
+        }) : null,
+        !isNoneish(fill) ? axisTextKx(k3, anchor, data, {
+            fill,
+            fillOpacity,
+            stroke: textStroke,
+            strokeOpacity: textStrokeOpacity,
+            strokeWidth: textStrokeWidth,
+            textAnchor,
+            tickSize,
+            tickPadding,
+            tickRotate,
+            y: y7,
+            marginTop,
+            marginRight,
+            marginBottom,
+            marginLeft,
+            ...options
+        }) : null,
+        !isNoneish(fill) && label !== null ? text([], {
+            fill,
+            fillOpacity,
+            ...options,
+            lineWidth: void 0,
+            textOverflow: void 0,
+            facet: "super",
+            x: null,
+            y: null,
+            initializer: function(data2, facets, channels, scales, dimensions) {
+                const scale5 = scales[k3];
+                const {
+                    marginTop: marginTop2,
+                    marginRight: marginRight2,
+                    marginBottom: marginBottom2,
+                    marginLeft: marginLeft2
+                } = k3 === "x" && dimensions.inset || dimensions;
+                const cla = labelAnchor ?? (scale5.bandwidth ? "center" : "right");
+                const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
+                if (cla === "center") {
+                    this.frameAnchor = anchor;
+                    this.textAnchor = void 0;
+                } else {
+                    this.frameAnchor = `${anchor}-${cla}`;
+                    this.textAnchor = cla === "right" ? "end" : "start";
+                }
+                this.lineAnchor = anchor;
+                this.dy = anchor === "top" ? -clo : clo;
+                this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
+                this.ariaLabel = `${k3}-axis label`;
+                return {
+                    facets: [
+                        [0]
+                    ],
+                    channels: {
+                        text: {
+                            value: [label === void 0 ? inferAxisLabel(k3, scale5, cla) : label]
+                        }
+                    }
+                };
+            }
+        }) : null
+    );
+}
+
+function axisTickKy(k3, anchor, data, {
+    strokeWidth = 1,
+    strokeLinecap = null,
+    strokeLinejoin = null,
+    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
+    frameAnchor = anchor,
+    tickSize,
+    inset = 0,
+    insetLeft = inset,
+    insetRight = inset,
+    dx = 0,
+    y: y7 = k3 === "y" ? void 0 : null,
+    ...options
+}) {
+    return axisMark(vectorY, k3, `${k3}-axis tick`, data, {
+        strokeWidth,
+        strokeLinecap,
+        strokeLinejoin,
+        facetAnchor,
+        frameAnchor,
+        y: y7,
+        ...options,
+        dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
+        anchor: "start",
+        length: tickSize,
+        shape: anchor === "left" ? shapeTickLeft : shapeTickRight
+    });
+}
+
+function axisTickKx(k3, anchor, data, {
+    strokeWidth = 1,
+    strokeLinecap = null,
+    strokeLinejoin = null,
+    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
+    frameAnchor = anchor,
+    tickSize,
+    inset = 0,
+    insetTop = inset,
+    insetBottom = inset,
+    dy = 0,
+    x: x7 = k3 === "x" ? void 0 : null,
+    ...options
+}) {
+    return axisMark(vectorX, k3, `${k3}-axis tick`, data, {
+        strokeWidth,
+        strokeLinejoin,
+        strokeLinecap,
+        facetAnchor,
+        frameAnchor,
+        x: x7,
+        ...options,
+        dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
+        anchor: "start",
+        length: tickSize,
+        shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
+    });
+}
+
+function axisTextKy(k3, anchor, data, {
+    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
+    frameAnchor = anchor,
+    tickSize,
+    tickRotate = 0,
+    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
+    tickFormat: tickFormat3,
+    text: text3 = typeof tickFormat3 === "function" ? tickFormat3 : void 0,
+    textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
+    lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
+    fontVariant,
+    inset = 0,
+    insetLeft = inset,
+    insetRight = inset,
+    dx = 0,
+    y: y7 = k3 === "y" ? void 0 : null,
+    ...options
+}) {
+    return axisMark(
+        textY,
+        k3,
+        `${k3}-axis tick label`,
+        data, {
+            facetAnchor,
+            frameAnchor,
+            text: text3 === void 0 ? null : text3,
+            textAnchor,
+            lineAnchor,
+            fontVariant,
+            rotate: tickRotate,
+            y: y7,
+            ...options,
+            dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
+        },
+        function(scale5, ticks3, channels) {
+            if (fontVariant === void 0)
+                this.fontVariant = inferFontVariant3(scale5);
+            if (text3 === void 0)
+                channels.text = inferTextChannel(scale5, ticks3, tickFormat3);
+        }
+    );
+}
+
+function axisTextKx(k3, anchor, data, {
+    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
+    frameAnchor = anchor,
+    tickSize,
+    tickRotate = 0,
+    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
+    tickFormat: tickFormat3,
+    text: text3 = typeof tickFormat3 === "function" ? tickFormat3 : void 0,
+    textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
+    lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
+    fontVariant,
+    inset = 0,
+    insetTop = inset,
+    insetBottom = inset,
+    dy = 0,
+    x: x7 = k3 === "x" ? void 0 : null,
+    ...options
+}) {
+    return axisMark(
+        textX,
+        k3,
+        `${k3}-axis tick label`,
+        data, {
+            facetAnchor,
+            frameAnchor,
+            text: text3 === void 0 ? null : text3,
+            textAnchor,
+            lineAnchor,
+            fontVariant,
+            rotate: tickRotate,
+            x: x7,
+            ...options,
+            dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
+        },
+        function(scale5, ticks3, channels) {
+            if (fontVariant === void 0)
+                this.fontVariant = inferFontVariant3(scale5);
+            if (text3 === void 0)
+                channels.text = inferTextChannel(scale5, ticks3, tickFormat3);
+        }
+    );
+}
+
+function gridY() {
+    const [data, options] = maybeData(...arguments);
+    return gridKy("y", anchorY(options), data, options);
+}
+
+function gridFy() {
+    const [data, options] = maybeData(...arguments);
+    return gridKy("fy", anchorFy(options), data, options);
+}
+
+function gridX() {
+    const [data, options] = maybeData(...arguments);
+    return gridKx("x", anchorX(options), data, options);
+}
+
+function gridFx() {
+    const [data, options] = maybeData(...arguments);
+    return gridKx("fx", anchorFx(options), data, options);
+}
+
+function gridKy(k3, anchor, data, {
+    y: y7 = k3 === "y" ? void 0 : null,
+    x: x7 = null,
+    x1: x13 = anchor === "left" ? x7 : null,
+    x2: x22 = anchor === "right" ? x7 : null,
+    ...options
+}) {
+    return axisMark(ruleY, k3, `${k3}-grid`, data, {
+        y: y7,
+        x1: x13,
+        x2: x22,
+        ...gridDefaults(options)
+    });
+}
+
+function gridKx(k3, anchor, data, {
+    x: x7 = k3 === "x" ? void 0 : null,
+    y: y7 = null,
+    y1: y13 = anchor === "top" ? y7 : null,
+    y2: y22 = anchor === "bottom" ? y7 : null,
+    ...options
+}) {
+    return axisMark(ruleX, k3, `${k3}-grid`, data, {
+        x: x7,
+        y1: y13,
+        y2: y22,
+        ...gridDefaults(options)
+    });
+}
+
+function gridDefaults({
+    color: color5 = "currentColor",
+    opacity: opacity3 = 0.1,
+    stroke = color5,
+    strokeOpacity = opacity3,
+    strokeWidth = 1,
+    ...options
+}) {
+    return {
+        stroke,
+        strokeOpacity,
+        strokeWidth,
+        ...options
+    };
+}
+
+function axisMark(mark, k3, ariaLabel, data, options, initialize) {
+    let channels;
+    const m5 = mark(
+        data,
+        initializer(options, function(data2, facets, _channels, scales) {
+            const {
+                [k3]: scale5
+            } = scales;
+            if (!scale5)
+                throw new Error(`missing scale: ${k3}`);
+            let {
+                ticks: ticks3,
+                tickSpacing,
+                interval: interval3
+            } = options;
+            if (isTemporalScale(scale5) && typeof ticks3 === "string")
+                interval3 = ticks3, ticks3 = void 0;
+            if (data2 == null) {
+                if (isIterable(ticks3)) {
+                    data2 = arrayify2(ticks3);
+                } else if (scale5.ticks) {
+                    if (ticks3 !== void 0) {
+                        data2 = scale5.ticks(ticks3);
+                    } else {
+                        interval3 = maybeRangeInterval(interval3 === void 0 ? scale5.interval : interval3, scale5.type);
+                        if (interval3 !== void 0) {
+                            const [min7, max9] = extent(scale5.domain());
+                            data2 = interval3.range(min7, interval3.offset(interval3.floor(max9)));
+                        } else {
+                            const [min7, max9] = extent(scale5.range());
+                            ticks3 = (max9 - min7) / (tickSpacing === void 0 ? k3 === "x" ? 80 : 35 : tickSpacing);
+                            data2 = scale5.ticks(ticks3);
+                        }
+                    }
+                } else {
+                    data2 = scale5.domain();
+                }
+                if (k3 === "y" || k3 === "x") {
+                    facets = [range4(data2)];
+                } else {
+                    channels[k3] = {
+                        scale: k3,
+                        value: identity6
+                    };
+                    facets = void 0;
+                }
+            }
+            initialize?.call(this, scale5, ticks3, channels);
+            return {
+                data: data2,
+                facets,
+                channels: Object.fromEntries(
+                    Object.entries(channels).map(([name, channel]) => [name, {
+                        ...channel,
+                        value: valueof(data2, channel.value)
+                    }])
+                )
+            };
+        })
+    );
+    if (data == null) {
+        channels = m5.channels;
+        m5.channels = {};
+    } else {
+        channels = {};
+    }
+    m5.ariaLabel = ariaLabel;
+    return m5;
+}
+
+function inferTextChannel(scale5, ticks3, tickFormat3) {
+    return {
+        value: inferTickFormat(scale5, ticks3, tickFormat3)
+    };
+}
+
+function inferTickFormat(scale5, ticks3, tickFormat3) {
+    return scale5.tickFormat ? scale5.tickFormat(isIterable(ticks3) ? null : ticks3, tickFormat3) : tickFormat3 === void 0 ? formatDefault : typeof tickFormat3 === "string" ? (isTemporal(scale5.domain()) ? utcFormat : format)(tickFormat3) : constant2(tickFormat3);
+}
+var shapeTickBottom = {
+    draw(context, l) {
+        context.moveTo(0, 0);
+        context.lineTo(0, l);
+    }
+};
+var shapeTickTop = {
+    draw(context, l) {
+        context.moveTo(0, 0);
+        context.lineTo(0, -l);
+    }
+};
+var shapeTickLeft = {
+    draw(context, l) {
+        context.moveTo(0, 0);
+        context.lineTo(-l, 0);
+    }
+};
+var shapeTickRight = {
+    draw(context, l) {
+        context.moveTo(0, 0);
+        context.lineTo(l, 0);
+    }
+};
+
+function inferFontVariant3(scale5) {
+    return scale5.bandwidth && scale5.interval === void 0 ? void 0 : "tabular-nums";
+}
+
+function inferScaleOrder(scale5) {
+    return Math.sign(orderof(scale5.domain())) * Math.sign(orderof(scale5.range()));
+}
+
+function inferAxisLabel(key, scale5, labelAnchor) {
+    const label = scale5.label;
+    if (scale5.bandwidth || !label?.inferred)
+        return label;
+    const order = inferScaleOrder(scale5);
+    return order ? key === "x" || labelAnchor === "center" ? key === "x" === order < 0 ? `\u2190 ${label}` : `${label} \u2192` : `${order < 0 ? "\u2191 " : "\u2193 "}${label}` : label;
+}
+
+// node_modules/@observablehq/plot/src/marks/frame.js
+var defaults4 = {
+    ariaLabel: "frame",
+    fill: "none",
+    stroke: "currentColor"
+};
+var lineDefaults = {
+    ariaLabel: "frame",
+    fill: null,
+    stroke: "currentColor",
+    strokeLinecap: "square"
+};
+var Frame = class extends Mark {
+    constructor(options = {}) {
+        const {
+            anchor = null,
+                inset = 0,
+                insetTop = inset,
+                insetRight = inset,
+                insetBottom = inset,
+                insetLeft = inset,
+                rx,
+                ry
+        } = options;
+        super(void 0, void 0, options, anchor == null ? defaults4 : lineDefaults);
+        this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
+        this.insetTop = number5(insetTop);
+        this.insetRight = number5(insetRight);
+        this.insetBottom = number5(insetBottom);
+        this.insetLeft = number5(insetLeft);
+        this.rx = number5(rx);
+        this.ry = number5(ry);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            marginTop,
+            marginRight,
+            marginBottom,
+            marginLeft,
+            width,
+            height
+        } = dimensions;
+        const {
+            anchor,
+            insetTop,
+            insetRight,
+            insetBottom,
+            insetLeft,
+            rx,
+            ry
+        } = this;
+        const x13 = marginLeft + insetLeft;
+        const x22 = width - marginRight - insetRight;
+        const y13 = marginTop + insetTop;
+        const y22 = height - marginBottom - insetBottom;
+        return create2(anchor ? "svg:line" : "svg:rect", context).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyTransform, this, {}).call(
+            anchor === "left" ? (line3) => line3.attr("x1", x13).attr("x2", x13).attr("y1", y13).attr("y2", y22) : anchor === "right" ? (line3) => line3.attr("x1", x22).attr("x2", x22).attr("y1", y13).attr("y2", y22) : anchor === "top" ? (line3) => line3.attr("x1", x13).attr("x2", x22).attr("y1", y13).attr("y2", y13) : anchor === "bottom" ? (line3) => line3.attr("x1", x13).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect3) => rect3.attr("x", x13).attr("y", y13).attr("width", x22 - x13).attr("height", y22 - y13).attr("rx", rx).attr("ry", ry)
+        ).node();
+    }
+};
+
+function frame2(options) {
+    return new Frame(options);
+}
+
+// node_modules/@observablehq/plot/src/plot.js
+function plot(options = {}) {
+    const {
+        facet,
+        style,
+        caption,
+        ariaLabel,
+        ariaDescription
+    } = options;
+    const className = maybeClassName(options.className);
+    const marks3 = options.marks === void 0 ? [] : flatMarks(options.marks);
+    const topFacetState = maybeTopFacet(facet, options);
+    const facetStateByMark = /* @__PURE__ */ new Map();
+    for (const mark of marks3) {
+        const facetState = maybeMarkFacet(mark, topFacetState, options);
+        if (facetState)
+            facetStateByMark.set(mark, facetState);
+    }
+    const channelsByScale = /* @__PURE__ */ new Map();
+    if (topFacetState)
+        addScaleChannels(channelsByScale, [topFacetState]);
+    addScaleChannels(channelsByScale, facetStateByMark);
+    const axes = flatMarks(inferAxes(marks3, channelsByScale, options));
+    for (const mark of axes) {
+        const facetState = maybeMarkFacet(mark, topFacetState, options);
+        if (facetState)
+            facetStateByMark.set(mark, facetState);
+    }
+    marks3.unshift(...axes);
+    const facets = createFacets(channelsByScale, options);
+    if (facets !== void 0) {
+        const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
+        for (const mark of marks3) {
+            if (mark.facet === null || mark.facet === "super")
+                continue;
+            const facetState = facetStateByMark.get(mark);
+            if (facetState === void 0)
+                continue;
+            facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
+        }
+        const nonEmpty = /* @__PURE__ */ new Set();
+        for (const {
+                facetsIndex
+            }
+            of facetStateByMark.values()) {
+            facetsIndex?.forEach((index5, i) => {
+                if (index5?.length > 0) {
+                    nonEmpty.add(i);
+                }
+            });
+        }
+        facets.forEach(
+            0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false
+        );
+        for (const mark of marks3) {
+            if (mark.facet === "exclude") {
+                const facetState = facetStateByMark.get(mark);
+                if (facetState !== void 0)
+                    facetState.facetsIndex = facetExclude(facetState.facetsIndex);
+            }
+        }
+    }
+    for (const key of registry.keys()) {
+        if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
+            channelsByScale.set(key, []);
+        }
+    }
+    const stateByMark = /* @__PURE__ */ new Map();
+    for (const mark of marks3) {
+        if (stateByMark.has(mark))
+            throw new Error("duplicate mark; each mark must be unique");
+        const {
+            facetsIndex,
+            channels: facetChannels
+        } = facetStateByMark.get(mark) ?? {};
+        const {
+            data,
+            facets: facets2,
+            channels
+        } = mark.initialize(facetsIndex, facetChannels);
+        applyScaleTransforms(channels, options);
+        stateByMark.set(mark, {
+            data,
+            facets: facets2,
+            channels
+        });
+    }
+    const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark), options);
+    const scales = createScaleFunctions(scaleDescriptors);
+    const dimensions = createDimensions(scaleDescriptors, marks3, options);
+    autoScaleRange(scaleDescriptors, dimensions);
+    const {
+        fx,
+        fy
+    } = scales;
+    const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
+    const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
+    const context = createContext(options, subdimensions, scaleDescriptors);
+    const newByScale = /* @__PURE__ */ new Set();
+    for (const [mark, state] of stateByMark) {
+        if (mark.initializer != null) {
+            const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
+            const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
+            if (update.data !== void 0) {
+                state.data = update.data;
+            }
+            if (update.facets !== void 0) {
+                state.facets = update.facets;
+            }
+            if (update.channels !== void 0) {
+                inferChannelScales(update.channels);
+                Object.assign(state.channels, update.channels);
+                for (const channel of Object.values(update.channels)) {
+                    const {
+                        scale: scale5
+                    } = channel;
+                    if (scale5 != null && registry.get(scale5) !== position) {
+                        applyScaleTransform(channel, options);
+                        newByScale.add(scale5);
+                    }
+                }
+                const {
+                    fx: fx2,
+                    fy: fy2
+                } = update.channels;
+                if (fx2 != null || fy2 != null) {
+                    const facetState = facetStateByMark.get(mark) ?? {
+                        channels: {}
+                    };
+                    if (fx2 != null)
+                        facetState.channels.fx = fx2;
+                    if (fy2 != null)
+                        facetState.channels.fy = fy2;
+                    facetState.groups = facetGroups(state.data, facetState.channels);
+                    facetState.facetsIndex = state.facets = facetFilter(facets, facetState);
+                    facetStateByMark.set(mark, facetState);
+                }
+            }
+        }
+    }
+    if (newByScale.size) {
+        const newChannelsByScale = /* @__PURE__ */ new Map();
+        addScaleChannels(newChannelsByScale, stateByMark, (key) => newByScale.has(key));
+        addScaleChannels(channelsByScale, stateByMark, (key) => newByScale.has(key));
+        const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
+        const newScales = createScaleFunctions(newScaleDescriptors);
+        Object.assign(scaleDescriptors, newScaleDescriptors);
+        Object.assign(scales, newScales);
+    }
+    for (const [mark, state] of stateByMark) {
+        state.values = mark.scale(state.channels, scales, context);
+    }
+    const {
+        width,
+        height
+    } = dimensions;
+    const svg3 = create2("svg", context).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
+        (svg4) => svg4.append("style").text(`
+        .${className} {
+          display: block;
+          background: white;
+          height: auto;
+          height: intrinsic;
+          max-width: 100%;
+        }
+        .${className} text,
+        .${className} tspan {
+          white-space: pre;
+        }
+      `)
+    ).call(applyInlineStyles, style).node();
+    if (facets !== void 0) {
+        const facetDomains = {
+            x: fx?.domain(),
+            y: fy?.domain()
+        };
+        facets.sort(facetOrder(facetDomains));
+        select_default2(svg3).selectAll().data(facets).enter().append("g").attr("aria-label", "facet").attr("transform", facetTranslate(fx, fy, dimensions)).each(function(f) {
+            let empty7 = true;
+            for (const mark of marks3) {
+                if (mark.facet === "super")
+                    continue;
+                const {
+                    channels,
+                    values: values3,
+                    facets: indexes3
+                } = stateByMark.get(mark);
+                if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty))
+                    continue;
+                let index5 = null;
+                if (indexes3) {
+                    index5 = indexes3[facetStateByMark.has(mark) ? f.i : 0];
+                    index5 = mark.filter(index5, channels, values3);
+                    if (index5.length === 0)
+                        continue;
+                    index5.fi = f.i;
+                }
+                const node = mark.render(index5, scales, values3, subdimensions, context);
+                if (node == null)
+                    continue;
+                empty7 = false;
+                this.appendChild(node);
+            }
+            if (empty7)
+                this.remove();
+        });
+    }
+    for (const mark of marks3) {
+        if (facets !== void 0 && mark.facet !== "super")
+            continue;
+        const {
+            channels,
+            values: values3,
+            facets: indexes3
+        } = stateByMark.get(mark);
+        let index5 = null;
+        if (indexes3) {
+            index5 = indexes3[0];
+            index5 = mark.filter(index5, channels, values3);
+            if (index5.length === 0)
+                continue;
+        }
+        const node = mark.render(index5, scales, values3, superdimensions, context);
+        if (node != null)
+            svg3.appendChild(node);
+    }
+    let figure = svg3;
+    const legends = createLegends(scaleDescriptors, context, options);
+    if (caption != null || legends.length > 0) {
+        const {
+            document: document2
+        } = context;
+        figure = document2.createElement("figure");
+        figure.style.maxWidth = "initial";
+        for (const legend3 of legends)
+            figure.appendChild(legend3);
+        figure.appendChild(svg3);
+        if (caption != null) {
+            const figcaption = document2.createElement("figcaption");
+            figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));
+            figure.appendChild(figcaption);
+        }
+    }
+    figure.scale = exposeScales(scaleDescriptors);
+    figure.legend = exposeLegends(scaleDescriptors, context, options);
+    const w = consumeWarnings();
+    if (w > 0) {
+        select_default2(svg3).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
+    }
+    return figure;
+}
+
+function plotThis({
+    marks: marks3 = [],
+    ...options
+} = {}) {
+    return plot({
+        ...options,
+        marks: [...marks3, this]
+    });
+}
+Mark.prototype.plot = plotThis;
+
+function flatMarks(marks3) {
+    return marks3.flat(Infinity).filter((mark) => mark != null).map(markify);
+}
+
+function markify(mark) {
+    return typeof mark.render === "function" ? mark : new Render(mark);
+}
+var Render = class extends Mark {
+    constructor(render2) {
+        if (typeof render2 !== "function")
+            throw new TypeError("invalid mark; missing render function");
+        super();
+        this.render = render2;
+    }
+    render() {}
+};
+
+function applyScaleTransforms(channels, options) {
+    for (const name in channels)
+        applyScaleTransform(channels[name], options);
+    return channels;
+}
+
+function applyScaleTransform(channel, options) {
+    const {
+        scale: scale5
+    } = channel;
+    if (scale5 == null)
+        return;
+    const {
+        type: type3,
+        percent,
+        interval: interval3,
+        transform: transform3 = percent ? (x7) => x7 * 100 : maybeInterval(interval3, type3)?.floor
+    } = options[scale5] ?? {};
+    if (transform3 != null)
+        channel.value = map4(channel.value, transform3);
+}
+
+function inferChannelScales(channels) {
+    for (const name in channels) {
+        inferChannelScale(name, channels[name]);
+    }
+}
+
+function addScaleChannels(channelsByScale, stateByMark, filter7 = yes) {
+    for (const {
+            channels
+        }
+        of stateByMark.values()) {
+        for (const name in channels) {
+            const channel = channels[name];
+            const {
+                scale: scale5
+            } = channel;
+            if (scale5 != null && filter7(scale5)) {
+                const scaleChannels = channelsByScale.get(scale5);
+                if (scaleChannels !== void 0)
+                    scaleChannels.push(channel);
+                else
+                    channelsByScale.set(scale5, [channel]);
+            }
+        }
+    }
+    return channelsByScale;
+}
+
+function maybeTopFacet(facet, options) {
+    if (facet == null)
+        return;
+    const {
+        x: x7,
+        y: y7
+    } = facet;
+    if (x7 == null && y7 == null)
+        return;
+    const data = arrayify2(facet.data ?? x7 ?? y7);
+    if (data === void 0)
+        throw new Error(`missing facet data`);
+    const channels = {};
+    if (x7 != null)
+        channels.fx = createChannel(data, {
+            value: x7,
+            scale: "fx"
+        });
+    if (y7 != null)
+        channels.fy = createChannel(data, {
+            value: y7,
+            scale: "fy"
+        });
+    applyScaleTransforms(channels, options);
+    const groups3 = facetGroups(data, channels);
+    return {
+        channels,
+        groups: groups3,
+        data: facet.data
+    };
+}
+
+function maybeMarkFacet(mark, topFacetState, options) {
+    if (mark.facet === null || mark.facet === "super")
+        return;
+    const {
+        fx,
+        fy
+    } = mark;
+    if (fx != null || fy != null) {
+        const data2 = arrayify2(mark.data ?? fx ?? fy);
+        if (data2 === void 0)
+            throw new Error(`missing facet data in ${mark.ariaLabel}`);
+        if (data2 === null)
+            return;
+        const channels2 = {};
+        if (fx != null)
+            channels2.fx = createChannel(data2, {
+                value: fx,
+                scale: "fx"
+            });
+        if (fy != null)
+            channels2.fy = createChannel(data2, {
+                value: fy,
+                scale: "fy"
+            });
+        applyScaleTransforms(channels2, options);
+        return {
+            channels: channels2,
+            groups: facetGroups(data2, channels2)
+        };
+    }
+    if (topFacetState === void 0)
+        return;
+    const {
+        channels,
+        groups: groups3,
+        data
+    } = topFacetState;
+    if (mark.facet !== "auto" || mark.data === data)
+        return {
+            channels,
+            groups: groups3
+        };
+    if ((groups3.size > 1 || groups3.size === 1 && channels.fx && channels.fy && [...groups3][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {
+        warn(
+            `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
+        );
+    }
+}
+
+function inferAxes(marks3, channelsByScale, options) {
+    let {
+        projection: projection3,
+        x: x7 = {},
+        y: y7 = {},
+        fx = {},
+        fy = {},
+        axis: axis3,
+        grid,
+        facet = {},
+        facet: {
+            axis: facetAxis = axis3,
+            grid: facetGrid
+        } = facet,
+        x: {
+            axis: xAxis = axis3,
+            grid: xGrid = xAxis === null ? null : grid
+        } = x7,
+        y: {
+            axis: yAxis = axis3,
+            grid: yGrid = yAxis === null ? null : grid
+        } = y7,
+        fx: {
+            axis: fxAxis = facetAxis,
+            grid: fxGrid = fxAxis === null ? null : facetGrid
+        } = fx,
+        fy: {
+            axis: fyAxis = facetAxis,
+            grid: fyGrid = fyAxis === null ? null : facetGrid
+        } = fy
+    } = options;
+    if (projection3 || !isScaleOptions(x7) && !hasScaleChannel("x", marks3))
+        xAxis = xGrid = null;
+    if (projection3 || !isScaleOptions(y7) && !hasScaleChannel("y", marks3))
+        yAxis = yGrid = null;
+    if (!channelsByScale.has("fx"))
+        fxAxis = fxGrid = null;
+    if (!channelsByScale.has("fy"))
+        fyAxis = fyGrid = null;
+    if (xAxis === void 0)
+        xAxis = !hasAxis(marks3, "x");
+    if (yAxis === void 0)
+        yAxis = !hasAxis(marks3, "y");
+    if (fxAxis === void 0)
+        fxAxis = !hasAxis(marks3, "fx");
+    if (fyAxis === void 0)
+        fyAxis = !hasAxis(marks3, "fy");
+    if (xAxis === true)
+        xAxis = "bottom";
+    if (yAxis === true)
+        yAxis = "left";
+    if (fxAxis === true)
+        fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
+    if (fyAxis === true)
+        fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
+    const axes = [];
+    maybeGrid(axes, fyGrid, gridFy, fy);
+    maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
+    maybeGrid(axes, fxGrid, gridFx, fx);
+    maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
+    maybeGrid(axes, yGrid, gridY, y7);
+    maybeAxis(axes, yAxis, axisY, "left", "right", options, y7);
+    maybeGrid(axes, xGrid, gridX, x7);
+    maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x7);
+    return axes;
+}
+
+function maybeAxis(axes, axis3, axisType, primary, secondary, defaults41, options) {
+    if (!axis3)
+        return;
+    const both = isBoth(axis3);
+    options = axisOptions(both ? primary : axis3, defaults41, options);
+    const {
+        line: line3
+    } = options;
+    if ((axisType === axisY || axisType === axisX) && line3 && !isNone(line3))
+        axes.push(frame2(lineOptions(options)));
+    axes.push(axisType(options));
+    if (both)
+        axes.push(axisType({
+            ...options,
+            anchor: secondary,
+            label: null
+        }));
+}
+
+function maybeGrid(axes, grid, gridType, options) {
+    if (!grid || isNone(grid))
+        return;
+    axes.push(gridType(gridOptions(grid, options)));
+}
+
+function isBoth(value) {
+    return /^\s*both\s*$/i.test(value);
+}
+
+function axisOptions(anchor, defaults41, {
+    line: line3 = defaults41.line,
+    ticks: ticks3,
+    tickSize,
+    tickSpacing,
+    tickPadding,
+    tickFormat: tickFormat3,
+    tickRotate,
+    fontVariant,
+    ariaLabel,
+    ariaDescription,
+    label = defaults41.label,
+    labelAnchor,
+    labelOffset
+}) {
+    return {
+        anchor,
+        line: line3,
+        ticks: ticks3,
+        tickSize,
+        tickSpacing,
+        tickPadding,
+        tickFormat: tickFormat3,
+        tickRotate,
+        fontVariant,
+        ariaLabel,
+        ariaDescription,
+        label,
+        labelAnchor,
+        labelOffset
+    };
+}
+
+function lineOptions(options) {
+    const {
+        anchor,
+        line: line3
+    } = options;
+    return {
+        anchor,
+        facetAnchor: anchor + "-empty",
+        stroke: line3 === true ? void 0 : line3
+    };
+}
+
+function gridOptions(grid, {
+    stroke = isColor(grid) ? grid : void 0,
+    ticks: ticks3 = isGridTicks(grid) ? grid : void 0,
+    tickSpacing,
+    ariaLabel,
+    ariaDescription
+}) {
+    return {
+        stroke,
+        ticks: ticks3,
+        tickSpacing,
+        ariaLabel,
+        ariaDescription
+    };
+}
+
+function isGridTicks(grid) {
+    switch (typeof grid) {
+        case "number":
+            return true;
+        case "string":
+            return !isColor(grid);
+    }
+    return isIterable(grid) || typeof grid?.range === "function";
+}
+
+function hasAxis(marks3, k3) {
+    const prefix = `${k3}-axis `;
+    return marks3.some((m5) => m5.ariaLabel?.startsWith(prefix));
+}
+
+function hasScaleChannel(k3, marks3) {
+    for (const mark of marks3) {
+        for (const key in mark.channels) {
+            if (mark.channels[key].scale === k3) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+function inheritScaleLabels(newScales, scales) {
+    for (const key in newScales) {
+        const newScale = newScales[key];
+        const scale5 = scales[key];
+        if (newScale.label === void 0 && scale5) {
+            newScale.label = scale5.label;
+        }
+    }
+    return newScales;
+}
+
+function actualDimensions({
+    fx,
+    fy
+}, dimensions) {
+    const {
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft,
+        width,
+        height
+    } = outerDimensions(dimensions);
+    const fxr = fx && outerRange(fx);
+    const fyr = fy && outerRange(fy);
+    return {
+        marginTop: fy ? fyr[0] : marginTop,
+        marginRight: fx ? width - fxr[1] : marginRight,
+        marginBottom: fy ? height - fyr[1] : marginBottom,
+        marginLeft: fx ? fxr[0] : marginLeft,
+        // Some marks, namely the x- and y-axis labels, want to know what the
+        // desired (rather than actual) margins are for positioning.
+        inset: {
+            marginTop: dimensions.marginTop,
+            marginRight: dimensions.marginRight,
+            marginBottom: dimensions.marginBottom,
+            marginLeft: dimensions.marginLeft
+        },
+        width,
+        height
+    };
+}
+
+function outerRange(scale5) {
+    const domain = scale5.domain();
+    let x13 = scale5(domain[0]);
+    let x22 = scale5(domain[domain.length - 1]);
+    if (x22 < x13)
+        [x13, x22] = [x22, x13];
+    return [x13, x22 + scale5.bandwidth()];
+}
+
+// node_modules/@observablehq/plot/src/curve.js
+var curves = /* @__PURE__ */ new Map([
+    ["basis", basis_default2],
+    ["basis-closed", basisClosed_default2],
+    ["basis-open", basisOpen_default],
+    ["bundle", bundle_default],
+    ["bump-x", bumpX],
+    ["bump-y", bumpY],
+    ["cardinal", cardinal_default],
+    ["cardinal-closed", cardinalClosed_default],
+    ["cardinal-open", cardinalOpen_default],
+    ["catmull-rom", catmullRom_default],
+    ["catmull-rom-closed", catmullRomClosed_default],
+    ["catmull-rom-open", catmullRomOpen_default],
+    ["linear", linear_default],
+    ["linear-closed", linearClosed_default],
+    ["monotone-x", monotoneX],
+    ["monotone-y", monotoneY],
+    ["natural", natural_default],
+    ["step", step_default],
+    ["step-after", stepAfter],
+    ["step-before", stepBefore]
+]);
+
+function maybeCurve(curve = linear_default, tension) {
+    if (typeof curve === "function")
+        return curve;
+    const c11 = curves.get(`${curve}`.toLowerCase());
+    if (!c11)
+        throw new Error(`unknown curve: ${curve}`);
+    if (tension !== void 0) {
+        if ("beta" in c11) {
+            return c11.beta(tension);
+        } else if ("tension" in c11) {
+            return c11.tension(tension);
+        } else if ("alpha" in c11) {
+            return c11.alpha(tension);
+        }
+    }
+    return c11;
+}
+
+function maybeCurveAuto(curve = curveAuto, tension) {
+    return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
+}
+
+function curveAuto(context) {
+    return linear_default(context);
+}
+
+// node_modules/@observablehq/plot/src/transforms/bin.js
+function binX(outputs = {
+    y: "count"
+}, options = {}) {
+    [outputs, options] = mergeOptions(outputs, options);
+    const {
+        x: x7,
+        y: y7
+    } = options;
+    return binn(maybeBinValue(x7, options, identity6), null, null, y7, outputs, maybeInsetX(options));
+}
+
+function binY(outputs = {
+    x: "count"
+}, options = {}) {
+    [outputs, options] = mergeOptions(outputs, options);
+    const {
+        x: x7,
+        y: y7
+    } = options;
+    return binn(null, maybeBinValue(y7, options, identity6), x7, null, outputs, maybeInsetY(options));
+}
+
+function bin2(outputs = {
+    fill: "count"
+}, options = {}) {
+    [outputs, options] = mergeOptions(outputs, options);
+    const {
+        x: x7,
+        y: y7
+    } = maybeBinValueTuple(options);
+    return binn(x7, y7, null, null, outputs, maybeInsetX(maybeInsetY(options)));
+}
+
+function maybeDenseInterval(bin5, k3, options = {}) {
+    return options?.interval == null ? options : bin5({
+        [k3]: options?.reduce === void 0 ? reduceFirst : options.reduce,
+        filter: null
+    }, options);
+}
+
+function maybeDenseIntervalX(options) {
+    return maybeDenseInterval(binX, "y", options);
+}
+
+function maybeDenseIntervalY(options) {
+    return maybeDenseInterval(binY, "x", options);
+}
+
+function binn(bx, by, gx, gy, {
+    data: reduceData = reduceIdentity,
+    // TODO avoid materializing when unused?
+    filter: filter7 = reduceCount,
+    // return only non-empty bins by default
+    sort: sort5,
+    reverse: reverse5,
+    ...outputs
+    // output channel definitions
+} = {}, inputs = {}) {
+    bx = maybeBin(bx);
+    by = maybeBin(by);
+    outputs = maybeBinOutputs(outputs, inputs);
+    reduceData = maybeBinReduce(reduceData, identity6);
+    sort5 = sort5 == null ? void 0 : maybeBinOutput("sort", sort5, inputs);
+    filter7 = filter7 == null ? void 0 : maybeBinEvaluator("filter", filter7, inputs);
+    if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
+        gx = null;
+    if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
+        gy = null;
+    const [BX1, setBX1] = maybeColumn(bx);
+    const [BX2, setBX2] = maybeColumn(bx);
+    const [BY1, setBY1] = maybeColumn(by);
+    const [BY2, setBY2] = maybeColumn(by);
+    const [k3, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
+    const [GK, setGK] = maybeColumn(k3);
+    const {
+        x: x7,
+        y: y7,
+        z,
+        fill,
+        stroke,
+        x1: x13,
+        x2: x22,
+        // consumed if x is an output
+        y1: y13,
+        y2: y22,
+        // consumed if y is an output
+        domain,
+        cumulative,
+        thresholds,
+        interval: interval3,
+        ...options
+    } = inputs;
+    const [GZ, setGZ] = maybeColumn(z);
+    const [vfill] = maybeColorChannel(fill);
+    const [vstroke] = maybeColorChannel(stroke);
+    const [GF, setGF] = maybeColumn(vfill);
+    const [GS, setGS] = maybeColumn(vstroke);
+    return {
+        ..."z" in inputs && {
+            z: GZ || z
+        },
+        ..."fill" in inputs && {
+            fill: GF || fill
+        },
+        ..."stroke" in inputs && {
+            stroke: GS || stroke
+        },
+        ...basic(options, (data, facets) => {
+            const K3 = valueof(data, k3);
+            const Z = valueof(data, z);
+            const F = valueof(data, vfill);
+            const S = valueof(data, vstroke);
+            const G = maybeSubgroup(outputs, {
+                z: Z,
+                fill: F,
+                stroke: S
+            });
+            const groupFacets = [];
+            const groupData = [];
+            const GK2 = K3 && setGK([]);
+            const GZ2 = Z && setGZ([]);
+            const GF2 = F && setGF([]);
+            const GS2 = S && setGS([]);
+            const BX12 = bx && setBX1([]);
+            const BX22 = bx && setBX2([]);
+            const BY12 = by && setBY1([]);
+            const BY22 = by && setBY2([]);
+            const bin5 = bing(bx?.(data), by?.(data));
+            let i = 0;
+            for (const o of outputs)
+                o.initialize(data);
+            if (sort5)
+                sort5.initialize(data);
+            if (filter7)
+                filter7.initialize(data);
+            for (const facet of facets) {
+                const groupFacet = [];
+                for (const o of outputs)
+                    o.scope("facet", facet);
+                if (sort5)
+                    sort5.scope("facet", facet);
+                if (filter7)
+                    filter7.scope("facet", facet);
+                for (const [f, I] of maybeGroup(facet, G)) {
+                    for (const [k4, g] of maybeGroup(I, K3)) {
+                        for (const [b, extent5] of bin5(g)) {
+                            if (filter7 && !filter7.reduce(b, extent5))
+                                continue;
+                            groupFacet.push(i++);
+                            groupData.push(reduceData.reduceIndex(b, data, extent5));
+                            if (K3)
+                                GK2.push(k4);
+                            if (Z)
+                                GZ2.push(G === Z ? f : Z[b[0]]);
+                            if (F)
+                                GF2.push(G === F ? f : F[b[0]]);
+                            if (S)
+                                GS2.push(G === S ? f : S[b[0]]);
+                            if (BX12)
+                                BX12.push(extent5.x1), BX22.push(extent5.x2);
+                            if (BY12)
+                                BY12.push(extent5.y1), BY22.push(extent5.y2);
+                            for (const o of outputs)
+                                o.reduce(b, extent5);
+                            if (sort5)
+                                sort5.reduce(b);
+                        }
+                    }
+                }
+                groupFacets.push(groupFacet);
+            }
+            maybeSort(groupFacets, sort5, reverse5);
+            return {
+                data: groupData,
+                facets: groupFacets
+            };
+        }),
+        ...!hasOutput(outputs, "x") && (BX1 ? {
+            x1: BX1,
+            x2: BX2,
+            x: mid(BX1, BX2)
+        } : {
+            x: x7,
+            x1: x13,
+            x2: x22
+        }),
+        ...!hasOutput(outputs, "y") && (BY1 ? {
+            y1: BY1,
+            y2: BY2,
+            y: mid(BY1, BY2)
+        } : {
+            y: y7,
+            y1: y13,
+            y2: y22
+        }),
+        ...GK && {
+            [gk]: GK
+        },
+        ...Object.fromEntries(outputs.map(({
+            name,
+            output
+        }) => [name, output]))
+    };
+}
+
+function mergeOptions({
+    cumulative,
+    domain,
+    thresholds,
+    interval: interval3,
+    ...outputs
+}, options) {
+    return [outputs, {
+        cumulative,
+        domain,
+        thresholds,
+        interval: interval3,
+        ...options
+    }];
+}
+
+function maybeBinValue(value, {
+    cumulative,
+    domain,
+    thresholds,
+    interval: interval3
+}, defaultValue) {
+    value = {
+        ...maybeValue(value)
+    };
+    if (value.domain === void 0)
+        value.domain = domain;
+    if (value.cumulative === void 0)
+        value.cumulative = cumulative;
+    if (value.thresholds === void 0)
+        value.thresholds = thresholds;
+    if (value.interval === void 0)
+        value.interval = interval3;
+    if (value.value === void 0)
+        value.value = defaultValue;
+    value.thresholds = maybeThresholds(value.thresholds, value.interval);
+    return value;
+}
+
+function maybeBinValueTuple(options) {
+    let {
+        x: x7,
+        y: y7
+    } = options;
+    x7 = maybeBinValue(x7, options);
+    y7 = maybeBinValue(y7, options);
+    [x7.value, y7.value] = maybeTuple(x7.value, y7.value);
+    return {
+        x: x7,
+        y: y7
+    };
+}
+
+function maybeBin(options) {
+    if (options == null)
+        return;
+    const {
+        value,
+        cumulative,
+        domain = extent,
+        thresholds
+    } = options;
+    const bin5 = (data) => {
+        let V = valueof(data, value);
+        let T;
+        if (isTemporal(V) || isTimeThresholds(thresholds)) {
+            V = map4(V, coerceDate, Float64Array);
+            let [min7, max9] = typeof domain === "function" ? domain(V) : domain;
+            let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min7, max9) : thresholds;
+            if (typeof t === "number")
+                t = utcTickInterval(min7, max9, t);
+            if (isInterval(t)) {
+                if (domain === extent) {
+                    min7 = t.floor(min7);
+                    max9 = t.offset(t.floor(max9));
+                }
+                t = t.range(min7, t.offset(max9));
+            }
+            T = t;
+        } else {
+            V = coerceNumbers(V);
+            let [min7, max9] = typeof domain === "function" ? domain(V) : domain;
+            let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min7, max9) : thresholds;
+            if (typeof t === "number") {
+                if (domain === extent) {
+                    let step = tickIncrement(min7, max9, t);
+                    if (isFinite(step)) {
+                        if (step > 0) {
+                            let r0 = Math.round(min7 / step);
+                            let r1 = Math.round(max9 / step);
+                            if (!(r0 * step <= min7))
+                                --r0;
+                            if (!(r1 * step > max9))
+                                ++r1;
+                            let n = r1 - r0 + 1;
+                            t = new Float64Array(n);
+                            for (let i = 0; i < n; ++i)
+                                t[i] = (r0 + i) * step;
+                        } else if (step < 0) {
+                            step = -step;
+                            let r0 = Math.round(min7 * step);
+                            let r1 = Math.round(max9 * step);
+                            if (!(r0 / step <= min7))
+                                --r0;
+                            if (!(r1 / step > max9))
+                                ++r1;
+                            let n = r1 - r0 + 1;
+                            t = new Float64Array(n);
+                            for (let i = 0; i < n; ++i)
+                                t[i] = (r0 + i) / step;
+                        } else {
+                            t = [min7];
+                        }
+                    } else {
+                        t = [min7];
+                    }
+                } else {
+                    t = ticks(min7, max9, t);
+                }
+            } else if (isInterval(t)) {
+                if (domain === extent) {
+                    min7 = t.floor(min7);
+                    max9 = t.offset(t.floor(max9));
+                }
+                t = t.range(min7, t.offset(max9));
+            }
+            T = t;
+        }
+        const E3 = [];
+        if (T.length === 1)
+            E3.push([T[0], T[0]]);
+        else
+            for (let i = 1; i < T.length; ++i)
+                E3.push([T[i - 1], T[i]]);
+        E3.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E3, T, V);
+        return E3;
+    };
+    bin5.label = labelof(value);
+    return bin5;
+}
+
+function maybeThresholds(thresholds, interval3, defaultThresholds = thresholdAuto) {
+    if (thresholds === void 0) {
+        return interval3 === void 0 ? defaultThresholds : maybeRangeInterval(interval3);
+    }
+    if (typeof thresholds === "string") {
+        switch (thresholds.toLowerCase()) {
+            case "freedman-diaconis":
+                return thresholdFreedmanDiaconis;
+            case "scott":
+                return thresholdScott;
+            case "sturges":
+                return thresholdSturges;
+            case "auto":
+                return thresholdAuto;
+        }
+        return maybeUtcInterval(thresholds);
+    }
+    return thresholds;
+}
+
+function maybeBinOutputs(outputs, inputs) {
+    return maybeOutputs(outputs, inputs, maybeBinOutput);
+}
+
+function maybeBinOutput(name, reduce3, inputs) {
+    return maybeOutput(name, reduce3, inputs, maybeBinEvaluator);
+}
+
+function maybeBinEvaluator(name, reduce3, inputs) {
+    return maybeEvaluator(name, reduce3, inputs, maybeBinReduce);
+}
+
+function maybeBinReduce(reduce3, value) {
+    return maybeReduce(reduce3, value, maybeBinReduceFallback);
+}
+
+function maybeBinReduceFallback(reduce3) {
+    switch (`${reduce3}`.toLowerCase()) {
+        case "x":
+            return reduceX;
+        case "x1":
+            return reduceX1;
+        case "x2":
+            return reduceX2;
+        case "y":
+            return reduceY;
+        case "y1":
+            return reduceY1;
+        case "y2":
+            return reduceY2;
+    }
+    throw new Error(`invalid bin reduce: ${reduce3}`);
+}
+
+function thresholdAuto(values3, min7, max9) {
+    return Math.min(200, thresholdScott(values3, min7, max9));
+}
+
+function isTimeThresholds(t) {
+    return isTimeInterval(t) || isIterable(t) && isTemporal(t);
+}
+
+function isTimeInterval(t) {
+    return isInterval(t) && typeof t === "function" && t() instanceof Date;
+}
+
+function isInterval(t) {
+    return typeof t?.range === "function";
+}
+
+function bing(EX, EY) {
+    return EX && EY ? function*(I) {
+        const X4 = EX.bin(I);
+        for (const [ix, [x13, x22]] of EX.entries()) {
+            const Y4 = EY.bin(X4[ix]);
+            for (const [iy, [y13, y22]] of EY.entries()) {
+                yield [Y4[iy], {
+                    x1: x13,
+                    y1: y13,
+                    x2: x22,
+                    y2: y22
+                }];
+            }
+        }
+    } : EX ? function*(I) {
+        const X4 = EX.bin(I);
+        for (const [i, [x13, x22]] of EX.entries()) {
+            yield [X4[i], {
+                x1: x13,
+                x2: x22
+            }];
+        }
+    } : function*(I) {
+        const Y4 = EY.bin(I);
+        for (const [i, [y13, y22]] of EY.entries()) {
+            yield [Y4[i], {
+                y1: y13,
+                y2: y22
+            }];
+        }
+    };
+}
+
+function bin1(E3, T, V) {
+    T = coerceNumbers(T);
+    return (I) => {
+        const B5 = E3.map(() => []);
+        for (const i of I)
+            B5[bisect_default(T, V[i]) - 1]?.push(i);
+        return B5;
+    };
+}
+
+function bin1cp(E3, T, V) {
+    const bin5 = bin1(E3, T, V);
+    return (I) => {
+        const B5 = bin5(I);
+        for (let i = 1, n = B5.length; i < n; ++i) {
+            const C4 = B5[i - 1];
+            const b = B5[i];
+            for (const j of C4)
+                b.push(j);
+        }
+        return B5;
+    };
+}
+
+function bin1cn(E3, T, V) {
+    const bin5 = bin1(E3, T, V);
+    return (I) => {
+        const B5 = bin5(I);
+        for (let i = B5.length - 2; i >= 0; --i) {
+            const C4 = B5[i + 1];
+            const b = B5[i];
+            for (const j of C4)
+                b.push(j);
+        }
+        return B5;
+    };
+}
+
+function mid1(x13, x22) {
+    const m5 = (+x13 + +x22) / 2;
+    return x13 instanceof Date ? new Date(m5) : m5;
+}
+var reduceX = {
+    reduceIndex(I, X4, {
+        x1: x13,
+        x2: x22
+    }) {
+        return mid1(x13, x22);
+    }
+};
+var reduceY = {
+    reduceIndex(I, X4, {
+        y1: y13,
+        y2: y22
+    }) {
+        return mid1(y13, y22);
+    }
+};
+var reduceX1 = {
+    reduceIndex(I, X4, {
+        x1: x13
+    }) {
+        return x13;
+    }
+};
+var reduceX2 = {
+    reduceIndex(I, X4, {
+        x2: x22
+    }) {
+        return x22;
+    }
+};
+var reduceY1 = {
+    reduceIndex(I, X4, {
+        y1: y13
+    }) {
+        return y13;
+    }
+};
+var reduceY2 = {
+    reduceIndex(I, X4, {
+        y2: y22
+    }) {
+        return y22;
+    }
+};
+
+// node_modules/@observablehq/plot/src/transforms/identity.js
+function maybeIdentityX(options = {}) {
+    const {
+        x: x7,
+        x1: x13,
+        x2: x22
+    } = options;
+    return x13 === void 0 && x22 === void 0 && x7 === void 0 ? {
+        ...options,
+        x: identity6
+    } : options;
+}
+
+function maybeIdentityY(options = {}) {
+    const {
+        y: y7,
+        y1: y13,
+        y2: y22
+    } = options;
+    return y13 === void 0 && y22 === void 0 && y7 === void 0 ? {
+        ...options,
+        y: identity6
+    } : options;
+}
+
+// node_modules/@observablehq/plot/src/transforms/stack.js
+function stackX(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        y1: y13,
+        y: y7 = y13,
+        x: x7,
+        ...rest
+    } = options;
+    const [transform3, Y4, x13, x22] = stackAlias(y7, x7, "x", stack3, rest);
+    return {
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x1: x13,
+        x2: x22,
+        x: mid(x13, x22)
+    };
+}
+
+function stackX1(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        y1: y13,
+        y: y7 = y13,
+        x: x7
+    } = options;
+    const [transform3, Y4, X4] = stackAlias(y7, x7, "x", stack3, options);
+    return {
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x: X4
+    };
+}
+
+function stackX2(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        y1: y13,
+        y: y7 = y13,
+        x: x7
+    } = options;
+    const [transform3, Y4, , X4] = stackAlias(y7, x7, "x", stack3, options);
+    return {
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x: X4
+    };
+}
+
+function stackY(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        x1: x13,
+        x: x7 = x13,
+        y: y7,
+        ...rest
+    } = options;
+    const [transform3, X4, y13, y22] = stackAlias(x7, y7, "y", stack3, rest);
+    return {
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y1: y13,
+        y2: y22,
+        y: mid(y13, y22)
+    };
+}
+
+function stackY1(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        x1: x13,
+        x: x7 = x13,
+        y: y7
+    } = options;
+    const [transform3, X4, Y4] = stackAlias(x7, y7, "y", stack3, options);
+    return {
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y: Y4
+    };
+}
+
+function stackY2(stack3 = {}, options = {}) {
+    if (arguments.length === 1)
+        [stack3, options] = mergeOptions2(stack3);
+    const {
+        x1: x13,
+        x: x7 = x13,
+        y: y7
+    } = options;
+    const [transform3, X4, , Y4] = stackAlias(x7, y7, "y", stack3, options);
+    return {
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y: Y4
+    };
+}
+
+function maybeStackX({
+    x: x7,
+    x1: x13,
+    x2: x22,
+    ...options
+} = {}) {
+    if (x13 === void 0 && x22 === void 0)
+        return stackX({
+            x: x7,
+            ...options
+        });
+    [x13, x22] = maybeZero(x7, x13, x22);
+    return {
+        ...options,
+        x1: x13,
+        x2: x22
+    };
+}
+
+function maybeStackY({
+    y: y7,
+    y1: y13,
+    y2: y22,
+    ...options
+} = {}) {
+    if (y13 === void 0 && y22 === void 0)
+        return stackY({
+            y: y7,
+            ...options
+        });
+    [y13, y22] = maybeZero(y7, y13, y22);
+    return {
+        ...options,
+        y1: y13,
+        y2: y22
+    };
+}
+
+function mergeOptions2(options) {
+    const {
+        offset: offset3,
+        order,
+        reverse: reverse5,
+        ...rest
+    } = options;
+    return [{
+        offset: offset3,
+        order,
+        reverse: reverse5
+    }, rest];
+}
+
+function stack(x7, y7 = one2, ky3, {
+    offset: offset3,
+    order,
+    reverse: reverse5
+}, options) {
+    const z = maybeZ(options);
+    const [X4, setX] = maybeColumn(x7);
+    const [Y15, setY1] = column(y7);
+    const [Y25, setY2] = column(y7);
+    offset3 = maybeOffset(offset3);
+    order = maybeOrder(order, offset3, ky3);
+    return [
+        basic(options, (data, facets) => {
+            const X5 = x7 == null ? void 0 : setX(valueof(data, x7));
+            const Y4 = valueof(data, y7, Float64Array);
+            const Z = valueof(data, z);
+            const O = order && order(data, X5, Y4, Z);
+            const n = data.length;
+            const Y16 = setY1(new Float64Array(n));
+            const Y26 = setY2(new Float64Array(n));
+            const facetstacks = [];
+            for (const facet of facets) {
+                const stacks = X5 ? Array.from(group(facet, (i) => X5[i]).values()) : [facet];
+                if (O)
+                    applyOrder(stacks, O);
+                for (const stack3 of stacks) {
+                    let yn = 0,
+                        yp = 0;
+                    if (reverse5)
+                        stack3.reverse();
+                    for (const i of stack3) {
+                        const y8 = Y4[i];
+                        if (y8 < 0)
+                            yn = Y26[i] = (Y16[i] = yn) + y8;
+                        else if (y8 > 0)
+                            yp = Y26[i] = (Y16[i] = yp) + y8;
+                        else
+                            Y26[i] = Y16[i] = yp;
+                    }
+                }
+                facetstacks.push(stacks);
+            }
+            if (offset3)
+                offset3(facetstacks, Y16, Y26, Z);
+            return {
+                data,
+                facets
+            };
+        }),
+        X4,
+        Y15,
+        Y25
+    ];
+}
+var stackAlias = stack;
+
+function maybeOffset(offset3) {
+    if (offset3 == null)
+        return;
+    if (typeof offset3 === "function")
+        return offset3;
+    switch (`${offset3}`.toLowerCase()) {
+        case "expand":
+        case "normalize":
+            return offsetExpand;
+        case "center":
+        case "silhouette":
+            return offsetCenter;
+        case "wiggle":
+            return offsetWiggle;
+    }
+    throw new Error(`unknown offset: ${offset3}`);
+}
+
+function extent2(stack3, Y25) {
+    let min7 = 0,
+        max9 = 0;
+    for (const i of stack3) {
+        const y7 = Y25[i];
+        if (y7 < min7)
+            min7 = y7;
+        if (y7 > max9)
+            max9 = y7;
+    }
+    return [min7, max9];
+}
+
+function offsetExpand(facetstacks, Y15, Y25) {
+    for (const stacks of facetstacks) {
+        for (const stack3 of stacks) {
+            const [yn, yp] = extent2(stack3, Y25);
+            for (const i of stack3) {
+                const m5 = 1 / (yp - yn || 1);
+                Y15[i] = m5 * (Y15[i] - yn);
+                Y25[i] = m5 * (Y25[i] - yn);
+            }
+        }
+    }
+}
+
+function offsetCenter(facetstacks, Y15, Y25) {
+    for (const stacks of facetstacks) {
+        for (const stack3 of stacks) {
+            const [yn, yp] = extent2(stack3, Y25);
+            for (const i of stack3) {
+                const m5 = (yp + yn) / 2;
+                Y15[i] -= m5;
+                Y25[i] -= m5;
+            }
+        }
+        offsetZero(stacks, Y15, Y25);
+    }
+    offsetCenterFacets(facetstacks, Y15, Y25);
+}
+
+function offsetWiggle(facetstacks, Y15, Y25, Z) {
+    for (const stacks of facetstacks) {
+        const prev = new InternMap();
+        let y7 = 0;
+        for (const stack3 of stacks) {
+            let j = -1;
+            const Fi = stack3.map((i) => Math.abs(Y25[i] - Y15[i]));
+            const Df = stack3.map((i) => {
+                j = Z ? Z[i] : ++j;
+                const value = Y25[i] - Y15[i];
+                const diff = prev.has(j) ? value - prev.get(j) : 0;
+                prev.set(j, value);
+                return diff;
+            });
+            const Cf1 = [0, ...cumsum(Df)];
+            for (const i of stack3) {
+                Y15[i] += y7;
+                Y25[i] += y7;
+            }
+            const s1 = sum(Fi);
+            if (s1)
+                y7 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
+        }
+        offsetZero(stacks, Y15, Y25);
+    }
+    offsetCenterFacets(facetstacks, Y15, Y25);
+}
+
+function offsetZero(stacks, Y15, Y25) {
+    const m5 = min(stacks, (stack3) => min(stack3, (i) => Y15[i]));
+    for (const stack3 of stacks) {
+        for (const i of stack3) {
+            Y15[i] -= m5;
+            Y25[i] -= m5;
+        }
+    }
+}
+
+function offsetCenterFacets(facetstacks, Y15, Y25) {
+    const n = facetstacks.length;
+    if (n === 1)
+        return;
+    const facets = facetstacks.map((stacks) => stacks.flat());
+    const m5 = facets.map((I) => (min(I, (i) => Y15[i]) + max(I, (i) => Y25[i])) / 2);
+    const m0 = min(m5);
+    for (let j = 0; j < n; j++) {
+        const p = m0 - m5[j];
+        for (const i of facets[j]) {
+            Y15[i] += p;
+            Y25[i] += p;
+        }
+    }
+}
+
+function maybeOrder(order, offset3, ky3) {
+    if (order === void 0 && offset3 === offsetWiggle)
+        return orderInsideOut;
+    if (order == null)
+        return;
+    if (typeof order === "string") {
+        switch (order.toLowerCase()) {
+            case "value":
+            case ky3:
+                return orderY;
+            case "z":
+                return orderZ;
+            case "sum":
+                return orderSum;
+            case "appearance":
+                return orderAppearance;
+            case "inside-out":
+                return orderInsideOut;
+        }
+        return orderFunction(field(order));
+    }
+    if (typeof order === "function")
+        return orderFunction(order);
+    if (Array.isArray(order))
+        return orderGiven(order);
+    throw new Error(`invalid order: ${order}`);
+}
+
+function orderY(data, X4, Y4) {
+    return Y4;
+}
+
+function orderZ(order, X4, Y4, Z) {
+    return Z;
+}
+
+function orderSum(data, X4, Y4, Z) {
+    return orderZDomain(
+        Z,
+        groupSort(
+            range4(data),
+            (I) => sum(I, (i) => Y4[i]),
+            (i) => Z[i]
+        )
+    );
+}
+
+function orderAppearance(data, X4, Y4, Z) {
+    return orderZDomain(
+        Z,
+        groupSort(
+            range4(data),
+            (I) => X4[greatest(I, (i) => Y4[i])],
+            (i) => Z[i]
+        )
+    );
+}
+
+function orderInsideOut(data, X4, Y4, Z) {
+    const I = range4(data);
+    const K3 = groupSort(
+        I,
+        (I2) => X4[greatest(I2, (i) => Y4[i])],
+        (i) => Z[i]
+    );
+    const sums = rollup(
+        I,
+        (I2) => sum(I2, (i) => Y4[i]),
+        (i) => Z[i]
+    );
+    const Kp = [],
+        Kn = [];
+    let s3 = 0;
+    for (const k3 of K3) {
+        if (s3 < 0) {
+            s3 += sums.get(k3);
+            Kp.push(k3);
+        } else {
+            s3 -= sums.get(k3);
+            Kn.push(k3);
+        }
+    }
+    return orderZDomain(Z, Kn.reverse().concat(Kp));
+}
+
+function orderFunction(f) {
+    return (data) => valueof(data, f);
+}
+
+function orderGiven(domain) {
+    return (data, X4, Y4, Z) => orderZDomain(Z, domain);
+}
+
+function orderZDomain(Z, domain) {
+    if (!Z)
+        throw new Error("missing channel: z");
+    domain = new InternMap(domain.map((d, i) => [d, i]));
+    return Z.map((z) => domain.get(z));
+}
+
+function applyOrder(stacks, O) {
+    for (const stack3 of stacks) {
+        stack3.sort((i, j) => ascendingDefined2(O[i], O[j]));
+    }
+}
+
+// node_modules/@observablehq/plot/src/marks/area.js
+var defaults5 = {
+    ariaLabel: "area",
+    strokeWidth: 1,
+    strokeLinecap: "round",
+    strokeLinejoin: "round",
+    strokeMiterlimit: 1
+};
+var Area = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            y1: y13,
+            x2: x22,
+            y2: y22,
+            z,
+            curve,
+            tension
+        } = options;
+        super(
+            data, {
+                x1: {
+                    value: x13,
+                    scale: "x"
+                },
+                y1: {
+                    value: y13,
+                    scale: "y"
+                },
+                x2: {
+                    value: x22,
+                    scale: "x",
+                    optional: true
+                },
+                y2: {
+                    value: y22,
+                    scale: "y",
+                    optional: true
+                },
+                z: {
+                    value: maybeZ(options),
+                    optional: true
+                }
+            },
+            options,
+            defaults5
+        );
+        this.z = z;
+        this.curve = maybeCurve(curve, tension);
+    }
+    filter(index5) {
+        return index5;
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15
+        } = channels;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
+            (g) => g.selectAll().data(groupIndex(index5, [X15, Y15, X25, Y25], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
+                "d",
+                area_default5().curve(this.curve).defined((i) => i >= 0).x0((i) => X15[i]).y0((i) => Y15[i]).x1((i) => X25[i]).y1((i) => Y25[i])
+            )
+        ).node();
+    }
+};
+
+function area(data, options) {
+    if (options === void 0)
+        return areaY(data, {
+            x: first,
+            y: second2
+        });
+    return new Area(data, options);
+}
+
+function areaX(data, options) {
+    const {
+        y: y7 = indexOf,
+        ...rest
+    } = maybeDenseIntervalY(options);
+    return new Area(data, maybeStackX(maybeIdentityX({
+        ...rest,
+        y1: y7,
+        y2: void 0
+    })));
+}
+
+function areaY(data, options) {
+    const {
+        x: x7 = indexOf,
+        ...rest
+    } = maybeDenseIntervalX(options);
+    return new Area(data, maybeStackY(maybeIdentityY({
+        ...rest,
+        x1: x7,
+        x2: void 0
+    })));
+}
+
+// node_modules/@observablehq/plot/src/marker.js
+function markers(mark, {
+    marker,
+    markerStart = marker,
+    markerMid = marker,
+    markerEnd = marker
+} = {}) {
+    mark.markerStart = maybeMarker(markerStart);
+    mark.markerMid = maybeMarker(markerMid);
+    mark.markerEnd = maybeMarker(markerEnd);
+}
+
+function maybeMarker(marker) {
+    if (marker == null || marker === false)
+        return null;
+    if (marker === true)
+        return markerCircleFill;
+    if (typeof marker === "function")
+        return marker;
+    switch (`${marker}`.toLowerCase()) {
+        case "none":
+            return null;
+        case "arrow":
+            return markerArrow;
+        case "dot":
+            return markerDot;
+        case "circle":
+        case "circle-fill":
+            return markerCircleFill;
+        case "circle-stroke":
+            return markerCircleStroke;
+    }
+    throw new Error(`invalid marker: ${marker}`);
+}
+
+function markerArrow(color5, context) {
+    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", "auto").attr("fill", "none").attr("stroke", color5).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
+}
+
+function markerDot(color5, context) {
+    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color5).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
+}
+
+function markerCircleFill(color5, context) {
+    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color5).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
+}
+
+function markerCircleStroke(color5, context) {
+    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color5).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
+}
+var nextMarkerId = 0;
+
+function applyMarkers(path3, mark, {
+    stroke: S
+}, context) {
+    return applyMarkersColor(path3, mark, S && ((i) => S[i]), context);
+}
+
+function applyGroupedMarkers(path3, mark, {
+    stroke: S
+}, context) {
+    return applyMarkersColor(path3, mark, S && (([i]) => S[i]), context);
+}
+
+function applyMarkersColor(path3, {
+    markerStart,
+    markerMid,
+    markerEnd,
+    stroke
+}, strokeof = () => stroke, context) {
+    const iriByMarkerColor = /* @__PURE__ */ new Map();
+
+    function applyMarker(marker) {
+        return function(i) {
+            const color5 = strokeof(i);
+            let iriByColor = iriByMarkerColor.get(marker);
+            if (!iriByColor)
+                iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
+            let iri = iriByColor.get(color5);
+            if (!iri) {
+                const node = this.parentNode.insertBefore(marker(color5, context), this);
+                const id3 = `plot-marker-${++nextMarkerId}`;
+                node.setAttribute("id", id3);
+                iriByColor.set(color5, iri = `url(#${id3})`);
+            }
+            return iri;
+        };
+    }
+    if (markerStart)
+        path3.attr("marker-start", applyMarker(markerStart));
+    if (markerMid)
+        path3.attr("marker-mid", applyMarker(markerMid));
+    if (markerEnd)
+        path3.attr("marker-end", applyMarker(markerEnd));
+}
+
+// node_modules/@observablehq/plot/src/marks/link.js
+var defaults6 = {
+    ariaLabel: "link",
+    fill: "none",
+    stroke: "currentColor",
+    strokeMiterlimit: 1
+};
+var Link = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            y1: y13,
+            x2: x22,
+            y2: y22,
+            curve,
+            tension
+        } = options;
+        super(
+            data, {
+                x1: {
+                    value: x13,
+                    scale: "x"
+                },
+                y1: {
+                    value: y13,
+                    scale: "y"
+                },
+                x2: {
+                    value: x22,
+                    scale: "x",
+                    optional: true
+                },
+                y2: {
+                    value: y22,
+                    scale: "y",
+                    optional: true
+                }
+            },
+            options,
+            defaults6
+        );
+        this.curve = maybeCurveAuto(curve, tension);
+        markers(this, options);
+    }
+    project(channels, values3, context) {
+        if (this.curve !== curveAuto) {
+            super.project(channels, values3, context);
+        }
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15
+        } = channels;
+        const {
+            curve
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).attr(
+                "d",
+                curve === curveAuto && context.projection ? sphereLink(context.projection, X15, Y15, X25, Y25) : (i) => {
+                    const p = pathRound();
+                    const c11 = curve(p);
+                    c11.lineStart();
+                    c11.point(X15[i], Y15[i]);
+                    c11.point(X25[i], Y25[i]);
+                    c11.lineEnd();
+                    return p;
+                }
+            ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
+        ).node();
+    }
+};
+
+function sphereLink(projection3, X15, Y15, X25, Y25) {
+    const path3 = path_default(projection3);
+    X15 = coerceNumbers(X15);
+    Y15 = coerceNumbers(Y15);
+    X25 = coerceNumbers(X25);
+    Y25 = coerceNumbers(Y25);
+    return (i) => path3({
+        type: "LineString",
+        coordinates: [
+            [X15[i], Y15[i]],
+            [X25[i], Y25[i]]
+        ]
+    });
+}
+
+function link3(data, options = {}) {
+    let {
+        x: x7,
+        x1: x13,
+        x2: x22,
+        y: y7,
+        y1: y13,
+        y2: y22,
+        ...remainingOptions
+    } = options;
+    [x13, x22] = maybeSameValue(x7, x13, x22);
+    [y13, y22] = maybeSameValue(y7, y13, y22);
+    return new Link(data, {
+        ...remainingOptions,
+        x1: x13,
+        x2: x22,
+        y1: y13,
+        y2: y22
+    });
+}
+
+function maybeSameValue(x7, x13, x22) {
+    if (x7 === void 0) {
+        if (x13 === void 0) {
+            if (x22 !== void 0)
+                return [x22];
+        } else {
+            if (x22 === void 0)
+                return [x13];
+        }
+    } else if (x13 === void 0) {
+        return x22 === void 0 ? [x7] : [x7, x22];
+    } else if (x22 === void 0) {
+        return [x7, x13];
+    }
+    return [x13, x22];
+}
+
+// node_modules/@observablehq/plot/src/marks/arrow.js
+var defaults7 = {
+    ariaLabel: "arrow",
+    fill: "none",
+    stroke: "currentColor",
+    strokeLinecap: "round",
+    strokeMiterlimit: 1,
+    strokeWidth: 1.5
+};
+var Arrow = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            y1: y13,
+            x2: x22,
+            y2: y22,
+            bend = 0,
+            headAngle = 60,
+            headLength = 8,
+            // Disable the arrow with headLength = 0; or, use Plot.link.
+            inset = 0,
+            insetStart = inset,
+            insetEnd = inset
+        } = options;
+        super(
+            data, {
+                x1: {
+                    value: x13,
+                    scale: "x"
+                },
+                y1: {
+                    value: y13,
+                    scale: "y"
+                },
+                x2: {
+                    value: x22,
+                    scale: "x",
+                    optional: true
+                },
+                y2: {
+                    value: y22,
+                    scale: "y",
+                    optional: true
+                }
+            },
+            options,
+            defaults7
+        );
+        this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
+        this.headAngle = +headAngle;
+        this.headLength = +headLength;
+        this.insetStart = +insetStart;
+        this.insetEnd = +insetEnd;
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15,
+            SW
+        } = channels;
+        const {
+            strokeWidth,
+            bend,
+            headAngle,
+            headLength,
+            insetStart,
+            insetEnd
+        } = this;
+        const sw = SW ? (i) => SW[i] : constant2(strokeWidth === void 0 ? 1 : strokeWidth);
+        const bendAngle = bend * radians3;
+        const wingAngle = headAngle * radians3 / 2;
+        const wingScale = headLength / 1.5;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
+                let x13 = X15[i],
+                    y13 = Y15[i],
+                    x22 = X25[i],
+                    y22 = Y25[i];
+                const lineLength = Math.hypot(x22 - x13, y22 - y13);
+                if (lineLength <= insetStart + insetEnd)
+                    return null;
+                let lineAngle = Math.atan2(y22 - y13, x22 - x13);
+                const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);
+                const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
+                if (insetStart || insetEnd) {
+                    if (r < 1e5) {
+                        const sign5 = Math.sign(bendAngle);
+                        const [cx, cy] = pointPointCenter([x13, y13], [x22, y22], r, sign5);
+                        if (insetStart) {
+                            [x13, y13] = circleCircleIntersect([cx, cy, r], [x13, y13, insetStart], -sign5 * Math.sign(insetStart));
+                        }
+                        if (insetEnd) {
+                            const [x7, y7] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign5 * Math.sign(insetEnd));
+                            lineAngle += Math.atan2(y7 - cy, x7 - cx) - Math.atan2(y22 - cy, x22 - cx);
+                            x22 = x7, y22 = y7;
+                        }
+                    } else {
+                        const dx = x22 - x13,
+                            dy = y22 - y13,
+                            d = Math.hypot(dx, dy);
+                        if (insetStart)
+                            x13 += dx / d * insetStart, y13 += dy / d * insetStart;
+                        if (insetEnd)
+                            x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;
+                    }
+                }
+                const endAngle = lineAngle + bendAngle;
+                const leftAngle = endAngle + wingAngle;
+                const rightAngle = endAngle - wingAngle;
+                const x32 = x22 - headLength2 * Math.cos(leftAngle);
+                const y32 = y22 - headLength2 * Math.sin(leftAngle);
+                const x42 = x22 - headLength2 * Math.cos(rightAngle);
+                const y42 = y22 - headLength2 * Math.sin(rightAngle);
+                return `M${x13},${y13}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x42},${y42}`;
+            }).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function pointPointCenter([ax, ay], [bx, by], r, sign5) {
+    const dx = bx - ax,
+        dy = by - ay,
+        d = Math.hypot(dx, dy);
+    const k3 = sign5 * Math.sqrt(r * r - d * d / 4) / d;
+    return [(ax + bx) / 2 - dy * k3, (ay + by) / 2 + dx * k3];
+}
+
+function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign5) {
+    const dx = bx - ax,
+        dy = by - ay,
+        d = Math.hypot(dx, dy);
+    const x7 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
+    const y7 = sign5 * Math.sqrt(ar * ar - x7 * x7);
+    return [ax + (dx * x7 + dy * y7) / d, ay + (dy * x7 - dx * y7) / d];
+}
+
+function arrow(data, options = {}) {
+    let {
+        x: x7,
+        x1: x13,
+        x2: x22,
+        y: y7,
+        y1: y13,
+        y2: y22,
+        ...remainingOptions
+    } = options;
+    [x13, x22] = maybeSameValue(x7, x13, x22);
+    [y13, y22] = maybeSameValue(y7, y13, y22);
+    return new Arrow(data, {
+        ...remainingOptions,
+        x1: x13,
+        x2: x22,
+        y1: y13,
+        y2: y22
+    });
+}
+
+// node_modules/@observablehq/plot/src/marks/bar.js
+var AbstractBar = class extends Mark {
+    constructor(data, channels, options = {}, defaults41) {
+        super(data, channels, options, defaults41);
+        const {
+            inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry
+        } = options;
+        this.insetTop = number5(insetTop);
+        this.insetRight = number5(insetRight);
+        this.insetBottom = number5(insetBottom);
+        this.insetLeft = number5(insetLeft);
+        this.rx = impliedString(rx, "auto");
+        this.ry = impliedString(ry, "auto");
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            rx,
+            ry
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("rect").call(applyDirectStyles, this).attr("x", this._x(scales, channels, dimensions)).attr("width", this._width(scales, channels, dimensions)).attr("y", this._y(scales, channels, dimensions)).attr("height", this._height(scales, channels, dimensions)).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+    _x(scales, {
+        x: X4
+    }, {
+        marginLeft
+    }) {
+        const {
+            insetLeft
+        } = this;
+        return X4 ? (i) => X4[i] + insetLeft : marginLeft + insetLeft;
+    }
+    _y(scales, {
+        y: Y4
+    }, {
+        marginTop
+    }) {
+        const {
+            insetTop
+        } = this;
+        return Y4 ? (i) => Y4[i] + insetTop : marginTop + insetTop;
+    }
+    _width({
+        x: x7
+    }, {
+        x: X4
+    }, {
+        marginRight,
+        marginLeft,
+        width
+    }) {
+        const {
+            insetLeft,
+            insetRight
+        } = this;
+        const bandwidth = X4 && x7 ? x7.bandwidth() : width - marginRight - marginLeft;
+        return Math.max(0, bandwidth - insetLeft - insetRight);
+    }
+    _height({
+        y: y7
+    }, {
+        y: Y4
+    }, {
+        marginTop,
+        marginBottom,
+        height
+    }) {
+        const {
+            insetTop,
+            insetBottom
+        } = this;
+        const bandwidth = Y4 && y7 ? y7.bandwidth() : height - marginTop - marginBottom;
+        return Math.max(0, bandwidth - insetTop - insetBottom);
+    }
+};
+var defaults8 = {
+    ariaLabel: "bar"
+};
+var BarX = class extends AbstractBar {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            x2: x22,
+            y: y7
+        } = options;
+        super(
+            data, {
+                x1: {
+                    value: x13,
+                    scale: "x"
+                },
+                x2: {
+                    value: x22,
+                    scale: "x"
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    type: "band",
+                    optional: true
+                }
+            },
+            options,
+            defaults8
+        );
+    }
+    _transform(selection3, mark, {
+        x: x7
+    }) {
+        selection3.call(applyTransform, mark, {
+            x: x7
+        }, 0, 0);
+    }
+    _x({
+        x: x7
+    }, {
+        x1: X15,
+        x2: X25
+    }, {
+        marginLeft
+    }) {
+        const {
+            insetLeft
+        } = this;
+        return isCollapsed(x7) ? marginLeft + insetLeft : (i) => Math.min(X15[i], X25[i]) + insetLeft;
+    }
+    _width({
+        x: x7
+    }, {
+        x1: X15,
+        x2: X25
+    }, {
+        marginRight,
+        marginLeft,
+        width
+    }) {
+        const {
+            insetLeft,
+            insetRight
+        } = this;
+        return isCollapsed(x7) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X25[i] - X15[i]) - insetLeft - insetRight);
+    }
+};
+var BarY = class extends AbstractBar {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y1: y13,
+            y2: y22
+        } = options;
+        super(
+            data, {
+                y1: {
+                    value: y13,
+                    scale: "y"
+                },
+                y2: {
+                    value: y22,
+                    scale: "y"
+                },
+                x: {
+                    value: x7,
+                    scale: "x",
+                    type: "band",
+                    optional: true
+                }
+            },
+            options,
+            defaults8
+        );
+    }
+    _transform(selection3, mark, {
+        y: y7
+    }) {
+        selection3.call(applyTransform, mark, {
+            y: y7
+        }, 0, 0);
+    }
+    _y({
+        y: y7
+    }, {
+        y1: Y15,
+        y2: Y25
+    }, {
+        marginTop
+    }) {
+        const {
+            insetTop
+        } = this;
+        return isCollapsed(y7) ? marginTop + insetTop : (i) => Math.min(Y15[i], Y25[i]) + insetTop;
+    }
+    _height({
+        y: y7
+    }, {
+        y1: Y15,
+        y2: Y25
+    }, {
+        marginTop,
+        marginBottom,
+        height
+    }) {
+        const {
+            insetTop,
+            insetBottom
+        } = this;
+        return isCollapsed(y7) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y25[i] - Y15[i]) - insetTop - insetBottom);
+    }
+};
+
+function barX(data, options = {
+    y: indexOf,
+    x2: identity6
+}) {
+    return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
+}
+
+function barY(data, options = {
+    x: indexOf,
+    y2: identity6
+}) {
+    return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
+}
+
+// node_modules/@observablehq/plot/src/marks/cell.js
+var defaults9 = {
+    ariaLabel: "cell"
+};
+var Cell = class extends AbstractBar {
+    constructor(data, {
+        x: x7,
+        y: y7,
+        ...options
+    } = {}) {
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    type: "band",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    type: "band",
+                    optional: true
+                }
+            },
+            options,
+            defaults9
+        );
+    }
+    _transform(selection3, mark) {
+        selection3.call(applyTransform, mark, {}, 0, 0);
+    }
+};
+
+function cell(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    [x7, y7] = maybeTuple(x7, y7);
+    return new Cell(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+
+function cellX(data, options = {}) {
+    let {
+        x: x7 = indexOf,
+        fill,
+        stroke,
+        ...remainingOptions
+    } = options;
+    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
+        fill = identity6;
+    return new Cell(data, {
+        ...remainingOptions,
+        x: x7,
+        fill,
+        stroke
+    });
+}
+
+function cellY(data, options = {}) {
+    let {
+        y: y7 = indexOf,
+        fill,
+        stroke,
+        ...remainingOptions
+    } = options;
+    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
+        fill = identity6;
+    return new Cell(data, {
+        ...remainingOptions,
+        y: y7,
+        fill,
+        stroke
+    });
+}
+
+// node_modules/@observablehq/plot/src/marks/dot.js
+var defaults10 = {
+    ariaLabel: "dot",
+    fill: "none",
+    stroke: "currentColor",
+    strokeWidth: 1.5
+};
+
+function withDefaultSort(options) {
+    return options.sort === void 0 && options.reverse === void 0 ? sort2({
+        channel: "r",
+        order: "descending"
+    }, options) : options;
+}
+var Dot = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            r,
+            rotate,
+            symbol: symbol3 = circle_default3,
+            frameAnchor
+        } = options;
+        const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
+        const [vsymbol, csymbol] = maybeSymbolChannel(symbol3);
+        const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                r: {
+                    value: vr,
+                    scale: "r",
+                    filter: positive,
+                    optional: true
+                },
+                rotate: {
+                    value: vrotate,
+                    optional: true
+                },
+                symbol: {
+                    value: vsymbol,
+                    scale: "auto",
+                    optional: true
+                }
+            },
+            withDefaultSort(options),
+            defaults10
+        );
+        this.r = cr;
+        this.rotate = crotate;
+        this.symbol = csymbol;
+        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        const {
+            channels
+        } = this;
+        const {
+            symbol: symbolChannel
+        } = channels;
+        if (symbolChannel) {
+            const {
+                fill: fillChannel,
+                stroke: strokeChannel
+            } = channels;
+            symbolChannel.hint = {
+                fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill,
+                stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke
+            };
+        }
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            r: R,
+            rotate: A6,
+            symbol: S
+        } = channels;
+        const {
+            r,
+            rotate,
+            symbol: symbol3
+        } = this;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const circle3 = this.symbol === circle_default3;
+        const size = R ? void 0 : r * r * Math.PI;
+        if (negative(r))
+            index5 = [];
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            (g) => g.selectAll().data(index5).enter().append(circle3 ? "circle" : "path").call(applyDirectStyles, this).call(
+                circle3 ? (selection3) => {
+                    selection3.attr("cx", X4 ? (i) => X4[i] : cx).attr("cy", Y4 ? (i) => Y4[i] : cy).attr("r", R ? (i) => R[i] : r);
+                } : (selection3) => {
+                    selection3.attr(
+                        "transform",
+                        template`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${A6 ? (i) => ` rotate(${A6[i]})` : rotate ? ` rotate(${rotate})` : ``}`
+                    ).attr(
+                        "d",
+                        R && S ? (i) => {
+                            const p = pathRound();
+                            S[i].draw(p, R[i] * R[i] * Math.PI);
+                            return p;
+                        } : R ? (i) => {
+                            const p = pathRound();
+                            symbol3.draw(p, R[i] * R[i] * Math.PI);
+                            return p;
+                        } : S ? (i) => {
+                            const p = pathRound();
+                            S[i].draw(p, size);
+                            return p;
+                        } : (() => {
+                            const p = pathRound();
+                            symbol3.draw(p, size);
+                            return p;
+                        })()
+                    );
+                }
+            ).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function dot(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    if (options.frameAnchor === void 0)
+        [x7, y7] = maybeTuple(x7, y7);
+    return new Dot(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+
+function dotX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new Dot(data, maybeIntervalMidY({
+        ...remainingOptions,
+        x: x7
+    }));
+}
+
+function dotY(data, options = {}) {
+    const {
+        y: y7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new Dot(data, maybeIntervalMidX({
+        ...remainingOptions,
+        y: y7
+    }));
+}
+
+function circle(data, options) {
+    return dot(data, {
+        ...options,
+        symbol: "circle"
+    });
+}
+
+function hexagon(data, options) {
+    return dot(data, {
+        ...options,
+        symbol: "hexagon"
+    });
+}
+
+// node_modules/@observablehq/plot/src/marks/line.js
+var defaults11 = {
+    ariaLabel: "line",
+    fill: "none",
+    stroke: "currentColor",
+    strokeWidth: 1.5,
+    strokeLinecap: "round",
+    strokeLinejoin: "round",
+    strokeMiterlimit: 1
+};
+var Line = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            z,
+            curve,
+            tension
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x"
+                },
+                y: {
+                    value: y7,
+                    scale: "y"
+                },
+                z: {
+                    value: maybeZ(options),
+                    optional: true
+                }
+            },
+            options,
+            defaults11
+        );
+        this.z = z;
+        this.curve = maybeCurveAuto(curve, tension);
+        markers(this, options);
+    }
+    filter(index5) {
+        return index5;
+    }
+    project(channels, values3, context) {
+        if (this.curve !== curveAuto) {
+            super.project(channels, values3, context);
+        }
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: X4,
+            y: Y4
+        } = channels;
+        const {
+            curve
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
+            (g) => g.selectAll().data(groupIndex(index5, [X4, Y4], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
+                "d",
+                curve === curveAuto && context.projection ? sphereLine(context.projection, X4, Y4) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X4[i]).y((i) => Y4[i])
+            )
+        ).node();
+    }
+};
+
+function sphereLine(projection3, X4, Y4) {
+    const path3 = path_default(projection3);
+    X4 = coerceNumbers(X4);
+    Y4 = coerceNumbers(Y4);
+    return (I) => {
+        let line3 = [];
+        const lines = [line3];
+        for (const i of I) {
+            if (i === -1) {
+                line3 = [];
+                lines.push(line3);
+            } else {
+                line3.push([X4[i], Y4[i]]);
+            }
+        }
+        return path3({
+            type: "MultiLineString",
+            coordinates: lines
+        });
+    };
+}
+
+function line(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    [x7, y7] = maybeTuple(x7, y7);
+    return new Line(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+
+function lineX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        y: y7 = indexOf,
+        ...remainingOptions
+    } = options;
+    return new Line(data, maybeDenseIntervalY({
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    }));
+}
+
+function lineY(data, options = {}) {
+    const {
+        x: x7 = indexOf,
+        y: y7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new Line(data, maybeDenseIntervalX({
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    }));
+}
+
+// node_modules/@observablehq/plot/src/marks/rect.js
+var defaults12 = {
+    ariaLabel: "rect"
+};
+var Rect = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x1: x13,
+            y1: y13,
+            x2: x22,
+            y2: y22,
+            inset = 0,
+            insetTop = inset,
+            insetRight = inset,
+            insetBottom = inset,
+            insetLeft = inset,
+            rx,
+            ry
+        } = options;
+        super(
+            data, {
+                x1: {
+                    value: x13,
+                    scale: "x",
+                    optional: true
+                },
+                y1: {
+                    value: y13,
+                    scale: "y",
+                    optional: true
+                },
+                x2: {
+                    value: x22,
+                    scale: "x",
+                    optional: true
+                },
+                y2: {
+                    value: y22,
+                    scale: "y",
+                    optional: true
+                }
+            },
+            options,
+            defaults12
+        );
+        this.insetTop = number5(insetTop);
+        this.insetRight = number5(insetRight);
+        this.insetBottom = number5(insetBottom);
+        this.insetLeft = number5(insetLeft);
+        this.rx = impliedString(rx, "auto");
+        this.ry = impliedString(ry, "auto");
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x1: X15,
+            y1: Y15,
+            x2: X25,
+            y2: Y25
+        } = channels;
+        const {
+            marginTop,
+            marginRight,
+            marginBottom,
+            marginLeft,
+            width,
+            height
+        } = dimensions;
+        const {
+            projection: projection3
+        } = context;
+        const {
+            insetTop,
+            insetRight,
+            insetBottom,
+            insetLeft,
+            rx,
+            ry
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X15 && X25 && x7,
+            y: Y15 && Y25 && y7
+        }, 0, 0).call(
+            (g) => g.selectAll().data(index5).enter().append("rect").call(applyDirectStyles, this).attr(
+                "x",
+                X15 && X25 && (projection3 || !isCollapsed(x7)) ? (i) => Math.min(X15[i], X25[i]) + insetLeft : marginLeft + insetLeft
+            ).attr(
+                "y",
+                Y15 && Y25 && (projection3 || !isCollapsed(y7)) ? (i) => Math.min(Y15[i], Y25[i]) + insetTop : marginTop + insetTop
+            ).attr(
+                "width",
+                X15 && X25 && (projection3 || !isCollapsed(x7)) ? (i) => Math.max(0, Math.abs(X25[i] - X15[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft
+            ).attr(
+                "height",
+                Y15 && Y25 && (projection3 || !isCollapsed(y7)) ? (i) => Math.max(0, Math.abs(Y15[i] - Y25[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom
+            ).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function rect(data, options) {
+    return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
+}
+
+function rectX(data, options = {
+    y: indexOf,
+    interval: 1,
+    x2: identity6
+}) {
+    return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
+}
+
+function rectY(data, options = {
+    x: indexOf,
+    interval: 1,
+    y2: identity6
+}) {
+    return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
+}
+
+// node_modules/@observablehq/plot/src/marks/auto.js
+function autoSpec(data, options) {
+    const {
+        x: x7,
+        y: y7,
+        fx,
+        fy,
+        color: color5,
+        size,
+        mark
+    } = autoImpl(data, options);
+    return {
+        x: x7,
+        y: y7,
+        fx,
+        fy,
+        color: color5,
+        size,
+        mark
+    };
+}
+
+function autoImpl(data, options) {
+    options = normalizeOptions(options);
+    const {
+        x: x7,
+        y: y7,
+        color: color5,
+        size
+    } = options;
+    const X4 = materializeValue(data, x7);
+    const Y4 = materializeValue(data, y7);
+    const C4 = materializeValue(data, color5);
+    const S = materializeValue(data, size);
+    let {
+        fx,
+        fy,
+        x: {
+            value: xValue,
+            reduce: xReduce,
+            zero: xZero,
+            ...xOptions
+        },
+        y: {
+            value: yValue,
+            reduce: yReduce,
+            zero: yZero,
+            ...yOptions
+        },
+        color: {
+            value: colorValue,
+            color: colorColor,
+            reduce: colorReduce
+        },
+        size: {
+            value: sizeValue,
+            reduce: sizeReduce
+        },
+        // TODO constant radius?
+        mark
+    } = options;
+    if (xReduce === void 0)
+        xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? "count" : null;
+    if (yReduce === void 0)
+        yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? "count" : null;
+    if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X4)) && (yValue == null || isOrdinal(Y4))) {
+        sizeReduce = "count";
+    }
+    if (xZero === void 0)
+        xZero = isZeroReducer(xReduce) ? true : void 0;
+    if (yZero === void 0)
+        yZero = isZeroReducer(yReduce) ? true : void 0;
+    if (xValue == null && yValue == null)
+        throw new Error("must specify x or y");
+    if (xReduce != null && yValue == null)
+        throw new Error("reducing x requires y");
+    if (yReduce != null && xValue == null)
+        throw new Error("reducing y requires x");
+    if (mark === void 0) {
+        mark = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal(X4) || isOrdinal(Y4) || xReduce == null && yReduce == null && !isMonotonic(X4) && !isMonotonic(Y4) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
+    }
+    let Z;
+    let colorMode;
+    let markImpl;
+    switch (mark) {
+        case "dot":
+            markImpl = dot;
+            colorMode = "stroke";
+            break;
+        case "line":
+            markImpl = X4 && Y4 ? line : X4 ? lineX : lineY;
+            colorMode = "stroke";
+            if (isHighCardinality(C4))
+                Z = null;
+            break;
+        case "area":
+            markImpl = yZero ? areaY : xZero || Y4 && isMonotonic(Y4) ? areaX : areaY;
+            colorMode = "fill";
+            if (isHighCardinality(C4))
+                Z = null;
+            break;
+        case "rule":
+            markImpl = X4 ? ruleX : ruleY;
+            colorMode = "stroke";
+            break;
+        case "bar":
+            markImpl = yZero ? isOrdinalReduced(xReduce, X4) ? barY : rectY : xZero ? isOrdinalReduced(yReduce, Y4) ? barX : rectX : isOrdinalReduced(xReduce, X4) && isOrdinalReduced(yReduce, Y4) ? cell : isOrdinalReduced(xReduce, X4) ? barY : isOrdinalReduced(yReduce, Y4) ? barX : rectY;
+            colorMode = "fill";
+            break;
+        default:
+            throw new Error(`invalid mark: ${mark}`);
+    }
+    let markOptions = {
+        fx,
+        fy,
+        x: X4 ?? void 0,
+        // treat null x as undefined for implicit stack
+        y: Y4 ?? void 0,
+        // treat null y as undefined for implicit stack
+        [colorMode]: C4 ?? colorColor,
+        z: Z,
+        r: S ?? void 0
+        // treat null size as undefined for default constant radius
+    };
+    let transformImpl;
+    let transformOptions = {
+        [colorMode]: colorReduce ?? void 0,
+        r: sizeReduce ?? void 0
+    };
+    if (xReduce != null && yReduce != null) {
+        throw new Error(`cannot reduce both x and y`);
+    } else if (yReduce != null) {
+        transformOptions.y = yReduce;
+        transformImpl = isOrdinal(X4) ? groupX : binX;
+    } else if (xReduce != null) {
+        transformOptions.x = xReduce;
+        transformImpl = isOrdinal(Y4) ? groupY : binY;
+    } else if (colorReduce != null || sizeReduce != null) {
+        if (X4 && Y4) {
+            transformImpl = isOrdinal(X4) && isOrdinal(Y4) ? group2 : isOrdinal(X4) ? binY : isOrdinal(Y4) ? binX : bin2;
+        } else if (X4) {
+            transformImpl = isOrdinal(X4) ? groupX : binX;
+        } else if (Y4) {
+            transformImpl = isOrdinal(Y4) ? groupY : binY;
+        }
+    }
+    if (transformImpl === bin2 || transformImpl === binX)
+        markOptions.x = {
+            value: X4,
+            ...xOptions
+        };
+    if (transformImpl === bin2 || transformImpl === binY)
+        markOptions.y = {
+            value: Y4,
+            ...yOptions
+        };
+    if (xZero === void 0)
+        xZero = X4 && !(transformImpl === bin2 || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);
+    if (yZero === void 0)
+        yZero = Y4 && !(transformImpl === bin2 || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);
+    return {
+        fx: fx ?? null,
+        fy: fy ?? null,
+        x: {
+            value: xValue ?? null,
+            reduce: xReduce ?? null,
+            zero: !!xZero,
+            ...xOptions
+        },
+        y: {
+            value: yValue ?? null,
+            reduce: yReduce ?? null,
+            zero: !!yZero,
+            ...yOptions
+        },
+        color: {
+            value: colorValue ?? null,
+            reduce: colorReduce ?? null,
+            ...colorColor !== void 0 && {
+                color: colorColor
+            }
+        },
+        size: {
+            value: sizeValue ?? null,
+            reduce: sizeReduce ?? null
+        },
+        mark,
+        markImpl,
+        markOptions,
+        transformImpl,
+        transformOptions,
+        colorMode
+    };
+}
+
+function auto(data, options) {
+    const {
+        fx,
+        fy,
+        x: {
+            zero: xZero
+        },
+        y: {
+            zero: yZero
+        },
+        markImpl,
+        markOptions,
+        transformImpl,
+        transformOptions,
+        colorMode
+    } = autoImpl(data, options);
+    const frames = fx != null || fy != null ? frame2({
+        strokeOpacity: 0.1
+    }) : null;
+    const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];
+    const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions) : markOptions);
+    return colorMode === "stroke" ? marks(frames, rules, mark) : marks(frames, mark, rules);
+}
+
+function isMonotonic(values3) {
+    let previous;
+    let previousOrder;
+    for (const value of values3) {
+        if (value == null)
+            continue;
+        if (previous === void 0) {
+            previous = value;
+            continue;
+        }
+        const order = Math.sign(ascending(previous, value));
+        if (!order)
+            continue;
+        if (previousOrder !== void 0 && order !== previousOrder)
+            return false;
+        previous = value;
+        previousOrder = order;
+    }
+    return true;
+}
+
+function normalizeOptions({
+    x: x7,
+    y: y7,
+    color: color5,
+    size,
+    fx,
+    fy,
+    mark
+} = {}) {
+    if (!isOptions(x7))
+        x7 = makeOptions(x7);
+    if (!isOptions(y7))
+        y7 = makeOptions(y7);
+    if (!isOptions(color5))
+        color5 = isColor(color5) ? {
+            color: color5
+        } : makeOptions(color5);
+    if (!isOptions(size))
+        size = makeOptions(size);
+    if (isOptions(fx))
+        ({
+            value: fx
+        } = makeOptions(fx));
+    if (isOptions(fy))
+        ({
+            value: fy
+        } = makeOptions(fy));
+    if (mark != null)
+        mark = `${mark}`.toLowerCase();
+    return {
+        x: x7,
+        y: y7,
+        color: color5,
+        size,
+        fx,
+        fy,
+        mark
+    };
+}
+
+function materializeValue(data, options) {
+    const V = valueof(data, options.value);
+    if (V)
+        V.label = labelof(options.value);
+    return V;
+}
+
+function makeOptions(value) {
+    return isReducer(value) ? {
+        reduce: value
+    } : {
+        value
+    };
+}
+
+function isZeroReducer(reduce3) {
+    return /^(?:distinct|count|sum|proportion)$/i.test(reduce3);
+}
+
+function isSelectReducer(reduce3) {
+    return /^(?:first|last|mode)$/i.test(reduce3);
+}
+
+function isOrdinalReduced(reduce3, value) {
+    return reduce3 != null && !isSelectReducer(reduce3) || !value ? false : isOrdinal(value);
+}
+
+function isReducer(reduce3) {
+    if (reduce3 == null)
+        return false;
+    if (typeof reduce3.reduceIndex === "function")
+        return true;
+    if (typeof reduce3.reduce === "function" && isObject(reduce3))
+        return true;
+    if (/^p\d{2}$/i.test(reduce3))
+        return true;
+    switch (`${reduce3}`.toLowerCase()) {
+        case "first":
+        case "last":
+        case "count":
+        case "distinct":
+        case "sum":
+        case "proportion":
+        case "proportion-facet":
+        case "deviation":
+        case "min":
+        case "min-index":
+        case "max":
+        case "max-index":
+        case "mean":
+        case "median":
+        case "variance":
+        case "mode":
+            return true;
+    }
+    return false;
+}
+
+function isHighCardinality(value) {
+    return value ? new InternSet(value).size > value.length >> 1 : false;
+}
+
+// node_modules/@observablehq/plot/src/transforms/map.js
+function mapX(map11, options = {}) {
+    return mapAlias(
+        Object.fromEntries(["x", "x1", "x2"].filter((key) => options[key] != null).map((key) => [key, map11])),
+        options
+    );
+}
+
+function mapY(map11, options = {}) {
+    return mapAlias(
+        Object.fromEntries(["y", "y1", "y2"].filter((key) => options[key] != null).map((key) => [key, map11])),
+        options
+    );
+}
+
+function map5(outputs = {}, options = {}) {
+    const z = maybeZ(options);
+    const channels = Object.entries(outputs).map(([key, map11]) => {
+        const input = maybeInput(key, options);
+        if (input == null)
+            throw new Error(`missing channel: ${key}`);
+        const [output, setOutput] = column(input);
+        return {
+            key,
+            input,
+            output,
+            setOutput,
+            map: maybeMap(map11)
+        };
+    });
+    return {
+        ...basic(options, (data, facets) => {
+            const Z = valueof(data, z);
+            const X4 = channels.map(({
+                input
+            }) => valueof(data, input));
+            const MX = channels.map(({
+                setOutput
+            }) => setOutput(new Array(data.length)));
+            for (const facet of facets) {
+                for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
+                    channels.forEach(({
+                        map: map11
+                    }, i) => map11.mapIndex(I, X4[i], MX[i]));
+                }
+            }
+            return {
+                data,
+                facets
+            };
+        }),
+        ...Object.fromEntries(channels.map(({
+            key,
+            output
+        }) => [key, output]))
+    };
+}
+var mapAlias = map5;
+
+function maybeMap(map11) {
+    if (map11 == null)
+        throw new Error("missing map");
+    if (typeof map11.mapIndex === "function")
+        return map11;
+    if (typeof map11.map === "function" && isObject(map11))
+        return mapMap(map11);
+    if (typeof map11 === "function")
+        return mapFunction(map11);
+    switch (`${map11}`.toLowerCase()) {
+        case "cumsum":
+            return mapCumsum;
+        case "rank":
+            return mapFunction(rank);
+        case "quantile":
+            return mapFunction(rankQuantile);
+    }
+    throw new Error(`invalid map: ${map11}`);
+}
+
+function mapMap(map11) {
+    console.warn("deprecated map interface; implement mapIndex instead.");
+    return {
+        mapIndex: map11.map.bind(map11)
+    };
+}
+
+function rankQuantile(V) {
+    const n = count(V) - 1;
+    return rank(V).map((r) => r / n);
+}
+
+function mapFunction(f) {
+    return {
+        mapIndex(I, S, T) {
+            const M3 = f(take(S, I));
+            if (M3.length !== I.length)
+                throw new Error("map function returned a mismatched length");
+            for (let i = 0, n = I.length; i < n; ++i)
+                T[I[i]] = M3[i];
+        }
+    };
+}
+var mapCumsum = {
+    mapIndex(I, S, T) {
+        let sum8 = 0;
+        for (const i of I)
+            T[i] = sum8 += S[i];
+    }
+};
+
+// node_modules/@observablehq/plot/src/marks/tick.js
+var defaults13 = {
+    ariaLabel: "tick",
+    fill: null,
+    stroke: "currentColor"
+};
+var AbstractTick = class extends Mark {
+    constructor(data, channels, options) {
+        super(data, channels, options, defaults13);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+var TickX = class extends AbstractTick {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            inset = 0,
+            insetTop = inset,
+            insetBottom = inset
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x"
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    type: "band",
+                    optional: true
+                }
+            },
+            options
+        );
+        this.insetTop = number5(insetTop);
+        this.insetBottom = number5(insetBottom);
+    }
+    _transform(selection3, mark, {
+        x: x7
+    }) {
+        selection3.call(applyTransform, mark, {
+            x: x7
+        }, offset, 0);
+    }
+    _x1(scales, {
+        x: X4
+    }) {
+        return (i) => X4[i];
+    }
+    _x2(scales, {
+        x: X4
+    }) {
+        return (i) => X4[i];
+    }
+    _y1({
+        y: y7
+    }, {
+        y: Y4
+    }, {
+        marginTop
+    }) {
+        const {
+            insetTop
+        } = this;
+        return Y4 && y7 ? (i) => Y4[i] + insetTop : marginTop + insetTop;
+    }
+    _y2({
+        y: y7
+    }, {
+        y: Y4
+    }, {
+        height,
+        marginBottom
+    }) {
+        const {
+            insetBottom
+        } = this;
+        return Y4 && y7 ? (i) => Y4[i] + y7.bandwidth() - insetBottom : height - marginBottom - insetBottom;
+    }
+};
+var TickY = class extends AbstractTick {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            inset = 0,
+            insetRight = inset,
+            insetLeft = inset
+        } = options;
+        super(
+            data, {
+                y: {
+                    value: y7,
+                    scale: "y"
+                },
+                x: {
+                    value: x7,
+                    scale: "x",
+                    type: "band",
+                    optional: true
+                }
+            },
+            options
+        );
+        this.insetRight = number5(insetRight);
+        this.insetLeft = number5(insetLeft);
+    }
+    _transform(selection3, mark, {
+        y: y7
+    }) {
+        selection3.call(applyTransform, mark, {
+            y: y7
+        }, 0, offset);
+    }
+    _x1({
+        x: x7
+    }, {
+        x: X4
+    }, {
+        marginLeft
+    }) {
+        const {
+            insetLeft
+        } = this;
+        return X4 && x7 ? (i) => X4[i] + insetLeft : marginLeft + insetLeft;
+    }
+    _x2({
+        x: x7
+    }, {
+        x: X4
+    }, {
+        width,
+        marginRight
+    }) {
+        const {
+            insetRight
+        } = this;
+        return X4 && x7 ? (i) => X4[i] + x7.bandwidth() - insetRight : width - marginRight - insetRight;
+    }
+    _y1(scales, {
+        y: Y4
+    }) {
+        return (i) => Y4[i];
+    }
+    _y2(scales, {
+        y: Y4
+    }) {
+        return (i) => Y4[i];
+    }
+};
+
+function tickX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new TickX(data, {
+        ...remainingOptions,
+        x: x7
+    });
+}
+
+function tickY(data, options = {}) {
+    const {
+        y: y7 = identity6,
+        ...remainingOptions
+    } = options;
+    return new TickY(data, {
+        ...remainingOptions,
+        y: y7
+    });
+}
+
+// node_modules/@observablehq/plot/src/marks/box.js
+function boxX(data, options = {}) {
+    const {
+        x: x7 = identity6,
+        y: y7 = null,
+        fill = "#ccc",
+        fillOpacity,
+        stroke = "currentColor",
+        strokeOpacity,
+        strokeWidth = 2,
+        sort: sort5,
+        ...remainingOptions
+    } = options;
+    const group5 = y7 != null ? groupY : groupZ;
+    return marks(
+        ruleY(data, group5({
+            x1: loqr1,
+            x2: hiqr2
+        }, {
+            x: x7,
+            y: y7,
+            stroke,
+            strokeOpacity,
+            ...remainingOptions
+        })),
+        barX(data, group5({
+            x1: "p25",
+            x2: "p75"
+        }, {
+            x: x7,
+            y: y7,
+            fill,
+            fillOpacity,
+            ...remainingOptions
+        })),
+        tickX(data, group5({
+            x: "p50"
+        }, {
+            x: x7,
+            y: y7,
+            stroke,
+            strokeOpacity,
+            strokeWidth,
+            sort: sort5,
+            ...remainingOptions
+        })),
+        dot(data, map5({
+            x: oqr
+        }, {
+            x: x7,
+            y: y7,
+            z: y7,
+            stroke,
+            strokeOpacity,
+            ...remainingOptions
+        }))
+    );
+}
+
+function boxY(data, options = {}) {
+    const {
+        y: y7 = identity6,
+        x: x7 = null,
+        fill = "#ccc",
+        fillOpacity,
+        stroke = "currentColor",
+        strokeOpacity,
+        strokeWidth = 2,
+        sort: sort5,
+        ...remainingOptions
+    } = options;
+    const group5 = x7 != null ? groupX : groupZ;
+    return marks(
+        ruleX(data, group5({
+            y1: loqr1,
+            y2: hiqr2
+        }, {
+            x: x7,
+            y: y7,
+            stroke,
+            strokeOpacity,
+            ...remainingOptions
+        })),
+        barY(data, group5({
+            y1: "p25",
+            y2: "p75"
+        }, {
+            x: x7,
+            y: y7,
+            fill,
+            fillOpacity,
+            ...remainingOptions
+        })),
+        tickY(data, group5({
+            y: "p50"
+        }, {
+            x: x7,
+            y: y7,
+            stroke,
+            strokeOpacity,
+            strokeWidth,
+            sort: sort5,
+            ...remainingOptions
+        })),
+        dot(data, map5({
+            y: oqr
+        }, {
+            x: x7,
+            y: y7,
+            z: x7,
+            stroke,
+            strokeOpacity,
+            ...remainingOptions
+        }))
+    );
+}
+
+function oqr(values3) {
+    const r1 = loqr1(values3);
+    const r2 = hiqr2(values3);
+    return values3.map((v3) => v3 < r1 || v3 > r2 ? v3 : NaN);
+}
+
+function loqr1(values3) {
+    const lo = quartile1(values3) * 2.5 - quartile3(values3) * 1.5;
+    return min(values3, (d) => d >= lo ? d : NaN);
+}
+
+function hiqr2(values3) {
+    const hi = quartile3(values3) * 2.5 - quartile1(values3) * 1.5;
+    return max(values3, (d) => d <= hi ? d : NaN);
+}
+
+function quartile1(values3) {
+    return quantile(values3, 0.25);
+}
+
+function quartile3(values3) {
+    return quantile(values3, 0.75);
+}
+
+// node_modules/@observablehq/plot/src/marks/raster.js
+var defaults14 = {
+    ariaLabel: "raster",
+    stroke: null,
+    pixelSize: 1
+};
+
+function number6(input, name) {
+    const x7 = +input;
+    if (isNaN(x7))
+        throw new Error(`invalid ${name}: ${input}`);
+    return x7;
+}
+
+function integer(input, name) {
+    const x7 = Math.floor(input);
+    if (isNaN(x7))
+        throw new Error(`invalid ${name}: ${input}`);
+    return x7;
+}
+var AbstractRaster = class extends Mark {
+    constructor(data, channels, options = {}, defaults41) {
+        let {
+            width,
+            height,
+            x: x7,
+            y: y7,
+            x1: x13 = x7 == null ? 0 : void 0,
+            y1: y13 = y7 == null ? 0 : void 0,
+            x2: x22 = x7 == null ? width : void 0,
+            y2: y22 = y7 == null ? height : void 0,
+            pixelSize = defaults41.pixelSize,
+            blur: blur4 = 0,
+            interpolate
+        } = options;
+        if (width != null)
+            width = integer(width, "width");
+        if (height != null)
+            height = integer(height, "height");
+        if (x13 != null)
+            x13 = number6(x13, "x1");
+        if (y13 != null)
+            y13 = number6(y13, "y1");
+        if (x22 != null)
+            x22 = number6(x22, "x2");
+        if (y22 != null)
+            y22 = number6(y22, "y2");
+        if (x7 == null && (x13 == null || x22 == null))
+            throw new Error("missing x");
+        if (y7 == null && (y13 == null || y22 == null))
+            throw new Error("missing y");
+        if (data != null && width != null && height != null) {
+            if (x7 === void 0 && x13 != null && x22 != null)
+                x7 = denseX(x13, x22, width, height);
+            if (y7 === void 0 && y13 != null && y22 != null)
+                y7 = denseY(y13, y22, width, height);
+        }
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                x1: {
+                    value: x13 == null ? null : [x13],
+                    scale: "x",
+                    optional: true,
+                    filter: null
+                },
+                y1: {
+                    value: y13 == null ? null : [y13],
+                    scale: "y",
+                    optional: true,
+                    filter: null
+                },
+                x2: {
+                    value: x22 == null ? null : [x22],
+                    scale: "x",
+                    optional: true,
+                    filter: null
+                },
+                y2: {
+                    value: y22 == null ? null : [y22],
+                    scale: "y",
+                    optional: true,
+                    filter: null
+                },
+                ...channels
+            },
+            options,
+            defaults41
+        );
+        this.width = width;
+        this.height = height;
+        this.pixelSize = number6(pixelSize, "pixelSize");
+        this.blur = number6(blur4, "blur");
+        this.interpolate = x7 == null || y7 == null ? null : maybeInterpolate(interpolate);
+    }
+};
+var Raster = class extends AbstractRaster {
+    constructor(data, options = {}) {
+        const {
+            imageRendering
+        } = options;
+        if (data == null) {
+            const {
+                fill,
+                fillOpacity
+            } = options;
+            if (maybeNumberChannel(fillOpacity)[0] !== void 0)
+                options = sampler("fillOpacity", options);
+            if (maybeColorChannel(fill)[0] !== void 0)
+                options = sampler("fill", options);
+        }
+        super(data, void 0, options, defaults14);
+        this.imageRendering = impliedString(imageRendering, "auto");
+    }
+    // Ignore the color scale, so the fill channel is returned unscaled.
+    scale(channels, {
+        color: color5,
+        ...scales
+    }, context) {
+        return super.scale(channels, scales, context);
+    }
+    render(index5, scales, values3, dimensions, context) {
+        const color5 = scales[values3.channels.fill?.scale] ?? ((x7) => x7);
+        const {
+            x: X4,
+            y: Y4
+        } = values3;
+        const {
+            document: document2
+        } = context;
+        const [x13, y13, x22, y22] = renderBounds(values3, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
+        const {
+            pixelSize: k3,
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
+        } = this;
+        const n = w * h;
+        let {
+            fill: F,
+            fillOpacity: FO
+        } = values3;
+        let offset3 = 0;
+        if (this.interpolate) {
+            const kx3 = w / dx;
+            const ky3 = h / dy;
+            const IX = map4(X4, (x7) => (x7 - x13) * kx3, Float64Array);
+            const IY = map4(Y4, (y7) => (y7 - y13) * ky3, Float64Array);
+            if (F)
+                F = this.interpolate(index5, w, h, IX, IY, F);
+            if (FO)
+                FO = this.interpolate(index5, w, h, IX, IY, FO);
+        } else if (this.data == null && index5)
+            offset3 = index5.fi * n;
+        const canvas = document2.createElement("canvas");
+        canvas.width = w;
+        canvas.height = h;
+        const context2d = canvas.getContext("2d");
+        const image3 = context2d.createImageData(w, h);
+        const imageData = image3.data;
+        let {
+            r,
+            g,
+            b
+        } = rgb(this.fill) ?? {
+            r: 0,
+            g: 0,
+            b: 0
+        };
+        let a7 = (this.fillOpacity ?? 1) * 255;
+        for (let i = 0; i < n; ++i) {
+            const j = i << 2;
+            if (F) {
+                const fi = color5(F[i + offset3]);
+                if (fi == null) {
+                    imageData[j + 3] = 0;
+                    continue;
+                }
+                ({
+                    r,
+                    g,
+                    b
+                } = rgb(fi));
+            }
+            if (FO)
+                a7 = FO[i + offset3] * 255;
+            imageData[j + 0] = r;
+            imageData[j + 1] = g;
+            imageData[j + 2] = b;
+            imageData[j + 3] = a7;
+        }
+        if (this.blur > 0)
+            blurImage(image3, this.blur);
+        context2d.putImageData(image3, 0, 0);
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
+            (g2) => g2.append("image").attr("transform", `translate(${x13},${y13}) scale(${Math.sign(x22 - x13)},${Math.sign(y22 - y13)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr, "image-rendering", this.imageRendering).call(applyDirectStyles, this).attr("xlink:href", canvas.toDataURL())
+        ).node();
+    }
+};
+
+function maybeTuples(k3, data, options) {
+    if (arguments.length < 3)
+        options = data, data = null;
+    let {
+        x: x7,
+        y: y7,
+        [k3]: z,
+        ...rest
+    } = options;
+    if (x7 === void 0 && y7 === void 0 && isTuples(data)) {
+        x7 = first, y7 = second2;
+        if (z === void 0)
+            z = third;
+    }
+    return [data, {
+        ...rest,
+        x: x7,
+        y: y7,
+        [k3]: z
+    }];
+}
+
+function raster() {
+    const [data, options] = maybeTuples("fill", ...arguments);
+    return new Raster(
+        data,
+        data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : {
+            ...options,
+            fill: identity6
+        }
+    );
+}
+
+function renderBounds({
+    x1: x13,
+    y1: y13,
+    x2: x22,
+    y2: y22
+}, dimensions, {
+    projection: projection3
+}) {
+    const {
+        width,
+        height,
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft
+    } = dimensions;
+    return [
+        x13 && projection3 == null ? x13[0] : marginLeft,
+        y13 && projection3 == null ? y13[0] : marginTop,
+        x22 && projection3 == null ? x22[0] : width - marginRight,
+        y22 && projection3 == null ? y22[0] : height - marginBottom
+    ];
+}
+
+function rasterBounds({
+    x1: x13,
+    y1: y13,
+    x2: x22,
+    y2: y22
+}, scales, dimensions, context) {
+    const channels = {};
+    if (x13)
+        channels.x1 = x13;
+    if (y13)
+        channels.y1 = y13;
+    if (x22)
+        channels.x2 = x22;
+    if (y22)
+        channels.y2 = y22;
+    return renderBounds(valueObject(channels, scales), dimensions, context);
+}
+
+function sampler(name, options = {}) {
+    const {
+        [name]: value
+    } = options;
+    if (typeof value !== "function")
+        throw new Error(`invalid ${name}: not a function`);
+    return initializer({
+        ...options,
+        [name]: void 0
+    }, function(data, facets, channels, scales, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        if (!x7)
+            throw new Error("missing scale: x");
+        if (!y7)
+            throw new Error("missing scale: y");
+        const [x13, y13, x22, y22] = rasterBounds(channels, scales, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
+        const {
+            pixelSize: k3
+        } = this;
+        const {
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
+        } = options;
+        const V = new Array(w * h * (facets ? facets.length : 1));
+        const kx3 = dx / w;
+        const ky3 = dy / h;
+        let i = 0;
+        for (const facet of facets ?? [void 0]) {
+            for (let yi = 0.5; yi < h; ++yi) {
+                for (let xi = 0.5; xi < w; ++xi, ++i) {
+                    V[i] = value(x7.invert(x13 + xi * kx3), y7.invert(y13 + yi * ky3), facet);
+                }
+            }
+        }
+        return {
+            data: V,
+            facets,
+            channels: {
+                [name]: {
+                    value: V,
+                    scale: "auto"
+                }
+            }
+        };
+    });
+}
+
+function maybeInterpolate(interpolate) {
+    if (typeof interpolate === "function")
+        return interpolate;
+    if (interpolate == null)
+        return interpolateNone;
+    switch (`${interpolate}`.toLowerCase()) {
+        case "none":
+            return interpolateNone;
+        case "nearest":
+            return interpolateNearest;
+        case "barycentric":
+            return interpolatorBarycentric();
+        case "random-walk":
+            return interpolatorRandomWalk();
+    }
+    throw new Error(`invalid interpolate: ${interpolate}`);
+}
+
+function interpolateNone(index5, width, height, X4, Y4, V) {
+    const W = new Array(width * height);
+    for (const i of index5) {
+        if (X4[i] < 0 || X4[i] >= width || Y4[i] < 0 || Y4[i] >= height)
+            continue;
+        W[Math.floor(Y4[i]) * width + Math.floor(X4[i])] = V[i];
+    }
+    return W;
+}
+
+function interpolatorBarycentric({
+    random = lcg(42)
+} = {}) {
+    return (index5, width, height, X4, Y4, V) => {
+        const n = index5.length;
+        const nw = width >> 2;
+        const nh = (height >> 2) - 1;
+        const m5 = n + nw * 2 + nh * 2;
+        const XY3 = new Float64Array(m5 * 2);
+        for (let i2 = 0; i2 < n; ++i2)
+            XY3[i2 * 2] = X4[index5[i2]], XY3[i2 * 2 + 1] = Y4[index5[i2]];
+        let i = n;
+        const addPoint = (x7, y7) => (XY3[i * 2] = x7, XY3[i * 2 + 1] = y7, i++);
+        for (let j = 0; j <= nw; ++j)
+            addPoint(j / nw * width, 0), addPoint(j / nw * width, height);
+        for (let j = 0; j < nh; ++j)
+            addPoint(width, j / nh * height), addPoint(0, j / nh * height);
+        V = take(V, index5);
+        const delaunay = new Delaunay(XY3.subarray(0, n * 2));
+        for (let j = n, ij; j < m5; ++j)
+            V[j] = V[ij = delaunay.find(XY3[j * 2], XY3[j * 2 + 1], ij)];
+        const {
+            points,
+            triangles
+        } = new Delaunay(XY3);
+        const W = new V.constructor(width * height);
+        const mix = mixer(V, random);
+        for (let i2 = 0; i2 < triangles.length; i2 += 3) {
+            const ta = triangles[i2];
+            const tb = triangles[i2 + 1];
+            const tc = triangles[i2 + 2];
+            const Ax = points[2 * ta];
+            const Bx = points[2 * tb];
+            const Cx = points[2 * tc];
+            const Ay = points[2 * ta + 1];
+            const By = points[2 * tb + 1];
+            const Cy = points[2 * tc + 1];
+            const x13 = Math.min(Ax, Bx, Cx);
+            const x22 = Math.max(Ax, Bx, Cx);
+            const y13 = Math.min(Ay, By, Cy);
+            const y22 = Math.max(Ay, By, Cy);
+            const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);
+            if (!z)
+                continue;
+            const va = V[ta];
+            const vb = V[tb];
+            const vc = V[tc];
+            for (let x7 = Math.floor(x13); x7 < x22; ++x7) {
+                for (let y7 = Math.floor(y13); y7 < y22; ++y7) {
+                    if (x7 < 0 || x7 >= width || y7 < 0 || y7 >= height)
+                        continue;
+                    const xp = x7 + 0.5;
+                    const yp = y7 + 0.5;
+                    const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z;
+                    if (ga < 0)
+                        continue;
+                    const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z;
+                    if (gb < 0)
+                        continue;
+                    const gc = 1 - ga - gb;
+                    if (gc < 0)
+                        continue;
+                    W[x7 + width * y7] = mix(va, ga, vb, gb, vc, gc, x7, y7);
+                }
+            }
+        }
+        return W;
+    };
+}
+
+function interpolateNearest(index5, width, height, X4, Y4, V) {
+    const W = new V.constructor(width * height);
+    const delaunay = Delaunay.from(
+        index5,
+        (i) => X4[i],
+        (i) => Y4[i]
+    );
+    let iy, ix;
+    for (let y7 = 0.5, k3 = 0; y7 < height; ++y7) {
+        ix = iy;
+        for (let x7 = 0.5; x7 < width; ++x7, ++k3) {
+            ix = delaunay.find(x7, y7, ix);
+            if (x7 === 0.5)
+                iy = ix;
+            W[k3] = V[index5[ix]];
+        }
+    }
+    return W;
+}
+
+function interpolatorRandomWalk({
+    random = lcg(42),
+    minDistance = 0.5,
+    maxSteps = 2
+} = {}) {
+    return (index5, width, height, X4, Y4, V) => {
+        const W = new V.constructor(width * height);
+        const delaunay = Delaunay.from(
+            index5,
+            (i) => X4[i],
+            (i) => Y4[i]
+        );
+        let iy, ix, iw;
+        for (let y7 = 0.5, k3 = 0; y7 < height; ++y7) {
+            ix = iy;
+            for (let x7 = 0.5; x7 < width; ++x7, ++k3) {
+                let cx = x7;
+                let cy = y7;
+                iw = ix = delaunay.find(cx, cy, ix);
+                if (x7 === 0.5)
+                    iy = ix;
+                let distance;
+                let step = 0;
+                while ((distance = Math.hypot(X4[index5[iw]] - cx, Y4[index5[iw]] - cy)) > minDistance && step < maxSteps) {
+                    const angle3 = random(x7, y7, step) * 2 * Math.PI;
+                    cx += Math.cos(angle3) * distance;
+                    cy += Math.sin(angle3) * distance;
+                    iw = delaunay.find(cx, cy, iw);
+                    ++step;
+                }
+                W[k3] = V[index5[iw]];
+            }
+        }
+        return W;
+    };
+}
+
+function blend(a7, ca5, b, cb, c11, cc3) {
+    return ca5 * a7 + cb * b + cc3 * c11;
+}
+
+function pick(random) {
+    return (a7, ca5, b, cb, c11, cc3, x7, y7) => {
+        const u7 = random(x7, y7);
+        return u7 < ca5 ? a7 : u7 < ca5 + cb ? b : c11;
+    };
+}
+
+function mixer(F, random) {
+    return isNumeric(F) || isTemporal(F) ? blend : pick(random);
+}
+
+function denseX(x13, x22, width) {
+    return {
+        transform(data) {
+            const n = data.length;
+            const X4 = new Float64Array(n);
+            const kx3 = (x22 - x13) / width;
+            const x011 = x13 + kx3 / 2;
+            for (let i = 0; i < n; ++i)
+                X4[i] = i % width * kx3 + x011;
+            return X4;
+        }
+    };
+}
+
+function denseY(y13, y22, width, height) {
+    return {
+        transform(data) {
+            const n = data.length;
+            const Y4 = new Float64Array(n);
+            const ky3 = (y22 - y13) / height;
+            const y011 = y13 + ky3 / 2;
+            for (let i = 0; i < n; ++i)
+                Y4[i] = Math.floor(i / width) % height * ky3 + y011;
+            return Y4;
+        }
+    };
+}
+
+// node_modules/@observablehq/plot/src/marks/contour.js
+var defaults15 = {
+    ariaLabel: "contour",
+    fill: "none",
+    stroke: "currentColor",
+    strokeMiterlimit: 1,
+    pixelSize: 2
+};
+var Contour = class extends AbstractRaster {
+    constructor(data, {
+        smooth = true,
+        value,
+        ...options
+    } = {}) {
+        const channels = styles({}, options, defaults15);
+        if (value === void 0) {
+            for (const key in channels) {
+                if (channels[key].value != null) {
+                    if (value !== void 0)
+                        throw new Error("ambiguous contour value");
+                    value = options[key];
+                    options[key] = "value";
+                }
+            }
+        }
+        if (value != null) {
+            const v3 = {
+                transform: (D5) => D5.map((d) => d.value),
+                label: labelof(value)
+            };
+            for (const key in channels) {
+                if (options[key] === "value") {
+                    options[key] = v3;
+                }
+            }
+        }
+        if (data == null) {
+            if (value == null)
+                throw new Error("missing contour value");
+            options = sampler("value", {
+                value,
+                ...options
+            });
+            value = null;
+        } else {
+            let {
+                interpolate
+            } = options;
+            if (value === void 0)
+                value = identity6;
+            if (interpolate === void 0)
+                options.interpolate = "nearest";
+        }
+        super(data, {
+            value: {
+                value,
+                optional: true
+            }
+        }, contourGeometry(options), defaults15);
+        const contourChannels = {
+            geometry: {
+                value: identity6
+            }
+        };
+        for (const key in this.channels) {
+            const channel = this.channels[key];
+            const {
+                scale: scale5
+            } = channel;
+            if (scale5 === "x" || scale5 === "y" || key === "value")
+                continue;
+            contourChannels[key] = channel;
+            delete this.channels[key];
+        }
+        this.contourChannels = contourChannels;
+        this.smooth = !!smooth;
+    }
+    filter(index5, {
+        x: x7,
+        y: y7,
+        value,
+        ...channels
+    }, values3) {
+        return super.filter(index5, channels, values3);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            geometry: G
+        } = channels;
+        const path3 = path_default();
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
+            g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => path3(G[i])).call(applyChannelStyles, this, channels);
+        }).node();
+    }
+};
+
+function contourGeometry({
+    thresholds,
+    interval: interval3,
+    ...options
+}) {
+    thresholds = maybeThresholds(thresholds, interval3, thresholdSturges);
+    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
+        const [x13, y13, x22, y22] = rasterBounds(channels, scales, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
+        const {
+            pixelSize: k3,
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
+        } = this;
+        const kx3 = w / dx;
+        const ky3 = h / dy;
+        const V = channels.value.value;
+        const VV = [];
+        if (this.interpolate) {
+            const {
+                x: X4,
+                y: Y4
+            } = applyPosition(channels, scales, context);
+            const IX = map4(X4, (x7) => (x7 - x13) * kx3, Float64Array);
+            const IY = map4(Y4, (y7) => (y7 - y13) * ky3, Float64Array);
+            const ichannels = [channels.x, channels.y, channels.value];
+            const ivalues = [IX, IY, V];
+            for (const facet of facets) {
+                const index5 = this.filter(facet, ichannels, ivalues);
+                VV.push(this.interpolate(index5, w, h, IX, IY, V));
+            }
+        } else if (facets) {
+            const n = w * h;
+            const m5 = facets.length;
+            for (let i = 0; i < m5; ++i)
+                VV.push(V.slice(i * n, i * n + n));
+        } else {
+            VV.push(V);
+        }
+        if (this.blur > 0)
+            for (const V2 of VV)
+                blur2({
+                    data: V2,
+                    width: w,
+                    height: h
+                }, this.blur);
+        const T = maybeTicks(thresholds, V, ...finiteExtent(VV));
+        if (T === null)
+            throw new Error(`unsupported thresholds: ${thresholds}`);
+        const {
+            contour: contour3
+        } = contours_default().size([w, h]).smooth(this.smooth);
+        const contourData = [];
+        const contourFacets = [];
+        for (const V2 of VV) {
+            contourFacets.push(range(contourData.length, contourData.push(...map4(T, (t) => contour3(V2, t)))));
+        }
+        for (const {
+                coordinates: coordinates3
+            }
+            of contourData) {
+            for (const rings of coordinates3) {
+                for (const ring of rings) {
+                    for (const point11 of ring) {
+                        point11[0] = point11[0] / kx3 + x13;
+                        point11[1] = point11[1] / ky3 + y13;
+                    }
+                }
+            }
+        }
+        return {
+            data: contourData,
+            facets: contourFacets,
+            channels: createChannels(this.contourChannels, contourData)
+        };
+    });
+}
+
+function maybeTicks(thresholds, V, min7, max9) {
+    if (typeof thresholds?.range === "function")
+        return thresholds.range(thresholds.floor(min7), max9);
+    if (typeof thresholds === "function")
+        thresholds = thresholds(V, min7, max9);
+    if (typeof thresholds !== "number")
+        return arrayify2(thresholds);
+    const tz = ticks(...nice(min7, max9, thresholds), thresholds);
+    while (tz[tz.length - 1] >= max9)
+        tz.pop();
+    while (tz[1] < min7)
+        tz.shift();
+    return tz;
+}
+
+function contour() {
+    return new Contour(...maybeTuples("value", ...arguments));
+}
+
+function finiteExtent(VV) {
+    return [min(VV, (V) => min(V, finite3)), max(VV, (V) => max(V, finite3))];
+}
+
+function finite3(x7) {
+    return isFinite(x7) ? x7 : NaN;
+}
+
+// node_modules/@observablehq/plot/src/marks/delaunay.js
+var delaunayLinkDefaults = {
+    ariaLabel: "delaunay link",
+    fill: "none",
+    stroke: "currentColor",
+    strokeMiterlimit: 1
+};
+var delaunayMeshDefaults = {
+    ariaLabel: "delaunay mesh",
+    fill: null,
+    stroke: "currentColor",
+    strokeOpacity: 0.2
+};
+var hullDefaults = {
+    ariaLabel: "hull",
+    fill: "none",
+    stroke: "currentColor",
+    strokeWidth: 1.5,
+    strokeMiterlimit: 1
+};
+var voronoiDefaults = {
+    ariaLabel: "voronoi",
+    fill: "none",
+    stroke: "currentColor",
+    strokeMiterlimit: 1
+};
+var voronoiMeshDefaults = {
+    ariaLabel: "voronoi mesh",
+    fill: null,
+    stroke: "currentColor",
+    strokeOpacity: 0.2
+};
+var DelaunayLink = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            z,
+            curve,
+            tension
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                z: {
+                    value: z,
+                    optional: true
+                }
+            },
+            options,
+            delaunayLinkDefaults
+        );
+        this.curve = maybeCurve(curve, tension);
+        markers(this, options);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            z: Z
+        } = channels;
+        const {
+            curve
+        } = this;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant2(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant2(cy);
+        const mark = this;
+
+        function links(index6) {
+            let i = -1;
+            const newIndex = [];
+            const newChannels = {};
+            for (const k3 in channels)
+                newChannels[k3] = [];
+            const X15 = [];
+            const X25 = [];
+            const Y15 = [];
+            const Y25 = [];
+
+            function link7(ti, tj) {
+                ti = index6[ti];
+                tj = index6[tj];
+                newIndex.push(++i);
+                X15[i] = xi(ti);
+                Y15[i] = yi(ti);
+                X25[i] = xi(tj);
+                Y25[i] = yi(tj);
+                for (const k3 in channels)
+                    newChannels[k3].push(channels[k3][tj]);
+            }
+            const {
+                halfedges,
+                hull: hull3,
+                triangles
+            } = Delaunay.from(index6, xi, yi);
+            for (let i2 = 0; i2 < halfedges.length; ++i2) {
+                const j = halfedges[i2];
+                if (j > i2)
+                    link7(triangles[i2], triangles[j]);
+            }
+            for (let i2 = 0; i2 < hull3.length; ++i2) {
+                link7(hull3[i2], hull3[(i2 + 1) % hull3.length]);
+            }
+            select_default2(this).selectAll().data(newIndex).join("path").call(applyDirectStyles, mark).attr("d", (i2) => {
+                const p = pathRound();
+                const c11 = curve(p);
+                c11.lineStart();
+                c11.point(X15[i2], Y15[i2]);
+                c11.point(X25[i2], Y25[i2]);
+                c11.lineEnd();
+                return p;
+            }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels, context);
+        }
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            Z ? (g) => g.selectAll().data(group(index5, (i) => Z[i]).values()).enter().append("g").each(links) : (g) => g.datum(index5).each(links)
+        ).node();
+    }
+};
+var AbstractDelaunayMark = class extends Mark {
+    constructor(data, options = {}, defaults41, zof = ({
+        z
+    }) => z) {
+        const {
+            x: x7,
+            y: y7
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                z: {
+                    value: zof(options),
+                    optional: true
+                }
+            },
+            options,
+            defaults41
+        );
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            z: Z
+        } = channels;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant2(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant2(cy);
+        const mark = this;
+
+        function mesh(index6) {
+            const delaunay = Delaunay.from(index6, xi, yi);
+            select_default2(this).append("path").datum(index6[0]).call(applyDirectStyles, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);
+        }
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            Z ? (g) => g.selectAll().data(group(index5, (i) => Z[i]).values()).enter().append("g").each(mesh) : (g) => g.datum(index5).each(mesh)
+        ).node();
+    }
+};
+var DelaunayMesh = class extends AbstractDelaunayMark {
+    constructor(data, options = {}) {
+        super(data, options, delaunayMeshDefaults);
+        this.fill = "none";
+    }
+    _render(delaunay) {
+        return delaunay.render();
+    }
+};
+var Hull = class extends AbstractDelaunayMark {
+    constructor(data, options = {}) {
+        super(data, options, hullDefaults, maybeZ);
+    }
+    _render(delaunay) {
+        return delaunay.renderHull();
+    }
+};
+var Voronoi2 = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            z
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                z: {
+                    value: z,
+                    optional: true
+                }
+            },
+            options,
+            voronoiDefaults
+        );
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            z: Z
+        } = channels;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant2(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant2(cy);
+        const mark = this;
+
+        function cells(index6) {
+            const delaunay = Delaunay.from(index6, xi, yi);
+            const voronoi3 = voronoiof(delaunay, dimensions);
+            select_default2(this).selectAll().data(index6).enter().append("path").call(applyDirectStyles, mark).attr("d", (_, i) => voronoi3.renderCell(i)).call(applyChannelStyles, mark, channels);
+        }
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            Z ? (g) => g.selectAll().data(group(index5, (i) => Z[i]).values()).enter().append("g").each(cells) : (g) => g.datum(index5).each(cells)
+        ).node();
+    }
+};
+var VoronoiMesh = class extends AbstractDelaunayMark {
+    constructor(data, options) {
+        super(data, options, voronoiMeshDefaults);
+        this.fill = "none";
+    }
+    _render(delaunay, dimensions) {
+        return voronoiof(delaunay, dimensions).render();
+    }
+};
+
+function voronoiof(delaunay, dimensions) {
+    const {
+        width,
+        height,
+        marginTop,
+        marginRight,
+        marginBottom,
+        marginLeft
+    } = dimensions;
+    return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);
+}
+
+function delaunayMark(DelaunayMark, data, {
+    x: x7,
+    y: y7,
+    ...options
+} = {}) {
+    [x7, y7] = maybeTuple(x7, y7);
+    return new DelaunayMark(data, {
+        ...options,
+        x: x7,
+        y: y7
+    });
+}
+
+function delaunayLink(data, options) {
+    return delaunayMark(DelaunayLink, data, options);
+}
+
+function delaunayMesh(data, options) {
+    return delaunayMark(DelaunayMesh, data, options);
+}
+
+function hull(data, options) {
+    return delaunayMark(Hull, data, options);
+}
+
+function voronoi(data, options) {
+    return delaunayMark(Voronoi2, data, options);
+}
+
+function voronoiMesh(data, options) {
+    return delaunayMark(VoronoiMesh, data, options);
+}
+
+// node_modules/@observablehq/plot/src/marks/density.js
+var defaults16 = {
+    ariaLabel: "density",
+    fill: "none",
+    stroke: "currentColor",
+    strokeMiterlimit: 1
+};
+var Density = class extends Mark {
+    constructor(data, {
+        x: x7,
+        y: y7,
+        z,
+        weight,
+        fill,
+        stroke,
+        ...options
+    } = {}) {
+        const fillDensity = isDensity(fill) && (fill = "currentColor", true);
+        const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                z: {
+                    value: maybeZ({
+                        z,
+                        fill,
+                        stroke
+                    }),
+                    optional: true
+                },
+                weight: {
+                    value: weight,
+                    optional: true
+                }
+            },
+            densityInitializer({
+                ...options,
+                fill,
+                stroke
+            }, fillDensity, strokeDensity),
+            defaults16
+        );
+        if (fillDensity)
+            this.fill = void 0;
+        if (strokeDensity)
+            this.stroke = void 0;
+        this.z = z;
+    }
+    filter(index5) {
+        return index5;
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            contours
+        } = channels;
+        const path3 = path_default();
+        return create_default("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i) => path3(contours[i]))
+        ).node();
+    }
+};
+
+function density(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    [x7, y7] = maybeTuple(x7, y7);
+    return new Density(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
+
+function densityInitializer(options, fillDensity, strokeDensity) {
+    const k3 = 100;
+    let {
+        bandwidth,
+        thresholds
+    } = options;
+    bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
+    thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers(thresholds) : +thresholds;
+    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
+        const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
+        const Z = channels.z?.value;
+        const {
+            z
+        } = this;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const {
+            width,
+            height
+        } = dimensions;
+        const {
+            x: X4,
+            y: Y4
+        } = applyPosition(channels, scales, context);
+        const newChannels = Object.fromEntries(
+            Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, {
+                ...channel,
+                value: []
+            }])
+        );
+        const FD = fillDensity && [];
+        const SD = strokeDensity && [];
+        const density3 = density_default().x(X4 ? (i) => X4[i] : cx).y(Y4 ? (i) => Y4[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);
+        const facetsContours = [];
+        for (const facet of facets) {
+            const facetContours = [];
+            facetsContours.push(facetContours);
+            for (const index5 of Z ? groupZ2(facet, Z, z) : [facet]) {
+                const contour3 = density3.contours(index5);
+                facetContours.push([index5, contour3]);
+            }
+        }
+        let T = thresholds;
+        if (!(T instanceof TypedArray)) {
+            let maxValue = 0;
+            for (const facetContours of facetsContours) {
+                for (const [, contour3] of facetContours) {
+                    const max9 = contour3.max;
+                    if (max9 > maxValue)
+                        maxValue = max9;
+                }
+            }
+            T = Float64Array.from({
+                length: thresholds - 1
+            }, (_, i) => maxValue * k3 * (i + 1) / thresholds);
+        }
+        const newFacets = [];
+        const contours = [];
+        for (const facetContours of facetsContours) {
+            const newFacet = [];
+            newFacets.push(newFacet);
+            for (const [index5, contour3] of facetContours) {
+                for (const t of T) {
+                    newFacet.push(contours.length);
+                    contours.push(contour3(t / k3));
+                    if (FD)
+                        FD.push(t);
+                    if (SD)
+                        SD.push(t);
+                    for (const key in newChannels) {
+                        newChannels[key].value.push(channels[key].value[index5[0]]);
+                    }
+                }
+            }
+        }
+        if (FD)
+            FD.push(0);
+        if (SD)
+            SD.push(0);
+        return {
+            data,
+            facets: newFacets,
+            channels: {
+                ...newChannels,
+                ...FD && {
+                    fill: {
+                        value: FD,
+                        scale: "color"
+                    }
+                },
+                ...SD && {
+                    stroke: {
+                        value: SD,
+                        scale: "color"
+                    }
+                },
+                contours: {
+                    value: contours
+                }
+            }
+        };
+    });
+}
+
+function isDensity(value) {
+    return /^density$/i.test(value);
+}
+
+// node_modules/@observablehq/plot/src/marks/geo.js
+var defaults17 = {
+    ariaLabel: "geo",
+    fill: "none",
+    stroke: "currentColor",
+    strokeWidth: 1,
+    strokeLinecap: "round",
+    strokeLinejoin: "round",
+    strokeMiterlimit: 1
+};
+var Geo = class extends Mark {
+    constructor(data, options = {}) {
+        const [vr, cr] = maybeNumberChannel(options.r, 3);
+        super(
+            data, {
+                geometry: {
+                    value: options.geometry
+                },
+                r: {
+                    value: vr,
+                    scale: "r",
+                    filter: positive,
+                    optional: true
+                }
+            },
+            withDefaultSort(options),
+            defaults17
+        );
+        this.r = cr;
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            geometry: G,
+            r: R
+        } = channels;
+        const path3 = path_default(context.projection ?? scaleProjection2(scales));
+        const {
+            r
+        } = this;
+        if (negative(r))
+            index5 = [];
+        else if (r !== void 0)
+            path3.pointRadius(r);
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
+            g.selectAll().data(index5).enter().append("path").call(applyDirectStyles, this).attr("d", R ? (i) => path3.pointRadius(R[i])(G[i]) : (i) => path3(G[i])).call(applyChannelStyles, this, channels);
+        }).node();
+    }
+};
+
+function scaleProjection2({
+    x: X4,
+    y: Y4
+}) {
+    if (X4 || Y4) {
+        X4 ??= (x7) => x7;
+        Y4 ??= (y7) => y7;
+        return transform_default({
+            point(x7, y7) {
+                this.stream.point(X4(x7), Y4(y7));
+            }
+        });
+    }
+}
+
+function geo(data, {
+    geometry = identity6,
+    ...options
+} = {}) {
+    switch (data?.type) {
+        case "FeatureCollection":
+            data = data.features;
+            break;
+        case "GeometryCollection":
+            data = data.geometries;
+            break;
+        case "Feature":
+        case "LineString":
+        case "MultiLineString":
+        case "MultiPoint":
+        case "MultiPolygon":
+        case "Point":
+        case "Polygon":
+        case "Sphere":
+            data = [data];
+            break;
+    }
+    return new Geo(data, {
+        geometry,
+        ...options
+    });
+}
+
+function sphere({
+    strokeWidth = 1.5,
+    ...options
+} = {}) {
+    return geo({
+        type: "Sphere"
+    }, {
+        strokeWidth,
+        ...options
+    });
+}
+
+function graticule2({
+    strokeOpacity = 0.1,
+    ...options
+} = {}) {
+    return geo(graticule10(), {
+        strokeOpacity,
+        ...options
+    });
+}
+
+// node_modules/@observablehq/plot/src/transforms/hexbin.js
+var ox = 0.5;
+var oy = 0;
+
+function hexbin(outputs = {
+    fill: "count"
+}, {
+    binWidth,
+    ...options
+} = {}) {
+    binWidth = binWidth === void 0 ? 20 : number5(binWidth);
+    outputs = maybeOutputs(outputs, options);
+    const {
+        z,
+        fill,
+        stroke
+    } = options;
+    if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, "fill"))
+        options.stroke = "none";
+    if (options.symbol === void 0)
+        options.symbol = "hexagon";
+    if (options.r === void 0 && !hasOutput(outputs, "r"))
+        options.r = binWidth / 2;
+    return initializer(options, (data, facets, channels, scales, _, context) => {
+        let {
+            x: X4,
+            y: Y4,
+            z: Z,
+            fill: F,
+            stroke: S,
+            symbol: Q
+        } = channels;
+        if (X4 === void 0)
+            throw new Error("missing channel: x");
+        if (Y4 === void 0)
+            throw new Error("missing channel: y");
+        ({
+            x: X4,
+            y: Y4
+        } = applyPosition(channels, scales, context));
+        Z = Z ? Z.value : valueof(data, z);
+        F = F?.value;
+        S = S?.value;
+        Q = Q?.value;
+        const G = maybeSubgroup(outputs, {
+            z: Z,
+            fill: F,
+            stroke: S,
+            symbol: Q
+        });
+        const GZ = Z && [];
+        const GF = F && [];
+        const GS = S && [];
+        const GQ = Q && [];
+        const binFacets = [];
+        const BX = [];
+        const BY = [];
+        let i = -1;
+        for (const o of outputs)
+            o.initialize(data);
+        for (const facet of facets) {
+            const binFacet = [];
+            for (const o of outputs)
+                o.scope("facet", facet);
+            for (const [f, I] of maybeGroup(facet, G)) {
+                for (const bin5 of hbin(I, X4, Y4, binWidth)) {
+                    binFacet.push(++i);
+                    BX.push(bin5.x);
+                    BY.push(bin5.y);
+                    if (Z)
+                        GZ.push(G === Z ? f : Z[bin5[0]]);
+                    if (F)
+                        GF.push(G === F ? f : F[bin5[0]]);
+                    if (S)
+                        GS.push(G === S ? f : S[bin5[0]]);
+                    if (Q)
+                        GQ.push(G === Q ? f : Q[bin5[0]]);
+                    for (const o of outputs)
+                        o.reduce(bin5);
+                }
+            }
+            binFacets.push(binFacet);
+        }
+        const binChannels = {
+            x: {
+                value: BX
+            },
+            y: {
+                value: BY
+            },
+            ...Z && {
+                z: {
+                    value: GZ
+                }
+            },
+            ...F && {
+                fill: {
+                    value: GF,
+                    scale: "auto"
+                }
+            },
+            ...S && {
+                stroke: {
+                    value: GS,
+                    scale: "auto"
+                }
+            },
+            ...Q && {
+                symbol: {
+                    value: GQ,
+                    scale: "auto"
+                }
+            },
+            ...Object.fromEntries(
+                outputs.map(({
+                    name,
+                    output
+                }) => [
+                    name, {
+                        scale: "auto",
+                        radius: name === "r" ? binWidth / 2 : void 0,
+                        value: output.transform()
+                    }
+                ])
+            )
+        };
+        return {
+            data,
+            facets: binFacets,
+            channels: binChannels
+        };
+    });
+}
+
+function hbin(I, X4, Y4, dx) {
+    const dy = dx * (1.5 / sqrt35);
+    const bins = /* @__PURE__ */ new Map();
+    for (const i of I) {
+        let px = X4[i],
+            py = Y4[i];
+        if (isNaN(px) || isNaN(py))
+            continue;
+        let pj = Math.round(py = (py - oy) / dy),
+            pi13 = Math.round(px = (px - ox) / dx - (pj & 1) / 2),
+            py1 = py - pj;
+        if (Math.abs(py1) * 3 > 1) {
+            let px1 = px - pi13,
+                pi22 = pi13 + (px < pi13 ? -1 : 1) / 2,
+                pj2 = pj + (py < pj ? -1 : 1),
+                px2 = px - pi22,
+                py2 = py - pj2;
+            if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
+                pi13 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
+        }
+        const key = `${pi13},${pj}`;
+        let bin5 = bins.get(key);
+        if (bin5 === void 0) {
+            bins.set(key, bin5 = []);
+            bin5.x = (pi13 + (pj & 1) / 2) * dx + ox;
+            bin5.y = pj * dy + oy;
+        }
+        bin5.push(i);
+    }
+    return bins.values();
+}
+
+// node_modules/@observablehq/plot/src/marks/hexgrid.js
+var defaults18 = {
+    ariaLabel: "hexgrid",
+    fill: "none",
+    stroke: "currentColor",
+    strokeOpacity: 0.1
+};
+
+function hexgrid(options) {
+    return new Hexgrid(options);
+}
+var Hexgrid = class extends Mark {
+    constructor({
+        binWidth = 20,
+        clip = true,
+        ...options
+    } = {}) {
+        super(void 0, void 0, {
+            clip,
+            ...options
+        }, defaults18);
+        this.binWidth = number5(binWidth);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            binWidth
+        } = this;
+        const {
+            marginTop,
+            marginRight,
+            marginBottom,
+            marginLeft,
+            width,
+            height
+        } = dimensions;
+        const x011 = marginLeft - ox,
+            x13 = width - marginRight - ox,
+            y011 = marginTop - oy,
+            y13 = height - marginBottom - oy,
+            rx = binWidth / 2,
+            ry = rx * sqrt4_3,
+            hy = ry / 2,
+            wx = rx * 2,
+            wy = ry * 1.5,
+            i0 = Math.floor(x011 / wx),
+            i1 = Math.ceil(x13 / wx),
+            j0 = Math.floor((y011 + hy) / wy),
+            j1 = Math.ceil((y13 - hy) / wy) + 1,
+            path3 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;
+        let d = path3;
+        for (let j = j0; j < j1; ++j) {
+            for (let i = i0; i < i1; ++i) {
+                d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path3}`;
+            }
+        }
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append("path").call(applyDirectStyles, this).attr("d", d)).node();
+    }
+};
+
+function round(x7) {
+    return Math.round(x7 * 1e3) / 1e3;
+}
+
+// node_modules/@observablehq/plot/src/marks/image.js
+var defaults19 = {
+    ariaLabel: "image",
+    fill: null,
+    stroke: null
+};
+
+function isPath(string3) {
+    return /^\.*\//.test(string3);
+}
+
+function isUrl(string3) {
+    return /^(blob|data|file|http|https):/i.test(string3);
+}
+
+function maybePathChannel(value) {
+    return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
+}
+var Image2 = class extends Mark {
+    constructor(data, options = {}) {
+        let {
+            x: x7,
+            y: y7,
+            width,
+            height,
+            src,
+            preserveAspectRatio,
+            crossOrigin,
+            frameAnchor,
+            imageRendering
+        } = options;
+        if (width === void 0 && height !== void 0)
+            width = height;
+        else if (height === void 0 && width !== void 0)
+            height = width;
+        const [vs, cs] = maybePathChannel(src);
+        const [vw, cw] = maybeNumberChannel(width, 16);
+        const [vh, ch] = maybeNumberChannel(height, 16);
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x",
+                    optional: true
+                },
+                y: {
+                    value: y7,
+                    scale: "y",
+                    optional: true
+                },
+                width: {
+                    value: vw,
+                    filter: positive,
+                    optional: true
+                },
+                height: {
+                    value: vh,
+                    filter: positive,
+                    optional: true
+                },
+                src: {
+                    value: vs,
+                    optional: true
+                }
+            },
+            options,
+            defaults19
+        );
+        this.src = cs;
+        this.width = cw;
+        this.height = ch;
+        this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
+        this.crossOrigin = string(crossOrigin);
+        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        this.imageRendering = impliedString(imageRendering, "auto");
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: x7,
+            y: y7
+        } = scales;
+        const {
+            x: X4,
+            y: Y4,
+            width: W,
+            height: H,
+            src: S
+        } = channels;
+        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
+            x: X4 && x7,
+            y: Y4 && y7
+        }).call(
+            (g) => g.selectAll().data(index5).enter().append("image").call(applyDirectStyles, this).attr(
+                "x",
+                W && X4 ? (i) => X4[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X4 ? (i) => X4[i] - this.width / 2 : cx - this.width / 2
+            ).attr(
+                "y",
+                H && Y4 ? (i) => Y4[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y4 ? (i) => Y4[i] - this.height / 2 : cy - this.height / 2
+            ).attr("width", W ? (i) => W[i] : this.width).attr("height", H ? (i) => H[i] : this.height).call(applyAttr, "href", S ? (i) => S[i] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyAttr, "image-rendering", this.imageRendering).call(applyChannelStyles, this, channels)
+        ).node();
+    }
+};
+
+function image(data, options = {}) {
+    let {
+        x: x7,
+        y: y7,
+        ...remainingOptions
+    } = options;
+    if (options.frameAnchor === void 0)
+        [x7, y7] = maybeTuple(x7, y7);
+    return new Image2(data, {
+        ...remainingOptions,
+        x: x7,
+        y: y7
+    });
+}
+
+// node_modules/@observablehq/plot/src/stats.js
+function ibetainv(p, a7, b) {
+    var EPS = 1e-8;
+    var a1 = a7 - 1;
+    var b13 = b - 1;
+    var j = 0;
+    var lna, lnb, pp, t, u7, err, x7, al, h, w, afac;
+    if (p <= 0)
+        return 0;
+    if (p >= 1)
+        return 1;
+    if (a7 >= 1 && b >= 1) {
+        pp = p < 0.5 ? p : 1 - p;
+        t = Math.sqrt(-2 * Math.log(pp));
+        x7 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
+        if (p < 0.5)
+            x7 = -x7;
+        al = (x7 * x7 - 3) / 6;
+        h = 2 / (1 / (2 * a7 - 1) + 1 / (2 * b - 1));
+        w = x7 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a7 - 1)) * (al + 5 / 6 - 2 / (3 * h));
+        x7 = a7 / (a7 + b * Math.exp(2 * w));
+    } else {
+        lna = Math.log(a7 / (a7 + b));
+        lnb = Math.log(b / (a7 + b));
+        t = Math.exp(a7 * lna) / a7;
+        u7 = Math.exp(b * lnb) / b;
+        w = t + u7;
+        if (p < t / w)
+            x7 = Math.pow(a7 * w * p, 1 / a7);
+        else
+            x7 = 1 - Math.pow(b * w * (1 - p), 1 / b);
+    }
+    afac = -gammaln(a7) - gammaln(b) + gammaln(a7 + b);
+    for (; j < 10; j++) {
+        if (x7 === 0 || x7 === 1)
+            return x7;
+        err = ibeta(x7, a7, b) - p;
+        t = Math.exp(a1 * Math.log(x7) + b13 * Math.log(1 - x7) + afac);
+        u7 = err / t;
+        x7 -= t = u7 / (1 - 0.5 * Math.min(1, u7 * (a1 / x7 - b13 / (1 - x7))));
+        if (x7 <= 0)
+            x7 = 0.5 * (x7 + t);
+        if (x7 >= 1)
+            x7 = 0.5 * (x7 + t + 1);
+        if (Math.abs(t) < EPS * x7 && j > 0)
+            break;
+    }
+    return x7;
+}
+
+function ibeta(x7, a7, b) {
+    var bt = x7 === 0 || x7 === 1 ? 0 : Math.exp(gammaln(a7 + b) - gammaln(a7) - gammaln(b) + a7 * Math.log(x7) + b * Math.log(1 - x7));
+    if (x7 < 0 || x7 > 1)
+        return false;
+    if (x7 < (a7 + 1) / (a7 + b + 2))
+        return bt * betacf(x7, a7, b) / a7;
+    return 1 - bt * betacf(1 - x7, b, a7) / b;
+}
+
+function betacf(x7, a7, b) {
+    var fpmin = 1e-30;
+    var m5 = 1;
+    var qab = a7 + b;
+    var qap = a7 + 1;
+    var qam = a7 - 1;
+    var c11 = 1;
+    var d = 1 - qab * x7 / qap;
+    var m22, aa3, del, h;
+    if (Math.abs(d) < fpmin)
+        d = fpmin;
+    d = 1 / d;
+    h = d;
+    for (; m5 <= 100; m5++) {
+        m22 = 2 * m5;
+        aa3 = m5 * (b - m5) * x7 / ((qam + m22) * (a7 + m22));
+        d = 1 + aa3 * d;
+        if (Math.abs(d) < fpmin)
+            d = fpmin;
+        c11 = 1 + aa3 / c11;
+        if (Math.abs(c11) < fpmin)
+            c11 = fpmin;
+        d = 1 / d;
+        h *= d * c11;
+        aa3 = -(a7 + m5) * (qab + m5) * x7 / ((a7 + m22) * (qap + m22));
+        d = 1 + aa3 * d;
+        if (Math.abs(d) < fpmin)
+            d = fpmin;
+        c11 = 1 + aa3 / c11;
+        if (Math.abs(c11) < fpmin)
+            c11 = fpmin;
+        d = 1 / d;
+        del = d * c11;
+        h *= del;
+        if (Math.abs(del - 1) < 3e-7)
+            break;
+    }
+    return h;
+}
+
+function gammaln(x7) {
+    var j = 0;
+    var cof = [
+        76.18009172947146,
+        -86.5053203294167,
+        24.01409824083091,
+        -1.231739572450155,
+        0.001208650973866179,
+        -5395239384953e-18
+    ];
+    var ser = 1.000000000190015;
+    var xx, y7, tmp2;
+    tmp2 = (y7 = xx = x7) + 5.5;
+    tmp2 -= (xx + 0.5) * Math.log(tmp2);
+    for (; j < 6; j++)
+        ser += cof[j] / ++y7;
+    return Math.log(2.506628274631 * ser / xx) - tmp2;
+}
+
+function qt(p, dof) {
+    var x7 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
+    x7 = Math.sqrt(dof * (1 - x7) / x7);
+    return p > 0.5 ? x7 : -x7;
+}
+
+// node_modules/@observablehq/plot/src/marks/linearRegression.js
+var defaults20 = {
+    ariaLabel: "linear-regression",
+    fill: "currentColor",
+    fillOpacity: 0.1,
+    stroke: "currentColor",
+    strokeWidth: 1.5,
+    strokeLinecap: "round",
+    strokeLinejoin: "round",
+    strokeMiterlimit: 1
+};
+var LinearRegression = class extends Mark {
+    constructor(data, options = {}) {
+        const {
+            x: x7,
+            y: y7,
+            z,
+            ci = 0.95,
+            precision = 4
+        } = options;
+        super(
+            data, {
+                x: {
+                    value: x7,
+                    scale: "x"
+                },
+                y: {
+                    value: y7,
+                    scale: "y"
+                },
+                z: {
+                    value: maybeZ(options),
+                    optional: true
+                }
+            },
+            options,
+            defaults20
+        );
+        this.z = z;
+        this.ci = +ci;
+        this.precision = +precision;
+        if (!(0 <= this.ci && this.ci < 1))
+            throw new Error(`invalid ci; not in [0, 1): ${ci}`);
+        if (!(this.precision > 0))
+            throw new Error(`invalid precision: ${precision}`);
+    }
+    render(index5, scales, channels, dimensions, context) {
+        const {
+            x: X4,
+            y: Y4,
+            z: Z
+        } = channels;
+        const {
+            ci
+        } = this;
+        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
+            (g) => g.selectAll().data(Z ? groupZ2(index5, Z, this.z) : [index5]).enter().call(
+                (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
+                    ...channels,
+                    fill: null,
+                    fillOpacity: null
+                }).attr("d", (I) => this._renderLine(I, X4, Y4)).call(
+                    ci && !isNone(this.fill) ? (path3) => path3.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
+                        ...channels,
+                        stroke: null,
+                        strokeOpacity: null,
+                        strokeWidth: null
+                    }).attr("d", (I) => this._renderBand(I, X4, Y4)) : () => {}
+                )
+            )
+        ).node();
+    }
+};
+
+function pathBefore() {
+    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
+}
+var LinearRegressionX = class extends LinearRegression {
+    constructor(data, options) {
+        super(data, options);
+    }
+    _renderBand(I, X4, Y4) {
+        const {
+            ci,
+            precision
+        } = this;
+        const [y13, y22] = extent(I, (i) => Y4[i]);
+        const f = linearRegressionF(I, Y4, X4);
+        const g = confidenceIntervalF(I, Y4, X4, (1 - ci) / 2, f);
+        return area_default5().y((y7) => y7).x0((y7) => g(y7, -1)).x1((y7) => g(y7, 1))(range(y13, y22 - precision / 2, precision).concat(y22));
+    }
+    _renderLine(I, X4, Y4) {
+        const [y13, y22] = extent(I, (i) => Y4[i]);
+        const f = linearRegressionF(I, Y4, X4);
+        return `M${f(y13)},${y13}L${f(y22)},${y22}`;
+    }
+};
+var LinearRegressionY = class extends LinearRegression {
+    constructor(data, options) {
+        super(data, options);
+    }
+    _renderBand(I, X4, Y4) {
+        const {
+            ci,
+            precision
+        } = this;
+        const [x13, x22] = extent(I, (i) => X4[i]);
+        const f = linearRegressionF(I, X4, Y4);
+        const g = confidenceIntervalF(I, X4, Y4, (1 - ci) / 2, f);
+        return area_default5().x((x7) => x7).y0((x7) => g(x7, -1)).y1((x7) => g(x7, 1))(range(x13, x22 - precision / 2, precision).concat(x22));
+    }
+    _renderLine(I, X4, Y4) {
+        const [x13, x22] = extent(I, (i) => X4[i]);
+        const f = linearRegressionF(I, X4, Y4);
+        return `M${x13},${f(x13)}L${x22},${f(x22)}`;
+    }
+};
+
+function linearRegressionX(data, options = {}) {
+    const {
+        y: y7 = indexOf,
+        x: x7 = identity6,
+        stroke,
+        fill = isNoneish(stroke) ? "currentColor" : stroke,
+        ...remainingOptions
+    } = options;
+    return new LinearRegressionX(data, maybeDenseIntervalY({
+        ...remainingOptions,
+        x: x7,
+        y: y7,
+        fill,
+        stroke
+    }));
+}
+
+function linearRegressionY(data, options = {}) {
+    const {
+        x: x7 = indexOf,
+        y: y7 = identity6,
+        stroke,
+        fill = isNoneish(stroke) ? "currentColor" : stroke,
+        ...remainingOptions
+    } = options;
+    return new LinearRegressionY(data, maybeDenseIntervalX({
+        ...remainingOptions,
+        x: x7,
+        y: y7,
+        fill,
+        stroke
+    }));
+}
+
+function linearRegressionF(I, X4, Y4) {
+    let sumX = 0,
+        sumY = 0,
+        sumXY = 0,
+        sumX2 = 0;
+    for (const i of I) {
+        const xi = X4[i];
+        const yi = Y4[i];
+        sumX += xi;
+        sumY += yi;
+        sumXY += xi * yi;
+        sumX2 += xi * xi;
+    }
+    const n = I.length;
+    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
+    const intercept = (sumY - slope * sumX) / n;
+    return (x7) => slope * x7 + intercept;
+}
+
+function confidenceIntervalF(I, X4, Y4, p, f) {
+    const mean3 = sum(I, (i) => X4[i]) / I.length;
+    let a7 = 0,
+        b = 0;
+    for (const i of I) {
+        a7 += (X4[i] - mean3) ** 2;
+        b += (Y4[i] - f(X4[i])) ** 2;
+    }
+    const sy = Math.sqrt(b / (I.length - 2));
+    const t = qt(p, I.length - 2);
+    return (x7, k3) => {
+        const Y5 = f(x7);
+        const se = sy * Math.sqrt(1 / I.length + (x7 - mean3) ** 2 / a7);
+        return Y5 + k3 * t * se;
+    };
+}
+
+// node_modules/@observablehq/plot/src/transforms/tree.js
+function treeNode(options = {}) {
+    let {
+        path: path3 = identity6,
+        // the delimited path
+        delimiter,
+        // how the path is separated
+        frameAnchor,
+        treeLayout = tree_default,
+        treeSort,
+        treeSeparation,
+        treeAnchor,
+        ...remainingOptions
+    } = options;
+    treeAnchor = maybeTreeAnchor(treeAnchor);
+    treeSort = maybeTreeSort(treeSort);
+    if (frameAnchor === void 0)
+        frameAnchor = treeAnchor.frameAnchor;
+    const normalize7 = normalizer(delimiter);
+    const outputs = treeOutputs(remainingOptions, maybeNodeValue);
+    const [X4, setX] = column();
+    const [Y4, setY] = column();
+    return {
+        x: X4,
+        y: Y4,
+        frameAnchor,
+        ...basic(remainingOptions, (data, facets) => {
+            const P = normalize7(valueof(data, path3));
+            const X5 = setX([]);
+            const Y5 = setY([]);
+            let treeIndex = -1;
+            const treeData = [];
+            const treeFacets = [];
+            const rootof = stratify_default().path((i) => P[i]);
+            const layout = treeLayout();
+            if (layout.nodeSize)
+                layout.nodeSize([1, 1]);
+            if (layout.separation && treeSeparation !== void 0)
+                layout.separation(treeSeparation ?? one2);
+            for (const o of outputs)
+                o[output_values] = o[output_setValues]([]);
+            for (const facet of facets) {
+                const treeFacet = [];
+                const root5 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
+                if (treeSort != null)
+                    root5.sort(treeSort);
+                layout(root5);
+                for (const node of root5.descendants()) {
+                    treeFacet.push(++treeIndex);
+                    treeData[treeIndex] = node.data;
+                    treeAnchor.position(node, treeIndex, X5, Y5);
+                    for (const o of outputs)
+                        o[output_values][treeIndex] = o[output_evaluate](node);
+                }
+                treeFacets.push(treeFacet);
+            }
+            return {
+                data: treeData,
+                facets: treeFacets
+            };
+        }),
+        ...Object.fromEntries(outputs)
+    };
+}
+
+function treeLink(options = {}) {
+    let {
+        path: path3 = identity6,
+        // the delimited path
+        delimiter,
+        // how the path is separated
+        curve = "bump-x",
+        stroke = "#555",
+        strokeWidth = 1.5,
+        strokeOpacity = 0.5,
+        treeLayout = tree_default,
+        treeSort,
+        treeSeparation,
+        treeAnchor,
+        ...remainingOptions
+    } = options;
+    treeAnchor = maybeTreeAnchor(treeAnchor);
+    treeSort = maybeTreeSort(treeSort);
+    remainingOptions = {
+        curve,
+        stroke,
+        strokeWidth,
+        strokeOpacity,
+        ...remainingOptions
+    };
+    const normalize7 = normalizer(delimiter);
+    const outputs = treeOutputs(remainingOptions, maybeLinkValue);
+    const [X15, setX1] = column();
+    const [X25, setX2] = column();
+    const [Y15, setY1] = column();
+    const [Y25, setY2] = column();
+    return {
+        x1: X15,
+        x2: X25,
+        y1: Y15,
+        y2: Y25,
+        ...basic(remainingOptions, (data, facets) => {
+            const P = normalize7(valueof(data, path3));
+            const X16 = setX1([]);
+            const X26 = setX2([]);
+            const Y16 = setY1([]);
+            const Y26 = setY2([]);
+            let treeIndex = -1;
+            const treeData = [];
+            const treeFacets = [];
+            const rootof = stratify_default().path((i) => P[i]);
+            const layout = treeLayout();
+            if (layout.nodeSize)
+                layout.nodeSize([1, 1]);
+            if (layout.separation && treeSeparation !== void 0)
+                layout.separation(treeSeparation ?? one2);
+            for (const o of outputs)
+                o[output_values] = o[output_setValues]([]);
+            for (const facet of facets) {
+                const treeFacet = [];
+                const root5 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
+                if (treeSort != null)
+                    root5.sort(treeSort);
+                layout(root5);
+                for (const {
+                        source,
+                        target
+                    }
+                    of root5.links()) {
+                    treeFacet.push(++treeIndex);
+                    treeData[treeIndex] = target.data;
+                    treeAnchor.position(source, treeIndex, X16, Y16);
+                    treeAnchor.position(target, treeIndex, X26, Y26);
+                    for (const o of outputs)
+                        o[output_values][treeIndex] = o[output_evaluate](target, source);
+                }
+                treeFacets.push(treeFacet);
+            }
+            return {
+                data: treeData,
+                facets: treeFacets
+            };
+        }),
+        ...Object.fromEntries(outputs)
+    };
+}
+
+function maybeTreeAnchor(anchor = "left") {
+    switch (`${anchor}`.trim().toLowerCase()) {
+        case "left":
+            return treeAnchorLeft;
+        case "right":
+            return treeAnchorRight;
+    }
+    throw new Error(`invalid tree anchor: ${anchor}`);
+}
+var treeAnchorLeft = {
+    frameAnchor: "left",
+    dx: 6,
+    position({
+        x: x7,
+        y: y7
+    }, i, X4, Y4) {
+        X4[i] = y7;
+        Y4[i] = -x7;
+    }
+};
+var treeAnchorRight = {
+    frameAnchor: "right",
+    dx: -6,
+    position({
+        x: x7,
+        y: y7
+    }, i, X4, Y4) {
+        X4[i] = -y7;
+        Y4[i] = -x7;
+    }
+};
+
+function maybeTreeSort(sort5) {
+    return sort5 == null || typeof sort5 === "function" ? sort5 : `${sort5}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort5)) : nodeSort(nodeData(sort5));
+}
+
+function nodeSort(value) {
+    return (a7, b) => ascendingDefined2(value(a7), value(b));
+}
+
+function nodeData(field3) {
+    return (node) => node.data?.[field3];
+}
+
+function normalizer(delimiter = "/") {
+    return `${delimiter}` === "/" ? (P) => P : (P) => P.map(replaceAll(delimiter, "/"));
+}
+
+function replaceAll(search, replace) {
+    search = new RegExp(regexEscape(search), "g");
+    return (value) => value == null ? null : `${value}`.replace(search, replace);
+}
+
+function regexEscape(string3) {
+    return `${string3}`.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
+}
+
+function isNodeValue(option) {
+    return isObject(option) && typeof option.node === "function";
+}
+
+function isLinkValue(option) {
+    return isObject(option) && typeof option.link === "function";
+}
+
+function maybeNodeValue(value) {
+    if (isNodeValue(value))
+        return value.node;
+    value = `${value}`.trim().toLowerCase();
+    if (!value.startsWith("node:"))
+        return;
+    switch (value) {
+        case "node:name":
+            return nodeName;
+        case "node:path":
+            return nodePath;
+        case "node:internal":
+            return nodeInternal;
+        case "node:depth":
+            return nodeDepth;
+        case "node:height":
+            return nodeHeight;
+    }
+    throw new Error(`invalid node value: ${value}`);
+}
+
+function maybeLinkValue(value) {
+    if (isNodeValue(value))
+        return value.node;
+    if (isLinkValue(value))
+        return value.link;
+    value = `${value}`.trim().toLowerCase();
+    if (!value.startsWith("node:") && !value.startsWith("parent:"))
+        return;
+    switch (value) {
+        case "parent:name":
+            return parentValue(nodeName);
+        case "parent:path":
+            return parentValue(nodePath);
+        case "parent:depth":
+            return parentValue(nodeDepth);
+        case "parent:height":
+            return parentValue(nodeHeight);
+        case "node:name":
+            return nodeName;
+        case "node:path":
+            return nodePath;
+        case "node:internal":
+            return nodeInternal;
+        case "node:depth":
+            return nodeDepth;
+        case "node:height":
+            return nodeHeight;
+    }
+    throw new Error(`invalid link value: ${value}`);
+}
+
+function nodePath(node) {
+    return node.id;
+}
+
+function nodeName(node) {
+    return nameof(node.id);
+}
+
+function nodeDepth(node) {
+    return node.depth;
+}
+
+function nodeHeight(node) {
+    return node.height;
+}
+
+function nodeInternal(node) {
+    return !!node.children;
+}
+
+function parentValue(evaluate) {
+    return (child, parent) => parent == null ? void 0 : evaluate(parent);
+}
+
+function nameof(path3) {
+    let i = path3.length;
+    while (--i > 0)
+        if (slash2(path3, i))
+            break;
+    return path3.slice(i + 1);
+}
+
+function slash2(path3, i) {
+    if (path3[i] === "/") {
+        let k3 = 0;
+        while (i > 0 && path3[--i] === "\\")
+            ++k3;
+        if ((k3 & 1) === 0)
+            return true;
+    }
+    return false;
+}
+var output_setValues = 2;
+var output_evaluate = 3;
+var output_values = 4;
+
+function treeOutputs(options, maybeTreeValue) {
+    const outputs = [];
+    for (const name in options) {
+        const value = options[name];
+        const treeValue = maybeTreeValue(value);
+        if (treeValue !== void 0) {
+            outputs.push([name, ...column(value), treeValue]);
+        }
+    }
+    return outputs;
+}
+
+// node_modules/@observablehq/plot/src/marks/tree.js
+function tree(data, options = {}) {
+    let {
+        fill,
+        stroke,
+        strokeWidth,
+        strokeOpacity,
+        strokeLinejoin,
+        strokeLinecap,
+        strokeMiterlimit,
+        strokeDasharray,
+        strokeDashoffset,
+        marker,
+        markerStart = marker,
+        markerEnd = marker,
+        dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd),
+        text: textText = "node:name",
+        textStroke = "white",
+        title = "node:path",
+        dx,
+        dy,
+        ...remainingOptions
+    } = options;
+    if (dx === void 0)
+        dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;
+    return marks(
+        link3(
+            data,
+            treeLink({
+                markerStart,
+                markerEnd,
+                stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
+                strokeWidth,
+                strokeOpacity,
+                strokeLinejoin,
+                strokeLinecap,
+                strokeMiterlimit,
+                strokeDasharray,
+                strokeDashoffset,
+                ...remainingOptions
+            })
+        ),
+        dotDot ? dot(data, treeNode({
+            fill: fill === void 0 ? "node:internal" : fill,
+            title,
+            ...remainingOptions
+        })) : null,
+        textText != null ? text(
+            data,
+            treeNode({
+                text: textText,
+                fill: fill === void 0 ? "currentColor" : fill,
+                stroke: textStroke,
+                dx,
+                dy,
+                title,
+                ...remainingOptions
+            })
+        ) : null
+    );
+}
+
+function cluster(data, options) {
+    return tree(data, {
+        ...options,
+        treeLayout: cluster_default
+    });
+}
+
+// node_modules/@observablehq/plot/src/transforms/centroid.js
+function centroid({
+    geometry = identity6,
+    ...options
+} = {}) {
+    return initializer({
+        ...options,
+        x: null,
+        y: null
+    }, (data, facets, channels, scales, dimensions, {
+        projection: projection3
+    }) => {
+        const G = valueof(data, geometry);
+        const n = G.length;
+        const X4 = new Float64Array(n);
+        const Y4 = new Float64Array(n);
+        const path3 = path_default(projection3);
+        for (let i = 0; i < n; ++i)
+            [X4[i], Y4[i]] = path3.centroid(G[i]);
+        return {
+            data,
+            facets,
+            channels: {
+                x: {
+                    value: X4
+                },
+                y: {
+                    value: Y4
+                }
+            }
+        };
+    });
+}
+
+function geoCentroid({
+    geometry = identity6,
+    ...options
+} = {}) {
+    let C4;
+    return {
+        ...options,
+        x: {
+            transform: (data) => Float64Array.from(C4 = valueof(valueof(data, geometry), centroid_default), ([x7]) => x7)
+        },
+        y: {
+            transform: () => Float64Array.from(C4, ([, y7]) => y7)
+        }
+    };
+}
+
+// node_modules/@observablehq/plot/src/transforms/dodge.js
+var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
+var anchorXLeft = ({
+    marginLeft
+}) => [1, marginLeft];
+var anchorXRight = ({
+    width,
+    marginRight
+}) => [-1, width - marginRight];
+var anchorXMiddle = ({
+    width,
+    marginLeft,
+    marginRight
+}) => [0, (marginLeft + width - marginRight) / 2];
+var anchorYTop = ({
+    marginTop
+}) => [1, marginTop];
+var anchorYBottom = ({
+    height,
+    marginBottom
+}) => [-1, height - marginBottom];
+var anchorYMiddle = ({
+    height,
+    marginTop,
+    marginBottom
+}) => [0, (marginTop + height - marginBottom) / 2];
+
+function maybeAnchor2(anchor) {
+    return typeof anchor === "string" ? {
+        anchor
+    } : anchor;
+}
+
+function dodgeX(dodgeOptions = {}, options = {}) {
+    if (arguments.length === 1)
+        [dodgeOptions, options] = mergeOptions3(dodgeOptions);
+    let {
+        anchor = "left", padding = 1
+    } = maybeAnchor2(dodgeOptions);
+    switch (`${anchor}`.toLowerCase()) {
+        case "left":
+            anchor = anchorXLeft;
+            break;
+        case "right":
+            anchor = anchorXRight;
+            break;
+        case "middle":
+            anchor = anchorXMiddle;
+            break;
+        default:
+            throw new Error(`unknown dodge anchor: ${anchor}`);
+    }
+    return dodge("x", "y", anchor, number5(padding), options);
+}
+
+function dodgeY(dodgeOptions = {}, options = {}) {
+    if (arguments.length === 1)
+        [dodgeOptions, options] = mergeOptions3(dodgeOptions);
+    let {
+        anchor = "bottom", padding = 1
+    } = maybeAnchor2(dodgeOptions);
+    switch (`${anchor}`.toLowerCase()) {
+        case "top":
+            anchor = anchorYTop;
+            break;
+        case "bottom":
+            anchor = anchorYBottom;
+            break;
+        case "middle":
+            anchor = anchorYMiddle;
+            break;
+        default:
+            throw new Error(`unknown dodge anchor: ${anchor}`);
+    }
+    return dodge("y", "x", anchor, number5(padding), options);
+}
+
+function mergeOptions3(options) {
+    const {
+        anchor,
+        padding,
+        ...rest
+    } = options;
+    return [{
+        anchor,
+        padding
+    }, rest];
+}
+
+function dodge(y7, x7, anchor, padding, options) {
+    const {
+        r
+    } = options;
+    if (r != null && typeof r !== "number") {
+        const {
+            channels,
+            sort: sort5,
+            reverse: reverse5
+        } = options;
+        options = {
+            ...options,
+            channels: {
+                r: {
+                    value: r,
+                    scale: "r"
+                },
+                ...maybeNamed(channels)
+            }
+        };
+        if (sort5 === void 0 && reverse5 === void 0)
+            options.sort = {
+                channel: "r",
+                order: "descending"
+            };
+    }
+    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
+        let {
+            [x7]: X4, r: R
+        } = channels;
+        if (!channels[x7])
+            throw new Error(`missing channel: ${x7}`);
+        ({
+            [x7]: X4
+        } = applyPosition(channels, scales, context));
+        const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number5(options.r) : 3;
+        if (R)
+            R = valueof(R.value, scales[R.scale] || identity6, Float64Array);
+        let [ky3, ty] = anchor(dimensions);
+        const compare = ky3 ? compareAscending : compareSymmetric;
+        const Y4 = new Float64Array(X4.length);
+        const radius3 = R ? (i) => R[i] : () => r2;
+        for (let I of facets) {
+            const tree3 = (0, import_interval_tree_1d.default)();
+            I = I.filter(R ? (i) => finite2(X4[i]) && positive(R[i]) : (i) => finite2(X4[i]));
+            const intervals = new Float64Array(2 * I.length + 2);
+            for (const i of I) {
+                const ri = radius3(i);
+                const y011 = ky3 ? ri + padding : 0;
+                const l = X4[i] - ri;
+                const h = X4[i] + ri;
+                let k3 = 2;
+                tree3.queryInterval(l - padding, h + padding, ([, , j]) => {
+                    const yj = Y4[j] - y011;
+                    const dx = X4[i] - X4[j];
+                    const dr = padding + (R ? R[i] + R[j] : 2 * r2);
+                    const dy = Math.sqrt(dr * dr - dx * dx);
+                    intervals[k3++] = yj - dy;
+                    intervals[k3++] = yj + dy;
+                });
+                let candidates = intervals.slice(0, k3);
+                if (ky3)
+                    candidates = candidates.filter((y8) => y8 >= 0);
+                out:
+                    for (const y8 of candidates.sort(compare)) {
+                        for (let j = 0; j < k3; j += 2) {
+                            if (intervals[j] + 1e-6 < y8 && y8 < intervals[j + 1] - 1e-6) {
+                                continue out;
+                            }
+                        }
+                        Y4[i] = y8 + y011;
+                        break;
+                    }
+                tree3.insert([l, h, i]);
+            }
+        }
+        if (!ky3)
+            ky3 = 1;
+        for (const I of facets) {
+            for (const i of I) {
+                Y4[i] = Y4[i] * ky3 + ty;
+            }
+        }
+        return {
+            data,
+            facets,
+            channels: {
+                [x7]: {
+                    value: X4
+                },
+                [y7]: {
+                    value: Y4
+                },
+                ...R && {
+                    r: {
+                        value: R
+                    }
+                }
+            }
+        };
+    });
+}
+
+function compareSymmetric(a7, b) {
+    return Math.abs(a7) - Math.abs(b);
+}
+
+function compareAscending(a7, b) {
+    return a7 - b;
+}
+
+// node_modules/@observablehq/plot/src/transforms/normalize.js
+function normalizeX(basis3, options) {
+    if (arguments.length === 1)
+        ({
+            basis: basis3,
+            ...options
+        } = basis3);
+    return mapX(normalize3(basis3), options);
+}
+
+function normalizeY(basis3, options) {
+    if (arguments.length === 1)
+        ({
+            basis: basis3,
+            ...options
+        } = basis3);
+    return mapY(normalize3(basis3), options);
+}
+
+function normalize3(basis3) {
+    if (basis3 === void 0)
+        return normalizeFirst;
+    if (typeof basis3 === "function")
+        return normalizeBasis((I, S) => basis3(take(S, I)));
+    if (/^p\d{2}$/i.test(basis3))
+        return normalizeAccessor(percentile(basis3));
+    switch (`${basis3}`.toLowerCase()) {
+        case "deviation":
+            return normalizeDeviation;
+        case "first":
+            return normalizeFirst;
+        case "last":
+            return normalizeLast;
+        case "max":
+            return normalizeMax;
+        case "mean":
+            return normalizeMean;
+        case "median":
+            return normalizeMedian;
+        case "min":
+            return normalizeMin;
+        case "sum":
+            return normalizeSum;
+        case "extent":
+            return normalizeExtent;
+    }
+    throw new Error(`invalid basis: ${basis3}`);
+}
+
+function normalizeBasis(basis3) {
+    return {
+        mapIndex(I, S, T) {
+            const b = +basis3(I, S);
+            for (const i of I) {
+                T[i] = S[i] === null ? NaN : S[i] / b;
+            }
+        }
+    };
+}
+
+function normalizeAccessor(f) {
+    return normalizeBasis((I, S) => f(I, (i) => S[i]));
+}
+var normalizeExtent = {
+    mapIndex(I, S, T) {
+        const [s1, s22] = extent(I, (i) => S[i]);
+        const d = s22 - s1;
+        for (const i of I) {
+            T[i] = S[i] === null ? NaN : (S[i] - s1) / d;
+        }
+    }
+};
+var normalizeFirst = normalizeBasis((I, S) => {
+    for (let i = 0; i < I.length; ++i) {
+        const s3 = S[I[i]];
+        if (defined(s3))
+            return s3;
+    }
+});
+var normalizeLast = normalizeBasis((I, S) => {
+    for (let i = I.length - 1; i >= 0; --i) {
+        const s3 = S[I[i]];
+        if (defined(s3))
+            return s3;
+    }
+});
+var normalizeDeviation = {
+    mapIndex(I, S, T) {
+        const m5 = mean(I, (i) => S[i]);
+        const d = deviation(I, (i) => S[i]);
+        for (const i of I) {
+            T[i] = S[i] === null ? NaN : d ? (S[i] - m5) / d : 0;
+        }
+    }
+};
+var normalizeMax = normalizeAccessor(max);
+var normalizeMean = normalizeAccessor(mean);
+var normalizeMedian = normalizeAccessor(median);
+var normalizeMin = normalizeAccessor(min);
+var normalizeSum = normalizeAccessor(sum);
+
+// node_modules/@observablehq/plot/src/transforms/window.js
+function windowX(windowOptions = {}, options) {
+    if (arguments.length === 1)
+        options = windowOptions;
+    return mapX(window2(windowOptions), options);
+}
+
+function windowY(windowOptions = {}, options) {
+    if (arguments.length === 1)
+        options = windowOptions;
+    return mapY(window2(windowOptions), options);
+}
+
+function window2(options = {}) {
+    if (typeof options === "number")
+        options = {
+            k: options
+        };
+    let {
+        k: k3,
+        reduce: reduce3,
+        shift,
+        anchor,
+        strict
+    } = options;
+    if (anchor === void 0 && shift !== void 0) {
+        anchor = maybeShift(shift);
+        warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
+    }
+    if (!((k3 = Math.floor(k3)) > 0))
+        throw new Error(`invalid k: ${k3}`);
+    return maybeReduce2(reduce3)(k3, maybeAnchor3(anchor, k3), strict);
+}
+
+function maybeAnchor3(anchor = "middle", k3) {
+    switch (`${anchor}`.toLowerCase()) {
+        case "middle":
+            return k3 - 1 >> 1;
+        case "start":
+            return 0;
+        case "end":
+            return k3 - 1;
+    }
+    throw new Error(`invalid anchor: ${anchor}`);
+}
+
+function maybeShift(shift) {
+    switch (`${shift}`.toLowerCase()) {
+        case "centered":
+            return "middle";
+        case "leading":
+            return "start";
+        case "trailing":
+            return "end";
+    }
+    throw new Error(`invalid shift: ${shift}`);
+}
+
+function maybeReduce2(reduce3 = "mean") {
+    if (typeof reduce3 === "string") {
+        if (/^p\d{2}$/i.test(reduce3))
+            return reduceNumbers(percentile(reduce3));
+        switch (reduce3.toLowerCase()) {
+            case "deviation":
+                return reduceNumbers(deviation);
+            case "max":
+                return reduceArray(max);
+            case "mean":
+                return reduceMean;
+            case "median":
+                return reduceNumbers(median);
+            case "min":
+                return reduceArray(min);
+            case "mode":
+                return reduceArray(mode);
+            case "sum":
+                return reduceSum2;
+            case "variance":
+                return reduceNumbers(variance);
+            case "difference":
+                return reduceDifference;
+            case "ratio":
+                return reduceRatio;
+            case "first":
+                return reduceFirst2;
+            case "last":
+                return reduceLast2;
+        }
+    }
+    if (typeof reduce3 !== "function")
+        throw new Error(`invalid reduce: ${reduce3}`);
+    return reduceArray(reduce3);
+}
+
+function slice6(I, i, j) {
+    return I.subarray ? I.subarray(i, j) : I.slice(i, j);
+}
+
+function reduceNumbers(f) {
+    return (k3, s3, strict) => strict ? {
+        mapIndex(I, S, T) {
+            const C4 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
+            let nans = 0;
+            for (let i = 0; i < k3 - 1; ++i)
+                if (isNaN(C4[i]))
+                    ++nans;
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                if (isNaN(C4[i + k3 - 1]))
+                    ++nans;
+                T[I[i + s3]] = nans === 0 ? f(C4.subarray(i, i + k3)) : NaN;
+                if (isNaN(C4[i]))
+                    --nans;
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            const C4 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
+            for (let i = -s3; i < 0; ++i) {
+                T[I[i + s3]] = f(C4.subarray(0, i + k3));
+            }
+            for (let i = 0, n = I.length - s3; i < n; ++i) {
+                T[I[i + s3]] = f(C4.subarray(i, i + k3));
+            }
+        }
+    };
+}
+
+function reduceArray(f) {
+    return (k3, s3, strict) => strict ? {
+        mapIndex(I, S, T) {
+            let count5 = 0;
+            for (let i = 0; i < k3 - 1; ++i)
+                count5 += defined(S[I[i]]);
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                count5 += defined(S[I[i + k3 - 1]]);
+                if (count5 === k3)
+                    T[I[i + s3]] = f(take(S, slice6(I, i, i + k3)));
+                count5 -= defined(S[I[i]]);
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            for (let i = -s3; i < 0; ++i) {
+                T[I[i + s3]] = f(take(S, slice6(I, 0, i + k3)));
+            }
+            for (let i = 0, n = I.length - s3; i < n; ++i) {
+                T[I[i + s3]] = f(take(S, slice6(I, i, i + k3)));
+            }
+        }
+    };
+}
+
+function reduceSum2(k3, s3, strict) {
+    return strict ? {
+        mapIndex(I, S, T) {
+            let nans = 0;
+            let sum8 = 0;
+            for (let i = 0; i < k3 - 1; ++i) {
+                const v3 = S[I[i]];
+                if (v3 === null || isNaN(v3))
+                    ++nans;
+                else
+                    sum8 += +v3;
+            }
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
+                if (b === null || isNaN(b))
+                    ++nans;
+                else
+                    sum8 += +b;
+                T[I[i + s3]] = nans === 0 ? sum8 : NaN;
+                if (a7 === null || isNaN(a7))
+                    --nans;
+                else
+                    sum8 -= +a7;
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            let sum8 = 0;
+            const n = I.length;
+            for (let i = 0, j = Math.min(n, k3 - s3 - 1); i < j; ++i) {
+                sum8 += +S[I[i]] || 0;
+            }
+            for (let i = -s3, j = n - s3; i < j; ++i) {
+                sum8 += +S[I[i + k3 - 1]] || 0;
+                T[I[i + s3]] = sum8;
+                sum8 -= +S[I[i]] || 0;
+            }
+        }
+    };
+}
+
+function reduceMean(k3, s3, strict) {
+    if (strict) {
+        const sum8 = reduceSum2(k3, s3, strict);
+        return {
+            mapIndex(I, S, T) {
+                sum8.mapIndex(I, S, T);
+                for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                    T[I[i + s3]] /= k3;
+                }
+            }
+        };
+    } else {
+        return {
+            mapIndex(I, S, T) {
+                let sum8 = 0;
+                let count5 = 0;
+                const n = I.length;
+                for (let i = 0, j = Math.min(n, k3 - s3 - 1); i < j; ++i) {
+                    let v3 = S[I[i]];
+                    if (v3 !== null && !isNaN(v3 = +v3))
+                        sum8 += v3, ++count5;
+                }
+                for (let i = -s3, j = n - s3; i < j; ++i) {
+                    let a7 = S[I[i + k3 - 1]];
+                    let b = S[I[i]];
+                    if (a7 !== null && !isNaN(a7 = +a7))
+                        sum8 += a7, ++count5;
+                    T[I[i + s3]] = sum8 / count5;
+                    if (b !== null && !isNaN(b = +b))
+                        sum8 -= b, --count5;
+                }
+            }
+        };
+    }
+}
+
+function firstDefined(S, I, i, k3) {
+    for (let j = i + k3; i < j; ++i) {
+        const v3 = S[I[i]];
+        if (defined(v3))
+            return v3;
+    }
+}
+
+function lastDefined(S, I, i, k3) {
+    for (let j = i + k3 - 1; j >= i; --j) {
+        const v3 = S[I[j]];
+        if (defined(v3))
+            return v3;
+    }
+}
+
+function firstNumber(S, I, i, k3) {
+    for (let j = i + k3; i < j; ++i) {
+        let v3 = S[I[i]];
+        if (v3 !== null && !isNaN(v3 = +v3))
+            return v3;
+    }
+}
+
+function lastNumber(S, I, i, k3) {
+    for (let j = i + k3 - 1; j >= i; --j) {
+        let v3 = S[I[j]];
+        if (v3 !== null && !isNaN(v3 = +v3))
+            return v3;
+    }
+}
+
+function reduceDifference(k3, s3, strict) {
+    return strict ? {
+        mapIndex(I, S, T) {
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
+                T[I[i + s3]] = a7 === null || b === null ? NaN : b - a7;
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastNumber(S, I, i, k3) - firstNumber(S, I, i, k3);
+            }
+        }
+    };
+}
+
+function reduceRatio(k3, s3, strict) {
+    return strict ? {
+        mapIndex(I, S, T) {
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
+                T[I[i + s3]] = a7 === null || b === null ? NaN : b / a7;
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastNumber(S, I, i, k3) / firstNumber(S, I, i, k3);
+            }
+        }
+    };
+}
+
+function reduceFirst2(k3, s3, strict) {
+    return strict ? {
+        mapIndex(I, S, T) {
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                T[I[i + s3]] = S[I[i]];
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = firstDefined(S, I, i, k3);
+            }
+        }
+    };
+}
+
+function reduceLast2(k3, s3, strict) {
+    return strict ? {
+        mapIndex(I, S, T) {
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                T[I[i + s3]] = S[I[i + k3 - 1]];
+            }
+        }
+    } : {
+        mapIndex(I, S, T) {
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastDefined(S, I, i, k3);
+            }
+        }
+    };
+}
+
+// node_modules/@observablehq/plot/src/transforms/select.js
+function select(selector, options = {}) {
+    if (typeof selector === "string") {
+        switch (selector.toLowerCase()) {
+            case "first":
+                return selectFirst(options);
+            case "last":
+                return selectLast(options);
+        }
+    }
+    if (typeof selector === "function") {
+        return selectChannel(null, selector, options);
+    }
+    let key, value;
+    for (key in selector) {
+        if (value !== void 0)
+            throw new Error("ambiguous selector; multiple inputs");
+        value = maybeSelector(selector[key]);
+    }
+    if (value === void 0)
+        throw new Error(`invalid selector: ${selector}`);
+    return selectChannel(key, value, options);
+}
+
+function maybeSelector(selector) {
+    if (typeof selector === "function")
+        return selector;
+    switch (`${selector}`.toLowerCase()) {
+        case "min":
+            return selectorMin;
+        case "max":
+            return selectorMax;
+    }
+    throw new Error(`unknown selector: ${selector}`);
+}
+
+function selectFirst(options) {
+    return selectChannel(null, selectorFirst, options);
+}
+
+function selectLast(options) {
+    return selectChannel(null, selectorLast, options);
+}
+
+function selectMinX(options) {
+    return selectChannel("x", selectorMin, options);
+}
+
+function selectMinY(options) {
+    return selectChannel("y", selectorMin, options);
+}
+
+function selectMaxX(options) {
+    return selectChannel("x", selectorMax, options);
+}
+
+function selectMaxY(options) {
+    return selectChannel("y", selectorMax, options);
+}
+
+function* selectorFirst(I) {
+    yield I[0];
+}
+
+function* selectorLast(I) {
+    yield I[I.length - 1];
+}
+
+function* selectorMin(I, X4) {
+    yield least(I, (i) => X4[i]);
+}
+
+function* selectorMax(I, X4) {
+    yield greatest(I, (i) => X4[i]);
+}
+
+function selectChannel(v3, selector, options) {
+    if (v3 != null) {
+        if (options[v3] == null)
+            throw new Error(`missing channel: ${v3}`);
+        v3 = options[v3];
+    }
+    const z = maybeZ(options);
+    return basic(options, (data, facets) => {
+        const Z = valueof(data, z);
+        const V = valueof(data, v3);
+        const selectFacets = [];
+        for (const facet of facets) {
+            const selectFacet = [];
+            for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
+                for (const i of selector(I, V)) {
+                    selectFacet.push(i);
+                }
+            }
+            selectFacets.push(selectFacet);
+        }
+        return {
+            data,
+            facets: selectFacets
+        };
+    });
+}
+
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/index.js
+var src_exports4 = {};
+__export(src_exports4, {
+    Area: () => Area2,
+    Arrow: () => Arrow2,
+    BarX: () => BarX2,
+    BarY: () => BarY2,
+    Cell: () => Cell2,
+    Contour: () => Contour2,
+    Density: () => Density2,
+    Dot: () => Dot2,
+    Frame: () => Frame2,
+    Geo: () => Geo2,
+    Hexgrid: () => Hexgrid2,
+    Image: () => Image3,
+    Line: () => Line2,
+    Link: () => Link2,
+    Mark: () => Mark2,
+    Raster: () => Raster2,
+    Rect: () => Rect2,
+    RuleX: () => RuleX2,
+    RuleY: () => RuleY2,
+    Text: () => Text2,
+    TickX: () => TickX2,
+    TickY: () => TickY2,
+    Vector: () => Vector2,
+    area: () => area2,
+    areaX: () => areaX2,
+    areaY: () => areaY2,
+    arrow: () => arrow2,
+    auto: () => auto2,
+    autoSpec: () => autoSpec2,
+    axisFx: () => axisFx2,
+    axisFy: () => axisFy2,
+    axisX: () => axisX2,
+    axisY: () => axisY2,
+    barX: () => barX2,
+    barY: () => barY2,
+    bin: () => bin4,
+    binX: () => binX2,
+    binY: () => binY2,
+    boxX: () => boxX2,
+    boxY: () => boxY2,
+    cell: () => cell2,
+    cellX: () => cellX2,
+    cellY: () => cellY2,
+    centroid: () => centroid2,
+    circle: () => circle2,
+    cluster: () => cluster2,
+    column: () => column2,
+    contour: () => contour2,
+    delaunayLink: () => delaunayLink2,
+    delaunayMesh: () => delaunayMesh2,
+    density: () => density2,
+    dodgeX: () => dodgeX2,
+    dodgeY: () => dodgeY2,
+    dot: () => dot2,
+    dotX: () => dotX2,
+    dotY: () => dotY2,
+    filter: () => filter6,
+    formatIsoDate: () => formatIsoDate2,
+    formatMonth: () => formatMonth2,
+    formatWeekday: () => formatWeekday2,
+    frame: () => frame4,
+    geo: () => geo2,
+    geoCentroid: () => geoCentroid2,
+    graticule: () => graticule4,
+    gridFx: () => gridFx2,
+    gridFy: () => gridFy2,
+    gridX: () => gridX2,
+    gridY: () => gridY2,
+    group: () => group4,
+    groupX: () => groupX2,
+    groupY: () => groupY2,
+    groupZ: () => groupZ3,
+    hexagon: () => hexagon2,
+    hexbin: () => hexbin2,
+    hexgrid: () => hexgrid2,
+    hull: () => hull2,
+    identity: () => identity13,
+    image: () => image2,
+    initializer: () => initializer2,
+    interpolateNearest: () => interpolateNearest2,
+    interpolateNone: () => interpolateNone2,
+    interpolatorBarycentric: () => interpolatorBarycentric2,
+    interpolatorRandomWalk: () => interpolatorRandomWalk2,
+    legend: () => legend2,
+    line: () => line2,
+    lineX: () => lineX2,
+    lineY: () => lineY2,
+    linearRegressionX: () => linearRegressionX2,
+    linearRegressionY: () => linearRegressionY2,
+    link: () => link6,
+    map: () => map10,
+    mapX: () => mapX2,
+    mapY: () => mapY2,
+    marks: () => marks2,
+    normalize: () => normalize6,
+    normalizeX: () => normalizeX2,
+    normalizeY: () => normalizeY2,
+    plot: () => plot2,
+    raster: () => raster2,
+    rect: () => rect2,
+    rectX: () => rectX2,
+    rectY: () => rectY2,
+    reverse: () => reverse4,
+    ruleX: () => ruleX2,
+    ruleY: () => ruleY2,
+    scale: () => scale4,
+    select: () => select2,
+    selectFirst: () => selectFirst2,
+    selectLast: () => selectLast2,
+    selectMaxX: () => selectMaxX2,
+    selectMaxY: () => selectMaxY2,
+    selectMinX: () => selectMinX2,
+    selectMinY: () => selectMinY2,
+    shuffle: () => shuffle4,
+    sort: () => sort4,
+    sphere: () => sphere2,
+    spike: () => spike2,
+    stackX: () => stackX3,
+    stackX1: () => stackX12,
+    stackX2: () => stackX22,
+    stackY: () => stackY3,
+    stackY1: () => stackY12,
+    stackY2: () => stackY22,
+    text: () => text2,
+    textX: () => textX2,
+    textY: () => textY2,
+    tickX: () => tickX2,
+    tickY: () => tickY2,
+    transform: () => basic2,
+    tree: () => tree2,
+    treeLink: () => treeLink2,
+    treeNode: () => treeNode2,
+    valueof: () => valueof2,
+    vector: () => vector2,
+    vectorX: () => vectorX2,
+    vectorY: () => vectorY2,
+    voronoi: () => voronoi2,
+    voronoiMesh: () => voronoiMesh2,
+    window: () => window3,
+    windowX: () => windowX2,
+    windowY: () => windowY2
+});
+
+// js/pyobsplot-js/node_modules/d3/src/index.js
+var src_exports3 = {};
+__export(src_exports3, {
+    Adder: () => Adder2,
+    Delaunay: () => Delaunay2,
+    FormatSpecifier: () => FormatSpecifier2,
+    InternMap: () => InternMap2,
+    InternSet: () => InternSet2,
+    Node: () => Node4,
+    Path: () => Path3,
+    Voronoi: () => Voronoi3,
+    ZoomTransform: () => Transform2,
+    active: () => active_default2,
+    arc: () => arc_default2,
+    area: () => area_default10,
+    areaRadial: () => areaRadial_default2,
+    ascending: () => ascending3,
+    autoType: () => autoType2,
+    axisBottom: () => axisBottom2,
+    axisLeft: () => axisLeft2,
+    axisRight: () => axisRight2,
+    axisTop: () => axisTop2,
+    bin: () => bin3,
+    bisect: () => bisect_default2,
+    bisectCenter: () => bisectCenter2,
+    bisectLeft: () => bisectLeft2,
+    bisectRight: () => bisectRight2,
+    bisector: () => bisector2,
+    blob: () => blob_default2,
+    blur: () => blur3,
+    blur2: () => blur22,
+    blurImage: () => blurImage2,
+    brush: () => brush_default2,
+    brushSelection: () => brushSelection2,
+    brushX: () => brushX2,
+    brushY: () => brushY2,
+    buffer: () => buffer_default3,
+    chord: () => chord_default2,
+    chordDirected: () => chordDirected2,
+    chordTranspose: () => chordTranspose2,
+    cluster: () => cluster_default2,
+    color: () => color3,
+    contourDensity: () => density_default2,
+    contours: () => contours_default2,
+    count: () => count3,
+    create: () => create_default2,
+    creator: () => creator_default2,
+    cross: () => cross2,
+    csv: () => csv4,
+    csvFormat: () => csvFormat2,
+    csvFormatBody: () => csvFormatBody2,
+    csvFormatRow: () => csvFormatRow2,
+    csvFormatRows: () => csvFormatRows2,
+    csvFormatValue: () => csvFormatValue2,
+    csvParse: () => csvParse2,
+    csvParseRows: () => csvParseRows2,
+    cubehelix: () => cubehelix3,
+    cumsum: () => cumsum2,
+    curveBasis: () => basis_default4,
+    curveBasisClosed: () => basisClosed_default4,
+    curveBasisOpen: () => basisOpen_default2,
+    curveBumpX: () => bumpX2,
+    curveBumpY: () => bumpY2,
+    curveBundle: () => bundle_default2,
+    curveCardinal: () => cardinal_default2,
+    curveCardinalClosed: () => cardinalClosed_default2,
+    curveCardinalOpen: () => cardinalOpen_default2,
+    curveCatmullRom: () => catmullRom_default2,
+    curveCatmullRomClosed: () => catmullRomClosed_default2,
+    curveCatmullRomOpen: () => catmullRomOpen_default2,
+    curveLinear: () => linear_default2,
+    curveLinearClosed: () => linearClosed_default2,
+    curveMonotoneX: () => monotoneX2,
+    curveMonotoneY: () => monotoneY2,
+    curveNatural: () => natural_default2,
+    curveStep: () => step_default2,
+    curveStepAfter: () => stepAfter2,
+    curveStepBefore: () => stepBefore2,
+    descending: () => descending2,
+    deviation: () => deviation2,
+    difference: () => difference3,
+    disjoint: () => disjoint2,
+    dispatch: () => dispatch_default3,
+    drag: () => drag_default2,
+    dragDisable: () => nodrag_default2,
+    dragEnable: () => yesdrag2,
+    dsv: () => dsv2,
+    dsvFormat: () => dsv_default2,
+    easeBack: () => backInOut2,
+    easeBackIn: () => backIn2,
+    easeBackInOut: () => backInOut2,
+    easeBackOut: () => backOut2,
+    easeBounce: () => bounceOut2,
+    easeBounceIn: () => bounceIn2,
+    easeBounceInOut: () => bounceInOut2,
+    easeBounceOut: () => bounceOut2,
+    easeCircle: () => circleInOut2,
+    easeCircleIn: () => circleIn2,
+    easeCircleInOut: () => circleInOut2,
+    easeCircleOut: () => circleOut2,
+    easeCubic: () => cubicInOut2,
+    easeCubicIn: () => cubicIn2,
+    easeCubicInOut: () => cubicInOut2,
+    easeCubicOut: () => cubicOut2,
+    easeElastic: () => elasticOut2,
+    easeElasticIn: () => elasticIn2,
+    easeElasticInOut: () => elasticInOut2,
+    easeElasticOut: () => elasticOut2,
+    easeExp: () => expInOut2,
+    easeExpIn: () => expIn2,
+    easeExpInOut: () => expInOut2,
+    easeExpOut: () => expOut2,
+    easeLinear: () => linear5,
+    easePoly: () => polyInOut2,
+    easePolyIn: () => polyIn2,
+    easePolyInOut: () => polyInOut2,
+    easePolyOut: () => polyOut2,
+    easeQuad: () => quadInOut2,
+    easeQuadIn: () => quadIn2,
+    easeQuadInOut: () => quadInOut2,
+    easeQuadOut: () => quadOut2,
+    easeSin: () => sinInOut2,
+    easeSinIn: () => sinIn2,
+    easeSinInOut: () => sinInOut2,
+    easeSinOut: () => sinOut2,
+    every: () => every2,
+    extent: () => extent3,
+    fcumsum: () => fcumsum2,
+    filter: () => filter4,
+    flatGroup: () => flatGroup2,
+    flatRollup: () => flatRollup2,
+    forceCenter: () => center_default2,
+    forceCollide: () => collide_default2,
+    forceLink: () => link_default2,
+    forceManyBody: () => manyBody_default2,
+    forceRadial: () => radial_default2,
+    forceSimulation: () => simulation_default2,
+    forceX: () => x_default4,
+    forceY: () => y_default4,
+    format: () => format3,
+    formatDefaultLocale: () => defaultLocale3,
+    formatLocale: () => locale_default2,
+    formatPrefix: () => formatPrefix2,
+    formatSpecifier: () => formatSpecifier2,
+    fsum: () => fsum2,
+    geoAlbers: () => albers_default2,
+    geoAlbersUsa: () => albersUsa_default2,
+    geoArea: () => area_default7,
+    geoAzimuthalEqualArea: () => azimuthalEqualArea_default2,
+    geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw2,
+    geoAzimuthalEquidistant: () => azimuthalEquidistant_default2,
+    geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw2,
+    geoBounds: () => bounds_default3,
+    geoCentroid: () => centroid_default4,
+    geoCircle: () => circle_default4,
+    geoClipAntimeridian: () => antimeridian_default2,
+    geoClipCircle: () => circle_default5,
+    geoClipExtent: () => extent_default4,
+    geoClipRectangle: () => clipRectangle2,
+    geoConicConformal: () => conicConformal_default2,
+    geoConicConformalRaw: () => conicConformalRaw2,
+    geoConicEqualArea: () => conicEqualArea_default2,
+    geoConicEqualAreaRaw: () => conicEqualAreaRaw2,
+    geoConicEquidistant: () => conicEquidistant_default2,
+    geoConicEquidistantRaw: () => conicEquidistantRaw2,
+    geoContains: () => contains_default5,
+    geoDistance: () => distance_default2,
+    geoEqualEarth: () => equalEarth_default2,
+    geoEqualEarthRaw: () => equalEarthRaw2,
+    geoEquirectangular: () => equirectangular_default2,
+    geoEquirectangularRaw: () => equirectangularRaw2,
+    geoGnomonic: () => gnomonic_default2,
+    geoGnomonicRaw: () => gnomonicRaw2,
+    geoGraticule: () => graticule3,
+    geoGraticule10: () => graticule102,
+    geoIdentity: () => identity_default9,
+    geoInterpolate: () => interpolate_default4,
+    geoLength: () => length_default3,
+    geoMercator: () => mercator_default2,
+    geoMercatorRaw: () => mercatorRaw2,
+    geoNaturalEarth1: () => naturalEarth1_default2,
+    geoNaturalEarth1Raw: () => naturalEarth1Raw2,
+    geoOrthographic: () => orthographic_default2,
+    geoOrthographicRaw: () => orthographicRaw2,
+    geoPath: () => path_default3,
+    geoProjection: () => projection2,
+    geoProjectionMutator: () => projectionMutator2,
+    geoRotation: () => rotation_default2,
+    geoStereographic: () => stereographic_default2,
+    geoStereographicRaw: () => stereographicRaw2,
+    geoStream: () => stream_default2,
+    geoTransform: () => transform_default2,
+    geoTransverseMercator: () => transverseMercator_default2,
+    geoTransverseMercatorRaw: () => transverseMercatorRaw2,
+    gray: () => gray2,
+    greatest: () => greatest2,
+    greatestIndex: () => greatestIndex2,
+    group: () => group3,
+    groupSort: () => groupSort2,
+    groups: () => groups2,
+    hcl: () => hcl3,
+    hierarchy: () => hierarchy2,
+    histogram: () => bin3,
+    hsl: () => hsl3,
+    html: () => html2,
+    image: () => image_default2,
+    index: () => index3,
+    indexes: () => indexes2,
+    interpolate: () => value_default2,
+    interpolateArray: () => array_default4,
+    interpolateBasis: () => basis_default3,
+    interpolateBasisClosed: () => basisClosed_default3,
+    interpolateBlues: () => Blues_default2,
+    interpolateBrBG: () => BrBG_default2,
+    interpolateBuGn: () => BuGn_default2,
+    interpolateBuPu: () => BuPu_default2,
+    interpolateCividis: () => cividis_default2,
+    interpolateCool: () => cool2,
+    interpolateCubehelix: () => cubehelix_default3,
+    interpolateCubehelixDefault: () => cubehelix_default4,
+    interpolateCubehelixLong: () => cubehelixLong2,
+    interpolateDate: () => date_default2,
+    interpolateDiscrete: () => discrete_default2,
+    interpolateGnBu: () => GnBu_default2,
+    interpolateGreens: () => Greens_default2,
+    interpolateGreys: () => Greys_default2,
+    interpolateHcl: () => hcl_default2,
+    interpolateHclLong: () => hclLong2,
+    interpolateHsl: () => hsl_default2,
+    interpolateHslLong: () => hslLong2,
+    interpolateHue: () => hue_default2,
+    interpolateInferno: () => inferno2,
+    interpolateLab: () => lab4,
+    interpolateMagma: () => magma2,
+    interpolateNumber: () => number_default2,
+    interpolateNumberArray: () => numberArray_default2,
+    interpolateObject: () => object_default2,
+    interpolateOrRd: () => OrRd_default2,
+    interpolateOranges: () => Oranges_default2,
+    interpolatePRGn: () => PRGn_default2,
+    interpolatePiYG: () => PiYG_default2,
+    interpolatePlasma: () => plasma2,
+    interpolatePuBu: () => PuBu_default2,
+    interpolatePuBuGn: () => PuBuGn_default2,
+    interpolatePuOr: () => PuOr_default2,
+    interpolatePuRd: () => PuRd_default2,
+    interpolatePurples: () => Purples_default2,
+    interpolateRainbow: () => rainbow_default2,
+    interpolateRdBu: () => RdBu_default2,
+    interpolateRdGy: () => RdGy_default2,
+    interpolateRdPu: () => RdPu_default2,
+    interpolateRdYlBu: () => RdYlBu_default2,
+    interpolateRdYlGn: () => RdYlGn_default2,
+    interpolateReds: () => Reds_default2,
+    interpolateRgb: () => rgb_default2,
+    interpolateRgbBasis: () => rgbBasis2,
+    interpolateRgbBasisClosed: () => rgbBasisClosed2,
+    interpolateRound: () => round_default3,
+    interpolateSinebow: () => sinebow_default2,
+    interpolateSpectral: () => Spectral_default2,
+    interpolateString: () => string_default2,
+    interpolateTransformCss: () => interpolateTransformCss2,
+    interpolateTransformSvg: () => interpolateTransformSvg2,
+    interpolateTurbo: () => turbo_default2,
+    interpolateViridis: () => viridis_default2,
+    interpolateWarm: () => warm2,
+    interpolateYlGn: () => YlGn_default2,
+    interpolateYlGnBu: () => YlGnBu_default2,
+    interpolateYlOrBr: () => YlOrBr_default2,
+    interpolateYlOrRd: () => YlOrRd_default2,
+    interpolateZoom: () => zoom_default3,
+    interrupt: () => interrupt_default3,
+    intersection: () => intersection2,
+    interval: () => interval_default2,
+    isoFormat: () => isoFormat_default2,
+    isoParse: () => isoParse_default2,
+    json: () => json_default2,
+    lab: () => lab3,
+    lch: () => lch2,
+    least: () => least2,
+    leastIndex: () => leastIndex2,
+    line: () => line_default4,
+    lineRadial: () => lineRadial_default2,
+    link: () => link5,
+    linkHorizontal: () => linkHorizontal2,
+    linkRadial: () => linkRadial2,
+    linkVertical: () => linkVertical2,
+    local: () => local3,
+    map: () => map7,
+    matcher: () => matcher_default2,
+    max: () => max5,
+    maxIndex: () => maxIndex2,
+    mean: () => mean2,
+    median: () => median2,
+    medianIndex: () => medianIndex2,
+    merge: () => merge2,
+    min: () => min4,
+    minIndex: () => minIndex2,
+    mode: () => mode2,
+    namespace: () => namespace_default2,
+    namespaces: () => namespaces_default2,
+    nice: () => nice3,
+    now: () => now2,
+    pack: () => pack_default2,
+    packEnclose: () => enclose_default2,
+    packSiblings: () => siblings_default2,
+    pairs: () => pairs2,
+    partition: () => partition_default2,
+    path: () => path2,
+    pathRound: () => pathRound2,
+    permute: () => permute2,
+    pie: () => pie_default2,
+    piecewise: () => piecewise2,
+    pointRadial: () => pointRadial_default2,
+    pointer: () => pointer_default2,
+    pointers: () => pointers_default2,
+    polygonArea: () => area_default9,
+    polygonCentroid: () => centroid_default6,
+    polygonContains: () => contains_default6,
+    polygonHull: () => hull_default2,
+    polygonLength: () => length_default4,
+    precisionFixed: () => precisionFixed_default2,
+    precisionPrefix: () => precisionPrefix_default2,
+    precisionRound: () => precisionRound_default2,
+    quadtree: () => quadtree2,
+    quantile: () => quantile3,
+    quantileIndex: () => quantileIndex2,
+    quantileSorted: () => quantileSorted2,
+    quantize: () => quantize_default2,
+    quickselect: () => quickselect2,
+    radialArea: () => areaRadial_default2,
+    radialLine: () => lineRadial_default2,
+    randomBates: () => bates_default2,
+    randomBernoulli: () => bernoulli_default2,
+    randomBeta: () => beta_default2,
+    randomBinomial: () => binomial_default2,
+    randomCauchy: () => cauchy_default2,
+    randomExponential: () => exponential_default2,
+    randomGamma: () => gamma_default2,
+    randomGeometric: () => geometric_default2,
+    randomInt: () => int_default2,
+    randomIrwinHall: () => irwinHall_default2,
+    randomLcg: () => lcg2,
+    randomLogNormal: () => logNormal_default2,
+    randomLogistic: () => logistic_default2,
+    randomNormal: () => normal_default2,
+    randomPareto: () => pareto_default2,
+    randomPoisson: () => poisson_default2,
+    randomUniform: () => uniform_default2,
+    randomWeibull: () => weibull_default2,
+    range: () => range5,
+    rank: () => rank2,
+    reduce: () => reduce2,
+    reverse: () => reverse3,
+    rgb: () => rgb2,
+    ribbon: () => ribbon_default2,
+    ribbonArrow: () => ribbonArrow2,
+    rollup: () => rollup2,
+    rollups: () => rollups2,
+    scaleBand: () => band2,
+    scaleDiverging: () => diverging2,
+    scaleDivergingLog: () => divergingLog2,
+    scaleDivergingPow: () => divergingPow2,
+    scaleDivergingSqrt: () => divergingSqrt2,
+    scaleDivergingSymlog: () => divergingSymlog2,
+    scaleIdentity: () => identity11,
+    scaleImplicit: () => implicit2,
+    scaleLinear: () => linear6,
+    scaleLog: () => log4,
+    scaleOrdinal: () => ordinal2,
+    scalePoint: () => point6,
+    scalePow: () => pow6,
+    scaleQuantile: () => quantile4,
+    scaleQuantize: () => quantize2,
+    scaleRadial: () => radial2,
+    scaleSequential: () => sequential2,
+    scaleSequentialLog: () => sequentialLog2,
+    scaleSequentialPow: () => sequentialPow2,
+    scaleSequentialQuantile: () => sequentialQuantile2,
+    scaleSequentialSqrt: () => sequentialSqrt2,
+    scaleSequentialSymlog: () => sequentialSymlog2,
+    scaleSqrt: () => sqrt5,
+    scaleSymlog: () => symlog2,
+    scaleThreshold: () => threshold2,
+    scaleTime: () => time2,
+    scaleUtc: () => utcTime2,
+    scan: () => scan2,
+    schemeAccent: () => Accent_default2,
+    schemeBlues: () => scheme49,
+    schemeBrBG: () => scheme28,
+    schemeBuGn: () => scheme37,
+    schemeBuPu: () => scheme38,
+    schemeCategory10: () => category10_default2,
+    schemeDark2: () => Dark2_default2,
+    schemeGnBu: () => scheme39,
+    schemeGreens: () => scheme50,
+    schemeGreys: () => scheme51,
+    schemeOrRd: () => scheme40,
+    schemeOranges: () => scheme54,
+    schemePRGn: () => scheme29,
+    schemePaired: () => Paired_default2,
+    schemePastel1: () => Pastel1_default2,
+    schemePastel2: () => Pastel2_default2,
+    schemePiYG: () => scheme30,
+    schemePuBu: () => scheme42,
+    schemePuBuGn: () => scheme41,
+    schemePuOr: () => scheme31,
+    schemePuRd: () => scheme43,
+    schemePurples: () => scheme52,
+    schemeRdBu: () => scheme32,
+    schemeRdGy: () => scheme33,
+    schemeRdPu: () => scheme44,
+    schemeRdYlBu: () => scheme34,
+    schemeRdYlGn: () => scheme35,
+    schemeReds: () => scheme53,
+    schemeSet1: () => Set1_default2,
+    schemeSet2: () => Set2_default2,
+    schemeSet3: () => Set3_default2,
+    schemeSpectral: () => scheme36,
+    schemeTableau10: () => Tableau10_default2,
+    schemeYlGn: () => scheme46,
+    schemeYlGnBu: () => scheme45,
+    schemeYlOrBr: () => scheme47,
+    schemeYlOrRd: () => scheme48,
+    select: () => select_default5,
+    selectAll: () => selectAll_default5,
+    selection: () => selection_default3,
+    selector: () => selector_default2,
+    selectorAll: () => selectorAll_default2,
+    shuffle: () => shuffle_default2,
+    shuffler: () => shuffler2,
+    some: () => some2,
+    sort: () => sort3,
+    stack: () => stack_default2,
+    stackOffsetDiverging: () => diverging_default2,
+    stackOffsetExpand: () => expand_default2,
+    stackOffsetNone: () => none_default3,
+    stackOffsetSilhouette: () => silhouette_default2,
+    stackOffsetWiggle: () => wiggle_default2,
+    stackOrderAppearance: () => appearance_default2,
+    stackOrderAscending: () => ascending_default4,
+    stackOrderDescending: () => descending_default4,
+    stackOrderInsideOut: () => insideOut_default2,
+    stackOrderNone: () => none_default4,
+    stackOrderReverse: () => reverse_default2,
+    stratify: () => stratify_default2,
+    style: () => styleValue2,
+    subset: () => subset2,
+    sum: () => sum4,
+    superset: () => superset2,
+    svg: () => svg2,
+    symbol: () => Symbol3,
+    symbolAsterisk: () => asterisk_default2,
+    symbolCircle: () => circle_default6,
+    symbolCross: () => cross_default4,
+    symbolDiamond: () => diamond_default2,
+    symbolDiamond2: () => diamond2_default2,
+    symbolPlus: () => plus_default2,
+    symbolSquare: () => square_default2,
+    symbolSquare2: () => square2_default2,
+    symbolStar: () => star_default2,
+    symbolTimes: () => times_default2,
+    symbolTriangle: () => triangle_default2,
+    symbolTriangle2: () => triangle2_default2,
+    symbolWye: () => wye_default2,
+    symbolX: () => times_default2,
+    symbols: () => symbolsFill2,
+    symbolsFill: () => symbolsFill2,
+    symbolsStroke: () => symbolsStroke2,
+    text: () => text_default6,
+    thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis2,
+    thresholdScott: () => thresholdScott2,
+    thresholdSturges: () => thresholdSturges2,
+    tickFormat: () => tickFormat2,
+    tickIncrement: () => tickIncrement2,
+    tickStep: () => tickStep2,
+    ticks: () => ticks2,
+    timeDay: () => timeDay2,
+    timeDays: () => timeDays2,
+    timeFormat: () => timeFormat2,
+    timeFormatDefaultLocale: () => defaultLocale4,
+    timeFormatLocale: () => formatLocale2,
+    timeFriday: () => timeFriday2,
+    timeFridays: () => timeFridays2,
+    timeHour: () => timeHour2,
+    timeHours: () => timeHours2,
+    timeInterval: () => timeInterval2,
+    timeMillisecond: () => millisecond2,
+    timeMilliseconds: () => milliseconds2,
+    timeMinute: () => timeMinute2,
+    timeMinutes: () => timeMinutes2,
+    timeMonday: () => timeMonday2,
+    timeMondays: () => timeMondays2,
+    timeMonth: () => timeMonth2,
+    timeMonths: () => timeMonths2,
+    timeParse: () => timeParse2,
+    timeSaturday: () => timeSaturday2,
+    timeSaturdays: () => timeSaturdays2,
+    timeSecond: () => second3,
+    timeSeconds: () => seconds2,
+    timeSunday: () => timeSunday2,
+    timeSundays: () => timeSundays2,
+    timeThursday: () => timeThursday2,
+    timeThursdays: () => timeThursdays2,
+    timeTickInterval: () => timeTickInterval2,
+    timeTicks: () => timeTicks2,
+    timeTuesday: () => timeTuesday2,
+    timeTuesdays: () => timeTuesdays2,
+    timeWednesday: () => timeWednesday2,
+    timeWednesdays: () => timeWednesdays2,
+    timeWeek: () => timeSunday2,
+    timeWeeks: () => timeSundays2,
+    timeYear: () => timeYear2,
+    timeYears: () => timeYears2,
+    timeout: () => timeout_default2,
+    timer: () => timer2,
+    timerFlush: () => timerFlush2,
+    transition: () => transition2,
+    transpose: () => transpose2,
+    tree: () => tree_default2,
+    treemap: () => treemap_default2,
+    treemapBinary: () => binary_default2,
+    treemapDice: () => dice_default2,
+    treemapResquarify: () => resquarify_default2,
+    treemapSlice: () => slice_default2,
+    treemapSliceDice: () => sliceDice_default2,
+    treemapSquarify: () => squarify_default2,
+    tsv: () => tsv4,
+    tsvFormat: () => tsvFormat2,
+    tsvFormatBody: () => tsvFormatBody2,
+    tsvFormatRow: () => tsvFormatRow2,
+    tsvFormatRows: () => tsvFormatRows2,
+    tsvFormatValue: () => tsvFormatValue2,
+    tsvParse: () => tsvParse2,
+    tsvParseRows: () => tsvParseRows2,
+    union: () => union2,
+    unixDay: () => unixDay2,
+    unixDays: () => unixDays2,
+    utcDay: () => utcDay2,
+    utcDays: () => utcDays2,
+    utcFormat: () => utcFormat2,
+    utcFriday: () => utcFriday2,
+    utcFridays: () => utcFridays2,
+    utcHour: () => utcHour2,
+    utcHours: () => utcHours2,
+    utcMillisecond: () => millisecond2,
+    utcMilliseconds: () => milliseconds2,
+    utcMinute: () => utcMinute2,
+    utcMinutes: () => utcMinutes2,
+    utcMonday: () => utcMonday2,
+    utcMondays: () => utcMondays2,
+    utcMonth: () => utcMonth2,
+    utcMonths: () => utcMonths2,
+    utcParse: () => utcParse2,
+    utcSaturday: () => utcSaturday2,
+    utcSaturdays: () => utcSaturdays2,
+    utcSecond: () => second3,
+    utcSeconds: () => seconds2,
+    utcSunday: () => utcSunday2,
+    utcSundays: () => utcSundays2,
+    utcThursday: () => utcThursday2,
+    utcThursdays: () => utcThursdays2,
+    utcTickInterval: () => utcTickInterval2,
+    utcTicks: () => utcTicks2,
+    utcTuesday: () => utcTuesday2,
+    utcTuesdays: () => utcTuesdays2,
+    utcWednesday: () => utcWednesday2,
+    utcWednesdays: () => utcWednesdays2,
+    utcWeek: () => utcSunday2,
+    utcWeeks: () => utcSundays2,
+    utcYear: () => utcYear2,
+    utcYears: () => utcYears2,
+    variance: () => variance2,
+    window: () => window_default2,
+    xml: () => xml_default2,
+    zip: () => zip2,
+    zoom: () => zoom_default4,
+    zoomIdentity: () => identity12,
+    zoomTransform: () => transform2
+});
+
+// js/pyobsplot-js/node_modules/d3-array/src/ascending.js
+function ascending3(a7, b) {
+    return a7 == null || b == null ? NaN : a7 < b ? -1 : a7 > b ? 1 : a7 >= b ? 0 : NaN;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/descending.js
+function descending2(a7, b) {
+    return a7 == null || b == null ? NaN : b < a7 ? -1 : b > a7 ? 1 : b >= a7 ? 0 : NaN;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/bisector.js
+function bisector2(f) {
+    let compare1, compare2, delta;
+    if (f.length !== 2) {
+        compare1 = ascending3;
+        compare2 = (d, x7) => ascending3(f(d), x7);
+        delta = (d, x7) => f(d) - x7;
+    } else {
+        compare1 = f === ascending3 || f === descending2 ? f : zero3;
+        compare2 = f;
+        delta = f;
+    }
+
+    function left3(a7, x7, lo = 0, hi = a7.length) {
+        if (lo < hi) {
+            if (compare1(x7, x7) !== 0)
+                return hi;
+            do {
+                const mid3 = lo + hi >>> 1;
+                if (compare2(a7[mid3], x7) < 0)
+                    lo = mid3 + 1;
+                else
+                    hi = mid3;
+            } while (lo < hi);
+        }
+        return lo;
+    }
+
+    function right3(a7, x7, lo = 0, hi = a7.length) {
+        if (lo < hi) {
+            if (compare1(x7, x7) !== 0)
+                return hi;
+            do {
+                const mid3 = lo + hi >>> 1;
+                if (compare2(a7[mid3], x7) <= 0)
+                    lo = mid3 + 1;
+                else
+                    hi = mid3;
+            } while (lo < hi);
+        }
+        return lo;
+    }
+
+    function center3(a7, x7, lo = 0, hi = a7.length) {
+        const i = left3(a7, x7, lo, hi - 1);
+        return i > lo && delta(a7[i - 1], x7) > -delta(a7[i], x7) ? i - 1 : i;
+    }
+    return {
+        left: left3,
+        center: center3,
+        right: right3
+    };
+}
+
+function zero3() {
+    return 0;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/number.js
+function number7(x7) {
+    return x7 === null ? NaN : +x7;
+}
+
+function* numbers2(values3, valueof3) {
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value != null && (value = +value) >= value) {
+                yield value;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                yield value;
+            }
+        }
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/bisect.js
+var ascendingBisect2 = bisector2(ascending3);
+var bisectRight2 = ascendingBisect2.right;
+var bisectLeft2 = ascendingBisect2.left;
+var bisectCenter2 = bisector2(number7).center;
+var bisect_default2 = bisectRight2;
+
+// js/pyobsplot-js/node_modules/d3-array/src/blur.js
+function blur3(values3, r) {
+    if (!((r = +r) >= 0))
+        throw new RangeError("invalid r");
+    let length7 = values3.length;
+    if (!((length7 = Math.floor(length7)) >= 0))
+        throw new RangeError("invalid length");
+    if (!length7 || !r)
+        return values3;
+    const blur4 = blurf2(r);
+    const temp = values3.slice();
+    blur4(values3, temp, 0, length7, 1);
+    blur4(temp, values3, 0, length7, 1);
+    blur4(values3, temp, 0, length7, 1);
+    return values3;
+}
+var blur22 = Blur22(blurf2);
+var blurImage2 = Blur22(blurfImage2);
+
+function Blur22(blur4) {
+    return function(data, rx, ry = rx) {
+        if (!((rx = +rx) >= 0))
+            throw new RangeError("invalid rx");
+        if (!((ry = +ry) >= 0))
+            throw new RangeError("invalid ry");
+        let {
+            data: values3,
+            width,
+            height
+        } = data;
+        if (!((width = Math.floor(width)) >= 0))
+            throw new RangeError("invalid width");
+        if (!((height = Math.floor(height !== void 0 ? height : values3.length / width)) >= 0))
+            throw new RangeError("invalid height");
+        if (!width || !height || !rx && !ry)
+            return data;
+        const blurx = rx && blur4(rx);
+        const blury = ry && blur4(ry);
+        const temp = values3.slice();
+        if (blurx && blury) {
+            blurh2(blurx, temp, values3, width, height);
+            blurh2(blurx, values3, temp, width, height);
+            blurh2(blurx, temp, values3, width, height);
+            blurv2(blury, values3, temp, width, height);
+            blurv2(blury, temp, values3, width, height);
+            blurv2(blury, values3, temp, width, height);
+        } else if (blurx) {
+            blurh2(blurx, values3, temp, width, height);
+            blurh2(blurx, temp, values3, width, height);
+            blurh2(blurx, values3, temp, width, height);
+        } else if (blury) {
+            blurv2(blury, values3, temp, width, height);
+            blurv2(blury, temp, values3, width, height);
+            blurv2(blury, values3, temp, width, height);
+        }
+        return data;
+    };
+}
+
+function blurh2(blur4, T, S, w, h) {
+    for (let y7 = 0, n = w * h; y7 < n;) {
+        blur4(T, S, y7, y7 += w, 1);
+    }
+}
+
+function blurv2(blur4, T, S, w, h) {
+    for (let x7 = 0, n = w * h; x7 < w; ++x7) {
+        blur4(T, S, x7, x7 + n, w);
+    }
+}
+
+function blurfImage2(radius3) {
+    const blur4 = blurf2(radius3);
+    return (T, S, start3, stop, step) => {
+        start3 <<= 2, stop <<= 2, step <<= 2;
+        blur4(T, S, start3 + 0, stop + 0, step);
+        blur4(T, S, start3 + 1, stop + 1, step);
+        blur4(T, S, start3 + 2, stop + 2, step);
+        blur4(T, S, start3 + 3, stop + 3, step);
+    };
+}
+
+function blurf2(radius3) {
+    const radius0 = Math.floor(radius3);
+    if (radius0 === radius3)
+        return bluri2(radius3);
+    const t = radius3 - radius0;
+    const w = 2 * radius3 + 1;
+    return (T, S, start3, stop, step) => {
+        if (!((stop -= step) >= start3))
+            return;
+        let sum8 = radius0 * S[start3];
+        const s0 = step * radius0;
+        const s1 = s0 + step;
+        for (let i = start3, j = start3 + s0; i < j; i += step) {
+            sum8 += S[Math.min(stop, i)];
+        }
+        for (let i = start3, j = stop; i <= j; i += step) {
+            sum8 += S[Math.min(stop, i + s0)];
+            T[i] = (sum8 + t * (S[Math.max(start3, i - s1)] + S[Math.min(stop, i + s1)])) / w;
+            sum8 -= S[Math.max(start3, i - s0)];
+        }
+    };
+}
+
+function bluri2(radius3) {
+    const w = 2 * radius3 + 1;
+    return (T, S, start3, stop, step) => {
+        if (!((stop -= step) >= start3))
+            return;
+        let sum8 = radius3 * S[start3];
+        const s3 = step * radius3;
+        for (let i = start3, j = start3 + s3; i < j; i += step) {
+            sum8 += S[Math.min(stop, i)];
+        }
+        for (let i = start3, j = stop; i <= j; i += step) {
+            sum8 += S[Math.min(stop, i + s3)];
+            T[i] = sum8 / w;
+            sum8 -= S[Math.max(start3, i - s3)];
+        }
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/count.js
+function count3(values3, valueof3) {
+    let count5 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value != null && (value = +value) >= value) {
+                ++count5;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                ++count5;
+            }
+        }
+    }
+    return count5;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/cross.js
+function length4(array7) {
+    return array7.length | 0;
+}
+
+function empty4(length7) {
+    return !(length7 > 0);
+}
+
+function arrayify3(values3) {
+    return typeof values3 !== "object" || "length" in values3 ? values3 : Array.from(values3);
+}
+
+function reducer2(reduce3) {
+    return (values3) => reduce3(...values3);
+}
+
+function cross2(...values3) {
+    const reduce3 = typeof values3[values3.length - 1] === "function" && reducer2(values3.pop());
+    values3 = values3.map(arrayify3);
+    const lengths = values3.map(length4);
+    const j = values3.length - 1;
+    const index5 = new Array(j + 1).fill(0);
+    const product = [];
+    if (j < 0 || lengths.some(empty4))
+        return product;
+    while (true) {
+        product.push(index5.map((j2, i2) => values3[i2][j2]));
+        let i = j;
+        while (++index5[i] === lengths[i]) {
+            if (i === 0)
+                return reduce3 ? product.map(reduce3) : product;
+            index5[i--] = 0;
+        }
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/cumsum.js
+function cumsum2(values3, valueof3) {
+    var sum8 = 0,
+        index5 = 0;
+    return Float64Array.from(values3, valueof3 === void 0 ? (v3) => sum8 += +v3 || 0 : (v3) => sum8 += +valueof3(v3, index5++, values3) || 0);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/variance.js
+function variance2(values3, valueof3) {
+    let count5 = 0;
+    let delta;
+    let mean3 = 0;
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value != null && (value = +value) >= value) {
+                delta = value - mean3;
+                mean3 += delta / ++count5;
+                sum8 += delta * (value - mean3);
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                delta = value - mean3;
+                mean3 += delta / ++count5;
+                sum8 += delta * (value - mean3);
+            }
+        }
+    }
+    if (count5 > 1)
+        return sum8 / (count5 - 1);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/deviation.js
+function deviation2(values3, valueof3) {
+    const v3 = variance2(values3, valueof3);
+    return v3 ? Math.sqrt(v3) : v3;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/extent.js
+function extent3(values3, valueof3) {
+    let min7;
+    let max9;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            if (value != null) {
+                if (min7 === void 0) {
+                    if (value >= value)
+                        min7 = max9 = value;
+                } else {
+                    if (min7 > value)
+                        min7 = value;
+                    if (max9 < value)
+                        max9 = value;
+                }
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null) {
+                if (min7 === void 0) {
+                    if (value >= value)
+                        min7 = max9 = value;
+                } else {
+                    if (min7 > value)
+                        min7 = value;
+                    if (max9 < value)
+                        max9 = value;
+                }
+            }
+        }
+    }
+    return [min7, max9];
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/fsum.js
+var Adder2 = class {
+    constructor() {
+        this._partials = new Float64Array(32);
+        this._n = 0;
+    }
+    add(x7) {
+        const p = this._partials;
+        let i = 0;
+        for (let j = 0; j < this._n && j < 32; j++) {
+            const y7 = p[j],
+                hi = x7 + y7,
+                lo = Math.abs(x7) < Math.abs(y7) ? x7 - (hi - y7) : y7 - (hi - x7);
+            if (lo)
+                p[i++] = lo;
+            x7 = hi;
+        }
+        p[i] = x7;
+        this._n = i + 1;
+        return this;
+    }
+    valueOf() {
+        const p = this._partials;
+        let n = this._n,
+            x7, y7, lo, hi = 0;
+        if (n > 0) {
+            hi = p[--n];
+            while (n > 0) {
+                x7 = hi;
+                y7 = p[--n];
+                hi = x7 + y7;
+                lo = y7 - (hi - x7);
+                if (lo)
+                    break;
+            }
+            if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
+                y7 = lo * 2;
+                x7 = hi + y7;
+                if (y7 == x7 - hi)
+                    hi = x7;
+            }
+        }
+        return hi;
+    }
+};
+
+function fsum2(values3, valueof3) {
+    const adder = new Adder2();
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value = +value) {
+                adder.add(value);
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if (value = +valueof3(value, ++index5, values3)) {
+                adder.add(value);
+            }
+        }
+    }
+    return +adder;
+}
+
+function fcumsum2(values3, valueof3) {
+    const adder = new Adder2();
+    let index5 = -1;
+    return Float64Array.from(
+        values3,
+        valueof3 === void 0 ? (v3) => adder.add(+v3 || 0) : (v3) => adder.add(+valueof3(v3, ++index5, values3) || 0)
+    );
+}
+
+// js/pyobsplot-js/node_modules/internmap/src/index.js
+var InternMap2 = class extends Map {
+    constructor(entries, key = keyof3) {
+        super();
+        Object.defineProperties(this, {
+            _intern: {
+                value: /* @__PURE__ */ new Map()
+            },
+            _key: {
+                value: key
+            }
+        });
+        if (entries != null)
+            for (const [key2, value] of entries)
+                this.set(key2, value);
+    }
+    get(key) {
+        return super.get(intern_get2(this, key));
+    }
+    has(key) {
+        return super.has(intern_get2(this, key));
+    }
+    set(key, value) {
+        return super.set(intern_set2(this, key), value);
+    }
+    delete(key) {
+        return super.delete(intern_delete2(this, key));
+    }
+};
+var InternSet2 = class extends Set {
+    constructor(values3, key = keyof3) {
+        super();
+        Object.defineProperties(this, {
+            _intern: {
+                value: /* @__PURE__ */ new Map()
+            },
+            _key: {
+                value: key
+            }
+        });
+        if (values3 != null)
+            for (const value of values3)
+                this.add(value);
+    }
+    has(value) {
+        return super.has(intern_get2(this, value));
+    }
+    add(value) {
+        return super.add(intern_set2(this, value));
+    }
+    delete(value) {
+        return super.delete(intern_delete2(this, value));
+    }
+};
+
+function intern_get2({
+    _intern,
+    _key
+}, value) {
+    const key = _key(value);
+    return _intern.has(key) ? _intern.get(key) : value;
+}
+
+function intern_set2({
+    _intern,
+    _key
+}, value) {
+    const key = _key(value);
+    if (_intern.has(key))
+        return _intern.get(key);
+    _intern.set(key, value);
+    return value;
+}
+
+function intern_delete2({
+    _intern,
+    _key
+}, value) {
+    const key = _key(value);
+    if (_intern.has(key)) {
+        value = _intern.get(key);
+        _intern.delete(key);
+    }
+    return value;
+}
+
+function keyof3(value) {
+    return value !== null && typeof value === "object" ? value.valueOf() : value;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/identity.js
+function identity8(x7) {
+    return x7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/group.js
+function group3(values3, ...keys) {
+    return nest2(values3, identity8, identity8, keys);
+}
+
+function groups2(values3, ...keys) {
+    return nest2(values3, Array.from, identity8, keys);
+}
+
+function flatten3(groups3, keys) {
+    for (let i = 1, n = keys.length; i < n; ++i) {
+        groups3 = groups3.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
+    }
+    return groups3;
+}
+
+function flatGroup2(values3, ...keys) {
+    return flatten3(groups2(values3, ...keys), keys);
+}
+
+function flatRollup2(values3, reduce3, ...keys) {
+    return flatten3(rollups2(values3, reduce3, ...keys), keys);
+}
+
+function rollup2(values3, reduce3, ...keys) {
+    return nest2(values3, identity8, reduce3, keys);
+}
+
+function rollups2(values3, reduce3, ...keys) {
+    return nest2(values3, Array.from, reduce3, keys);
+}
+
+function index3(values3, ...keys) {
+    return nest2(values3, identity8, unique2, keys);
+}
+
+function indexes2(values3, ...keys) {
+    return nest2(values3, Array.from, unique2, keys);
+}
+
+function unique2(values3) {
+    if (values3.length !== 1)
+        throw new Error("duplicate key");
+    return values3[0];
+}
+
+function nest2(values3, map11, reduce3, keys) {
+    return function regroup(values4, i) {
+        if (i >= keys.length)
+            return reduce3(values4);
+        const groups3 = new InternMap2();
+        const keyof5 = keys[i++];
+        let index5 = -1;
+        for (const value of values4) {
+            const key = keyof5(value, ++index5, values4);
+            const group5 = groups3.get(key);
+            if (group5)
+                group5.push(value);
+            else
+                groups3.set(key, [value]);
+        }
+        for (const [key, values5] of groups3) {
+            groups3.set(key, regroup(values5, i));
+        }
+        return map11(groups3);
+    }(values3, 0);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/permute.js
+function permute2(source, keys) {
+    return Array.from(keys, (key) => source[key]);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/sort.js
+function sort3(values3, ...F) {
+    if (typeof values3[Symbol.iterator] !== "function")
+        throw new TypeError("values is not iterable");
+    values3 = Array.from(values3);
+    let [f] = F;
+    if (f && f.length !== 2 || F.length > 1) {
+        const index5 = Uint32Array.from(values3, (d, i) => i);
+        if (F.length > 1) {
+            F = F.map((f2) => values3.map(f2));
+            index5.sort((i, j) => {
+                for (const f2 of F) {
+                    const c11 = ascendingDefined3(f2[i], f2[j]);
+                    if (c11)
+                        return c11;
+                }
+            });
+        } else {
+            f = values3.map(f);
+            index5.sort((i, j) => ascendingDefined3(f[i], f[j]));
+        }
+        return permute2(values3, index5);
+    }
+    return values3.sort(compareDefined2(f));
+}
+
+function compareDefined2(compare = ascending3) {
+    if (compare === ascending3)
+        return ascendingDefined3;
+    if (typeof compare !== "function")
+        throw new TypeError("compare is not a function");
+    return (a7, b) => {
+        const x7 = compare(a7, b);
+        if (x7 || x7 === 0)
+            return x7;
+        return (compare(b, b) === 0) - (compare(a7, a7) === 0);
+    };
+}
+
+function ascendingDefined3(a7, b) {
+    return (a7 == null || !(a7 >= a7)) - (b == null || !(b >= b)) || (a7 < b ? -1 : a7 > b ? 1 : 0);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/groupSort.js
+function groupSort2(values3, reduce3, key) {
+    return (reduce3.length !== 2 ? sort3(rollup2(values3, reduce3, key), ([ak, av], [bk, bv]) => ascending3(av, bv) || ascending3(ak, bk)) : sort3(group3(values3, key), ([ak, av], [bk, bv]) => reduce3(av, bv) || ascending3(ak, bk))).map(([key2]) => key2);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/array.js
+var array4 = Array.prototype;
+var slice7 = array4.slice;
+var map6 = array4.map;
+
+// js/pyobsplot-js/node_modules/d3-array/src/constant.js
+function constant3(x7) {
+    return () => x7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/ticks.js
+var e102 = Math.sqrt(50);
+var e52 = Math.sqrt(10);
+var e22 = Math.sqrt(2);
+
+function tickSpec2(start3, stop, count5) {
+    const step = (stop - start3) / Math.max(0, count5),
+        power = Math.floor(Math.log10(step)),
+        error = step / Math.pow(10, power),
+        factor = error >= e102 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1;
+    let i1, i2, inc3;
+    if (power < 0) {
+        inc3 = Math.pow(10, -power) / factor;
+        i1 = Math.round(start3 * inc3);
+        i2 = Math.round(stop * inc3);
+        if (i1 / inc3 < start3)
+            ++i1;
+        if (i2 / inc3 > stop)
+            --i2;
+        inc3 = -inc3;
+    } else {
+        inc3 = Math.pow(10, power) * factor;
+        i1 = Math.round(start3 / inc3);
+        i2 = Math.round(stop / inc3);
+        if (i1 * inc3 < start3)
+            ++i1;
+        if (i2 * inc3 > stop)
+            --i2;
+    }
+    if (i2 < i1 && 0.5 <= count5 && count5 < 2)
+        return tickSpec2(start3, stop, count5 * 2);
+    return [i1, i2, inc3];
+}
+
+function ticks2(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    if (!(count5 > 0))
+        return [];
+    if (start3 === stop)
+        return [start3];
+    const reverse5 = stop < start3,
+        [i1, i2, inc3] = reverse5 ? tickSpec2(stop, start3, count5) : tickSpec2(start3, stop, count5);
+    if (!(i2 >= i1))
+        return [];
+    const n = i2 - i1 + 1,
+        ticks3 = new Array(n);
+    if (reverse5) {
+        if (inc3 < 0)
+            for (let i = 0; i < n; ++i)
+                ticks3[i] = (i2 - i) / -inc3;
+        else
+            for (let i = 0; i < n; ++i)
+                ticks3[i] = (i2 - i) * inc3;
+    } else {
+        if (inc3 < 0)
+            for (let i = 0; i < n; ++i)
+                ticks3[i] = (i1 + i) / -inc3;
+        else
+            for (let i = 0; i < n; ++i)
+                ticks3[i] = (i1 + i) * inc3;
+    }
+    return ticks3;
+}
+
+function tickIncrement2(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    return tickSpec2(start3, stop, count5)[2];
+}
+
+function tickStep2(start3, stop, count5) {
+    stop = +stop, start3 = +start3, count5 = +count5;
+    const reverse5 = stop < start3,
+        inc3 = reverse5 ? tickIncrement2(stop, start3, count5) : tickIncrement2(start3, stop, count5);
+    return (reverse5 ? -1 : 1) * (inc3 < 0 ? 1 / -inc3 : inc3);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/nice.js
+function nice3(start3, stop, count5) {
+    let prestep;
+    while (true) {
+        const step = tickIncrement2(start3, stop, count5);
+        if (step === prestep || step === 0 || !isFinite(step)) {
+            return [start3, stop];
+        } else if (step > 0) {
+            start3 = Math.floor(start3 / step) * step;
+            stop = Math.ceil(stop / step) * step;
+        } else if (step < 0) {
+            start3 = Math.ceil(start3 * step) / step;
+            stop = Math.floor(stop * step) / step;
+        }
+        prestep = step;
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/threshold/sturges.js
+function thresholdSturges2(values3) {
+    return Math.max(1, Math.ceil(Math.log(count3(values3)) / Math.LN2) + 1);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/bin.js
+function bin3() {
+    var value = identity8,
+        domain = extent3,
+        threshold3 = thresholdSturges2;
+
+    function histogram(data) {
+        if (!Array.isArray(data))
+            data = Array.from(data);
+        var i, n = data.length,
+            x7, step, values3 = new Array(n);
+        for (i = 0; i < n; ++i) {
+            values3[i] = value(data[i], i, data);
+        }
+        var xz = domain(values3),
+            x011 = xz[0],
+            x13 = xz[1],
+            tz = threshold3(values3, x011, x13);
+        if (!Array.isArray(tz)) {
+            const max9 = x13,
+                tn = +tz;
+            if (domain === extent3)
+                [x011, x13] = nice3(x011, x13, tn);
+            tz = ticks2(x011, x13, tn);
+            if (tz[0] <= x011)
+                step = tickIncrement2(x011, x13, tn);
+            if (tz[tz.length - 1] >= x13) {
+                if (max9 >= x13 && domain === extent3) {
+                    const step2 = tickIncrement2(x011, x13, tn);
+                    if (isFinite(step2)) {
+                        if (step2 > 0) {
+                            x13 = (Math.floor(x13 / step2) + 1) * step2;
+                        } else if (step2 < 0) {
+                            x13 = (Math.ceil(x13 * -step2) + 1) / -step2;
+                        }
+                    }
+                } else {
+                    tz.pop();
+                }
+            }
+        }
+        var m5 = tz.length,
+            a7 = 0,
+            b = m5;
+        while (tz[a7] <= x011)
+            ++a7;
+        while (tz[b - 1] > x13)
+            --b;
+        if (a7 || b < m5)
+            tz = tz.slice(a7, b), m5 = b - a7;
+        var bins = new Array(m5 + 1),
+            bin5;
+        for (i = 0; i <= m5; ++i) {
+            bin5 = bins[i] = [];
+            bin5.x0 = i > 0 ? tz[i - 1] : x011;
+            bin5.x1 = i < m5 ? tz[i] : x13;
+        }
+        if (isFinite(step)) {
+            if (step > 0) {
+                for (i = 0; i < n; ++i) {
+                    if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                        bins[Math.min(m5, Math.floor((x7 - x011) / step))].push(data[i]);
+                    }
+                }
+            } else if (step < 0) {
+                for (i = 0; i < n; ++i) {
+                    if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                        const j = Math.floor((x011 - x7) * step);
+                        bins[Math.min(m5, j + (tz[j] <= x7))].push(data[i]);
+                    }
+                }
+            }
+        } else {
+            for (i = 0; i < n; ++i) {
+                if ((x7 = values3[i]) != null && x011 <= x7 && x7 <= x13) {
+                    bins[bisect_default2(tz, x7, 0, m5)].push(data[i]);
+                }
+            }
+        }
+        return bins;
+    }
+    histogram.value = function(_) {
+        return arguments.length ? (value = typeof _ === "function" ? _ : constant3(_), histogram) : value;
+    };
+    histogram.domain = function(_) {
+        return arguments.length ? (domain = typeof _ === "function" ? _ : constant3([_[0], _[1]]), histogram) : domain;
+    };
+    histogram.thresholds = function(_) {
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : constant3(Array.isArray(_) ? slice7.call(_) : _), histogram) : threshold3;
+    };
+    return histogram;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/max.js
+function max5(values3, valueof3) {
+    let max9;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            if (value != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value;
+            }
+        }
+    }
+    return max9;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/maxIndex.js
+function maxIndex2(values3, valueof3) {
+    let max9;
+    let maxIndex3 = -1;
+    let index5 = -1;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            ++index5;
+            if (value != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value, maxIndex3 = index5;
+            }
+        }
+    } else {
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (max9 < value || max9 === void 0 && value >= value)) {
+                max9 = value, maxIndex3 = index5;
+            }
+        }
+    }
+    return maxIndex3;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/min.js
+function min4(values3, valueof3) {
+    let min7;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            if (value != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value;
+            }
+        }
+    }
+    return min7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/minIndex.js
+function minIndex2(values3, valueof3) {
+    let min7;
+    let minIndex3 = -1;
+    let index5 = -1;
+    if (valueof3 === void 0) {
+        for (const value of values3) {
+            ++index5;
+            if (value != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value, minIndex3 = index5;
+            }
+        }
+    } else {
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (min7 > value || min7 === void 0 && value >= value)) {
+                min7 = value, minIndex3 = index5;
+            }
+        }
+    }
+    return minIndex3;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/quickselect.js
+function quickselect2(array7, k3, left3 = 0, right3 = Infinity, compare) {
+    k3 = Math.floor(k3);
+    left3 = Math.floor(Math.max(0, left3));
+    right3 = Math.floor(Math.min(array7.length - 1, right3));
+    if (!(left3 <= k3 && k3 <= right3))
+        return array7;
+    compare = compare === void 0 ? ascendingDefined3 : compareDefined2(compare);
+    while (right3 > left3) {
+        if (right3 - left3 > 600) {
+            const n = right3 - left3 + 1;
+            const m5 = k3 - left3 + 1;
+            const z = Math.log(n);
+            const s3 = 0.5 * Math.exp(2 * z / 3);
+            const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m5 - n / 2 < 0 ? -1 : 1);
+            const newLeft = Math.max(left3, Math.floor(k3 - m5 * s3 / n + sd));
+            const newRight = Math.min(right3, Math.floor(k3 + (n - m5) * s3 / n + sd));
+            quickselect2(array7, k3, newLeft, newRight, compare);
+        }
+        const t = array7[k3];
+        let i = left3;
+        let j = right3;
+        swap3(array7, left3, k3);
+        if (compare(array7[right3], t) > 0)
+            swap3(array7, left3, right3);
+        while (i < j) {
+            swap3(array7, i, j), ++i, --j;
+            while (compare(array7[i], t) < 0)
+                ++i;
+            while (compare(array7[j], t) > 0)
+                --j;
+        }
+        if (compare(array7[left3], t) === 0)
+            swap3(array7, left3, j);
+        else
+
+        ++j, swap3(array7, j, right3);
+        if (j <= k3)
+            left3 = j + 1;
+        if (k3 <= j)
+            right3 = j - 1;
+    }
+    return array7;
+}
+
+function swap3(array7, i, j) {
+    const t = array7[i];
+    array7[i] = array7[j];
+    array7[j] = t;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/greatest.js
+function greatest2(values3, compare = ascending3) {
+    let max9;
+    let defined3 = false;
+    if (compare.length === 1) {
+        let maxValue;
+        for (const element of values3) {
+            const value = compare(element);
+            if (defined3 ? ascending3(value, maxValue) > 0 : ascending3(value, value) === 0) {
+                max9 = element;
+                maxValue = value;
+                defined3 = true;
+            }
+        }
+    } else {
+        for (const value of values3) {
+            if (defined3 ? compare(value, max9) > 0 : compare(value, value) === 0) {
+                max9 = value;
+                defined3 = true;
+            }
+        }
+    }
+    return max9;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/quantile.js
+function quantile3(values3, p, valueof3) {
+    values3 = Float64Array.from(numbers2(values3, valueof3));
+    if (!(n = values3.length) || isNaN(p = +p))
+        return;
+    if (p <= 0 || n < 2)
+        return min4(values3);
+    if (p >= 1)
+        return max5(values3);
+    var n, i = (n - 1) * p,
+        i0 = Math.floor(i),
+        value0 = max5(quickselect2(values3, i0).subarray(0, i0 + 1)),
+        value1 = min4(values3.subarray(i0 + 1));
+    return value0 + (value1 - value0) * (i - i0);
+}
+
+function quantileSorted2(values3, p, valueof3 = number7) {
+    if (!(n = values3.length) || isNaN(p = +p))
+        return;
+    if (p <= 0 || n < 2)
+        return +valueof3(values3[0], 0, values3);
+    if (p >= 1)
+        return +valueof3(values3[n - 1], n - 1, values3);
+    var n, i = (n - 1) * p,
+        i0 = Math.floor(i),
+        value0 = +valueof3(values3[i0], i0, values3),
+        value1 = +valueof3(values3[i0 + 1], i0 + 1, values3);
+    return value0 + (value1 - value0) * (i - i0);
+}
+
+function quantileIndex2(values3, p, valueof3) {
+    values3 = Float64Array.from(numbers2(values3, valueof3));
+    if (!(n = values3.length) || isNaN(p = +p))
+        return;
+    if (p <= 0 || n < 2)
+        return minIndex2(values3);
+    if (p >= 1)
+        return maxIndex2(values3);
+    var n, i = Math.floor((n - 1) * p),
+        order = (i2, j) => ascendingDefined3(values3[i2], values3[j]),
+        index5 = quickselect2(Uint32Array.from(values3, (_, i2) => i2), i, 0, n - 1, order);
+    return greatest2(index5.subarray(0, i + 1), (i2) => values3[i2]);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/threshold/freedmanDiaconis.js
+function thresholdFreedmanDiaconis2(values3, min7, max9) {
+    const c11 = count3(values3),
+        d = quantile3(values3, 0.75) - quantile3(values3, 0.25);
+    return c11 && d ? Math.ceil((max9 - min7) / (2 * d * Math.pow(c11, -1 / 3))) : 1;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/threshold/scott.js
+function thresholdScott2(values3, min7, max9) {
+    const c11 = count3(values3),
+        d = deviation2(values3);
+    return c11 && d ? Math.ceil((max9 - min7) * Math.cbrt(c11) / (3.49 * d)) : 1;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/mean.js
+function mean2(values3, valueof3) {
+    let count5 = 0;
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value != null && (value = +value) >= value) {
+                ++count5, sum8 += value;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && (value = +value) >= value) {
+                ++count5, sum8 += value;
+            }
+        }
+    }
+    if (count5)
+        return sum8 / count5;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/median.js
+function median2(values3, valueof3) {
+    return quantile3(values3, 0.5, valueof3);
+}
+
+function medianIndex2(values3, valueof3) {
+    return quantileIndex2(values3, 0.5, valueof3);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/merge.js
+function* flatten4(arrays) {
+    for (const array7 of arrays) {
+        yield* array7;
+    }
+}
+
+function merge2(arrays) {
+    return Array.from(flatten4(arrays));
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/mode.js
+function mode2(values3, valueof3) {
+    const counts = new InternMap2();
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value != null && value >= value) {
+                counts.set(value, (counts.get(value) || 0) + 1);
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if ((value = valueof3(value, ++index5, values3)) != null && value >= value) {
+                counts.set(value, (counts.get(value) || 0) + 1);
+            }
+        }
+    }
+    let modeValue;
+    let modeCount = 0;
+    for (const [value, count5] of counts) {
+        if (count5 > modeCount) {
+            modeCount = count5;
+            modeValue = value;
+        }
+    }
+    return modeValue;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/pairs.js
+function pairs2(values3, pairof = pair2) {
+    const pairs3 = [];
+    let previous;
+    let first3 = false;
+    for (const value of values3) {
+        if (first3)
+            pairs3.push(pairof(previous, value));
+        previous = value;
+        first3 = true;
+    }
+    return pairs3;
+}
+
+function pair2(a7, b) {
+    return [a7, b];
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/range.js
+function range5(start3, stop, step) {
+    start3 = +start3, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start3, start3 = 0, 1) : n < 3 ? 1 : +step;
+    var i = -1,
+        n = Math.max(0, Math.ceil((stop - start3) / step)) | 0,
+        range9 = new Array(n);
+    while (++i < n) {
+        range9[i] = start3 + i * step;
+    }
+    return range9;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/rank.js
+function rank2(values3, valueof3 = ascending3) {
+    if (typeof values3[Symbol.iterator] !== "function")
+        throw new TypeError("values is not iterable");
+    let V = Array.from(values3);
+    const R = new Float64Array(V.length);
+    if (valueof3.length !== 2)
+        V = V.map(valueof3), valueof3 = ascending3;
+    const compareIndex = (i, j) => valueof3(V[i], V[j]);
+    let k3, r;
+    values3 = Uint32Array.from(V, (_, i) => i);
+    values3.sort(valueof3 === ascending3 ? (i, j) => ascendingDefined3(V[i], V[j]) : compareDefined2(compareIndex));
+    values3.forEach((j, i) => {
+        const c11 = compareIndex(j, k3 === void 0 ? j : k3);
+        if (c11 >= 0) {
+            if (k3 === void 0 || c11 > 0)
+                k3 = j, r = i;
+            R[j] = r;
+        } else {
+            R[j] = NaN;
+        }
+    });
+    return R;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/least.js
+function least2(values3, compare = ascending3) {
+    let min7;
+    let defined3 = false;
+    if (compare.length === 1) {
+        let minValue;
+        for (const element of values3) {
+            const value = compare(element);
+            if (defined3 ? ascending3(value, minValue) < 0 : ascending3(value, value) === 0) {
+                min7 = element;
+                minValue = value;
+                defined3 = true;
+            }
+        }
+    } else {
+        for (const value of values3) {
+            if (defined3 ? compare(value, min7) < 0 : compare(value, value) === 0) {
+                min7 = value;
+                defined3 = true;
+            }
+        }
+    }
+    return min7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/leastIndex.js
+function leastIndex2(values3, compare = ascending3) {
+    if (compare.length === 1)
+        return minIndex2(values3, compare);
+    let minValue;
+    let min7 = -1;
+    let index5 = -1;
+    for (const value of values3) {
+        ++index5;
+        if (min7 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
+            minValue = value;
+            min7 = index5;
+        }
+    }
+    return min7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/greatestIndex.js
+function greatestIndex2(values3, compare = ascending3) {
+    if (compare.length === 1)
+        return maxIndex2(values3, compare);
+    let maxValue;
+    let max9 = -1;
+    let index5 = -1;
+    for (const value of values3) {
+        ++index5;
+        if (max9 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
+            maxValue = value;
+            max9 = index5;
+        }
+    }
+    return max9;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/scan.js
+function scan2(values3, compare) {
+    const index5 = leastIndex2(values3, compare);
+    return index5 < 0 ? void 0 : index5;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/shuffle.js
+var shuffle_default2 = shuffler2(Math.random);
+
+function shuffler2(random) {
+    return function shuffle5(array7, i0 = 0, i1 = array7.length) {
+        let m5 = i1 - (i0 = +i0);
+        while (m5) {
+            const i = random() * m5-- | 0,
+                t = array7[m5 + i0];
+            array7[m5 + i0] = array7[i + i0];
+            array7[i + i0] = t;
+        }
+        return array7;
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/sum.js
+function sum4(values3, valueof3) {
+    let sum8 = 0;
+    if (valueof3 === void 0) {
+        for (let value of values3) {
+            if (value = +value) {
+                sum8 += value;
+            }
+        }
+    } else {
+        let index5 = -1;
+        for (let value of values3) {
+            if (value = +valueof3(value, ++index5, values3)) {
+                sum8 += value;
+            }
+        }
+    }
+    return sum8;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/transpose.js
+function transpose2(matrix) {
+    if (!(n = matrix.length))
+        return [];
+    for (var i = -1, m5 = min4(matrix, length5), transpose3 = new Array(m5); ++i < m5;) {
+        for (var j = -1, n, row = transpose3[i] = new Array(n); ++j < n;) {
+            row[j] = matrix[j][i];
+        }
+    }
+    return transpose3;
+}
+
+function length5(d) {
+    return d.length;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/zip.js
+function zip2() {
+    return transpose2(arguments);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/every.js
+function every2(values3, test) {
+    if (typeof test !== "function")
+        throw new TypeError("test is not a function");
+    let index5 = -1;
+    for (const value of values3) {
+        if (!test(value, ++index5, values3)) {
+            return false;
+        }
+    }
+    return true;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/some.js
+function some2(values3, test) {
+    if (typeof test !== "function")
+        throw new TypeError("test is not a function");
+    let index5 = -1;
+    for (const value of values3) {
+        if (test(value, ++index5, values3)) {
+            return true;
+        }
+    }
+    return false;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/filter.js
+function filter4(values3, test) {
+    if (typeof test !== "function")
+        throw new TypeError("test is not a function");
+    const array7 = [];
+    let index5 = -1;
+    for (const value of values3) {
+        if (test(value, ++index5, values3)) {
+            array7.push(value);
+        }
+    }
+    return array7;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/map.js
+function map7(values3, mapper) {
+    if (typeof values3[Symbol.iterator] !== "function")
+        throw new TypeError("values is not iterable");
+    if (typeof mapper !== "function")
+        throw new TypeError("mapper is not a function");
+    return Array.from(values3, (value, index5) => mapper(value, index5, values3));
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/reduce.js
+function reduce2(values3, reducer3, value) {
+    if (typeof reducer3 !== "function")
+        throw new TypeError("reducer is not a function");
+    const iterator = values3[Symbol.iterator]();
+    let done, next, index5 = -1;
+    if (arguments.length < 3) {
+        ({
+            done,
+            value
+        } = iterator.next());
+        if (done)
+            return;
+        ++index5;
+    }
+    while ({
+            done,
+            value: next
+        } = iterator.next(), !done) {
+        value = reducer3(value, next, ++index5, values3);
+    }
+    return value;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/reverse.js
+function reverse3(values3) {
+    if (typeof values3[Symbol.iterator] !== "function")
+        throw new TypeError("values is not iterable");
+    return Array.from(values3).reverse();
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/difference.js
+function difference3(values3, ...others) {
+    values3 = new InternSet2(values3);
+    for (const other of others) {
+        for (const value of other) {
+            values3.delete(value);
+        }
+    }
+    return values3;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/disjoint.js
+function disjoint2(values3, other) {
+    const iterator = other[Symbol.iterator](),
+        set7 = new InternSet2();
+    for (const v3 of values3) {
+        if (set7.has(v3))
+            return false;
+        let value, done;
+        while ({
+                value,
+                done
+            } = iterator.next()) {
+            if (done)
+                break;
+            if (Object.is(v3, value))
+                return false;
+            set7.add(value);
+        }
+    }
+    return true;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/intersection.js
+function intersection2(values3, ...others) {
+    values3 = new InternSet2(values3);
+    others = others.map(set4);
+    out:
+        for (const value of values3) {
+            for (const other of others) {
+                if (!other.has(value)) {
+                    values3.delete(value);
+                    continue out;
+                }
+            }
+        }
+    return values3;
+}
+
+function set4(values3) {
+    return values3 instanceof InternSet2 ? values3 : new InternSet2(values3);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/superset.js
+function superset2(values3, other) {
+    const iterator = values3[Symbol.iterator](),
+        set7 = /* @__PURE__ */ new Set();
+    for (const o of other) {
+        const io = intern2(o);
+        if (set7.has(io))
+            continue;
+        let value, done;
+        while ({
+                value,
+                done
+            } = iterator.next()) {
+            if (done)
+                return false;
+            const ivalue = intern2(value);
+            set7.add(ivalue);
+            if (Object.is(io, ivalue))
+                break;
+        }
+    }
+    return true;
+}
+
+function intern2(value) {
+    return value !== null && typeof value === "object" ? value.valueOf() : value;
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/subset.js
+function subset2(values3, other) {
+    return superset2(other, values3);
+}
+
+// js/pyobsplot-js/node_modules/d3-array/src/union.js
+function union2(...others) {
+    const set7 = new InternSet2();
+    for (const other of others) {
+        for (const o of other) {
+            set7.add(o);
+        }
+    }
+    return set7;
+}
+
+// js/pyobsplot-js/node_modules/d3-axis/src/identity.js
+function identity_default6(x7) {
+    return x7;
+}
+
+// js/pyobsplot-js/node_modules/d3-axis/src/axis.js
+var top2 = 1;
+var right2 = 2;
+var bottom2 = 3;
+var left2 = 4;
+var epsilon9 = 1e-6;
+
+function translateX2(x7) {
+    return "translate(" + x7 + ",0)";
+}
+
+function translateY2(y7) {
+    return "translate(0," + y7 + ")";
+}
+
+function number8(scale5) {
+    return (d) => +scale5(d);
+}
+
+function center2(scale5, offset3) {
+    offset3 = Math.max(0, scale5.bandwidth() - offset3 * 2) / 2;
+    if (scale5.round())
+        offset3 = Math.round(offset3);
+    return (d) => +scale5(d) + offset3;
+}
+
+function entering2() {
+    return !this.__axis;
+}
+
+function axis2(orient, scale5) {
+    var tickArguments = [],
+        tickValues = null,
+        tickFormat3 = null,
+        tickSizeInner = 6,
+        tickSizeOuter = 6,
+        tickPadding = 3,
+        offset3 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
+        k3 = orient === top2 || orient === left2 ? -1 : 1,
+        x7 = orient === left2 || orient === right2 ? "x" : "y",
+        transform3 = orient === top2 || orient === bottom2 ? translateX2 : translateY2;
+
+    function axis3(context) {
+        var values3 = tickValues == null ? scale5.ticks ? scale5.ticks.apply(scale5, tickArguments) : scale5.domain() : tickValues,
+            format5 = tickFormat3 == null ? scale5.tickFormat ? scale5.tickFormat.apply(scale5, tickArguments) : identity_default6 : tickFormat3,
+            spacing = Math.max(tickSizeInner, 0) + tickPadding,
+            range9 = scale5.range(),
+            range0 = +range9[0] + offset3,
+            range1 = +range9[range9.length - 1] + offset3,
+            position3 = (scale5.bandwidth ? center2 : number8)(scale5.copy(), offset3),
+            selection3 = context.selection ? context.selection() : context,
+            path3 = selection3.selectAll(".domain").data([null]),
+            tick = selection3.selectAll(".tick").data(values3, scale5).order(),
+            tickExit = tick.exit(),
+            tickEnter = tick.enter().append("g").attr("class", "tick"),
+            line3 = tick.select("line"),
+            text3 = tick.select("text");
+        path3 = path3.merge(path3.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
+        tick = tick.merge(tickEnter);
+        line3 = line3.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x7 + "2", k3 * tickSizeInner));
+        text3 = text3.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x7, k3 * spacing).attr("dy", orient === top2 ? "0em" : orient === bottom2 ? "0.71em" : "0.32em"));
+        if (context !== selection3) {
+            path3 = path3.transition(context);
+            tick = tick.transition(context);
+            line3 = line3.transition(context);
+            text3 = text3.transition(context);
+            tickExit = tickExit.transition(context).attr("opacity", epsilon9).attr("transform", function(d) {
+                return isFinite(d = position3(d)) ? transform3(d + offset3) : this.getAttribute("transform");
+            });
+            tickEnter.attr("opacity", epsilon9).attr("transform", function(d) {
+                var p = this.parentNode.__axis;
+                return transform3((p && isFinite(p = p(d)) ? p : position3(d)) + offset3);
+            });
+        }
+        tickExit.remove();
+        path3.attr("d", orient === left2 || orient === right2 ? tickSizeOuter ? "M" + k3 * tickSizeOuter + "," + range0 + "H" + offset3 + "V" + range1 + "H" + k3 * tickSizeOuter : "M" + offset3 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k3 * tickSizeOuter + "V" + offset3 + "H" + range1 + "V" + k3 * tickSizeOuter : "M" + range0 + "," + offset3 + "H" + range1);
+        tick.attr("opacity", 1).attr("transform", function(d) {
+            return transform3(position3(d) + offset3);
+        });
+        line3.attr(x7 + "2", k3 * tickSizeInner);
+        text3.attr(x7, k3 * spacing).text(format5);
+        selection3.filter(entering2).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right2 ? "start" : orient === left2 ? "end" : "middle");
+        selection3.each(function() {
+            this.__axis = position3;
+        });
+    }
+    axis3.scale = function(_) {
+        return arguments.length ? (scale5 = _, axis3) : scale5;
+    };
+    axis3.ticks = function() {
+        return tickArguments = Array.from(arguments), axis3;
+    };
+    axis3.tickArguments = function(_) {
+        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis3) : tickArguments.slice();
+    };
+    axis3.tickValues = function(_) {
+        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis3) : tickValues && tickValues.slice();
+    };
+    axis3.tickFormat = function(_) {
+        return arguments.length ? (tickFormat3 = _, axis3) : tickFormat3;
+    };
+    axis3.tickSize = function(_) {
+        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis3) : tickSizeInner;
+    };
+    axis3.tickSizeInner = function(_) {
+        return arguments.length ? (tickSizeInner = +_, axis3) : tickSizeInner;
+    };
+    axis3.tickSizeOuter = function(_) {
+        return arguments.length ? (tickSizeOuter = +_, axis3) : tickSizeOuter;
+    };
+    axis3.tickPadding = function(_) {
+        return arguments.length ? (tickPadding = +_, axis3) : tickPadding;
+    };
+    axis3.offset = function(_) {
+        return arguments.length ? (offset3 = +_, axis3) : offset3;
+    };
+    return axis3;
+}
+
+function axisTop2(scale5) {
+    return axis2(top2, scale5);
+}
+
+function axisRight2(scale5) {
+    return axis2(right2, scale5);
+}
+
+function axisBottom2(scale5) {
+    return axis2(bottom2, scale5);
+}
+
+function axisLeft2(scale5) {
+    return axis2(left2, scale5);
+}
+
+// js/pyobsplot-js/node_modules/d3-dispatch/src/dispatch.js
+var noop3 = {
+    value: () => {}
+};
+
+function dispatch2() {
+    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
+        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
+            throw new Error("illegal type: " + t);
+        _[t] = [];
+    }
+    return new Dispatch2(_);
+}
+
+function Dispatch2(_) {
+    this._ = _;
+}
+
+function parseTypenames3(typenames, types) {
+    return typenames.trim().split(/^|\s+/).map(function(t) {
+        var name = "",
+            i = t.indexOf(".");
+        if (i >= 0)
+            name = t.slice(i + 1), t = t.slice(0, i);
+        if (t && !types.hasOwnProperty(t))
+            throw new Error("unknown type: " + t);
+        return {
+            type: t,
+            name
+        };
+    });
+}
+Dispatch2.prototype = dispatch2.prototype = {
+    constructor: Dispatch2,
+    on: function(typename, callback) {
+        var _ = this._,
+            T = parseTypenames3(typename + "", _),
+            t, i = -1,
+            n = T.length;
+        if (arguments.length < 2) {
+            while (++i < n)
+                if ((t = (typename = T[i]).type) && (t = get3(_[t], typename.name)))
+                    return t;
+            return;
+        }
+        if (callback != null && typeof callback !== "function")
+            throw new Error("invalid callback: " + callback);
+        while (++i < n) {
+            if (t = (typename = T[i]).type)
+                _[t] = set5(_[t], typename.name, callback);
+            else if (callback == null)
+                for (t in _)
+                    _[t] = set5(_[t], typename.name, null);
+        }
+        return this;
+    },
+    copy: function() {
+        var copy5 = {},
+            _ = this._;
+        for (var t in _)
+            copy5[t] = _[t].slice();
+        return new Dispatch2(copy5);
+    },
+    call: function(type3, that) {
+        if ((n = arguments.length - 2) > 0)
+            for (var args = new Array(n), i = 0, n, t; i < n; ++i)
+                args[i] = arguments[i + 2];
+        if (!this._.hasOwnProperty(type3))
+            throw new Error("unknown type: " + type3);
+        for (t = this._[type3], i = 0, n = t.length; i < n; ++i)
+            t[i].value.apply(that, args);
+    },
+    apply: function(type3, that, args) {
+        if (!this._.hasOwnProperty(type3))
+            throw new Error("unknown type: " + type3);
+        for (var t = this._[type3], i = 0, n = t.length; i < n; ++i)
+            t[i].value.apply(that, args);
+    }
+};
+
+function get3(type3, name) {
+    for (var i = 0, n = type3.length, c11; i < n; ++i) {
+        if ((c11 = type3[i]).name === name) {
+            return c11.value;
+        }
+    }
+}
+
+function set5(type3, name, callback) {
+    for (var i = 0, n = type3.length; i < n; ++i) {
+        if (type3[i].name === name) {
+            type3[i] = noop3, type3 = type3.slice(0, i).concat(type3.slice(i + 1));
+            break;
+        }
+    }
+    if (callback != null)
+        type3.push({
+            name,
+            value: callback
+        });
+    return type3;
+}
+var dispatch_default3 = dispatch2;
+
+// js/pyobsplot-js/node_modules/d3-selection/src/namespaces.js
+var xhtml2 = "http://www.w3.org/1999/xhtml";
+var namespaces_default2 = {
+    svg: "http://www.w3.org/2000/svg",
+    xhtml: xhtml2,
+    xlink: "http://www.w3.org/1999/xlink",
+    xml: "http://www.w3.org/XML/1998/namespace",
+    xmlns: "http://www.w3.org/2000/xmlns/"
+};
+
+// js/pyobsplot-js/node_modules/d3-selection/src/namespace.js
+function namespace_default2(name) {
+    var prefix = name += "",
+        i = prefix.indexOf(":");
+    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
+        name = name.slice(i + 1);
+    return namespaces_default2.hasOwnProperty(prefix) ? {
+        space: namespaces_default2[prefix],
+        local: name
+    } : name;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/creator.js
+function creatorInherit2(name) {
+    return function() {
+        var document2 = this.ownerDocument,
+            uri = this.namespaceURI;
+        return uri === xhtml2 && document2.documentElement.namespaceURI === xhtml2 ? document2.createElement(name) : document2.createElementNS(uri, name);
+    };
+}
+
+function creatorFixed2(fullname) {
+    return function() {
+        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
+    };
+}
+
+function creator_default2(name) {
+    var fullname = namespace_default2(name);
+    return (fullname.local ? creatorFixed2 : creatorInherit2)(fullname);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selector.js
+function none2() {}
+
+function selector_default2(selector) {
+    return selector == null ? none2 : function() {
+        return this.querySelector(selector);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/select.js
+function select_default4(select3) {
+    if (typeof select3 !== "function")
+        select3 = selector_default2(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && (subnode = select3.call(node, node.__data__, i, group5))) {
+                if ("__data__" in node)
+                    subnode.__data__ = node.__data__;
+                subgroup[i] = subnode;
+            }
+        }
+    }
+    return new Selection3(subgroups, this._parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/array.js
+function array5(x7) {
+    return x7 == null ? [] : Array.isArray(x7) ? x7 : Array.from(x7);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selectorAll.js
+function empty5() {
+    return [];
+}
+
+function selectorAll_default2(selector) {
+    return selector == null ? empty5 : function() {
+        return this.querySelectorAll(selector);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/selectAll.js
+function arrayAll2(select3) {
+    return function() {
+        return array5(select3.apply(this, arguments));
+    };
+}
+
+function selectAll_default4(select3) {
+    if (typeof select3 === "function")
+        select3 = arrayAll2(select3);
+    else
+        select3 = selectorAll_default2(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = [], parents = [], j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                subgroups.push(select3.call(node, node.__data__, i, group5));
+                parents.push(node);
+            }
+        }
+    }
+    return new Selection3(subgroups, parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/matcher.js
+function matcher_default2(selector) {
+    return function() {
+        return this.matches(selector);
+    };
+}
+
+function childMatcher2(selector) {
+    return function(node) {
+        return node.matches(selector);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/selectChild.js
+var find3 = Array.prototype.find;
+
+function childFind2(match) {
+    return function() {
+        return find3.call(this.children, match);
+    };
+}
+
+function childFirst2() {
+    return this.firstElementChild;
+}
+
+function selectChild_default2(match) {
+    return this.select(match == null ? childFirst2 : childFind2(typeof match === "function" ? match : childMatcher2(match)));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/selectChildren.js
+var filter5 = Array.prototype.filter;
+
+function children2() {
+    return Array.from(this.children);
+}
+
+function childrenFilter2(match) {
+    return function() {
+        return filter5.call(this.children, match);
+    };
+}
+
+function selectChildren_default2(match) {
+    return this.selectAll(match == null ? children2 : childrenFilter2(typeof match === "function" ? match : childMatcher2(match)));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/filter.js
+function filter_default3(match) {
+    if (typeof match !== "function")
+        match = matcher_default2(match);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && match.call(node, node.__data__, i, group5)) {
+                subgroup.push(node);
+            }
+        }
+    }
+    return new Selection3(subgroups, this._parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/sparse.js
+function sparse_default2(update) {
+    return new Array(update.length);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/enter.js
+function enter_default2() {
+    return new Selection3(this._enter || this._groups.map(sparse_default2), this._parents);
+}
+
+function EnterNode2(parent, datum3) {
+    this.ownerDocument = parent.ownerDocument;
+    this.namespaceURI = parent.namespaceURI;
+    this._next = null;
+    this._parent = parent;
+    this.__data__ = datum3;
+}
+EnterNode2.prototype = {
+    constructor: EnterNode2,
+    appendChild: function(child) {
+        return this._parent.insertBefore(child, this._next);
+    },
+    insertBefore: function(child, next) {
+        return this._parent.insertBefore(child, next);
+    },
+    querySelector: function(selector) {
+        return this._parent.querySelector(selector);
+    },
+    querySelectorAll: function(selector) {
+        return this._parent.querySelectorAll(selector);
+    }
+};
+
+// js/pyobsplot-js/node_modules/d3-selection/src/constant.js
+function constant_default12(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/data.js
+function bindIndex2(parent, group5, enter, update, exit, data) {
+    var i = 0,
+        node, groupLength = group5.length,
+        dataLength = data.length;
+    for (; i < dataLength; ++i) {
+        if (node = group5[i]) {
+            node.__data__ = data[i];
+            update[i] = node;
+        } else {
+            enter[i] = new EnterNode2(parent, data[i]);
+        }
+    }
+    for (; i < groupLength; ++i) {
+        if (node = group5[i]) {
+            exit[i] = node;
+        }
+    }
+}
+
+function bindKey2(parent, group5, enter, update, exit, data, key) {
+    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(),
+        groupLength = group5.length,
+        dataLength = data.length,
+        keyValues = new Array(groupLength),
+        keyValue;
+    for (i = 0; i < groupLength; ++i) {
+        if (node = group5[i]) {
+            keyValues[i] = keyValue = key.call(node, node.__data__, i, group5) + "";
+            if (nodeByKeyValue.has(keyValue)) {
+                exit[i] = node;
+            } else {
+                nodeByKeyValue.set(keyValue, node);
+            }
+        }
+    }
+    for (i = 0; i < dataLength; ++i) {
+        keyValue = key.call(parent, data[i], i, data) + "";
+        if (node = nodeByKeyValue.get(keyValue)) {
+            update[i] = node;
+            node.__data__ = data[i];
+            nodeByKeyValue.delete(keyValue);
+        } else {
+            enter[i] = new EnterNode2(parent, data[i]);
+        }
+    }
+    for (i = 0; i < groupLength; ++i) {
+        if ((node = group5[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
+            exit[i] = node;
+        }
+    }
+}
+
+function datum2(node) {
+    return node.__data__;
+}
+
+function data_default3(value, key) {
+    if (!arguments.length)
+        return Array.from(this, datum2);
+    var bind = key ? bindKey2 : bindIndex2,
+        parents = this._parents,
+        groups3 = this._groups;
+    if (typeof value !== "function")
+        value = constant_default12(value);
+    for (var m5 = groups3.length, update = new Array(m5), enter = new Array(m5), exit = new Array(m5), j = 0; j < m5; ++j) {
+        var parent = parents[j],
+            group5 = groups3[j],
+            groupLength = group5.length,
+            data = arraylike2(value.call(parent, parent && parent.__data__, j, parents)),
+            dataLength = data.length,
+            enterGroup = enter[j] = new Array(dataLength),
+            updateGroup = update[j] = new Array(dataLength),
+            exitGroup = exit[j] = new Array(groupLength);
+        bind(parent, group5, enterGroup, updateGroup, exitGroup, data, key);
+        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
+            if (previous = enterGroup[i0]) {
+                if (i0 >= i1)
+                    i1 = i0 + 1;
+                while (!(next = updateGroup[i1]) && ++i1 < dataLength)
+                ;
+                previous._next = next || null;
+            }
+        }
+    }
+    update = new Selection3(update, parents);
+    update._enter = enter;
+    update._exit = exit;
+    return update;
+}
+
+function arraylike2(data) {
+    return typeof data === "object" && "length" in data ? data : Array.from(data);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/exit.js
+function exit_default2() {
+    return new Selection3(this._exit || this._groups.map(sparse_default2), this._parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/join.js
+function join_default2(onenter, onupdate, onexit) {
+    var enter = this.enter(),
+        update = this,
+        exit = this.exit();
+    if (typeof onenter === "function") {
+        enter = onenter(enter);
+        if (enter)
+            enter = enter.selection();
+    } else {
+        enter = enter.append(onenter + "");
+    }
+    if (onupdate != null) {
+        update = onupdate(update);
+        if (update)
+            update = update.selection();
+    }
+    if (onexit == null)
+        exit.remove();
+    else
+        onexit(exit);
+    return enter && update ? enter.merge(update).order() : update;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/merge.js
+function merge_default3(context) {
+    var selection3 = context.selection ? context.selection() : context;
+    for (var groups0 = this._groups, groups1 = selection3._groups, m0 = groups0.length, m1 = groups1.length, m5 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m5; ++j) {
+        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+            if (node = group0[i] || group1[i]) {
+                merge3[i] = node;
+            }
+        }
+    }
+    for (; j < m0; ++j) {
+        merges[j] = groups0[j];
+    }
+    return new Selection3(merges, this._parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/order.js
+function order_default2() {
+    for (var groups3 = this._groups, j = -1, m5 = groups3.length; ++j < m5;) {
+        for (var group5 = groups3[j], i = group5.length - 1, next = group5[i], node; --i >= 0;) {
+            if (node = group5[i]) {
+                if (next && node.compareDocumentPosition(next) ^ 4)
+                    next.parentNode.insertBefore(node, next);
+                next = node;
+            }
+        }
+    }
+    return this;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/sort.js
+function sort_default3(compare) {
+    if (!compare)
+        compare = ascending4;
+
+    function compareNode(a7, b) {
+        return a7 && b ? compare(a7.__data__, b.__data__) : !a7 - !b;
+    }
+    for (var groups3 = this._groups, m5 = groups3.length, sortgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                sortgroup[i] = node;
+            }
+        }
+        sortgroup.sort(compareNode);
+    }
+    return new Selection3(sortgroups, this._parents).order();
+}
+
+function ascending4(a7, b) {
+    return a7 < b ? -1 : a7 > b ? 1 : a7 >= b ? 0 : NaN;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/call.js
+function call_default2() {
+    var callback = arguments[0];
+    arguments[0] = this;
+    callback.apply(null, arguments);
+    return this;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/nodes.js
+function nodes_default2() {
+    return Array.from(this);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/node.js
+function node_default2() {
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length; i < n; ++i) {
+            var node = group5[i];
+            if (node)
+                return node;
+        }
+    }
+    return null;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/size.js
+function size_default3() {
+    let size = 0;
+    for (const node of this)
+        ++size;
+    return size;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/empty.js
+function empty_default2() {
+    return !this.node();
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/each.js
+function each_default3(callback) {
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length, node; i < n; ++i) {
+            if (node = group5[i])
+                callback.call(node, node.__data__, i, group5);
+        }
+    }
+    return this;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/attr.js
+function attrRemove3(name) {
+    return function() {
+        this.removeAttribute(name);
+    };
+}
+
+function attrRemoveNS3(fullname) {
+    return function() {
+        this.removeAttributeNS(fullname.space, fullname.local);
+    };
+}
+
+function attrConstant3(name, value) {
+    return function() {
+        this.setAttribute(name, value);
+    };
+}
+
+function attrConstantNS3(fullname, value) {
+    return function() {
+        this.setAttributeNS(fullname.space, fullname.local, value);
+    };
+}
+
+function attrFunction3(name, value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
+            this.removeAttribute(name);
+        else
+            this.setAttribute(name, v3);
+    };
+}
+
+function attrFunctionNS3(fullname, value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
+            this.removeAttributeNS(fullname.space, fullname.local);
+        else
+            this.setAttributeNS(fullname.space, fullname.local, v3);
+    };
+}
+
+function attr_default3(name, value) {
+    var fullname = namespace_default2(name);
+    if (arguments.length < 2) {
+        var node = this.node();
+        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
+    }
+    return this.each((value == null ? fullname.local ? attrRemoveNS3 : attrRemove3 : typeof value === "function" ? fullname.local ? attrFunctionNS3 : attrFunction3 : fullname.local ? attrConstantNS3 : attrConstant3)(fullname, value));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/window.js
+function window_default2(node) {
+    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/style.js
+function styleRemove3(name) {
+    return function() {
+        this.style.removeProperty(name);
+    };
+}
+
+function styleConstant3(name, value, priority) {
+    return function() {
+        this.style.setProperty(name, value, priority);
+    };
+}
+
+function styleFunction3(name, value, priority) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
+            this.style.removeProperty(name);
+        else
+            this.style.setProperty(name, v3, priority);
+    };
+}
+
+function style_default3(name, value, priority) {
+    return arguments.length > 1 ? this.each((value == null ? styleRemove3 : typeof value === "function" ? styleFunction3 : styleConstant3)(name, value, priority == null ? "" : priority)) : styleValue2(this.node(), name);
+}
+
+function styleValue2(node, name) {
+    return node.style.getPropertyValue(name) || window_default2(node).getComputedStyle(node, null).getPropertyValue(name);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/property.js
+function propertyRemove2(name) {
+    return function() {
+        delete this[name];
+    };
+}
+
+function propertyConstant2(name, value) {
+    return function() {
+        this[name] = value;
+    };
+}
+
+function propertyFunction2(name, value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        if (v3 == null)
+            delete this[name];
+        else
+            this[name] = v3;
+    };
+}
+
+function property_default2(name, value) {
+    return arguments.length > 1 ? this.each((value == null ? propertyRemove2 : typeof value === "function" ? propertyFunction2 : propertyConstant2)(name, value)) : this.node()[name];
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/classed.js
+function classArray2(string3) {
+    return string3.trim().split(/^|\s+/);
+}
+
+function classList2(node) {
+    return node.classList || new ClassList2(node);
+}
+
+function ClassList2(node) {
+    this._node = node;
+    this._names = classArray2(node.getAttribute("class") || "");
+}
+ClassList2.prototype = {
+    add: function(name) {
+        var i = this._names.indexOf(name);
+        if (i < 0) {
+            this._names.push(name);
+            this._node.setAttribute("class", this._names.join(" "));
+        }
+    },
+    remove: function(name) {
+        var i = this._names.indexOf(name);
+        if (i >= 0) {
+            this._names.splice(i, 1);
+            this._node.setAttribute("class", this._names.join(" "));
+        }
+    },
+    contains: function(name) {
+        return this._names.indexOf(name) >= 0;
+    }
+};
+
+function classedAdd2(node, names) {
+    var list = classList2(node),
+        i = -1,
+        n = names.length;
+    while (++i < n)
+        list.add(names[i]);
+}
+
+function classedRemove2(node, names) {
+    var list = classList2(node),
+        i = -1,
+        n = names.length;
+    while (++i < n)
+        list.remove(names[i]);
+}
+
+function classedTrue2(names) {
+    return function() {
+        classedAdd2(this, names);
+    };
+}
+
+function classedFalse2(names) {
+    return function() {
+        classedRemove2(this, names);
+    };
+}
+
+function classedFunction2(names, value) {
+    return function() {
+        (value.apply(this, arguments) ? classedAdd2 : classedRemove2)(this, names);
+    };
+}
+
+function classed_default2(name, value) {
+    var names = classArray2(name + "");
+    if (arguments.length < 2) {
+        var list = classList2(this.node()),
+            i = -1,
+            n = names.length;
+        while (++i < n)
+            if (!list.contains(names[i]))
+                return false;
+        return true;
+    }
+    return this.each((typeof value === "function" ? classedFunction2 : value ? classedTrue2 : classedFalse2)(names, value));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/text.js
+function textRemove2() {
+    this.textContent = "";
+}
+
+function textConstant3(value) {
+    return function() {
+        this.textContent = value;
+    };
+}
+
+function textFunction3(value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        this.textContent = v3 == null ? "" : v3;
+    };
+}
+
+function text_default4(value) {
+    return arguments.length ? this.each(value == null ? textRemove2 : (typeof value === "function" ? textFunction3 : textConstant3)(value)) : this.node().textContent;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/html.js
+function htmlRemove2() {
+    this.innerHTML = "";
+}
+
+function htmlConstant2(value) {
+    return function() {
+        this.innerHTML = value;
+    };
+}
+
+function htmlFunction2(value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        this.innerHTML = v3 == null ? "" : v3;
+    };
+}
+
+function html_default2(value) {
+    return arguments.length ? this.each(value == null ? htmlRemove2 : (typeof value === "function" ? htmlFunction2 : htmlConstant2)(value)) : this.node().innerHTML;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/raise.js
+function raise2() {
+    if (this.nextSibling)
+        this.parentNode.appendChild(this);
+}
+
+function raise_default2() {
+    return this.each(raise2);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/lower.js
+function lower2() {
+    if (this.previousSibling)
+        this.parentNode.insertBefore(this, this.parentNode.firstChild);
+}
+
+function lower_default2() {
+    return this.each(lower2);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/append.js
+function append_default2(name) {
+    var create5 = typeof name === "function" ? name : creator_default2(name);
+    return this.select(function() {
+        return this.appendChild(create5.apply(this, arguments));
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/insert.js
+function constantNull2() {
+    return null;
+}
+
+function insert_default2(name, before) {
+    var create5 = typeof name === "function" ? name : creator_default2(name),
+        select3 = before == null ? constantNull2 : typeof before === "function" ? before : selector_default2(before);
+    return this.select(function() {
+        return this.insertBefore(create5.apply(this, arguments), select3.apply(this, arguments) || null);
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/remove.js
+function remove2() {
+    var parent = this.parentNode;
+    if (parent)
+        parent.removeChild(this);
+}
+
+function remove_default4() {
+    return this.each(remove2);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/clone.js
+function selection_cloneShallow2() {
+    var clone = this.cloneNode(false),
+        parent = this.parentNode;
+    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
+}
+
+function selection_cloneDeep2() {
+    var clone = this.cloneNode(true),
+        parent = this.parentNode;
+    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
+}
+
+function clone_default2(deep) {
+    return this.select(deep ? selection_cloneDeep2 : selection_cloneShallow2);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/datum.js
+function datum_default2(value) {
+    return arguments.length ? this.property("__data__", value) : this.node().__data__;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/on.js
+function contextListener2(listener) {
+    return function(event) {
+        listener.call(this, event, this.__data__);
+    };
+}
+
+function parseTypenames4(typenames) {
+    return typenames.trim().split(/^|\s+/).map(function(t) {
+        var name = "",
+            i = t.indexOf(".");
+        if (i >= 0)
+            name = t.slice(i + 1), t = t.slice(0, i);
+        return {
+            type: t,
+            name
+        };
+    });
+}
+
+function onRemove2(typename) {
+    return function() {
+        var on = this.__on;
+        if (!on)
+            return;
+        for (var j = 0, i = -1, m5 = on.length, o; j < m5; ++j) {
+            if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
+                this.removeEventListener(o.type, o.listener, o.options);
+            } else {
+                on[++i] = o;
+            }
+        }
+        if (++i)
+            on.length = i;
+        else
+            delete this.__on;
+    };
+}
+
+function onAdd2(typename, value, options) {
+    return function() {
+        var on = this.__on,
+            o, listener = contextListener2(value);
+        if (on)
+            for (var j = 0, m5 = on.length; j < m5; ++j) {
+                if ((o = on[j]).type === typename.type && o.name === typename.name) {
+                    this.removeEventListener(o.type, o.listener, o.options);
+                    this.addEventListener(o.type, o.listener = listener, o.options = options);
+                    o.value = value;
+                    return;
+                }
+            }
+        this.addEventListener(typename.type, listener, options);
+        o = {
+            type: typename.type,
+            name: typename.name,
+            value,
+            listener,
+            options
+        };
+        if (!on)
+            this.__on = [o];
+        else
+            on.push(o);
+    };
+}
+
+function on_default3(typename, value, options) {
+    var typenames = parseTypenames4(typename + ""),
+        i, n = typenames.length,
+        t;
+    if (arguments.length < 2) {
+        var on = this.node().__on;
+        if (on)
+            for (var j = 0, m5 = on.length, o; j < m5; ++j) {
+                for (i = 0, o = on[j]; i < n; ++i) {
+                    if ((t = typenames[i]).type === o.type && t.name === o.name) {
+                        return o.value;
+                    }
+                }
+            }
+        return;
+    }
+    on = value ? onAdd2 : onRemove2;
+    for (i = 0; i < n; ++i)
+        this.each(on(typenames[i], value, options));
+    return this;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/dispatch.js
+function dispatchEvent2(node, type3, params) {
+    var window4 = window_default2(node),
+        event = window4.CustomEvent;
+    if (typeof event === "function") {
+        event = new event(type3, params);
+    } else {
+        event = window4.document.createEvent("Event");
+        if (params)
+            event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
+        else
+            event.initEvent(type3, false, false);
+    }
+    node.dispatchEvent(event);
+}
+
+function dispatchConstant2(type3, params) {
+    return function() {
+        return dispatchEvent2(this, type3, params);
+    };
+}
+
+function dispatchFunction2(type3, params) {
+    return function() {
+        return dispatchEvent2(this, type3, params.apply(this, arguments));
+    };
+}
+
+function dispatch_default4(type3, params) {
+    return this.each((typeof params === "function" ? dispatchFunction2 : dispatchConstant2)(type3, params));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/iterator.js
+function* iterator_default3() {
+    for (var groups3 = this._groups, j = 0, m5 = groups3.length; j < m5; ++j) {
+        for (var group5 = groups3[j], i = 0, n = group5.length, node; i < n; ++i) {
+            if (node = group5[i])
+                yield node;
+        }
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selection/index.js
+var root3 = [null];
+
+function Selection3(groups3, parents) {
+    this._groups = groups3;
+    this._parents = parents;
+}
+
+function selection2() {
+    return new Selection3([
+        [document.documentElement]
+    ], root3);
+}
+
+function selection_selection2() {
+    return this;
+}
+Selection3.prototype = selection2.prototype = {
+    constructor: Selection3,
+    select: select_default4,
+    selectAll: selectAll_default4,
+    selectChild: selectChild_default2,
+    selectChildren: selectChildren_default2,
+    filter: filter_default3,
+    data: data_default3,
+    enter: enter_default2,
+    exit: exit_default2,
+    join: join_default2,
+    merge: merge_default3,
+    selection: selection_selection2,
+    order: order_default2,
+    sort: sort_default3,
+    call: call_default2,
+    nodes: nodes_default2,
+    node: node_default2,
+    size: size_default3,
+    empty: empty_default2,
+    each: each_default3,
+    attr: attr_default3,
+    style: style_default3,
+    property: property_default2,
+    classed: classed_default2,
+    text: text_default4,
+    html: html_default2,
+    raise: raise_default2,
+    lower: lower_default2,
+    append: append_default2,
+    insert: insert_default2,
+    remove: remove_default4,
+    clone: clone_default2,
+    datum: datum_default2,
+    on: on_default3,
+    dispatch: dispatch_default4,
+    [Symbol.iterator]: iterator_default3
+};
+var selection_default3 = selection2;
+
+// js/pyobsplot-js/node_modules/d3-selection/src/select.js
+function select_default5(selector) {
+    return typeof selector === "string" ? new Selection3([
+        [document.querySelector(selector)]
+    ], [document.documentElement]) : new Selection3([
+        [selector]
+    ], root3);
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/create.js
+function create_default2(name) {
+    return select_default5(creator_default2(name).call(document.documentElement));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/local.js
+var nextId2 = 0;
+
+function local3() {
+    return new Local2();
+}
+
+function Local2() {
+    this._ = "@" + (++nextId2).toString(36);
+}
+Local2.prototype = local3.prototype = {
+    constructor: Local2,
+    get: function(node) {
+        var id3 = this._;
+        while (!(id3 in node))
+            if (!(node = node.parentNode))
+                return;
+        return node[id3];
+    },
+    set: function(node, value) {
+        return node[this._] = value;
+    },
+    remove: function(node) {
+        return this._ in node && delete node[this._];
+    },
+    toString: function() {
+        return this._;
+    }
+};
+
+// js/pyobsplot-js/node_modules/d3-selection/src/sourceEvent.js
+function sourceEvent_default2(event) {
+    let sourceEvent;
+    while (sourceEvent = event.sourceEvent)
+        event = sourceEvent;
+    return event;
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/pointer.js
+function pointer_default2(event, node) {
+    event = sourceEvent_default2(event);
+    if (node === void 0)
+        node = event.currentTarget;
+    if (node) {
+        var svg3 = node.ownerSVGElement || node;
+        if (svg3.createSVGPoint) {
+            var point11 = svg3.createSVGPoint();
+            point11.x = event.clientX, point11.y = event.clientY;
+            point11 = point11.matrixTransform(node.getScreenCTM().inverse());
+            return [point11.x, point11.y];
+        }
+        if (node.getBoundingClientRect) {
+            var rect3 = node.getBoundingClientRect();
+            return [event.clientX - rect3.left - node.clientLeft, event.clientY - rect3.top - node.clientTop];
+        }
+    }
+    return [event.pageX, event.pageY];
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/pointers.js
+function pointers_default2(events, node) {
+    if (events.target) {
+        events = sourceEvent_default2(events);
+        if (node === void 0)
+            node = events.currentTarget;
+        events = events.touches || [events];
+    }
+    return Array.from(events, (event) => pointer_default2(event, node));
+}
+
+// js/pyobsplot-js/node_modules/d3-selection/src/selectAll.js
+function selectAll_default5(selector) {
+    return typeof selector === "string" ? new Selection3([document.querySelectorAll(selector)], [document.documentElement]) : new Selection3([array5(selector)], root3);
+}
+
+// js/pyobsplot-js/node_modules/d3-drag/src/noevent.js
+var nonpassive2 = {
+    passive: false
+};
+var nonpassivecapture2 = {
+    capture: true,
+    passive: false
+};
+
+function nopropagation4(event) {
+    event.stopImmediatePropagation();
+}
+
+function noevent_default4(event) {
+    event.preventDefault();
+    event.stopImmediatePropagation();
+}
+
+// js/pyobsplot-js/node_modules/d3-drag/src/nodrag.js
+function nodrag_default2(view) {
+    var root5 = view.document.documentElement,
+        selection3 = select_default5(view).on("dragstart.drag", noevent_default4, nonpassivecapture2);
+    if ("onselectstart" in root5) {
+        selection3.on("selectstart.drag", noevent_default4, nonpassivecapture2);
+    } else {
+        root5.__noselect = root5.style.MozUserSelect;
+        root5.style.MozUserSelect = "none";
+    }
+}
+
+function yesdrag2(view, noclick) {
+    var root5 = view.document.documentElement,
+        selection3 = select_default5(view).on("dragstart.drag", null);
+    if (noclick) {
+        selection3.on("click.drag", noevent_default4, nonpassivecapture2);
+        setTimeout(function() {
+            selection3.on("click.drag", null);
+        }, 0);
+    }
+    if ("onselectstart" in root5) {
+        selection3.on("selectstart.drag", null);
+    } else {
+        root5.style.MozUserSelect = root5.__noselect;
+        delete root5.__noselect;
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-drag/src/constant.js
+var constant_default13 = (x7) => () => x7;
+
+// js/pyobsplot-js/node_modules/d3-drag/src/event.js
+function DragEvent2(type3, {
+    sourceEvent,
+    subject,
+    target,
+    identifier,
+    active,
+    x: x7,
+    y: y7,
+    dx,
+    dy,
+    dispatch: dispatch3
+}) {
+    Object.defineProperties(this, {
+        type: {
+            value: type3,
+            enumerable: true,
+            configurable: true
+        },
+        sourceEvent: {
+            value: sourceEvent,
+            enumerable: true,
+            configurable: true
+        },
+        subject: {
+            value: subject,
+            enumerable: true,
+            configurable: true
+        },
+        target: {
+            value: target,
+            enumerable: true,
+            configurable: true
+        },
+        identifier: {
+            value: identifier,
+            enumerable: true,
+            configurable: true
+        },
+        active: {
+            value: active,
+            enumerable: true,
+            configurable: true
+        },
+        x: {
+            value: x7,
+            enumerable: true,
+            configurable: true
+        },
+        y: {
+            value: y7,
+            enumerable: true,
+            configurable: true
+        },
+        dx: {
+            value: dx,
+            enumerable: true,
+            configurable: true
+        },
+        dy: {
+            value: dy,
+            enumerable: true,
+            configurable: true
+        },
+        _: {
+            value: dispatch3
+        }
+    });
+}
+DragEvent2.prototype.on = function() {
+    var value = this._.on.apply(this._, arguments);
+    return value === this._ ? this : value;
+};
+
+// js/pyobsplot-js/node_modules/d3-drag/src/drag.js
+function defaultFilter4(event) {
+    return !event.ctrlKey && !event.button;
+}
+
+function defaultContainer2() {
+    return this.parentNode;
+}
+
+function defaultSubject2(event, d) {
+    return d == null ? {
+        x: event.x,
+        y: event.y
+    } : d;
+}
+
+function defaultTouchable4() {
+    return navigator.maxTouchPoints || "ontouchstart" in this;
+}
+
+function drag_default2() {
+    var filter7 = defaultFilter4,
+        container = defaultContainer2,
+        subject = defaultSubject2,
+        touchable = defaultTouchable4,
+        gestures = {},
+        listeners = dispatch_default3("start", "drag", "end"),
+        active = 0,
+        mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
+
+    function drag(selection3) {
+        selection3.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive2).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+    }
+
+    function mousedowned(event, d) {
+        if (touchending || !filter7.call(this, event, d))
+            return;
+        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
+        if (!gesture)
+            return;
+        select_default5(event.view).on("mousemove.drag", mousemoved, nonpassivecapture2).on("mouseup.drag", mouseupped, nonpassivecapture2);
+        nodrag_default2(event.view);
+        nopropagation4(event);
+        mousemoving = false;
+        mousedownx = event.clientX;
+        mousedowny = event.clientY;
+        gesture("start", event);
+    }
+
+    function mousemoved(event) {
+        noevent_default4(event);
+        if (!mousemoving) {
+            var dx = event.clientX - mousedownx,
+                dy = event.clientY - mousedowny;
+            mousemoving = dx * dx + dy * dy > clickDistance2;
+        }
+        gestures.mouse("drag", event);
+    }
+
+    function mouseupped(event) {
+        select_default5(event.view).on("mousemove.drag mouseup.drag", null);
+        yesdrag2(event.view, mousemoving);
+        noevent_default4(event);
+        gestures.mouse("end", event);
+    }
+
+    function touchstarted(event, d) {
+        if (!filter7.call(this, event, d))
+            return;
+        var touches = event.changedTouches,
+            c11 = container.call(this, event, d),
+            n = touches.length,
+            i, gesture;
+        for (i = 0; i < n; ++i) {
+            if (gesture = beforestart(this, c11, event, d, touches[i].identifier, touches[i])) {
+                nopropagation4(event);
+                gesture("start", event, touches[i]);
+            }
+        }
+    }
+
+    function touchmoved(event) {
+        var touches = event.changedTouches,
+            n = touches.length,
+            i, gesture;
+        for (i = 0; i < n; ++i) {
+            if (gesture = gestures[touches[i].identifier]) {
+                noevent_default4(event);
+                gesture("drag", event, touches[i]);
+            }
+        }
+    }
+
+    function touchended(event) {
+        var touches = event.changedTouches,
+            n = touches.length,
+            i, gesture;
+        if (touchending)
+            clearTimeout(touchending);
+        touchending = setTimeout(function() {
+            touchending = null;
+        }, 500);
+        for (i = 0; i < n; ++i) {
+            if (gesture = gestures[touches[i].identifier]) {
+                nopropagation4(event);
+                gesture("end", event, touches[i]);
+            }
+        }
+    }
+
+    function beforestart(that, container2, event, d, identifier, touch) {
+        var dispatch3 = listeners.copy(),
+            p = pointer_default2(touch || event, container2),
+            dx, dy, s3;
+        if ((s3 = subject.call(that, new DragEvent2("beforestart", {
+                sourceEvent: event,
+                target: drag,
+                identifier,
+                active,
+                x: p[0],
+                y: p[1],
+                dx: 0,
+                dy: 0,
+                dispatch: dispatch3
+            }), d)) == null)
+            return;
+        dx = s3.x - p[0] || 0;
+        dy = s3.y - p[1] || 0;
+        return function gesture(type3, event2, touch2) {
+            var p03 = p,
+                n;
+            switch (type3) {
+                case "start":
+                    gestures[identifier] = gesture, n = active++;
+                    break;
+                case "end":
+                    delete gestures[identifier], --active;
+                case "drag":
+                    p = pointer_default2(touch2 || event2, container2), n = active;
+                    break;
+            }
+            dispatch3.call(
+                type3,
+                that,
+                new DragEvent2(type3, {
+                    sourceEvent: event2,
+                    subject: s3,
+                    target: drag,
+                    identifier,
+                    active: n,
+                    x: p[0] + dx,
+                    y: p[1] + dy,
+                    dx: p[0] - p03[0],
+                    dy: p[1] - p03[1],
+                    dispatch: dispatch3
+                }),
+                d
+            );
+        };
+    }
+    drag.filter = function(_) {
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default13(!!_), drag) : filter7;
+    };
+    drag.container = function(_) {
+        return arguments.length ? (container = typeof _ === "function" ? _ : constant_default13(_), drag) : container;
+    };
+    drag.subject = function(_) {
+        return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default13(_), drag) : subject;
+    };
+    drag.touchable = function(_) {
+        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default13(!!_), drag) : touchable;
+    };
+    drag.on = function() {
+        var value = listeners.on.apply(listeners, arguments);
+        return value === listeners ? drag : value;
+    };
+    drag.clickDistance = function(_) {
+        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
+    };
+    return drag;
+}
+
+// js/pyobsplot-js/node_modules/d3-color/src/define.js
+function define_default2(constructor, factory, prototype) {
+    constructor.prototype = factory.prototype = prototype;
+    prototype.constructor = constructor;
+}
+
+function extend2(parent, definition) {
+    var prototype = Object.create(parent.prototype);
+    for (var key in definition)
+        prototype[key] = definition[key];
+    return prototype;
+}
+
+// js/pyobsplot-js/node_modules/d3-color/src/color.js
+function Color2() {}
+var darker2 = 0.7;
+var brighter2 = 1 / darker2;
+var reI2 = "\\s*([+-]?\\d+)\\s*";
+var reN2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
+var reP2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
+var reHex2 = /^#([0-9a-f]{3,8})$/;
+var reRgbInteger2 = new RegExp(`^rgb\\(${reI2},${reI2},${reI2}\\)$`);
+var reRgbPercent2 = new RegExp(`^rgb\\(${reP2},${reP2},${reP2}\\)$`);
+var reRgbaInteger2 = new RegExp(`^rgba\\(${reI2},${reI2},${reI2},${reN2}\\)$`);
+var reRgbaPercent2 = new RegExp(`^rgba\\(${reP2},${reP2},${reP2},${reN2}\\)$`);
+var reHslPercent2 = new RegExp(`^hsl\\(${reN2},${reP2},${reP2}\\)$`);
+var reHslaPercent2 = new RegExp(`^hsla\\(${reN2},${reP2},${reP2},${reN2}\\)$`);
+var named3 = {
+    aliceblue: 15792383,
+    antiquewhite: 16444375,
+    aqua: 65535,
+    aquamarine: 8388564,
+    azure: 15794175,
+    beige: 16119260,
+    bisque: 16770244,
+    black: 0,
+    blanchedalmond: 16772045,
+    blue: 255,
+    blueviolet: 9055202,
+    brown: 10824234,
+    burlywood: 14596231,
+    cadetblue: 6266528,
+    chartreuse: 8388352,
+    chocolate: 13789470,
+    coral: 16744272,
+    cornflowerblue: 6591981,
+    cornsilk: 16775388,
+    crimson: 14423100,
+    cyan: 65535,
+    darkblue: 139,
+    darkcyan: 35723,
+    darkgoldenrod: 12092939,
+    darkgray: 11119017,
+    darkgreen: 25600,
+    darkgrey: 11119017,
+    darkkhaki: 12433259,
+    darkmagenta: 9109643,
+    darkolivegreen: 5597999,
+    darkorange: 16747520,
+    darkorchid: 10040012,
+    darkred: 9109504,
+    darksalmon: 15308410,
+    darkseagreen: 9419919,
+    darkslateblue: 4734347,
+    darkslategray: 3100495,
+    darkslategrey: 3100495,
+    darkturquoise: 52945,
+    darkviolet: 9699539,
+    deeppink: 16716947,
+    deepskyblue: 49151,
+    dimgray: 6908265,
+    dimgrey: 6908265,
+    dodgerblue: 2003199,
+    firebrick: 11674146,
+    floralwhite: 16775920,
+    forestgreen: 2263842,
+    fuchsia: 16711935,
+    gainsboro: 14474460,
+    ghostwhite: 16316671,
+    gold: 16766720,
+    goldenrod: 14329120,
+    gray: 8421504,
+    green: 32768,
+    greenyellow: 11403055,
+    grey: 8421504,
+    honeydew: 15794160,
+    hotpink: 16738740,
+    indianred: 13458524,
+    indigo: 4915330,
+    ivory: 16777200,
+    khaki: 15787660,
+    lavender: 15132410,
+    lavenderblush: 16773365,
+    lawngreen: 8190976,
+    lemonchiffon: 16775885,
+    lightblue: 11393254,
+    lightcoral: 15761536,
+    lightcyan: 14745599,
+    lightgoldenrodyellow: 16448210,
+    lightgray: 13882323,
+    lightgreen: 9498256,
+    lightgrey: 13882323,
+    lightpink: 16758465,
+    lightsalmon: 16752762,
+    lightseagreen: 2142890,
+    lightskyblue: 8900346,
+    lightslategray: 7833753,
+    lightslategrey: 7833753,
+    lightsteelblue: 11584734,
+    lightyellow: 16777184,
+    lime: 65280,
+    limegreen: 3329330,
+    linen: 16445670,
+    magenta: 16711935,
+    maroon: 8388608,
+    mediumaquamarine: 6737322,
+    mediumblue: 205,
+    mediumorchid: 12211667,
+    mediumpurple: 9662683,
+    mediumseagreen: 3978097,
+    mediumslateblue: 8087790,
+    mediumspringgreen: 64154,
+    mediumturquoise: 4772300,
+    mediumvioletred: 13047173,
+    midnightblue: 1644912,
+    mintcream: 16121850,
+    mistyrose: 16770273,
+    moccasin: 16770229,
+    navajowhite: 16768685,
+    navy: 128,
+    oldlace: 16643558,
+    olive: 8421376,
+    olivedrab: 7048739,
+    orange: 16753920,
+    orangered: 16729344,
+    orchid: 14315734,
+    palegoldenrod: 15657130,
+    palegreen: 10025880,
+    paleturquoise: 11529966,
+    palevioletred: 14381203,
+    papayawhip: 16773077,
+    peachpuff: 16767673,
+    peru: 13468991,
+    pink: 16761035,
+    plum: 14524637,
+    powderblue: 11591910,
+    purple: 8388736,
+    rebeccapurple: 6697881,
+    red: 16711680,
+    rosybrown: 12357519,
+    royalblue: 4286945,
+    saddlebrown: 9127187,
+    salmon: 16416882,
+    sandybrown: 16032864,
+    seagreen: 3050327,
+    seashell: 16774638,
+    sienna: 10506797,
+    silver: 12632256,
+    skyblue: 8900331,
+    slateblue: 6970061,
+    slategray: 7372944,
+    slategrey: 7372944,
+    snow: 16775930,
+    springgreen: 65407,
+    steelblue: 4620980,
+    tan: 13808780,
+    teal: 32896,
+    thistle: 14204888,
+    tomato: 16737095,
+    turquoise: 4251856,
+    violet: 15631086,
+    wheat: 16113331,
+    white: 16777215,
+    whitesmoke: 16119285,
+    yellow: 16776960,
+    yellowgreen: 10145074
+};
+define_default2(Color2, color3, {
+    copy(channels) {
+        return Object.assign(new this.constructor(), this, channels);
+    },
+    displayable() {
+        return this.rgb().displayable();
+    },
+    hex: color_formatHex2,
+    // Deprecated! Use color.formatHex.
+    formatHex: color_formatHex2,
+    formatHex8: color_formatHex82,
+    formatHsl: color_formatHsl2,
+    formatRgb: color_formatRgb2,
+    toString: color_formatRgb2
+});
+
+function color_formatHex2() {
+    return this.rgb().formatHex();
+}
+
+function color_formatHex82() {
+    return this.rgb().formatHex8();
+}
+
+function color_formatHsl2() {
+    return hslConvert2(this).formatHsl();
+}
+
+function color_formatRgb2() {
+    return this.rgb().formatRgb();
+}
+
+function color3(format5) {
+    var m5, l;
+    format5 = (format5 + "").trim().toLowerCase();
+    return (m5 = reHex2.exec(format5)) ? (l = m5[1].length, m5 = parseInt(m5[1], 16), l === 6 ? rgbn2(m5) : l === 3 ? new Rgb2(m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, (m5 & 15) << 4 | m5 & 15, 1) : l === 8 ? rgba2(m5 >> 24 & 255, m5 >> 16 & 255, m5 >> 8 & 255, (m5 & 255) / 255) : l === 4 ? rgba2(m5 >> 12 & 15 | m5 >> 8 & 240, m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, ((m5 & 15) << 4 | m5 & 15) / 255) : null) : (m5 = reRgbInteger2.exec(format5)) ? new Rgb2(m5[1], m5[2], m5[3], 1) : (m5 = reRgbPercent2.exec(format5)) ? new Rgb2(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, 1) : (m5 = reRgbaInteger2.exec(format5)) ? rgba2(m5[1], m5[2], m5[3], m5[4]) : (m5 = reRgbaPercent2.exec(format5)) ? rgba2(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, m5[4]) : (m5 = reHslPercent2.exec(format5)) ? hsla2(m5[1], m5[2] / 100, m5[3] / 100, 1) : (m5 = reHslaPercent2.exec(format5)) ? hsla2(m5[1], m5[2] / 100, m5[3] / 100, m5[4]) : named3.hasOwnProperty(format5) ? rgbn2(named3[format5]) : format5 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
+}
+
+function rgbn2(n) {
+    return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
+}
+
+function rgba2(r, g, b, a7) {
+    if (a7 <= 0)
+        r = g = b = NaN;
+    return new Rgb2(r, g, b, a7);
+}
+
+function rgbConvert2(o) {
+    if (!(o instanceof Color2))
+        o = color3(o);
+    if (!o)
+        return new Rgb2();
+    o = o.rgb();
+    return new Rgb2(o.r, o.g, o.b, o.opacity);
+}
+
+function rgb2(r, g, b, opacity3) {
+    return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b, opacity3 == null ? 1 : opacity3);
+}
+
+function Rgb2(r, g, b, opacity3) {
+    this.r = +r;
+    this.g = +g;
+    this.b = +b;
+    this.opacity = +opacity3;
+}
+define_default2(Rgb2, rgb2, extend2(Color2, {
+    brighter(k3) {
+        k3 = k3 == null ? brighter2 : Math.pow(brighter2, k3);
+        return new Rgb2(this.r * k3, this.g * k3, this.b * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker2 : Math.pow(darker2, k3);
+        return new Rgb2(this.r * k3, this.g * k3, this.b * k3, this.opacity);
+    },
+    rgb() {
+        return this;
+    },
+    clamp() {
+        return new Rgb2(clampi2(this.r), clampi2(this.g), clampi2(this.b), clampa2(this.opacity));
+    },
+    displayable() {
+        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
+    },
+    hex: rgb_formatHex2,
+    // Deprecated! Use color.formatHex.
+    formatHex: rgb_formatHex2,
+    formatHex8: rgb_formatHex82,
+    formatRgb: rgb_formatRgb2,
+    toString: rgb_formatRgb2
+}));
+
+function rgb_formatHex2() {
+    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
+}
+
+function rgb_formatHex82() {
+    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
+}
+
+function rgb_formatRgb2() {
+    const a7 = clampa2(this.opacity);
+    return `${a7 === 1 ? "rgb(" : "rgba("}${clampi2(this.r)}, ${clampi2(this.g)}, ${clampi2(this.b)}${a7 === 1 ? ")" : `, ${a7})`}`;
+}
+
+function clampa2(opacity3) {
+    return isNaN(opacity3) ? 1 : Math.max(0, Math.min(1, opacity3));
+}
+
+function clampi2(value) {
+    return Math.max(0, Math.min(255, Math.round(value) || 0));
+}
+
+function hex2(value) {
+    value = clampi2(value);
+    return (value < 16 ? "0" : "") + value.toString(16);
+}
+
+function hsla2(h, s3, l, a7) {
+    if (a7 <= 0)
+        h = s3 = l = NaN;
+    else if (l <= 0 || l >= 1)
+        h = s3 = NaN;
+    else if (s3 <= 0)
+        h = NaN;
+    return new Hsl2(h, s3, l, a7);
+}
+
+function hslConvert2(o) {
+    if (o instanceof Hsl2)
+        return new Hsl2(o.h, o.s, o.l, o.opacity);
+    if (!(o instanceof Color2))
+        o = color3(o);
+    if (!o)
+        return new Hsl2();
+    if (o instanceof Hsl2)
+        return o;
+    o = o.rgb();
+    var r = o.r / 255,
+        g = o.g / 255,
+        b = o.b / 255,
+        min7 = Math.min(r, g, b),
+        max9 = Math.max(r, g, b),
+        h = NaN,
+        s3 = max9 - min7,
+        l = (max9 + min7) / 2;
+    if (s3) {
+        if (r === max9)
+            h = (g - b) / s3 + (g < b) * 6;
+        else if (g === max9)
+            h = (b - r) / s3 + 2;
+        else
+            h = (r - g) / s3 + 4;
+        s3 /= l < 0.5 ? max9 + min7 : 2 - max9 - min7;
+        h *= 60;
+    } else {
+        s3 = l > 0 && l < 1 ? 0 : h;
+    }
+    return new Hsl2(h, s3, l, o.opacity);
+}
+
+function hsl3(h, s3, l, opacity3) {
+    return arguments.length === 1 ? hslConvert2(h) : new Hsl2(h, s3, l, opacity3 == null ? 1 : opacity3);
+}
+
+function Hsl2(h, s3, l, opacity3) {
+    this.h = +h;
+    this.s = +s3;
+    this.l = +l;
+    this.opacity = +opacity3;
+}
+define_default2(Hsl2, hsl3, extend2(Color2, {
+    brighter(k3) {
+        k3 = k3 == null ? brighter2 : Math.pow(brighter2, k3);
+        return new Hsl2(this.h, this.s, this.l * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker2 : Math.pow(darker2, k3);
+        return new Hsl2(this.h, this.s, this.l * k3, this.opacity);
+    },
+    rgb() {
+        var h = this.h % 360 + (this.h < 0) * 360,
+            s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s,
+            l = this.l,
+            m22 = l + (l < 0.5 ? l : 1 - l) * s3,
+            m1 = 2 * l - m22;
+        return new Rgb2(
+            hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m22),
+            hsl2rgb2(h, m1, m22),
+            hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m22),
+            this.opacity
+        );
+    },
+    clamp() {
+        return new Hsl2(clamph2(this.h), clampt2(this.s), clampt2(this.l), clampa2(this.opacity));
+    },
+    displayable() {
+        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
+    },
+    formatHsl() {
+        const a7 = clampa2(this.opacity);
+        return `${a7 === 1 ? "hsl(" : "hsla("}${clamph2(this.h)}, ${clampt2(this.s) * 100}%, ${clampt2(this.l) * 100}%${a7 === 1 ? ")" : `, ${a7})`}`;
+    }
+}));
+
+function clamph2(value) {
+    value = (value || 0) % 360;
+    return value < 0 ? value + 360 : value;
+}
+
+function clampt2(value) {
+    return Math.max(0, Math.min(1, value || 0));
+}
+
+function hsl2rgb2(h, m1, m22) {
+    return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
+}
+
+// js/pyobsplot-js/node_modules/d3-color/src/math.js
+var radians4 = Math.PI / 180;
+var degrees4 = 180 / Math.PI;
+
+// js/pyobsplot-js/node_modules/d3-color/src/lab.js
+var K2 = 18;
+var Xn2 = 0.96422;
+var Yn2 = 1;
+var Zn2 = 0.82521;
+var t03 = 4 / 29;
+var t13 = 6 / 29;
+var t22 = 3 * t13 * t13;
+var t32 = t13 * t13 * t13;
+
+function labConvert2(o) {
+    if (o instanceof Lab2)
+        return new Lab2(o.l, o.a, o.b, o.opacity);
+    if (o instanceof Hcl2)
+        return hcl2lab2(o);
+    if (!(o instanceof Rgb2))
+        o = rgbConvert2(o);
+    var r = rgb2lrgb2(o.r),
+        g = rgb2lrgb2(o.g),
+        b = rgb2lrgb2(o.b),
+        y7 = xyz2lab2((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn2),
+        x7, z;
+    if (r === g && g === b)
+        x7 = z = y7;
+    else {
+        x7 = xyz2lab2((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn2);
+        z = xyz2lab2((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn2);
+    }
+    return new Lab2(116 * y7 - 16, 500 * (x7 - y7), 200 * (y7 - z), o.opacity);
+}
+
+function gray2(l, opacity3) {
+    return new Lab2(l, 0, 0, opacity3 == null ? 1 : opacity3);
+}
+
+function lab3(l, a7, b, opacity3) {
+    return arguments.length === 1 ? labConvert2(l) : new Lab2(l, a7, b, opacity3 == null ? 1 : opacity3);
+}
+
+function Lab2(l, a7, b, opacity3) {
+    this.l = +l;
+    this.a = +a7;
+    this.b = +b;
+    this.opacity = +opacity3;
+}
+define_default2(Lab2, lab3, extend2(Color2, {
+    brighter(k3) {
+        return new Lab2(this.l + K2 * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
+    },
+    darker(k3) {
+        return new Lab2(this.l - K2 * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
+    },
+    rgb() {
+        var y7 = (this.l + 16) / 116,
+            x7 = isNaN(this.a) ? y7 : y7 + this.a / 500,
+            z = isNaN(this.b) ? y7 : y7 - this.b / 200;
+        x7 = Xn2 * lab2xyz2(x7);
+        y7 = Yn2 * lab2xyz2(y7);
+        z = Zn2 * lab2xyz2(z);
+        return new Rgb2(
+            lrgb2rgb2(3.1338561 * x7 - 1.6168667 * y7 - 0.4906146 * z),
+            lrgb2rgb2(-0.9787684 * x7 + 1.9161415 * y7 + 0.033454 * z),
+            lrgb2rgb2(0.0719453 * x7 - 0.2289914 * y7 + 1.4052427 * z),
+            this.opacity
+        );
+    }
+}));
+
+function xyz2lab2(t) {
+    return t > t32 ? Math.pow(t, 1 / 3) : t / t22 + t03;
+}
+
+function lab2xyz2(t) {
+    return t > t13 ? t * t * t : t22 * (t - t03);
+}
+
+function lrgb2rgb2(x7) {
+    return 255 * (x7 <= 31308e-7 ? 12.92 * x7 : 1.055 * Math.pow(x7, 1 / 2.4) - 0.055);
+}
+
+function rgb2lrgb2(x7) {
+    return (x7 /= 255) <= 0.04045 ? x7 / 12.92 : Math.pow((x7 + 0.055) / 1.055, 2.4);
+}
+
+function hclConvert2(o) {
+    if (o instanceof Hcl2)
+        return new Hcl2(o.h, o.c, o.l, o.opacity);
+    if (!(o instanceof Lab2))
+        o = labConvert2(o);
+    if (o.a === 0 && o.b === 0)
+        return new Hcl2(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
+    var h = Math.atan2(o.b, o.a) * degrees4;
+    return new Hcl2(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
+}
+
+function lch2(l, c11, h, opacity3) {
+    return arguments.length === 1 ? hclConvert2(l) : new Hcl2(h, c11, l, opacity3 == null ? 1 : opacity3);
+}
+
+function hcl3(h, c11, l, opacity3) {
+    return arguments.length === 1 ? hclConvert2(h) : new Hcl2(h, c11, l, opacity3 == null ? 1 : opacity3);
+}
+
+function Hcl2(h, c11, l, opacity3) {
+    this.h = +h;
+    this.c = +c11;
+    this.l = +l;
+    this.opacity = +opacity3;
+}
+
+function hcl2lab2(o) {
+    if (isNaN(o.h))
+        return new Lab2(o.l, 0, 0, o.opacity);
+    var h = o.h * radians4;
+    return new Lab2(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
+}
+define_default2(Hcl2, hcl3, extend2(Color2, {
+    brighter(k3) {
+        return new Hcl2(this.h, this.c, this.l + K2 * (k3 == null ? 1 : k3), this.opacity);
+    },
+    darker(k3) {
+        return new Hcl2(this.h, this.c, this.l - K2 * (k3 == null ? 1 : k3), this.opacity);
+    },
+    rgb() {
+        return hcl2lab2(this).rgb();
+    }
+}));
+
+// js/pyobsplot-js/node_modules/d3-color/src/cubehelix.js
+var A5 = -0.14861;
+var B3 = 1.78277;
+var C3 = -0.29227;
+var D3 = -0.90649;
+var E2 = 1.97294;
+var ED2 = E2 * D3;
+var EB2 = E2 * B3;
+var BC_DA2 = B3 * C3 - D3 * A5;
+
+function cubehelixConvert2(o) {
+    if (o instanceof Cubehelix2)
+        return new Cubehelix2(o.h, o.s, o.l, o.opacity);
+    if (!(o instanceof Rgb2))
+        o = rgbConvert2(o);
+    var r = o.r / 255,
+        g = o.g / 255,
+        b = o.b / 255,
+        l = (BC_DA2 * b + ED2 * r - EB2 * g) / (BC_DA2 + ED2 - EB2),
+        bl = b - l,
+        k3 = (E2 * (g - l) - C3 * bl) / D3,
+        s3 = Math.sqrt(k3 * k3 + bl * bl) / (E2 * l * (1 - l)),
+        h = s3 ? Math.atan2(k3, bl) * degrees4 - 120 : NaN;
+    return new Cubehelix2(h < 0 ? h + 360 : h, s3, l, o.opacity);
+}
+
+function cubehelix3(h, s3, l, opacity3) {
+    return arguments.length === 1 ? cubehelixConvert2(h) : new Cubehelix2(h, s3, l, opacity3 == null ? 1 : opacity3);
+}
+
+function Cubehelix2(h, s3, l, opacity3) {
+    this.h = +h;
+    this.s = +s3;
+    this.l = +l;
+    this.opacity = +opacity3;
+}
+define_default2(Cubehelix2, cubehelix3, extend2(Color2, {
+    brighter(k3) {
+        k3 = k3 == null ? brighter2 : Math.pow(brighter2, k3);
+        return new Cubehelix2(this.h, this.s, this.l * k3, this.opacity);
+    },
+    darker(k3) {
+        k3 = k3 == null ? darker2 : Math.pow(darker2, k3);
+        return new Cubehelix2(this.h, this.s, this.l * k3, this.opacity);
+    },
+    rgb() {
+        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians4,
+            l = +this.l,
+            a7 = isNaN(this.s) ? 0 : this.s * l * (1 - l),
+            cosh3 = Math.cos(h),
+            sinh3 = Math.sin(h);
+        return new Rgb2(
+            255 * (l + a7 * (A5 * cosh3 + B3 * sinh3)),
+            255 * (l + a7 * (C3 * cosh3 + D3 * sinh3)),
+            255 * (l + a7 * (E2 * cosh3)),
+            this.opacity
+        );
+    }
+}));
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/basis.js
+function basis2(t15, v0, v1, v22, v3) {
+    var t23 = t15 * t15,
+        t33 = t23 * t15;
+    return ((1 - 3 * t15 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t15 + 3 * t23 - 3 * t33) * v22 + t33 * v3) / 6;
+}
+
+function basis_default3(values3) {
+    var n = values3.length - 1;
+    return function(t) {
+        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
+            v1 = values3[i],
+            v22 = values3[i + 1],
+            v0 = i > 0 ? values3[i - 1] : 2 * v1 - v22,
+            v3 = i < n - 1 ? values3[i + 2] : 2 * v22 - v1;
+        return basis2((t - i / n) * n, v0, v1, v22, v3);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/basisClosed.js
+function basisClosed_default3(values3) {
+    var n = values3.length;
+    return function(t) {
+        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
+            v0 = values3[(i + n - 1) % n],
+            v1 = values3[i % n],
+            v22 = values3[(i + 1) % n],
+            v3 = values3[(i + 2) % n];
+        return basis2((t - i / n) * n, v0, v1, v22, v3);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/constant.js
+var constant_default14 = (x7) => () => x7;
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/color.js
+function linear4(a7, d) {
+    return function(t) {
+        return a7 + t * d;
+    };
+}
+
+function exponential2(a7, b, y7) {
+    return a7 = Math.pow(a7, y7), b = Math.pow(b, y7) - a7, y7 = 1 / y7,
+        function(t) {
+            return Math.pow(a7 + t * b, y7);
+        };
+}
+
+function hue2(a7, b) {
+    var d = b - a7;
+    return d ? linear4(a7, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default14(isNaN(a7) ? b : a7);
+}
+
+function gamma2(y7) {
+    return (y7 = +y7) === 1 ? nogamma2 : function(a7, b) {
+        return b - a7 ? exponential2(a7, b, y7) : constant_default14(isNaN(a7) ? b : a7);
+    };
+}
+
+function nogamma2(a7, b) {
+    var d = b - a7;
+    return d ? linear4(a7, d) : constant_default14(isNaN(a7) ? b : a7);
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/rgb.js
+var rgb_default2 = function rgbGamma2(y7) {
+    var color5 = gamma2(y7);
+
+    function rgb3(start3, end) {
+        var r = color5((start3 = rgb2(start3)).r, (end = rgb2(end)).r),
+            g = color5(start3.g, end.g),
+            b = color5(start3.b, end.b),
+            opacity3 = nogamma2(start3.opacity, end.opacity);
+        return function(t) {
+            start3.r = r(t);
+            start3.g = g(t);
+            start3.b = b(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
+        };
+    }
+    rgb3.gamma = rgbGamma2;
+    return rgb3;
+}(1);
+
+function rgbSpline2(spline) {
+    return function(colors) {
+        var n = colors.length,
+            r = new Array(n),
+            g = new Array(n),
+            b = new Array(n),
+            i, color5;
+        for (i = 0; i < n; ++i) {
+            color5 = rgb2(colors[i]);
+            r[i] = color5.r || 0;
+            g[i] = color5.g || 0;
+            b[i] = color5.b || 0;
+        }
+        r = spline(r);
+        g = spline(g);
+        b = spline(b);
+        color5.opacity = 1;
+        return function(t) {
+            color5.r = r(t);
+            color5.g = g(t);
+            color5.b = b(t);
+            return color5 + "";
+        };
+    };
+}
+var rgbBasis2 = rgbSpline2(basis_default3);
+var rgbBasisClosed2 = rgbSpline2(basisClosed_default3);
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/numberArray.js
+function numberArray_default2(a7, b) {
+    if (!b)
+        b = [];
+    var n = a7 ? Math.min(b.length, a7.length) : 0,
+        c11 = b.slice(),
+        i;
+    return function(t) {
+        for (i = 0; i < n; ++i)
+            c11[i] = a7[i] * (1 - t) + b[i] * t;
+        return c11;
+    };
+}
+
+function isNumberArray2(x7) {
+    return ArrayBuffer.isView(x7) && !(x7 instanceof DataView);
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/array.js
+function array_default4(a7, b) {
+    return (isNumberArray2(b) ? numberArray_default2 : genericArray2)(a7, b);
+}
+
+function genericArray2(a7, b) {
+    var nb = b ? b.length : 0,
+        na = a7 ? Math.min(nb, a7.length) : 0,
+        x7 = new Array(na),
+        c11 = new Array(nb),
+        i;
+    for (i = 0; i < na; ++i)
+        x7[i] = value_default2(a7[i], b[i]);
+    for (; i < nb; ++i)
+        c11[i] = b[i];
+    return function(t) {
+        for (i = 0; i < na; ++i)
+            c11[i] = x7[i](t);
+        return c11;
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/date.js
+function date_default2(a7, b) {
+    var d = /* @__PURE__ */ new Date();
+    return a7 = +a7, b = +b,
+        function(t) {
+            return d.setTime(a7 * (1 - t) + b * t), d;
+        };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/number.js
+function number_default2(a7, b) {
+    return a7 = +a7, b = +b,
+        function(t) {
+            return a7 * (1 - t) + b * t;
+        };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/object.js
+function object_default2(a7, b) {
+    var i = {},
+        c11 = {},
+        k3;
+    if (a7 === null || typeof a7 !== "object")
+        a7 = {};
+    if (b === null || typeof b !== "object")
+        b = {};
+    for (k3 in b) {
+        if (k3 in a7) {
+            i[k3] = value_default2(a7[k3], b[k3]);
+        } else {
+            c11[k3] = b[k3];
+        }
+    }
+    return function(t) {
+        for (k3 in i)
+            c11[k3] = i[k3](t);
+        return c11;
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/string.js
+var reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
+var reB2 = new RegExp(reA2.source, "g");
+
+function zero4(b) {
+    return function() {
+        return b;
+    };
+}
+
+function one3(b) {
+    return function(t) {
+        return b(t) + "";
+    };
+}
+
+function string_default2(a7, b) {
+    var bi = reA2.lastIndex = reB2.lastIndex = 0,
+        am, bm, bs, i = -1,
+        s3 = [],
+        q = [];
+    a7 = a7 + "", b = b + "";
+    while ((am = reA2.exec(a7)) && (bm = reB2.exec(b))) {
+        if ((bs = bm.index) > bi) {
+            bs = b.slice(bi, bs);
+            if (s3[i])
+                s3[i] += bs;
+            else
+                s3[++i] = bs;
+        }
+        if ((am = am[0]) === (bm = bm[0])) {
+            if (s3[i])
+                s3[i] += bm;
+            else
+                s3[++i] = bm;
+        } else {
+            s3[++i] = null;
+            q.push({
+                i,
+                x: number_default2(am, bm)
+            });
+        }
+        bi = reB2.lastIndex;
+    }
+    if (bi < b.length) {
+        bs = b.slice(bi);
+        if (s3[i])
+            s3[i] += bs;
+        else
+            s3[++i] = bs;
+    }
+    return s3.length < 2 ? q[0] ? one3(q[0].x) : zero4(b) : (b = q.length, function(t) {
+        for (var i2 = 0, o; i2 < b; ++i2)
+            s3[(o = q[i2]).i] = o.x(t);
+        return s3.join("");
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/value.js
+function value_default2(a7, b) {
+    var t = typeof b,
+        c11;
+    return b == null || t === "boolean" ? constant_default14(b) : (t === "number" ? number_default2 : t === "string" ? (c11 = color3(b)) ? (b = c11, rgb_default2) : string_default2 : b instanceof color3 ? rgb_default2 : b instanceof Date ? date_default2 : isNumberArray2(b) ? numberArray_default2 : Array.isArray(b) ? genericArray2 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default2 : number_default2)(a7, b);
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/discrete.js
+function discrete_default2(range9) {
+    var n = range9.length;
+    return function(t) {
+        return range9[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/hue.js
+function hue_default2(a7, b) {
+    var i = hue2(+a7, +b);
+    return function(t) {
+        var x7 = i(t);
+        return x7 - 360 * Math.floor(x7 / 360);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/round.js
+function round_default3(a7, b) {
+    return a7 = +a7, b = +b,
+        function(t) {
+            return Math.round(a7 * (1 - t) + b * t);
+        };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/transform/decompose.js
+var degrees5 = 180 / Math.PI;
+var identity9 = {
+    translateX: 0,
+    translateY: 0,
+    rotate: 0,
+    skewX: 0,
+    scaleX: 1,
+    scaleY: 1
+};
+
+function decompose_default2(a7, b, c11, d, e, f) {
+    var scaleX, scaleY, skewX;
+    if (scaleX = Math.sqrt(a7 * a7 + b * b))
+        a7 /= scaleX, b /= scaleX;
+    if (skewX = a7 * c11 + b * d)
+        c11 -= a7 * skewX, d -= b * skewX;
+    if (scaleY = Math.sqrt(c11 * c11 + d * d))
+        c11 /= scaleY, d /= scaleY, skewX /= scaleY;
+    if (a7 * d < b * c11)
+        a7 = -a7, b = -b, skewX = -skewX, scaleX = -scaleX;
+    return {
+        translateX: e,
+        translateY: f,
+        rotate: Math.atan2(b, a7) * degrees5,
+        skewX: Math.atan(skewX) * degrees5,
+        scaleX,
+        scaleY
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/transform/parse.js
+var svgNode2;
+
+function parseCss2(value) {
+    const m5 = new(typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
+    return m5.isIdentity ? identity9 : decompose_default2(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f);
+}
+
+function parseSvg2(value) {
+    if (value == null)
+        return identity9;
+    if (!svgNode2)
+        svgNode2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
+    svgNode2.setAttribute("transform", value);
+    if (!(value = svgNode2.transform.baseVal.consolidate()))
+        return identity9;
+    value = value.matrix;
+    return decompose_default2(value.a, value.b, value.c, value.d, value.e, value.f);
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/transform/index.js
+function interpolateTransform2(parse3, pxComma, pxParen, degParen) {
+    function pop(s3) {
+        return s3.length ? s3.pop() + " " : "";
+    }
+
+    function translate(xa, ya, xb, yb, s3, q) {
+        if (xa !== xb || ya !== yb) {
+            var i = s3.push("translate(", null, pxComma, null, pxParen);
+            q.push({
+                i: i - 4,
+                x: number_default2(xa, xb)
+            }, {
+                i: i - 2,
+                x: number_default2(ya, yb)
+            });
+        } else if (xb || yb) {
+            s3.push("translate(" + xb + pxComma + yb + pxParen);
+        }
+    }
+
+    function rotate(a7, b, s3, q) {
+        if (a7 !== b) {
+            if (a7 - b > 180)
+                b += 360;
+            else if (b - a7 > 180)
+                a7 += 360;
+            q.push({
+                i: s3.push(pop(s3) + "rotate(", null, degParen) - 2,
+                x: number_default2(a7, b)
+            });
+        } else if (b) {
+            s3.push(pop(s3) + "rotate(" + b + degParen);
+        }
+    }
+
+    function skewX(a7, b, s3, q) {
+        if (a7 !== b) {
+            q.push({
+                i: s3.push(pop(s3) + "skewX(", null, degParen) - 2,
+                x: number_default2(a7, b)
+            });
+        } else if (b) {
+            s3.push(pop(s3) + "skewX(" + b + degParen);
+        }
+    }
+
+    function scale5(xa, ya, xb, yb, s3, q) {
+        if (xa !== xb || ya !== yb) {
+            var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
+            q.push({
+                i: i - 4,
+                x: number_default2(xa, xb)
+            }, {
+                i: i - 2,
+                x: number_default2(ya, yb)
+            });
+        } else if (xb !== 1 || yb !== 1) {
+            s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
+        }
+    }
+    return function(a7, b) {
+        var s3 = [],
+            q = [];
+        a7 = parse3(a7), b = parse3(b);
+        translate(a7.translateX, a7.translateY, b.translateX, b.translateY, s3, q);
+        rotate(a7.rotate, b.rotate, s3, q);
+        skewX(a7.skewX, b.skewX, s3, q);
+        scale5(a7.scaleX, a7.scaleY, b.scaleX, b.scaleY, s3, q);
+        a7 = b = null;
+        return function(t) {
+            var i = -1,
+                n = q.length,
+                o;
+            while (++i < n)
+                s3[(o = q[i]).i] = o.x(t);
+            return s3.join("");
+        };
+    };
+}
+var interpolateTransformCss2 = interpolateTransform2(parseCss2, "px, ", "px)", "deg)");
+var interpolateTransformSvg2 = interpolateTransform2(parseSvg2, ", ", ")", ")");
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/zoom.js
+var epsilon23 = 1e-12;
+
+function cosh2(x7) {
+    return ((x7 = Math.exp(x7)) + 1 / x7) / 2;
+}
+
+function sinh2(x7) {
+    return ((x7 = Math.exp(x7)) - 1 / x7) / 2;
+}
+
+function tanh2(x7) {
+    return ((x7 = Math.exp(2 * x7)) - 1) / (x7 + 1);
+}
+var zoom_default3 = function zoomRho2(rho, rho2, rho4) {
+    function zoom(p03, p1) {
+        var ux0 = p03[0],
+            uy0 = p03[1],
+            w0 = p03[2],
+            ux1 = p1[0],
+            uy1 = p1[1],
+            w1 = p1[2],
+            dx = ux1 - ux0,
+            dy = uy1 - uy0,
+            d2 = dx * dx + dy * dy,
+            i, S;
+        if (d2 < epsilon23) {
+            S = Math.log(w1 / w0) / rho;
+            i = function(t) {
+                return [
+                    ux0 + t * dx,
+                    uy0 + t * dy,
+                    w0 * Math.exp(rho * t * S)
+                ];
+            };
+        } else {
+            var d1 = Math.sqrt(d2),
+                b03 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
+                b13 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
+                r0 = Math.log(Math.sqrt(b03 * b03 + 1) - b03),
+                r1 = Math.log(Math.sqrt(b13 * b13 + 1) - b13);
+            S = (r1 - r0) / rho;
+            i = function(t) {
+                var s3 = t * S,
+                    coshr0 = cosh2(r0),
+                    u7 = w0 / (rho2 * d1) * (coshr0 * tanh2(rho * s3 + r0) - sinh2(r0));
+                return [
+                    ux0 + u7 * dx,
+                    uy0 + u7 * dy,
+                    w0 * coshr0 / cosh2(rho * s3 + r0)
+                ];
+            };
+        }
+        i.duration = S * 1e3 * rho / Math.SQRT2;
+        return i;
+    }
+    zoom.rho = function(_) {
+        var _1 = Math.max(1e-3, +_),
+            _2 = _1 * _1,
+            _4 = _2 * _2;
+        return zoomRho2(_1, _2, _4);
+    };
+    return zoom;
+}(Math.SQRT2, 2, 4);
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/hsl.js
+function hsl4(hue3) {
+    return function(start3, end) {
+        var h = hue3((start3 = hsl3(start3)).h, (end = hsl3(end)).h),
+            s3 = nogamma2(start3.s, end.s),
+            l = nogamma2(start3.l, end.l),
+            opacity3 = nogamma2(start3.opacity, end.opacity);
+        return function(t) {
+            start3.h = h(t);
+            start3.s = s3(t);
+            start3.l = l(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
+        };
+    };
+}
+var hsl_default2 = hsl4(hue2);
+var hslLong2 = hsl4(nogamma2);
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/lab.js
+function lab4(start3, end) {
+    var l = nogamma2((start3 = lab3(start3)).l, (end = lab3(end)).l),
+        a7 = nogamma2(start3.a, end.a),
+        b = nogamma2(start3.b, end.b),
+        opacity3 = nogamma2(start3.opacity, end.opacity);
+    return function(t) {
+        start3.l = l(t);
+        start3.a = a7(t);
+        start3.b = b(t);
+        start3.opacity = opacity3(t);
+        return start3 + "";
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/hcl.js
+function hcl4(hue3) {
+    return function(start3, end) {
+        var h = hue3((start3 = hcl3(start3)).h, (end = hcl3(end)).h),
+            c11 = nogamma2(start3.c, end.c),
+            l = nogamma2(start3.l, end.l),
+            opacity3 = nogamma2(start3.opacity, end.opacity);
+        return function(t) {
+            start3.h = h(t);
+            start3.c = c11(t);
+            start3.l = l(t);
+            start3.opacity = opacity3(t);
+            return start3 + "";
+        };
+    };
+}
+var hcl_default2 = hcl4(hue2);
+var hclLong2 = hcl4(nogamma2);
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/cubehelix.js
+function cubehelix4(hue3) {
+    return function cubehelixGamma(y7) {
+        y7 = +y7;
+
+        function cubehelix5(start3, end) {
+            var h = hue3((start3 = cubehelix3(start3)).h, (end = cubehelix3(end)).h),
+                s3 = nogamma2(start3.s, end.s),
+                l = nogamma2(start3.l, end.l),
+                opacity3 = nogamma2(start3.opacity, end.opacity);
+            return function(t) {
+                start3.h = h(t);
+                start3.s = s3(t);
+                start3.l = l(Math.pow(t, y7));
+                start3.opacity = opacity3(t);
+                return start3 + "";
+            };
+        }
+        cubehelix5.gamma = cubehelixGamma;
+        return cubehelix5;
+    }(1);
+}
+var cubehelix_default3 = cubehelix4(hue2);
+var cubehelixLong2 = cubehelix4(nogamma2);
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/piecewise.js
+function piecewise2(interpolate, values3) {
+    if (values3 === void 0)
+        values3 = interpolate, interpolate = value_default2;
+    var i = 0,
+        n = values3.length - 1,
+        v3 = values3[0],
+        I = new Array(n < 0 ? 0 : n);
+    while (i < n)
+        I[i] = interpolate(v3, v3 = values3[++i]);
+    return function(t) {
+        var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
+        return I[i2](t - i2);
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-interpolate/src/quantize.js
+function quantize_default2(interpolator, n) {
+    var samples = new Array(n);
+    for (var i = 0; i < n; ++i)
+        samples[i] = interpolator(i / (n - 1));
+    return samples;
+}
+
+// js/pyobsplot-js/node_modules/d3-timer/src/timer.js
+var frame3 = 0;
+var timeout2 = 0;
+var interval2 = 0;
+var pokeDelay2 = 1e3;
+var taskHead2;
+var taskTail2;
+var clockLast2 = 0;
+var clockNow2 = 0;
+var clockSkew2 = 0;
+var clock2 = typeof performance === "object" && performance.now ? performance : Date;
+var setFrame2 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
+    setTimeout(f, 17);
+};
+
+function now2() {
+    return clockNow2 || (setFrame2(clearNow2), clockNow2 = clock2.now() + clockSkew2);
+}
+
+function clearNow2() {
+    clockNow2 = 0;
+}
+
+function Timer2() {
+    this._call = this._time = this._next = null;
+}
+Timer2.prototype = timer2.prototype = {
+    constructor: Timer2,
+    restart: function(callback, delay, time3) {
+        if (typeof callback !== "function")
+            throw new TypeError("callback is not a function");
+        time3 = (time3 == null ? now2() : +time3) + (delay == null ? 0 : +delay);
+        if (!this._next && taskTail2 !== this) {
+            if (taskTail2)
+                taskTail2._next = this;
+            else
+                taskHead2 = this;
+            taskTail2 = this;
+        }
+        this._call = callback;
+        this._time = time3;
+        sleep2();
+    },
+    stop: function() {
+        if (this._call) {
+            this._call = null;
+            this._time = Infinity;
+            sleep2();
+        }
+    }
+};
+
+function timer2(callback, delay, time3) {
+    var t = new Timer2();
+    t.restart(callback, delay, time3);
+    return t;
+}
+
+function timerFlush2() {
+    now2();
+    ++frame3;
+    var t = taskHead2,
+        e;
+    while (t) {
+        if ((e = clockNow2 - t._time) >= 0)
+            t._call.call(void 0, e);
+        t = t._next;
+    }
+    --frame3;
+}
+
+function wake2() {
+    clockNow2 = (clockLast2 = clock2.now()) + clockSkew2;
+    frame3 = timeout2 = 0;
+    try {
+        timerFlush2();
+    } finally {
+        frame3 = 0;
+        nap2();
+        clockNow2 = 0;
+    }
+}
+
+function poke2() {
+    var now3 = clock2.now(),
+        delay = now3 - clockLast2;
+    if (delay > pokeDelay2)
+        clockSkew2 -= delay, clockLast2 = now3;
+}
+
+function nap2() {
+    var t05, t15 = taskHead2,
+        t23, time3 = Infinity;
+    while (t15) {
+        if (t15._call) {
+            if (time3 > t15._time)
+                time3 = t15._time;
+            t05 = t15, t15 = t15._next;
+        } else {
+            t23 = t15._next, t15._next = null;
+            t15 = t05 ? t05._next = t23 : taskHead2 = t23;
+        }
+    }
+    taskTail2 = t05;
+    sleep2(time3);
+}
+
+function sleep2(time3) {
+    if (frame3)
+        return;
+    if (timeout2)
+        timeout2 = clearTimeout(timeout2);
+    var delay = time3 - clockNow2;
+    if (delay > 24) {
+        if (time3 < Infinity)
+            timeout2 = setTimeout(wake2, time3 - clock2.now() - clockSkew2);
+        if (interval2)
+            interval2 = clearInterval(interval2);
+    } else {
+        if (!interval2)
+            clockLast2 = clock2.now(), interval2 = setInterval(poke2, pokeDelay2);
+        frame3 = 1, setFrame2(wake2);
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-timer/src/timeout.js
+function timeout_default2(callback, delay, time3) {
+    var t = new Timer2();
+    delay = delay == null ? 0 : +delay;
+    t.restart((elapsed) => {
+        t.stop();
+        callback(elapsed + delay);
+    }, delay, time3);
+    return t;
+}
+
+// js/pyobsplot-js/node_modules/d3-timer/src/interval.js
+function interval_default2(callback, delay, time3) {
+    var t = new Timer2(),
+        total = delay;
+    if (delay == null)
+        return t.restart(callback, delay, time3), t;
+    t._restart = t.restart;
+    t.restart = function(callback2, delay2, time4) {
+        delay2 = +delay2, time4 = time4 == null ? now2() : +time4;
+        t._restart(function tick(elapsed) {
+            elapsed += total;
+            t._restart(tick, total += delay2, time4);
+            callback2(elapsed);
+        }, delay2, time4);
+    };
+    t.restart(callback, delay, time3);
+    return t;
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/schedule.js
+var emptyOn2 = dispatch_default3("start", "end", "cancel", "interrupt");
+var emptyTween2 = [];
+var CREATED2 = 0;
+var SCHEDULED2 = 1;
+var STARTING2 = 2;
+var STARTED2 = 3;
+var RUNNING2 = 4;
+var ENDING2 = 5;
+var ENDED2 = 6;
+
+function schedule_default2(node, name, id3, index5, group5, timing) {
+    var schedules = node.__transition;
+    if (!schedules)
+        node.__transition = {};
+    else if (id3 in schedules)
+        return;
+    create3(node, id3, {
+        name,
+        index: index5,
+        // For context during callback.
+        group: group5,
+        // For context during callback.
+        on: emptyOn2,
+        tween: emptyTween2,
+        time: timing.time,
+        delay: timing.delay,
+        duration: timing.duration,
+        ease: timing.ease,
+        timer: null,
+        state: CREATED2
+    });
+}
+
+function init2(node, id3) {
+    var schedule = get4(node, id3);
+    if (schedule.state > CREATED2)
+        throw new Error("too late; already scheduled");
+    return schedule;
+}
+
+function set6(node, id3) {
+    var schedule = get4(node, id3);
+    if (schedule.state > STARTED2)
+        throw new Error("too late; already running");
+    return schedule;
+}
+
+function get4(node, id3) {
+    var schedule = node.__transition;
+    if (!schedule || !(schedule = schedule[id3]))
+        throw new Error("transition not found");
+    return schedule;
+}
+
+function create3(node, id3, self) {
+    var schedules = node.__transition,
+        tween;
+    schedules[id3] = self;
+    self.timer = timer2(schedule, 0, self.time);
+
+    function schedule(elapsed) {
+        self.state = SCHEDULED2;
+        self.timer.restart(start3, self.delay, self.time);
+        if (self.delay <= elapsed)
+            start3(elapsed - self.delay);
+    }
+
+    function start3(elapsed) {
+        var i, j, n, o;
+        if (self.state !== SCHEDULED2)
+            return stop();
+        for (i in schedules) {
+            o = schedules[i];
+            if (o.name !== self.name)
+                continue;
+            if (o.state === STARTED2)
+                return timeout_default2(start3);
+            if (o.state === RUNNING2) {
+                o.state = ENDED2;
+                o.timer.stop();
+                o.on.call("interrupt", node, node.__data__, o.index, o.group);
+                delete schedules[i];
+            } else if (+i < id3) {
+                o.state = ENDED2;
+                o.timer.stop();
+                o.on.call("cancel", node, node.__data__, o.index, o.group);
+                delete schedules[i];
+            }
+        }
+        timeout_default2(function() {
+            if (self.state === STARTED2) {
+                self.state = RUNNING2;
+                self.timer.restart(tick, self.delay, self.time);
+                tick(elapsed);
+            }
+        });
+        self.state = STARTING2;
+        self.on.call("start", node, node.__data__, self.index, self.group);
+        if (self.state !== STARTING2)
+            return;
+        self.state = STARTED2;
+        tween = new Array(n = self.tween.length);
+        for (i = 0, j = -1; i < n; ++i) {
+            if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
+                tween[++j] = o;
+            }
+        }
+        tween.length = j + 1;
+    }
+
+    function tick(elapsed) {
+        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING2, 1),
+            i = -1,
+            n = tween.length;
+        while (++i < n) {
+            tween[i].call(node, t);
+        }
+        if (self.state === ENDING2) {
+            self.on.call("end", node, node.__data__, self.index, self.group);
+            stop();
+        }
+    }
+
+    function stop() {
+        self.state = ENDED2;
+        self.timer.stop();
+        delete schedules[id3];
+        for (var i in schedules)
+            return;
+        delete node.__transition;
+    }
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/interrupt.js
+function interrupt_default3(node, name) {
+    var schedules = node.__transition,
+        schedule, active, empty7 = true,
+        i;
+    if (!schedules)
+        return;
+    name = name == null ? null : name + "";
+    for (i in schedules) {
+        if ((schedule = schedules[i]).name !== name) {
+            empty7 = false;
+            continue;
+        }
+        active = schedule.state > STARTING2 && schedule.state < ENDING2;
+        schedule.state = ENDED2;
+        schedule.timer.stop();
+        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
+        delete schedules[i];
+    }
+    if (empty7)
+        delete node.__transition;
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/selection/interrupt.js
+function interrupt_default4(name) {
+    return this.each(function() {
+        interrupt_default3(this, name);
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/tween.js
+function tweenRemove2(id3, name) {
+    var tween0, tween1;
+    return function() {
+        var schedule = set6(this, id3),
+            tween = schedule.tween;
+        if (tween !== tween0) {
+            tween1 = tween0 = tween;
+            for (var i = 0, n = tween1.length; i < n; ++i) {
+                if (tween1[i].name === name) {
+                    tween1 = tween1.slice();
+                    tween1.splice(i, 1);
+                    break;
+                }
+            }
+        }
+        schedule.tween = tween1;
+    };
+}
+
+function tweenFunction2(id3, name, value) {
+    var tween0, tween1;
+    if (typeof value !== "function")
+        throw new Error();
+    return function() {
+        var schedule = set6(this, id3),
+            tween = schedule.tween;
+        if (tween !== tween0) {
+            tween1 = (tween0 = tween).slice();
+            for (var t = {
+                    name,
+                    value
+                }, i = 0, n = tween1.length; i < n; ++i) {
+                if (tween1[i].name === name) {
+                    tween1[i] = t;
+                    break;
+                }
+            }
+            if (i === n)
+                tween1.push(t);
+        }
+        schedule.tween = tween1;
+    };
+}
+
+function tween_default2(name, value) {
+    var id3 = this._id;
+    name += "";
+    if (arguments.length < 2) {
+        var tween = get4(this.node(), id3).tween;
+        for (var i = 0, n = tween.length, t; i < n; ++i) {
+            if ((t = tween[i]).name === name) {
+                return t.value;
+            }
+        }
+        return null;
+    }
+    return this.each((value == null ? tweenRemove2 : tweenFunction2)(id3, name, value));
+}
+
+function tweenValue2(transition3, name, value) {
+    var id3 = transition3._id;
+    transition3.each(function() {
+        var schedule = set6(this, id3);
+        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
+    });
+    return function(node) {
+        return get4(node, id3).value[name];
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/interpolate.js
+function interpolate_default3(a7, b) {
+    var c11;
+    return (typeof b === "number" ? number_default2 : b instanceof color3 ? rgb_default2 : (c11 = color3(b)) ? (b = c11, rgb_default2) : string_default2)(a7, b);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/attr.js
+function attrRemove4(name) {
+    return function() {
+        this.removeAttribute(name);
+    };
+}
+
+function attrRemoveNS4(fullname) {
+    return function() {
+        this.removeAttributeNS(fullname.space, fullname.local);
+    };
+}
+
+function attrConstant4(name, interpolate, value1) {
+    var string00, string1 = value1 + "",
+        interpolate0;
+    return function() {
+        var string0 = this.getAttribute(name);
+        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
+    };
+}
+
+function attrConstantNS4(fullname, interpolate, value1) {
+    var string00, string1 = value1 + "",
+        interpolate0;
+    return function() {
+        var string0 = this.getAttributeNS(fullname.space, fullname.local);
+        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
+    };
+}
+
+function attrFunction4(name, interpolate, value) {
+    var string00, string10, interpolate0;
+    return function() {
+        var string0, value1 = value(this),
+            string1;
+        if (value1 == null)
+            return void this.removeAttribute(name);
+        string0 = this.getAttribute(name);
+        string1 = value1 + "";
+        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
+    };
+}
+
+function attrFunctionNS4(fullname, interpolate, value) {
+    var string00, string10, interpolate0;
+    return function() {
+        var string0, value1 = value(this),
+            string1;
+        if (value1 == null)
+            return void this.removeAttributeNS(fullname.space, fullname.local);
+        string0 = this.getAttributeNS(fullname.space, fullname.local);
+        string1 = value1 + "";
+        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
+    };
+}
+
+function attr_default4(name, value) {
+    var fullname = namespace_default2(name),
+        i = fullname === "transform" ? interpolateTransformSvg2 : interpolate_default3;
+    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS4 : attrFunction4)(fullname, i, tweenValue2(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS4 : attrRemove4)(fullname) : (fullname.local ? attrConstantNS4 : attrConstant4)(fullname, i, value));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/attrTween.js
+function attrInterpolate2(name, i) {
+    return function(t) {
+        this.setAttribute(name, i.call(this, t));
+    };
+}
+
+function attrInterpolateNS2(fullname, i) {
+    return function(t) {
+        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
+    };
+}
+
+function attrTweenNS2(fullname, value) {
+    var t05, i0;
+
+    function tween() {
+        var i = value.apply(this, arguments);
+        if (i !== i0)
+            t05 = (i0 = i) && attrInterpolateNS2(fullname, i);
+        return t05;
+    }
+    tween._value = value;
+    return tween;
+}
+
+function attrTween2(name, value) {
+    var t05, i0;
+
+    function tween() {
+        var i = value.apply(this, arguments);
+        if (i !== i0)
+            t05 = (i0 = i) && attrInterpolate2(name, i);
+        return t05;
+    }
+    tween._value = value;
+    return tween;
+}
+
+function attrTween_default2(name, value) {
+    var key = "attr." + name;
+    if (arguments.length < 2)
+        return (key = this.tween(key)) && key._value;
+    if (value == null)
+        return this.tween(key, null);
+    if (typeof value !== "function")
+        throw new Error();
+    var fullname = namespace_default2(name);
+    return this.tween(key, (fullname.local ? attrTweenNS2 : attrTween2)(fullname, value));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/delay.js
+function delayFunction2(id3, value) {
+    return function() {
+        init2(this, id3).delay = +value.apply(this, arguments);
+    };
+}
+
+function delayConstant2(id3, value) {
+    return value = +value,
+        function() {
+            init2(this, id3).delay = value;
+        };
+}
+
+function delay_default2(value) {
+    var id3 = this._id;
+    return arguments.length ? this.each((typeof value === "function" ? delayFunction2 : delayConstant2)(id3, value)) : get4(this.node(), id3).delay;
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/duration.js
+function durationFunction2(id3, value) {
+    return function() {
+        set6(this, id3).duration = +value.apply(this, arguments);
+    };
+}
+
+function durationConstant2(id3, value) {
+    return value = +value,
+        function() {
+            set6(this, id3).duration = value;
+        };
+}
+
+function duration_default2(value) {
+    var id3 = this._id;
+    return arguments.length ? this.each((typeof value === "function" ? durationFunction2 : durationConstant2)(id3, value)) : get4(this.node(), id3).duration;
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/ease.js
+function easeConstant2(id3, value) {
+    if (typeof value !== "function")
+        throw new Error();
+    return function() {
+        set6(this, id3).ease = value;
+    };
+}
+
+function ease_default2(value) {
+    var id3 = this._id;
+    return arguments.length ? this.each(easeConstant2(id3, value)) : get4(this.node(), id3).ease;
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/easeVarying.js
+function easeVarying2(id3, value) {
+    return function() {
+        var v3 = value.apply(this, arguments);
+        if (typeof v3 !== "function")
+            throw new Error();
+        set6(this, id3).ease = v3;
+    };
+}
+
+function easeVarying_default2(value) {
+    if (typeof value !== "function")
+        throw new Error();
+    return this.each(easeVarying2(this._id, value));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/filter.js
+function filter_default4(match) {
+    if (typeof match !== "function")
+        match = matcher_default2(match);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && match.call(node, node.__data__, i, group5)) {
+                subgroup.push(node);
+            }
+        }
+    }
+    return new Transition2(subgroups, this._parents, this._name, this._id);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/merge.js
+function merge_default4(transition3) {
+    if (transition3._id !== this._id)
+        throw new Error();
+    for (var groups0 = this._groups, groups1 = transition3._groups, m0 = groups0.length, m1 = groups1.length, m5 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m5; ++j) {
+        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+            if (node = group0[i] || group1[i]) {
+                merge3[i] = node;
+            }
+        }
+    }
+    for (; j < m0; ++j) {
+        merges[j] = groups0[j];
+    }
+    return new Transition2(merges, this._parents, this._name, this._id);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/on.js
+function start2(name) {
+    return (name + "").trim().split(/^|\s+/).every(function(t) {
+        var i = t.indexOf(".");
+        if (i >= 0)
+            t = t.slice(0, i);
+        return !t || t === "start";
+    });
+}
+
+function onFunction2(id3, name, listener) {
+    var on0, on1, sit = start2(name) ? init2 : set6;
+    return function() {
+        var schedule = sit(this, id3),
+            on = schedule.on;
+        if (on !== on0)
+            (on1 = (on0 = on).copy()).on(name, listener);
+        schedule.on = on1;
+    };
+}
+
+function on_default4(name, listener) {
+    var id3 = this._id;
+    return arguments.length < 2 ? get4(this.node(), id3).on.on(name) : this.each(onFunction2(id3, name, listener));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/remove.js
+function removeFunction2(id3) {
+    return function() {
+        var parent = this.parentNode;
+        for (var i in this.__transition)
+            if (+i !== id3)
+                return;
+        if (parent)
+            parent.removeChild(this);
+    };
+}
+
+function remove_default5() {
+    return this.on("end.remove", removeFunction2(this._id));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/select.js
+function select_default6(select3) {
+    var name = this._name,
+        id3 = this._id;
+    if (typeof select3 !== "function")
+        select3 = selector_default2(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = new Array(m5), j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+            if ((node = group5[i]) && (subnode = select3.call(node, node.__data__, i, group5))) {
+                if ("__data__" in node)
+                    subnode.__data__ = node.__data__;
+                subgroup[i] = subnode;
+                schedule_default2(subgroup[i], name, id3, i, subgroup, get4(node, id3));
+            }
+        }
+    }
+    return new Transition2(subgroups, this._parents, name, id3);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/selectAll.js
+function selectAll_default6(select3) {
+    var name = this._name,
+        id3 = this._id;
+    if (typeof select3 !== "function")
+        select3 = selectorAll_default2(select3);
+    for (var groups3 = this._groups, m5 = groups3.length, subgroups = [], parents = [], j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                for (var children3 = select3.call(node, node.__data__, i, group5), child, inherit5 = get4(node, id3), k3 = 0, l = children3.length; k3 < l; ++k3) {
+                    if (child = children3[k3]) {
+                        schedule_default2(child, name, id3, k3, children3, inherit5);
+                    }
+                }
+                subgroups.push(children3);
+                parents.push(node);
+            }
+        }
+    }
+    return new Transition2(subgroups, parents, name, id3);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/selection.js
+var Selection4 = selection_default3.prototype.constructor;
+
+function selection_default4() {
+    return new Selection4(this._groups, this._parents);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/style.js
+function styleNull2(name, interpolate) {
+    var string00, string10, interpolate0;
+    return function() {
+        var string0 = styleValue2(this, name),
+            string1 = (this.style.removeProperty(name), styleValue2(this, name));
+        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
+    };
+}
+
+function styleRemove4(name) {
+    return function() {
+        this.style.removeProperty(name);
+    };
+}
+
+function styleConstant4(name, interpolate, value1) {
+    var string00, string1 = value1 + "",
+        interpolate0;
+    return function() {
+        var string0 = styleValue2(this, name);
+        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
+    };
+}
+
+function styleFunction4(name, interpolate, value) {
+    var string00, string10, interpolate0;
+    return function() {
+        var string0 = styleValue2(this, name),
+            value1 = value(this),
+            string1 = value1 + "";
+        if (value1 == null)
+            string1 = value1 = (this.style.removeProperty(name), styleValue2(this, name));
+        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
+    };
+}
+
+function styleMaybeRemove2(id3, name) {
+    var on0, on1, listener0, key = "style." + name,
+        event = "end." + key,
+        remove3;
+    return function() {
+        var schedule = set6(this, id3),
+            on = schedule.on,
+            listener = schedule.value[key] == null ? remove3 || (remove3 = styleRemove4(name)) : void 0;
+        if (on !== on0 || listener0 !== listener)
+            (on1 = (on0 = on).copy()).on(event, listener0 = listener);
+        schedule.on = on1;
+    };
+}
+
+function style_default4(name, value, priority) {
+    var i = (name += "") === "transform" ? interpolateTransformCss2 : interpolate_default3;
+    return value == null ? this.styleTween(name, styleNull2(name, i)).on("end.style." + name, styleRemove4(name)) : typeof value === "function" ? this.styleTween(name, styleFunction4(name, i, tweenValue2(this, "style." + name, value))).each(styleMaybeRemove2(this._id, name)) : this.styleTween(name, styleConstant4(name, i, value), priority).on("end.style." + name, null);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/styleTween.js
+function styleInterpolate2(name, i, priority) {
+    return function(t) {
+        this.style.setProperty(name, i.call(this, t), priority);
+    };
+}
+
+function styleTween2(name, value, priority) {
+    var t, i0;
+
+    function tween() {
+        var i = value.apply(this, arguments);
+        if (i !== i0)
+            t = (i0 = i) && styleInterpolate2(name, i, priority);
+        return t;
+    }
+    tween._value = value;
+    return tween;
+}
+
+function styleTween_default2(name, value, priority) {
+    var key = "style." + (name += "");
+    if (arguments.length < 2)
+        return (key = this.tween(key)) && key._value;
+    if (value == null)
+        return this.tween(key, null);
+    if (typeof value !== "function")
+        throw new Error();
+    return this.tween(key, styleTween2(name, value, priority == null ? "" : priority));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/text.js
+function textConstant4(value) {
+    return function() {
+        this.textContent = value;
+    };
+}
+
+function textFunction4(value) {
+    return function() {
+        var value1 = value(this);
+        this.textContent = value1 == null ? "" : value1;
+    };
+}
+
+function text_default5(value) {
+    return this.tween("text", typeof value === "function" ? textFunction4(tweenValue2(this, "text", value)) : textConstant4(value == null ? "" : value + ""));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/textTween.js
+function textInterpolate2(i) {
+    return function(t) {
+        this.textContent = i.call(this, t);
+    };
+}
+
+function textTween2(value) {
+    var t05, i0;
+
+    function tween() {
+        var i = value.apply(this, arguments);
+        if (i !== i0)
+            t05 = (i0 = i) && textInterpolate2(i);
+        return t05;
+    }
+    tween._value = value;
+    return tween;
+}
+
+function textTween_default2(value) {
+    var key = "text";
+    if (arguments.length < 1)
+        return (key = this.tween(key)) && key._value;
+    if (value == null)
+        return this.tween(key, null);
+    if (typeof value !== "function")
+        throw new Error();
+    return this.tween(key, textTween2(value));
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/transition.js
+function transition_default3() {
+    var name = this._name,
+        id0 = this._id,
+        id1 = newId2();
+    for (var groups3 = this._groups, m5 = groups3.length, j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                var inherit5 = get4(node, id0);
+                schedule_default2(node, name, id1, i, group5, {
+                    time: inherit5.time + inherit5.delay + inherit5.duration,
+                    delay: 0,
+                    duration: inherit5.duration,
+                    ease: inherit5.ease
+                });
+            }
+        }
+    }
+    return new Transition2(groups3, this._parents, name, id1);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/end.js
+function end_default2() {
+    var on0, on1, that = this,
+        id3 = that._id,
+        size = that.size();
+    return new Promise(function(resolve, reject) {
+        var cancel = {
+                value: reject
+            },
+            end = {
+                value: function() {
+                    if (--size === 0)
+                        resolve();
+                }
+            };
+        that.each(function() {
+            var schedule = set6(this, id3),
+                on = schedule.on;
+            if (on !== on0) {
+                on1 = (on0 = on).copy();
+                on1._.cancel.push(cancel);
+                on1._.interrupt.push(cancel);
+                on1._.end.push(end);
+            }
+            schedule.on = on1;
+        });
+        if (size === 0)
+            resolve();
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/transition/index.js
+var id2 = 0;
+
+function Transition2(groups3, parents, name, id3) {
+    this._groups = groups3;
+    this._parents = parents;
+    this._name = name;
+    this._id = id3;
+}
+
+function transition2(name) {
+    return selection_default3().transition(name);
+}
+
+function newId2() {
+    return ++id2;
+}
+var selection_prototype2 = selection_default3.prototype;
+Transition2.prototype = transition2.prototype = {
+    constructor: Transition2,
+    select: select_default6,
+    selectAll: selectAll_default6,
+    selectChild: selection_prototype2.selectChild,
+    selectChildren: selection_prototype2.selectChildren,
+    filter: filter_default4,
+    merge: merge_default4,
+    selection: selection_default4,
+    transition: transition_default3,
+    call: selection_prototype2.call,
+    nodes: selection_prototype2.nodes,
+    node: selection_prototype2.node,
+    size: selection_prototype2.size,
+    empty: selection_prototype2.empty,
+    each: selection_prototype2.each,
+    on: on_default4,
+    attr: attr_default4,
+    attrTween: attrTween_default2,
+    style: style_default4,
+    styleTween: styleTween_default2,
+    text: text_default5,
+    textTween: textTween_default2,
+    remove: remove_default5,
+    tween: tween_default2,
+    delay: delay_default2,
+    duration: duration_default2,
+    ease: ease_default2,
+    easeVarying: easeVarying_default2,
+    end: end_default2,
+    [Symbol.iterator]: selection_prototype2[Symbol.iterator]
+};
+
+// js/pyobsplot-js/node_modules/d3-ease/src/linear.js
+var linear5 = (t) => +t;
+
+// js/pyobsplot-js/node_modules/d3-ease/src/quad.js
+function quadIn2(t) {
+    return t * t;
+}
+
+function quadOut2(t) {
+    return t * (2 - t);
+}
+
+function quadInOut2(t) {
+    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/cubic.js
+function cubicIn2(t) {
+    return t * t * t;
+}
+
+function cubicOut2(t) {
+    return --t * t * t + 1;
+}
+
+function cubicInOut2(t) {
+    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/poly.js
+var exponent2 = 3;
+var polyIn2 = function custom19(e) {
+    e = +e;
+
+    function polyIn3(t) {
+        return Math.pow(t, e);
+    }
+    polyIn3.exponent = custom19;
+    return polyIn3;
+}(exponent2);
+var polyOut2 = function custom20(e) {
+    e = +e;
+
+    function polyOut3(t) {
+        return 1 - Math.pow(1 - t, e);
+    }
+    polyOut3.exponent = custom20;
+    return polyOut3;
+}(exponent2);
+var polyInOut2 = function custom21(e) {
+    e = +e;
+
+    function polyInOut3(t) {
+        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
+    }
+    polyInOut3.exponent = custom21;
+    return polyInOut3;
+}(exponent2);
+
+// js/pyobsplot-js/node_modules/d3-ease/src/sin.js
+var pi7 = Math.PI;
+var halfPi5 = pi7 / 2;
+
+function sinIn2(t) {
+    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi5);
+}
+
+function sinOut2(t) {
+    return Math.sin(t * halfPi5);
+}
+
+function sinInOut2(t) {
+    return (1 - Math.cos(pi7 * t)) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/math.js
+function tpmt2(x7) {
+    return (Math.pow(2, -10 * x7) - 9765625e-10) * 1.0009775171065494;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/exp.js
+function expIn2(t) {
+    return tpmt2(1 - +t);
+}
+
+function expOut2(t) {
+    return 1 - tpmt2(t);
+}
+
+function expInOut2(t) {
+    return ((t *= 2) <= 1 ? tpmt2(1 - t) : 2 - tpmt2(t - 1)) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/circle.js
+function circleIn2(t) {
+    return 1 - Math.sqrt(1 - t * t);
+}
+
+function circleOut2(t) {
+    return Math.sqrt(1 - --t * t);
+}
+
+function circleInOut2(t) {
+    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/bounce.js
+var b12 = 4 / 11;
+var b22 = 6 / 11;
+var b32 = 8 / 11;
+var b42 = 3 / 4;
+var b52 = 9 / 11;
+var b62 = 10 / 11;
+var b72 = 15 / 16;
+var b82 = 21 / 22;
+var b92 = 63 / 64;
+var b02 = 1 / b12 / b12;
+
+function bounceIn2(t) {
+    return 1 - bounceOut2(1 - t);
+}
+
+function bounceOut2(t) {
+    return (t = +t) < b12 ? b02 * t * t : t < b32 ? b02 * (t -= b22) * t + b42 : t < b62 ? b02 * (t -= b52) * t + b72 : b02 * (t -= b82) * t + b92;
+}
+
+function bounceInOut2(t) {
+    return ((t *= 2) <= 1 ? 1 - bounceOut2(1 - t) : bounceOut2(t - 1) + 1) / 2;
+}
+
+// js/pyobsplot-js/node_modules/d3-ease/src/back.js
+var overshoot2 = 1.70158;
+var backIn2 = function custom22(s3) {
+    s3 = +s3;
+
+    function backIn3(t) {
+        return (t = +t) * t * (s3 * (t - 1) + t);
+    }
+    backIn3.overshoot = custom22;
+    return backIn3;
+}(overshoot2);
+var backOut2 = function custom23(s3) {
+    s3 = +s3;
+
+    function backOut3(t) {
+        return --t * t * ((t + 1) * s3 + t) + 1;
+    }
+    backOut3.overshoot = custom23;
+    return backOut3;
+}(overshoot2);
+var backInOut2 = function custom24(s3) {
+    s3 = +s3;
+
+    function backInOut3(t) {
+        return ((t *= 2) < 1 ? t * t * ((s3 + 1) * t - s3) : (t -= 2) * t * ((s3 + 1) * t + s3) + 2) / 2;
+    }
+    backInOut3.overshoot = custom24;
+    return backInOut3;
+}(overshoot2);
+
+// js/pyobsplot-js/node_modules/d3-ease/src/elastic.js
+var tau8 = 2 * Math.PI;
+var amplitude2 = 1;
+var period2 = 0.3;
+var elasticIn2 = function custom25(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau8);
+
+    function elasticIn3(t) {
+        return a7 * tpmt2(- --t) * Math.sin((s3 - t) / p);
+    }
+    elasticIn3.amplitude = function(a8) {
+        return custom25(a8, p * tau8);
+    };
+    elasticIn3.period = function(p2) {
+        return custom25(a7, p2);
+    };
+    return elasticIn3;
+}(amplitude2, period2);
+var elasticOut2 = function custom26(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau8);
+
+    function elasticOut3(t) {
+        return 1 - a7 * tpmt2(t = +t) * Math.sin((t + s3) / p);
+    }
+    elasticOut3.amplitude = function(a8) {
+        return custom26(a8, p * tau8);
+    };
+    elasticOut3.period = function(p2) {
+        return custom26(a7, p2);
+    };
+    return elasticOut3;
+}(amplitude2, period2);
+var elasticInOut2 = function custom27(a7, p) {
+    var s3 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p /= tau8);
+
+    function elasticInOut3(t) {
+        return ((t = t * 2 - 1) < 0 ? a7 * tpmt2(-t) * Math.sin((s3 - t) / p) : 2 - a7 * tpmt2(t) * Math.sin((s3 + t) / p)) / 2;
+    }
+    elasticInOut3.amplitude = function(a8) {
+        return custom27(a8, p * tau8);
+    };
+    elasticInOut3.period = function(p2) {
+        return custom27(a7, p2);
+    };
+    return elasticInOut3;
+}(amplitude2, period2);
+
+// js/pyobsplot-js/node_modules/d3-transition/src/selection/transition.js
+var defaultTiming2 = {
+    time: null,
+    // Set on use.
+    delay: 0,
+    duration: 250,
+    ease: cubicInOut2
+};
+
+function inherit3(node, id3) {
+    var timing;
+    while (!(timing = node.__transition) || !(timing = timing[id3])) {
+        if (!(node = node.parentNode)) {
+            throw new Error(`transition ${id3} not found`);
+        }
+    }
+    return timing;
+}
+
+function transition_default4(name) {
+    var id3, timing;
+    if (name instanceof Transition2) {
+        id3 = name._id, name = name._name;
+    } else {
+        id3 = newId2(), (timing = defaultTiming2).time = now2(), name = name == null ? null : name + "";
+    }
+    for (var groups3 = this._groups, m5 = groups3.length, j = 0; j < m5; ++j) {
+        for (var group5 = groups3[j], n = group5.length, node, i = 0; i < n; ++i) {
+            if (node = group5[i]) {
+                schedule_default2(node, name, id3, i, group5, timing || inherit3(node, id3));
+            }
+        }
+    }
+    return new Transition2(groups3, this._parents, name, id3);
+}
+
+// js/pyobsplot-js/node_modules/d3-transition/src/selection/index.js
+selection_default3.prototype.interrupt = interrupt_default4;
+selection_default3.prototype.transition = transition_default4;
+
+// js/pyobsplot-js/node_modules/d3-transition/src/active.js
+var root4 = [null];
+
+function active_default2(node, name) {
+    var schedules = node.__transition,
+        schedule, i;
+    if (schedules) {
+        name = name == null ? null : name + "";
+        for (i in schedules) {
+            if ((schedule = schedules[i]).state > SCHEDULED2 && schedule.name === name) {
+                return new Transition2([
+                    [node]
+                ], root4, name, +i);
+            }
+        }
+    }
+    return null;
+}
+
+// js/pyobsplot-js/node_modules/d3-brush/src/constant.js
+var constant_default15 = (x7) => () => x7;
+
+// js/pyobsplot-js/node_modules/d3-brush/src/event.js
+function BrushEvent2(type3, {
+    sourceEvent,
+    target,
+    selection: selection3,
+    mode: mode3,
+    dispatch: dispatch3
+}) {
+    Object.defineProperties(this, {
+        type: {
+            value: type3,
+            enumerable: true,
+            configurable: true
+        },
+        sourceEvent: {
+            value: sourceEvent,
+            enumerable: true,
+            configurable: true
+        },
+        target: {
+            value: target,
+            enumerable: true,
+            configurable: true
+        },
+        selection: {
+            value: selection3,
+            enumerable: true,
+            configurable: true
+        },
+        mode: {
+            value: mode3,
+            enumerable: true,
+            configurable: true
+        },
+        _: {
+            value: dispatch3
+        }
+    });
+}
+
+// js/pyobsplot-js/node_modules/d3-brush/src/noevent.js
+function nopropagation5(event) {
+    event.stopImmediatePropagation();
+}
+
+function noevent_default5(event) {
+    event.preventDefault();
+    event.stopImmediatePropagation();
+}
+
+// js/pyobsplot-js/node_modules/d3-brush/src/brush.js
+var MODE_DRAG2 = {
+    name: "drag"
+};
+var MODE_SPACE2 = {
+    name: "space"
+};
+var MODE_HANDLE2 = {
+    name: "handle"
+};
+var MODE_CENTER2 = {
+    name: "center"
+};
+var {
+    abs: abs5,
+    max: max6,
+    min: min5
+} = Math;
+
+function number12(e) {
+    return [+e[0], +e[1]];
+}
+
+function number23(e) {
+    return [number12(e[0]), number12(e[1])];
+}
+var X3 = {
+    name: "x",
+    handles: ["w", "e"].map(type2),
+    input: function(x7, e) {
+        return x7 == null ? null : [
+            [+x7[0], e[0][1]],
+            [+x7[1], e[1][1]]
+        ];
+    },
+    output: function(xy) {
+        return xy && [xy[0][0], xy[1][0]];
+    }
+};
+var Y3 = {
+    name: "y",
+    handles: ["n", "s"].map(type2),
+    input: function(y7, e) {
+        return y7 == null ? null : [
+            [e[0][0], +y7[0]],
+            [e[1][0], +y7[1]]
+        ];
+    },
+    output: function(xy) {
+        return xy && [xy[0][1], xy[1][1]];
+    }
+};
+var XY2 = {
+    name: "xy",
+    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type2),
+    input: function(xy) {
+        return xy == null ? null : number23(xy);
+    },
+    output: function(xy) {
+        return xy;
+    }
+};
+var cursors2 = {
+    overlay: "crosshair",
+    selection: "move",
+    n: "ns-resize",
+    e: "ew-resize",
+    s: "ns-resize",
+    w: "ew-resize",
+    nw: "nwse-resize",
+    ne: "nesw-resize",
+    se: "nwse-resize",
+    sw: "nesw-resize"
+};
+var flipX2 = {
+    e: "w",
+    w: "e",
+    nw: "ne",
+    ne: "nw",
+    se: "sw",
+    sw: "se"
+};
+var flipY2 = {
+    n: "s",
+    s: "n",
+    nw: "sw",
+    ne: "se",
+    se: "ne",
+    sw: "nw"
+};
+var signsX2 = {
+    overlay: 1,
+    selection: 1,
+    n: null,
+    e: 1,
+    s: null,
+    w: -1,
+    nw: -1,
+    ne: 1,
+    se: 1,
+    sw: -1
+};
+var signsY2 = {
+    overlay: 1,
+    selection: 1,
+    n: -1,
+    e: null,
+    s: 1,
+    w: null,
+    nw: -1,
+    ne: -1,
+    se: 1,
+    sw: 1
+};
+
+function type2(t) {
+    return {
+        type: t
+    };
+}
+
+function defaultFilter5(event) {
+    return !event.ctrlKey && !event.button;
+}
+
+function defaultExtent3() {
+    var svg3 = this.ownerSVGElement || this;
+    if (svg3.hasAttribute("viewBox")) {
+        svg3 = svg3.viewBox.baseVal;
+        return [
+            [svg3.x, svg3.y],
+            [svg3.x + svg3.width, svg3.y + svg3.height]
+        ];
+    }
+    return [
+        [0, 0],
+        [svg3.width.baseVal.value, svg3.height.baseVal.value]
+    ];
+}
+
+function defaultTouchable5() {
+    return navigator.maxTouchPoints || "ontouchstart" in this;
+}
+
+function local4(node) {
+    while (!node.__brush)
+        if (!(node = node.parentNode))
+            return;
+    return node.__brush;
+}
+
+function empty6(extent5) {
+    return extent5[0][0] === extent5[1][0] || extent5[0][1] === extent5[1][1];
+}
+
+function brushSelection2(node) {
+    var state = node.__brush;
+    return state ? state.dim.output(state.selection) : null;
+}
+
+function brushX2() {
+    return brush2(X3);
+}
+
+function brushY2() {
+    return brush2(Y3);
+}
+
+function brush_default2() {
+    return brush2(XY2);
+}
+
+function brush2(dim) {
+    var extent5 = defaultExtent3,
+        filter7 = defaultFilter5,
+        touchable = defaultTouchable5,
+        keys = true,
+        listeners = dispatch_default3("start", "brush", "end"),
+        handleSize = 6,
+        touchending;
+
+    function brush3(group5) {
+        var overlay = group5.property("__brush", initialize).selectAll(".overlay").data([type2("overlay")]);
+        overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors2.overlay).merge(overlay).each(function() {
+            var extent6 = local4(this).extent;
+            select_default5(this).attr("x", extent6[0][0]).attr("y", extent6[0][1]).attr("width", extent6[1][0] - extent6[0][0]).attr("height", extent6[1][1] - extent6[0][1]);
+        });
+        group5.selectAll(".selection").data([type2("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors2.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
+        var handle = group5.selectAll(".handle").data(dim.handles, function(d) {
+            return d.type;
+        });
+        handle.exit().remove();
+        handle.enter().append("rect").attr("class", function(d) {
+            return "handle handle--" + d.type;
+        }).attr("cursor", function(d) {
+            return cursors2[d.type];
+        });
+        group5.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+    }
+    brush3.move = function(group5, selection3, event) {
+        if (group5.tween) {
+            group5.on("start.brush", function(event2) {
+                emitter(this, arguments).beforestart().start(event2);
+            }).on("interrupt.brush end.brush", function(event2) {
+                emitter(this, arguments).end(event2);
+            }).tween("brush", function() {
+                var that = this,
+                    state = that.__brush,
+                    emit = emitter(that, arguments),
+                    selection0 = state.selection,
+                    selection1 = dim.input(typeof selection3 === "function" ? selection3.apply(this, arguments) : selection3, state.extent),
+                    i = value_default2(selection0, selection1);
+
+                function tween(t) {
+                    state.selection = t === 1 && selection1 === null ? null : i(t);
+                    redraw.call(that);
+                    emit.brush();
+                }
+                return selection0 !== null && selection1 !== null ? tween : tween(1);
+            });
+        } else {
+            group5.each(function() {
+                var that = this,
+                    args = arguments,
+                    state = that.__brush,
+                    selection1 = dim.input(typeof selection3 === "function" ? selection3.apply(that, args) : selection3, state.extent),
+                    emit = emitter(that, args).beforestart();
+                interrupt_default3(that);
+                state.selection = selection1 === null ? null : selection1;
+                redraw.call(that);
+                emit.start(event).brush(event).end(event);
+            });
+        }
+    };
+    brush3.clear = function(group5, event) {
+        brush3.move(group5, null, event);
+    };
+
+    function redraw() {
+        var group5 = select_default5(this),
+            selection3 = local4(this).selection;
+        if (selection3) {
+            group5.selectAll(".selection").style("display", null).attr("x", selection3[0][0]).attr("y", selection3[0][1]).attr("width", selection3[1][0] - selection3[0][0]).attr("height", selection3[1][1] - selection3[0][1]);
+            group5.selectAll(".handle").style("display", null).attr("x", function(d) {
+                return d.type[d.type.length - 1] === "e" ? selection3[1][0] - handleSize / 2 : selection3[0][0] - handleSize / 2;
+            }).attr("y", function(d) {
+                return d.type[0] === "s" ? selection3[1][1] - handleSize / 2 : selection3[0][1] - handleSize / 2;
+            }).attr("width", function(d) {
+                return d.type === "n" || d.type === "s" ? selection3[1][0] - selection3[0][0] + handleSize : handleSize;
+            }).attr("height", function(d) {
+                return d.type === "e" || d.type === "w" ? selection3[1][1] - selection3[0][1] + handleSize : handleSize;
+            });
+        } else {
+            group5.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
+        }
+    }
+
+    function emitter(that, args, clean) {
+        var emit = that.__brush.emitter;
+        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
+    }
+
+    function Emitter(that, args, clean) {
+        this.that = that;
+        this.args = args;
+        this.state = that.__brush;
+        this.active = 0;
+        this.clean = clean;
+    }
+    Emitter.prototype = {
+        beforestart: function() {
+            if (++this.active === 1)
+                this.state.emitter = this, this.starting = true;
+            return this;
+        },
+        start: function(event, mode3) {
+            if (this.starting)
+                this.starting = false, this.emit("start", event, mode3);
+            else
+                this.emit("brush", event);
+            return this;
+        },
+        brush: function(event, mode3) {
+            this.emit("brush", event, mode3);
+            return this;
+        },
+        end: function(event, mode3) {
+            if (--this.active === 0)
+                delete this.state.emitter, this.emit("end", event, mode3);
+            return this;
+        },
+        emit: function(type3, event, mode3) {
+            var d = select_default5(this.that).datum();
+            listeners.call(
+                type3,
+                this.that,
+                new BrushEvent2(type3, {
+                    sourceEvent: event,
+                    target: brush3,
+                    selection: dim.output(this.state.selection),
+                    mode: mode3,
+                    dispatch: listeners
+                }),
+                d
+            );
+        }
+    };
+
+    function started(event) {
+        if (touchending && !event.touches)
+            return;
+        if (!filter7.apply(this, arguments))
+            return;
+        var that = this,
+            type3 = event.target.__data__.type,
+            mode3 = (keys && event.metaKey ? type3 = "overlay" : type3) === "selection" ? MODE_DRAG2 : keys && event.altKey ? MODE_CENTER2 : MODE_HANDLE2,
+            signX = dim === Y3 ? null : signsX2[type3],
+            signY = dim === X3 ? null : signsY2[type3],
+            state = local4(that),
+            extent6 = state.extent,
+            selection3 = state.selection,
+            W = extent6[0][0],
+            w0, w1, N = extent6[0][1],
+            n0, n1, E3 = extent6[1][0],
+            e0, e1, S = extent6[1][1],
+            s0, s1, dx = 0,
+            dy = 0,
+            moving, shifting = signX && signY && keys && event.shiftKey,
+            lockX, lockY, points = Array.from(event.touches || [event], (t) => {
+                const i = t.identifier;
+                t = pointer_default2(t, that);
+                t.point0 = t.slice();
+                t.identifier = i;
+                return t;
+            });
+        interrupt_default3(that);
+        var emit = emitter(that, arguments, true).beforestart();
+        if (type3 === "overlay") {
+            if (selection3)
+                moving = true;
+            const pts = [points[0], points[1] || points[0]];
+            state.selection = selection3 = [
+                [
+                    w0 = dim === Y3 ? W : min5(pts[0][0], pts[1][0]),
+                    n0 = dim === X3 ? N : min5(pts[0][1], pts[1][1])
+                ],
+                [
+                    e0 = dim === Y3 ? E3 : max6(pts[0][0], pts[1][0]),
+                    s0 = dim === X3 ? S : max6(pts[0][1], pts[1][1])
+                ]
+            ];
+            if (points.length > 1)
+                move(event);
+        } else {
+            w0 = selection3[0][0];
+            n0 = selection3[0][1];
+            e0 = selection3[1][0];
+            s0 = selection3[1][1];
+        }
+        w1 = w0;
+        n1 = n0;
+        e1 = e0;
+        s1 = s0;
+        var group5 = select_default5(that).attr("pointer-events", "none");
+        var overlay = group5.selectAll(".overlay").attr("cursor", cursors2[type3]);
+        if (event.touches) {
+            emit.moved = moved;
+            emit.ended = ended;
+        } else {
+            var view = select_default5(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
+            if (keys)
+                view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
+            nodrag_default2(event.view);
+        }
+        redraw.call(that);
+        emit.start(event, mode3.name);
+
+        function moved(event2) {
+            for (const p of event2.changedTouches || [event2]) {
+                for (const d of points)
+                    if (d.identifier === p.identifier)
+                        d.cur = pointer_default2(p, that);
+            }
+            if (shifting && !lockX && !lockY && points.length === 1) {
+                const point11 = points[0];
+                if (abs5(point11.cur[0] - point11[0]) > abs5(point11.cur[1] - point11[1]))
+                    lockY = true;
+                else
+                    lockX = true;
+            }
+            for (const point11 of points)
+                if (point11.cur)
+                    point11[0] = point11.cur[0], point11[1] = point11.cur[1];
+            moving = true;
+            noevent_default5(event2);
+            move(event2);
+        }
+
+        function move(event2) {
+            const point11 = points[0],
+                point0 = point11.point0;
+            var t;
+            dx = point11[0] - point0[0];
+            dy = point11[1] - point0[1];
+            switch (mode3) {
+                case MODE_SPACE2:
+                case MODE_DRAG2: {
+                    if (signX)
+                        dx = max6(W - w0, min5(E3 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
+                    if (signY)
+                        dy = max6(N - n0, min5(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
+                    break;
+                }
+                case MODE_HANDLE2: {
+                    if (points[1]) {
+                        if (signX)
+                            w1 = max6(W, min5(E3, points[0][0])), e1 = max6(W, min5(E3, points[1][0])), signX = 1;
+                        if (signY)
+                            n1 = max6(N, min5(S, points[0][1])), s1 = max6(N, min5(S, points[1][1])), signY = 1;
+                    } else {
+                        if (signX < 0)
+                            dx = max6(W - w0, min5(E3 - w0, dx)), w1 = w0 + dx, e1 = e0;
+                        else if (signX > 0)
+                            dx = max6(W - e0, min5(E3 - e0, dx)), w1 = w0, e1 = e0 + dx;
+                        if (signY < 0)
+                            dy = max6(N - n0, min5(S - n0, dy)), n1 = n0 + dy, s1 = s0;
+                        else if (signY > 0)
+                            dy = max6(N - s0, min5(S - s0, dy)), n1 = n0, s1 = s0 + dy;
+                    }
+                    break;
+                }
+                case MODE_CENTER2: {
+                    if (signX)
+                        w1 = max6(W, min5(E3, w0 - dx * signX)), e1 = max6(W, min5(E3, e0 + dx * signX));
+                    if (signY)
+                        n1 = max6(N, min5(S, n0 - dy * signY)), s1 = max6(N, min5(S, s0 + dy * signY));
+                    break;
+                }
+            }
+            if (e1 < w1) {
+                signX *= -1;
+                t = w0, w0 = e0, e0 = t;
+                t = w1, w1 = e1, e1 = t;
+                if (type3 in flipX2)
+                    overlay.attr("cursor", cursors2[type3 = flipX2[type3]]);
+            }
+            if (s1 < n1) {
+                signY *= -1;
+                t = n0, n0 = s0, s0 = t;
+                t = n1, n1 = s1, s1 = t;
+                if (type3 in flipY2)
+                    overlay.attr("cursor", cursors2[type3 = flipY2[type3]]);
+            }
+            if (state.selection)
+                selection3 = state.selection;
+            if (lockX)
+                w1 = selection3[0][0], e1 = selection3[1][0];
+            if (lockY)
+                n1 = selection3[0][1], s1 = selection3[1][1];
+            if (selection3[0][0] !== w1 || selection3[0][1] !== n1 || selection3[1][0] !== e1 || selection3[1][1] !== s1) {
+                state.selection = [
+                    [w1, n1],
+                    [e1, s1]
+                ];
+                redraw.call(that);
+                emit.brush(event2, mode3.name);
+            }
+        }
+
+        function ended(event2) {
+            nopropagation5(event2);
+            if (event2.touches) {
+                if (event2.touches.length)
+                    return;
+                if (touchending)
+                    clearTimeout(touchending);
+                touchending = setTimeout(function() {
+                    touchending = null;
+                }, 500);
+            } else {
+                yesdrag2(event2.view, moving);
+                view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
+            }
+            group5.attr("pointer-events", "all");
+            overlay.attr("cursor", cursors2.overlay);
+            if (state.selection)
+                selection3 = state.selection;
+            if (empty6(selection3))
+                state.selection = null, redraw.call(that);
+            emit.end(event2, mode3.name);
+        }
+
+        function keydowned(event2) {
+            switch (event2.keyCode) {
+                case 16: {
+                    shifting = signX && signY;
+                    break;
+                }
+                case 18: {
+                    if (mode3 === MODE_HANDLE2) {
+                        if (signX)
+                            e0 = e1 - dx * signX, w0 = w1 + dx * signX;
+                        if (signY)
+                            s0 = s1 - dy * signY, n0 = n1 + dy * signY;
+                        mode3 = MODE_CENTER2;
+                        move(event2);
+                    }
+                    break;
+                }
+                case 32: {
+                    if (mode3 === MODE_HANDLE2 || mode3 === MODE_CENTER2) {
+                        if (signX < 0)
+                            e0 = e1 - dx;
+                        else if (signX > 0)
+                            w0 = w1 - dx;
+                        if (signY < 0)
+                            s0 = s1 - dy;
+                        else if (signY > 0)
+                            n0 = n1 - dy;
+                        mode3 = MODE_SPACE2;
+                        overlay.attr("cursor", cursors2.selection);
+                        move(event2);
+                    }
+                    break;
+                }
+                default:
+                    return;
+            }
+            noevent_default5(event2);
+        }
+
+        function keyupped(event2) {
+            switch (event2.keyCode) {
+                case 16: {
+                    if (shifting) {
+                        lockX = lockY = shifting = false;
+                        move(event2);
+                    }
+                    break;
+                }
+                case 18: {
+                    if (mode3 === MODE_CENTER2) {
+                        if (signX < 0)
+                            e0 = e1;
+                        else if (signX > 0)
+                            w0 = w1;
+                        if (signY < 0)
+                            s0 = s1;
+                        else if (signY > 0)
+                            n0 = n1;
+                        mode3 = MODE_HANDLE2;
+                        move(event2);
+                    }
+                    break;
+                }
+                case 32: {
+                    if (mode3 === MODE_SPACE2) {
+                        if (event2.altKey) {
+                            if (signX)
+                                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
+                            if (signY)
+                                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
+                            mode3 = MODE_CENTER2;
+                        } else {
+                            if (signX < 0)
+                                e0 = e1;
+                            else if (signX > 0)
+                                w0 = w1;
+                            if (signY < 0)
+                                s0 = s1;
+                            else if (signY > 0)
+                                n0 = n1;
+                            mode3 = MODE_HANDLE2;
+                        }
+                        overlay.attr("cursor", cursors2[type3]);
+                        move(event2);
+                    }
+                    break;
+                }
+                default:
+                    return;
+            }
+            noevent_default5(event2);
+        }
+    }
+
+    function touchmoved(event) {
+        emitter(this, arguments).moved(event);
+    }
+
+    function touchended(event) {
+        emitter(this, arguments).ended(event);
+    }
+
+    function initialize() {
+        var state = this.__brush || {
+            selection: null
+        };
+        state.extent = number23(extent5.apply(this, arguments));
+        state.dim = dim;
+        return state;
+    }
+    brush3.extent = function(_) {
+        return arguments.length ? (extent5 = typeof _ === "function" ? _ : constant_default15(number23(_)), brush3) : extent5;
+    };
+    brush3.filter = function(_) {
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default15(!!_), brush3) : filter7;
+    };
+    brush3.touchable = function(_) {
+        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default15(!!_), brush3) : touchable;
+    };
+    brush3.handleSize = function(_) {
+        return arguments.length ? (handleSize = +_, brush3) : handleSize;
+    };
+    brush3.keyModifiers = function(_) {
+        return arguments.length ? (keys = !!_, brush3) : keys;
+    };
+    brush3.on = function() {
+        var value = listeners.on.apply(listeners, arguments);
+        return value === listeners ? brush3 : value;
+    };
+    return brush3;
+}
+
+// js/pyobsplot-js/node_modules/d3-chord/src/math.js
+var abs6 = Math.abs;
+var cos4 = Math.cos;
+var sin4 = Math.sin;
+var pi8 = Math.PI;
+var halfPi6 = pi8 / 2;
+var tau9 = pi8 * 2;
+var max7 = Math.max;
+var epsilon10 = 1e-12;
+
+// js/pyobsplot-js/node_modules/d3-chord/src/chord.js
+function range6(i, j) {
+    return Array.from({
+        length: j - i
+    }, (_, k3) => i + k3);
+}
+
+function compareValue2(compare) {
+    return function(a7, b) {
+        return compare(
+            a7.source.value + a7.target.value,
+            b.source.value + b.target.value
+        );
+    };
+}
+
+function chord_default2() {
+    return chord2(false, false);
+}
+
+function chordTranspose2() {
+    return chord2(false, true);
+}
+
+function chordDirected2() {
+    return chord2(true, false);
+}
+
+function chord2(directed, transpose3) {
+    var padAngle = 0,
+        sortGroups = null,
+        sortSubgroups = null,
+        sortChords = null;
+
+    function chord3(matrix) {
+        var n = matrix.length,
+            groupSums = new Array(n),
+            groupIndex3 = range6(0, n),
+            chords = new Array(n * n),
+            groups3 = new Array(n),
+            k3 = 0,
+            dx;
+        matrix = Float64Array.from({
+            length: n * n
+        }, transpose3 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);
+        for (let i = 0; i < n; ++i) {
+            let x7 = 0;
+            for (let j = 0; j < n; ++j)
+                x7 += matrix[i * n + j] + directed * matrix[j * n + i];
+            k3 += groupSums[i] = x7;
+        }
+        k3 = max7(0, tau9 - padAngle * n) / k3;
+        dx = k3 ? padAngle : tau9 / n; {
+            let x7 = 0;
+            if (sortGroups)
+                groupIndex3.sort((a7, b) => sortGroups(groupSums[a7], groupSums[b]));
+            for (const i of groupIndex3) {
+                const x011 = x7;
+                if (directed) {
+                    const subgroupIndex = range6(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
+                    if (sortSubgroups)
+                        subgroupIndex.sort((a7, b) => sortSubgroups(a7 < 0 ? -matrix[~a7 * n + i] : matrix[i * n + a7], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
+                    for (const j of subgroupIndex) {
+                        if (j < 0) {
+                            const chord4 = chords[~j * n + i] || (chords[~j * n + i] = {
+                                source: null,
+                                target: null
+                            });
+                            chord4.target = {
+                                index: i,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[~j * n + i] * k3,
+                                value: matrix[~j * n + i]
+                            };
+                        } else {
+                            const chord4 = chords[i * n + j] || (chords[i * n + j] = {
+                                source: null,
+                                target: null
+                            });
+                            chord4.source = {
+                                index: i,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
+                                value: matrix[i * n + j]
+                            };
+                        }
+                    }
+                    groups3[i] = {
+                        index: i,
+                        startAngle: x011,
+                        endAngle: x7,
+                        value: groupSums[i]
+                    };
+                } else {
+                    const subgroupIndex = range6(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);
+                    if (sortSubgroups)
+                        subgroupIndex.sort((a7, b) => sortSubgroups(matrix[i * n + a7], matrix[i * n + b]));
+                    for (const j of subgroupIndex) {
+                        let chord4;
+                        if (i < j) {
+                            chord4 = chords[i * n + j] || (chords[i * n + j] = {
+                                source: null,
+                                target: null
+                            });
+                            chord4.source = {
+                                index: i,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
+                                value: matrix[i * n + j]
+                            };
+                        } else {
+                            chord4 = chords[j * n + i] || (chords[j * n + i] = {
+                                source: null,
+                                target: null
+                            });
+                            chord4.target = {
+                                index: i,
+                                startAngle: x7,
+                                endAngle: x7 += matrix[i * n + j] * k3,
+                                value: matrix[i * n + j]
+                            };
+                            if (i === j)
+                                chord4.source = chord4.target;
+                        }
+                        if (chord4.source && chord4.target && chord4.source.value < chord4.target.value) {
+                            const source = chord4.source;
+                            chord4.source = chord4.target;
+                            chord4.target = source;
+                        }
+                    }
+                    groups3[i] = {
+                        index: i,
+                        startAngle: x011,
+                        endAngle: x7,
+                        value: groupSums[i]
+                    };
+                }
+                x7 += dx;
+            }
+        }
+        chords = Object.values(chords);
+        chords.groups = groups3;
+        return sortChords ? chords.sort(sortChords) : chords;
+    }
+    chord3.padAngle = function(_) {
+        return arguments.length ? (padAngle = max7(0, _), chord3) : padAngle;
+    };
+    chord3.sortGroups = function(_) {
+        return arguments.length ? (sortGroups = _, chord3) : sortGroups;
+    };
+    chord3.sortSubgroups = function(_) {
+        return arguments.length ? (sortSubgroups = _, chord3) : sortSubgroups;
+    };
+    chord3.sortChords = function(_) {
+        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue2(_))._ = _, chord3) : sortChords && sortChords._;
+    };
+    return chord3;
+}
+
+// js/pyobsplot-js/node_modules/d3-path/src/path.js
+var pi9 = Math.PI;
+var tau10 = 2 * pi9;
+var epsilon11 = 1e-6;
+var tauEpsilon2 = tau10 - epsilon11;
+
+function append3(strings) {
+    this._ += strings[0];
+    for (let i = 1, n = strings.length; i < n; ++i) {
+        this._ += arguments[i] + strings[i];
+    }
+}
+
+function appendRound3(digits) {
+    let d = Math.floor(digits);
+    if (!(d >= 0))
+        throw new Error(`invalid digits: ${digits}`);
+    if (d > 15)
+        return append3;
+    const k3 = 10 ** d;
+    return function(strings) {
+        this._ += strings[0];
+        for (let i = 1, n = strings.length; i < n; ++i) {
+            this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
+        }
+    };
+}
+var Path3 = class {
+    constructor(digits) {
+        this._x0 = this._y0 = // start of current subpath
+            this._x1 = this._y1 = null;
+        this._ = "";
+        this._append = digits == null ? append3 : appendRound3(digits);
+    }
+    moveTo(x7, y7) {
+        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
+    }
+    closePath() {
+        if (this._x1 !== null) {
+            this._x1 = this._x0, this._y1 = this._y0;
+            this._append`Z`;
+        }
+    }
+    lineTo(x7, y7) {
+        this._append`L${this._x1 = +x7},${this._y1 = +y7}`;
+    }
+    quadraticCurveTo(x13, y13, x7, y7) {
+        this._append`Q${+x13},${+y13},${this._x1 = +x7},${this._y1 = +y7}`;
+    }
+    bezierCurveTo(x13, y13, x22, y22, x7, y7) {
+        this._append`C${+x13},${+y13},${+x22},${+y22},${this._x1 = +x7},${this._y1 = +y7}`;
+    }
+    arcTo(x13, y13, x22, y22, r) {
+        x13 = +x13, y13 = +y13, x22 = +x22, y22 = +y22, r = +r;
+        if (r < 0)
+            throw new Error(`negative radius: ${r}`);
+        let x011 = this._x1,
+            y011 = this._y1,
+            x21 = x22 - x13,
+            y21 = y22 - y13,
+            x01 = x011 - x13,
+            y01 = y011 - y13,
+            l01_2 = x01 * x01 + y01 * y01;
+        if (this._x1 === null) {
+            this._append`M${this._x1 = x13},${this._y1 = y13}`;
+        } else if (!(l01_2 > epsilon11))
+        ;
+        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon11) || !r) {
+            this._append`L${this._x1 = x13},${this._y1 = y13}`;
+        } else {
+            let x20 = x22 - x011,
+                y20 = y22 - y011,
+                l21_2 = x21 * x21 + y21 * y21,
+                l20_2 = x20 * x20 + y20 * y20,
+                l21 = Math.sqrt(l21_2),
+                l01 = Math.sqrt(l01_2),
+                l = r * Math.tan((pi9 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
+                t01 = l / l01,
+                t21 = l / l21;
+            if (Math.abs(t01 - 1) > epsilon11) {
+                this._append`L${x13 + t01 * x01},${y13 + t01 * y01}`;
+            }
+            this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x13 + t21 * x21},${this._y1 = y13 + t21 * y21}`;
+        }
+    }
+    arc(x7, y7, r, a0, a1, ccw) {
+        x7 = +x7, y7 = +y7, r = +r, ccw = !!ccw;
+        if (r < 0)
+            throw new Error(`negative radius: ${r}`);
+        let dx = r * Math.cos(a0),
+            dy = r * Math.sin(a0),
+            x011 = x7 + dx,
+            y011 = y7 + dy,
+            cw = 1 ^ ccw,
+            da3 = ccw ? a0 - a1 : a1 - a0;
+        if (this._x1 === null) {
+            this._append`M${x011},${y011}`;
+        } else if (Math.abs(this._x1 - x011) > epsilon11 || Math.abs(this._y1 - y011) > epsilon11) {
+            this._append`L${x011},${y011}`;
+        }
+        if (!r)
+            return;
+        if (da3 < 0)
+            da3 = da3 % tau10 + tau10;
+        if (da3 > tauEpsilon2) {
+            this._append`A${r},${r},0,1,${cw},${x7 - dx},${y7 - dy}A${r},${r},0,1,${cw},${this._x1 = x011},${this._y1 = y011}`;
+        } else if (da3 > epsilon11) {
+            this._append`A${r},${r},0,${+(da3 >= pi9)},${cw},${this._x1 = x7 + r * Math.cos(a1)},${this._y1 = y7 + r * Math.sin(a1)}`;
+        }
+    }
+    rect(x7, y7, w, h) {
+        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${w = +w}v${+h}h${-w}Z`;
+    }
+    toString() {
+        return this._;
+    }
+};
+
+function path2() {
+    return new Path3();
+}
+path2.prototype = Path3.prototype;
+
+function pathRound2(digits = 3) {
+    return new Path3(+digits);
+}
+
+// js/pyobsplot-js/node_modules/d3-chord/src/array.js
+var slice8 = Array.prototype.slice;
+
+// js/pyobsplot-js/node_modules/d3-chord/src/constant.js
+function constant_default16(x7) {
+    return function() {
+        return x7;
+    };
+}
+
+// js/pyobsplot-js/node_modules/d3-chord/src/ribbon.js
+function defaultSource2(d) {
+    return d.source;
+}
+
+function defaultTarget2(d) {
+    return d.target;
+}
+
+function defaultRadius4(d) {
+    return d.radius;
+}
+
+function defaultStartAngle2(d) {
+    return d.startAngle;
+}
+
+function defaultEndAngle2(d) {
+    return d.endAngle;
+}
+
+function defaultPadAngle2() {
+    return 0;
+}
+
+function defaultArrowheadRadius2() {
+    return 10;
+}
+
+function ribbon2(headRadius) {
+    var source = defaultSource2,
+        target = defaultTarget2,
+        sourceRadius = defaultRadius4,
+        targetRadius = defaultRadius4,
+        startAngle = defaultStartAngle2,
+        endAngle = defaultEndAngle2,
+        padAngle = defaultPadAngle2,
+        context = null;
+
+    function ribbon3() {
+        var buffer, s3 = source.apply(this, arguments),
+            t = target.apply(this, arguments),
+            ap = padAngle.apply(this, arguments) / 2,
+            argv = slice8.call(arguments),
+            sr = +sourceRadius.apply(this, (argv[0] = s3, argv)),
+            sa0 = startAngle.apply(this, argv) - halfPi6,
+            sa1 = endAngle.apply(this, argv) - halfPi6,
+            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
+            ta0 = startAngle.apply(this, argv) - halfPi6,
+            ta1 = endAngle.apply(this, argv) - halfPi6;
+        if (!context)
+            context = buffer = path2();
+        if (ap > epsilon10) {
+            if (abs6(sa1 - sa0) > ap * 2 + epsilon10)
+                sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
+            else
+                sa0 = sa1 = (sa0 + sa1) / 2;
+            if (abs6(ta1 - ta0) > ap * 2 + epsilon10)
+                ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
+            else
+                ta0 = ta1 = (ta0 + ta1) / 2;
+        }
+        context.moveTo(sr * cos4(sa0), sr * sin4(sa0));
+        context.arc(0, 0, sr, sa0, sa1);
+        if (sa0 !== ta0 || sa1 !== ta1) {
+            if (headRadius) {
+                var hr = +headRadius.apply(this, arguments),
+                    tr2 = tr - hr,
+                    ta2 = (ta0 + ta1) / 2;
+                context.quadraticCurveTo(0, 0, tr2 * cos4(ta0), tr2 * sin4(ta0));
+                context.lineTo(tr * cos4(ta2), tr * sin4(ta2));
+                context.lineTo(tr2 * cos4(ta1), tr2 * sin4(ta1));
+            } else {
+                context.quadraticCurveTo(0, 0, tr * cos4(ta0), tr * sin4(ta0));
+                context.arc(0, 0, tr, ta0, ta1);
+            }
+        }
+        context.quadraticCurveTo(0, 0, sr * cos4(sa0), sr * sin4(sa0));
+        context.closePath();
+        if (buffer)
+            return context = null, buffer + "" || null;
+    }
+    if (headRadius)
+        ribbon3.headRadius = function(_) {
+            return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : headRadius;
+        };
+    ribbon3.radius = function(_) {
+        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : sourceRadius;
+    };
+    ribbon3.sourceRadius = function(_) {
+        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : sourceRadius;
+    };
+    ribbon3.targetRadius = function(_) {
+        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : targetRadius;
+    };
+    ribbon3.startAngle = function(_) {
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : startAngle;
+    };
+    ribbon3.endAngle = function(_) {
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : endAngle;
+    };
+    ribbon3.padAngle = function(_) {
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default16(+_), ribbon3) : padAngle;
+    };
+    ribbon3.source = function(_) {
+        return arguments.length ? (source = _, ribbon3) : source;
+    };
+    ribbon3.target = function(_) {
+        return arguments.length ? (target = _, ribbon3) : target;
+    };
+    ribbon3.context = function(_) {
+        return arguments.length ? (context = _ == null ? null : _, ribbon3) : context;
+    };
+    return ribbon3;
+}
+
+function ribbon_default2() {
+    return ribbon2();
+}
+
+function ribbonArrow2() {
+    return ribbon2(defaultArrowheadRadius2);
+}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/array.js
+var array6 = Array.prototype;
+var slice9 = array6.slice;
+
+// js/pyobsplot-js/node_modules/d3-contour/src/ascending.js
+function ascending_default3(a7, b) {
+    return a7 - b;
+}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/area.js
+function area_default6(ring) {
+    var i = 0,
+        n = ring.length,
+        area3 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
+    while (++i < n)
+        area3 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
+    return area3;
+}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/constant.js
+var constant_default17 = (x7) => () => x7;
+
+// js/pyobsplot-js/node_modules/d3-contour/src/contains.js
+function contains_default4(ring, hole) {
+    var i = -1,
+        n = hole.length,
+        c11;
+    while (++i < n)
+        if (c11 = ringContains2(ring, hole[i]))
+            return c11;
+    return 0;
+}
+
+function ringContains2(ring, point11) {
+    var x7 = point11[0],
+        y7 = point11[1],
+        contains = -1;
+    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
+        var pi13 = ring[i],
+            xi = pi13[0],
+            yi = pi13[1],
+            pj = ring[j],
+            xj = pj[0],
+            yj = pj[1];
+        if (segmentContains2(pi13, pj, point11))
+            return 0;
+        if (yi > y7 !== yj > y7 && x7 < (xj - xi) * (y7 - yi) / (yj - yi) + xi)
+            contains = -contains;
+    }
+    return contains;
+}
+
+function segmentContains2(a7, b, c11) {
+    var i;
+    return collinear3(a7, b, c11) && within2(a7[i = +(a7[0] === b[0])], c11[i], b[i]);
+}
+
+function collinear3(a7, b, c11) {
+    return (b[0] - a7[0]) * (c11[1] - a7[1]) === (c11[0] - a7[0]) * (b[1] - a7[1]);
+}
+
+function within2(p, q, r) {
+    return p <= q && q <= r || r <= q && q <= p;
+}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/noop.js
+function noop_default3() {}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/contours.js
+var cases2 = [
+    [],
+    [
+        [
+            [1, 1.5],
+            [0.5, 1]
+        ]
+    ],
+    [
+        [
+            [1.5, 1],
+            [1, 1.5]
+        ]
+    ],
+    [
+        [
+            [1.5, 1],
+            [0.5, 1]
+        ]
+    ],
+    [
+        [
+            [1, 0.5],
+            [1.5, 1]
+        ]
+    ],
+    [
+        [
+            [1, 1.5],
+            [0.5, 1]
+        ],
+        [
+            [1, 0.5],
+            [1.5, 1]
+        ]
+    ],
+    [
+        [
+            [1, 0.5],
+            [1, 1.5]
+        ]
+    ],
+    [
+        [
+            [1, 0.5],
+            [0.5, 1]
+        ]
+    ],
+    [
+        [
+            [0.5, 1],
+            [1, 0.5]
+        ]
+    ],
+    [
+        [
+            [1, 1.5],
+            [1, 0.5]
+        ]
+    ],
+    [
+        [
+            [0.5, 1],
+            [1, 0.5]
+        ],
+        [
+            [1.5, 1],
+            [1, 1.5]
+        ]
+    ],
+    [
+        [
+            [1.5, 1],
+            [1, 0.5]
+        ]
+    ],
+    [
+        [
+            [0.5, 1],
+            [1.5, 1]
+        ]
+    ],
+    [
+        [
+            [1, 1.5],
+            [1.5, 1]
+        ]
+    ],
+    [
+        [
+            [0.5, 1],
+            [1, 1.5]
+        ]
+    ],
+    []
+];
+
+function contours_default2() {
+    var dx = 1,
+        dy = 1,
+        threshold3 = thresholdSturges2,
+        smooth = smoothLinear;
+
+    function contours(values3) {
+        var tz = threshold3(values3);
+        if (!Array.isArray(tz)) {
+            const e = extent3(values3, finite4);
+            tz = ticks2(...nice3(e[0], e[1], tz), tz);
+            while (tz[tz.length - 1] >= e[1])
+                tz.pop();
+            while (tz[1] < e[0])
+                tz.shift();
+        } else {
+            tz = tz.slice().sort(ascending_default3);
+        }
+        return tz.map((value) => contour3(values3, value));
+    }
+
+    function contour3(values3, value) {
+        const v3 = value == null ? NaN : +value;
+        if (isNaN(v3))
+            throw new Error(`invalid value: ${value}`);
+        var polygons = [],
+            holes = [];
+        isorings(values3, v3, function(ring) {
+            smooth(ring, values3, v3);
+            if (area_default6(ring) > 0)
+                polygons.push([ring]);
+            else
+                holes.push(ring);
+        });
+        holes.forEach(function(hole) {
+            for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
+                if (contains_default4((polygon = polygons[i])[0], hole) !== -1) {
+                    polygon.push(hole);
+                    return;
+                }
+            }
+        });
+        return {
+            type: "MultiPolygon",
+            value,
+            coordinates: polygons
+        };
+    }
+
+    function isorings(values3, value, callback) {
+        var fragmentByStart = new Array(),
+            fragmentByEnd = new Array(),
+            x7, y7, t05, t15, t23, t33;
+        x7 = y7 = -1;
+        t15 = above2(values3[0], value);
+        cases2[t15 << 1].forEach(stitch);
+        while (++x7 < dx - 1) {
+            t05 = t15, t15 = above2(values3[x7 + 1], value);
+            cases2[t05 | t15 << 1].forEach(stitch);
+        }
+        cases2[t15 << 0].forEach(stitch);
+        while (++y7 < dy - 1) {
+            x7 = -1;
+            t15 = above2(values3[y7 * dx + dx], value);
+            t23 = above2(values3[y7 * dx], value);
+            cases2[t15 << 1 | t23 << 2].forEach(stitch);
+            while (++x7 < dx - 1) {
+                t05 = t15, t15 = above2(values3[y7 * dx + dx + x7 + 1], value);
+                t33 = t23, t23 = above2(values3[y7 * dx + x7 + 1], value);
+                cases2[t05 | t15 << 1 | t23 << 2 | t33 << 3].forEach(stitch);
+            }
+            cases2[t15 | t23 << 3].forEach(stitch);
+        }
+        x7 = -1;
+        t23 = values3[y7 * dx] >= value;
+        cases2[t23 << 2].forEach(stitch);
+        while (++x7 < dx - 1) {
+            t33 = t23, t23 = above2(values3[y7 * dx + x7 + 1], value);
+            cases2[t23 << 2 | t33 << 3].forEach(stitch);
+        }
+        cases2[t23 << 3].forEach(stitch);
+
+        function stitch(line3) {
+            var start3 = [line3[0][0] + x7, line3[0][1] + y7],
+                end = [line3[1][0] + x7, line3[1][1] + y7],
+                startIndex = index5(start3),
+                endIndex = index5(end),
+                f, g;
+            if (f = fragmentByEnd[startIndex]) {
+                if (g = fragmentByStart[endIndex]) {
+                    delete fragmentByEnd[f.end];
+                    delete fragmentByStart[g.start];
+                    if (f === g) {
+                        f.ring.push(end);
+                        callback(f.ring);
+                    } else {
+                        fragmentByStart[f.start] = fragmentByEnd[g.end] = {
+                            start: f.start,
+                            end: g.end,
+                            ring: f.ring.concat(g.ring)
+                        };
+                    }
+                } else {
+                    delete fragmentByEnd[f.end];
+                    f.ring.push(end);
+                    fragmentByEnd[f.end = endIndex] = f;
+                }
+            } else if (f = fragmentByStart[endIndex]) {
+                if (g = fragmentByEnd[startIndex]) {
+                    delete fragmentByStart[f.start];
+                    delete fragmentByEnd[g.end];
+                    if (f === g) {
+                        f.ring.push(end);
+                        callback(f.ring);
+                    } else {
+                        fragmentByStart[g.start] = fragmentByEnd[f.end] = {
+                            start: g.start,
+                            end: f.end,
+                            ring: g.ring.concat(f.ring)
+                        };
+                    }
+                } else {
+                    delete fragmentByStart[f.start];
+                    f.ring.unshift(start3);
+                    fragmentByStart[f.start = startIndex] = f;
+                }
+            } else {
+                fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
+                    start: startIndex,
+                    end: endIndex,
+                    ring: [start3, end]
+                };
+            }
+        }
+    }
+
+    function index5(point11) {
+        return point11[0] * 2 + point11[1] * (dx + 1) * 4;
+    }
+
+    function smoothLinear(ring, values3, value) {
+        ring.forEach(function(point11) {
+            var x7 = point11[0],
+                y7 = point11[1],
+                xt = x7 | 0,
+                yt = y7 | 0,
+                v1 = valid2(values3[yt * dx + xt]);
+            if (x7 > 0 && x7 < dx && xt === x7) {
+                point11[0] = smooth12(x7, valid2(values3[yt * dx + xt - 1]), v1, value);
+            }
+            if (y7 > 0 && y7 < dy && yt === y7) {
+                point11[1] = smooth12(y7, valid2(values3[(yt - 1) * dx + xt]), v1, value);
+            }
+        });
+    }
+    contours.contour = contour3;
+    contours.size = function(_) {
+        if (!arguments.length)
+            return [dx, dy];
+        var _0 = Math.floor(_[0]),
+            _1 = Math.floor(_[1]);
+        if (!(_0 >= 0 && _1 >= 0))
+            throw new Error("invalid size");
+        return dx = _0, dy = _1, contours;
+    };
+    contours.thresholds = function(_) {
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default17(slice9.call(_)) : constant_default17(_), contours) : threshold3;
+    };
+    contours.smooth = function(_) {
+        return arguments.length ? (smooth = _ ? smoothLinear : noop_default3, contours) : smooth === smoothLinear;
+    };
+    return contours;
+}
+
+function finite4(x7) {
+    return isFinite(x7) ? x7 : NaN;
+}
+
+function above2(x7, value) {
+    return x7 == null ? false : +x7 >= value;
+}
+
+function valid2(v3) {
+    return v3 == null || isNaN(v3 = +v3) ? -Infinity : v3;
+}
+
+function smooth12(x7, v0, v1, value) {
+    const a7 = value - v0;
+    const b = v1 - v0;
+    const d = isFinite(a7) || isFinite(b) ? a7 / b : Math.sign(a7) / Math.sign(b);
+    return isNaN(d) ? x7 : x7 + d - 0.5;
+}
+
+// js/pyobsplot-js/node_modules/d3-contour/src/density.js
+function defaultX3(d) {
+    return d[0];
+}
+
+function defaultY3(d) {
+    return d[1];
+}
+
+function defaultWeight2() {
+    return 1;
+}
+
+function density_default2() {
+    var x7 = defaultX3,
+        y7 = defaultY3,
+        weight = defaultWeight2,
+        dx = 960,
+        dy = 500,
+        r = 20,
+        k3 = 2,
+        o = r * 3,
+        n = dx + o * 2 >> k3,
+        m5 = dy + o * 2 >> k3,
+        threshold3 = constant_default17(20);
+
+    function grid(data) {
+        var values3 = new Float32Array(n * m5),
+            pow2k = Math.pow(2, -k3),
+            i = -1;
+        for (const d of data) {
+            var xi = (x7(d, ++i, data) + o) * pow2k,
+                yi = (y7(d, i, data) + o) * pow2k,
+                wi = +weight(d, i, data);
+            if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m5) {
+                var x011 = Math.floor(xi),
+                    y011 = Math.floor(yi),
+                    xt = xi - x011 - 0.5,
+                    yt = yi - y011 - 0.5;
+                values3[x011 + y011 * n] += (1 - xt) * (1 - yt) * wi;
+                values3[x011 + 1 + y011 * n] += xt * (1 - yt) * wi;
+                values3[x011 + 1 + (y011 + 1) * n] += xt * yt * wi;
+                values3[x011 + (y011 + 1) * n] += (1 - xt) * yt * wi;
+            }
+        }
+        blur22({
+            data: values3,
+            width: n,
+            height: m5
+        }, r * pow2k);
+        return values3;
+    }
+
+    function density3(data) {
+        var values3 = grid(data),
+            tz = threshold3(values3),
+            pow4k = Math.pow(2, 2 * k3);
+        if (!Array.isArray(tz)) {
+            tz = ticks2(Number.MIN_VALUE, max5(values3) / pow4k, tz);
+        }
+        return contours_default2().size([n, m5]).thresholds(tz.map((d) => d * pow4k))(values3).map((c11, i) => (c11.value = +tz[i], transform3(c11)));
+    }
+    density3.contours = function(data) {
+        var values3 = grid(data),
+            contours = contours_default2().size([n, m5]),
+            pow4k = Math.pow(2, 2 * k3),
+            contour3 = (value) => {
+                value = +value;
+                var c11 = transform3(contours.contour(values3, value * pow4k));
+                c11.value = value;
+                return c11;
+            };
+        Object.defineProperty(contour3, "max", {
+            get: () => max5(values3) / pow4k
+        });
+        return contour3;
+    };
+
+    function transform3(geometry) {
+        geometry.coordinates.forEach(transformPolygon);
+        return geometry;
+    }
+
+    function transformPolygon(coordinates3) {
+        coordinates3.forEach(transformRing);
+    }
+
+    function transformRing(coordinates3) {
+        coordinates3.forEach(transformPoint);
+    }
+
+    function transformPoint(coordinates3) {
+        coordinates3[0] = coordinates3[0] * Math.pow(2, k3) - o;
+        coordinates3[1] = coordinates3[1] * Math.pow(2, k3) - o;
+    }
+
+    function resize() {
+        o = r * 3;
+        n = dx + o * 2 >> k3;
+        m5 = dy + o * 2 >> k3;
+        return density3;
+    }
+    density3.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default17(+_), density3) : x7;
+    };
+    density3.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default17(+_), density3) : y7;
+    };
+    density3.weight = function(_) {
+        return arguments.length ? (weight = typeof _ === "function" ? _ : constant_default17(+_), density3) : weight;
+    };
+    density3.size = function(_) {
+        if (!arguments.length)
+            return [dx, dy];
+        var _0 = +_[0],
+            _1 = +_[1];
+        if (!(_0 >= 0 && _1 >= 0))
+            throw new Error("invalid size");
+        return dx = _0, dy = _1, resize();
+    };
+    density3.cellSize = function(_) {
+        if (!arguments.length)
+            return 1 << k3;
+        if (!((_ = +_) >= 1))
+            throw new Error("invalid cell size");
+        return k3 = Math.floor(Math.log(_) / Math.LN2), resize();
+    };
+    density3.thresholds = function(_) {
+        return arguments.length ? (threshold3 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default17(slice9.call(_)) : constant_default17(_), density3) : threshold3;
+    };
+    density3.bandwidth = function(_) {
+        if (!arguments.length)
+            return Math.sqrt(r * (r + 1));
+        if (!((_ = +_) >= 0))
+            throw new Error("invalid bandwidth");
+        return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
+    };
+    return density3;
+}
+
+// js/pyobsplot-js/node_modules/robust-predicates/esm/util.js
+var epsilon12 = 11102230246251565e-32;
+var splitter3 = 134217729;
+var resulterrbound2 = (3 + 8 * epsilon12) * epsilon12;
+
+function sum5(elen, e, flen, f, h) {
+    let Q, Qnew, hh, bvirt;
+    let enow = e[0];
+    let fnow = f[0];
+    let eindex = 0;
+    let findex = 0;
+    if (fnow > enow === fnow > -enow) {
+        Q = enow;
+        enow = e[++eindex];
+    } else {
+        Q = fnow;
+        fnow = f[++findex];
+    }
+    let hindex = 0;
+    if (eindex < elen && findex < flen) {
+        if (fnow > enow === fnow > -enow) {
+            Qnew = enow + Q;
+            hh = Q - (Qnew - enow);
+            enow = e[++eindex];
+        } else {
+            Qnew = fnow + Q;
+            hh = Q - (Qnew - fnow);
+            fnow = f[++findex];
+        }
+        Q = Qnew;
+        if (hh !== 0) {
+            h[hindex++] = hh;
+        }
+        while (eindex < elen && findex < flen) {
+            if (fnow > enow === fnow > -enow) {
+                Qnew = Q + enow;
+                bvirt = Qnew - Q;
+                hh = Q - (Qnew - bvirt) + (enow - bvirt);
+                enow = e[++eindex];
+            } else {
+                Qnew = Q + fnow;
+                bvirt = Qnew - Q;
+                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
+                fnow = f[++findex];
+            }
+            Q = Qnew;
+            if (hh !== 0) {
+                h[hindex++] = hh;
+            }
+        }
+    }
+    while (eindex < elen) {
+        Qnew = Q + enow;
+        bvirt = Qnew - Q;
+        hh = Q - (Qnew - bvirt) + (enow - bvirt);
+        enow = e[++eindex];
+        Q = Qnew;
+        if (hh !== 0) {
+            h[hindex++] = hh;
+        }
+    }
+    while (findex < flen) {
+        Qnew = Q + fnow;
+        bvirt = Qnew - Q;
+        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
+        fnow = f[++findex];
+        Q = Qnew;
+        if (hh !== 0) {
+            h[hindex++] = hh;
+        }
+    }
+    if (Q !== 0 || hindex === 0) {
+        h[hindex++] = Q;
+    }
+    return hindex;
+}
+
+function estimate2(elen, e) {
+    let Q = e[0];
+    for (let i = 1; i < elen; i++)
+        Q += e[i];
+    return Q;
+}
+
+function vec2(n) {
+    return new Float64Array(n);
+}
+
+// js/pyobsplot-js/node_modules/robust-predicates/esm/orient2d.js
+var ccwerrboundA2 = (3 + 16 * epsilon12) * epsilon12;
+var ccwerrboundB2 = (2 + 12 * epsilon12) * epsilon12;
+var ccwerrboundC2 = (9 + 64 * epsilon12) * epsilon12 * epsilon12;
+var B4 = vec2(4);
+var C12 = vec2(8);
+var C22 = vec2(12);
+var D4 = vec2(16);
+var u4 = vec2(4);
+
+function orient2dadapt2(ax, ay, bx, by, cx, cy, detsum) {
+    let acxtail, acytail, bcxtail, bcytail;
+    let bvirt, c11, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t15, t05, u33;
+    const acx = ax - cx;
+    const bcx = bx - cx;
+    const acy = ay - cy;
+    const bcy = by - cy;
+    s1 = acx * bcy;
+    c11 = splitter3 * acx;
+    ahi = c11 - (c11 - acx);
+    alo = acx - ahi;
+    c11 = splitter3 * bcy;
+    bhi = c11 - (c11 - bcy);
+    blo = bcy - bhi;
+    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
+    t15 = acy * bcx;
+    c11 = splitter3 * acy;
+    ahi = c11 - (c11 - acy);
+    alo = acy - ahi;
+    c11 = splitter3 * bcx;
+    bhi = c11 - (c11 - bcx);
+    blo = bcx - bhi;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
+    bvirt = s0 - _i;
+    B4[0] = s0 - (_i + bvirt) + (bvirt - t05);
+    _j2 = s1 + _i;
+    bvirt = _j2 - s1;
+    _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
+    _i = _0 - t15;
+    bvirt = _0 - _i;
+    B4[1] = _0 - (_i + bvirt) + (bvirt - t15);
+    u33 = _j2 + _i;
+    bvirt = u33 - _j2;
+    B4[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
+    B4[3] = u33;
+    let det = estimate2(4, B4);
+    let errbound = ccwerrboundB2 * detsum;
+    if (det >= errbound || -det >= errbound) {
+        return det;
+    }
+    bvirt = ax - acx;
+    acxtail = ax - (acx + bvirt) + (bvirt - cx);
+    bvirt = bx - bcx;
+    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
+    bvirt = ay - acy;
+    acytail = ay - (acy + bvirt) + (bvirt - cy);
+    bvirt = by - bcy;
+    bcytail = by - (bcy + bvirt) + (bvirt - cy);
+    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
+        return det;
+    }
+    errbound = ccwerrboundC2 * detsum + resulterrbound2 * Math.abs(det);
+    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
+    if (det >= errbound || -det >= errbound)
+        return det;
+    s1 = acxtail * bcy;
+    c11 = splitter3 * acxtail;
+    ahi = c11 - (c11 - acxtail);
+    alo = acxtail - ahi;
+    c11 = splitter3 * bcy;
+    bhi = c11 - (c11 - bcy);
+    blo = bcy - bhi;
+    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
+    t15 = acytail * bcx;
+    c11 = splitter3 * acytail;
+    ahi = c11 - (c11 - acytail);
+    alo = acytail - ahi;
+    c11 = splitter3 * bcx;
+    bhi = c11 - (c11 - bcx);
+    blo = bcx - bhi;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
+    bvirt = s0 - _i;
+    u4[0] = s0 - (_i + bvirt) + (bvirt - t05);
+    _j2 = s1 + _i;
+    bvirt = _j2 - s1;
+    _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
+    _i = _0 - t15;
+    bvirt = _0 - _i;
+    u4[1] = _0 - (_i + bvirt) + (bvirt - t15);
+    u33 = _j2 + _i;
+    bvirt = u33 - _j2;
+    u4[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
+    u4[3] = u33;
+    const C1len = sum5(4, B4, 4, u4, C12);
+    s1 = acx * bcytail;
+    c11 = splitter3 * acx;
+    ahi = c11 - (c11 - acx);
+    alo = acx - ahi;
+    c11 = splitter3 * bcytail;
+    bhi = c11 - (c11 - bcytail);
+    blo = bcytail - bhi;
+    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
+    t15 = acy * bcxtail;
+    c11 = splitter3 * acy;
+    ahi = c11 - (c11 - acy);
+    alo = acy - ahi;
+    c11 = splitter3 * bcxtail;
+    bhi = c11 - (c11 - bcxtail);
+    blo = bcxtail - bhi;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
+    bvirt = s0 - _i;
+    u4[0] = s0 - (_i + bvirt) + (bvirt - t05);
+    _j2 = s1 + _i;
+    bvirt = _j2 - s1;
+    _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
+    _i = _0 - t15;
+    bvirt = _0 - _i;
+    u4[1] = _0 - (_i + bvirt) + (bvirt - t15);
+    u33 = _j2 + _i;
+    bvirt = u33 - _j2;
+    u4[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
+    u4[3] = u33;
+    const C2len = sum5(C1len, C12, 4, u4, C22);
+    s1 = acxtail * bcytail;
+    c11 = splitter3 * acxtail;
+    ahi = c11 - (c11 - acxtail);
+    alo = acxtail - ahi;
+    c11 = splitter3 * bcytail;
+    bhi = c11 - (c11 - bcytail);
+    blo = bcytail - bhi;
+    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
+    t15 = acytail * bcxtail;
+    c11 = splitter3 * acytail;
+    ahi = c11 - (c11 - acytail);
+    alo = acytail - ahi;
+    c11 = splitter3 * bcxtail;
+    bhi = c11 - (c11 - bcxtail);
+    blo = bcxtail - bhi;
+    t05 = alo * blo - (t15 - ahi * bhi - alo * bhi - ahi * blo);
+    _i = s0 - t05;
+    bvirt = s0 - _i;
+    u4[0] = s0 - (_i + bvirt) + (bvirt - t05);
+    _j2 = s1 + _i;
+    bvirt = _j2 - s1;
+    _0 = s1 - (_j2 - bvirt) + (_i - bvirt);
+    _i = _0 - t15;
+    bvirt = _0 - _i;
+    u4[1] = _0 - (_i + bvirt) + (bvirt - t15);
+    u33 = _j2 + _i;
+    bvirt = u33 - _j2;
+    u4[2] = _j2 - (u33 - bvirt) + (_i - bvirt);
+    u4[3] = u33;
+    const Dlen = sum5(C2len, C22, 4, u4, D4);
+    return D4[Dlen - 1];
+}
+
+function orient2d2(ax, ay, bx, by, cx, cy) {
+    const detleft = (ay - cy) * (bx - cx);
+    const detright = (ax - cx) * (by - cy);
+    const det = detleft - detright;
+    if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)
+        return det;
+    const detsum = Math.abs(detleft + detright);
+    if (Math.abs(det) >= ccwerrboundA2 * detsum)
+        return det;
+    return -orient2dadapt2(ax, ay, bx, by, cx, cy, detsum);
 }
 
-// node_modules/robust-predicates/esm/orient3d.js
-var o3derrboundA = (7 + 56 * epsilon5) * epsilon5;
-var o3derrboundB = (3 + 28 * epsilon5) * epsilon5;
-var o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;
-var bc = vec(4);
-var ca = vec(4);
-var ab = vec(4);
-var at_b = vec(4);
-var at_c = vec(4);
-var bt_c = vec(4);
-var bt_a = vec(4);
-var ct_a = vec(4);
-var ct_b = vec(4);
-var bct = vec(8);
-var cat = vec(8);
-var abt = vec(8);
-var u2 = vec(4);
-var _8 = vec(8);
-var _8b = vec(8);
-var _16 = vec(8);
-var _12 = vec(12);
-var fin = vec(192);
-var fin2 = vec(192);
-
-// node_modules/robust-predicates/esm/incircle.js
-var iccerrboundA = (10 + 96 * epsilon5) * epsilon5;
-var iccerrboundB = (4 + 48 * epsilon5) * epsilon5;
-var iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;
-var bc2 = vec(4);
-var ca2 = vec(4);
-var ab2 = vec(4);
-var aa = vec(4);
-var bb = vec(4);
-var cc = vec(4);
-var u3 = vec(4);
-var v = vec(4);
-var axtbc = vec(8);
-var aytbc = vec(8);
-var bxtca = vec(8);
-var bytca = vec(8);
-var cxtab = vec(8);
-var cytab = vec(8);
-var abt2 = vec(8);
-var bct2 = vec(8);
-var cat2 = vec(8);
-var abtt = vec(4);
-var bctt = vec(4);
-var catt = vec(4);
-var _82 = vec(8);
-var _162 = vec(16);
-var _16b = vec(16);
-var _16c = vec(16);
-var _32 = vec(32);
-var _32b = vec(32);
-var _48 = vec(48);
-var _64 = vec(64);
-var fin3 = vec(1152);
-var fin22 = vec(1152);
-
-// node_modules/robust-predicates/esm/insphere.js
-var isperrboundA = (16 + 224 * epsilon5) * epsilon5;
-var isperrboundB = (5 + 72 * epsilon5) * epsilon5;
-var isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;
-var ab3 = vec(4);
-var bc3 = vec(4);
-var cd = vec(4);
-var de = vec(4);
-var ea = vec(4);
-var ac = vec(4);
-var bd = vec(4);
-var ce = vec(4);
-var da = vec(4);
-var eb = vec(4);
-var abc = vec(24);
-var bcd = vec(24);
-var cde = vec(24);
-var dea = vec(24);
-var eab = vec(24);
-var abd = vec(24);
-var bce = vec(24);
-var cda = vec(24);
-var deb = vec(24);
-var eac = vec(24);
-var adet = vec(1152);
-var bdet = vec(1152);
-var cdet = vec(1152);
-var ddet = vec(1152);
-var edet = vec(1152);
-var abdet = vec(2304);
-var cddet = vec(2304);
-var cdedet = vec(3456);
-var deter = vec(5760);
-var _83 = vec(8);
-var _8b2 = vec(8);
-var _8c = vec(8);
-var _163 = vec(16);
-var _24 = vec(24);
-var _482 = vec(48);
-var _48b = vec(48);
-var _96 = vec(96);
-var _192 = vec(192);
-var _384x = vec(384);
-var _384y = vec(384);
-var _384z = vec(384);
-var _768 = vec(768);
-var xdet = vec(96);
-var ydet = vec(96);
-var zdet = vec(96);
-var fin4 = vec(1152);
-
-// node_modules/delaunator/index.js
-var EPSILON = Math.pow(2, -52);
-var EDGE_STACK = new Uint32Array(512);
-var Delaunator = class {
-    static from(points, getX = defaultGetX, getY = defaultGetY) {
+// js/pyobsplot-js/node_modules/robust-predicates/esm/orient3d.js
+var o3derrboundA2 = (7 + 56 * epsilon12) * epsilon12;
+var o3derrboundB2 = (3 + 28 * epsilon12) * epsilon12;
+var o3derrboundC2 = (26 + 288 * epsilon12) * epsilon12 * epsilon12;
+var bc4 = vec2(4);
+var ca3 = vec2(4);
+var ab4 = vec2(4);
+var at_b2 = vec2(4);
+var at_c2 = vec2(4);
+var bt_c2 = vec2(4);
+var bt_a2 = vec2(4);
+var ct_a2 = vec2(4);
+var ct_b2 = vec2(4);
+var bct3 = vec2(8);
+var cat3 = vec2(8);
+var abt3 = vec2(8);
+var u5 = vec2(4);
+var _84 = vec2(8);
+var _8b3 = vec2(8);
+var _164 = vec2(8);
+var _122 = vec2(12);
+var fin5 = vec2(192);
+var fin23 = vec2(192);
+
+// js/pyobsplot-js/node_modules/robust-predicates/esm/incircle.js
+var iccerrboundA2 = (10 + 96 * epsilon12) * epsilon12;
+var iccerrboundB2 = (4 + 48 * epsilon12) * epsilon12;
+var iccerrboundC2 = (44 + 576 * epsilon12) * epsilon12 * epsilon12;
+var bc5 = vec2(4);
+var ca4 = vec2(4);
+var ab5 = vec2(4);
+var aa2 = vec2(4);
+var bb2 = vec2(4);
+var cc2 = vec2(4);
+var u6 = vec2(4);
+var v2 = vec2(4);
+var axtbc2 = vec2(8);
+var aytbc2 = vec2(8);
+var bxtca2 = vec2(8);
+var bytca2 = vec2(8);
+var cxtab2 = vec2(8);
+var cytab2 = vec2(8);
+var abt4 = vec2(8);
+var bct4 = vec2(8);
+var cat4 = vec2(8);
+var abtt2 = vec2(4);
+var bctt2 = vec2(4);
+var catt2 = vec2(4);
+var _85 = vec2(8);
+var _165 = vec2(16);
+var _16b2 = vec2(16);
+var _16c2 = vec2(16);
+var _322 = vec2(32);
+var _32b2 = vec2(32);
+var _483 = vec2(48);
+var _642 = vec2(64);
+var fin6 = vec2(1152);
+var fin24 = vec2(1152);
+
+// js/pyobsplot-js/node_modules/robust-predicates/esm/insphere.js
+var isperrboundA2 = (16 + 224 * epsilon12) * epsilon12;
+var isperrboundB2 = (5 + 72 * epsilon12) * epsilon12;
+var isperrboundC2 = (71 + 1408 * epsilon12) * epsilon12 * epsilon12;
+var ab6 = vec2(4);
+var bc6 = vec2(4);
+var cd2 = vec2(4);
+var de2 = vec2(4);
+var ea2 = vec2(4);
+var ac2 = vec2(4);
+var bd2 = vec2(4);
+var ce2 = vec2(4);
+var da2 = vec2(4);
+var eb2 = vec2(4);
+var abc2 = vec2(24);
+var bcd2 = vec2(24);
+var cde2 = vec2(24);
+var dea2 = vec2(24);
+var eab2 = vec2(24);
+var abd2 = vec2(24);
+var bce2 = vec2(24);
+var cda2 = vec2(24);
+var deb2 = vec2(24);
+var eac2 = vec2(24);
+var adet2 = vec2(1152);
+var bdet2 = vec2(1152);
+var cdet2 = vec2(1152);
+var ddet2 = vec2(1152);
+var edet2 = vec2(1152);
+var abdet2 = vec2(2304);
+var cddet2 = vec2(2304);
+var cdedet2 = vec2(3456);
+var deter2 = vec2(5760);
+var _86 = vec2(8);
+var _8b4 = vec2(8);
+var _8c2 = vec2(8);
+var _166 = vec2(16);
+var _242 = vec2(24);
+var _484 = vec2(48);
+var _48b2 = vec2(48);
+var _962 = vec2(96);
+var _1922 = vec2(192);
+var _384x2 = vec2(384);
+var _384y2 = vec2(384);
+var _384z2 = vec2(384);
+var _7682 = vec2(768);
+var xdet2 = vec2(96);
+var ydet2 = vec2(96);
+var zdet2 = vec2(96);
+var fin7 = vec2(1152);
+
+// js/pyobsplot-js/node_modules/delaunator/index.js
+var EPSILON2 = Math.pow(2, -52);
+var EDGE_STACK2 = new Uint32Array(512);
+var Delaunator2 = class {
+    static from(points, getX = defaultGetX2, getY = defaultGetY2) {
         const n = points.length;
         const coords = new Float64Array(n * 2);
         for (let i = 0; i < n; i++) {
             const p = points[i];
             coords[2 * i] = getX(p);
             coords[2 * i + 1] = getY(p);
         }
-        return new Delaunator(coords);
+        return new Delaunator2(coords);
     }
     constructor(coords) {
         const n = coords.length >> 1;
         if (n > 0 && typeof coords[0] !== "number")
             throw new Error("Expected coords to contain numbers.");
         this.coords = coords;
         const maxTriangles = Math.max(2 * n - 5, 0);
@@ -8703,442 +43395,442 @@
             _hullTri: hullTri,
             _hullHash: hullHash
         } = this;
         const n = coords.length >> 1;
         let minX = Infinity;
         let minY = Infinity;
         let maxX = -Infinity;
-        let maxY2 = -Infinity;
+        let maxY3 = -Infinity;
         for (let i = 0; i < n; i++) {
-            const x4 = coords[2 * i];
-            const y4 = coords[2 * i + 1];
-            if (x4 < minX)
-                minX = x4;
-            if (y4 < minY)
-                minY = y4;
-            if (x4 > maxX)
-                maxX = x4;
-            if (y4 > maxY2)
-                maxY2 = y4;
+            const x7 = coords[2 * i];
+            const y7 = coords[2 * i + 1];
+            if (x7 < minX)
+                minX = x7;
+            if (y7 < minY)
+                minY = y7;
+            if (x7 > maxX)
+                maxX = x7;
+            if (y7 > maxY3)
+                maxY3 = y7;
             this._ids[i] = i;
         }
         const cx = (minX + maxX) / 2;
-        const cy = (minY + maxY2) / 2;
+        const cy = (minY + maxY3) / 2;
         let minDist = Infinity;
         let i0, i1, i2;
         for (let i = 0; i < n; i++) {
-            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
+            const d = dist2(cx, cy, coords[2 * i], coords[2 * i + 1]);
             if (d < minDist) {
                 i0 = i;
                 minDist = d;
             }
         }
         const i0x = coords[2 * i0];
         const i0y = coords[2 * i0 + 1];
         minDist = Infinity;
         for (let i = 0; i < n; i++) {
             if (i === i0)
                 continue;
-            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
+            const d = dist2(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
             if (d < minDist && d > 0) {
                 i1 = i;
                 minDist = d;
             }
         }
         let i1x = coords[2 * i1];
         let i1y = coords[2 * i1 + 1];
         let minRadius = Infinity;
         for (let i = 0; i < n; i++) {
             if (i === i0 || i === i1)
                 continue;
-            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
+            const r = circumradius2(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
             if (r < minRadius) {
                 i2 = i;
                 minRadius = r;
             }
         }
         let i2x = coords[2 * i2];
         let i2y = coords[2 * i2 + 1];
         if (minRadius === Infinity) {
             for (let i = 0; i < n; i++) {
                 this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
             }
-            quicksort(this._ids, this._dists, 0, n - 1);
-            const hull2 = new Uint32Array(n);
+            quicksort2(this._ids, this._dists, 0, n - 1);
+            const hull3 = new Uint32Array(n);
             let j = 0;
             for (let i = 0, d0 = -Infinity; i < n; i++) {
-                const id2 = this._ids[i];
-                if (this._dists[id2] > d0) {
-                    hull2[j++] = id2;
-                    d0 = this._dists[id2];
+                const id3 = this._ids[i];
+                if (this._dists[id3] > d0) {
+                    hull3[j++] = id3;
+                    d0 = this._dists[id3];
                 }
             }
-            this.hull = hull2.subarray(0, j);
+            this.hull = hull3.subarray(0, j);
             this.triangles = new Uint32Array(0);
             this.halfedges = new Uint32Array(0);
             return;
         }
-        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
+        if (orient2d2(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
             const i = i1;
-            const x4 = i1x;
-            const y4 = i1y;
+            const x7 = i1x;
+            const y7 = i1y;
             i1 = i2;
             i1x = i2x;
             i1y = i2y;
             i2 = i;
-            i2x = x4;
-            i2y = y4;
+            i2x = x7;
+            i2y = y7;
         }
-        const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
-        this._cx = center2.x;
-        this._cy = center2.y;
+        const center3 = circumcenter2(i0x, i0y, i1x, i1y, i2x, i2y);
+        this._cx = center3.x;
+        this._cy = center3.y;
         for (let i = 0; i < n; i++) {
-            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
+            this._dists[i] = dist2(coords[2 * i], coords[2 * i + 1], center3.x, center3.y);
         }
-        quicksort(this._ids, this._dists, 0, n - 1);
+        quicksort2(this._ids, this._dists, 0, n - 1);
         this._hullStart = i0;
         let hullSize = 3;
         hullNext[i0] = hullPrev[i2] = i1;
         hullNext[i1] = hullPrev[i0] = i2;
         hullNext[i2] = hullPrev[i1] = i0;
         hullTri[i0] = 0;
         hullTri[i1] = 1;
         hullTri[i2] = 2;
         hullHash.fill(-1);
         hullHash[this._hashKey(i0x, i0y)] = i0;
         hullHash[this._hashKey(i1x, i1y)] = i1;
         hullHash[this._hashKey(i2x, i2y)] = i2;
         this.trianglesLen = 0;
         this._addTriangle(i0, i1, i2, -1, -1, -1);
-        for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
-            const i = this._ids[k2];
-            const x4 = coords[2 * i];
-            const y4 = coords[2 * i + 1];
-            if (k2 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)
+        for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
+            const i = this._ids[k3];
+            const x7 = coords[2 * i];
+            const y7 = coords[2 * i + 1];
+            if (k3 > 0 && Math.abs(x7 - xp) <= EPSILON2 && Math.abs(y7 - yp) <= EPSILON2)
                 continue;
-            xp = x4;
-            yp = y4;
+            xp = x7;
+            yp = y7;
             if (i === i0 || i === i1 || i === i2)
                 continue;
-            let start2 = 0;
-            for (let j = 0, key = this._hashKey(x4, y4); j < this._hashSize; j++) {
-                start2 = hullHash[(key + j) % this._hashSize];
-                if (start2 !== -1 && start2 !== hullNext[start2])
+            let start3 = 0;
+            for (let j = 0, key = this._hashKey(x7, y7); j < this._hashSize; j++) {
+                start3 = hullHash[(key + j) % this._hashSize];
+                if (start3 !== -1 && start3 !== hullNext[start3])
                     break;
             }
-            start2 = hullPrev[start2];
-            let e = start2,
+            start3 = hullPrev[start3];
+            let e = start3,
                 q;
-            while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
+            while (q = hullNext[e], orient2d2(x7, y7, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                 e = q;
-                if (e === start2) {
+                if (e === start3) {
                     e = -1;
                     break;
                 }
             }
             if (e === -1)
                 continue;
             let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
             hullTri[i] = this._legalize(t + 2);
             hullTri[e] = t;
             hullSize++;
             let n2 = hullNext[e];
-            while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
+            while (q = hullNext[n2], orient2d2(x7, y7, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                 t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
                 hullTri[i] = this._legalize(t + 2);
                 hullNext[n2] = n2;
                 hullSize--;
                 n2 = q;
             }
-            if (e === start2) {
-                while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
+            if (e === start3) {
+                while (q = hullPrev[e], orient2d2(x7, y7, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                     t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                     this._legalize(t + 2);
                     hullTri[q] = t;
                     hullNext[e] = e;
                     hullSize--;
                     e = q;
                 }
             }
             this._hullStart = hullPrev[i] = e;
             hullNext[e] = hullPrev[n2] = i;
             hullNext[i] = n2;
-            hullHash[this._hashKey(x4, y4)] = i;
+            hullHash[this._hashKey(x7, y7)] = i;
             hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
         }
         this.hull = new Uint32Array(hullSize);
         for (let i = 0, e = this._hullStart; i < hullSize; i++) {
             this.hull[i] = e;
             e = hullNext[e];
         }
         this.triangles = this._triangles.subarray(0, this.trianglesLen);
         this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
     }
-    _hashKey(x4, y4) {
-        return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;
+    _hashKey(x7, y7) {
+        return Math.floor(pseudoAngle2(x7 - this._cx, y7 - this._cy) * this._hashSize) % this._hashSize;
     }
-    _legalize(a4) {
+    _legalize(a7) {
         const {
             _triangles: triangles,
             _halfedges: halfedges,
             coords
         } = this;
         let i = 0;
         let ar = 0;
         while (true) {
-            const b = halfedges[a4];
-            const a0 = a4 - a4 % 3;
-            ar = a0 + (a4 + 2) % 3;
+            const b = halfedges[a7];
+            const a0 = a7 - a7 % 3;
+            ar = a0 + (a7 + 2) % 3;
             if (b === -1) {
                 if (i === 0)
                     break;
-                a4 = EDGE_STACK[--i];
+                a7 = EDGE_STACK2[--i];
                 continue;
             }
-            const b02 = b - b % 3;
-            const al = a0 + (a4 + 1) % 3;
-            const bl = b02 + (b + 2) % 3;
-            const p02 = triangles[ar];
-            const pr = triangles[a4];
+            const b03 = b - b % 3;
+            const al = a0 + (a7 + 1) % 3;
+            const bl = b03 + (b + 2) % 3;
+            const p03 = triangles[ar];
+            const pr = triangles[a7];
             const pl = triangles[al];
             const p1 = triangles[bl];
-            const illegal = inCircle(
-                coords[2 * p02],
-                coords[2 * p02 + 1],
+            const illegal = inCircle2(
+                coords[2 * p03],
+                coords[2 * p03 + 1],
                 coords[2 * pr],
                 coords[2 * pr + 1],
                 coords[2 * pl],
                 coords[2 * pl + 1],
                 coords[2 * p1],
                 coords[2 * p1 + 1]
             );
             if (illegal) {
-                triangles[a4] = p1;
-                triangles[b] = p02;
+                triangles[a7] = p1;
+                triangles[b] = p03;
                 const hbl = halfedges[bl];
                 if (hbl === -1) {
                     let e = this._hullStart;
                     do {
                         if (this._hullTri[e] === bl) {
-                            this._hullTri[e] = a4;
+                            this._hullTri[e] = a7;
                             break;
                         }
                         e = this._hullPrev[e];
                     } while (e !== this._hullStart);
                 }
-                this._link(a4, hbl);
+                this._link(a7, hbl);
                 this._link(b, halfedges[ar]);
                 this._link(ar, bl);
-                const br = b02 + (b + 1) % 3;
-                if (i < EDGE_STACK.length) {
-                    EDGE_STACK[i++] = br;
+                const br = b03 + (b + 1) % 3;
+                if (i < EDGE_STACK2.length) {
+                    EDGE_STACK2[i++] = br;
                 }
             } else {
                 if (i === 0)
                     break;
-                a4 = EDGE_STACK[--i];
+                a7 = EDGE_STACK2[--i];
             }
         }
         return ar;
     }
-    _link(a4, b) {
-        this._halfedges[a4] = b;
+    _link(a7, b) {
+        this._halfedges[a7] = b;
         if (b !== -1)
-            this._halfedges[b] = a4;
+            this._halfedges[b] = a7;
     }
     // add a new triangle given vertex indices and adjacent half-edge ids
-    _addTriangle(i0, i1, i2, a4, b, c6) {
+    _addTriangle(i0, i1, i2, a7, b, c11) {
         const t = this.trianglesLen;
         this._triangles[t] = i0;
         this._triangles[t + 1] = i1;
         this._triangles[t + 2] = i2;
-        this._link(t, a4);
+        this._link(t, a7);
         this._link(t + 1, b);
-        this._link(t + 2, c6);
+        this._link(t + 2, c11);
         this.trianglesLen += 3;
         return t;
     }
 };
 
-function pseudoAngle(dx, dy) {
+function pseudoAngle2(dx, dy) {
     const p = dx / (Math.abs(dx) + Math.abs(dy));
     return (dy > 0 ? 3 - p : 1 + p) / 4;
 }
 
-function dist(ax, ay, bx, by) {
+function dist2(ax, ay, bx, by) {
     const dx = ax - bx;
     const dy = ay - by;
     return dx * dx + dy * dy;
 }
 
-function inCircle(ax, ay, bx, by, cx, cy, px, py) {
+function inCircle2(ax, ay, bx, by, cx, cy, px, py) {
     const dx = ax - px;
     const dy = ay - py;
     const ex = bx - px;
     const ey = by - py;
     const fx = cx - px;
     const fy = cy - py;
     const ap = dx * dx + dy * dy;
     const bp = ex * ex + ey * ey;
     const cp = fx * fx + fy * fy;
     return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
 }
 
-function circumradius(ax, ay, bx, by, cx, cy) {
+function circumradius2(ax, ay, bx, by, cx, cy) {
     const dx = bx - ax;
     const dy = by - ay;
     const ex = cx - ax;
     const ey = cy - ay;
     const bl = dx * dx + dy * dy;
     const cl = ex * ex + ey * ey;
     const d = 0.5 / (dx * ey - dy * ex);
-    const x4 = (ey * bl - dy * cl) * d;
-    const y4 = (dx * cl - ex * bl) * d;
-    return x4 * x4 + y4 * y4;
+    const x7 = (ey * bl - dy * cl) * d;
+    const y7 = (dx * cl - ex * bl) * d;
+    return x7 * x7 + y7 * y7;
 }
 
-function circumcenter(ax, ay, bx, by, cx, cy) {
+function circumcenter2(ax, ay, bx, by, cx, cy) {
     const dx = bx - ax;
     const dy = by - ay;
     const ex = cx - ax;
     const ey = cy - ay;
     const bl = dx * dx + dy * dy;
     const cl = ex * ex + ey * ey;
     const d = 0.5 / (dx * ey - dy * ex);
-    const x4 = ax + (ey * bl - dy * cl) * d;
-    const y4 = ay + (dx * cl - ex * bl) * d;
+    const x7 = ax + (ey * bl - dy * cl) * d;
+    const y7 = ay + (dx * cl - ex * bl) * d;
     return {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     };
 }
 
-function quicksort(ids, dists, left2, right2) {
-    if (right2 - left2 <= 20) {
-        for (let i = left2 + 1; i <= right2; i++) {
+function quicksort2(ids, dists, left3, right3) {
+    if (right3 - left3 <= 20) {
+        for (let i = left3 + 1; i <= right3; i++) {
             const temp = ids[i];
             const tempDist = dists[temp];
             let j = i - 1;
-            while (j >= left2 && dists[ids[j]] > tempDist)
+            while (j >= left3 && dists[ids[j]] > tempDist)
                 ids[j + 1] = ids[j--];
             ids[j + 1] = temp;
         }
     } else {
-        const median2 = left2 + right2 >> 1;
-        let i = left2 + 1;
-        let j = right2;
-        swap2(ids, median2, i);
-        if (dists[ids[left2]] > dists[ids[right2]])
-            swap2(ids, left2, right2);
-        if (dists[ids[i]] > dists[ids[right2]])
-            swap2(ids, i, right2);
-        if (dists[ids[left2]] > dists[ids[i]])
-            swap2(ids, left2, i);
+        const median3 = left3 + right3 >> 1;
+        let i = left3 + 1;
+        let j = right3;
+        swap4(ids, median3, i);
+        if (dists[ids[left3]] > dists[ids[right3]])
+            swap4(ids, left3, right3);
+        if (dists[ids[i]] > dists[ids[right3]])
+            swap4(ids, i, right3);
+        if (dists[ids[left3]] > dists[ids[i]])
+            swap4(ids, left3, i);
         const temp = ids[i];
         const tempDist = dists[temp];
         while (true) {
             do
                 i++;
             while (dists[ids[i]] < tempDist);
             do
                 j--;
             while (dists[ids[j]] > tempDist);
             if (j < i)
                 break;
-            swap2(ids, i, j);
+            swap4(ids, i, j);
         }
-        ids[left2 + 1] = ids[j];
+        ids[left3 + 1] = ids[j];
         ids[j] = temp;
-        if (right2 - i + 1 >= j - left2) {
-            quicksort(ids, dists, i, right2);
-            quicksort(ids, dists, left2, j - 1);
+        if (right3 - i + 1 >= j - left3) {
+            quicksort2(ids, dists, i, right3);
+            quicksort2(ids, dists, left3, j - 1);
         } else {
-            quicksort(ids, dists, left2, j - 1);
-            quicksort(ids, dists, i, right2);
+            quicksort2(ids, dists, left3, j - 1);
+            quicksort2(ids, dists, i, right3);
         }
     }
 }
 
-function swap2(arr, i, j) {
+function swap4(arr, i, j) {
     const tmp2 = arr[i];
     arr[i] = arr[j];
     arr[j] = tmp2;
 }
 
-function defaultGetX(p) {
+function defaultGetX2(p) {
     return p[0];
 }
 
-function defaultGetY(p) {
+function defaultGetY2(p) {
     return p[1];
 }
 
-// node_modules/d3-delaunay/src/path.js
-var epsilon6 = 1e-6;
-var Path2 = class {
+// js/pyobsplot-js/node_modules/d3-delaunay/src/path.js
+var epsilon13 = 1e-6;
+var Path4 = class {
     constructor() {
         this._x0 = this._y0 = // start of current subpath
             this._x1 = this._y1 = null;
         this._ = "";
     }
-    moveTo(x4, y4) {
-        this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
+    moveTo(x7, y7) {
+        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
     }
     closePath() {
         if (this._x1 !== null) {
             this._x1 = this._x0, this._y1 = this._y0;
             this._ += "Z";
         }
     }
-    lineTo(x4, y4) {
-        this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;
+    lineTo(x7, y7) {
+        this._ += `L${this._x1 = +x7},${this._y1 = +y7}`;
     }
-    arc(x4, y4, r) {
-        x4 = +x4, y4 = +y4, r = +r;
-        const x06 = x4 + r;
-        const y06 = y4;
+    arc(x7, y7, r) {
+        x7 = +x7, y7 = +y7, r = +r;
+        const x011 = x7 + r;
+        const y011 = y7;
         if (r < 0)
             throw new Error("negative radius");
         if (this._x1 === null)
-            this._ += `M${x06},${y06}`;
-        else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)
-            this._ += "L" + x06 + "," + y06;
+            this._ += `M${x011},${y011}`;
+        else if (Math.abs(this._x1 - x011) > epsilon13 || Math.abs(this._y1 - y011) > epsilon13)
+            this._ += "L" + x011 + "," + y011;
         if (!r)
             return;
-        this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
+        this._ += `A${r},${r},0,1,1,${x7 - r},${y7}A${r},${r},0,1,1,${this._x1 = x011},${this._y1 = y011}`;
     }
-    rect(x4, y4, w, h) {
-        this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;
+    rect(x7, y7, w, h) {
+        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${+w}v${+h}h${-w}Z`;
     }
     value() {
         return this._ || null;
     }
 };
 
-// node_modules/d3-delaunay/src/polygon.js
-var Polygon = class {
+// js/pyobsplot-js/node_modules/d3-delaunay/src/polygon.js
+var Polygon2 = class {
     constructor() {
         this._ = [];
     }
-    moveTo(x4, y4) {
-        this._.push([x4, y4]);
+    moveTo(x7, y7) {
+        this._.push([x7, y7]);
     }
     closePath() {
         this._.push(this._[0].slice());
     }
-    lineTo(x4, y4) {
-        this._.push([x4, y4]);
+    lineTo(x7, y7) {
+        this._.push([x7, y7]);
     }
     value() {
         return this._.length ? this._ : null;
     }
 };
 
-// node_modules/d3-delaunay/src/voronoi.js
-var Voronoi = class {
+// js/pyobsplot-js/node_modules/d3-delaunay/src/voronoi.js
+var Voronoi3 = class {
     constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
         if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
             throw new Error("invalid bounds");
         this.delaunay = delaunay;
         this._circumcenters = new Float64Array(delaunay.points.length * 2);
         this.vectors = new Float64Array(delaunay.points.length * 2);
         this.xmax = xmax, this.xmin = xmin;
@@ -9150,109 +43842,114 @@
         this._init();
         return this;
     }
     _init() {
         const {
             delaunay: {
                 points,
-                hull: hull2,
+                hull: hull3,
                 triangles
             },
             vectors
         } = this;
+        let bx, by;
         const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
-        for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {
-            const t13 = triangles[i] * 2;
-            const t22 = triangles[i + 1] * 2;
-            const t32 = triangles[i + 2] * 2;
-            const x13 = points[t13];
-            const y13 = points[t13 + 1];
-            const x22 = points[t22];
-            const y22 = points[t22 + 1];
-            const x32 = points[t32];
-            const y32 = points[t32 + 1];
-            const dx = x22 - x13;
-            const dy = y22 - y13;
-            const ex = x32 - x13;
-            const ey = y32 - y13;
-            const ab4 = (dx * ey - dy * ex) * 2;
-            if (Math.abs(ab4) < 1e-9) {
-                let a4 = 1e9;
-                const r = triangles[0] * 2;
-                a4 *= Math.sign((points[r] - x13) * ey - (points[r + 1] - y13) * ex);
-                x4 = (x13 + x32) / 2 - a4 * ey;
-                y4 = (y13 + y32) / 2 + a4 * ex;
+        for (let i = 0, j = 0, n = triangles.length, x7, y7; i < n; i += 3, j += 2) {
+            const t15 = triangles[i] * 2;
+            const t23 = triangles[i + 1] * 2;
+            const t33 = triangles[i + 2] * 2;
+            const x14 = points[t15];
+            const y14 = points[t15 + 1];
+            const x22 = points[t23];
+            const y22 = points[t23 + 1];
+            const x32 = points[t33];
+            const y32 = points[t33 + 1];
+            const dx = x22 - x14;
+            const dy = y22 - y14;
+            const ex = x32 - x14;
+            const ey = y32 - y14;
+            const ab7 = (dx * ey - dy * ex) * 2;
+            if (Math.abs(ab7) < 1e-9) {
+                if (bx === void 0) {
+                    bx = by = 0;
+                    for (const i2 of hull3)
+                        bx += points[i2 * 2], by += points[i2 * 2 + 1];
+                    bx /= hull3.length, by /= hull3.length;
+                }
+                const a7 = 1e9 * Math.sign((bx - x14) * ey - (by - y14) * ex);
+                x7 = (x14 + x32) / 2 - a7 * ey;
+                y7 = (y14 + y32) / 2 + a7 * ex;
             } else {
-                const d = 1 / ab4;
+                const d = 1 / ab7;
                 const bl = dx * dx + dy * dy;
                 const cl = ex * ex + ey * ey;
-                x4 = x13 + (ey * bl - dy * cl) * d;
-                y4 = y13 + (dx * cl - ex * bl) * d;
+                x7 = x14 + (ey * bl - dy * cl) * d;
+                y7 = y14 + (dx * cl - ex * bl) * d;
             }
-            circumcenters[j] = x4;
-            circumcenters[j + 1] = y4;
+            circumcenters[j] = x7;
+            circumcenters[j + 1] = y7;
         }
-        let h = hull2[hull2.length - 1];
-        let p02, p1 = h * 4;
-        let x06, x12 = points[2 * h];
-        let y06, y12 = points[2 * h + 1];
+        let h = hull3[hull3.length - 1];
+        let p03, p1 = h * 4;
+        let x011, x13 = points[2 * h];
+        let y011, y13 = points[2 * h + 1];
         vectors.fill(0);
-        for (let i = 0; i < hull2.length; ++i) {
-            h = hull2[i];
-            p02 = p1, x06 = x12, y06 = y12;
-            p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];
-            vectors[p02 + 2] = vectors[p1] = y06 - y12;
-            vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
+        for (let i = 0; i < hull3.length; ++i) {
+            h = hull3[i];
+            p03 = p1, x011 = x13, y011 = y13;
+            p1 = h * 4, x13 = points[2 * h], y13 = points[2 * h + 1];
+            vectors[p03 + 2] = vectors[p1] = y011 - y13;
+            vectors[p03 + 3] = vectors[p1 + 1] = x13 - x011;
         }
     }
     render(context) {
-        const buffer = context == null ? context = new Path2() : void 0;
+        const buffer = context == null ? context = new Path4() : void 0;
         const {
             delaunay: {
                 halfedges,
                 inedges,
-                hull: hull2
+                hull: hull3
             },
             circumcenters,
             vectors
         } = this;
-        if (hull2.length <= 1)
+        if (hull3.length <= 1)
             return null;
         for (let i = 0, n = halfedges.length; i < n; ++i) {
             const j = halfedges[i];
             if (j < i)
                 continue;
             const ti = Math.floor(i / 3) * 2;
             const tj = Math.floor(j / 3) * 2;
             const xi = circumcenters[ti];
             const yi = circumcenters[ti + 1];
             const xj = circumcenters[tj];
             const yj = circumcenters[tj + 1];
             this._renderSegment(xi, yi, xj, yj, context);
         }
-        let h0, h1 = hull2[hull2.length - 1];
-        for (let i = 0; i < hull2.length; ++i) {
-            h0 = h1, h1 = hull2[i];
+        let h0, h1 = hull3[hull3.length - 1];
+        for (let i = 0; i < hull3.length; ++i) {
+            h0 = h1, h1 = hull3[i];
             const t = Math.floor(inedges[h1] / 3) * 2;
-            const x4 = circumcenters[t];
-            const y4 = circumcenters[t + 1];
-            const v2 = h0 * 4;
-            const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);
+            const x7 = circumcenters[t];
+            const y7 = circumcenters[t + 1];
+            const v3 = h0 * 4;
+            const p = this._project(x7, y7, vectors[v3 + 2], vectors[v3 + 3]);
             if (p)
-                this._renderSegment(x4, y4, p[0], p[1], context);
+                this._renderSegment(x7, y7, p[0], p[1], context);
         }
         return buffer && buffer.value();
     }
     renderBounds(context) {
-        const buffer = context == null ? context = new Path2() : void 0;
+        const buffer = context == null ? context = new Path4() : void 0;
         context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
         return buffer && buffer.value();
     }
     renderCell(i, context) {
-            const buffer = context == null ? context = new Path2() : void 0;
+            const buffer = context == null ? context = new Path4() : void 0;
             const points = this._clip(i);
             if (points === null || !points.length)
                 return;
             context.moveTo(points[0], points[1]);
             let n = points.length;
             while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)
                 n -= 2;
@@ -9266,51 +43963,51 @@
         * cellPolygons() {
             const {
                 delaunay: {
                     points
                 }
             } = this;
             for (let i = 0, n = points.length / 2; i < n; ++i) {
-                const cell2 = this.cellPolygon(i);
-                if (cell2)
-                    cell2.index = i, yield cell2;
+                const cell3 = this.cellPolygon(i);
+                if (cell3)
+                    cell3.index = i, yield cell3;
             }
         }
     cellPolygon(i) {
-        const polygon = new Polygon();
+        const polygon = new Polygon2();
         this.renderCell(i, polygon);
         return polygon.value();
     }
-    _renderSegment(x06, y06, x12, y12, context) {
+    _renderSegment(x011, y011, x13, y13, context) {
         let S;
-        const c0 = this._regioncode(x06, y06);
-        const c1 = this._regioncode(x12, y12);
+        const c0 = this._regioncode(x011, y011);
+        const c1 = this._regioncode(x13, y13);
         if (c0 === 0 && c1 === 0) {
-            context.moveTo(x06, y06);
-            context.lineTo(x12, y12);
-        } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
+            context.moveTo(x011, y011);
+            context.lineTo(x13, y13);
+        } else if (S = this._clipSegment(x011, y011, x13, y13, c0, c1)) {
             context.moveTo(S[0], S[1]);
             context.lineTo(S[2], S[3]);
         }
     }
-    contains(i, x4, y4) {
-            if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))
+    contains(i, x7, y7) {
+            if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
                 return false;
-            return this.delaunay._step(i, x4, y4) === i;
+            return this.delaunay._step(i, x7, y7) === i;
         }
         * neighbors(i) {
             const ci = this._clip(i);
             if (ci)
                 for (const j of this.delaunay.neighbors(i)) {
                     const cj = this._clip(j);
                     if (cj)
                         loop:
                         for (let ai = 0, li = ci.length; ai < li; ai += 2) {
                             for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
-                                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
+                                if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                                     yield j;
                                     break loop;
                                 }
                             }
                         }
                 }
         }
@@ -9344,41 +44041,41 @@
         }
         const points = this._cell(i);
         if (points === null)
             return null;
         const {
             vectors: V
         } = this;
-        const v2 = i * 4;
-        return V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points);
+        const v3 = i * 4;
+        return this._simplify(V[v3] || V[v3 + 1] ? this._clipInfinite(i, points, V[v3], V[v3 + 1], V[v3 + 2], V[v3 + 3]) : this._clipFinite(i, points));
     }
     _clipFinite(i, points) {
         const n = points.length;
         let P = null;
-        let x06, y06, x12 = points[n - 2],
-            y12 = points[n - 1];
-        let c0, c1 = this._regioncode(x12, y12);
+        let x011, y011, x13 = points[n - 2],
+            y13 = points[n - 1];
+        let c0, c1 = this._regioncode(x13, y13);
         let e0, e1 = 0;
         for (let j = 0; j < n; j += 2) {
-            x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];
-            c0 = c1, c1 = this._regioncode(x12, y12);
+            x011 = x13, y011 = y13, x13 = points[j], y13 = points[j + 1];
+            c0 = c1, c1 = this._regioncode(x13, y13);
             if (c0 === 0 && c1 === 0) {
                 e0 = e1, e1 = 0;
                 if (P)
-                    P.push(x12, y12);
+                    P.push(x13, y13);
                 else
-                    P = [x12, y12];
+                    P = [x13, y13];
             } else {
                 let S, sx0, sy0, sx1, sy1;
                 if (c0 === 0) {
-                    if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)
+                    if ((S = this._clipSegment(x011, y011, x13, y13, c0, c1)) === null)
                         continue;
                     [sx0, sy0, sx1, sy1] = S;
                 } else {
-                    if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)
+                    if ((S = this._clipSegment(x13, y13, x011, y011, c1, c0)) === null)
                         continue;
                     [sx1, sy1, sx0, sy0] = S;
                     e0 = e1, e1 = this._edgecode(sx0, sy0);
                     if (e0 && e1)
                         this._edge(i, e0, e1, P, P.length);
                     if (P)
                         P.push(sx0, sy0);
@@ -9399,33 +44096,36 @@
             if (e0 && e1)
                 this._edge(i, e0, e1, P, P.length);
         } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
             return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
         }
         return P;
     }
-    _clipSegment(x06, y06, x12, y12, c0, c1) {
+    _clipSegment(x011, y011, x13, y13, c0, c1) {
+        const flip3 = c0 < c1;
+        if (flip3)
+            [x011, y011, x13, y13, c0, c1] = [x13, y13, x011, y011, c1, c0];
         while (true) {
             if (c0 === 0 && c1 === 0)
-                return [x06, y06, x12, y12];
+                return flip3 ? [x13, y13, x011, y011] : [x011, y011, x13, y13];
             if (c0 & c1)
                 return null;
-            let x4, y4, c6 = c0 || c1;
-            if (c6 & 8)
-                x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;
-            else if (c6 & 4)
-                x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;
-            else if (c6 & 2)
-                y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;
+            let x7, y7, c11 = c0 || c1;
+            if (c11 & 8)
+                x7 = x011 + (x13 - x011) * (this.ymax - y011) / (y13 - y011), y7 = this.ymax;
+            else if (c11 & 4)
+                x7 = x011 + (x13 - x011) * (this.ymin - y011) / (y13 - y011), y7 = this.ymin;
+            else if (c11 & 2)
+                y7 = y011 + (y13 - y011) * (this.xmax - x011) / (x13 - x011), x7 = this.xmax;
             else
-                y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;
+                y7 = y011 + (y13 - y011) * (this.xmin - x011) / (x13 - x011), x7 = this.xmin;
             if (c0)
-                x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);
+                x011 = x7, y011 = y7, c0 = this._regioncode(x011, y011);
             else
-                x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);
+                x13 = x7, y13 = y7, c1 = this._regioncode(x13, y13);
         }
     }
     _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
         let P = Array.from(points),
             p;
         if (p = this._project(P[0], P[1], vx0, vy0))
             P.unshift(p[0], p[1]);
@@ -9440,267 +44140,273 @@
         } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
             P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
         }
         return P;
     }
     _edge(i, e0, e1, P, j) {
         while (e0 !== e1) {
-            let x4, y4;
+            let x7, y7;
             switch (e0) {
                 case 5:
                     e0 = 4;
                     continue;
                 case 4:
-                    e0 = 6, x4 = this.xmax, y4 = this.ymin;
+                    e0 = 6, x7 = this.xmax, y7 = this.ymin;
                     break;
                 case 6:
                     e0 = 2;
                     continue;
                 case 2:
-                    e0 = 10, x4 = this.xmax, y4 = this.ymax;
+                    e0 = 10, x7 = this.xmax, y7 = this.ymax;
                     break;
                 case 10:
                     e0 = 8;
                     continue;
                 case 8:
-                    e0 = 9, x4 = this.xmin, y4 = this.ymax;
+                    e0 = 9, x7 = this.xmin, y7 = this.ymax;
                     break;
                 case 9:
                     e0 = 1;
                     continue;
                 case 1:
-                    e0 = 5, x4 = this.xmin, y4 = this.ymin;
+                    e0 = 5, x7 = this.xmin, y7 = this.ymin;
                     break;
             }
-            if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {
-                P.splice(j, 0, x4, y4), j += 2;
-            }
-        }
-        if (P.length > 4) {
-            for (let i2 = 0; i2 < P.length; i2 += 2) {
-                const j2 = (i2 + 2) % P.length,
-                    k2 = (i2 + 4) % P.length;
-                if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])
-                    P.splice(j2, 2), i2 -= 2;
+            if ((P[j] !== x7 || P[j + 1] !== y7) && this.contains(i, x7, y7)) {
+                P.splice(j, 0, x7, y7), j += 2;
             }
         }
         return j;
     }
-    _project(x06, y06, vx, vy) {
+    _project(x011, y011, vx, vy) {
         let t = Infinity,
-            c6, x4, y4;
+            c11, x7, y7;
         if (vy < 0) {
-            if (y06 <= this.ymin)
+            if (y011 <= this.ymin)
                 return null;
-            if ((c6 = (this.ymin - y06) / vy) < t)
-                y4 = this.ymin, x4 = x06 + (t = c6) * vx;
+            if ((c11 = (this.ymin - y011) / vy) < t)
+                y7 = this.ymin, x7 = x011 + (t = c11) * vx;
         } else if (vy > 0) {
-            if (y06 >= this.ymax)
+            if (y011 >= this.ymax)
                 return null;
-            if ((c6 = (this.ymax - y06) / vy) < t)
-                y4 = this.ymax, x4 = x06 + (t = c6) * vx;
+            if ((c11 = (this.ymax - y011) / vy) < t)
+                y7 = this.ymax, x7 = x011 + (t = c11) * vx;
         }
         if (vx > 0) {
-            if (x06 >= this.xmax)
+            if (x011 >= this.xmax)
                 return null;
-            if ((c6 = (this.xmax - x06) / vx) < t)
-                x4 = this.xmax, y4 = y06 + (t = c6) * vy;
+            if ((c11 = (this.xmax - x011) / vx) < t)
+                x7 = this.xmax, y7 = y011 + (t = c11) * vy;
         } else if (vx < 0) {
-            if (x06 <= this.xmin)
+            if (x011 <= this.xmin)
                 return null;
-            if ((c6 = (this.xmin - x06) / vx) < t)
-                x4 = this.xmin, y4 = y06 + (t = c6) * vy;
+            if ((c11 = (this.xmin - x011) / vx) < t)
+                x7 = this.xmin, y7 = y011 + (t = c11) * vy;
         }
-        return [x4, y4];
+        return [x7, y7];
     }
-    _edgecode(x4, y4) {
-        return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);
+    _edgecode(x7, y7) {
+        return (x7 === this.xmin ? 1 : x7 === this.xmax ? 2 : 0) | (y7 === this.ymin ? 4 : y7 === this.ymax ? 8 : 0);
     }
-    _regioncode(x4, y4) {
-        return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);
+    _regioncode(x7, y7) {
+        return (x7 < this.xmin ? 1 : x7 > this.xmax ? 2 : 0) | (y7 < this.ymin ? 4 : y7 > this.ymax ? 8 : 0);
+    }
+    _simplify(P) {
+        if (P && P.length > 4) {
+            for (let i = 0; i < P.length; i += 2) {
+                const j = (i + 2) % P.length,
+                    k3 = (i + 4) % P.length;
+                if (P[i] === P[j] && P[j] === P[k3] || P[i + 1] === P[j + 1] && P[j + 1] === P[k3 + 1]) {
+                    P.splice(j, 2), i -= 2;
+                }
+            }
+            if (!P.length)
+                P = null;
+        }
+        return P;
     }
 };
 
-// node_modules/d3-delaunay/src/delaunay.js
-var tau4 = 2 * Math.PI;
-var pow = Math.pow;
+// js/pyobsplot-js/node_modules/d3-delaunay/src/delaunay.js
+var tau11 = 2 * Math.PI;
+var pow4 = Math.pow;
 
-function pointX(p) {
+function pointX2(p) {
     return p[0];
 }
 
-function pointY(p) {
+function pointY2(p) {
     return p[1];
 }
 
-function collinear2(d) {
+function collinear4(d) {
     const {
         triangles,
         coords
     } = d;
     for (let i = 0; i < triangles.length; i += 3) {
-        const a4 = 2 * triangles[i],
+        const a7 = 2 * triangles[i],
             b = 2 * triangles[i + 1],
-            c6 = 2 * triangles[i + 2],
-            cross2 = (coords[c6] - coords[a4]) * (coords[b + 1] - coords[a4 + 1]) - (coords[b] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);
-        if (cross2 > 1e-10)
+            c11 = 2 * triangles[i + 2],
+            cross3 = (coords[c11] - coords[a7]) * (coords[b + 1] - coords[a7 + 1]) - (coords[b] - coords[a7]) * (coords[c11 + 1] - coords[a7 + 1]);
+        if (cross3 > 1e-10)
             return false;
     }
     return true;
 }
 
-function jitter(x4, y4, r) {
-    return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];
+function jitter2(x7, y7, r) {
+    return [x7 + Math.sin(x7 + y7) * r, y7 + Math.cos(x7 - y7) * r];
 }
-var Delaunay = class {
-    static from(points, fx = pointX, fy = pointY, that) {
-        return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
+var Delaunay2 = class {
+    static from(points, fx = pointX2, fy = pointY2, that) {
+        return new Delaunay2("length" in points ? flatArray2(points, fx, fy, that) : Float64Array.from(flatIterable2(points, fx, fy, that)));
     }
     constructor(points) {
-        this._delaunator = new Delaunator(points);
+        this._delaunator = new Delaunator2(points);
         this.inedges = new Int32Array(points.length / 2);
         this._hullIndex = new Int32Array(points.length / 2);
         this.points = this._delaunator.coords;
         this._init();
     }
     update() {
         this._delaunator.update();
         this._init();
         return this;
     }
     _init() {
         const d = this._delaunator,
             points = this.points;
-        if (d.hull && d.hull.length > 2 && collinear2(d)) {
+        if (d.hull && d.hull.length > 2 && collinear4(d)) {
             this.collinear = Int32Array.from({
                 length: points.length / 2
             }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
             const e = this.collinear[0],
                 f = this.collinear[this.collinear.length - 1],
                 bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]],
                 r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
             for (let i = 0, n = points.length / 2; i < n; ++i) {
-                const p = jitter(points[2 * i], points[2 * i + 1], r);
+                const p = jitter2(points[2 * i], points[2 * i + 1], r);
                 points[2 * i] = p[0];
                 points[2 * i + 1] = p[1];
             }
-            this._delaunator = new Delaunator(points);
+            this._delaunator = new Delaunator2(points);
         } else {
             delete this.collinear;
         }
         const halfedges = this.halfedges = this._delaunator.halfedges;
-        const hull2 = this.hull = this._delaunator.hull;
+        const hull3 = this.hull = this._delaunator.hull;
         const triangles = this.triangles = this._delaunator.triangles;
         const inedges = this.inedges.fill(-1);
         const hullIndex = this._hullIndex.fill(-1);
         for (let e = 0, n = halfedges.length; e < n; ++e) {
             const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
             if (halfedges[e] === -1 || inedges[p] === -1)
                 inedges[p] = e;
         }
-        for (let i = 0, n = hull2.length; i < n; ++i) {
-            hullIndex[hull2[i]] = i;
+        for (let i = 0, n = hull3.length; i < n; ++i) {
+            hullIndex[hull3[i]] = i;
         }
-        if (hull2.length <= 2 && hull2.length > 0) {
+        if (hull3.length <= 2 && hull3.length > 0) {
             this.triangles = new Int32Array(3).fill(-1);
             this.halfedges = new Int32Array(3).fill(-1);
-            this.triangles[0] = hull2[0];
-            inedges[hull2[0]] = 1;
-            if (hull2.length === 2) {
-                inedges[hull2[1]] = 0;
-                this.triangles[1] = hull2[1];
-                this.triangles[2] = hull2[1];
+            this.triangles[0] = hull3[0];
+            inedges[hull3[0]] = 1;
+            if (hull3.length === 2) {
+                inedges[hull3[1]] = 0;
+                this.triangles[1] = hull3[1];
+                this.triangles[2] = hull3[1];
             }
         }
     }
     voronoi(bounds) {
-            return new Voronoi(this, bounds);
+            return new Voronoi3(this, bounds);
         }
         * neighbors(i) {
             const {
                 inedges,
-                hull: hull2,
+                hull: hull3,
                 _hullIndex,
                 halfedges,
                 triangles,
-                collinear: collinear3
+                collinear: collinear5
             } = this;
-            if (collinear3) {
-                const l = collinear3.indexOf(i);
+            if (collinear5) {
+                const l = collinear5.indexOf(i);
                 if (l > 0)
-                    yield collinear3[l - 1];
-                if (l < collinear3.length - 1)
-                    yield collinear3[l + 1];
+                    yield collinear5[l - 1];
+                if (l < collinear5.length - 1)
+                    yield collinear5[l + 1];
                 return;
             }
             const e0 = inedges[i];
             if (e0 === -1)
                 return;
             let e = e0,
-                p02 = -1;
+                p03 = -1;
             do {
-                yield p02 = triangles[e];
+                yield p03 = triangles[e];
                 e = e % 3 === 2 ? e - 2 : e + 1;
                 if (triangles[e] !== i)
                     return;
                 e = halfedges[e];
                 if (e === -1) {
-                    const p = hull2[(_hullIndex[i] + 1) % hull2.length];
-                    if (p !== p02)
+                    const p = hull3[(_hullIndex[i] + 1) % hull3.length];
+                    if (p !== p03)
                         yield p;
                     return;
                 }
             } while (e !== e0);
         }
-    find(x4, y4, i = 0) {
-        if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))
+    find(x7, y7, i = 0) {
+        if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
             return -1;
         const i0 = i;
-        let c6;
-        while ((c6 = this._step(i, x4, y4)) >= 0 && c6 !== i && c6 !== i0)
-            i = c6;
-        return c6;
+        let c11;
+        while ((c11 = this._step(i, x7, y7)) >= 0 && c11 !== i && c11 !== i0)
+            i = c11;
+        return c11;
     }
-    _step(i, x4, y4) {
+    _step(i, x7, y7) {
         const {
             inedges,
-            hull: hull2,
+            hull: hull3,
             _hullIndex,
             halfedges,
             triangles,
             points
         } = this;
         if (inedges[i] === -1 || !points.length)
             return (i + 1) % (points.length >> 1);
-        let c6 = i;
-        let dc = pow(x4 - points[i * 2], 2) + pow(y4 - points[i * 2 + 1], 2);
+        let c11 = i;
+        let dc = pow4(x7 - points[i * 2], 2) + pow4(y7 - points[i * 2 + 1], 2);
         const e0 = inedges[i];
         let e = e0;
         do {
             let t = triangles[e];
-            const dt = pow(x4 - points[t * 2], 2) + pow(y4 - points[t * 2 + 1], 2);
+            const dt = pow4(x7 - points[t * 2], 2) + pow4(y7 - points[t * 2 + 1], 2);
             if (dt < dc)
-                dc = dt, c6 = t;
+                dc = dt, c11 = t;
             e = e % 3 === 2 ? e - 2 : e + 1;
             if (triangles[e] !== i)
                 break;
             e = halfedges[e];
             if (e === -1) {
-                e = hull2[(_hullIndex[i] + 1) % hull2.length];
+                e = hull3[(_hullIndex[i] + 1) % hull3.length];
                 if (e !== t) {
-                    if (pow(x4 - points[e * 2], 2) + pow(y4 - points[e * 2 + 1], 2) < dc)
+                    if (pow4(x7 - points[e * 2], 2) + pow4(y7 - points[e * 2 + 1], 2) < dc)
                         return e;
                 }
                 break;
             }
         } while (e !== e0);
-        return c6;
+        return c11;
     }
     render(context) {
-        const buffer = context == null ? context = new Path2() : void 0;
+        const buffer = context == null ? context = new Path4() : void 0;
         const {
             points,
             halfedges,
             triangles
         } = this;
         for (let i = 0, n = halfedges.length; i < n; ++i) {
             const j = halfedges[i];
@@ -9714,659 +44420,659 @@
         this.renderHull(context);
         return buffer && buffer.value();
     }
     renderPoints(context, r) {
         if (r === void 0 && (!context || typeof context.moveTo !== "function"))
             r = context, context = null;
         r = r == void 0 ? 2 : +r;
-        const buffer = context == null ? context = new Path2() : void 0;
+        const buffer = context == null ? context = new Path4() : void 0;
         const {
             points
         } = this;
         for (let i = 0, n = points.length; i < n; i += 2) {
-            const x4 = points[i],
-                y4 = points[i + 1];
-            context.moveTo(x4 + r, y4);
-            context.arc(x4, y4, r, 0, tau4);
+            const x7 = points[i],
+                y7 = points[i + 1];
+            context.moveTo(x7 + r, y7);
+            context.arc(x7, y7, r, 0, tau11);
         }
         return buffer && buffer.value();
     }
     renderHull(context) {
-        const buffer = context == null ? context = new Path2() : void 0;
+        const buffer = context == null ? context = new Path4() : void 0;
         const {
-            hull: hull2,
+            hull: hull3,
             points
         } = this;
-        const h = hull2[0] * 2,
-            n = hull2.length;
+        const h = hull3[0] * 2,
+            n = hull3.length;
         context.moveTo(points[h], points[h + 1]);
         for (let i = 1; i < n; ++i) {
-            const h2 = 2 * hull2[i];
+            const h2 = 2 * hull3[i];
             context.lineTo(points[h2], points[h2 + 1]);
         }
         context.closePath();
         return buffer && buffer.value();
     }
     hullPolygon() {
-        const polygon = new Polygon();
+        const polygon = new Polygon2();
         this.renderHull(polygon);
         return polygon.value();
     }
     renderTriangle(i, context) {
-            const buffer = context == null ? context = new Path2() : void 0;
+            const buffer = context == null ? context = new Path4() : void 0;
             const {
                 points,
                 triangles
             } = this;
-            const t03 = triangles[i *= 3] * 2;
-            const t13 = triangles[i + 1] * 2;
-            const t22 = triangles[i + 2] * 2;
-            context.moveTo(points[t03], points[t03 + 1]);
-            context.lineTo(points[t13], points[t13 + 1]);
-            context.lineTo(points[t22], points[t22 + 1]);
+            const t05 = triangles[i *= 3] * 2;
+            const t15 = triangles[i + 1] * 2;
+            const t23 = triangles[i + 2] * 2;
+            context.moveTo(points[t05], points[t05 + 1]);
+            context.lineTo(points[t15], points[t15 + 1]);
+            context.lineTo(points[t23], points[t23 + 1]);
             context.closePath();
             return buffer && buffer.value();
         }
         * trianglePolygons() {
             const {
                 triangles
             } = this;
             for (let i = 0, n = triangles.length / 3; i < n; ++i) {
                 yield this.trianglePolygon(i);
             }
         }
     trianglePolygon(i) {
-        const polygon = new Polygon();
+        const polygon = new Polygon2();
         this.renderTriangle(i, polygon);
         return polygon.value();
     }
 };
 
-function flatArray(points, fx, fy, that) {
+function flatArray2(points, fx, fy, that) {
     const n = points.length;
-    const array4 = new Float64Array(n * 2);
+    const array7 = new Float64Array(n * 2);
     for (let i = 0; i < n; ++i) {
         const p = points[i];
-        array4[i * 2] = fx.call(that, p, i, points);
-        array4[i * 2 + 1] = fy.call(that, p, i, points);
+        array7[i * 2] = fx.call(that, p, i, points);
+        array7[i * 2 + 1] = fy.call(that, p, i, points);
     }
-    return array4;
+    return array7;
 }
 
-function* flatIterable(points, fx, fy, that) {
+function* flatIterable2(points, fx, fy, that) {
     let i = 0;
     for (const p of points) {
         yield fx.call(that, p, i, points);
         yield fy.call(that, p, i, points);
         ++i;
     }
 }
 
-// node_modules/d3-dsv/src/dsv.js
-var EOL = {};
-var EOF = {};
-var QUOTE = 34;
-var NEWLINE = 10;
-var RETURN = 13;
+// js/pyobsplot-js/node_modules/d3-dsv/src/dsv.js
+var EOL2 = {};
+var EOF2 = {};
+var QUOTE2 = 34;
+var NEWLINE2 = 10;
+var RETURN2 = 13;
 
-function objectConverter(columns) {
+function objectConverter2(columns) {
     return new Function("d", "return {" + columns.map(function(name, i) {
         return JSON.stringify(name) + ": d[" + i + '] || ""';
     }).join(",") + "}");
 }
 
-function customConverter(columns, f) {
-    var object2 = objectConverter(columns);
+function customConverter2(columns, f) {
+    var object3 = objectConverter2(columns);
     return function(row, i) {
-        return f(object2(row), i, columns);
+        return f(object3(row), i, columns);
     };
 }
 
-function inferColumns(rows) {
+function inferColumns2(rows) {
     var columnSet = /* @__PURE__ */ Object.create(null),
         columns = [];
     rows.forEach(function(row) {
-        for (var column2 in row) {
-            if (!(column2 in columnSet)) {
-                columns.push(columnSet[column2] = column2);
+        for (var column3 in row) {
+            if (!(column3 in columnSet)) {
+                columns.push(columnSet[column3] = column3);
             }
         }
     });
     return columns;
 }
 
-function pad(value, width) {
-    var s2 = value + "",
-        length4 = s2.length;
-    return length4 < width ? new Array(width - length4 + 1).join(0) + s2 : s2;
+function pad4(value, width) {
+    var s3 = value + "",
+        length7 = s3.length;
+    return length7 < width ? new Array(width - length7 + 1).join(0) + s3 : s3;
 }
 
-function formatYear(year) {
-    return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
+function formatYear4(year) {
+    return year < 0 ? "-" + pad4(-year, 6) : year > 9999 ? "+" + pad4(year, 6) : pad4(year, 4);
 }
 
-function formatDate(date2) {
-    var hours = date2.getUTCHours(),
-        minutes = date2.getUTCMinutes(),
-        seconds2 = date2.getUTCSeconds(),
-        milliseconds2 = date2.getUTCMilliseconds();
-    return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
+function formatDate2(date3) {
+    var hours = date3.getUTCHours(),
+        minutes = date3.getUTCMinutes(),
+        seconds3 = date3.getUTCSeconds(),
+        milliseconds3 = date3.getUTCMilliseconds();
+    return isNaN(date3) ? "Invalid Date" : formatYear4(date3.getUTCFullYear(), 4) + "-" + pad4(date3.getUTCMonth() + 1, 2) + "-" + pad4(date3.getUTCDate(), 2) + (milliseconds3 ? "T" + pad4(hours, 2) + ":" + pad4(minutes, 2) + ":" + pad4(seconds3, 2) + "." + pad4(milliseconds3, 3) + "Z" : seconds3 ? "T" + pad4(hours, 2) + ":" + pad4(minutes, 2) + ":" + pad4(seconds3, 2) + "Z" : minutes || hours ? "T" + pad4(hours, 2) + ":" + pad4(minutes, 2) + "Z" : "");
 }
 
-function dsv_default(delimiter) {
+function dsv_default2(delimiter) {
     var reFormat = new RegExp('["' + delimiter + "\n\r]"),
         DELIMITER = delimiter.charCodeAt(0);
 
-    function parse2(text2, f) {
-        var convert, columns, rows = parseRows(text2, function(row, i) {
+    function parse3(text3, f) {
+        var convert, columns, rows = parseRows(text3, function(row, i) {
             if (convert)
                 return convert(row, i - 1);
-            columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
+            columns = row, convert = f ? customConverter2(row, f) : objectConverter2(row);
         });
         rows.columns = columns || [];
         return rows;
     }
 
-    function parseRows(text2, f) {
+    function parseRows(text3, f) {
         var rows = [],
-            N = text2.length,
+            N = text3.length,
             I = 0,
             n = 0,
             t, eof = N <= 0,
             eol = false;
-        if (text2.charCodeAt(N - 1) === NEWLINE)
+        if (text3.charCodeAt(N - 1) === NEWLINE2)
             --N;
-        if (text2.charCodeAt(N - 1) === RETURN)
+        if (text3.charCodeAt(N - 1) === RETURN2)
             --N;
 
         function token() {
             if (eof)
-                return EOF;
+                return EOF2;
             if (eol)
-                return eol = false, EOL;
+                return eol = false, EOL2;
             var i, j = I,
-                c6;
-            if (text2.charCodeAt(j) === QUOTE) {
-                while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
+                c11;
+            if (text3.charCodeAt(j) === QUOTE2) {
+                while (I++ < N && text3.charCodeAt(I) !== QUOTE2 || text3.charCodeAt(++I) === QUOTE2)
                 ;
                 if ((i = I) >= N)
                     eof = true;
-                else if ((c6 = text2.charCodeAt(I++)) === NEWLINE)
+                else if ((c11 = text3.charCodeAt(I++)) === NEWLINE2)
                     eol = true;
-                else if (c6 === RETURN) {
+                else if (c11 === RETURN2) {
                     eol = true;
-                    if (text2.charCodeAt(I) === NEWLINE)
+                    if (text3.charCodeAt(I) === NEWLINE2)
                         ++I;
                 }
-                return text2.slice(j + 1, i - 1).replace(/""/g, '"');
+                return text3.slice(j + 1, i - 1).replace(/""/g, '"');
             }
             while (I < N) {
-                if ((c6 = text2.charCodeAt(i = I++)) === NEWLINE)
+                if ((c11 = text3.charCodeAt(i = I++)) === NEWLINE2)
                     eol = true;
-                else if (c6 === RETURN) {
+                else if (c11 === RETURN2) {
                     eol = true;
-                    if (text2.charCodeAt(I) === NEWLINE)
+                    if (text3.charCodeAt(I) === NEWLINE2)
                         ++I;
-                } else if (c6 !== DELIMITER)
+                } else if (c11 !== DELIMITER)
                     continue;
-                return text2.slice(j, i);
+                return text3.slice(j, i);
             }
-            return eof = true, text2.slice(j, N);
+            return eof = true, text3.slice(j, N);
         }
-        while ((t = token()) !== EOF) {
+        while ((t = token()) !== EOF2) {
             var row = [];
-            while (t !== EOL && t !== EOF)
+            while (t !== EOL2 && t !== EOF2)
                 row.push(t), t = token();
             if (f && (row = f(row, n++)) == null)
                 continue;
             rows.push(row);
         }
         return rows;
     }
 
     function preformatBody(rows, columns) {
         return rows.map(function(row) {
-            return columns.map(function(column2) {
-                return formatValue(row[column2]);
+            return columns.map(function(column3) {
+                return formatValue(row[column3]);
             }).join(delimiter);
         });
     }
 
-    function format3(rows, columns) {
+    function format5(rows, columns) {
         if (columns == null)
-            columns = inferColumns(rows);
+            columns = inferColumns2(rows);
         return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
     }
 
     function formatBody(rows, columns) {
         if (columns == null)
-            columns = inferColumns(rows);
+            columns = inferColumns2(rows);
         return preformatBody(rows, columns).join("\n");
     }
 
     function formatRows(rows) {
         return rows.map(formatRow).join("\n");
     }
 
     function formatRow(row) {
         return row.map(formatValue).join(delimiter);
     }
 
     function formatValue(value) {
-        return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
+        return value == null ? "" : value instanceof Date ? formatDate2(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
     }
     return {
-        parse: parse2,
+        parse: parse3,
         parseRows,
-        format: format3,
+        format: format5,
         formatBody,
         formatRows,
         formatRow,
         formatValue
     };
 }
 
-// node_modules/d3-dsv/src/csv.js
-var csv = dsv_default(",");
-var csvParse = csv.parse;
-var csvParseRows = csv.parseRows;
-var csvFormat = csv.format;
-var csvFormatBody = csv.formatBody;
-var csvFormatRows = csv.formatRows;
-var csvFormatRow = csv.formatRow;
-var csvFormatValue = csv.formatValue;
-
-// node_modules/d3-dsv/src/tsv.js
-var tsv = dsv_default("	");
-var tsvParse = tsv.parse;
-var tsvParseRows = tsv.parseRows;
-var tsvFormat = tsv.format;
-var tsvFormatBody = tsv.formatBody;
-var tsvFormatRows = tsv.formatRows;
-var tsvFormatRow = tsv.formatRow;
-var tsvFormatValue = tsv.formatValue;
-
-// node_modules/d3-dsv/src/autoType.js
-function autoType(object2) {
-    for (var key in object2) {
-        var value = object2[key].trim(),
-            number7, m3;
+// js/pyobsplot-js/node_modules/d3-dsv/src/csv.js
+var csv3 = dsv_default2(",");
+var csvParse2 = csv3.parse;
+var csvParseRows2 = csv3.parseRows;
+var csvFormat2 = csv3.format;
+var csvFormatBody2 = csv3.formatBody;
+var csvFormatRows2 = csv3.formatRows;
+var csvFormatRow2 = csv3.formatRow;
+var csvFormatValue2 = csv3.formatValue;
+
+// js/pyobsplot-js/node_modules/d3-dsv/src/tsv.js
+var tsv3 = dsv_default2("	");
+var tsvParse2 = tsv3.parse;
+var tsvParseRows2 = tsv3.parseRows;
+var tsvFormat2 = tsv3.format;
+var tsvFormatBody2 = tsv3.formatBody;
+var tsvFormatRows2 = tsv3.formatRows;
+var tsvFormatRow2 = tsv3.formatRow;
+var tsvFormatValue2 = tsv3.formatValue;
+
+// js/pyobsplot-js/node_modules/d3-dsv/src/autoType.js
+function autoType2(object3) {
+    for (var key in object3) {
+        var value = object3[key].trim(),
+            number14, m5;
         if (!value)
             value = null;
         else if (value === "true")
             value = true;
         else if (value === "false")
             value = false;
         else if (value === "NaN")
             value = NaN;
-        else if (!isNaN(number7 = +value))
-            value = number7;
-        else if (m3 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
-            if (fixtz && !!m3[4] && !m3[7])
+        else if (!isNaN(number14 = +value))
+            value = number14;
+        else if (m5 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
+            if (fixtz2 && !!m5[4] && !m5[7])
                 value = value.replace(/-/g, "/").replace(/T/, " ");
             value = new Date(value);
         } else
             continue;
-        object2[key] = value;
+        object3[key] = value;
     }
-    return object2;
+    return object3;
 }
-var fixtz = ( /* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || ( /* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();
+var fixtz2 = ( /* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || ( /* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();
 
-// node_modules/d3-fetch/src/blob.js
-function responseBlob(response) {
+// js/pyobsplot-js/node_modules/d3-fetch/src/blob.js
+function responseBlob2(response) {
     if (!response.ok)
         throw new Error(response.status + " " + response.statusText);
     return response.blob();
 }
 
-function blob_default(input, init2) {
-    return fetch(input, init2).then(responseBlob);
+function blob_default2(input, init3) {
+    return fetch(input, init3).then(responseBlob2);
 }
 
-// node_modules/d3-fetch/src/buffer.js
-function responseArrayBuffer(response) {
+// js/pyobsplot-js/node_modules/d3-fetch/src/buffer.js
+function responseArrayBuffer2(response) {
     if (!response.ok)
         throw new Error(response.status + " " + response.statusText);
     return response.arrayBuffer();
 }
 
-function buffer_default(input, init2) {
-    return fetch(input, init2).then(responseArrayBuffer);
+function buffer_default3(input, init3) {
+    return fetch(input, init3).then(responseArrayBuffer2);
 }
 
-// node_modules/d3-fetch/src/text.js
-function responseText(response) {
+// js/pyobsplot-js/node_modules/d3-fetch/src/text.js
+function responseText2(response) {
     if (!response.ok)
         throw new Error(response.status + " " + response.statusText);
     return response.text();
 }
 
-function text_default3(input, init2) {
-    return fetch(input, init2).then(responseText);
+function text_default6(input, init3) {
+    return fetch(input, init3).then(responseText2);
 }
 
-// node_modules/d3-fetch/src/dsv.js
-function dsvParse(parse2) {
-    return function(input, init2, row) {
-        if (arguments.length === 2 && typeof init2 === "function")
-            row = init2, init2 = void 0;
-        return text_default3(input, init2).then(function(response) {
-            return parse2(response, row);
+// js/pyobsplot-js/node_modules/d3-fetch/src/dsv.js
+function dsvParse2(parse3) {
+    return function(input, init3, row) {
+        if (arguments.length === 2 && typeof init3 === "function")
+            row = init3, init3 = void 0;
+        return text_default6(input, init3).then(function(response) {
+            return parse3(response, row);
         });
     };
 }
 
-function dsv(delimiter, input, init2, row) {
-    if (arguments.length === 3 && typeof init2 === "function")
-        row = init2, init2 = void 0;
-    var format3 = dsv_default(delimiter);
-    return text_default3(input, init2).then(function(response) {
-        return format3.parse(response, row);
+function dsv2(delimiter, input, init3, row) {
+    if (arguments.length === 3 && typeof init3 === "function")
+        row = init3, init3 = void 0;
+    var format5 = dsv_default2(delimiter);
+    return text_default6(input, init3).then(function(response) {
+        return format5.parse(response, row);
     });
 }
-var csv2 = dsvParse(csvParse);
-var tsv2 = dsvParse(tsvParse);
+var csv4 = dsvParse2(csvParse2);
+var tsv4 = dsvParse2(tsvParse2);
 
-// node_modules/d3-fetch/src/image.js
-function image_default(input, init2) {
+// js/pyobsplot-js/node_modules/d3-fetch/src/image.js
+function image_default2(input, init3) {
     return new Promise(function(resolve, reject) {
-        var image2 = new Image();
-        for (var key in init2)
-            image2[key] = init2[key];
-        image2.onerror = reject;
-        image2.onload = function() {
-            resolve(image2);
+        var image3 = new Image();
+        for (var key in init3)
+            image3[key] = init3[key];
+        image3.onerror = reject;
+        image3.onload = function() {
+            resolve(image3);
         };
-        image2.src = input;
+        image3.src = input;
     });
 }
 
-// node_modules/d3-fetch/src/json.js
-function responseJson(response) {
+// js/pyobsplot-js/node_modules/d3-fetch/src/json.js
+function responseJson2(response) {
     if (!response.ok)
         throw new Error(response.status + " " + response.statusText);
     if (response.status === 204 || response.status === 205)
         return;
     return response.json();
 }
 
-function json_default(input, init2) {
-    return fetch(input, init2).then(responseJson);
+function json_default2(input, init3) {
+    return fetch(input, init3).then(responseJson2);
 }
 
-// node_modules/d3-fetch/src/xml.js
-function parser(type2) {
-    return (input, init2) => text_default3(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));
+// js/pyobsplot-js/node_modules/d3-fetch/src/xml.js
+function parser2(type3) {
+    return (input, init3) => text_default6(input, init3).then((text3) => new DOMParser().parseFromString(text3, type3));
 }
-var xml_default = parser("application/xml");
-var html = parser("text/html");
-var svg = parser("image/svg+xml");
+var xml_default2 = parser2("application/xml");
+var html2 = parser2("text/html");
+var svg2 = parser2("image/svg+xml");
 
-// node_modules/d3-force/src/center.js
-function center_default(x4, y4) {
+// js/pyobsplot-js/node_modules/d3-force/src/center.js
+function center_default2(x7, y7) {
     var nodes, strength = 1;
-    if (x4 == null)
-        x4 = 0;
-    if (y4 == null)
-        y4 = 0;
+    if (x7 == null)
+        x7 = 0;
+    if (y7 == null)
+        y7 = 0;
 
     function force() {
         var i, n = nodes.length,
             node, sx = 0,
             sy = 0;
         for (i = 0; i < n; ++i) {
             node = nodes[i], sx += node.x, sy += node.y;
         }
-        for (sx = (sx / n - x4) * strength, sy = (sy / n - y4) * strength, i = 0; i < n; ++i) {
+        for (sx = (sx / n - x7) * strength, sy = (sy / n - y7) * strength, i = 0; i < n; ++i) {
             node = nodes[i], node.x -= sx, node.y -= sy;
         }
     }
     force.initialize = function(_) {
         nodes = _;
     };
     force.x = function(_) {
-        return arguments.length ? (x4 = +_, force) : x4;
+        return arguments.length ? (x7 = +_, force) : x7;
     };
     force.y = function(_) {
-        return arguments.length ? (y4 = +_, force) : y4;
+        return arguments.length ? (y7 = +_, force) : y7;
     };
     force.strength = function(_) {
         return arguments.length ? (strength = +_, force) : strength;
     };
     return force;
 }
 
-// node_modules/d3-quadtree/src/add.js
-function add_default(d) {
-    const x4 = +this._x.call(null, d),
-        y4 = +this._y.call(null, d);
-    return add(this.cover(x4, y4), x4, y4, d);
+// js/pyobsplot-js/node_modules/d3-quadtree/src/add.js
+function add_default2(d) {
+    const x7 = +this._x.call(null, d),
+        y7 = +this._y.call(null, d);
+    return add2(this.cover(x7, y7), x7, y7, d);
 }
 
-function add(tree2, x4, y4, d) {
-    if (isNaN(x4) || isNaN(y4))
-        return tree2;
-    var parent, node = tree2._root,
+function add2(tree3, x7, y7, d) {
+    if (isNaN(x7) || isNaN(y7))
+        return tree3;
+    var parent, node = tree3._root,
         leaf = {
             data: d
         },
-        x06 = tree2._x0,
-        y06 = tree2._y0,
-        x12 = tree2._x1,
-        y12 = tree2._y1,
-        xm, ym, xp, yp, right2, bottom2, i, j;
+        x011 = tree3._x0,
+        y011 = tree3._y0,
+        x13 = tree3._x1,
+        y13 = tree3._y1,
+        xm, ym, xp, yp, right3, bottom3, i, j;
     if (!node)
-        return tree2._root = leaf, tree2;
+        return tree3._root = leaf, tree3;
     while (node.length) {
-        if (right2 = x4 >= (xm = (x06 + x12) / 2))
-            x06 = xm;
+        if (right3 = x7 >= (xm = (x011 + x13) / 2))
+            x011 = xm;
         else
-            x12 = xm;
-        if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
-            y06 = ym;
+            x13 = xm;
+        if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+            y011 = ym;
         else
-            y12 = ym;
-        if (parent = node, !(node = node[i = bottom2 << 1 | right2]))
-            return parent[i] = leaf, tree2;
-    }
-    xp = +tree2._x.call(null, node.data);
-    yp = +tree2._y.call(null, node.data);
-    if (x4 === xp && y4 === yp)
-        return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
+            y13 = ym;
+        if (parent = node, !(node = node[i = bottom3 << 1 | right3]))
+            return parent[i] = leaf, tree3;
+    }
+    xp = +tree3._x.call(null, node.data);
+    yp = +tree3._y.call(null, node.data);
+    if (x7 === xp && y7 === yp)
+        return leaf.next = node, parent ? parent[i] = leaf : tree3._root = leaf, tree3;
     do {
-        parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
-        if (right2 = x4 >= (xm = (x06 + x12) / 2))
-            x06 = xm;
+        parent = parent ? parent[i] = new Array(4) : tree3._root = new Array(4);
+        if (right3 = x7 >= (xm = (x011 + x13) / 2))
+            x011 = xm;
         else
-            x12 = xm;
-        if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
-            y06 = ym;
+            x13 = xm;
+        if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+            y011 = ym;
         else
-            y12 = ym;
-    } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
-    return parent[j] = node, parent[i] = leaf, tree2;
+            y13 = ym;
+    } while ((i = bottom3 << 1 | right3) === (j = (yp >= ym) << 1 | xp >= xm));
+    return parent[j] = node, parent[i] = leaf, tree3;
 }
 
-function addAll(data) {
+function addAll2(data) {
     var d, i, n = data.length,
-        x4, y4, xz = new Array(n),
+        x7, y7, xz = new Array(n),
         yz = new Array(n),
-        x06 = Infinity,
-        y06 = Infinity,
-        x12 = -Infinity,
-        y12 = -Infinity;
+        x011 = Infinity,
+        y011 = Infinity,
+        x13 = -Infinity,
+        y13 = -Infinity;
     for (i = 0; i < n; ++i) {
-        if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))
+        if (isNaN(x7 = +this._x.call(null, d = data[i])) || isNaN(y7 = +this._y.call(null, d)))
             continue;
-        xz[i] = x4;
-        yz[i] = y4;
-        if (x4 < x06)
-            x06 = x4;
-        if (x4 > x12)
-            x12 = x4;
-        if (y4 < y06)
-            y06 = y4;
-        if (y4 > y12)
-            y12 = y4;
+        xz[i] = x7;
+        yz[i] = y7;
+        if (x7 < x011)
+            x011 = x7;
+        if (x7 > x13)
+            x13 = x7;
+        if (y7 < y011)
+            y011 = y7;
+        if (y7 > y13)
+            y13 = y7;
     }
-    if (x06 > x12 || y06 > y12)
+    if (x011 > x13 || y011 > y13)
         return this;
-    this.cover(x06, y06).cover(x12, y12);
+    this.cover(x011, y011).cover(x13, y13);
     for (i = 0; i < n; ++i) {
-        add(this, xz[i], yz[i], data[i]);
+        add2(this, xz[i], yz[i], data[i]);
     }
     return this;
 }
 
-// node_modules/d3-quadtree/src/cover.js
-function cover_default(x4, y4) {
-    if (isNaN(x4 = +x4) || isNaN(y4 = +y4))
+// js/pyobsplot-js/node_modules/d3-quadtree/src/cover.js
+function cover_default2(x7, y7) {
+    if (isNaN(x7 = +x7) || isNaN(y7 = +y7))
         return this;
-    var x06 = this._x0,
-        y06 = this._y0,
-        x12 = this._x1,
-        y12 = this._y1;
-    if (isNaN(x06)) {
-        x12 = (x06 = Math.floor(x4)) + 1;
-        y12 = (y06 = Math.floor(y4)) + 1;
+    var x011 = this._x0,
+        y011 = this._y0,
+        x13 = this._x1,
+        y13 = this._y1;
+    if (isNaN(x011)) {
+        x13 = (x011 = Math.floor(x7)) + 1;
+        y13 = (y011 = Math.floor(y7)) + 1;
     } else {
-        var z = x12 - x06 || 1,
+        var z = x13 - x011 || 1,
             node = this._root,
             parent, i;
-        while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {
-            i = (y4 < y06) << 1 | x4 < x06;
+        while (x011 > x7 || x7 >= x13 || y011 > y7 || y7 >= y13) {
+            i = (y7 < y011) << 1 | x7 < x011;
             parent = new Array(4), parent[i] = node, node = parent, z *= 2;
             switch (i) {
                 case 0:
-                    x12 = x06 + z, y12 = y06 + z;
+                    x13 = x011 + z, y13 = y011 + z;
                     break;
                 case 1:
-                    x06 = x12 - z, y12 = y06 + z;
+                    x011 = x13 - z, y13 = y011 + z;
                     break;
                 case 2:
-                    x12 = x06 + z, y06 = y12 - z;
+                    x13 = x011 + z, y011 = y13 - z;
                     break;
                 case 3:
-                    x06 = x12 - z, y06 = y12 - z;
+                    x011 = x13 - z, y011 = y13 - z;
                     break;
             }
         }
         if (this._root && this._root.length)
             this._root = node;
     }
-    this._x0 = x06;
-    this._y0 = y06;
-    this._x1 = x12;
-    this._y1 = y12;
+    this._x0 = x011;
+    this._y0 = y011;
+    this._x1 = x13;
+    this._y1 = y13;
     return this;
 }
 
-// node_modules/d3-quadtree/src/data.js
-function data_default2() {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/data.js
+function data_default4() {
     var data = [];
     this.visit(function(node) {
         if (!node.length)
             do
                 data.push(node.data);
             while (node = node.next);
     });
     return data;
 }
 
-// node_modules/d3-quadtree/src/extent.js
-function extent_default(_) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/extent.js
+function extent_default3(_) {
     return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [
         [this._x0, this._y0],
         [this._x1, this._y1]
     ];
 }
 
-// node_modules/d3-quadtree/src/quad.js
-function quad_default(node, x06, y06, x12, y12) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/quad.js
+function quad_default2(node, x011, y011, x13, y13) {
     this.node = node;
-    this.x0 = x06;
-    this.y0 = y06;
-    this.x1 = x12;
-    this.y1 = y12;
+    this.x0 = x011;
+    this.y0 = y011;
+    this.x1 = x13;
+    this.y1 = y13;
 }
 
-// node_modules/d3-quadtree/src/find.js
-function find_default(x4, y4, radius2) {
-    var data, x06 = this._x0,
-        y06 = this._y0,
-        x12, y12, x22, y22, x32 = this._x1,
+// js/pyobsplot-js/node_modules/d3-quadtree/src/find.js
+function find_default3(x7, y7, radius3) {
+    var data, x011 = this._x0,
+        y011 = this._y0,
+        x13, y13, x22, y22, x32 = this._x1,
         y32 = this._y1,
         quads = [],
         node = this._root,
         q, i;
     if (node)
-        quads.push(new quad_default(node, x06, y06, x32, y32));
-    if (radius2 == null)
-        radius2 = Infinity;
+        quads.push(new quad_default2(node, x011, y011, x32, y32));
+    if (radius3 == null)
+        radius3 = Infinity;
     else {
-        x06 = x4 - radius2, y06 = y4 - radius2;
-        x32 = x4 + radius2, y32 = y4 + radius2;
-        radius2 *= radius2;
+        x011 = x7 - radius3, y011 = y7 - radius3;
+        x32 = x7 + radius3, y32 = y7 + radius3;
+        radius3 *= radius3;
     }
     while (q = quads.pop()) {
-        if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)
+        if (!(node = q.node) || (x13 = q.x0) > x32 || (y13 = q.y0) > y32 || (x22 = q.x1) < x011 || (y22 = q.y1) < y011)
             continue;
         if (node.length) {
-            var xm = (x12 + x22) / 2,
-                ym = (y12 + y22) / 2;
+            var xm = (x13 + x22) / 2,
+                ym = (y13 + y22) / 2;
             quads.push(
-                new quad_default(node[3], xm, ym, x22, y22),
-                new quad_default(node[2], x12, ym, xm, y22),
-                new quad_default(node[1], xm, y12, x22, ym),
-                new quad_default(node[0], x12, y12, xm, ym)
+                new quad_default2(node[3], xm, ym, x22, y22),
+                new quad_default2(node[2], x13, ym, xm, y22),
+                new quad_default2(node[1], xm, y13, x22, ym),
+                new quad_default2(node[0], x13, y13, xm, ym)
             );
-            if (i = (y4 >= ym) << 1 | x4 >= xm) {
+            if (i = (y7 >= ym) << 1 | x7 >= xm) {
                 q = quads[quads.length - 1];
                 quads[quads.length - 1] = quads[quads.length - 1 - i];
                 quads[quads.length - 1 - i] = q;
             }
         } else {
-            var dx = x4 - +this._x.call(null, node.data),
-                dy = y4 - +this._y.call(null, node.data),
+            var dx = x7 - +this._x.call(null, node.data),
+                dy = y7 - +this._y.call(null, node.data),
                 d2 = dx * dx + dy * dy;
-            if (d2 < radius2) {
-                var d = Math.sqrt(radius2 = d2);
-                x06 = x4 - d, y06 = y4 - d;
-                x32 = x4 + d, y32 = y4 + d;
+            if (d2 < radius3) {
+                var d = Math.sqrt(radius3 = d2);
+                x011 = x7 - d, y011 = y7 - d;
+                x32 = x7 + d, y32 = y7 + d;
                 data = node.data;
             }
         }
     }
     return data;
 }
 
-// node_modules/d3-quadtree/src/remove.js
-function remove_default3(d) {
-    if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))
+// js/pyobsplot-js/node_modules/d3-quadtree/src/remove.js
+function remove_default6(d) {
+    if (isNaN(x7 = +this._x.call(null, d)) || isNaN(y7 = +this._y.call(null, d)))
         return this;
     var parent, node = this._root,
-        retainer, previous, next, x06 = this._x0,
-        y06 = this._y0,
-        x12 = this._x1,
-        y12 = this._y1,
-        x4, y4, xm, ym, right2, bottom2, i, j;
+        retainer, previous, next, x011 = this._x0,
+        y011 = this._y0,
+        x13 = this._x1,
+        y13 = this._y1,
+        x7, y7, xm, ym, right3, bottom3, i, j;
     if (!node)
         return this;
     if (node.length)
         while (true) {
-            if (right2 = x4 >= (xm = (x06 + x12) / 2))
-                x06 = xm;
+            if (right3 = x7 >= (xm = (x011 + x13) / 2))
+                x011 = xm;
             else
-                x12 = xm;
-            if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
-                y06 = ym;
+                x13 = xm;
+            if (bottom3 = y7 >= (ym = (y011 + y13) / 2))
+                y011 = ym;
             else
-                y12 = ym;
-            if (!(parent = node, node = node[i = bottom2 << 1 | right2]))
+                y13 = ym;
+            if (!(parent = node, node = node[i = bottom3 << 1 | right3]))
                 return this;
             if (!node.length)
                 break;
             if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
                 retainer = parent, j = i;
         }
     while (node.data !== d)
@@ -10384,248 +45090,248 @@
             retainer[j] = node;
         else
             this._root = node;
     }
     return this;
 }
 
-function removeAll(data) {
+function removeAll2(data) {
     for (var i = 0, n = data.length; i < n; ++i)
         this.remove(data[i]);
     return this;
 }
 
-// node_modules/d3-quadtree/src/root.js
-function root_default() {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/root.js
+function root_default2() {
     return this._root;
 }
 
-// node_modules/d3-quadtree/src/size.js
-function size_default2() {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/size.js
+function size_default4() {
     var size = 0;
     this.visit(function(node) {
         if (!node.length)
             do
 
                 ++size;
             while (node = node.next);
     });
     return size;
 }
 
-// node_modules/d3-quadtree/src/visit.js
-function visit_default(callback) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/visit.js
+function visit_default2(callback) {
     var quads = [],
         q, node = this._root,
-        child, x06, y06, x12, y12;
+        child, x011, y011, x13, y13;
     if (node)
-        quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
+        quads.push(new quad_default2(node, this._x0, this._y0, this._x1, this._y1));
     while (q = quads.pop()) {
-        if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
-            var xm = (x06 + x12) / 2,
-                ym = (y06 + y12) / 2;
+        if (!callback(node = q.node, x011 = q.x0, y011 = q.y0, x13 = q.x1, y13 = q.y1) && node.length) {
+            var xm = (x011 + x13) / 2,
+                ym = (y011 + y13) / 2;
             if (child = node[3])
-                quads.push(new quad_default(child, xm, ym, x12, y12));
+                quads.push(new quad_default2(child, xm, ym, x13, y13));
             if (child = node[2])
-                quads.push(new quad_default(child, x06, ym, xm, y12));
+                quads.push(new quad_default2(child, x011, ym, xm, y13));
             if (child = node[1])
-                quads.push(new quad_default(child, xm, y06, x12, ym));
+                quads.push(new quad_default2(child, xm, y011, x13, ym));
             if (child = node[0])
-                quads.push(new quad_default(child, x06, y06, xm, ym));
+                quads.push(new quad_default2(child, x011, y011, xm, ym));
         }
     }
     return this;
 }
 
-// node_modules/d3-quadtree/src/visitAfter.js
-function visitAfter_default(callback) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/visitAfter.js
+function visitAfter_default2(callback) {
     var quads = [],
         next = [],
         q;
     if (this._root)
-        quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
+        quads.push(new quad_default2(this._root, this._x0, this._y0, this._x1, this._y1));
     while (q = quads.pop()) {
         var node = q.node;
         if (node.length) {
-            var child, x06 = q.x0,
-                y06 = q.y0,
-                x12 = q.x1,
-                y12 = q.y1,
-                xm = (x06 + x12) / 2,
-                ym = (y06 + y12) / 2;
+            var child, x011 = q.x0,
+                y011 = q.y0,
+                x13 = q.x1,
+                y13 = q.y1,
+                xm = (x011 + x13) / 2,
+                ym = (y011 + y13) / 2;
             if (child = node[0])
-                quads.push(new quad_default(child, x06, y06, xm, ym));
+                quads.push(new quad_default2(child, x011, y011, xm, ym));
             if (child = node[1])
-                quads.push(new quad_default(child, xm, y06, x12, ym));
+                quads.push(new quad_default2(child, xm, y011, x13, ym));
             if (child = node[2])
-                quads.push(new quad_default(child, x06, ym, xm, y12));
+                quads.push(new quad_default2(child, x011, ym, xm, y13));
             if (child = node[3])
-                quads.push(new quad_default(child, xm, ym, x12, y12));
+                quads.push(new quad_default2(child, xm, ym, x13, y13));
         }
         next.push(q);
     }
     while (q = next.pop()) {
         callback(q.node, q.x0, q.y0, q.x1, q.y1);
     }
     return this;
 }
 
-// node_modules/d3-quadtree/src/x.js
-function defaultX2(d) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/x.js
+function defaultX4(d) {
     return d[0];
 }
 
-function x_default(_) {
+function x_default3(_) {
     return arguments.length ? (this._x = _, this) : this._x;
 }
 
-// node_modules/d3-quadtree/src/y.js
-function defaultY2(d) {
+// js/pyobsplot-js/node_modules/d3-quadtree/src/y.js
+function defaultY4(d) {
     return d[1];
 }
 
-function y_default(_) {
+function y_default3(_) {
     return arguments.length ? (this._y = _, this) : this._y;
 }
 
-// node_modules/d3-quadtree/src/quadtree.js
-function quadtree(nodes, x4, y4) {
-    var tree2 = new Quadtree(x4 == null ? defaultX2 : x4, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);
-    return nodes == null ? tree2 : tree2.addAll(nodes);
+// js/pyobsplot-js/node_modules/d3-quadtree/src/quadtree.js
+function quadtree2(nodes, x7, y7) {
+    var tree3 = new Quadtree2(x7 == null ? defaultX4 : x7, y7 == null ? defaultY4 : y7, NaN, NaN, NaN, NaN);
+    return nodes == null ? tree3 : tree3.addAll(nodes);
 }
 
-function Quadtree(x4, y4, x06, y06, x12, y12) {
-    this._x = x4;
-    this._y = y4;
-    this._x0 = x06;
-    this._y0 = y06;
-    this._x1 = x12;
-    this._y1 = y12;
+function Quadtree2(x7, y7, x011, y011, x13, y13) {
+    this._x = x7;
+    this._y = y7;
+    this._x0 = x011;
+    this._y0 = y011;
+    this._x1 = x13;
+    this._y1 = y13;
     this._root = void 0;
 }
 
-function leaf_copy(leaf) {
-    var copy3 = {
+function leaf_copy2(leaf) {
+    var copy5 = {
             data: leaf.data
         },
-        next = copy3;
+        next = copy5;
     while (leaf = leaf.next)
         next = next.next = {
             data: leaf.data
         };
-    return copy3;
+    return copy5;
 }
-var treeProto = quadtree.prototype = Quadtree.prototype;
-treeProto.copy = function() {
-    var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
+var treeProto2 = quadtree2.prototype = Quadtree2.prototype;
+treeProto2.copy = function() {
+    var copy5 = new Quadtree2(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
         node = this._root,
         nodes, child;
     if (!node)
-        return copy3;
+        return copy5;
     if (!node.length)
-        return copy3._root = leaf_copy(node), copy3;
+        return copy5._root = leaf_copy2(node), copy5;
     nodes = [{
         source: node,
-        target: copy3._root = new Array(4)
+        target: copy5._root = new Array(4)
     }];
     while (node = nodes.pop()) {
         for (var i = 0; i < 4; ++i) {
             if (child = node.source[i]) {
                 if (child.length)
                     nodes.push({
                         source: child,
                         target: node.target[i] = new Array(4)
                     });
                 else
-                    node.target[i] = leaf_copy(child);
+                    node.target[i] = leaf_copy2(child);
             }
         }
     }
-    return copy3;
+    return copy5;
 };
-treeProto.add = add_default;
-treeProto.addAll = addAll;
-treeProto.cover = cover_default;
-treeProto.data = data_default2;
-treeProto.extent = extent_default;
-treeProto.find = find_default;
-treeProto.remove = remove_default3;
-treeProto.removeAll = removeAll;
-treeProto.root = root_default;
-treeProto.size = size_default2;
-treeProto.visit = visit_default;
-treeProto.visitAfter = visitAfter_default;
-treeProto.x = x_default;
-treeProto.y = y_default;
+treeProto2.add = add_default2;
+treeProto2.addAll = addAll2;
+treeProto2.cover = cover_default2;
+treeProto2.data = data_default4;
+treeProto2.extent = extent_default3;
+treeProto2.find = find_default3;
+treeProto2.remove = remove_default6;
+treeProto2.removeAll = removeAll2;
+treeProto2.root = root_default2;
+treeProto2.size = size_default4;
+treeProto2.visit = visit_default2;
+treeProto2.visitAfter = visitAfter_default2;
+treeProto2.x = x_default3;
+treeProto2.y = y_default3;
 
-// node_modules/d3-force/src/constant.js
-function constant_default7(x4) {
+// js/pyobsplot-js/node_modules/d3-force/src/constant.js
+function constant_default18(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
-// node_modules/d3-force/src/jiggle.js
-function jiggle_default(random) {
+// js/pyobsplot-js/node_modules/d3-force/src/jiggle.js
+function jiggle_default2(random) {
     return (random() - 0.5) * 1e-6;
 }
 
-// node_modules/d3-force/src/collide.js
-function x(d) {
+// js/pyobsplot-js/node_modules/d3-force/src/collide.js
+function x4(d) {
     return d.x + d.vx;
 }
 
-function y(d) {
+function y4(d) {
     return d.y + d.vy;
 }
 
-function collide_default(radius2) {
+function collide_default2(radius3) {
     var nodes, radii, random, strength = 1,
-        iterations2 = 1;
-    if (typeof radius2 !== "function")
-        radius2 = constant_default7(radius2 == null ? 1 : +radius2);
+        iterations3 = 1;
+    if (typeof radius3 !== "function")
+        radius3 = constant_default18(radius3 == null ? 1 : +radius3);
 
     function force() {
         var i, n = nodes.length,
-            tree2, node, xi, yi, ri, ri2;
-        for (var k2 = 0; k2 < iterations2; ++k2) {
-            tree2 = quadtree(nodes, x, y).visitAfter(prepare);
+            tree3, node, xi, yi, ri, ri2;
+        for (var k3 = 0; k3 < iterations3; ++k3) {
+            tree3 = quadtree2(nodes, x4, y4).visitAfter(prepare);
             for (i = 0; i < n; ++i) {
                 node = nodes[i];
                 ri = radii[node.index], ri2 = ri * ri;
                 xi = node.x + node.vx;
                 yi = node.y + node.vy;
-                tree2.visit(apply2);
+                tree3.visit(apply3);
             }
         }
 
-        function apply2(quad, x06, y06, x12, y12) {
+        function apply3(quad, x011, y011, x13, y13) {
             var data = quad.data,
                 rj = quad.r,
                 r = ri + rj;
             if (data) {
                 if (data.index > node.index) {
-                    var x4 = xi - data.x - data.vx,
-                        y4 = yi - data.y - data.vy,
-                        l = x4 * x4 + y4 * y4;
+                    var x7 = xi - data.x - data.vx,
+                        y7 = yi - data.y - data.vy,
+                        l = x7 * x7 + y7 * y7;
                     if (l < r * r) {
-                        if (x4 === 0)
-                            x4 = jiggle_default(random), l += x4 * x4;
-                        if (y4 === 0)
-                            y4 = jiggle_default(random), l += y4 * y4;
+                        if (x7 === 0)
+                            x7 = jiggle_default2(random), l += x7 * x7;
+                        if (y7 === 0)
+                            y7 = jiggle_default2(random), l += y7 * y7;
                         l = (r - (l = Math.sqrt(l))) / l * strength;
-                        node.vx += (x4 *= l) * (r = (rj *= rj) / (ri2 + rj));
-                        node.vy += (y4 *= l) * r;
-                        data.vx -= x4 * (r = 1 - r);
-                        data.vy -= y4 * r;
+                        node.vx += (x7 *= l) * (r = (rj *= rj) / (ri2 + rj));
+                        node.vy += (y7 *= l) * r;
+                        data.vx -= x7 * (r = 1 - r);
+                        data.vy -= y7 * r;
                     }
                 }
                 return;
             }
-            return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;
+            return x011 > xi + r || x13 < xi - r || y011 > yi + r || y13 < yi - r;
         }
     }
 
     function prepare(quad) {
         if (quad.data)
             return quad.r = radii[quad.data.index];
         for (var i = quad.r = 0; i < 4; ++i) {
@@ -10638,95 +45344,95 @@
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length,
             node;
         radii = new Array(n);
         for (i = 0; i < n; ++i)
-            node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
+            node = nodes[i], radii[node.index] = +radius3(node, i, nodes);
     }
     force.initialize = function(_nodes, _random) {
         nodes = _nodes;
         random = _random;
         initialize();
     };
     force.iterations = function(_) {
-        return arguments.length ? (iterations2 = +_, force) : iterations2;
+        return arguments.length ? (iterations3 = +_, force) : iterations3;
     };
     force.strength = function(_) {
         return arguments.length ? (strength = +_, force) : strength;
     };
     force.radius = function(_) {
-        return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius2;
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : radius3;
     };
     return force;
 }
 
-// node_modules/d3-force/src/link.js
-function index2(d) {
+// js/pyobsplot-js/node_modules/d3-force/src/link.js
+function index4(d) {
     return d.index;
 }
 
-function find2(nodeById, nodeId) {
+function find4(nodeById, nodeId) {
     var node = nodeById.get(nodeId);
     if (!node)
         throw new Error("node not found: " + nodeId);
     return node;
 }
 
-function link_default(links) {
-    var id2 = index2,
+function link_default2(links) {
+    var id3 = index4,
         strength = defaultStrength,
-        strengths, distance = constant_default7(30),
-        distances, nodes, count3, bias, random, iterations2 = 1;
+        strengths, distance = constant_default18(30),
+        distances, nodes, count5, bias, random, iterations3 = 1;
     if (links == null)
         links = [];
 
-    function defaultStrength(link4) {
-        return 1 / Math.min(count3[link4.source.index], count3[link4.target.index]);
+    function defaultStrength(link7) {
+        return 1 / Math.min(count5[link7.source.index], count5[link7.target.index]);
     }
 
     function force(alpha) {
-        for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {
-            for (var i = 0, link4, source, target, x4, y4, l, b; i < n; ++i) {
-                link4 = links[i], source = link4.source, target = link4.target;
-                x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
-                y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
-                l = Math.sqrt(x4 * x4 + y4 * y4);
+        for (var k3 = 0, n = links.length; k3 < iterations3; ++k3) {
+            for (var i = 0, link7, source, target, x7, y7, l, b; i < n; ++i) {
+                link7 = links[i], source = link7.source, target = link7.target;
+                x7 = target.x + target.vx - source.x - source.vx || jiggle_default2(random);
+                y7 = target.y + target.vy - source.y - source.vy || jiggle_default2(random);
+                l = Math.sqrt(x7 * x7 + y7 * y7);
                 l = (l - distances[i]) / l * alpha * strengths[i];
-                x4 *= l, y4 *= l;
-                target.vx -= x4 * (b = bias[i]);
-                target.vy -= y4 * b;
-                source.vx += x4 * (b = 1 - b);
-                source.vy += y4 * b;
+                x7 *= l, y7 *= l;
+                target.vx -= x7 * (b = bias[i]);
+                target.vy -= y7 * b;
+                source.vx += x7 * (b = 1 - b);
+                source.vy += y7 * b;
             }
         }
     }
 
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length,
-            m3 = links.length,
-            nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])),
-            link4;
-        for (i = 0, count3 = new Array(n); i < m3; ++i) {
-            link4 = links[i], link4.index = i;
-            if (typeof link4.source !== "object")
-                link4.source = find2(nodeById, link4.source);
-            if (typeof link4.target !== "object")
-                link4.target = find2(nodeById, link4.target);
-            count3[link4.source.index] = (count3[link4.source.index] || 0) + 1;
-            count3[link4.target.index] = (count3[link4.target.index] || 0) + 1;
+            m5 = links.length,
+            nodeById = new Map(nodes.map((d, i2) => [id3(d, i2, nodes), d])),
+            link7;
+        for (i = 0, count5 = new Array(n); i < m5; ++i) {
+            link7 = links[i], link7.index = i;
+            if (typeof link7.source !== "object")
+                link7.source = find4(nodeById, link7.source);
+            if (typeof link7.target !== "object")
+                link7.target = find4(nodeById, link7.target);
+            count5[link7.source.index] = (count5[link7.source.index] || 0) + 1;
+            count5[link7.target.index] = (count5[link7.target.index] || 0) + 1;
         }
-        for (i = 0, bias = new Array(m3); i < m3; ++i) {
-            link4 = links[i], bias[i] = count3[link4.source.index] / (count3[link4.source.index] + count3[link4.target.index]);
+        for (i = 0, bias = new Array(m5); i < m5; ++i) {
+            link7 = links[i], bias[i] = count5[link7.source.index] / (count5[link7.source.index] + count5[link7.target.index]);
         }
-        strengths = new Array(m3), initializeStrength();
-        distances = new Array(m3), initializeDistance();
+        strengths = new Array(m5), initializeStrength();
+        distances = new Array(m5), initializeDistance();
     }
 
     function initializeStrength() {
         if (!nodes)
             return;
         for (var i = 0, n = links.length; i < n; ++i) {
             strengths[i] = +strength(links[i], i, links);
@@ -10745,77 +45451,77 @@
         random = _random;
         initialize();
     };
     force.links = function(_) {
         return arguments.length ? (links = _, initialize(), force) : links;
     };
     force.id = function(_) {
-        return arguments.length ? (id2 = _, force) : id2;
+        return arguments.length ? (id3 = _, force) : id3;
     };
     force.iterations = function(_) {
-        return arguments.length ? (iterations2 = +_, force) : iterations2;
+        return arguments.length ? (iterations3 = +_, force) : iterations3;
     };
     force.strength = function(_) {
-        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initializeStrength(), force) : strength;
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default18(+_), initializeStrength(), force) : strength;
     };
     force.distance = function(_) {
-        return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default7(+_), initializeDistance(), force) : distance;
+        return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default18(+_), initializeDistance(), force) : distance;
     };
     return force;
 }
 
-// node_modules/d3-force/src/lcg.js
-var a = 1664525;
-var c = 1013904223;
-var m = 4294967296;
-
-function lcg_default() {
-    let s2 = 1;
-    return () => (s2 = (a * s2 + c) % m) / m;
+// js/pyobsplot-js/node_modules/d3-force/src/lcg.js
+var a4 = 1664525;
+var c6 = 1013904223;
+var m3 = 4294967296;
+
+function lcg_default3() {
+    let s3 = 1;
+    return () => (s3 = (a4 * s3 + c6) % m3) / m3;
 }
 
-// node_modules/d3-force/src/simulation.js
-function x2(d) {
+// js/pyobsplot-js/node_modules/d3-force/src/simulation.js
+function x5(d) {
     return d.x;
 }
 
-function y2(d) {
+function y5(d) {
     return d.y;
 }
-var initialRadius = 10;
-var initialAngle = Math.PI * (3 - Math.sqrt(5));
+var initialRadius2 = 10;
+var initialAngle2 = Math.PI * (3 - Math.sqrt(5));
 
-function simulation_default(nodes) {
+function simulation_default2(nodes) {
     var simulation, alpha = 1,
         alphaMin = 1e-3,
         alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
         alphaTarget = 0,
         velocityDecay = 0.6,
         forces = /* @__PURE__ */ new Map(),
-        stepper = timer(step),
-        event = dispatch_default("tick", "end"),
-        random = lcg_default();
+        stepper = timer2(step),
+        event = dispatch_default3("tick", "end"),
+        random = lcg_default3();
     if (nodes == null)
         nodes = [];
 
     function step() {
         tick();
         event.call("tick", simulation);
         if (alpha < alphaMin) {
             stepper.stop();
             event.call("end", simulation);
         }
     }
 
-    function tick(iterations2) {
+    function tick(iterations3) {
         var i, n = nodes.length,
             node;
-        if (iterations2 === void 0)
-            iterations2 = 1;
-        for (var k2 = 0; k2 < iterations2; ++k2) {
+        if (iterations3 === void 0)
+            iterations3 = 1;
+        for (var k3 = 0; k3 < iterations3; ++k3) {
             alpha += (alphaTarget - alpha) * alphaDecay;
             forces.forEach(function(force) {
                 force(alpha);
             });
             for (i = 0; i < n; ++i) {
                 node = nodes[i];
                 if (node.fx == null)
@@ -10835,18 +45541,18 @@
         for (var i = 0, n = nodes.length, node; i < n; ++i) {
             node = nodes[i], node.index = i;
             if (node.fx != null)
                 node.x = node.fx;
             if (node.fy != null)
                 node.y = node.fy;
             if (isNaN(node.x) || isNaN(node.y)) {
-                var radius2 = initialRadius * Math.sqrt(0.5 + i),
-                    angle2 = i * initialAngle;
-                node.x = radius2 * Math.cos(angle2);
-                node.y = radius2 * Math.sin(angle2);
+                var radius3 = initialRadius2 * Math.sqrt(0.5 + i),
+                    angle3 = i * initialAngle2;
+                node.x = radius3 * Math.cos(angle3);
+                node.y = radius3 * Math.sin(angle3);
             }
             if (isNaN(node.vx) || isNaN(node.vy)) {
                 node.vx = node.vy = 0;
             }
         }
     }
 
@@ -10884,1485 +45590,1485 @@
         },
         randomSource: function(_) {
             return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
         },
         force: function(name, _) {
             return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
         },
-        find: function(x4, y4, radius2) {
+        find: function(x7, y7, radius3) {
             var i = 0,
                 n = nodes.length,
                 dx, dy, d2, node, closest;
-            if (radius2 == null)
-                radius2 = Infinity;
+            if (radius3 == null)
+                radius3 = Infinity;
             else
-                radius2 *= radius2;
+                radius3 *= radius3;
             for (i = 0; i < n; ++i) {
                 node = nodes[i];
-                dx = x4 - node.x;
-                dy = y4 - node.y;
+                dx = x7 - node.x;
+                dy = y7 - node.y;
                 d2 = dx * dx + dy * dy;
-                if (d2 < radius2)
-                    closest = node, radius2 = d2;
+                if (d2 < radius3)
+                    closest = node, radius3 = d2;
             }
             return closest;
         },
         on: function(name, _) {
             return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
         }
     };
 }
 
-// node_modules/d3-force/src/manyBody.js
-function manyBody_default() {
-    var nodes, node, random, alpha, strength = constant_default7(-30),
+// js/pyobsplot-js/node_modules/d3-force/src/manyBody.js
+function manyBody_default2() {
+    var nodes, node, random, alpha, strength = constant_default18(-30),
         strengths, distanceMin2 = 1,
         distanceMax2 = Infinity,
         theta2 = 0.81;
 
     function force(_) {
         var i, n = nodes.length,
-            tree2 = quadtree(nodes, x2, y2).visitAfter(accumulate);
+            tree3 = quadtree2(nodes, x5, y5).visitAfter(accumulate);
         for (alpha = _, i = 0; i < n; ++i)
-            node = nodes[i], tree2.visit(apply2);
+            node = nodes[i], tree3.visit(apply3);
     }
 
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length,
             node2;
         strengths = new Array(n);
         for (i = 0; i < n; ++i)
             node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
     }
 
     function accumulate(quad) {
         var strength2 = 0,
-            q, c6, weight = 0,
-            x4, y4, i;
+            q, c11, weight = 0,
+            x7, y7, i;
         if (quad.length) {
-            for (x4 = y4 = i = 0; i < 4; ++i) {
-                if ((q = quad[i]) && (c6 = Math.abs(q.value))) {
-                    strength2 += q.value, weight += c6, x4 += c6 * q.x, y4 += c6 * q.y;
+            for (x7 = y7 = i = 0; i < 4; ++i) {
+                if ((q = quad[i]) && (c11 = Math.abs(q.value))) {
+                    strength2 += q.value, weight += c11, x7 += c11 * q.x, y7 += c11 * q.y;
                 }
             }
-            quad.x = x4 / weight;
-            quad.y = y4 / weight;
+            quad.x = x7 / weight;
+            quad.y = y7 / weight;
         } else {
             q = quad;
             q.x = q.data.x;
             q.y = q.data.y;
             do
                 strength2 += strengths[q.data.index];
             while (q = q.next);
         }
         quad.value = strength2;
     }
 
-    function apply2(quad, x12, _, x22) {
+    function apply3(quad, x13, _, x22) {
         if (!quad.value)
             return true;
-        var x4 = quad.x - node.x,
-            y4 = quad.y - node.y,
-            w = x22 - x12,
-            l = x4 * x4 + y4 * y4;
+        var x7 = quad.x - node.x,
+            y7 = quad.y - node.y,
+            w = x22 - x13,
+            l = x7 * x7 + y7 * y7;
         if (w * w / theta2 < l) {
             if (l < distanceMax2) {
-                if (x4 === 0)
-                    x4 = jiggle_default(random), l += x4 * x4;
-                if (y4 === 0)
-                    y4 = jiggle_default(random), l += y4 * y4;
+                if (x7 === 0)
+                    x7 = jiggle_default2(random), l += x7 * x7;
+                if (y7 === 0)
+                    y7 = jiggle_default2(random), l += y7 * y7;
                 if (l < distanceMin2)
                     l = Math.sqrt(distanceMin2 * l);
-                node.vx += x4 * quad.value * alpha / l;
-                node.vy += y4 * quad.value * alpha / l;
+                node.vx += x7 * quad.value * alpha / l;
+                node.vy += y7 * quad.value * alpha / l;
             }
             return true;
         } else if (quad.length || l >= distanceMax2)
             return;
         if (quad.data !== node || quad.next) {
-            if (x4 === 0)
-                x4 = jiggle_default(random), l += x4 * x4;
-            if (y4 === 0)
-                y4 = jiggle_default(random), l += y4 * y4;
+            if (x7 === 0)
+                x7 = jiggle_default2(random), l += x7 * x7;
+            if (y7 === 0)
+                y7 = jiggle_default2(random), l += y7 * y7;
             if (l < distanceMin2)
                 l = Math.sqrt(distanceMin2 * l);
         }
         do
             if (quad.data !== node) {
                 w = strengths[quad.data.index] * alpha / l;
-                node.vx += x4 * w;
-                node.vy += y4 * w;
+                node.vx += x7 * w;
+                node.vy += y7 * w;
             }
         while (quad = quad.next);
     }
     force.initialize = function(_nodes, _random) {
         nodes = _nodes;
         random = _random;
         initialize();
     };
     force.strength = function(_) {
-        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : strength;
     };
     force.distanceMin = function(_) {
         return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
     };
     force.distanceMax = function(_) {
         return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
     };
     force.theta = function(_) {
         return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
     };
     return force;
 }
 
-// node_modules/d3-force/src/radial.js
-function radial_default(radius2, x4, y4) {
-    var nodes, strength = constant_default7(0.1),
+// js/pyobsplot-js/node_modules/d3-force/src/radial.js
+function radial_default2(radius3, x7, y7) {
+    var nodes, strength = constant_default18(0.1),
         strengths, radiuses;
-    if (typeof radius2 !== "function")
-        radius2 = constant_default7(+radius2);
-    if (x4 == null)
-        x4 = 0;
-    if (y4 == null)
-        y4 = 0;
+    if (typeof radius3 !== "function")
+        radius3 = constant_default18(+radius3);
+    if (x7 == null)
+        x7 = 0;
+    if (y7 == null)
+        y7 = 0;
 
     function force(alpha) {
         for (var i = 0, n = nodes.length; i < n; ++i) {
             var node = nodes[i],
-                dx = node.x - x4 || 1e-6,
-                dy = node.y - y4 || 1e-6,
+                dx = node.x - x7 || 1e-6,
+                dy = node.y - y7 || 1e-6,
                 r = Math.sqrt(dx * dx + dy * dy),
-                k2 = (radiuses[i] - r) * strengths[i] * alpha / r;
-            node.vx += dx * k2;
-            node.vy += dy * k2;
+                k3 = (radiuses[i] - r) * strengths[i] * alpha / r;
+            node.vx += dx * k3;
+            node.vy += dy * k3;
         }
     }
 
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length;
         strengths = new Array(n);
         radiuses = new Array(n);
         for (i = 0; i < n; ++i) {
-            radiuses[i] = +radius2(nodes[i], i, nodes);
+            radiuses[i] = +radius3(nodes[i], i, nodes);
             strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
         }
     }
     force.initialize = function(_) {
         nodes = _, initialize();
     };
     force.strength = function(_) {
-        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : strength;
     };
     force.radius = function(_) {
-        return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius2;
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : radius3;
     };
     force.x = function(_) {
-        return arguments.length ? (x4 = +_, force) : x4;
+        return arguments.length ? (x7 = +_, force) : x7;
     };
     force.y = function(_) {
-        return arguments.length ? (y4 = +_, force) : y4;
+        return arguments.length ? (y7 = +_, force) : y7;
     };
     return force;
 }
 
-// node_modules/d3-force/src/x.js
-function x_default2(x4) {
-    var strength = constant_default7(0.1),
+// js/pyobsplot-js/node_modules/d3-force/src/x.js
+function x_default4(x7) {
+    var strength = constant_default18(0.1),
         nodes, strengths, xz;
-    if (typeof x4 !== "function")
-        x4 = constant_default7(x4 == null ? 0 : +x4);
+    if (typeof x7 !== "function")
+        x7 = constant_default18(x7 == null ? 0 : +x7);
 
     function force(alpha) {
         for (var i = 0, n = nodes.length, node; i < n; ++i) {
             node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
         }
     }
 
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length;
         strengths = new Array(n);
         xz = new Array(n);
         for (i = 0; i < n; ++i) {
-            strengths[i] = isNaN(xz[i] = +x4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
+            strengths[i] = isNaN(xz[i] = +x7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
         }
     }
     force.initialize = function(_) {
         nodes = _;
         initialize();
     };
     force.strength = function(_) {
-        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : strength;
     };
     force.x = function(_) {
-        return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : x4;
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : x7;
     };
     return force;
 }
 
-// node_modules/d3-force/src/y.js
-function y_default2(y4) {
-    var strength = constant_default7(0.1),
+// js/pyobsplot-js/node_modules/d3-force/src/y.js
+function y_default4(y7) {
+    var strength = constant_default18(0.1),
         nodes, strengths, yz;
-    if (typeof y4 !== "function")
-        y4 = constant_default7(y4 == null ? 0 : +y4);
+    if (typeof y7 !== "function")
+        y7 = constant_default18(y7 == null ? 0 : +y7);
 
     function force(alpha) {
         for (var i = 0, n = nodes.length, node; i < n; ++i) {
             node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
         }
     }
 
     function initialize() {
         if (!nodes)
             return;
         var i, n = nodes.length;
         strengths = new Array(n);
         yz = new Array(n);
         for (i = 0; i < n; ++i) {
-            strengths[i] = isNaN(yz[i] = +y4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
+            strengths[i] = isNaN(yz[i] = +y7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
         }
     }
     force.initialize = function(_) {
         nodes = _;
         initialize();
     };
     force.strength = function(_) {
-        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
+        return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : strength;
     };
     force.y = function(_) {
-        return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : y4;
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default18(+_), initialize(), force) : y7;
     };
     return force;
 }
 
-// node_modules/d3-format/src/formatDecimal.js
-function formatDecimal_default(x4) {
-    return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
+// js/pyobsplot-js/node_modules/d3-format/src/formatDecimal.js
+function formatDecimal_default2(x7) {
+    return Math.abs(x7 = Math.round(x7)) >= 1e21 ? x7.toLocaleString("en").replace(/,/g, "") : x7.toString(10);
 }
 
-function formatDecimalParts(x4, p) {
-    if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf("e")) < 0)
+function formatDecimalParts2(x7, p) {
+    if ((i = (x7 = p ? x7.toExponential(p - 1) : x7.toExponential()).indexOf("e")) < 0)
         return null;
-    var i, coefficient = x4.slice(0, i);
+    var i, coefficient = x7.slice(0, i);
     return [
         coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
-        +x4.slice(i + 1)
+        +x7.slice(i + 1)
     ];
 }
 
-// node_modules/d3-format/src/exponent.js
-function exponent_default(x4) {
-    return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
+// js/pyobsplot-js/node_modules/d3-format/src/exponent.js
+function exponent_default2(x7) {
+    return x7 = formatDecimalParts2(Math.abs(x7)), x7 ? x7[1] : NaN;
 }
 
-// node_modules/d3-format/src/formatGroup.js
-function formatGroup_default(grouping, thousands) {
+// js/pyobsplot-js/node_modules/d3-format/src/formatGroup.js
+function formatGroup_default2(grouping, thousands) {
     return function(value, width) {
         var i = value.length,
             t = [],
             j = 0,
             g = grouping[0],
-            length4 = 0;
+            length7 = 0;
         while (i > 0 && g > 0) {
-            if (length4 + g + 1 > width)
-                g = Math.max(1, width - length4);
+            if (length7 + g + 1 > width)
+                g = Math.max(1, width - length7);
             t.push(value.substring(i -= g, i + g));
-            if ((length4 += g + 1) > width)
+            if ((length7 += g + 1) > width)
                 break;
             g = grouping[j = (j + 1) % grouping.length];
         }
         return t.reverse().join(thousands);
     };
 }
 
-// node_modules/d3-format/src/formatNumerals.js
-function formatNumerals_default(numerals) {
+// js/pyobsplot-js/node_modules/d3-format/src/formatNumerals.js
+function formatNumerals_default2(numerals) {
     return function(value) {
         return value.replace(/[0-9]/g, function(i) {
             return numerals[+i];
         });
     };
 }
 
-// node_modules/d3-format/src/formatSpecifier.js
-var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+// js/pyobsplot-js/node_modules/d3-format/src/formatSpecifier.js
+var re3 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
 
-function formatSpecifier(specifier) {
-    if (!(match = re.exec(specifier)))
+function formatSpecifier2(specifier) {
+    if (!(match = re3.exec(specifier)))
         throw new Error("invalid format: " + specifier);
     var match;
-    return new FormatSpecifier({
+    return new FormatSpecifier2({
         fill: match[1],
         align: match[2],
         sign: match[3],
         symbol: match[4],
         zero: match[5],
         width: match[6],
         comma: match[7],
         precision: match[8] && match[8].slice(1),
         trim: match[9],
         type: match[10]
     });
 }
-formatSpecifier.prototype = FormatSpecifier.prototype;
+formatSpecifier2.prototype = FormatSpecifier2.prototype;
 
-function FormatSpecifier(specifier) {
+function FormatSpecifier2(specifier) {
     this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
     this.align = specifier.align === void 0 ? ">" : specifier.align + "";
     this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
     this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
     this.zero = !!specifier.zero;
     this.width = specifier.width === void 0 ? void 0 : +specifier.width;
     this.comma = !!specifier.comma;
     this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
     this.trim = !!specifier.trim;
     this.type = specifier.type === void 0 ? "" : specifier.type + "";
 }
-FormatSpecifier.prototype.toString = function() {
+FormatSpecifier2.prototype.toString = function() {
     return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
 };
 
-// node_modules/d3-format/src/formatTrim.js
-function formatTrim_default(s2) {
-    out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
-        switch (s2[i]) {
+// js/pyobsplot-js/node_modules/d3-format/src/formatTrim.js
+function formatTrim_default2(s3) {
+    out: for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
+        switch (s3[i]) {
             case ".":
                 i0 = i1 = i;
                 break;
             case "0":
                 if (i0 === 0)
                     i0 = i;
                 i1 = i;
                 break;
             default:
-                if (!+s2[i])
+                if (!+s3[i])
                     break out;
                 if (i0 > 0)
                     i0 = 0;
                 break;
         }
     }
-    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
+    return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
 }
 
-// node_modules/d3-format/src/formatPrefixAuto.js
-var prefixExponent;
+// js/pyobsplot-js/node_modules/d3-format/src/formatPrefixAuto.js
+var prefixExponent2;
 
-function formatPrefixAuto_default(x4, p) {
-    var d = formatDecimalParts(x4, p);
+function formatPrefixAuto_default2(x7, p) {
+    var d = formatDecimalParts2(x7, p);
     if (!d)
-        return x4 + "";
+        return x7 + "";
     var coefficient = d[0],
-        exponent2 = d[1],
-        i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1,
+        exponent3 = d[1],
+        i = exponent3 - (prefixExponent2 = Math.max(-8, Math.min(8, Math.floor(exponent3 / 3))) * 3) + 1,
         n = coefficient.length;
-    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];
+    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts2(x7, Math.max(0, p + i - 1))[0];
 }
 
-// node_modules/d3-format/src/formatRounded.js
-function formatRounded_default(x4, p) {
-    var d = formatDecimalParts(x4, p);
+// js/pyobsplot-js/node_modules/d3-format/src/formatRounded.js
+function formatRounded_default2(x7, p) {
+    var d = formatDecimalParts2(x7, p);
     if (!d)
-        return x4 + "";
+        return x7 + "";
     var coefficient = d[0],
-        exponent2 = d[1];
-    return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
-}
-
-// node_modules/d3-format/src/formatTypes.js
-var formatTypes_default = {
-    "%": (x4, p) => (x4 * 100).toFixed(p),
-    "b": (x4) => Math.round(x4).toString(2),
-    "c": (x4) => x4 + "",
-    "d": formatDecimal_default,
-    "e": (x4, p) => x4.toExponential(p),
-    "f": (x4, p) => x4.toFixed(p),
-    "g": (x4, p) => x4.toPrecision(p),
-    "o": (x4) => Math.round(x4).toString(8),
-    "p": (x4, p) => formatRounded_default(x4 * 100, p),
-    "r": formatRounded_default,
-    "s": formatPrefixAuto_default,
-    "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
-    "x": (x4) => Math.round(x4).toString(16)
-};
-
-// node_modules/d3-format/src/identity.js
-function identity_default2(x4) {
-    return x4;
+        exponent3 = d[1];
+    return exponent3 < 0 ? "0." + new Array(-exponent3).join("0") + coefficient : coefficient.length > exponent3 + 1 ? coefficient.slice(0, exponent3 + 1) + "." + coefficient.slice(exponent3 + 1) : coefficient + new Array(exponent3 - coefficient.length + 2).join("0");
 }
 
-// node_modules/d3-format/src/locale.js
-var map3 = Array.prototype.map;
-var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
-
-function locale_default(locale3) {
-    var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""),
-        currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "",
-        currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "",
-        decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "",
-        numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)),
-        percent = locale3.percent === void 0 ? "%" : locale3.percent + "",
-        minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "",
-        nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
+// js/pyobsplot-js/node_modules/d3-format/src/formatTypes.js
+var formatTypes_default2 = {
+    "%": (x7, p) => (x7 * 100).toFixed(p),
+    "b": (x7) => Math.round(x7).toString(2),
+    "c": (x7) => x7 + "",
+    "d": formatDecimal_default2,
+    "e": (x7, p) => x7.toExponential(p),
+    "f": (x7, p) => x7.toFixed(p),
+    "g": (x7, p) => x7.toPrecision(p),
+    "o": (x7) => Math.round(x7).toString(8),
+    "p": (x7, p) => formatRounded_default2(x7 * 100, p),
+    "r": formatRounded_default2,
+    "s": formatPrefixAuto_default2,
+    "X": (x7) => Math.round(x7).toString(16).toUpperCase(),
+    "x": (x7) => Math.round(x7).toString(16)
+};
+
+// js/pyobsplot-js/node_modules/d3-format/src/identity.js
+function identity_default7(x7) {
+    return x7;
+}
+
+// js/pyobsplot-js/node_modules/d3-format/src/locale.js
+var map8 = Array.prototype.map;
+var prefixes2 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
+
+function locale_default2(locale5) {
+    var group5 = locale5.grouping === void 0 || locale5.thousands === void 0 ? identity_default7 : formatGroup_default2(map8.call(locale5.grouping, Number), locale5.thousands + ""),
+        currencyPrefix = locale5.currency === void 0 ? "" : locale5.currency[0] + "",
+        currencySuffix = locale5.currency === void 0 ? "" : locale5.currency[1] + "",
+        decimal = locale5.decimal === void 0 ? "." : locale5.decimal + "",
+        numerals = locale5.numerals === void 0 ? identity_default7 : formatNumerals_default2(map8.call(locale5.numerals, String)),
+        percent = locale5.percent === void 0 ? "%" : locale5.percent + "",
+        minus = locale5.minus === void 0 ? "\u2212" : locale5.minus + "",
+        nan = locale5.nan === void 0 ? "NaN" : locale5.nan + "";
 
     function newFormat(specifier) {
-        specifier = formatSpecifier(specifier);
+        specifier = formatSpecifier2(specifier);
         var fill = specifier.fill,
             align = specifier.align,
-            sign3 = specifier.sign,
-            symbol2 = specifier.symbol,
-            zero3 = specifier.zero,
+            sign5 = specifier.sign,
+            symbol3 = specifier.symbol,
+            zero5 = specifier.zero,
             width = specifier.width,
             comma = specifier.comma,
             precision = specifier.precision,
             trim = specifier.trim,
-            type2 = specifier.type;
-        if (type2 === "n")
-            comma = true, type2 = "g";
-        else if (!formatTypes_default[type2])
-            precision === void 0 && (precision = 12), trim = true, type2 = "g";
-        if (zero3 || fill === "0" && align === "=")
-            zero3 = true, fill = "0", align = "=";
-        var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "",
-            suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
-        var formatType = formatTypes_default[type2],
-            maybeSuffix = /[defgprs%]/.test(type2);
-        precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
+            type3 = specifier.type;
+        if (type3 === "n")
+            comma = true, type3 = "g";
+        else if (!formatTypes_default2[type3])
+            precision === void 0 && (precision = 12), trim = true, type3 = "g";
+        if (zero5 || fill === "0" && align === "=")
+            zero5 = true, fill = "0", align = "=";
+        var prefix = symbol3 === "$" ? currencyPrefix : symbol3 === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "",
+            suffix = symbol3 === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
+        var formatType = formatTypes_default2[type3],
+            maybeSuffix = /[defgprs%]/.test(type3);
+        precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
 
-        function format3(value) {
+        function format5(value) {
             var valuePrefix = prefix,
                 valueSuffix = suffix,
-                i, n, c6;
-            if (type2 === "c") {
+                i, n, c11;
+            if (type3 === "c") {
                 valueSuffix = formatType(value) + valueSuffix;
                 value = "";
             } else {
                 value = +value;
                 var valueNegative = value < 0 || 1 / value < 0;
                 value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                 if (trim)
-                    value = formatTrim_default(value);
-                if (valueNegative && +value === 0 && sign3 !== "+")
+                    value = formatTrim_default2(value);
+                if (valueNegative && +value === 0 && sign5 !== "+")
                     valueNegative = false;
-                valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
-                valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
+                valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
+                valueSuffix = (type3 === "s" ? prefixes2[8 + prefixExponent2 / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
                 if (maybeSuffix) {
                     i = -1, n = value.length;
                     while (++i < n) {
-                        if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {
-                            valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
+                        if (c11 = value.charCodeAt(i), 48 > c11 || c11 > 57) {
+                            valueSuffix = (c11 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                             value = value.slice(0, i);
                             break;
                         }
                     }
                 }
             }
-            if (comma && !zero3)
-                value = group3(value, Infinity);
-            var length4 = valuePrefix.length + value.length + valueSuffix.length,
-                padding = length4 < width ? new Array(width - length4 + 1).join(fill) : "";
-            if (comma && zero3)
-                value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
+            if (comma && !zero5)
+                value = group5(value, Infinity);
+            var length7 = valuePrefix.length + value.length + valueSuffix.length,
+                padding = length7 < width ? new Array(width - length7 + 1).join(fill) : "";
+            if (comma && zero5)
+                value = group5(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
             switch (align) {
                 case "<":
                     value = valuePrefix + value + valueSuffix + padding;
                     break;
                 case "=":
                     value = valuePrefix + padding + value + valueSuffix;
                     break;
                 case "^":
-                    value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);
+                    value = padding.slice(0, length7 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length7);
                     break;
                 default:
                     value = padding + valuePrefix + value + valueSuffix;
                     break;
             }
             return numerals(value);
         }
-        format3.toString = function() {
+        format5.toString = function() {
             return specifier + "";
         };
-        return format3;
+        return format5;
     }
 
-    function formatPrefix2(specifier, value) {
-        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
-            e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3,
-            k2 = Math.pow(10, -e),
-            prefix = prefixes[8 + e / 3];
+    function formatPrefix3(specifier, value) {
+        var f = newFormat((specifier = formatSpecifier2(specifier), specifier.type = "f", specifier)),
+            e = Math.max(-8, Math.min(8, Math.floor(exponent_default2(value) / 3))) * 3,
+            k3 = Math.pow(10, -e),
+            prefix = prefixes2[8 + e / 3];
         return function(value2) {
-            return f(k2 * value2) + prefix;
+            return f(k3 * value2) + prefix;
         };
     }
     return {
         format: newFormat,
-        formatPrefix: formatPrefix2
+        formatPrefix: formatPrefix3
     };
 }
 
-// node_modules/d3-format/src/defaultLocale.js
-var locale;
-var format;
-var formatPrefix;
-defaultLocale({
+// js/pyobsplot-js/node_modules/d3-format/src/defaultLocale.js
+var locale3;
+var format3;
+var formatPrefix2;
+defaultLocale3({
     thousands: ",",
     grouping: [3],
     currency: ["$", ""]
 });
 
-function defaultLocale(definition) {
-    locale = locale_default(definition);
-    format = locale.format;
-    formatPrefix = locale.formatPrefix;
-    return locale;
+function defaultLocale3(definition) {
+    locale3 = locale_default2(definition);
+    format3 = locale3.format;
+    formatPrefix2 = locale3.formatPrefix;
+    return locale3;
 }
 
-// node_modules/d3-format/src/precisionFixed.js
-function precisionFixed_default(step) {
-    return Math.max(0, -exponent_default(Math.abs(step)));
+// js/pyobsplot-js/node_modules/d3-format/src/precisionFixed.js
+function precisionFixed_default2(step) {
+    return Math.max(0, -exponent_default2(Math.abs(step)));
 }
 
-// node_modules/d3-format/src/precisionPrefix.js
-function precisionPrefix_default(step, value) {
-    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
+// js/pyobsplot-js/node_modules/d3-format/src/precisionPrefix.js
+function precisionPrefix_default2(step, value) {
+    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default2(value) / 3))) * 3 - exponent_default2(Math.abs(step)));
 }
 
-// node_modules/d3-format/src/precisionRound.js
-function precisionRound_default(step, max5) {
-    step = Math.abs(step), max5 = Math.abs(max5) - step;
-    return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
+// js/pyobsplot-js/node_modules/d3-format/src/precisionRound.js
+function precisionRound_default2(step, max9) {
+    step = Math.abs(step), max9 = Math.abs(max9) - step;
+    return Math.max(0, exponent_default2(max9) - exponent_default2(step)) + 1;
 }
 
-// node_modules/d3-geo/src/math.js
-var epsilon7 = 1e-6;
-var epsilon22 = 1e-12;
-var pi4 = Math.PI;
-var halfPi3 = pi4 / 2;
-var quarterPi = pi4 / 4;
-var tau5 = pi4 * 2;
-var degrees3 = 180 / pi4;
-var radians2 = pi4 / 180;
-var abs3 = Math.abs;
-var atan = Math.atan;
-var atan2 = Math.atan2;
-var cos2 = Math.cos;
-var ceil = Math.ceil;
-var exp = Math.exp;
-var hypot = Math.hypot;
-var log = Math.log;
-var pow2 = Math.pow;
-var sin2 = Math.sin;
-var sign = Math.sign || function(x4) {
-    return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
+// js/pyobsplot-js/node_modules/d3-geo/src/math.js
+var epsilon14 = 1e-6;
+var epsilon24 = 1e-12;
+var pi10 = Math.PI;
+var halfPi7 = pi10 / 2;
+var quarterPi2 = pi10 / 4;
+var tau12 = pi10 * 2;
+var degrees6 = 180 / pi10;
+var radians5 = pi10 / 180;
+var abs7 = Math.abs;
+var atan3 = Math.atan;
+var atan23 = Math.atan2;
+var cos5 = Math.cos;
+var ceil2 = Math.ceil;
+var exp2 = Math.exp;
+var hypot2 = Math.hypot;
+var log3 = Math.log;
+var pow5 = Math.pow;
+var sin5 = Math.sin;
+var sign3 = Math.sign || function(x7) {
+    return x7 > 0 ? 1 : x7 < 0 ? -1 : 0;
 };
-var sqrt = Math.sqrt;
-var tan = Math.tan;
+var sqrt4 = Math.sqrt;
+var tan2 = Math.tan;
 
-function acos(x4) {
-    return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);
+function acos3(x7) {
+    return x7 > 1 ? 0 : x7 < -1 ? pi10 : Math.acos(x7);
 }
 
-function asin(x4) {
-    return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);
+function asin3(x7) {
+    return x7 > 1 ? halfPi7 : x7 < -1 ? -halfPi7 : Math.asin(x7);
 }
 
-function haversin(x4) {
-    return (x4 = sin2(x4 / 2)) * x4;
+function haversin2(x7) {
+    return (x7 = sin5(x7 / 2)) * x7;
 }
 
-// node_modules/d3-geo/src/noop.js
-function noop2() {}
+// js/pyobsplot-js/node_modules/d3-geo/src/noop.js
+function noop4() {}
 
-// node_modules/d3-geo/src/stream.js
-function streamGeometry(geometry, stream) {
-    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
-        streamGeometryType[geometry.type](geometry, stream);
+// js/pyobsplot-js/node_modules/d3-geo/src/stream.js
+function streamGeometry2(geometry, stream) {
+    if (geometry && streamGeometryType2.hasOwnProperty(geometry.type)) {
+        streamGeometryType2[geometry.type](geometry, stream);
     }
 }
-var streamObjectType = {
-    Feature: function(object2, stream) {
-        streamGeometry(object2.geometry, stream);
+var streamObjectType2 = {
+    Feature: function(object3, stream) {
+        streamGeometry2(object3.geometry, stream);
     },
-    FeatureCollection: function(object2, stream) {
-        var features = object2.features,
+    FeatureCollection: function(object3, stream) {
+        var features = object3.features,
             i = -1,
             n = features.length;
         while (++i < n)
-            streamGeometry(features[i].geometry, stream);
+            streamGeometry2(features[i].geometry, stream);
     }
 };
-var streamGeometryType = {
-    Sphere: function(object2, stream) {
+var streamGeometryType2 = {
+    Sphere: function(object3, stream) {
         stream.sphere();
     },
-    Point: function(object2, stream) {
-        object2 = object2.coordinates;
-        stream.point(object2[0], object2[1], object2[2]);
+    Point: function(object3, stream) {
+        object3 = object3.coordinates;
+        stream.point(object3[0], object3[1], object3[2]);
     },
-    MultiPoint: function(object2, stream) {
-        var coordinates2 = object2.coordinates,
+    MultiPoint: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
+            object3 = coordinates3[i], stream.point(object3[0], object3[1], object3[2]);
     },
-    LineString: function(object2, stream) {
-        streamLine(object2.coordinates, stream, 0);
+    LineString: function(object3, stream) {
+        streamLine2(object3.coordinates, stream, 0);
     },
-    MultiLineString: function(object2, stream) {
-        var coordinates2 = object2.coordinates,
+    MultiLineString: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            streamLine(coordinates2[i], stream, 0);
+            streamLine2(coordinates3[i], stream, 0);
     },
-    Polygon: function(object2, stream) {
-        streamPolygon(object2.coordinates, stream);
+    Polygon: function(object3, stream) {
+        streamPolygon2(object3.coordinates, stream);
     },
-    MultiPolygon: function(object2, stream) {
-        var coordinates2 = object2.coordinates,
+    MultiPolygon: function(object3, stream) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            streamPolygon(coordinates2[i], stream);
+            streamPolygon2(coordinates3[i], stream);
     },
-    GeometryCollection: function(object2, stream) {
-        var geometries = object2.geometries,
+    GeometryCollection: function(object3, stream) {
+        var geometries = object3.geometries,
             i = -1,
             n = geometries.length;
         while (++i < n)
-            streamGeometry(geometries[i], stream);
+            streamGeometry2(geometries[i], stream);
     }
 };
 
-function streamLine(coordinates2, stream, closed) {
+function streamLine2(coordinates3, stream, closed) {
     var i = -1,
-        n = coordinates2.length - closed,
+        n = coordinates3.length - closed,
         coordinate;
     stream.lineStart();
     while (++i < n)
-        coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
+        coordinate = coordinates3[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
     stream.lineEnd();
 }
 
-function streamPolygon(coordinates2, stream) {
+function streamPolygon2(coordinates3, stream) {
     var i = -1,
-        n = coordinates2.length;
+        n = coordinates3.length;
     stream.polygonStart();
     while (++i < n)
-        streamLine(coordinates2[i], stream, 1);
+        streamLine2(coordinates3[i], stream, 1);
     stream.polygonEnd();
 }
 
-function stream_default(object2, stream) {
-    if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
-        streamObjectType[object2.type](object2, stream);
+function stream_default2(object3, stream) {
+    if (object3 && streamObjectType2.hasOwnProperty(object3.type)) {
+        streamObjectType2[object3.type](object3, stream);
     } else {
-        streamGeometry(object2, stream);
+        streamGeometry2(object3, stream);
     }
 }
 
-// node_modules/d3-geo/src/area.js
-var areaRingSum = new Adder();
-var areaSum = new Adder();
-var lambda00;
-var phi00;
-var lambda0;
-var cosPhi0;
-var sinPhi0;
-var areaStream = {
-    point: noop2,
-    lineStart: noop2,
-    lineEnd: noop2,
+// js/pyobsplot-js/node_modules/d3-geo/src/area.js
+var areaRingSum3 = new Adder2();
+var areaSum3 = new Adder2();
+var lambda004;
+var phi004;
+var lambda04;
+var cosPhi03;
+var sinPhi03;
+var areaStream3 = {
+    point: noop4,
+    lineStart: noop4,
+    lineEnd: noop4,
     polygonStart: function() {
-        areaRingSum = new Adder();
-        areaStream.lineStart = areaRingStart;
-        areaStream.lineEnd = areaRingEnd;
+        areaRingSum3 = new Adder2();
+        areaStream3.lineStart = areaRingStart3;
+        areaStream3.lineEnd = areaRingEnd3;
     },
     polygonEnd: function() {
-        var areaRing = +areaRingSum;
-        areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);
-        this.lineStart = this.lineEnd = this.point = noop2;
+        var areaRing = +areaRingSum3;
+        areaSum3.add(areaRing < 0 ? tau12 + areaRing : areaRing);
+        this.lineStart = this.lineEnd = this.point = noop4;
     },
     sphere: function() {
-        areaSum.add(tau5);
+        areaSum3.add(tau12);
     }
 };
 
-function areaRingStart() {
-    areaStream.point = areaPointFirst;
+function areaRingStart3() {
+    areaStream3.point = areaPointFirst3;
 }
 
-function areaRingEnd() {
-    areaPoint(lambda00, phi00);
+function areaRingEnd3() {
+    areaPoint3(lambda004, phi004);
 }
 
-function areaPointFirst(lambda, phi2) {
-    areaStream.point = areaPoint;
-    lambda00 = lambda, phi00 = phi2;
-    lambda *= radians2, phi2 *= radians2;
-    lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
+function areaPointFirst3(lambda, phi3) {
+    areaStream3.point = areaPoint3;
+    lambda004 = lambda, phi004 = phi3;
+    lambda *= radians5, phi3 *= radians5;
+    lambda04 = lambda, cosPhi03 = cos5(phi3 = phi3 / 2 + quarterPi2), sinPhi03 = sin5(phi3);
 }
 
-function areaPoint(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    phi2 = phi2 / 2 + quarterPi;
-    var dLambda = lambda - lambda0,
+function areaPoint3(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    phi3 = phi3 / 2 + quarterPi2;
+    var dLambda = lambda - lambda04,
         sdLambda = dLambda >= 0 ? 1 : -1,
         adLambda = sdLambda * dLambda,
-        cosPhi = cos2(phi2),
-        sinPhi = sin2(phi2),
-        k2 = sinPhi0 * sinPhi,
-        u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda),
-        v2 = k2 * sdLambda * sin2(adLambda);
-    areaRingSum.add(atan2(v2, u4));
-    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
+        cosPhi = cos5(phi3),
+        sinPhi = sin5(phi3),
+        k3 = sinPhi03 * sinPhi,
+        u7 = cosPhi03 * cosPhi + k3 * cos5(adLambda),
+        v3 = k3 * sdLambda * sin5(adLambda);
+    areaRingSum3.add(atan23(v3, u7));
+    lambda04 = lambda, cosPhi03 = cosPhi, sinPhi03 = sinPhi;
 }
 
-function area_default2(object2) {
-    areaSum = new Adder();
-    stream_default(object2, areaStream);
-    return areaSum * 2;
+function area_default7(object3) {
+    areaSum3 = new Adder2();
+    stream_default2(object3, areaStream3);
+    return areaSum3 * 2;
 }
 
-// node_modules/d3-geo/src/cartesian.js
-function spherical(cartesian2) {
-    return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
+// js/pyobsplot-js/node_modules/d3-geo/src/cartesian.js
+function spherical2(cartesian3) {
+    return [atan23(cartesian3[1], cartesian3[0]), asin3(cartesian3[2])];
 }
 
-function cartesian(spherical2) {
-    var lambda = spherical2[0],
-        phi2 = spherical2[1],
-        cosPhi = cos2(phi2);
-    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
+function cartesian2(spherical3) {
+    var lambda = spherical3[0],
+        phi3 = spherical3[1],
+        cosPhi = cos5(phi3);
+    return [cosPhi * cos5(lambda), cosPhi * sin5(lambda), sin5(phi3)];
 }
 
-function cartesianDot(a4, b) {
-    return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
+function cartesianDot2(a7, b) {
+    return a7[0] * b[0] + a7[1] * b[1] + a7[2] * b[2];
 }
 
-function cartesianCross(a4, b) {
-    return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];
+function cartesianCross2(a7, b) {
+    return [a7[1] * b[2] - a7[2] * b[1], a7[2] * b[0] - a7[0] * b[2], a7[0] * b[1] - a7[1] * b[0]];
 }
 
-function cartesianAddInPlace(a4, b) {
-    a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];
+function cartesianAddInPlace2(a7, b) {
+    a7[0] += b[0], a7[1] += b[1], a7[2] += b[2];
 }
 
-function cartesianScale(vector2, k2) {
-    return [vector2[0] * k2, vector2[1] * k2, vector2[2] * k2];
+function cartesianScale2(vector3, k3) {
+    return [vector3[0] * k3, vector3[1] * k3, vector3[2] * k3];
 }
 
-function cartesianNormalizeInPlace(d) {
-    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
+function cartesianNormalizeInPlace2(d) {
+    var l = sqrt4(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
     d[0] /= l, d[1] /= l, d[2] /= l;
 }
 
-// node_modules/d3-geo/src/bounds.js
-var lambda02;
-var phi0;
-var lambda1;
-var phi1;
-var lambda2;
-var lambda002;
-var phi002;
-var p0;
-var deltaSum;
-var ranges;
-var range3;
-var boundsStream = {
-    point: boundsPoint,
-    lineStart: boundsLineStart,
-    lineEnd: boundsLineEnd,
+// js/pyobsplot-js/node_modules/d3-geo/src/bounds.js
+var lambda05;
+var phi02;
+var lambda12;
+var phi12;
+var lambda22;
+var lambda005;
+var phi005;
+var p02;
+var deltaSum2;
+var ranges2;
+var range7;
+var boundsStream3 = {
+    point: boundsPoint3,
+    lineStart: boundsLineStart2,
+    lineEnd: boundsLineEnd2,
     polygonStart: function() {
-        boundsStream.point = boundsRingPoint;
-        boundsStream.lineStart = boundsRingStart;
-        boundsStream.lineEnd = boundsRingEnd;
-        deltaSum = new Adder();
-        areaStream.polygonStart();
+        boundsStream3.point = boundsRingPoint2;
+        boundsStream3.lineStart = boundsRingStart2;
+        boundsStream3.lineEnd = boundsRingEnd2;
+        deltaSum2 = new Adder2();
+        areaStream3.polygonStart();
     },
     polygonEnd: function() {
-        areaStream.polygonEnd();
-        boundsStream.point = boundsPoint;
-        boundsStream.lineStart = boundsLineStart;
-        boundsStream.lineEnd = boundsLineEnd;
-        if (areaRingSum < 0)
-            lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
-        else if (deltaSum > epsilon7)
-            phi1 = 90;
-        else if (deltaSum < -epsilon7)
-            phi0 = -90;
-        range3[0] = lambda02, range3[1] = lambda1;
+        areaStream3.polygonEnd();
+        boundsStream3.point = boundsPoint3;
+        boundsStream3.lineStart = boundsLineStart2;
+        boundsStream3.lineEnd = boundsLineEnd2;
+        if (areaRingSum3 < 0)
+            lambda05 = -(lambda12 = 180), phi02 = -(phi12 = 90);
+        else if (deltaSum2 > epsilon14)
+            phi12 = 90;
+        else if (deltaSum2 < -epsilon14)
+            phi02 = -90;
+        range7[0] = lambda05, range7[1] = lambda12;
     },
     sphere: function() {
-        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
+        lambda05 = -(lambda12 = 180), phi02 = -(phi12 = 90);
     }
 };
 
-function boundsPoint(lambda, phi2) {
-    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
-    if (phi2 < phi0)
-        phi0 = phi2;
-    if (phi2 > phi1)
-        phi1 = phi2;
+function boundsPoint3(lambda, phi3) {
+    ranges2.push(range7 = [lambda05 = lambda, lambda12 = lambda]);
+    if (phi3 < phi02)
+        phi02 = phi3;
+    if (phi3 > phi12)
+        phi12 = phi3;
 }
 
-function linePoint(lambda, phi2) {
-    var p = cartesian([lambda * radians2, phi2 * radians2]);
-    if (p0) {
-        var normal = cartesianCross(p0, p),
+function linePoint2(lambda, phi3) {
+    var p = cartesian2([lambda * radians5, phi3 * radians5]);
+    if (p02) {
+        var normal = cartesianCross2(p02, p),
             equatorial = [normal[1], -normal[0], 0],
-            inflection = cartesianCross(equatorial, normal);
-        cartesianNormalizeInPlace(inflection);
-        inflection = spherical(inflection);
-        var delta = lambda - lambda2,
-            sign3 = delta > 0 ? 1 : -1,
-            lambdai = inflection[0] * degrees3 * sign3,
-            phii, antimeridian = abs3(delta) > 180;
-        if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
-            phii = inflection[1] * degrees3;
-            if (phii > phi1)
-                phi1 = phii;
-        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
-            phii = -inflection[1] * degrees3;
-            if (phii < phi0)
-                phi0 = phii;
+            inflection = cartesianCross2(equatorial, normal);
+        cartesianNormalizeInPlace2(inflection);
+        inflection = spherical2(inflection);
+        var delta = lambda - lambda22,
+            sign5 = delta > 0 ? 1 : -1,
+            lambdai = inflection[0] * degrees6 * sign5,
+            phii, antimeridian = abs7(delta) > 180;
+        if (antimeridian ^ (sign5 * lambda22 < lambdai && lambdai < sign5 * lambda)) {
+            phii = inflection[1] * degrees6;
+            if (phii > phi12)
+                phi12 = phii;
+        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign5 * lambda22 < lambdai && lambdai < sign5 * lambda)) {
+            phii = -inflection[1] * degrees6;
+            if (phii < phi02)
+                phi02 = phii;
         } else {
-            if (phi2 < phi0)
-                phi0 = phi2;
-            if (phi2 > phi1)
-                phi1 = phi2;
+            if (phi3 < phi02)
+                phi02 = phi3;
+            if (phi3 > phi12)
+                phi12 = phi3;
         }
         if (antimeridian) {
-            if (lambda < lambda2) {
-                if (angle(lambda02, lambda) > angle(lambda02, lambda1))
-                    lambda1 = lambda;
+            if (lambda < lambda22) {
+                if (angle2(lambda05, lambda) > angle2(lambda05, lambda12))
+                    lambda12 = lambda;
             } else {
-                if (angle(lambda, lambda1) > angle(lambda02, lambda1))
-                    lambda02 = lambda;
+                if (angle2(lambda, lambda12) > angle2(lambda05, lambda12))
+                    lambda05 = lambda;
             }
         } else {
-            if (lambda1 >= lambda02) {
-                if (lambda < lambda02)
-                    lambda02 = lambda;
-                if (lambda > lambda1)
-                    lambda1 = lambda;
+            if (lambda12 >= lambda05) {
+                if (lambda < lambda05)
+                    lambda05 = lambda;
+                if (lambda > lambda12)
+                    lambda12 = lambda;
             } else {
-                if (lambda > lambda2) {
-                    if (angle(lambda02, lambda) > angle(lambda02, lambda1))
-                        lambda1 = lambda;
+                if (lambda > lambda22) {
+                    if (angle2(lambda05, lambda) > angle2(lambda05, lambda12))
+                        lambda12 = lambda;
                 } else {
-                    if (angle(lambda, lambda1) > angle(lambda02, lambda1))
-                        lambda02 = lambda;
+                    if (angle2(lambda, lambda12) > angle2(lambda05, lambda12))
+                        lambda05 = lambda;
                 }
             }
         }
     } else {
-        ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
+        ranges2.push(range7 = [lambda05 = lambda, lambda12 = lambda]);
     }
-    if (phi2 < phi0)
-        phi0 = phi2;
-    if (phi2 > phi1)
-        phi1 = phi2;
-    p0 = p, lambda2 = lambda;
+    if (phi3 < phi02)
+        phi02 = phi3;
+    if (phi3 > phi12)
+        phi12 = phi3;
+    p02 = p, lambda22 = lambda;
 }
 
-function boundsLineStart() {
-    boundsStream.point = linePoint;
+function boundsLineStart2() {
+    boundsStream3.point = linePoint2;
 }
 
-function boundsLineEnd() {
-    range3[0] = lambda02, range3[1] = lambda1;
-    boundsStream.point = boundsPoint;
-    p0 = null;
+function boundsLineEnd2() {
+    range7[0] = lambda05, range7[1] = lambda12;
+    boundsStream3.point = boundsPoint3;
+    p02 = null;
 }
 
-function boundsRingPoint(lambda, phi2) {
-    if (p0) {
-        var delta = lambda - lambda2;
-        deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
+function boundsRingPoint2(lambda, phi3) {
+    if (p02) {
+        var delta = lambda - lambda22;
+        deltaSum2.add(abs7(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
     } else {
-        lambda002 = lambda, phi002 = phi2;
+        lambda005 = lambda, phi005 = phi3;
     }
-    areaStream.point(lambda, phi2);
-    linePoint(lambda, phi2);
+    areaStream3.point(lambda, phi3);
+    linePoint2(lambda, phi3);
 }
 
-function boundsRingStart() {
-    areaStream.lineStart();
+function boundsRingStart2() {
+    areaStream3.lineStart();
 }
 
-function boundsRingEnd() {
-    boundsRingPoint(lambda002, phi002);
-    areaStream.lineEnd();
-    if (abs3(deltaSum) > epsilon7)
-        lambda02 = -(lambda1 = 180);
-    range3[0] = lambda02, range3[1] = lambda1;
-    p0 = null;
+function boundsRingEnd2() {
+    boundsRingPoint2(lambda005, phi005);
+    areaStream3.lineEnd();
+    if (abs7(deltaSum2) > epsilon14)
+        lambda05 = -(lambda12 = 180);
+    range7[0] = lambda05, range7[1] = lambda12;
+    p02 = null;
 }
 
-function angle(lambda04, lambda12) {
-    return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
+function angle2(lambda07, lambda13) {
+    return (lambda13 -= lambda07) < 0 ? lambda13 + 360 : lambda13;
 }
 
-function rangeCompare(a4, b) {
-    return a4[0] - b[0];
+function rangeCompare2(a7, b) {
+    return a7[0] - b[0];
 }
 
-function rangeContains(range5, x4) {
-    return range5[0] <= range5[1] ? range5[0] <= x4 && x4 <= range5[1] : x4 < range5[0] || range5[1] < x4;
+function rangeContains2(range9, x7) {
+    return range9[0] <= range9[1] ? range9[0] <= x7 && x7 <= range9[1] : x7 < range9[0] || range9[1] < x7;
 }
 
-function bounds_default(feature) {
-    var i, n, a4, b, merged, deltaMax, delta;
-    phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
-    ranges = [];
-    stream_default(feature, boundsStream);
-    if (n = ranges.length) {
-        ranges.sort(rangeCompare);
-        for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {
-            b = ranges[i];
-            if (rangeContains(a4, b[0]) || rangeContains(a4, b[1])) {
-                if (angle(a4[0], b[1]) > angle(a4[0], a4[1]))
-                    a4[1] = b[1];
-                if (angle(b[0], a4[1]) > angle(a4[0], a4[1]))
-                    a4[0] = b[0];
+function bounds_default3(feature) {
+    var i, n, a7, b, merged, deltaMax, delta;
+    phi12 = lambda12 = -(lambda05 = phi02 = Infinity);
+    ranges2 = [];
+    stream_default2(feature, boundsStream3);
+    if (n = ranges2.length) {
+        ranges2.sort(rangeCompare2);
+        for (i = 1, a7 = ranges2[0], merged = [a7]; i < n; ++i) {
+            b = ranges2[i];
+            if (rangeContains2(a7, b[0]) || rangeContains2(a7, b[1])) {
+                if (angle2(a7[0], b[1]) > angle2(a7[0], a7[1]))
+                    a7[1] = b[1];
+                if (angle2(b[0], a7[1]) > angle2(a7[0], a7[1]))
+                    a7[0] = b[0];
             } else {
-                merged.push(a4 = b);
+                merged.push(a7 = b);
             }
         }
-        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b, ++i) {
+        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a7 = merged[n]; i <= n; a7 = b, ++i) {
             b = merged[i];
-            if ((delta = angle(a4[1], b[0])) > deltaMax)
-                deltaMax = delta, lambda02 = b[0], lambda1 = a4[1];
+            if ((delta = angle2(a7[1], b[0])) > deltaMax)
+                deltaMax = delta, lambda05 = b[0], lambda12 = a7[1];
         }
     }
-    ranges = range3 = null;
-    return lambda02 === Infinity || phi0 === Infinity ? [
+    ranges2 = range7 = null;
+    return lambda05 === Infinity || phi02 === Infinity ? [
         [NaN, NaN],
         [NaN, NaN]
     ] : [
-        [lambda02, phi0],
-        [lambda1, phi1]
+        [lambda05, phi02],
+        [lambda12, phi12]
     ];
 }
 
-// node_modules/d3-geo/src/centroid.js
-var W0;
-var W1;
-var X0;
-var Y0;
-var Z0;
-var X1;
-var Y1;
-var Z1;
-var X2;
-var Y2;
-var Z2;
-var lambda003;
-var phi003;
-var x0;
-var y0;
-var z0;
-var centroidStream = {
-    sphere: noop2,
-    point: centroidPoint,
-    lineStart: centroidLineStart,
-    lineEnd: centroidLineEnd,
+// js/pyobsplot-js/node_modules/d3-geo/src/centroid.js
+var W02;
+var W12;
+var X03;
+var Y03;
+var Z03;
+var X13;
+var Y13;
+var Z13;
+var X23;
+var Y23;
+var Z23;
+var lambda006;
+var phi006;
+var x06;
+var y06;
+var z02;
+var centroidStream3 = {
+    sphere: noop4,
+    point: centroidPoint3,
+    lineStart: centroidLineStart3,
+    lineEnd: centroidLineEnd3,
     polygonStart: function() {
-        centroidStream.lineStart = centroidRingStart;
-        centroidStream.lineEnd = centroidRingEnd;
+        centroidStream3.lineStart = centroidRingStart3;
+        centroidStream3.lineEnd = centroidRingEnd3;
     },
     polygonEnd: function() {
-        centroidStream.lineStart = centroidLineStart;
-        centroidStream.lineEnd = centroidLineEnd;
+        centroidStream3.lineStart = centroidLineStart3;
+        centroidStream3.lineEnd = centroidLineEnd3;
     }
 };
 
-function centroidPoint(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    var cosPhi = cos2(phi2);
-    centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
-}
-
-function centroidPointCartesian(x4, y4, z) {
-    ++W0;
-    X0 += (x4 - X0) / W0;
-    Y0 += (y4 - Y0) / W0;
-    Z0 += (z - Z0) / W0;
-}
-
-function centroidLineStart() {
-    centroidStream.point = centroidLinePointFirst;
-}
-
-function centroidLinePointFirst(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    var cosPhi = cos2(phi2);
-    x0 = cosPhi * cos2(lambda);
-    y0 = cosPhi * sin2(lambda);
-    z0 = sin2(phi2);
-    centroidStream.point = centroidLinePoint;
-    centroidPointCartesian(x0, y0, z0);
-}
-
-function centroidLinePoint(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    var cosPhi = cos2(phi2),
-        x4 = cosPhi * cos2(lambda),
-        y4 = cosPhi * sin2(lambda),
-        z = sin2(phi2),
-        w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);
-    W1 += w;
-    X1 += w * (x0 + (x0 = x4));
-    Y1 += w * (y0 + (y0 = y4));
-    Z1 += w * (z0 + (z0 = z));
-    centroidPointCartesian(x0, y0, z0);
-}
-
-function centroidLineEnd() {
-    centroidStream.point = centroidPoint;
-}
-
-function centroidRingStart() {
-    centroidStream.point = centroidRingPointFirst;
-}
-
-function centroidRingEnd() {
-    centroidRingPoint(lambda003, phi003);
-    centroidStream.point = centroidPoint;
-}
-
-function centroidRingPointFirst(lambda, phi2) {
-    lambda003 = lambda, phi003 = phi2;
-    lambda *= radians2, phi2 *= radians2;
-    centroidStream.point = centroidRingPoint;
-    var cosPhi = cos2(phi2);
-    x0 = cosPhi * cos2(lambda);
-    y0 = cosPhi * sin2(lambda);
-    z0 = sin2(phi2);
-    centroidPointCartesian(x0, y0, z0);
-}
-
-function centroidRingPoint(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    var cosPhi = cos2(phi2),
-        x4 = cosPhi * cos2(lambda),
-        y4 = cosPhi * sin2(lambda),
-        z = sin2(phi2),
-        cx = y0 * z - z0 * y4,
-        cy = z0 * x4 - x0 * z,
-        cz = x0 * y4 - y0 * x4,
-        m3 = hypot(cx, cy, cz),
-        w = asin(m3),
-        v2 = m3 && -w / m3;
-    X2.add(v2 * cx);
-    Y2.add(v2 * cy);
-    Z2.add(v2 * cz);
-    W1 += w;
-    X1 += w * (x0 + (x0 = x4));
-    Y1 += w * (y0 + (y0 = y4));
-    Z1 += w * (z0 + (z0 = z));
-    centroidPointCartesian(x0, y0, z0);
-}
-
-function centroid_default(object2) {
-    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
-    X2 = new Adder();
-    Y2 = new Adder();
-    Z2 = new Adder();
-    stream_default(object2, centroidStream);
-    var x4 = +X2,
-        y4 = +Y2,
-        z = +Z2,
-        m3 = hypot(x4, y4, z);
-    if (m3 < epsilon22) {
-        x4 = X1, y4 = Y1, z = Z1;
-        if (W1 < epsilon7)
-            x4 = X0, y4 = Y0, z = Z0;
-        m3 = hypot(x4, y4, z);
-        if (m3 < epsilon22)
+function centroidPoint3(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    var cosPhi = cos5(phi3);
+    centroidPointCartesian2(cosPhi * cos5(lambda), cosPhi * sin5(lambda), sin5(phi3));
+}
+
+function centroidPointCartesian2(x7, y7, z) {
+    ++W02;
+    X03 += (x7 - X03) / W02;
+    Y03 += (y7 - Y03) / W02;
+    Z03 += (z - Z03) / W02;
+}
+
+function centroidLineStart3() {
+    centroidStream3.point = centroidLinePointFirst2;
+}
+
+function centroidLinePointFirst2(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    var cosPhi = cos5(phi3);
+    x06 = cosPhi * cos5(lambda);
+    y06 = cosPhi * sin5(lambda);
+    z02 = sin5(phi3);
+    centroidStream3.point = centroidLinePoint2;
+    centroidPointCartesian2(x06, y06, z02);
+}
+
+function centroidLinePoint2(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    var cosPhi = cos5(phi3),
+        x7 = cosPhi * cos5(lambda),
+        y7 = cosPhi * sin5(lambda),
+        z = sin5(phi3),
+        w = atan23(sqrt4((w = y06 * z - z02 * y7) * w + (w = z02 * x7 - x06 * z) * w + (w = x06 * y7 - y06 * x7) * w), x06 * x7 + y06 * y7 + z02 * z);
+    W12 += w;
+    X13 += w * (x06 + (x06 = x7));
+    Y13 += w * (y06 + (y06 = y7));
+    Z13 += w * (z02 + (z02 = z));
+    centroidPointCartesian2(x06, y06, z02);
+}
+
+function centroidLineEnd3() {
+    centroidStream3.point = centroidPoint3;
+}
+
+function centroidRingStart3() {
+    centroidStream3.point = centroidRingPointFirst2;
+}
+
+function centroidRingEnd3() {
+    centroidRingPoint2(lambda006, phi006);
+    centroidStream3.point = centroidPoint3;
+}
+
+function centroidRingPointFirst2(lambda, phi3) {
+    lambda006 = lambda, phi006 = phi3;
+    lambda *= radians5, phi3 *= radians5;
+    centroidStream3.point = centroidRingPoint2;
+    var cosPhi = cos5(phi3);
+    x06 = cosPhi * cos5(lambda);
+    y06 = cosPhi * sin5(lambda);
+    z02 = sin5(phi3);
+    centroidPointCartesian2(x06, y06, z02);
+}
+
+function centroidRingPoint2(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    var cosPhi = cos5(phi3),
+        x7 = cosPhi * cos5(lambda),
+        y7 = cosPhi * sin5(lambda),
+        z = sin5(phi3),
+        cx = y06 * z - z02 * y7,
+        cy = z02 * x7 - x06 * z,
+        cz = x06 * y7 - y06 * x7,
+        m5 = hypot2(cx, cy, cz),
+        w = asin3(m5),
+        v3 = m5 && -w / m5;
+    X23.add(v3 * cx);
+    Y23.add(v3 * cy);
+    Z23.add(v3 * cz);
+    W12 += w;
+    X13 += w * (x06 + (x06 = x7));
+    Y13 += w * (y06 + (y06 = y7));
+    Z13 += w * (z02 + (z02 = z));
+    centroidPointCartesian2(x06, y06, z02);
+}
+
+function centroid_default4(object3) {
+    W02 = W12 = X03 = Y03 = Z03 = X13 = Y13 = Z13 = 0;
+    X23 = new Adder2();
+    Y23 = new Adder2();
+    Z23 = new Adder2();
+    stream_default2(object3, centroidStream3);
+    var x7 = +X23,
+        y7 = +Y23,
+        z = +Z23,
+        m5 = hypot2(x7, y7, z);
+    if (m5 < epsilon24) {
+        x7 = X13, y7 = Y13, z = Z13;
+        if (W12 < epsilon14)
+            x7 = X03, y7 = Y03, z = Z03;
+        m5 = hypot2(x7, y7, z);
+        if (m5 < epsilon24)
             return [NaN, NaN];
     }
-    return [atan2(y4, x4) * degrees3, asin(z / m3) * degrees3];
+    return [atan23(y7, x7) * degrees6, asin3(z / m5) * degrees6];
 }
 
-// node_modules/d3-geo/src/constant.js
-function constant_default8(x4) {
+// js/pyobsplot-js/node_modules/d3-geo/src/constant.js
+function constant_default19(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
-// node_modules/d3-geo/src/compose.js
-function compose_default(a4, b) {
-    function compose(x4, y4) {
-        return x4 = a4(x4, y4), b(x4[0], x4[1]);
-    }
-    if (a4.invert && b.invert)
-        compose.invert = function(x4, y4) {
-            return x4 = b.invert(x4, y4), x4 && a4.invert(x4[0], x4[1]);
+// js/pyobsplot-js/node_modules/d3-geo/src/compose.js
+function compose_default2(a7, b) {
+    function compose(x7, y7) {
+        return x7 = a7(x7, y7), b(x7[0], x7[1]);
+    }
+    if (a7.invert && b.invert)
+        compose.invert = function(x7, y7) {
+            return x7 = b.invert(x7, y7), x7 && a7.invert(x7[0], x7[1]);
         };
     return compose;
 }
 
-// node_modules/d3-geo/src/rotation.js
-function rotationIdentity(lambda, phi2) {
-    if (abs3(lambda) > pi4)
-        lambda -= Math.round(lambda / tau5) * tau5;
-    return [lambda, phi2];
+// js/pyobsplot-js/node_modules/d3-geo/src/rotation.js
+function rotationIdentity2(lambda, phi3) {
+    if (abs7(lambda) > pi10)
+        lambda -= Math.round(lambda / tau12) * tau12;
+    return [lambda, phi3];
 }
-rotationIdentity.invert = rotationIdentity;
+rotationIdentity2.invert = rotationIdentity2;
 
-function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
-    return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
+function rotateRadians2(deltaLambda, deltaPhi, deltaGamma) {
+    return (deltaLambda %= tau12) ? deltaPhi || deltaGamma ? compose_default2(rotationLambda2(deltaLambda), rotationPhiGamma2(deltaPhi, deltaGamma)) : rotationLambda2(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma2(deltaPhi, deltaGamma) : rotationIdentity2;
 }
 
-function forwardRotationLambda(deltaLambda) {
-    return function(lambda, phi2) {
+function forwardRotationLambda2(deltaLambda) {
+    return function(lambda, phi3) {
         lambda += deltaLambda;
-        if (abs3(lambda) > pi4)
-            lambda -= Math.round(lambda / tau5) * tau5;
-        return [lambda, phi2];
+        if (abs7(lambda) > pi10)
+            lambda -= Math.round(lambda / tau12) * tau12;
+        return [lambda, phi3];
     };
 }
 
-function rotationLambda(deltaLambda) {
-    var rotation = forwardRotationLambda(deltaLambda);
-    rotation.invert = forwardRotationLambda(-deltaLambda);
+function rotationLambda2(deltaLambda) {
+    var rotation = forwardRotationLambda2(deltaLambda);
+    rotation.invert = forwardRotationLambda2(-deltaLambda);
     return rotation;
 }
 
-function rotationPhiGamma(deltaPhi, deltaGamma) {
-    var cosDeltaPhi = cos2(deltaPhi),
-        sinDeltaPhi = sin2(deltaPhi),
-        cosDeltaGamma = cos2(deltaGamma),
-        sinDeltaGamma = sin2(deltaGamma);
-
-    function rotation(lambda, phi2) {
-        var cosPhi = cos2(phi2),
-            x4 = cos2(lambda) * cosPhi,
-            y4 = sin2(lambda) * cosPhi,
-            z = sin2(phi2),
-            k2 = z * cosDeltaPhi + x4 * sinDeltaPhi;
+function rotationPhiGamma2(deltaPhi, deltaGamma) {
+    var cosDeltaPhi = cos5(deltaPhi),
+        sinDeltaPhi = sin5(deltaPhi),
+        cosDeltaGamma = cos5(deltaGamma),
+        sinDeltaGamma = sin5(deltaGamma);
+
+    function rotation(lambda, phi3) {
+        var cosPhi = cos5(phi3),
+            x7 = cos5(lambda) * cosPhi,
+            y7 = sin5(lambda) * cosPhi,
+            z = sin5(phi3),
+            k3 = z * cosDeltaPhi + x7 * sinDeltaPhi;
         return [
-            atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),
-            asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)
+            atan23(y7 * cosDeltaGamma - k3 * sinDeltaGamma, x7 * cosDeltaPhi - z * sinDeltaPhi),
+            asin3(k3 * cosDeltaGamma + y7 * sinDeltaGamma)
         ];
     }
-    rotation.invert = function(lambda, phi2) {
-        var cosPhi = cos2(phi2),
-            x4 = cos2(lambda) * cosPhi,
-            y4 = sin2(lambda) * cosPhi,
-            z = sin2(phi2),
-            k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;
+    rotation.invert = function(lambda, phi3) {
+        var cosPhi = cos5(phi3),
+            x7 = cos5(lambda) * cosPhi,
+            y7 = sin5(lambda) * cosPhi,
+            z = sin5(phi3),
+            k3 = z * cosDeltaGamma - y7 * sinDeltaGamma;
         return [
-            atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k2 * sinDeltaPhi),
-            asin(k2 * cosDeltaPhi - x4 * sinDeltaPhi)
+            atan23(y7 * cosDeltaGamma + z * sinDeltaGamma, x7 * cosDeltaPhi + k3 * sinDeltaPhi),
+            asin3(k3 * cosDeltaPhi - x7 * sinDeltaPhi)
         ];
     };
     return rotation;
 }
 
-function rotation_default(rotate) {
-    rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
+function rotation_default2(rotate) {
+    rotate = rotateRadians2(rotate[0] * radians5, rotate[1] * radians5, rotate.length > 2 ? rotate[2] * radians5 : 0);
 
-    function forward(coordinates2) {
-        coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
-        return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
-    }
-    forward.invert = function(coordinates2) {
-        coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
-        return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
+    function forward(coordinates3) {
+        coordinates3 = rotate(coordinates3[0] * radians5, coordinates3[1] * radians5);
+        return coordinates3[0] *= degrees6, coordinates3[1] *= degrees6, coordinates3;
+    }
+    forward.invert = function(coordinates3) {
+        coordinates3 = rotate.invert(coordinates3[0] * radians5, coordinates3[1] * radians5);
+        return coordinates3[0] *= degrees6, coordinates3[1] *= degrees6, coordinates3;
     };
     return forward;
 }
 
-// node_modules/d3-geo/src/circle.js
-function circleStream(stream, radius2, delta, direction, t03, t13) {
+// js/pyobsplot-js/node_modules/d3-geo/src/circle.js
+function circleStream2(stream, radius3, delta, direction, t05, t15) {
     if (!delta)
         return;
-    var cosRadius = cos2(radius2),
-        sinRadius = sin2(radius2),
+    var cosRadius = cos5(radius3),
+        sinRadius = sin5(radius3),
         step = direction * delta;
-    if (t03 == null) {
-        t03 = radius2 + direction * tau5;
-        t13 = radius2 - step / 2;
-    } else {
-        t03 = circleRadius(cosRadius, t03);
-        t13 = circleRadius(cosRadius, t13);
-        if (direction > 0 ? t03 < t13 : t03 > t13)
-            t03 += direction * tau5;
-    }
-    for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
-        point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
-        stream.point(point6[0], point6[1]);
+    if (t05 == null) {
+        t05 = radius3 + direction * tau12;
+        t15 = radius3 - step / 2;
+    } else {
+        t05 = circleRadius2(cosRadius, t05);
+        t15 = circleRadius2(cosRadius, t15);
+        if (direction > 0 ? t05 < t15 : t05 > t15)
+            t05 += direction * tau12;
+    }
+    for (var point11, t = t05; direction > 0 ? t > t15 : t < t15; t -= step) {
+        point11 = spherical2([cosRadius, -sinRadius * cos5(t), -sinRadius * sin5(t)]);
+        stream.point(point11[0], point11[1]);
     }
 }
 
-function circleRadius(cosRadius, point6) {
-    point6 = cartesian(point6), point6[0] -= cosRadius;
-    cartesianNormalizeInPlace(point6);
-    var radius2 = acos(-point6[1]);
-    return ((-point6[2] < 0 ? -radius2 : radius2) + tau5 - epsilon7) % tau5;
+function circleRadius2(cosRadius, point11) {
+    point11 = cartesian2(point11), point11[0] -= cosRadius;
+    cartesianNormalizeInPlace2(point11);
+    var radius3 = acos3(-point11[1]);
+    return ((-point11[2] < 0 ? -radius3 : radius3) + tau12 - epsilon14) % tau12;
 }
 
-function circle_default() {
-    var center2 = constant_default8([0, 0]),
-        radius2 = constant_default8(90),
-        precision = constant_default8(6),
+function circle_default4() {
+    var center3 = constant_default19([0, 0]),
+        radius3 = constant_default19(90),
+        precision = constant_default19(6),
         ring, rotate, stream = {
-            point: point6
+            point: point11
         };
 
-    function point6(x4, y4) {
-        ring.push(x4 = rotate(x4, y4));
-        x4[0] *= degrees3, x4[1] *= degrees3;
+    function point11(x7, y7) {
+        ring.push(x7 = rotate(x7, y7));
+        x7[0] *= degrees6, x7[1] *= degrees6;
     }
 
-    function circle2() {
-        var c6 = center2.apply(this, arguments),
-            r = radius2.apply(this, arguments) * radians2,
-            p = precision.apply(this, arguments) * radians2;
+    function circle3() {
+        var c11 = center3.apply(this, arguments),
+            r = radius3.apply(this, arguments) * radians5,
+            p = precision.apply(this, arguments) * radians5;
         ring = [];
-        rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;
-        circleStream(stream, r, p, 1);
-        c6 = {
+        rotate = rotateRadians2(-c11[0] * radians5, -c11[1] * radians5, 0).invert;
+        circleStream2(stream, r, p, 1);
+        c11 = {
             type: "Polygon",
             coordinates: [ring]
         };
         ring = rotate = null;
-        return c6;
+        return c11;
     }
-    circle2.center = function(_) {
-        return arguments.length ? (center2 = typeof _ === "function" ? _ : constant_default8([+_[0], +_[1]]), circle2) : center2;
+    circle3.center = function(_) {
+        return arguments.length ? (center3 = typeof _ === "function" ? _ : constant_default19([+_[0], +_[1]]), circle3) : center3;
     };
-    circle2.radius = function(_) {
-        return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default8(+_), circle2) : radius2;
+    circle3.radius = function(_) {
+        return arguments.length ? (radius3 = typeof _ === "function" ? _ : constant_default19(+_), circle3) : radius3;
     };
-    circle2.precision = function(_) {
-        return arguments.length ? (precision = typeof _ === "function" ? _ : constant_default8(+_), circle2) : precision;
+    circle3.precision = function(_) {
+        return arguments.length ? (precision = typeof _ === "function" ? _ : constant_default19(+_), circle3) : precision;
     };
-    return circle2;
+    return circle3;
 }
 
-// node_modules/d3-geo/src/clip/buffer.js
-function buffer_default2() {
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/buffer.js
+function buffer_default4() {
     var lines = [],
-        line2;
+        line3;
     return {
-        point: function(x4, y4, m3) {
-            line2.push([x4, y4, m3]);
+        point: function(x7, y7, m5) {
+            line3.push([x7, y7, m5]);
         },
         lineStart: function() {
-            lines.push(line2 = []);
+            lines.push(line3 = []);
         },
-        lineEnd: noop2,
+        lineEnd: noop4,
         rejoin: function() {
             if (lines.length > 1)
                 lines.push(lines.pop().concat(lines.shift()));
         },
         result: function() {
             var result = lines;
             lines = [];
-            line2 = null;
+            line3 = null;
             return result;
         }
     };
 }
 
-// node_modules/d3-geo/src/pointEqual.js
-function pointEqual_default(a4, b) {
-    return abs3(a4[0] - b[0]) < epsilon7 && abs3(a4[1] - b[1]) < epsilon7;
+// js/pyobsplot-js/node_modules/d3-geo/src/pointEqual.js
+function pointEqual_default2(a7, b) {
+    return abs7(a7[0] - b[0]) < epsilon14 && abs7(a7[1] - b[1]) < epsilon14;
 }
 
-// node_modules/d3-geo/src/clip/rejoin.js
-function Intersection(point6, points, other, entry) {
-    this.x = point6;
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/rejoin.js
+function Intersection2(point11, points, other, entry) {
+    this.x = point11;
     this.z = points;
     this.o = other;
     this.e = entry;
     this.v = false;
     this.n = this.p = null;
 }
 
-function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
+function rejoin_default2(segments, compareIntersection3, startInside, interpolate, stream) {
     var subject = [],
         clip = [],
         i, n;
     segments.forEach(function(segment) {
         if ((n2 = segment.length - 1) <= 0)
             return;
-        var n2, p02 = segment[0],
+        var n2, p03 = segment[0],
             p1 = segment[n2],
-            x4;
-        if (pointEqual_default(p02, p1)) {
-            if (!p02[2] && !p1[2]) {
+            x7;
+        if (pointEqual_default2(p03, p1)) {
+            if (!p03[2] && !p1[2]) {
                 stream.lineStart();
                 for (i = 0; i < n2; ++i)
-                    stream.point((p02 = segment[i])[0], p02[1]);
+                    stream.point((p03 = segment[i])[0], p03[1]);
                 stream.lineEnd();
                 return;
             }
-            p1[0] += 2 * epsilon7;
+            p1[0] += 2 * epsilon14;
         }
-        subject.push(x4 = new Intersection(p02, segment, null, true));
-        clip.push(x4.o = new Intersection(p02, null, x4, false));
-        subject.push(x4 = new Intersection(p1, segment, null, false));
-        clip.push(x4.o = new Intersection(p1, null, x4, true));
+        subject.push(x7 = new Intersection2(p03, segment, null, true));
+        clip.push(x7.o = new Intersection2(p03, null, x7, false));
+        subject.push(x7 = new Intersection2(p1, segment, null, false));
+        clip.push(x7.o = new Intersection2(p1, null, x7, true));
     });
     if (!subject.length)
         return;
-    clip.sort(compareIntersection2);
-    link(subject);
-    link(clip);
+    clip.sort(compareIntersection3);
+    link4(subject);
+    link4(clip);
     for (i = 0, n = clip.length; i < n; ++i) {
         clip[i].e = startInside = !startInside;
     }
-    var start2 = subject[0],
-        points, point6;
+    var start3 = subject[0],
+        points, point11;
     while (1) {
-        var current = start2,
+        var current = start3,
             isSubject = true;
         while (current.v)
-            if ((current = current.n) === start2)
+            if ((current = current.n) === start3)
                 return;
         points = current.z;
         stream.lineStart();
         do {
             current.v = current.o.v = true;
             if (current.e) {
                 if (isSubject) {
                     for (i = 0, n = points.length; i < n; ++i)
-                        stream.point((point6 = points[i])[0], point6[1]);
+                        stream.point((point11 = points[i])[0], point11[1]);
                 } else {
                     interpolate(current.x, current.n.x, 1, stream);
                 }
                 current = current.n;
             } else {
                 if (isSubject) {
                     points = current.p.z;
                     for (i = points.length - 1; i >= 0; --i)
-                        stream.point((point6 = points[i])[0], point6[1]);
+                        stream.point((point11 = points[i])[0], point11[1]);
                 } else {
                     interpolate(current.x, current.p.x, -1, stream);
                 }
                 current = current.p;
             }
             current = current.o;
             points = current.z;
             isSubject = !isSubject;
         } while (!current.v);
         stream.lineEnd();
     }
 }
 
-function link(array4) {
-    if (!(n = array4.length))
+function link4(array7) {
+    if (!(n = array7.length))
         return;
     var n, i = 0,
-        a4 = array4[0],
+        a7 = array7[0],
         b;
     while (++i < n) {
-        a4.n = b = array4[i];
-        b.p = a4;
-        a4 = b;
+        a7.n = b = array7[i];
+        b.p = a7;
+        a7 = b;
     }
-    a4.n = b = array4[0];
-    b.p = a4;
+    a7.n = b = array7[0];
+    b.p = a7;
 }
 
-// node_modules/d3-geo/src/polygonContains.js
-function longitude(point6) {
-    return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);
+// js/pyobsplot-js/node_modules/d3-geo/src/polygonContains.js
+function longitude2(point11) {
+    return abs7(point11[0]) <= pi10 ? point11[0] : sign3(point11[0]) * ((abs7(point11[0]) + pi10) % tau12 - pi10);
 }
 
-function polygonContains_default(polygon, point6) {
-    var lambda = longitude(point6),
-        phi2 = point6[1],
-        sinPhi = sin2(phi2),
-        normal = [sin2(lambda), -cos2(lambda), 0],
-        angle2 = 0,
+function polygonContains_default2(polygon, point11) {
+    var lambda = longitude2(point11),
+        phi3 = point11[1],
+        sinPhi = sin5(phi3),
+        normal = [sin5(lambda), -cos5(lambda), 0],
+        angle3 = 0,
         winding = 0;
-    var sum5 = new Adder();
+    var sum8 = new Adder2();
     if (sinPhi === 1)
-        phi2 = halfPi3 + epsilon7;
+        phi3 = halfPi7 + epsilon14;
     else if (sinPhi === -1)
-        phi2 = -halfPi3 - epsilon7;
+        phi3 = -halfPi7 - epsilon14;
     for (var i = 0, n = polygon.length; i < n; ++i) {
-        if (!(m3 = (ring = polygon[i]).length))
+        if (!(m5 = (ring = polygon[i]).length))
             continue;
-        var ring, m3, point0 = ring[m3 - 1],
-            lambda04 = longitude(point0),
-            phi02 = point0[1] / 2 + quarterPi,
-            sinPhi03 = sin2(phi02),
-            cosPhi03 = cos2(phi02);
-        for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
+        var ring, m5, point0 = ring[m5 - 1],
+            lambda07 = longitude2(point0),
+            phi03 = point0[1] / 2 + quarterPi2,
+            sinPhi05 = sin5(phi03),
+            cosPhi05 = cos5(phi03);
+        for (var j = 0; j < m5; ++j, lambda07 = lambda13, sinPhi05 = sinPhi1, cosPhi05 = cosPhi1, point0 = point1) {
             var point1 = ring[j],
-                lambda12 = longitude(point1),
-                phi12 = point1[1] / 2 + quarterPi,
-                sinPhi1 = sin2(phi12),
-                cosPhi1 = cos2(phi12),
-                delta = lambda12 - lambda04,
-                sign3 = delta >= 0 ? 1 : -1,
-                absDelta = sign3 * delta,
-                antimeridian = absDelta > pi4,
-                k2 = sinPhi03 * sinPhi1;
-            sum5.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));
-            angle2 += antimeridian ? delta + sign3 * tau5 : delta;
-            if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
-                var arc = cartesianCross(cartesian(point0), cartesian(point1));
-                cartesianNormalizeInPlace(arc);
-                var intersection2 = cartesianCross(normal, arc);
-                cartesianNormalizeInPlace(intersection2);
-                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
-                if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
+                lambda13 = longitude2(point1),
+                phi13 = point1[1] / 2 + quarterPi2,
+                sinPhi1 = sin5(phi13),
+                cosPhi1 = cos5(phi13),
+                delta = lambda13 - lambda07,
+                sign5 = delta >= 0 ? 1 : -1,
+                absDelta = sign5 * delta,
+                antimeridian = absDelta > pi10,
+                k3 = sinPhi05 * sinPhi1;
+            sum8.add(atan23(k3 * sign5 * sin5(absDelta), cosPhi05 * cosPhi1 + k3 * cos5(absDelta)));
+            angle3 += antimeridian ? delta + sign5 * tau12 : delta;
+            if (antimeridian ^ lambda07 >= lambda ^ lambda13 >= lambda) {
+                var arc = cartesianCross2(cartesian2(point0), cartesian2(point1));
+                cartesianNormalizeInPlace2(arc);
+                var intersection3 = cartesianCross2(normal, arc);
+                cartesianNormalizeInPlace2(intersection3);
+                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin3(intersection3[2]);
+                if (phi3 > phiArc || phi3 === phiArc && (arc[0] || arc[1])) {
                     winding += antimeridian ^ delta >= 0 ? 1 : -1;
                 }
             }
         }
     }
-    return (angle2 < -epsilon7 || angle2 < epsilon7 && sum5 < -epsilon22) ^ winding & 1;
+    return (angle3 < -epsilon14 || angle3 < epsilon14 && sum8 < -epsilon24) ^ winding & 1;
 }
 
-// node_modules/d3-geo/src/clip/index.js
-function clip_default(pointVisible, clipLine, interpolate, start2) {
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/index.js
+function clip_default2(pointVisible, clipLine, interpolate, start3) {
     return function(sink) {
-        var line2 = clipLine(sink),
-            ringBuffer = buffer_default2(),
+        var line3 = clipLine(sink),
+            ringBuffer = buffer_default4(),
             ringSink = clipLine(ringBuffer),
             polygonStarted = false,
             polygon, segments, ring;
         var clip = {
-            point: point6,
+            point: point11,
             lineStart,
             lineEnd,
             polygonStart: function() {
                 clip.point = pointRing;
                 clip.lineStart = ringStart;
                 clip.lineEnd = ringEnd;
                 segments = [];
                 polygon = [];
             },
             polygonEnd: function() {
-                clip.point = point6;
+                clip.point = point11;
                 clip.lineStart = lineStart;
                 clip.lineEnd = lineEnd;
-                segments = merge(segments);
-                var startInside = polygonContains_default(polygon, start2);
+                segments = merge2(segments);
+                var startInside = polygonContains_default2(polygon, start3);
                 if (segments.length) {
                     if (!polygonStarted)
                         sink.polygonStart(), polygonStarted = true;
-                    rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
+                    rejoin_default2(segments, compareIntersection2, startInside, interpolate, sink);
                 } else if (startInside) {
                     if (!polygonStarted)
                         sink.polygonStart(), polygonStarted = true;
                     sink.lineStart();
                     interpolate(null, null, 1, sink);
                     sink.lineEnd();
                 }
@@ -12375,1072 +47081,1072 @@
                 sink.lineStart();
                 interpolate(null, null, 1, sink);
                 sink.lineEnd();
                 sink.polygonEnd();
             }
         };
 
-        function point6(lambda, phi2) {
-            if (pointVisible(lambda, phi2))
-                sink.point(lambda, phi2);
+        function point11(lambda, phi3) {
+            if (pointVisible(lambda, phi3))
+                sink.point(lambda, phi3);
         }
 
-        function pointLine(lambda, phi2) {
-            line2.point(lambda, phi2);
+        function pointLine(lambda, phi3) {
+            line3.point(lambda, phi3);
         }
 
         function lineStart() {
             clip.point = pointLine;
-            line2.lineStart();
+            line3.lineStart();
         }
 
         function lineEnd() {
-            clip.point = point6;
-            line2.lineEnd();
+            clip.point = point11;
+            line3.lineEnd();
         }
 
-        function pointRing(lambda, phi2) {
-            ring.push([lambda, phi2]);
-            ringSink.point(lambda, phi2);
+        function pointRing(lambda, phi3) {
+            ring.push([lambda, phi3]);
+            ringSink.point(lambda, phi3);
         }
 
         function ringStart() {
             ringSink.lineStart();
             ring = [];
         }
 
         function ringEnd() {
             pointRing(ring[0][0], ring[0][1]);
             ringSink.lineEnd();
             var clean = ringSink.clean(),
                 ringSegments = ringBuffer.result(),
                 i, n = ringSegments.length,
-                m3, segment, point7;
+                m5, segment, point12;
             ring.pop();
             polygon.push(ring);
             ring = null;
             if (!n)
                 return;
             if (clean & 1) {
                 segment = ringSegments[0];
-                if ((m3 = segment.length - 1) > 0) {
+                if ((m5 = segment.length - 1) > 0) {
                     if (!polygonStarted)
                         sink.polygonStart(), polygonStarted = true;
                     sink.lineStart();
-                    for (i = 0; i < m3; ++i)
-                        sink.point((point7 = segment[i])[0], point7[1]);
+                    for (i = 0; i < m5; ++i)
+                        sink.point((point12 = segment[i])[0], point12[1]);
                     sink.lineEnd();
                 }
                 return;
             }
             if (n > 1 && clean & 2)
                 ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
-            segments.push(ringSegments.filter(validSegment));
+            segments.push(ringSegments.filter(validSegment2));
         }
         return clip;
     };
 }
 
-function validSegment(segment) {
+function validSegment2(segment) {
     return segment.length > 1;
 }
 
-function compareIntersection(a4, b) {
-    return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);
+function compareIntersection2(a7, b) {
+    return ((a7 = a7.x)[0] < 0 ? a7[1] - halfPi7 - epsilon14 : halfPi7 - a7[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi7 - epsilon14 : halfPi7 - b[1]);
 }
 
-// node_modules/d3-geo/src/clip/antimeridian.js
-var antimeridian_default = clip_default(
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/antimeridian.js
+var antimeridian_default2 = clip_default2(
     function() {
         return true;
     },
-    clipAntimeridianLine,
-    clipAntimeridianInterpolate,
-    [-pi4, -halfPi3]
+    clipAntimeridianLine2,
+    clipAntimeridianInterpolate2,
+    [-pi10, -halfPi7]
 );
 
-function clipAntimeridianLine(stream) {
-    var lambda04 = NaN,
-        phi02 = NaN,
+function clipAntimeridianLine2(stream) {
+    var lambda07 = NaN,
+        phi03 = NaN,
         sign0 = NaN,
         clean;
     return {
         lineStart: function() {
             stream.lineStart();
             clean = 1;
         },
-        point: function(lambda12, phi12) {
-            var sign1 = lambda12 > 0 ? pi4 : -pi4,
-                delta = abs3(lambda12 - lambda04);
-            if (abs3(delta - pi4) < epsilon7) {
-                stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);
-                stream.point(sign0, phi02);
+        point: function(lambda13, phi13) {
+            var sign1 = lambda13 > 0 ? pi10 : -pi10,
+                delta = abs7(lambda13 - lambda07);
+            if (abs7(delta - pi10) < epsilon14) {
+                stream.point(lambda07, phi03 = (phi03 + phi13) / 2 > 0 ? halfPi7 : -halfPi7);
+                stream.point(sign0, phi03);
                 stream.lineEnd();
                 stream.lineStart();
-                stream.point(sign1, phi02);
-                stream.point(lambda12, phi02);
+                stream.point(sign1, phi03);
+                stream.point(lambda13, phi03);
                 clean = 0;
-            } else if (sign0 !== sign1 && delta >= pi4) {
-                if (abs3(lambda04 - sign0) < epsilon7)
-                    lambda04 -= sign0 * epsilon7;
-                if (abs3(lambda12 - sign1) < epsilon7)
-                    lambda12 -= sign1 * epsilon7;
-                phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
-                stream.point(sign0, phi02);
+            } else if (sign0 !== sign1 && delta >= pi10) {
+                if (abs7(lambda07 - sign0) < epsilon14)
+                    lambda07 -= sign0 * epsilon14;
+                if (abs7(lambda13 - sign1) < epsilon14)
+                    lambda13 -= sign1 * epsilon14;
+                phi03 = clipAntimeridianIntersect2(lambda07, phi03, lambda13, phi13);
+                stream.point(sign0, phi03);
                 stream.lineEnd();
                 stream.lineStart();
-                stream.point(sign1, phi02);
+                stream.point(sign1, phi03);
                 clean = 0;
             }
-            stream.point(lambda04 = lambda12, phi02 = phi12);
+            stream.point(lambda07 = lambda13, phi03 = phi13);
             sign0 = sign1;
         },
         lineEnd: function() {
             stream.lineEnd();
-            lambda04 = phi02 = NaN;
+            lambda07 = phi03 = NaN;
         },
         clean: function() {
             return 2 - clean;
         }
     };
 }
 
-function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
-    var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);
-    return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
+function clipAntimeridianIntersect2(lambda07, phi03, lambda13, phi13) {
+    var cosPhi05, cosPhi1, sinLambda0Lambda1 = sin5(lambda07 - lambda13);
+    return abs7(sinLambda0Lambda1) > epsilon14 ? atan3((sin5(phi03) * (cosPhi1 = cos5(phi13)) * sin5(lambda13) - sin5(phi13) * (cosPhi05 = cos5(phi03)) * sin5(lambda07)) / (cosPhi05 * cosPhi1 * sinLambda0Lambda1)) : (phi03 + phi13) / 2;
 }
 
-function clipAntimeridianInterpolate(from, to, direction, stream) {
-    var phi2;
+function clipAntimeridianInterpolate2(from, to, direction, stream) {
+    var phi3;
     if (from == null) {
-        phi2 = direction * halfPi3;
-        stream.point(-pi4, phi2);
-        stream.point(0, phi2);
-        stream.point(pi4, phi2);
-        stream.point(pi4, 0);
-        stream.point(pi4, -phi2);
-        stream.point(0, -phi2);
-        stream.point(-pi4, -phi2);
-        stream.point(-pi4, 0);
-        stream.point(-pi4, phi2);
-    } else if (abs3(from[0] - to[0]) > epsilon7) {
-        var lambda = from[0] < to[0] ? pi4 : -pi4;
-        phi2 = direction * lambda / 2;
-        stream.point(-lambda, phi2);
-        stream.point(0, phi2);
-        stream.point(lambda, phi2);
+        phi3 = direction * halfPi7;
+        stream.point(-pi10, phi3);
+        stream.point(0, phi3);
+        stream.point(pi10, phi3);
+        stream.point(pi10, 0);
+        stream.point(pi10, -phi3);
+        stream.point(0, -phi3);
+        stream.point(-pi10, -phi3);
+        stream.point(-pi10, 0);
+        stream.point(-pi10, phi3);
+    } else if (abs7(from[0] - to[0]) > epsilon14) {
+        var lambda = from[0] < to[0] ? pi10 : -pi10;
+        phi3 = direction * lambda / 2;
+        stream.point(-lambda, phi3);
+        stream.point(0, phi3);
+        stream.point(lambda, phi3);
     } else {
         stream.point(to[0], to[1]);
     }
 }
 
-// node_modules/d3-geo/src/clip/circle.js
-function circle_default2(radius2) {
-    var cr = cos2(radius2),
-        delta = 6 * radians2,
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/circle.js
+function circle_default5(radius3) {
+    var cr = cos5(radius3),
+        delta = 6 * radians5,
         smallRadius = cr > 0,
-        notHemisphere = abs3(cr) > epsilon7;
+        notHemisphere = abs7(cr) > epsilon14;
 
     function interpolate(from, to, direction, stream) {
-        circleStream(stream, radius2, delta, direction, from, to);
+        circleStream2(stream, radius3, delta, direction, from, to);
     }
 
-    function visible(lambda, phi2) {
-        return cos2(lambda) * cos2(phi2) > cr;
+    function visible(lambda, phi3) {
+        return cos5(lambda) * cos5(phi3) > cr;
     }
 
     function clipLine(stream) {
         var point0, c0, v0, v00, clean;
         return {
             lineStart: function() {
                 v00 = v0 = false;
                 clean = 1;
             },
-            point: function(lambda, phi2) {
-                var point1 = [lambda, phi2],
-                    point22, v2 = visible(lambda, phi2),
-                    c6 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
-                if (!point0 && (v00 = v0 = v2))
+            point: function(lambda, phi3) {
+                var point1 = [lambda, phi3],
+                    point22, v3 = visible(lambda, phi3),
+                    c11 = smallRadius ? v3 ? 0 : code(lambda, phi3) : v3 ? code(lambda + (lambda < 0 ? pi10 : -pi10), phi3) : 0;
+                if (!point0 && (v00 = v0 = v3))
                     stream.lineStart();
-                if (v2 !== v0) {
-                    point22 = intersect2(point0, point1);
-                    if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
+                if (v3 !== v0) {
+                    point22 = intersect3(point0, point1);
+                    if (!point22 || pointEqual_default2(point0, point22) || pointEqual_default2(point1, point22))
                         point1[2] = 1;
                 }
-                if (v2 !== v0) {
+                if (v3 !== v0) {
                     clean = 0;
-                    if (v2) {
+                    if (v3) {
                         stream.lineStart();
-                        point22 = intersect2(point1, point0);
+                        point22 = intersect3(point1, point0);
                         stream.point(point22[0], point22[1]);
                     } else {
-                        point22 = intersect2(point0, point1);
+                        point22 = intersect3(point0, point1);
                         stream.point(point22[0], point22[1], 2);
                         stream.lineEnd();
                     }
                     point0 = point22;
-                } else if (notHemisphere && point0 && smallRadius ^ v2) {
+                } else if (notHemisphere && point0 && smallRadius ^ v3) {
                     var t;
-                    if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {
+                    if (!(c11 & c0) && (t = intersect3(point1, point0, true))) {
                         clean = 0;
                         if (smallRadius) {
                             stream.lineStart();
                             stream.point(t[0][0], t[0][1]);
                             stream.point(t[1][0], t[1][1]);
                             stream.lineEnd();
                         } else {
                             stream.point(t[1][0], t[1][1]);
                             stream.lineEnd();
                             stream.lineStart();
                             stream.point(t[0][0], t[0][1], 3);
                         }
                     }
                 }
-                if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
+                if (v3 && (!point0 || !pointEqual_default2(point0, point1))) {
                     stream.point(point1[0], point1[1]);
                 }
-                point0 = point1, v0 = v2, c0 = c6;
+                point0 = point1, v0 = v3, c0 = c11;
             },
             lineEnd: function() {
                 if (v0)
                     stream.lineEnd();
                 point0 = null;
             },
             // Rejoin first and last segments if there were intersections and the first
             // and last points were visible.
             clean: function() {
                 return clean | (v00 && v0) << 1;
             }
         };
     }
 
-    function intersect2(a4, b, two) {
-        var pa = cartesian(a4),
-            pb = cartesian(b);
+    function intersect3(a7, b, two) {
+        var pa = cartesian2(a7),
+            pb = cartesian2(b);
         var n1 = [1, 0, 0],
-            n2 = cartesianCross(pa, pb),
-            n2n2 = cartesianDot(n2, n2),
+            n2 = cartesianCross2(pa, pb),
+            n2n2 = cartesianDot2(n2, n2),
             n1n2 = n2[0],
             determinant = n2n2 - n1n2 * n1n2;
         if (!determinant)
-            return !two && a4;
+            return !two && a7;
         var c1 = cr * n2n2 / determinant,
             c22 = -cr * n1n2 / determinant,
-            n1xn2 = cartesianCross(n1, n2),
-            A5 = cartesianScale(n1, c1),
-            B3 = cartesianScale(n2, c22);
-        cartesianAddInPlace(A5, B3);
-        var u4 = n1xn2,
-            w = cartesianDot(A5, u4),
-            uu = cartesianDot(u4, u4),
-            t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
-        if (t22 < 0)
-            return;
-        var t = sqrt(t22),
-            q = cartesianScale(u4, (-w - t) / uu);
-        cartesianAddInPlace(q, A5);
-        q = spherical(q);
+            n1xn2 = cartesianCross2(n1, n2),
+            A6 = cartesianScale2(n1, c1),
+            B5 = cartesianScale2(n2, c22);
+        cartesianAddInPlace2(A6, B5);
+        var u7 = n1xn2,
+            w = cartesianDot2(A6, u7),
+            uu = cartesianDot2(u7, u7),
+            t23 = w * w - uu * (cartesianDot2(A6, A6) - 1);
+        if (t23 < 0)
+            return;
+        var t = sqrt4(t23),
+            q = cartesianScale2(u7, (-w - t) / uu);
+        cartesianAddInPlace2(q, A6);
+        q = spherical2(q);
         if (!two)
             return q;
-        var lambda04 = a4[0],
-            lambda12 = b[0],
-            phi02 = a4[1],
-            phi12 = b[1],
+        var lambda07 = a7[0],
+            lambda13 = b[0],
+            phi03 = a7[1],
+            phi13 = b[1],
             z;
-        if (lambda12 < lambda04)
-            z = lambda04, lambda04 = lambda12, lambda12 = z;
-        var delta2 = lambda12 - lambda04,
-            polar = abs3(delta2 - pi4) < epsilon7,
-            meridian = polar || delta2 < epsilon7;
-        if (!polar && phi12 < phi02)
-            z = phi02, phi02 = phi12, phi12 = z;
-        if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {
-            var q1 = cartesianScale(u4, (-w + t) / uu);
-            cartesianAddInPlace(q1, A5);
-            return [q, spherical(q1)];
+        if (lambda13 < lambda07)
+            z = lambda07, lambda07 = lambda13, lambda13 = z;
+        var delta2 = lambda13 - lambda07,
+            polar = abs7(delta2 - pi10) < epsilon14,
+            meridian = polar || delta2 < epsilon14;
+        if (!polar && phi13 < phi03)
+            z = phi03, phi03 = phi13, phi13 = z;
+        if (meridian ? polar ? phi03 + phi13 > 0 ^ q[1] < (abs7(q[0] - lambda07) < epsilon14 ? phi03 : phi13) : phi03 <= q[1] && q[1] <= phi13 : delta2 > pi10 ^ (lambda07 <= q[0] && q[0] <= lambda13)) {
+            var q1 = cartesianScale2(u7, (-w + t) / uu);
+            cartesianAddInPlace2(q1, A6);
+            return [q, spherical2(q1)];
         }
     }
 
-    function code(lambda, phi2) {
-        var r = smallRadius ? radius2 : pi4 - radius2,
+    function code(lambda, phi3) {
+        var r = smallRadius ? radius3 : pi10 - radius3,
             code2 = 0;
         if (lambda < -r)
             code2 |= 1;
         else if (lambda > r)
             code2 |= 2;
-        if (phi2 < -r)
+        if (phi3 < -r)
             code2 |= 4;
-        else if (phi2 > r)
+        else if (phi3 > r)
             code2 |= 8;
         return code2;
     }
-    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi4, radius2 - pi4]);
+    return clip_default2(visible, clipLine, interpolate, smallRadius ? [0, -radius3] : [-pi10, radius3 - pi10]);
 }
 
-// node_modules/d3-geo/src/clip/line.js
-function line_default(a4, b, x06, y06, x12, y12) {
-    var ax = a4[0],
-        ay = a4[1],
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/line.js
+function line_default3(a7, b, x011, y011, x13, y13) {
+    var ax = a7[0],
+        ay = a7[1],
         bx = b[0],
         by = b[1],
-        t03 = 0,
-        t13 = 1,
+        t05 = 0,
+        t15 = 1,
         dx = bx - ax,
         dy = by - ay,
         r;
-    r = x06 - ax;
+    r = x011 - ax;
     if (!dx && r > 0)
         return;
     r /= dx;
     if (dx < 0) {
-        if (r < t03)
+        if (r < t05)
             return;
-        if (r < t13)
-            t13 = r;
+        if (r < t15)
+            t15 = r;
     } else if (dx > 0) {
-        if (r > t13)
+        if (r > t15)
             return;
-        if (r > t03)
-            t03 = r;
+        if (r > t05)
+            t05 = r;
     }
-    r = x12 - ax;
+    r = x13 - ax;
     if (!dx && r < 0)
         return;
     r /= dx;
     if (dx < 0) {
-        if (r > t13)
+        if (r > t15)
             return;
-        if (r > t03)
-            t03 = r;
+        if (r > t05)
+            t05 = r;
     } else if (dx > 0) {
-        if (r < t03)
+        if (r < t05)
             return;
-        if (r < t13)
-            t13 = r;
+        if (r < t15)
+            t15 = r;
     }
-    r = y06 - ay;
+    r = y011 - ay;
     if (!dy && r > 0)
         return;
     r /= dy;
     if (dy < 0) {
-        if (r < t03)
+        if (r < t05)
             return;
-        if (r < t13)
-            t13 = r;
+        if (r < t15)
+            t15 = r;
     } else if (dy > 0) {
-        if (r > t13)
+        if (r > t15)
             return;
-        if (r > t03)
-            t03 = r;
+        if (r > t05)
+            t05 = r;
     }
-    r = y12 - ay;
+    r = y13 - ay;
     if (!dy && r < 0)
         return;
     r /= dy;
     if (dy < 0) {
-        if (r > t13)
+        if (r > t15)
             return;
-        if (r > t03)
-            t03 = r;
+        if (r > t05)
+            t05 = r;
     } else if (dy > 0) {
-        if (r < t03)
+        if (r < t05)
             return;
-        if (r < t13)
-            t13 = r;
+        if (r < t15)
+            t15 = r;
     }
-    if (t03 > 0)
-        a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;
-    if (t13 < 1)
-        b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
+    if (t05 > 0)
+        a7[0] = ax + t05 * dx, a7[1] = ay + t05 * dy;
+    if (t15 < 1)
+        b[0] = ax + t15 * dx, b[1] = ay + t15 * dy;
     return true;
 }
 
-// node_modules/d3-geo/src/clip/rectangle.js
-var clipMax = 1e9;
-var clipMin = -clipMax;
-
-function clipRectangle(x06, y06, x12, y12) {
-    function visible(x4, y4) {
-        return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/rectangle.js
+var clipMax2 = 1e9;
+var clipMin2 = -clipMax2;
+
+function clipRectangle2(x011, y011, x13, y13) {
+    function visible(x7, y7) {
+        return x011 <= x7 && x7 <= x13 && y011 <= y7 && y7 <= y13;
     }
 
     function interpolate(from, to, direction, stream) {
-        var a4 = 0,
+        var a7 = 0,
             a1 = 0;
-        if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
+        if (from == null || (a7 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
             do
-                stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);
-            while ((a4 = (a4 + direction + 4) % 4) !== a1);
+                stream.point(a7 === 0 || a7 === 3 ? x011 : x13, a7 > 1 ? y13 : y011);
+            while ((a7 = (a7 + direction + 4) % 4) !== a1);
         } else {
             stream.point(to[0], to[1]);
         }
     }
 
     function corner(p, direction) {
-        return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
+        return abs7(p[0] - x011) < epsilon14 ? direction > 0 ? 0 : 3 : abs7(p[0] - x13) < epsilon14 ? direction > 0 ? 2 : 1 : abs7(p[1] - y011) < epsilon14 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
     }
 
-    function compareIntersection2(a4, b) {
-        return comparePoint(a4.x, b.x);
+    function compareIntersection3(a7, b) {
+        return comparePoint(a7.x, b.x);
     }
 
-    function comparePoint(a4, b) {
-        var ca3 = corner(a4, 1),
+    function comparePoint(a7, b) {
+        var ca5 = corner(a7, 1),
             cb = corner(b, 1);
-        return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a4[1] : ca3 === 1 ? a4[0] - b[0] : ca3 === 2 ? a4[1] - b[1] : b[0] - a4[0];
+        return ca5 !== cb ? ca5 - cb : ca5 === 0 ? b[1] - a7[1] : ca5 === 1 ? a7[0] - b[0] : ca5 === 2 ? a7[1] - b[1] : b[0] - a7[0];
     }
     return function(stream) {
         var activeStream = stream,
-            bufferStream = buffer_default2(),
-            segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;
+            bufferStream = buffer_default4(),
+            segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
         var clipStream = {
-            point: point6,
+            point: point11,
             lineStart,
             lineEnd,
             polygonStart,
             polygonEnd
         };
 
-        function point6(x4, y4) {
-            if (visible(x4, y4))
-                activeStream.point(x4, y4);
+        function point11(x7, y7) {
+            if (visible(x7, y7))
+                activeStream.point(x7, y7);
         }
 
         function polygonInside() {
             var winding = 0;
             for (var i = 0, n = polygon.length; i < n; ++i) {
-                for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j < m3; ++j) {
-                    a0 = b02, a1 = b12, point7 = ring2[j], b02 = point7[0], b12 = point7[1];
-                    if (a1 <= y12) {
-                        if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0))
+                for (var ring2 = polygon[i], j = 1, m5 = ring2.length, point12 = ring2[0], a0, a1, b03 = point12[0], b13 = point12[1]; j < m5; ++j) {
+                    a0 = b03, a1 = b13, point12 = ring2[j], b03 = point12[0], b13 = point12[1];
+                    if (a1 <= y13) {
+                        if (b13 > y13 && (b03 - a0) * (y13 - a1) > (b13 - a1) * (x011 - a0))
                             ++winding;
                     } else {
-                        if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0))
+                        if (b13 <= y13 && (b03 - a0) * (y13 - a1) < (b13 - a1) * (x011 - a0))
                             --winding;
                     }
                 }
             }
             return winding;
         }
 
         function polygonStart() {
             activeStream = bufferStream, segments = [], polygon = [], clean = true;
         }
 
         function polygonEnd() {
             var startInside = polygonInside(),
                 cleanInside = clean && startInside,
-                visible2 = (segments = merge(segments)).length;
+                visible2 = (segments = merge2(segments)).length;
             if (cleanInside || visible2) {
                 stream.polygonStart();
                 if (cleanInside) {
                     stream.lineStart();
                     interpolate(null, null, 1, stream);
                     stream.lineEnd();
                 }
                 if (visible2) {
-                    rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
+                    rejoin_default2(segments, compareIntersection3, startInside, interpolate, stream);
                 }
                 stream.polygonEnd();
             }
             activeStream = stream, segments = polygon = ring = null;
         }
 
         function lineStart() {
-            clipStream.point = linePoint2;
+            clipStream.point = linePoint3;
             if (polygon)
                 polygon.push(ring = []);
-            first2 = true;
+            first3 = true;
             v_ = false;
             x_ = y_ = NaN;
         }
 
         function lineEnd() {
             if (segments) {
-                linePoint2(x__, y__);
+                linePoint3(x__, y__);
                 if (v__ && v_)
                     bufferStream.rejoin();
                 segments.push(bufferStream.result());
             }
-            clipStream.point = point6;
+            clipStream.point = point11;
             if (v_)
                 activeStream.lineEnd();
         }
 
-        function linePoint2(x4, y4) {
-            var v2 = visible(x4, y4);
+        function linePoint3(x7, y7) {
+            var v3 = visible(x7, y7);
             if (polygon)
-                ring.push([x4, y4]);
-            if (first2) {
-                x__ = x4, y__ = y4, v__ = v2;
-                first2 = false;
-                if (v2) {
+                ring.push([x7, y7]);
+            if (first3) {
+                x__ = x7, y__ = y7, v__ = v3;
+                first3 = false;
+                if (v3) {
                     activeStream.lineStart();
-                    activeStream.point(x4, y4);
+                    activeStream.point(x7, y7);
                 }
             } else {
-                if (v2 && v_)
-                    activeStream.point(x4, y4);
+                if (v3 && v_)
+                    activeStream.point(x7, y7);
                 else {
-                    var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
-                        b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
-                    if (line_default(a4, b, x06, y06, x12, y12)) {
+                    var a7 = [x_ = Math.max(clipMin2, Math.min(clipMax2, x_)), y_ = Math.max(clipMin2, Math.min(clipMax2, y_))],
+                        b = [x7 = Math.max(clipMin2, Math.min(clipMax2, x7)), y7 = Math.max(clipMin2, Math.min(clipMax2, y7))];
+                    if (line_default3(a7, b, x011, y011, x13, y13)) {
                         if (!v_) {
                             activeStream.lineStart();
-                            activeStream.point(a4[0], a4[1]);
+                            activeStream.point(a7[0], a7[1]);
                         }
                         activeStream.point(b[0], b[1]);
-                        if (!v2)
+                        if (!v3)
                             activeStream.lineEnd();
                         clean = false;
-                    } else if (v2) {
+                    } else if (v3) {
                         activeStream.lineStart();
-                        activeStream.point(x4, y4);
+                        activeStream.point(x7, y7);
                         clean = false;
                     }
                 }
             }
-            x_ = x4, y_ = y4, v_ = v2;
+            x_ = x7, y_ = y7, v_ = v3;
         }
         return clipStream;
     };
 }
 
-// node_modules/d3-geo/src/clip/extent.js
-function extent_default2() {
-    var x06 = 0,
-        y06 = 0,
-        x12 = 960,
-        y12 = 500,
+// js/pyobsplot-js/node_modules/d3-geo/src/clip/extent.js
+function extent_default4() {
+    var x011 = 0,
+        y011 = 0,
+        x13 = 960,
+        y13 = 500,
         cache, cacheStream, clip;
     return clip = {
         stream: function(stream) {
-            return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);
+            return cache && cacheStream === stream ? cache : cache = clipRectangle2(x011, y011, x13, y13)(cacheStream = stream);
         },
         extent: function(_) {
-            return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip) : [
-                [x06, y06],
-                [x12, y12]
+            return arguments.length ? (x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1], cache = cacheStream = null, clip) : [
+                [x011, y011],
+                [x13, y13]
             ];
         }
     };
 }
 
-// node_modules/d3-geo/src/length.js
-var lengthSum;
-var lambda03;
-var sinPhi02;
-var cosPhi02;
-var lengthStream = {
-    sphere: noop2,
-    point: noop2,
-    lineStart: lengthLineStart,
-    lineEnd: noop2,
-    polygonStart: noop2,
-    polygonEnd: noop2
-};
-
-function lengthLineStart() {
-    lengthStream.point = lengthPointFirst;
-    lengthStream.lineEnd = lengthLineEnd;
-}
-
-function lengthLineEnd() {
-    lengthStream.point = lengthStream.lineEnd = noop2;
-}
-
-function lengthPointFirst(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);
-    lengthStream.point = lengthPoint;
-}
-
-function lengthPoint(lambda, phi2) {
-    lambda *= radians2, phi2 *= radians2;
-    var sinPhi = sin2(phi2),
-        cosPhi = cos2(phi2),
-        delta = abs3(lambda - lambda03),
-        cosDelta = cos2(delta),
-        sinDelta = sin2(delta),
-        x4 = cosPhi * sinDelta,
-        y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta,
-        z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
-    lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z));
-    lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
-}
-
-function length_default(object2) {
-    lengthSum = new Adder();
-    stream_default(object2, lengthStream);
-    return +lengthSum;
-}
-
-// node_modules/d3-geo/src/distance.js
-var coordinates = [null, null];
-var object = {
+// js/pyobsplot-js/node_modules/d3-geo/src/length.js
+var lengthSum3;
+var lambda06;
+var sinPhi04;
+var cosPhi04;
+var lengthStream3 = {
+    sphere: noop4,
+    point: noop4,
+    lineStart: lengthLineStart2,
+    lineEnd: noop4,
+    polygonStart: noop4,
+    polygonEnd: noop4
+};
+
+function lengthLineStart2() {
+    lengthStream3.point = lengthPointFirst3;
+    lengthStream3.lineEnd = lengthLineEnd2;
+}
+
+function lengthLineEnd2() {
+    lengthStream3.point = lengthStream3.lineEnd = noop4;
+}
+
+function lengthPointFirst3(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    lambda06 = lambda, sinPhi04 = sin5(phi3), cosPhi04 = cos5(phi3);
+    lengthStream3.point = lengthPoint3;
+}
+
+function lengthPoint3(lambda, phi3) {
+    lambda *= radians5, phi3 *= radians5;
+    var sinPhi = sin5(phi3),
+        cosPhi = cos5(phi3),
+        delta = abs7(lambda - lambda06),
+        cosDelta = cos5(delta),
+        sinDelta = sin5(delta),
+        x7 = cosPhi * sinDelta,
+        y7 = cosPhi04 * sinPhi - sinPhi04 * cosPhi * cosDelta,
+        z = sinPhi04 * sinPhi + cosPhi04 * cosPhi * cosDelta;
+    lengthSum3.add(atan23(sqrt4(x7 * x7 + y7 * y7), z));
+    lambda06 = lambda, sinPhi04 = sinPhi, cosPhi04 = cosPhi;
+}
+
+function length_default3(object3) {
+    lengthSum3 = new Adder2();
+    stream_default2(object3, lengthStream3);
+    return +lengthSum3;
+}
+
+// js/pyobsplot-js/node_modules/d3-geo/src/distance.js
+var coordinates2 = [null, null];
+var object2 = {
     type: "LineString",
-    coordinates
+    coordinates: coordinates2
 };
 
-function distance_default(a4, b) {
-    coordinates[0] = a4;
-    coordinates[1] = b;
-    return length_default(object);
+function distance_default2(a7, b) {
+    coordinates2[0] = a7;
+    coordinates2[1] = b;
+    return length_default3(object2);
 }
 
-// node_modules/d3-geo/src/contains.js
-var containsObjectType = {
-    Feature: function(object2, point6) {
-        return containsGeometry(object2.geometry, point6);
+// js/pyobsplot-js/node_modules/d3-geo/src/contains.js
+var containsObjectType2 = {
+    Feature: function(object3, point11) {
+        return containsGeometry2(object3.geometry, point11);
     },
-    FeatureCollection: function(object2, point6) {
-        var features = object2.features,
+    FeatureCollection: function(object3, point11) {
+        var features = object3.features,
             i = -1,
             n = features.length;
         while (++i < n)
-            if (containsGeometry(features[i].geometry, point6))
+            if (containsGeometry2(features[i].geometry, point11))
                 return true;
         return false;
     }
 };
-var containsGeometryType = {
+var containsGeometryType2 = {
     Sphere: function() {
         return true;
     },
-    Point: function(object2, point6) {
-        return containsPoint(object2.coordinates, point6);
+    Point: function(object3, point11) {
+        return containsPoint2(object3.coordinates, point11);
     },
-    MultiPoint: function(object2, point6) {
-        var coordinates2 = object2.coordinates,
+    MultiPoint: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            if (containsPoint(coordinates2[i], point6))
+            if (containsPoint2(coordinates3[i], point11))
                 return true;
         return false;
     },
-    LineString: function(object2, point6) {
-        return containsLine(object2.coordinates, point6);
+    LineString: function(object3, point11) {
+        return containsLine2(object3.coordinates, point11);
     },
-    MultiLineString: function(object2, point6) {
-        var coordinates2 = object2.coordinates,
+    MultiLineString: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            if (containsLine(coordinates2[i], point6))
+            if (containsLine2(coordinates3[i], point11))
                 return true;
         return false;
     },
-    Polygon: function(object2, point6) {
-        return containsPolygon(object2.coordinates, point6);
+    Polygon: function(object3, point11) {
+        return containsPolygon2(object3.coordinates, point11);
     },
-    MultiPolygon: function(object2, point6) {
-        var coordinates2 = object2.coordinates,
+    MultiPolygon: function(object3, point11) {
+        var coordinates3 = object3.coordinates,
             i = -1,
-            n = coordinates2.length;
+            n = coordinates3.length;
         while (++i < n)
-            if (containsPolygon(coordinates2[i], point6))
+            if (containsPolygon2(coordinates3[i], point11))
                 return true;
         return false;
     },
-    GeometryCollection: function(object2, point6) {
-        var geometries = object2.geometries,
+    GeometryCollection: function(object3, point11) {
+        var geometries = object3.geometries,
             i = -1,
             n = geometries.length;
         while (++i < n)
-            if (containsGeometry(geometries[i], point6))
+            if (containsGeometry2(geometries[i], point11))
                 return true;
         return false;
     }
 };
 
-function containsGeometry(geometry, point6) {
-    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;
+function containsGeometry2(geometry, point11) {
+    return geometry && containsGeometryType2.hasOwnProperty(geometry.type) ? containsGeometryType2[geometry.type](geometry, point11) : false;
 }
 
-function containsPoint(coordinates2, point6) {
-    return distance_default(coordinates2, point6) === 0;
+function containsPoint2(coordinates3, point11) {
+    return distance_default2(coordinates3, point11) === 0;
 }
 
-function containsLine(coordinates2, point6) {
-    var ao, bo, ab4;
-    for (var i = 0, n = coordinates2.length; i < n; i++) {
-        bo = distance_default(coordinates2[i], point6);
+function containsLine2(coordinates3, point11) {
+    var ao, bo, ab7;
+    for (var i = 0, n = coordinates3.length; i < n; i++) {
+        bo = distance_default2(coordinates3[i], point11);
         if (bo === 0)
             return true;
         if (i > 0) {
-            ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);
-            if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)
+            ab7 = distance_default2(coordinates3[i], coordinates3[i - 1]);
+            if (ab7 > 0 && ao <= ab7 && bo <= ab7 && (ao + bo - ab7) * (1 - Math.pow((ao - bo) / ab7, 2)) < epsilon24 * ab7)
                 return true;
         }
         ao = bo;
     }
     return false;
 }
 
-function containsPolygon(coordinates2, point6) {
-    return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));
+function containsPolygon2(coordinates3, point11) {
+    return !!polygonContains_default2(coordinates3.map(ringRadians2), pointRadians2(point11));
 }
 
-function ringRadians(ring) {
-    return ring = ring.map(pointRadians), ring.pop(), ring;
+function ringRadians2(ring) {
+    return ring = ring.map(pointRadians2), ring.pop(), ring;
 }
 
-function pointRadians(point6) {
-    return [point6[0] * radians2, point6[1] * radians2];
+function pointRadians2(point11) {
+    return [point11[0] * radians5, point11[1] * radians5];
 }
 
-function contains_default2(object2, point6) {
-    return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);
+function contains_default5(object3, point11) {
+    return (object3 && containsObjectType2.hasOwnProperty(object3.type) ? containsObjectType2[object3.type] : containsGeometry2)(object3, point11);
 }
 
-// node_modules/d3-geo/src/graticule.js
-function graticuleX(y06, y12, dy) {
-    var y4 = range(y06, y12 - epsilon7, dy).concat(y12);
-    return function(x4) {
-        return y4.map(function(y5) {
-            return [x4, y5];
+// js/pyobsplot-js/node_modules/d3-geo/src/graticule.js
+function graticuleX2(y011, y13, dy) {
+    var y7 = range5(y011, y13 - epsilon14, dy).concat(y13);
+    return function(x7) {
+        return y7.map(function(y8) {
+            return [x7, y8];
         });
     };
 }
 
-function graticuleY(x06, x12, dx) {
-    var x4 = range(x06, x12 - epsilon7, dx).concat(x12);
-    return function(y4) {
-        return x4.map(function(x5) {
-            return [x5, y4];
+function graticuleY2(x011, x13, dx) {
+    var x7 = range5(x011, x13 - epsilon14, dx).concat(x13);
+    return function(y7) {
+        return x7.map(function(x8) {
+            return [x8, y7];
         });
     };
 }
 
-function graticule() {
-    var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10,
+function graticule3() {
+    var x13, x011, X15, X05, y13, y011, Y15, Y05, dx = 10,
         dy = dx,
         DX = 90,
         DY = 360,
-        x4, y4, X3, Y3, precision = 2.5;
+        x7, y7, X4, Y4, precision = 2.5;
 
-    function graticule3() {
+    function graticule5() {
         return {
             type: "MultiLineString",
             coordinates: lines()
         };
     }
 
     function lines() {
-        return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {
-            return abs3(x5 % DX) > epsilon7;
-        }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {
-            return abs3(y5 % DY) > epsilon7;
-        }).map(y4));
+        return range5(ceil2(X05 / DX) * DX, X15, DX).map(X4).concat(range5(ceil2(Y05 / DY) * DY, Y15, DY).map(Y4)).concat(range5(ceil2(x011 / dx) * dx, x13, dx).filter(function(x8) {
+            return abs7(x8 % DX) > epsilon14;
+        }).map(x7)).concat(range5(ceil2(y011 / dy) * dy, y13, dy).filter(function(y8) {
+            return abs7(y8 % DY) > epsilon14;
+        }).map(y7));
     }
-    graticule3.lines = function() {
-        return lines().map(function(coordinates2) {
+    graticule5.lines = function() {
+        return lines().map(function(coordinates3) {
             return {
                 type: "LineString",
-                coordinates: coordinates2
+                coordinates: coordinates3
             };
         });
     };
-    graticule3.outline = function() {
+    graticule5.outline = function() {
         return {
             type: "Polygon",
             coordinates: [
-                X3(X03).concat(
-                    Y3(Y13).slice(1),
-                    X3(X13).reverse().slice(1),
-                    Y3(Y03).reverse().slice(1)
+                X4(X05).concat(
+                    Y4(Y15).slice(1),
+                    X4(X15).reverse().slice(1),
+                    Y4(Y05).reverse().slice(1)
                 )
             ]
         };
     };
-    graticule3.extent = function(_) {
+    graticule5.extent = function(_) {
         if (!arguments.length)
-            return graticule3.extentMinor();
-        return graticule3.extentMajor(_).extentMinor(_);
+            return graticule5.extentMinor();
+        return graticule5.extentMajor(_).extentMinor(_);
     };
-    graticule3.extentMajor = function(_) {
+    graticule5.extentMajor = function(_) {
         if (!arguments.length)
             return [
-                [X03, Y03],
-                [X13, Y13]
+                [X05, Y05],
+                [X15, Y15]
             ];
-        X03 = +_[0][0], X13 = +_[1][0];
-        Y03 = +_[0][1], Y13 = +_[1][1];
-        if (X03 > X13)
-            _ = X03, X03 = X13, X13 = _;
-        if (Y03 > Y13)
-            _ = Y03, Y03 = Y13, Y13 = _;
-        return graticule3.precision(precision);
+        X05 = +_[0][0], X15 = +_[1][0];
+        Y05 = +_[0][1], Y15 = +_[1][1];
+        if (X05 > X15)
+            _ = X05, X05 = X15, X15 = _;
+        if (Y05 > Y15)
+            _ = Y05, Y05 = Y15, Y15 = _;
+        return graticule5.precision(precision);
     };
-    graticule3.extentMinor = function(_) {
+    graticule5.extentMinor = function(_) {
         if (!arguments.length)
             return [
-                [x06, y06],
-                [x12, y12]
+                [x011, y011],
+                [x13, y13]
             ];
-        x06 = +_[0][0], x12 = +_[1][0];
-        y06 = +_[0][1], y12 = +_[1][1];
-        if (x06 > x12)
-            _ = x06, x06 = x12, x12 = _;
-        if (y06 > y12)
-            _ = y06, y06 = y12, y12 = _;
-        return graticule3.precision(precision);
+        x011 = +_[0][0], x13 = +_[1][0];
+        y011 = +_[0][1], y13 = +_[1][1];
+        if (x011 > x13)
+            _ = x011, x011 = x13, x13 = _;
+        if (y011 > y13)
+            _ = y011, y011 = y13, y13 = _;
+        return graticule5.precision(precision);
     };
-    graticule3.step = function(_) {
+    graticule5.step = function(_) {
         if (!arguments.length)
-            return graticule3.stepMinor();
-        return graticule3.stepMajor(_).stepMinor(_);
+            return graticule5.stepMinor();
+        return graticule5.stepMajor(_).stepMinor(_);
     };
-    graticule3.stepMajor = function(_) {
+    graticule5.stepMajor = function(_) {
         if (!arguments.length)
             return [DX, DY];
         DX = +_[0], DY = +_[1];
-        return graticule3;
+        return graticule5;
     };
-    graticule3.stepMinor = function(_) {
+    graticule5.stepMinor = function(_) {
         if (!arguments.length)
             return [dx, dy];
         dx = +_[0], dy = +_[1];
-        return graticule3;
+        return graticule5;
     };
-    graticule3.precision = function(_) {
+    graticule5.precision = function(_) {
         if (!arguments.length)
             return precision;
         precision = +_;
-        x4 = graticuleX(y06, y12, 90);
-        y4 = graticuleY(x06, x12, precision);
-        X3 = graticuleX(Y03, Y13, 90);
-        Y3 = graticuleY(X03, X13, precision);
-        return graticule3;
-    };
-    return graticule3.extentMajor([
-        [-180, -90 + epsilon7],
-        [180, 90 - epsilon7]
+        x7 = graticuleX2(y011, y13, 90);
+        y7 = graticuleY2(x011, x13, precision);
+        X4 = graticuleX2(Y05, Y15, 90);
+        Y4 = graticuleY2(X05, X15, precision);
+        return graticule5;
+    };
+    return graticule5.extentMajor([
+        [-180, -90 + epsilon14],
+        [180, 90 - epsilon14]
     ]).extentMinor([
-        [-180, -80 - epsilon7],
-        [180, 80 + epsilon7]
+        [-180, -80 - epsilon14],
+        [180, 80 + epsilon14]
     ]);
 }
 
-function graticule10() {
-    return graticule()();
+function graticule102() {
+    return graticule3()();
 }
 
-// node_modules/d3-geo/src/interpolate.js
-function interpolate_default2(a4, b) {
-    var x06 = a4[0] * radians2,
-        y06 = a4[1] * radians2,
-        x12 = b[0] * radians2,
-        y12 = b[1] * radians2,
-        cy0 = cos2(y06),
-        sy0 = sin2(y06),
-        cy1 = cos2(y12),
-        sy1 = sin2(y12),
-        kx0 = cy0 * cos2(x06),
-        ky0 = cy0 * sin2(x06),
-        kx1 = cy1 * cos2(x12),
-        ky1 = cy1 * sin2(x12),
-        d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))),
-        k2 = sin2(d);
+// js/pyobsplot-js/node_modules/d3-geo/src/interpolate.js
+function interpolate_default4(a7, b) {
+    var x011 = a7[0] * radians5,
+        y011 = a7[1] * radians5,
+        x13 = b[0] * radians5,
+        y13 = b[1] * radians5,
+        cy0 = cos5(y011),
+        sy0 = sin5(y011),
+        cy1 = cos5(y13),
+        sy1 = sin5(y13),
+        kx0 = cy0 * cos5(x011),
+        ky0 = cy0 * sin5(x011),
+        kx1 = cy1 * cos5(x13),
+        ky1 = cy1 * sin5(x13),
+        d = 2 * asin3(sqrt4(haversin2(y13 - y011) + cy0 * cy1 * haversin2(x13 - x011))),
+        k3 = sin5(d);
     var interpolate = d ? function(t) {
-        var B3 = sin2(t *= d) / k2,
-            A5 = sin2(d - t) / k2,
-            x4 = A5 * kx0 + B3 * kx1,
-            y4 = A5 * ky0 + B3 * ky1,
-            z = A5 * sy0 + B3 * sy1;
+        var B5 = sin5(t *= d) / k3,
+            A6 = sin5(d - t) / k3,
+            x7 = A6 * kx0 + B5 * kx1,
+            y7 = A6 * ky0 + B5 * ky1,
+            z = A6 * sy0 + B5 * sy1;
         return [
-            atan2(y4, x4) * degrees3,
-            atan2(z, sqrt(x4 * x4 + y4 * y4)) * degrees3
+            atan23(y7, x7) * degrees6,
+            atan23(z, sqrt4(x7 * x7 + y7 * y7)) * degrees6
         ];
     } : function() {
-        return [x06 * degrees3, y06 * degrees3];
+        return [x011 * degrees6, y011 * degrees6];
     };
     interpolate.distance = d;
     return interpolate;
 }
 
-// node_modules/d3-geo/src/identity.js
-var identity_default3 = (x4) => x4;
+// js/pyobsplot-js/node_modules/d3-geo/src/identity.js
+var identity_default8 = (x7) => x7;
 
-// node_modules/d3-geo/src/path/area.js
-var areaSum2 = new Adder();
-var areaRingSum2 = new Adder();
-var x00;
-var y00;
-var x02;
-var y02;
-var areaStream2 = {
-    point: noop2,
-    lineStart: noop2,
-    lineEnd: noop2,
+// js/pyobsplot-js/node_modules/d3-geo/src/path/area.js
+var areaSum4 = new Adder2();
+var areaRingSum4 = new Adder2();
+var x004;
+var y004;
+var x07;
+var y07;
+var areaStream4 = {
+    point: noop4,
+    lineStart: noop4,
+    lineEnd: noop4,
     polygonStart: function() {
-        areaStream2.lineStart = areaRingStart2;
-        areaStream2.lineEnd = areaRingEnd2;
+        areaStream4.lineStart = areaRingStart4;
+        areaStream4.lineEnd = areaRingEnd4;
     },
     polygonEnd: function() {
-        areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
-        areaSum2.add(abs3(areaRingSum2));
-        areaRingSum2 = new Adder();
+        areaStream4.lineStart = areaStream4.lineEnd = areaStream4.point = noop4;
+        areaSum4.add(abs7(areaRingSum4));
+        areaRingSum4 = new Adder2();
     },
     result: function() {
-        var area2 = areaSum2 / 2;
-        areaSum2 = new Adder();
-        return area2;
+        var area3 = areaSum4 / 2;
+        areaSum4 = new Adder2();
+        return area3;
     }
 };
 
-function areaRingStart2() {
-    areaStream2.point = areaPointFirst2;
+function areaRingStart4() {
+    areaStream4.point = areaPointFirst4;
 }
 
-function areaPointFirst2(x4, y4) {
-    areaStream2.point = areaPoint2;
-    x00 = x02 = x4, y00 = y02 = y4;
+function areaPointFirst4(x7, y7) {
+    areaStream4.point = areaPoint4;
+    x004 = x07 = x7, y004 = y07 = y7;
 }
 
-function areaPoint2(x4, y4) {
-    areaRingSum2.add(y02 * x4 - x02 * y4);
-    x02 = x4, y02 = y4;
+function areaPoint4(x7, y7) {
+    areaRingSum4.add(y07 * x7 - x07 * y7);
+    x07 = x7, y07 = y7;
 }
 
-function areaRingEnd2() {
-    areaPoint2(x00, y00);
+function areaRingEnd4() {
+    areaPoint4(x004, y004);
 }
-var area_default3 = areaStream2;
+var area_default8 = areaStream4;
 
-// node_modules/d3-geo/src/path/bounds.js
-var x03 = Infinity;
-var y03 = x03;
-var x1 = -x03;
-var y1 = x1;
-var boundsStream2 = {
-    point: boundsPoint2,
-    lineStart: noop2,
-    lineEnd: noop2,
-    polygonStart: noop2,
-    polygonEnd: noop2,
+// js/pyobsplot-js/node_modules/d3-geo/src/path/bounds.js
+var x08 = Infinity;
+var y08 = x08;
+var x12 = -x08;
+var y12 = x12;
+var boundsStream4 = {
+    point: boundsPoint4,
+    lineStart: noop4,
+    lineEnd: noop4,
+    polygonStart: noop4,
+    polygonEnd: noop4,
     result: function() {
         var bounds = [
-            [x03, y03],
-            [x1, y1]
+            [x08, y08],
+            [x12, y12]
         ];
-        x1 = y1 = -(y03 = x03 = Infinity);
+        x12 = y12 = -(y08 = x08 = Infinity);
         return bounds;
     }
 };
 
-function boundsPoint2(x4, y4) {
-    if (x4 < x03)
-        x03 = x4;
-    if (x4 > x1)
-        x1 = x4;
-    if (y4 < y03)
-        y03 = y4;
-    if (y4 > y1)
-        y1 = y4;
-}
-var bounds_default2 = boundsStream2;
-
-// node_modules/d3-geo/src/path/centroid.js
-var X02 = 0;
-var Y02 = 0;
-var Z02 = 0;
-var X12 = 0;
-var Y12 = 0;
-var Z12 = 0;
-var X22 = 0;
-var Y22 = 0;
-var Z22 = 0;
-var x002;
-var y002;
-var x04;
-var y04;
-var centroidStream2 = {
-    point: centroidPoint2,
-    lineStart: centroidLineStart2,
-    lineEnd: centroidLineEnd2,
+function boundsPoint4(x7, y7) {
+    if (x7 < x08)
+        x08 = x7;
+    if (x7 > x12)
+        x12 = x7;
+    if (y7 < y08)
+        y08 = y7;
+    if (y7 > y12)
+        y12 = y7;
+}
+var bounds_default4 = boundsStream4;
+
+// js/pyobsplot-js/node_modules/d3-geo/src/path/centroid.js
+var X04 = 0;
+var Y04 = 0;
+var Z04 = 0;
+var X14 = 0;
+var Y14 = 0;
+var Z14 = 0;
+var X24 = 0;
+var Y24 = 0;
+var Z24 = 0;
+var x005;
+var y005;
+var x09;
+var y09;
+var centroidStream4 = {
+    point: centroidPoint4,
+    lineStart: centroidLineStart4,
+    lineEnd: centroidLineEnd4,
     polygonStart: function() {
-        centroidStream2.lineStart = centroidRingStart2;
-        centroidStream2.lineEnd = centroidRingEnd2;
+        centroidStream4.lineStart = centroidRingStart4;
+        centroidStream4.lineEnd = centroidRingEnd4;
     },
     polygonEnd: function() {
-        centroidStream2.point = centroidPoint2;
-        centroidStream2.lineStart = centroidLineStart2;
-        centroidStream2.lineEnd = centroidLineEnd2;
+        centroidStream4.point = centroidPoint4;
+        centroidStream4.lineStart = centroidLineStart4;
+        centroidStream4.lineEnd = centroidLineEnd4;
     },
     result: function() {
-        var centroid2 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
-        X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
-        return centroid2;
+        var centroid3 = Z24 ? [X24 / Z24, Y24 / Z24] : Z14 ? [X14 / Z14, Y14 / Z14] : Z04 ? [X04 / Z04, Y04 / Z04] : [NaN, NaN];
+        X04 = Y04 = Z04 = X14 = Y14 = Z14 = X24 = Y24 = Z24 = 0;
+        return centroid3;
     }
 };
 
-function centroidPoint2(x4, y4) {
-    X02 += x4;
-    Y02 += y4;
-    ++Z02;
+function centroidPoint4(x7, y7) {
+    X04 += x7;
+    Y04 += y7;
+    ++Z04;
 }
 
-function centroidLineStart2() {
-    centroidStream2.point = centroidPointFirstLine;
+function centroidLineStart4() {
+    centroidStream4.point = centroidPointFirstLine2;
 }
 
-function centroidPointFirstLine(x4, y4) {
-    centroidStream2.point = centroidPointLine;
-    centroidPoint2(x04 = x4, y04 = y4);
+function centroidPointFirstLine2(x7, y7) {
+    centroidStream4.point = centroidPointLine2;
+    centroidPoint4(x09 = x7, y09 = y7);
 }
 
-function centroidPointLine(x4, y4) {
-    var dx = x4 - x04,
-        dy = y4 - y04,
-        z = sqrt(dx * dx + dy * dy);
-    X12 += z * (x04 + x4) / 2;
-    Y12 += z * (y04 + y4) / 2;
-    Z12 += z;
-    centroidPoint2(x04 = x4, y04 = y4);
+function centroidPointLine2(x7, y7) {
+    var dx = x7 - x09,
+        dy = y7 - y09,
+        z = sqrt4(dx * dx + dy * dy);
+    X14 += z * (x09 + x7) / 2;
+    Y14 += z * (y09 + y7) / 2;
+    Z14 += z;
+    centroidPoint4(x09 = x7, y09 = y7);
 }
 
-function centroidLineEnd2() {
-    centroidStream2.point = centroidPoint2;
+function centroidLineEnd4() {
+    centroidStream4.point = centroidPoint4;
 }
 
-function centroidRingStart2() {
-    centroidStream2.point = centroidPointFirstRing;
+function centroidRingStart4() {
+    centroidStream4.point = centroidPointFirstRing2;
 }
 
-function centroidRingEnd2() {
-    centroidPointRing(x002, y002);
+function centroidRingEnd4() {
+    centroidPointRing2(x005, y005);
 }
 
-function centroidPointFirstRing(x4, y4) {
-    centroidStream2.point = centroidPointRing;
-    centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);
+function centroidPointFirstRing2(x7, y7) {
+    centroidStream4.point = centroidPointRing2;
+    centroidPoint4(x005 = x09 = x7, y005 = y09 = y7);
 }
 
-function centroidPointRing(x4, y4) {
-    var dx = x4 - x04,
-        dy = y4 - y04,
-        z = sqrt(dx * dx + dy * dy);
-    X12 += z * (x04 + x4) / 2;
-    Y12 += z * (y04 + y4) / 2;
-    Z12 += z;
-    z = y04 * x4 - x04 * y4;
-    X22 += z * (x04 + x4);
-    Y22 += z * (y04 + y4);
-    Z22 += z * 3;
-    centroidPoint2(x04 = x4, y04 = y4);
+function centroidPointRing2(x7, y7) {
+    var dx = x7 - x09,
+        dy = y7 - y09,
+        z = sqrt4(dx * dx + dy * dy);
+    X14 += z * (x09 + x7) / 2;
+    Y14 += z * (y09 + y7) / 2;
+    Z14 += z;
+    z = y09 * x7 - x09 * y7;
+    X24 += z * (x09 + x7);
+    Y24 += z * (y09 + y7);
+    Z24 += z * 3;
+    centroidPoint4(x09 = x7, y09 = y7);
 }
-var centroid_default2 = centroidStream2;
+var centroid_default5 = centroidStream4;
 
-// node_modules/d3-geo/src/path/context.js
-function PathContext(context) {
+// js/pyobsplot-js/node_modules/d3-geo/src/path/context.js
+function PathContext2(context) {
     this._context = context;
 }
-PathContext.prototype = {
+PathContext2.prototype = {
     _radius: 4.5,
     pointRadius: function(_) {
         return this._radius = _, this;
     },
     polygonStart: function() {
         this._line = 0;
     },
@@ -13451,85 +48157,85 @@
         this._point = 0;
     },
     lineEnd: function() {
         if (this._line === 0)
             this._context.closePath();
         this._point = NaN;
     },
-    point: function(x4, y4) {
+    point: function(x7, y7) {
         switch (this._point) {
             case 0: {
-                this._context.moveTo(x4, y4);
+                this._context.moveTo(x7, y7);
                 this._point = 1;
                 break;
             }
             case 1: {
-                this._context.lineTo(x4, y4);
+                this._context.lineTo(x7, y7);
                 break;
             }
             default: {
-                this._context.moveTo(x4 + this._radius, y4);
-                this._context.arc(x4, y4, this._radius, 0, tau5);
+                this._context.moveTo(x7 + this._radius, y7);
+                this._context.arc(x7, y7, this._radius, 0, tau12);
                 break;
             }
         }
     },
-    result: noop2
+    result: noop4
 };
 
-// node_modules/d3-geo/src/path/measure.js
-var lengthSum2 = new Adder();
-var lengthRing;
-var x003;
-var y003;
-var x05;
-var y05;
-var lengthStream2 = {
-    point: noop2,
+// js/pyobsplot-js/node_modules/d3-geo/src/path/measure.js
+var lengthSum4 = new Adder2();
+var lengthRing2;
+var x006;
+var y006;
+var x010;
+var y010;
+var lengthStream4 = {
+    point: noop4,
     lineStart: function() {
-        lengthStream2.point = lengthPointFirst2;
+        lengthStream4.point = lengthPointFirst4;
     },
     lineEnd: function() {
-        if (lengthRing)
-            lengthPoint2(x003, y003);
-        lengthStream2.point = noop2;
+        if (lengthRing2)
+            lengthPoint4(x006, y006);
+        lengthStream4.point = noop4;
     },
     polygonStart: function() {
-        lengthRing = true;
+        lengthRing2 = true;
     },
     polygonEnd: function() {
-        lengthRing = null;
+        lengthRing2 = null;
     },
     result: function() {
-        var length4 = +lengthSum2;
-        lengthSum2 = new Adder();
-        return length4;
+        var length7 = +lengthSum4;
+        lengthSum4 = new Adder2();
+        return length7;
     }
 };
 
-function lengthPointFirst2(x4, y4) {
-    lengthStream2.point = lengthPoint2;
-    x003 = x05 = x4, y003 = y05 = y4;
+function lengthPointFirst4(x7, y7) {
+    lengthStream4.point = lengthPoint4;
+    x006 = x010 = x7, y006 = y010 = y7;
 }
 
-function lengthPoint2(x4, y4) {
-    x05 -= x4, y05 -= y4;
-    lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
-    x05 = x4, y05 = y4;
+function lengthPoint4(x7, y7) {
+    x010 -= x7, y010 -= y7;
+    lengthSum4.add(sqrt4(x010 * x010 + y010 * y010));
+    x010 = x7, y010 = y7;
 }
-var measure_default = lengthStream2;
+var measure_default2 = lengthStream4;
 
-// node_modules/d3-geo/src/path/string.js
-var cacheDigits;
-var cacheAppend;
-var cacheRadius;
-var cacheCircle;
-var PathString = class {
+// js/pyobsplot-js/node_modules/d3-geo/src/path/string.js
+var cacheDigits2;
+var cacheAppend2;
+var cacheRadius2;
+var cacheCircle2;
+var PathString2 = class {
     constructor(digits) {
-        this._append = digits == null ? append2 : appendRound2(digits);
+        this._append = digits == null ? append4 : appendRound4(digits);
         this._radius = 4.5;
         this._ = "";
     }
     pointRadius(_) {
         this._radius = +_;
         return this;
     }
@@ -13543,167 +48249,167 @@
         this._point = 0;
     }
     lineEnd() {
         if (this._line === 0)
             this._ += "Z";
         this._point = NaN;
     }
-    point(x4, y4) {
+    point(x7, y7) {
         switch (this._point) {
             case 0: {
-                this._append`M${x4},${y4}`;
+                this._append`M${x7},${y7}`;
                 this._point = 1;
                 break;
             }
             case 1: {
-                this._append`L${x4},${y4}`;
+                this._append`L${x7},${y7}`;
                 break;
             }
             default: {
-                this._append`M${x4},${y4}`;
-                if (this._radius !== cacheRadius || this._append !== cacheAppend) {
+                this._append`M${x7},${y7}`;
+                if (this._radius !== cacheRadius2 || this._append !== cacheAppend2) {
                     const r = this._radius;
-                    const s2 = this._;
+                    const s3 = this._;
                     this._ = "";
                     this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
-                    cacheRadius = r;
-                    cacheAppend = this._append;
-                    cacheCircle = this._;
-                    this._ = s2;
+                    cacheRadius2 = r;
+                    cacheAppend2 = this._append;
+                    cacheCircle2 = this._;
+                    this._ = s3;
                 }
-                this._ += cacheCircle;
+                this._ += cacheCircle2;
                 break;
             }
         }
     }
     result() {
         const result = this._;
         this._ = "";
         return result.length ? result : null;
     }
 };
 
-function append2(strings) {
+function append4(strings) {
     let i = 1;
     this._ += strings[0];
     for (const j = strings.length; i < j; ++i) {
         this._ += arguments[i] + strings[i];
     }
 }
 
-function appendRound2(digits) {
+function appendRound4(digits) {
     const d = Math.floor(digits);
     if (!(d >= 0))
         throw new RangeError(`invalid digits: ${digits}`);
     if (d > 15)
-        return append2;
-    if (d !== cacheDigits) {
-        const k2 = 10 ** d;
-        cacheDigits = d;
-        cacheAppend = function append3(strings) {
+        return append4;
+    if (d !== cacheDigits2) {
+        const k3 = 10 ** d;
+        cacheDigits2 = d;
+        cacheAppend2 = function append5(strings) {
             let i = 1;
             this._ += strings[0];
             for (const j = strings.length; i < j; ++i) {
-                this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
+                this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
             }
         };
     }
-    return cacheAppend;
+    return cacheAppend2;
 }
 
-// node_modules/d3-geo/src/path/index.js
-function path_default(projection2, context) {
+// js/pyobsplot-js/node_modules/d3-geo/src/path/index.js
+function path_default3(projection3, context) {
     let digits = 3,
         pointRadius = 4.5,
         projectionStream, contextStream;
 
-    function path2(object2) {
-        if (object2) {
+    function path3(object3) {
+        if (object3) {
             if (typeof pointRadius === "function")
                 contextStream.pointRadius(+pointRadius.apply(this, arguments));
-            stream_default(object2, projectionStream(contextStream));
+            stream_default2(object3, projectionStream(contextStream));
         }
         return contextStream.result();
     }
-    path2.area = function(object2) {
-        stream_default(object2, projectionStream(area_default3));
-        return area_default3.result();
-    };
-    path2.measure = function(object2) {
-        stream_default(object2, projectionStream(measure_default));
-        return measure_default.result();
+    path3.area = function(object3) {
+        stream_default2(object3, projectionStream(area_default8));
+        return area_default8.result();
+    };
+    path3.measure = function(object3) {
+        stream_default2(object3, projectionStream(measure_default2));
+        return measure_default2.result();
+    };
+    path3.bounds = function(object3) {
+        stream_default2(object3, projectionStream(bounds_default4));
+        return bounds_default4.result();
+    };
+    path3.centroid = function(object3) {
+        stream_default2(object3, projectionStream(centroid_default5));
+        return centroid_default5.result();
     };
-    path2.bounds = function(object2) {
-        stream_default(object2, projectionStream(bounds_default2));
-        return bounds_default2.result();
-    };
-    path2.centroid = function(object2) {
-        stream_default(object2, projectionStream(centroid_default2));
-        return centroid_default2.result();
-    };
-    path2.projection = function(_) {
+    path3.projection = function(_) {
         if (!arguments.length)
-            return projection2;
-        projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream;
-        return path2;
+            return projection3;
+        projectionStream = _ == null ? (projection3 = null, identity_default8) : (projection3 = _).stream;
+        return path3;
     };
-    path2.context = function(_) {
+    path3.context = function(_) {
         if (!arguments.length)
             return context;
-        contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
+        contextStream = _ == null ? (context = null, new PathString2(digits)) : new PathContext2(context = _);
         if (typeof pointRadius !== "function")
             contextStream.pointRadius(pointRadius);
-        return path2;
+        return path3;
     };
-    path2.pointRadius = function(_) {
+    path3.pointRadius = function(_) {
         if (!arguments.length)
             return pointRadius;
         pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
-        return path2;
+        return path3;
     };
-    path2.digits = function(_) {
+    path3.digits = function(_) {
         if (!arguments.length)
             return digits;
         if (_ == null)
             digits = null;
         else {
             const d = Math.floor(_);
             if (!(d >= 0))
                 throw new RangeError(`invalid digits: ${_}`);
             digits = d;
         }
         if (context === null)
-            contextStream = new PathString(digits);
-        return path2;
+            contextStream = new PathString2(digits);
+        return path3;
     };
-    return path2.projection(projection2).digits(digits).context(context);
+    return path3.projection(projection3).digits(digits).context(context);
 }
 
-// node_modules/d3-geo/src/transform.js
-function transform_default(methods) {
+// js/pyobsplot-js/node_modules/d3-geo/src/transform.js
+function transform_default2(methods) {
     return {
-        stream: transformer(methods)
+        stream: transformer5(methods)
     };
 }
 
-function transformer(methods) {
+function transformer5(methods) {
     return function(stream) {
-        var s2 = new TransformStream();
+        var s3 = new TransformStream2();
         for (var key in methods)
-            s2[key] = methods[key];
-        s2.stream = stream;
-        return s2;
+            s3[key] = methods[key];
+        s3.stream = stream;
+        return s3;
     };
 }
 
-function TransformStream() {}
-TransformStream.prototype = {
-    constructor: TransformStream,
-    point: function(x4, y4) {
-        this.stream.point(x4, y4);
+function TransformStream2() {}
+TransformStream2.prototype = {
+    constructor: TransformStream2,
+    point: function(x7, y7) {
+        this.stream.point(x7, y7);
     },
     sphere: function() {
         this.stream.sphere();
     },
     lineStart: function() {
         this.stream.lineStart();
     },
@@ -13714,390 +48420,390 @@
         this.stream.polygonStart();
     },
     polygonEnd: function() {
         this.stream.polygonEnd();
     }
 };
 
-// node_modules/d3-geo/src/projection/fit.js
-function fit(projection2, fitBounds, object2) {
-    var clip = projection2.clipExtent && projection2.clipExtent();
-    projection2.scale(150).translate([0, 0]);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/fit.js
+function fit2(projection3, fitBounds, object3) {
+    var clip = projection3.clipExtent && projection3.clipExtent();
+    projection3.scale(150).translate([0, 0]);
     if (clip != null)
-        projection2.clipExtent(null);
-    stream_default(object2, projection2.stream(bounds_default2));
-    fitBounds(bounds_default2.result());
+        projection3.clipExtent(null);
+    stream_default2(object3, projection3.stream(bounds_default4));
+    fitBounds(bounds_default4.result());
     if (clip != null)
-        projection2.clipExtent(clip);
-    return projection2;
+        projection3.clipExtent(clip);
+    return projection3;
 }
 
-function fitExtent(projection2, extent3, object2) {
-    return fit(projection2, function(b) {
-        var w = extent3[1][0] - extent3[0][0],
-            h = extent3[1][1] - extent3[0][1],
-            k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
-            x4 = +extent3[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2,
-            y4 = +extent3[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
-        projection2.scale(150 * k2).translate([x4, y4]);
-    }, object2);
+function fitExtent2(projection3, extent5, object3) {
+    return fit2(projection3, function(b) {
+        var w = extent5[1][0] - extent5[0][0],
+            h = extent5[1][1] - extent5[0][1],
+            k3 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
+            x7 = +extent5[0][0] + (w - k3 * (b[1][0] + b[0][0])) / 2,
+            y7 = +extent5[0][1] + (h - k3 * (b[1][1] + b[0][1])) / 2;
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
 }
 
-function fitSize(projection2, size, object2) {
-    return fitExtent(projection2, [
+function fitSize2(projection3, size, object3) {
+    return fitExtent2(projection3, [
         [0, 0], size
-    ], object2);
+    ], object3);
 }
 
-function fitWidth(projection2, width, object2) {
-    return fit(projection2, function(b) {
+function fitWidth2(projection3, width, object3) {
+    return fit2(projection3, function(b) {
         var w = +width,
-            k2 = w / (b[1][0] - b[0][0]),
-            x4 = (w - k2 * (b[1][0] + b[0][0])) / 2,
-            y4 = -k2 * b[0][1];
-        projection2.scale(150 * k2).translate([x4, y4]);
-    }, object2);
+            k3 = w / (b[1][0] - b[0][0]),
+            x7 = (w - k3 * (b[1][0] + b[0][0])) / 2,
+            y7 = -k3 * b[0][1];
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
 }
 
-function fitHeight(projection2, height, object2) {
-    return fit(projection2, function(b) {
+function fitHeight2(projection3, height, object3) {
+    return fit2(projection3, function(b) {
         var h = +height,
-            k2 = h / (b[1][1] - b[0][1]),
-            x4 = -k2 * b[0][0],
-            y4 = (h - k2 * (b[1][1] + b[0][1])) / 2;
-        projection2.scale(150 * k2).translate([x4, y4]);
-    }, object2);
-}
-
-// node_modules/d3-geo/src/projection/resample.js
-var maxDepth = 16;
-var cosMinDistance = cos2(30 * radians2);
-
-function resample_default(project2, delta2) {
-    return +delta2 ? resample(project2, delta2) : resampleNone(project2);
-}
-
-function resampleNone(project2) {
-    return transformer({
-        point: function(x4, y4) {
-            x4 = project2(x4, y4);
-            this.stream.point(x4[0], x4[1]);
+            k3 = h / (b[1][1] - b[0][1]),
+            x7 = -k3 * b[0][0],
+            y7 = (h - k3 * (b[1][1] + b[0][1])) / 2;
+        projection3.scale(150 * k3).translate([x7, y7]);
+    }, object3);
+}
+
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/resample.js
+var maxDepth2 = 16;
+var cosMinDistance2 = cos5(30 * radians5);
+
+function resample_default2(project3, delta2) {
+    return +delta2 ? resample2(project3, delta2) : resampleNone2(project3);
+}
+
+function resampleNone2(project3) {
+    return transformer5({
+        point: function(x7, y7) {
+            x7 = project3(x7, y7);
+            this.stream.point(x7[0], x7[1]);
         }
     });
 }
 
-function resample(project2, delta2) {
-    function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
-        var dx = x12 - x06,
-            dy = y12 - y06,
+function resample2(project3, delta2) {
+    function resampleLineTo(x011, y011, lambda07, a0, b03, c0, x13, y13, lambda13, a1, b13, c1, depth, stream) {
+        var dx = x13 - x011,
+            dy = y13 - y011,
             d2 = dx * dx + dy * dy;
         if (d2 > 4 * delta2 && depth--) {
-            var a4 = a0 + a1,
-                b = b02 + b12,
-                c6 = c0 + c1,
-                m3 = sqrt(a4 * a4 + b * b + c6 * c6),
-                phi2 = asin(c6 /= m3),
-                lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a4),
-                p = project2(lambda22, phi2),
+            var a7 = a0 + a1,
+                b = b03 + b13,
+                c11 = c0 + c1,
+                m5 = sqrt4(a7 * a7 + b * b + c11 * c11),
+                phi22 = asin3(c11 /= m5),
+                lambda23 = abs7(abs7(c11) - 1) < epsilon14 || abs7(lambda07 - lambda13) < epsilon14 ? (lambda07 + lambda13) / 2 : atan23(b, a7),
+                p = project3(lambda23, phi22),
                 x22 = p[0],
                 y22 = p[1],
-                dx2 = x22 - x06,
-                dy2 = y22 - y06,
+                dx2 = x22 - x011,
+                dy2 = y22 - y011,
                 dz = dy * dx2 - dx * dy2;
-            if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
-                resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m3, b /= m3, c6, depth, stream);
+            if (dz * dz / d2 > delta2 || abs7((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b03 * b13 + c0 * c1 < cosMinDistance2) {
+                resampleLineTo(x011, y011, lambda07, a0, b03, c0, x22, y22, lambda23, a7 /= m5, b /= m5, c11, depth, stream);
                 stream.point(x22, y22);
-                resampleLineTo(x22, y22, lambda22, a4, b, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);
+                resampleLineTo(x22, y22, lambda23, a7, b, c11, x13, y13, lambda13, a1, b13, c1, depth, stream);
             }
         }
     }
     return function(stream) {
-        var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;
+        var lambda007, x007, y007, a00, b00, c00, lambda07, x011, y011, a0, b03, c0;
         var resampleStream = {
-            point: point6,
+            point: point11,
             lineStart,
             lineEnd,
             polygonStart: function() {
                 stream.polygonStart();
                 resampleStream.lineStart = ringStart;
             },
             polygonEnd: function() {
                 stream.polygonEnd();
                 resampleStream.lineStart = lineStart;
             }
         };
 
-        function point6(x4, y4) {
-            x4 = project2(x4, y4);
-            stream.point(x4[0], x4[1]);
+        function point11(x7, y7) {
+            x7 = project3(x7, y7);
+            stream.point(x7[0], x7[1]);
         }
 
         function lineStart() {
-            x06 = NaN;
-            resampleStream.point = linePoint2;
+            x011 = NaN;
+            resampleStream.point = linePoint3;
             stream.lineStart();
         }
 
-        function linePoint2(lambda, phi2) {
-            var c6 = cartesian([lambda, phi2]),
-                p = project2(lambda, phi2);
-            resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);
-            stream.point(x06, y06);
+        function linePoint3(lambda, phi3) {
+            var c11 = cartesian2([lambda, phi3]),
+                p = project3(lambda, phi3);
+            resampleLineTo(x011, y011, lambda07, a0, b03, c0, x011 = p[0], y011 = p[1], lambda07 = lambda, a0 = c11[0], b03 = c11[1], c0 = c11[2], maxDepth2, stream);
+            stream.point(x011, y011);
         }
 
         function lineEnd() {
-            resampleStream.point = point6;
+            resampleStream.point = point11;
             stream.lineEnd();
         }
 
         function ringStart() {
             lineStart();
             resampleStream.point = ringPoint;
             resampleStream.lineEnd = ringEnd;
         }
 
-        function ringPoint(lambda, phi2) {
-            linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;
-            resampleStream.point = linePoint2;
+        function ringPoint(lambda, phi3) {
+            linePoint3(lambda007 = lambda, phi3), x007 = x011, y007 = y011, a00 = a0, b00 = b03, c00 = c0;
+            resampleStream.point = linePoint3;
         }
 
         function ringEnd() {
-            resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);
+            resampleLineTo(x011, y011, lambda07, a0, b03, c0, x007, y007, lambda007, a00, b00, c00, maxDepth2, stream);
             resampleStream.lineEnd = lineEnd;
             lineEnd();
         }
         return resampleStream;
     };
 }
 
-// node_modules/d3-geo/src/projection/index.js
-var transformRadians = transformer({
-    point: function(x4, y4) {
-        this.stream.point(x4 * radians2, y4 * radians2);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/index.js
+var transformRadians2 = transformer5({
+    point: function(x7, y7) {
+        this.stream.point(x7 * radians5, y7 * radians5);
     }
 });
 
-function transformRotate(rotate) {
-    return transformer({
-        point: function(x4, y4) {
-            var r = rotate(x4, y4);
+function transformRotate2(rotate) {
+    return transformer5({
+        point: function(x7, y7) {
+            var r = rotate(x7, y7);
             return this.stream.point(r[0], r[1]);
         }
     });
 }
 
-function scaleTranslate(k2, dx, dy, sx, sy) {
-    function transform2(x4, y4) {
-        x4 *= sx;
-        y4 *= sy;
-        return [dx + k2 * x4, dy - k2 * y4];
+function scaleTranslate2(k3, dx, dy, sx, sy) {
+    function transform3(x7, y7) {
+        x7 *= sx;
+        y7 *= sy;
+        return [dx + k3 * x7, dy - k3 * y7];
     }
-    transform2.invert = function(x4, y4) {
-        return [(x4 - dx) / k2 * sx, (dy - y4) / k2 * sy];
+    transform3.invert = function(x7, y7) {
+        return [(x7 - dx) / k3 * sx, (dy - y7) / k3 * sy];
     };
-    return transform2;
+    return transform3;
 }
 
-function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
+function scaleTranslateRotate2(k3, dx, dy, sx, sy, alpha) {
     if (!alpha)
-        return scaleTranslate(k2, dx, dy, sx, sy);
-    var cosAlpha = cos2(alpha),
-        sinAlpha = sin2(alpha),
-        a4 = cosAlpha * k2,
-        b = sinAlpha * k2,
-        ai = cosAlpha / k2,
-        bi = sinAlpha / k2,
-        ci = (sinAlpha * dy - cosAlpha * dx) / k2,
-        fi = (sinAlpha * dx + cosAlpha * dy) / k2;
-
-    function transform2(x4, y4) {
-        x4 *= sx;
-        y4 *= sy;
-        return [a4 * x4 - b * y4 + dx, dy - b * x4 - a4 * y4];
-    }
-    transform2.invert = function(x4, y4) {
-        return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
-    };
-    return transform2;
-}
-
-function projection(project2) {
-    return projectionMutator(function() {
-        return project2;
+        return scaleTranslate2(k3, dx, dy, sx, sy);
+    var cosAlpha = cos5(alpha),
+        sinAlpha = sin5(alpha),
+        a7 = cosAlpha * k3,
+        b = sinAlpha * k3,
+        ai = cosAlpha / k3,
+        bi = sinAlpha / k3,
+        ci = (sinAlpha * dy - cosAlpha * dx) / k3,
+        fi = (sinAlpha * dx + cosAlpha * dy) / k3;
+
+    function transform3(x7, y7) {
+        x7 *= sx;
+        y7 *= sy;
+        return [a7 * x7 - b * y7 + dx, dy - b * x7 - a7 * y7];
+    }
+    transform3.invert = function(x7, y7) {
+        return [sx * (ai * x7 - bi * y7 + ci), sy * (fi - bi * x7 - ai * y7)];
+    };
+    return transform3;
+}
+
+function projection2(project3) {
+    return projectionMutator2(function() {
+        return project3;
     })();
 }
 
-function projectionMutator(projectAt) {
-    var project2, k2 = 150,
-        x4 = 480,
-        y4 = 250,
+function projectionMutator2(projectAt) {
+    var project3, k3 = 150,
+        x7 = 480,
+        y7 = 250,
         lambda = 0,
-        phi2 = 0,
+        phi3 = 0,
         deltaLambda = 0,
         deltaPhi = 0,
         deltaGamma = 0,
         rotate, alpha = 0,
         sx = 1,
         sy = 1,
         theta = null,
-        preclip = antimeridian_default,
-        x06 = null,
-        y06, x12, y12, postclip = identity_default3,
+        preclip = antimeridian_default2,
+        x011 = null,
+        y011, x13, y13, postclip = identity_default8,
         delta2 = 0.5,
         projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
 
-    function projection2(point6) {
-        return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
+    function projection3(point11) {
+        return projectRotateTransform(point11[0] * radians5, point11[1] * radians5);
     }
 
-    function invert(point6) {
-        point6 = projectRotateTransform.invert(point6[0], point6[1]);
-        return point6 && [point6[0] * degrees3, point6[1] * degrees3];
+    function invert(point11) {
+        point11 = projectRotateTransform.invert(point11[0], point11[1]);
+        return point11 && [point11[0] * degrees6, point11[1] * degrees6];
     }
-    projection2.stream = function(stream) {
-        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
+    projection3.stream = function(stream) {
+        return cache && cacheStream === stream ? cache : cache = transformRadians2(transformRotate2(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
     };
-    projection2.preclip = function(_) {
+    projection3.preclip = function(_) {
         return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
     };
-    projection2.postclip = function(_) {
-        return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;
+    projection3.postclip = function(_) {
+        return arguments.length ? (postclip = _, x011 = y011 = x13 = y13 = null, reset()) : postclip;
     };
-    projection2.clipAngle = function(_) {
-        return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
+    projection3.clipAngle = function(_) {
+        return arguments.length ? (preclip = +_ ? circle_default5(theta = _ * radians5) : (theta = null, antimeridian_default2), reset()) : theta * degrees6;
     };
-    projection2.clipExtent = function(_) {
-        return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [
-            [x06, y06],
-            [x12, y12]
+    projection3.clipExtent = function(_) {
+        return arguments.length ? (postclip = _ == null ? (x011 = y011 = x13 = y13 = null, identity_default8) : clipRectangle2(x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
         ];
     };
-    projection2.scale = function(_) {
-        return arguments.length ? (k2 = +_, recenter()) : k2;
+    projection3.scale = function(_) {
+        return arguments.length ? (k3 = +_, recenter()) : k3;
     };
-    projection2.translate = function(_) {
-        return arguments.length ? (x4 = +_[0], y4 = +_[1], recenter()) : [x4, y4];
+    projection3.translate = function(_) {
+        return arguments.length ? (x7 = +_[0], y7 = +_[1], recenter()) : [x7, y7];
     };
-    projection2.center = function(_) {
-        return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
+    projection3.center = function(_) {
+        return arguments.length ? (lambda = _[0] % 360 * radians5, phi3 = _[1] % 360 * radians5, recenter()) : [lambda * degrees6, phi3 * degrees6];
     };
-    projection2.rotate = function(_) {
-        return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
+    projection3.rotate = function(_) {
+        return arguments.length ? (deltaLambda = _[0] % 360 * radians5, deltaPhi = _[1] % 360 * radians5, deltaGamma = _.length > 2 ? _[2] % 360 * radians5 : 0, recenter()) : [deltaLambda * degrees6, deltaPhi * degrees6, deltaGamma * degrees6];
     };
-    projection2.angle = function(_) {
-        return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
+    projection3.angle = function(_) {
+        return arguments.length ? (alpha = _ % 360 * radians5, recenter()) : alpha * degrees6;
     };
-    projection2.reflectX = function(_) {
+    projection3.reflectX = function(_) {
         return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
     };
-    projection2.reflectY = function(_) {
+    projection3.reflectY = function(_) {
         return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
     };
-    projection2.precision = function(_) {
-        return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
+    projection3.precision = function(_) {
+        return arguments.length ? (projectResample = resample_default2(projectTransform, delta2 = _ * _), reset()) : sqrt4(delta2);
     };
-    projection2.fitExtent = function(extent3, object2) {
-        return fitExtent(projection2, extent3, object2);
+    projection3.fitExtent = function(extent5, object3) {
+        return fitExtent2(projection3, extent5, object3);
     };
-    projection2.fitSize = function(size, object2) {
-        return fitSize(projection2, size, object2);
+    projection3.fitSize = function(size, object3) {
+        return fitSize2(projection3, size, object3);
     };
-    projection2.fitWidth = function(width, object2) {
-        return fitWidth(projection2, width, object2);
+    projection3.fitWidth = function(width, object3) {
+        return fitWidth2(projection3, width, object3);
     };
-    projection2.fitHeight = function(height, object2) {
-        return fitHeight(projection2, height, object2);
+    projection3.fitHeight = function(height, object3) {
+        return fitHeight2(projection3, height, object3);
     };
 
     function recenter() {
-        var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)),
-            transform2 = scaleTranslateRotate(k2, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
-        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
-        projectTransform = compose_default(project2, transform2);
-        projectRotateTransform = compose_default(rotate, projectTransform);
-        projectResample = resample_default(projectTransform, delta2);
+        var center3 = scaleTranslateRotate2(k3, 0, 0, sx, sy, alpha).apply(null, project3(lambda, phi3)),
+            transform3 = scaleTranslateRotate2(k3, x7 - center3[0], y7 - center3[1], sx, sy, alpha);
+        rotate = rotateRadians2(deltaLambda, deltaPhi, deltaGamma);
+        projectTransform = compose_default2(project3, transform3);
+        projectRotateTransform = compose_default2(rotate, projectTransform);
+        projectResample = resample_default2(projectTransform, delta2);
         return reset();
     }
 
     function reset() {
         cache = cacheStream = null;
-        return projection2;
+        return projection3;
     }
     return function() {
-        project2 = projectAt.apply(this, arguments);
-        projection2.invert = project2.invert && invert;
+        project3 = projectAt.apply(this, arguments);
+        projection3.invert = project3.invert && invert;
         return recenter();
     };
 }
 
-// node_modules/d3-geo/src/projection/conic.js
-function conicProjection(projectAt) {
-    var phi02 = 0,
-        phi12 = pi4 / 3,
-        m3 = projectionMutator(projectAt),
-        p = m3(phi02, phi12);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/conic.js
+function conicProjection3(projectAt) {
+    var phi03 = 0,
+        phi13 = pi10 / 3,
+        m5 = projectionMutator2(projectAt),
+        p = m5(phi03, phi13);
     p.parallels = function(_) {
-        return arguments.length ? m3(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
+        return arguments.length ? m5(phi03 = _[0] * radians5, phi13 = _[1] * radians5) : [phi03 * degrees6, phi13 * degrees6];
     };
     return p;
 }
 
-// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
-function cylindricalEqualAreaRaw(phi02) {
-    var cosPhi03 = cos2(phi02);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
+function cylindricalEqualAreaRaw2(phi03) {
+    var cosPhi05 = cos5(phi03);
 
-    function forward(lambda, phi2) {
-        return [lambda * cosPhi03, sin2(phi2) / cosPhi03];
+    function forward(lambda, phi3) {
+        return [lambda * cosPhi05, sin5(phi3) / cosPhi05];
     }
-    forward.invert = function(x4, y4) {
-        return [x4 / cosPhi03, asin(y4 * cosPhi03)];
+    forward.invert = function(x7, y7) {
+        return [x7 / cosPhi05, asin3(y7 * cosPhi05)];
     };
     return forward;
 }
 
-// node_modules/d3-geo/src/projection/conicEqualArea.js
-function conicEqualAreaRaw(y06, y12) {
-    var sy0 = sin2(y06),
-        n = (sy0 + sin2(y12)) / 2;
-    if (abs3(n) < epsilon7)
-        return cylindricalEqualAreaRaw(y06);
-    var c6 = 1 + sy0 * (2 * n - sy0),
-        r0 = sqrt(c6) / n;
-
-    function project2(x4, y4) {
-        var r = sqrt(c6 - 2 * n * sin2(y4)) / n;
-        return [r * sin2(x4 *= n), r0 - r * cos2(x4)];
-    }
-    project2.invert = function(x4, y4) {
-        var r0y = r0 - y4,
-            l = atan2(x4, abs3(r0y)) * sign(r0y);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/conicEqualArea.js
+function conicEqualAreaRaw2(y011, y13) {
+    var sy0 = sin5(y011),
+        n = (sy0 + sin5(y13)) / 2;
+    if (abs7(n) < epsilon14)
+        return cylindricalEqualAreaRaw2(y011);
+    var c11 = 1 + sy0 * (2 * n - sy0),
+        r0 = sqrt4(c11) / n;
+
+    function project3(x7, y7) {
+        var r = sqrt4(c11 - 2 * n * sin5(y7)) / n;
+        return [r * sin5(x7 *= n), r0 - r * cos5(x7)];
+    }
+    project3.invert = function(x7, y7) {
+        var r0y = r0 - y7,
+            l = atan23(x7, abs7(r0y)) * sign3(r0y);
         if (r0y * n < 0)
-            l -= pi4 * sign(x4) * sign(r0y);
-        return [l / n, asin((c6 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];
+            l -= pi10 * sign3(x7) * sign3(r0y);
+        return [l / n, asin3((c11 - (x7 * x7 + r0y * r0y) * n * n) / (2 * n))];
     };
-    return project2;
+    return project3;
 }
 
-function conicEqualArea_default() {
-    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
+function conicEqualArea_default2() {
+    return conicProjection3(conicEqualAreaRaw2).scale(155.424).center([0, 33.6442]);
 }
 
-// node_modules/d3-geo/src/projection/albers.js
-function albers_default() {
-    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/albers.js
+function albers_default2() {
+    return conicEqualArea_default2().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
 }
 
-// node_modules/d3-geo/src/projection/albersUsa.js
-function multiplex(streams) {
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/albersUsa.js
+function multiplex2(streams) {
     var n = streams.length;
     return {
-        point: function(x4, y4) {
+        point: function(x7, y7) {
             var i = -1;
             while (++i < n)
-                streams[i].point(x4, y4);
+                streams[i].point(x7, y7);
         },
         sphere: function() {
             var i = -1;
             while (++i < n)
                 streams[i].sphere();
         },
         lineStart: function() {
@@ -14119,38 +48825,38 @@
             var i = -1;
             while (++i < n)
                 streams[i].polygonEnd();
         }
     };
 }
 
-function albersUsa_default() {
-    var cache, cacheStream, lower48 = albers_default(),
-        lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
-        alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
-        hawaiiPoint, point6, pointStream = {
-            point: function(x4, y4) {
-                point6 = [x4, y4];
+function albersUsa_default2() {
+    var cache, cacheStream, lower48 = albers_default2(),
+        lower48Point, alaska = conicEqualArea_default2().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+        alaskaPoint, hawaii = conicEqualArea_default2().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+        hawaiiPoint, point11, pointStream = {
+            point: function(x7, y7) {
+                point11 = [x7, y7];
             }
         };
 
-    function albersUsa(coordinates2) {
-        var x4 = coordinates2[0],
-            y4 = coordinates2[1];
-        return point6 = null, (lower48Point.point(x4, y4), point6) || (alaskaPoint.point(x4, y4), point6) || (hawaiiPoint.point(x4, y4), point6);
+    function albersUsa(coordinates3) {
+        var x7 = coordinates3[0],
+            y7 = coordinates3[1];
+        return point11 = null, (lower48Point.point(x7, y7), point11) || (alaskaPoint.point(x7, y7), point11) || (hawaiiPoint.point(x7, y7), point11);
     }
-    albersUsa.invert = function(coordinates2) {
-        var k2 = lower48.scale(),
+    albersUsa.invert = function(coordinates3) {
+        var k3 = lower48.scale(),
             t = lower48.translate(),
-            x4 = (coordinates2[0] - t[0]) / k2,
-            y4 = (coordinates2[1] - t[1]) / k2;
-        return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);
+            x7 = (coordinates3[0] - t[0]) / k3,
+            y7 = (coordinates3[1] - t[1]) / k3;
+        return (y7 >= 0.12 && y7 < 0.234 && x7 >= -0.425 && x7 < -0.214 ? alaska : y7 >= 0.166 && y7 < 0.234 && x7 >= -0.214 && x7 < -0.115 ? hawaii : lower48).invert(coordinates3);
     };
     albersUsa.stream = function(stream) {
-        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
+        return cache && cacheStream === stream ? cache : cache = multiplex2([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
     };
     albersUsa.precision = function(_) {
         if (!arguments.length)
             return lower48.precision();
         lower48.precision(_), alaska.precision(_), hawaii.precision(_);
         return reset();
     };
@@ -14159,1552 +48865,1552 @@
             return lower48.scale();
         lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
         return albersUsa.translate(lower48.translate());
     };
     albersUsa.translate = function(_) {
         if (!arguments.length)
             return lower48.translate();
-        var k2 = lower48.scale(),
-            x4 = +_[0],
-            y4 = +_[1];
+        var k3 = lower48.scale(),
+            x7 = +_[0],
+            y7 = +_[1];
         lower48Point = lower48.translate(_).clipExtent([
-            [x4 - 0.455 * k2, y4 - 0.238 * k2],
-            [x4 + 0.455 * k2, y4 + 0.238 * k2]
+            [x7 - 0.455 * k3, y7 - 0.238 * k3],
+            [x7 + 0.455 * k3, y7 + 0.238 * k3]
         ]).stream(pointStream);
-        alaskaPoint = alaska.translate([x4 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([
-            [x4 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7],
-            [x4 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]
+        alaskaPoint = alaska.translate([x7 - 0.307 * k3, y7 + 0.201 * k3]).clipExtent([
+            [x7 - 0.425 * k3 + epsilon14, y7 + 0.12 * k3 + epsilon14],
+            [x7 - 0.214 * k3 - epsilon14, y7 + 0.234 * k3 - epsilon14]
         ]).stream(pointStream);
-        hawaiiPoint = hawaii.translate([x4 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([
-            [x4 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7],
-            [x4 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]
+        hawaiiPoint = hawaii.translate([x7 - 0.205 * k3, y7 + 0.212 * k3]).clipExtent([
+            [x7 - 0.214 * k3 + epsilon14, y7 + 0.166 * k3 + epsilon14],
+            [x7 - 0.115 * k3 - epsilon14, y7 + 0.234 * k3 - epsilon14]
         ]).stream(pointStream);
         return reset();
     };
-    albersUsa.fitExtent = function(extent3, object2) {
-        return fitExtent(albersUsa, extent3, object2);
+    albersUsa.fitExtent = function(extent5, object3) {
+        return fitExtent2(albersUsa, extent5, object3);
     };
-    albersUsa.fitSize = function(size, object2) {
-        return fitSize(albersUsa, size, object2);
+    albersUsa.fitSize = function(size, object3) {
+        return fitSize2(albersUsa, size, object3);
     };
-    albersUsa.fitWidth = function(width, object2) {
-        return fitWidth(albersUsa, width, object2);
+    albersUsa.fitWidth = function(width, object3) {
+        return fitWidth2(albersUsa, width, object3);
     };
-    albersUsa.fitHeight = function(height, object2) {
-        return fitHeight(albersUsa, height, object2);
+    albersUsa.fitHeight = function(height, object3) {
+        return fitHeight2(albersUsa, height, object3);
     };
 
     function reset() {
         cache = cacheStream = null;
         return albersUsa;
     }
     return albersUsa.scale(1070);
 }
 
-// node_modules/d3-geo/src/projection/azimuthal.js
-function azimuthalRaw(scale3) {
-    return function(x4, y4) {
-        var cx = cos2(x4),
-            cy = cos2(y4),
-            k2 = scale3(cx * cy);
-        if (k2 === Infinity)
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/azimuthal.js
+function azimuthalRaw2(scale5) {
+    return function(x7, y7) {
+        var cx = cos5(x7),
+            cy = cos5(y7),
+            k3 = scale5(cx * cy);
+        if (k3 === Infinity)
             return [2, 0];
         return [
-            k2 * cy * sin2(x4),
-            k2 * sin2(y4)
+            k3 * cy * sin5(x7),
+            k3 * sin5(y7)
         ];
     };
 }
 
-function azimuthalInvert(angle2) {
-    return function(x4, y4) {
-        var z = sqrt(x4 * x4 + y4 * y4),
-            c6 = angle2(z),
-            sc = sin2(c6),
-            cc2 = cos2(c6);
+function azimuthalInvert2(angle3) {
+    return function(x7, y7) {
+        var z = sqrt4(x7 * x7 + y7 * y7),
+            c11 = angle3(z),
+            sc = sin5(c11),
+            cc3 = cos5(c11);
         return [
-            atan2(x4 * sc, z * cc2),
-            asin(z && y4 * sc / z)
+            atan23(x7 * sc, z * cc3),
+            asin3(z && y7 * sc / z)
         ];
     };
 }
 
-// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
-var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
-    return sqrt(2 / (1 + cxcy));
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
+var azimuthalEqualAreaRaw2 = azimuthalRaw2(function(cxcy) {
+    return sqrt4(2 / (1 + cxcy));
 });
-azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
-    return 2 * asin(z / 2);
+azimuthalEqualAreaRaw2.invert = azimuthalInvert2(function(z) {
+    return 2 * asin3(z / 2);
 });
 
-function azimuthalEqualArea_default() {
-    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
+function azimuthalEqualArea_default2() {
+    return projection2(azimuthalEqualAreaRaw2).scale(124.75).clipAngle(180 - 1e-3);
 }
 
-// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
-var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
-    return (c6 = acos(c6)) && c6 / sin2(c6);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
+var azimuthalEquidistantRaw2 = azimuthalRaw2(function(c11) {
+    return (c11 = acos3(c11)) && c11 / sin5(c11);
 });
-azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
+azimuthalEquidistantRaw2.invert = azimuthalInvert2(function(z) {
     return z;
 });
 
-function azimuthalEquidistant_default() {
-    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
+function azimuthalEquidistant_default2() {
+    return projection2(azimuthalEquidistantRaw2).scale(79.4188).clipAngle(180 - 1e-3);
 }
 
-// node_modules/d3-geo/src/projection/mercator.js
-function mercatorRaw(lambda, phi2) {
-    return [lambda, log(tan((halfPi3 + phi2) / 2))];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/mercator.js
+function mercatorRaw2(lambda, phi3) {
+    return [lambda, log3(tan2((halfPi7 + phi3) / 2))];
 }
-mercatorRaw.invert = function(x4, y4) {
-    return [x4, 2 * atan(exp(y4)) - halfPi3];
+mercatorRaw2.invert = function(x7, y7) {
+    return [x7, 2 * atan3(exp2(y7)) - halfPi7];
 };
 
-function mercator_default() {
-    return mercatorProjection(mercatorRaw).scale(961 / tau5);
+function mercator_default2() {
+    return mercatorProjection2(mercatorRaw2).scale(961 / tau12);
 }
 
-function mercatorProjection(project2) {
-    var m3 = projection(project2),
-        center2 = m3.center,
-        scale3 = m3.scale,
-        translate = m3.translate,
-        clipExtent = m3.clipExtent,
-        x06 = null,
-        y06, x12, y12;
-    m3.scale = function(_) {
-        return arguments.length ? (scale3(_), reclip()) : scale3();
+function mercatorProjection2(project3) {
+    var m5 = projection2(project3),
+        center3 = m5.center,
+        scale5 = m5.scale,
+        translate = m5.translate,
+        clipExtent = m5.clipExtent,
+        x011 = null,
+        y011, x13, y13;
+    m5.scale = function(_) {
+        return arguments.length ? (scale5(_), reclip()) : scale5();
     };
-    m3.translate = function(_) {
+    m5.translate = function(_) {
         return arguments.length ? (translate(_), reclip()) : translate();
     };
-    m3.center = function(_) {
-        return arguments.length ? (center2(_), reclip()) : center2();
+    m5.center = function(_) {
+        return arguments.length ? (center3(_), reclip()) : center3();
     };
-    m3.clipExtent = function(_) {
-        return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [
-            [x06, y06],
-            [x12, y12]
+    m5.clipExtent = function(_) {
+        return arguments.length ? (_ == null ? x011 = y011 = x13 = y13 = null : (x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reclip()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
         ];
     };
 
     function reclip() {
-        var k2 = pi4 * scale3(),
-            t = m3(rotation_default(m3.rotate()).invert([0, 0]));
-        return clipExtent(x06 == null ? [
-            [t[0] - k2, t[1] - k2],
-            [t[0] + k2, t[1] + k2]
-        ] : project2 === mercatorRaw ? [
-            [Math.max(t[0] - k2, x06), y06],
-            [Math.min(t[0] + k2, x12), y12]
+        var k3 = pi10 * scale5(),
+            t = m5(rotation_default2(m5.rotate()).invert([0, 0]));
+        return clipExtent(x011 == null ? [
+            [t[0] - k3, t[1] - k3],
+            [t[0] + k3, t[1] + k3]
+        ] : project3 === mercatorRaw2 ? [
+            [Math.max(t[0] - k3, x011), y011],
+            [Math.min(t[0] + k3, x13), y13]
         ] : [
-            [x06, Math.max(t[1] - k2, y06)],
-            [x12, Math.min(t[1] + k2, y12)]
+            [x011, Math.max(t[1] - k3, y011)],
+            [x13, Math.min(t[1] + k3, y13)]
         ]);
     }
     return reclip();
 }
 
-// node_modules/d3-geo/src/projection/conicConformal.js
-function tany(y4) {
-    return tan((halfPi3 + y4) / 2);
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/conicConformal.js
+function tany2(y7) {
+    return tan2((halfPi7 + y7) / 2);
 }
 
-function conicConformalRaw(y06, y12) {
-    var cy0 = cos2(y06),
-        n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)),
-        f = cy0 * pow2(tany(y06), n) / n;
+function conicConformalRaw2(y011, y13) {
+    var cy0 = cos5(y011),
+        n = y011 === y13 ? sin5(y011) : log3(cy0 / cos5(y13)) / log3(tany2(y13) / tany2(y011)),
+        f = cy0 * pow5(tany2(y011), n) / n;
     if (!n)
-        return mercatorRaw;
+        return mercatorRaw2;
 
-    function project2(x4, y4) {
+    function project3(x7, y7) {
         if (f > 0) {
-            if (y4 < -halfPi3 + epsilon7)
-                y4 = -halfPi3 + epsilon7;
+            if (y7 < -halfPi7 + epsilon14)
+                y7 = -halfPi7 + epsilon14;
         } else {
-            if (y4 > halfPi3 - epsilon7)
-                y4 = halfPi3 - epsilon7;
+            if (y7 > halfPi7 - epsilon14)
+                y7 = halfPi7 - epsilon14;
         }
-        var r = f / pow2(tany(y4), n);
-        return [r * sin2(n * x4), f - r * cos2(n * x4)];
+        var r = f / pow5(tany2(y7), n);
+        return [r * sin5(n * x7), f - r * cos5(n * x7)];
     }
-    project2.invert = function(x4, y4) {
-        var fy = f - y4,
-            r = sign(n) * sqrt(x4 * x4 + fy * fy),
-            l = atan2(x4, abs3(fy)) * sign(fy);
+    project3.invert = function(x7, y7) {
+        var fy = f - y7,
+            r = sign3(n) * sqrt4(x7 * x7 + fy * fy),
+            l = atan23(x7, abs7(fy)) * sign3(fy);
         if (fy * n < 0)
-            l -= pi4 * sign(x4) * sign(fy);
-        return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];
+            l -= pi10 * sign3(x7) * sign3(fy);
+        return [l / n, 2 * atan3(pow5(f / r, 1 / n)) - halfPi7];
     };
-    return project2;
+    return project3;
 }
 
-function conicConformal_default() {
-    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
+function conicConformal_default2() {
+    return conicProjection3(conicConformalRaw2).scale(109.5).parallels([30, 30]);
 }
 
-// node_modules/d3-geo/src/projection/equirectangular.js
-function equirectangularRaw(lambda, phi2) {
-    return [lambda, phi2];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/equirectangular.js
+function equirectangularRaw2(lambda, phi3) {
+    return [lambda, phi3];
 }
-equirectangularRaw.invert = equirectangularRaw;
+equirectangularRaw2.invert = equirectangularRaw2;
 
-function equirectangular_default() {
-    return projection(equirectangularRaw).scale(152.63);
+function equirectangular_default2() {
+    return projection2(equirectangularRaw2).scale(152.63);
 }
 
-// node_modules/d3-geo/src/projection/conicEquidistant.js
-function conicEquidistantRaw(y06, y12) {
-    var cy0 = cos2(y06),
-        n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06),
-        g = cy0 / n + y06;
-    if (abs3(n) < epsilon7)
-        return equirectangularRaw;
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/conicEquidistant.js
+function conicEquidistantRaw2(y011, y13) {
+    var cy0 = cos5(y011),
+        n = y011 === y13 ? sin5(y011) : (cy0 - cos5(y13)) / (y13 - y011),
+        g = cy0 / n + y011;
+    if (abs7(n) < epsilon14)
+        return equirectangularRaw2;
 
-    function project2(x4, y4) {
-        var gy = g - y4,
-            nx = n * x4;
-        return [gy * sin2(nx), g - gy * cos2(nx)];
+    function project3(x7, y7) {
+        var gy = g - y7,
+            nx = n * x7;
+        return [gy * sin5(nx), g - gy * cos5(nx)];
     }
-    project2.invert = function(x4, y4) {
-        var gy = g - y4,
-            l = atan2(x4, abs3(gy)) * sign(gy);
+    project3.invert = function(x7, y7) {
+        var gy = g - y7,
+            l = atan23(x7, abs7(gy)) * sign3(gy);
         if (gy * n < 0)
-            l -= pi4 * sign(x4) * sign(gy);
-        return [l / n, g - sign(n) * sqrt(x4 * x4 + gy * gy)];
+            l -= pi10 * sign3(x7) * sign3(gy);
+        return [l / n, g - sign3(n) * sqrt4(x7 * x7 + gy * gy)];
     };
-    return project2;
+    return project3;
 }
 
-function conicEquidistant_default() {
-    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
+function conicEquidistant_default2() {
+    return conicProjection3(conicEquidistantRaw2).scale(131.154).center([0, 13.9389]);
 }
 
-// node_modules/d3-geo/src/projection/equalEarth.js
-var A1 = 1.340264;
-var A2 = -0.081106;
-var A3 = 893e-6;
-var A4 = 3796e-6;
-var M = sqrt(3) / 2;
-var iterations = 12;
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/equalEarth.js
+var A12 = 1.340264;
+var A22 = -0.081106;
+var A32 = 893e-6;
+var A42 = 3796e-6;
+var M2 = sqrt4(3) / 2;
+var iterations2 = 12;
 
-function equalEarthRaw(lambda, phi2) {
-    var l = asin(M * sin2(phi2)),
+function equalEarthRaw2(lambda, phi3) {
+    var l = asin3(M2 * sin5(phi3)),
         l2 = l * l,
         l6 = l2 * l2 * l2;
     return [
-        lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
-        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
+        lambda * cos5(l) / (M2 * (A12 + 3 * A22 * l2 + l6 * (7 * A32 + 9 * A42 * l2))),
+        l * (A12 + A22 * l2 + l6 * (A32 + A42 * l2))
     ];
 }
-equalEarthRaw.invert = function(x4, y4) {
-    var l = y4,
+equalEarthRaw2.invert = function(x7, y7) {
+    var l = y7,
         l2 = l * l,
         l6 = l2 * l2 * l2;
-    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
-        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;
-        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
+    for (var i = 0, delta, fy, fpy; i < iterations2; ++i) {
+        fy = l * (A12 + A22 * l2 + l6 * (A32 + A42 * l2)) - y7;
+        fpy = A12 + 3 * A22 * l2 + l6 * (7 * A32 + 9 * A42 * l2);
         l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
-        if (abs3(delta) < epsilon22)
+        if (abs7(delta) < epsilon24)
             break;
     }
     return [
-        M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
-        asin(sin2(l) / M)
+        M2 * x7 * (A12 + 3 * A22 * l2 + l6 * (7 * A32 + 9 * A42 * l2)) / cos5(l),
+        asin3(sin5(l) / M2)
     ];
 };
 
-function equalEarth_default() {
-    return projection(equalEarthRaw).scale(177.158);
+function equalEarth_default2() {
+    return projection2(equalEarthRaw2).scale(177.158);
 }
 
-// node_modules/d3-geo/src/projection/gnomonic.js
-function gnomonicRaw(x4, y4) {
-    var cy = cos2(y4),
-        k2 = cos2(x4) * cy;
-    return [cy * sin2(x4) / k2, sin2(y4) / k2];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/gnomonic.js
+function gnomonicRaw2(x7, y7) {
+    var cy = cos5(y7),
+        k3 = cos5(x7) * cy;
+    return [cy * sin5(x7) / k3, sin5(y7) / k3];
 }
-gnomonicRaw.invert = azimuthalInvert(atan);
+gnomonicRaw2.invert = azimuthalInvert2(atan3);
 
-function gnomonic_default() {
-    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
+function gnomonic_default2() {
+    return projection2(gnomonicRaw2).scale(144.049).clipAngle(60);
 }
 
-// node_modules/d3-geo/src/projection/identity.js
-function identity_default4() {
-    var k2 = 1,
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/identity.js
+function identity_default9() {
+    var k3 = 1,
         tx = 0,
         ty = 0,
         sx = 1,
         sy = 1,
         alpha = 0,
-        ca3, sa, x06 = null,
-        y06, x12, y12, kx2 = 1,
-        ky2 = 1,
-        transform2 = transformer({
-            point: function(x4, y4) {
-                var p = projection2([x4, y4]);
+        ca5, sa, x011 = null,
+        y011, x13, y13, kx3 = 1,
+        ky3 = 1,
+        transform3 = transformer5({
+            point: function(x7, y7) {
+                var p = projection3([x7, y7]);
                 this.stream.point(p[0], p[1]);
             }
         }),
-        postclip = identity_default3,
+        postclip = identity_default8,
         cache, cacheStream;
 
     function reset() {
-        kx2 = k2 * sx;
-        ky2 = k2 * sy;
+        kx3 = k3 * sx;
+        ky3 = k3 * sy;
         cache = cacheStream = null;
-        return projection2;
+        return projection3;
     }
 
-    function projection2(p) {
-        var x4 = p[0] * kx2,
-            y4 = p[1] * ky2;
+    function projection3(p) {
+        var x7 = p[0] * kx3,
+            y7 = p[1] * ky3;
         if (alpha) {
-            var t = y4 * ca3 - x4 * sa;
-            x4 = x4 * ca3 + y4 * sa;
-            y4 = t;
-        }
-        return [x4 + tx, y4 + ty];
-    }
-    projection2.invert = function(p) {
-        var x4 = p[0] - tx,
-            y4 = p[1] - ty;
+            var t = y7 * ca5 - x7 * sa;
+            x7 = x7 * ca5 + y7 * sa;
+            y7 = t;
+        }
+        return [x7 + tx, y7 + ty];
+    }
+    projection3.invert = function(p) {
+        var x7 = p[0] - tx,
+            y7 = p[1] - ty;
         if (alpha) {
-            var t = y4 * ca3 + x4 * sa;
-            x4 = x4 * ca3 - y4 * sa;
-            y4 = t;
-        }
-        return [x4 / kx2, y4 / ky2];
-    };
-    projection2.stream = function(stream) {
-        return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
-    };
-    projection2.postclip = function(_) {
-        return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;
-    };
-    projection2.clipExtent = function(_) {
-        return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [
-            [x06, y06],
-            [x12, y12]
+            var t = y7 * ca5 + x7 * sa;
+            x7 = x7 * ca5 - y7 * sa;
+            y7 = t;
+        }
+        return [x7 / kx3, y7 / ky3];
+    };
+    projection3.stream = function(stream) {
+        return cache && cacheStream === stream ? cache : cache = transform3(postclip(cacheStream = stream));
+    };
+    projection3.postclip = function(_) {
+        return arguments.length ? (postclip = _, x011 = y011 = x13 = y13 = null, reset()) : postclip;
+    };
+    projection3.clipExtent = function(_) {
+        return arguments.length ? (postclip = _ == null ? (x011 = y011 = x13 = y13 = null, identity_default8) : clipRectangle2(x011 = +_[0][0], y011 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset()) : x011 == null ? null : [
+            [x011, y011],
+            [x13, y13]
         ];
     };
-    projection2.scale = function(_) {
-        return arguments.length ? (k2 = +_, reset()) : k2;
+    projection3.scale = function(_) {
+        return arguments.length ? (k3 = +_, reset()) : k3;
     };
-    projection2.translate = function(_) {
+    projection3.translate = function(_) {
         return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
     };
-    projection2.angle = function(_) {
-        return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;
+    projection3.angle = function(_) {
+        return arguments.length ? (alpha = _ % 360 * radians5, sa = sin5(alpha), ca5 = cos5(alpha), reset()) : alpha * degrees6;
     };
-    projection2.reflectX = function(_) {
+    projection3.reflectX = function(_) {
         return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
     };
-    projection2.reflectY = function(_) {
+    projection3.reflectY = function(_) {
         return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
     };
-    projection2.fitExtent = function(extent3, object2) {
-        return fitExtent(projection2, extent3, object2);
+    projection3.fitExtent = function(extent5, object3) {
+        return fitExtent2(projection3, extent5, object3);
     };
-    projection2.fitSize = function(size, object2) {
-        return fitSize(projection2, size, object2);
+    projection3.fitSize = function(size, object3) {
+        return fitSize2(projection3, size, object3);
     };
-    projection2.fitWidth = function(width, object2) {
-        return fitWidth(projection2, width, object2);
+    projection3.fitWidth = function(width, object3) {
+        return fitWidth2(projection3, width, object3);
     };
-    projection2.fitHeight = function(height, object2) {
-        return fitHeight(projection2, height, object2);
+    projection3.fitHeight = function(height, object3) {
+        return fitHeight2(projection3, height, object3);
     };
-    return projection2;
+    return projection3;
 }
 
-// node_modules/d3-geo/src/projection/naturalEarth1.js
-function naturalEarth1Raw(lambda, phi2) {
-    var phi22 = phi2 * phi2,
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/naturalEarth1.js
+function naturalEarth1Raw2(lambda, phi3) {
+    var phi22 = phi3 * phi3,
         phi4 = phi22 * phi22;
     return [
         lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
-        phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
+        phi3 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
     ];
 }
-naturalEarth1Raw.invert = function(x4, y4) {
-    var phi2 = y4,
+naturalEarth1Raw2.invert = function(x7, y7) {
+    var phi3 = y7,
         i = 25,
         delta;
     do {
-        var phi22 = phi2 * phi2,
+        var phi22 = phi3 * phi3,
             phi4 = phi22 * phi22;
-        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
-    } while (abs3(delta) > epsilon7 && --i > 0);
+        phi3 -= delta = (phi3 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y7) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
+    } while (abs7(delta) > epsilon14 && --i > 0);
     return [
-        x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
-        phi2
+        x7 / (0.8707 + (phi22 = phi3 * phi3) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
+        phi3
     ];
 };
 
-function naturalEarth1_default() {
-    return projection(naturalEarth1Raw).scale(175.295);
+function naturalEarth1_default2() {
+    return projection2(naturalEarth1Raw2).scale(175.295);
 }
 
-// node_modules/d3-geo/src/projection/orthographic.js
-function orthographicRaw(x4, y4) {
-    return [cos2(y4) * sin2(x4), sin2(y4)];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/orthographic.js
+function orthographicRaw2(x7, y7) {
+    return [cos5(y7) * sin5(x7), sin5(y7)];
 }
-orthographicRaw.invert = azimuthalInvert(asin);
+orthographicRaw2.invert = azimuthalInvert2(asin3);
 
-function orthographic_default() {
-    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);
+function orthographic_default2() {
+    return projection2(orthographicRaw2).scale(249.5).clipAngle(90 + epsilon14);
 }
 
-// node_modules/d3-geo/src/projection/stereographic.js
-function stereographicRaw(x4, y4) {
-    var cy = cos2(y4),
-        k2 = 1 + cos2(x4) * cy;
-    return [cy * sin2(x4) / k2, sin2(y4) / k2];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/stereographic.js
+function stereographicRaw2(x7, y7) {
+    var cy = cos5(y7),
+        k3 = 1 + cos5(x7) * cy;
+    return [cy * sin5(x7) / k3, sin5(y7) / k3];
 }
-stereographicRaw.invert = azimuthalInvert(function(z) {
-    return 2 * atan(z);
+stereographicRaw2.invert = azimuthalInvert2(function(z) {
+    return 2 * atan3(z);
 });
 
-function stereographic_default() {
-    return projection(stereographicRaw).scale(250).clipAngle(142);
+function stereographic_default2() {
+    return projection2(stereographicRaw2).scale(250).clipAngle(142);
 }
 
-// node_modules/d3-geo/src/projection/transverseMercator.js
-function transverseMercatorRaw(lambda, phi2) {
-    return [log(tan((halfPi3 + phi2) / 2)), -lambda];
+// js/pyobsplot-js/node_modules/d3-geo/src/projection/transverseMercator.js
+function transverseMercatorRaw2(lambda, phi3) {
+    return [log3(tan2((halfPi7 + phi3) / 2)), -lambda];
 }
-transverseMercatorRaw.invert = function(x4, y4) {
-    return [-y4, 2 * atan(exp(x4)) - halfPi3];
+transverseMercatorRaw2.invert = function(x7, y7) {
+    return [-y7, 2 * atan3(exp2(x7)) - halfPi7];
 };
 
-function transverseMercator_default() {
-    var m3 = mercatorProjection(transverseMercatorRaw),
-        center2 = m3.center,
-        rotate = m3.rotate;
-    m3.center = function(_) {
-        return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
+function transverseMercator_default2() {
+    var m5 = mercatorProjection2(transverseMercatorRaw2),
+        center3 = m5.center,
+        rotate = m5.rotate;
+    m5.center = function(_) {
+        return arguments.length ? center3([-_[1], _[0]]) : (_ = center3(), [_[1], -_[0]]);
     };
-    m3.rotate = function(_) {
+    m5.rotate = function(_) {
         return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
     };
     return rotate([0, 0, 90]).scale(159.155);
 }
 
-// node_modules/d3-hierarchy/src/cluster.js
-function defaultSeparation(a4, b) {
-    return a4.parent === b.parent ? 1 : 2;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/cluster.js
+function defaultSeparation3(a7, b) {
+    return a7.parent === b.parent ? 1 : 2;
 }
 
-function meanX(children2) {
-    return children2.reduce(meanXReduce, 0) / children2.length;
+function meanX2(children3) {
+    return children3.reduce(meanXReduce2, 0) / children3.length;
 }
 
-function meanXReduce(x4, c6) {
-    return x4 + c6.x;
+function meanXReduce2(x7, c11) {
+    return x7 + c11.x;
 }
 
-function maxY(children2) {
-    return 1 + children2.reduce(maxYReduce, 0);
+function maxY2(children3) {
+    return 1 + children3.reduce(maxYReduce2, 0);
 }
 
-function maxYReduce(y4, c6) {
-    return Math.max(y4, c6.y);
+function maxYReduce2(y7, c11) {
+    return Math.max(y7, c11.y);
 }
 
-function leafLeft(node) {
-    var children2;
-    while (children2 = node.children)
-        node = children2[0];
+function leafLeft2(node) {
+    var children3;
+    while (children3 = node.children)
+        node = children3[0];
     return node;
 }
 
-function leafRight(node) {
-    var children2;
-    while (children2 = node.children)
-        node = children2[children2.length - 1];
+function leafRight2(node) {
+    var children3;
+    while (children3 = node.children)
+        node = children3[children3.length - 1];
     return node;
 }
 
-function cluster_default() {
-    var separation = defaultSeparation,
+function cluster_default2() {
+    var separation = defaultSeparation3,
         dx = 1,
         dy = 1,
         nodeSize = false;
 
-    function cluster2(root3) {
-        var previousNode, x4 = 0;
-        root3.eachAfter(function(node) {
-            var children2 = node.children;
-            if (children2) {
-                node.x = meanX(children2);
-                node.y = maxY(children2);
+    function cluster3(root5) {
+        var previousNode, x7 = 0;
+        root5.eachAfter(function(node) {
+            var children3 = node.children;
+            if (children3) {
+                node.x = meanX2(children3);
+                node.y = maxY2(children3);
             } else {
-                node.x = previousNode ? x4 += separation(node, previousNode) : 0;
+                node.x = previousNode ? x7 += separation(node, previousNode) : 0;
                 node.y = 0;
                 previousNode = node;
             }
         });
-        var left2 = leafLeft(root3),
-            right2 = leafRight(root3),
-            x06 = left2.x - separation(left2, right2) / 2,
-            x12 = right2.x + separation(right2, left2) / 2;
-        return root3.eachAfter(nodeSize ? function(node) {
-            node.x = (node.x - root3.x) * dx;
-            node.y = (root3.y - node.y) * dy;
+        var left3 = leafLeft2(root5),
+            right3 = leafRight2(root5),
+            x011 = left3.x - separation(left3, right3) / 2,
+            x13 = right3.x + separation(right3, left3) / 2;
+        return root5.eachAfter(nodeSize ? function(node) {
+            node.x = (node.x - root5.x) * dx;
+            node.y = (root5.y - node.y) * dy;
         } : function(node) {
-            node.x = (node.x - x06) / (x12 - x06) * dx;
-            node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;
+            node.x = (node.x - x011) / (x13 - x011) * dx;
+            node.y = (1 - (root5.y ? node.y / root5.y : 1)) * dy;
         });
     }
-    cluster2.separation = function(x4) {
-        return arguments.length ? (separation = x4, cluster2) : separation;
+    cluster3.separation = function(x7) {
+        return arguments.length ? (separation = x7, cluster3) : separation;
     };
-    cluster2.size = function(x4) {
-        return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? null : [dx, dy];
+    cluster3.size = function(x7) {
+        return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], cluster3) : nodeSize ? null : [dx, dy];
     };
-    cluster2.nodeSize = function(x4) {
-        return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? [dx, dy] : null;
+    cluster3.nodeSize = function(x7) {
+        return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], cluster3) : nodeSize ? [dx, dy] : null;
     };
-    return cluster2;
+    return cluster3;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/count.js
-function count2(node) {
-    var sum5 = 0,
-        children2 = node.children,
-        i = children2 && children2.length;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/count.js
+function count4(node) {
+    var sum8 = 0,
+        children3 = node.children,
+        i = children3 && children3.length;
     if (!i)
-        sum5 = 1;
+        sum8 = 1;
     else
         while (--i >= 0)
-            sum5 += children2[i].value;
-    node.value = sum5;
+            sum8 += children3[i].value;
+    node.value = sum8;
 }
 
-function count_default() {
-    return this.eachAfter(count2);
+function count_default2() {
+    return this.eachAfter(count4);
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/each.js
-function each_default2(callback, that) {
-    let index3 = -1;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/each.js
+function each_default4(callback, that) {
+    let index5 = -1;
     for (const node of this) {
-        callback.call(that, node, ++index3, this);
+        callback.call(that, node, ++index5, this);
     }
     return this;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
-function eachBefore_default(callback, that) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
+function eachBefore_default2(callback, that) {
     var node = this,
         nodes = [node],
-        children2, i, index3 = -1;
+        children3, i, index5 = -1;
     while (node = nodes.pop()) {
-        callback.call(that, node, ++index3, this);
-        if (children2 = node.children) {
-            for (i = children2.length - 1; i >= 0; --i) {
-                nodes.push(children2[i]);
+        callback.call(that, node, ++index5, this);
+        if (children3 = node.children) {
+            for (i = children3.length - 1; i >= 0; --i) {
+                nodes.push(children3[i]);
             }
         }
     }
     return this;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
-function eachAfter_default(callback, that) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
+function eachAfter_default2(callback, that) {
     var node = this,
         nodes = [node],
         next = [],
-        children2, i, n, index3 = -1;
+        children3, i, n, index5 = -1;
     while (node = nodes.pop()) {
         next.push(node);
-        if (children2 = node.children) {
-            for (i = 0, n = children2.length; i < n; ++i) {
-                nodes.push(children2[i]);
+        if (children3 = node.children) {
+            for (i = 0, n = children3.length; i < n; ++i) {
+                nodes.push(children3[i]);
             }
         }
     }
     while (node = next.pop()) {
-        callback.call(that, node, ++index3, this);
+        callback.call(that, node, ++index5, this);
     }
     return this;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/find.js
-function find_default2(callback, that) {
-    let index3 = -1;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/find.js
+function find_default4(callback, that) {
+    let index5 = -1;
     for (const node of this) {
-        if (callback.call(that, node, ++index3, this)) {
+        if (callback.call(that, node, ++index5, this)) {
             return node;
         }
     }
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/sum.js
-function sum_default(value) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/sum.js
+function sum_default2(value) {
     return this.eachAfter(function(node) {
-        var sum5 = +value(node.data) || 0,
-            children2 = node.children,
-            i = children2 && children2.length;
+        var sum8 = +value(node.data) || 0,
+            children3 = node.children,
+            i = children3 && children3.length;
         while (--i >= 0)
-            sum5 += children2[i].value;
-        node.value = sum5;
+            sum8 += children3[i].value;
+        node.value = sum8;
     });
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/sort.js
-function sort_default2(compare) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/sort.js
+function sort_default4(compare) {
     return this.eachBefore(function(node) {
         if (node.children) {
             node.children.sort(compare);
         }
     });
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/path.js
-function path_default2(end) {
-    var start2 = this,
-        ancestor = leastCommonAncestor(start2, end),
-        nodes = [start2];
-    while (start2 !== ancestor) {
-        start2 = start2.parent;
-        nodes.push(start2);
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/path.js
+function path_default4(end) {
+    var start3 = this,
+        ancestor = leastCommonAncestor2(start3, end),
+        nodes = [start3];
+    while (start3 !== ancestor) {
+        start3 = start3.parent;
+        nodes.push(start3);
     }
-    var k2 = nodes.length;
+    var k3 = nodes.length;
     while (end !== ancestor) {
-        nodes.splice(k2, 0, end);
+        nodes.splice(k3, 0, end);
         end = end.parent;
     }
     return nodes;
 }
 
-function leastCommonAncestor(a4, b) {
-    if (a4 === b)
-        return a4;
-    var aNodes = a4.ancestors(),
+function leastCommonAncestor2(a7, b) {
+    if (a7 === b)
+        return a7;
+    var aNodes = a7.ancestors(),
         bNodes = b.ancestors(),
-        c6 = null;
-    a4 = aNodes.pop();
+        c11 = null;
+    a7 = aNodes.pop();
     b = bNodes.pop();
-    while (a4 === b) {
-        c6 = a4;
-        a4 = aNodes.pop();
+    while (a7 === b) {
+        c11 = a7;
+        a7 = aNodes.pop();
         b = bNodes.pop();
     }
-    return c6;
+    return c11;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
-function ancestors_default() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
+function ancestors_default2() {
     var node = this,
         nodes = [node];
     while (node = node.parent) {
         nodes.push(node);
     }
     return nodes;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/descendants.js
-function descendants_default() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/descendants.js
+function descendants_default2() {
     return Array.from(this);
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/leaves.js
-function leaves_default() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/leaves.js
+function leaves_default2() {
     var leaves = [];
     this.eachBefore(function(node) {
         if (!node.children) {
             leaves.push(node);
         }
     });
     return leaves;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/links.js
-function links_default() {
-    var root3 = this,
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/links.js
+function links_default2() {
+    var root5 = this,
         links = [];
-    root3.each(function(node) {
-        if (node !== root3) {
+    root5.each(function(node) {
+        if (node !== root5) {
             links.push({
                 source: node.parent,
                 target: node
             });
         }
     });
     return links;
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/iterator.js
-function* iterator_default2() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/iterator.js
+function* iterator_default4() {
     var node = this,
         current, next = [node],
-        children2, i, n;
+        children3, i, n;
     do {
         current = next.reverse(), next = [];
         while (node = current.pop()) {
             yield node;
-            if (children2 = node.children) {
-                for (i = 0, n = children2.length; i < n; ++i) {
-                    next.push(children2[i]);
+            if (children3 = node.children) {
+                for (i = 0, n = children3.length; i < n; ++i) {
+                    next.push(children3[i]);
                 }
             }
         }
     } while (next.length);
 }
 
-// node_modules/d3-hierarchy/src/hierarchy/index.js
-function hierarchy(data, children2) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/hierarchy/index.js
+function hierarchy2(data, children3) {
     if (data instanceof Map) {
         data = [void 0, data];
-        if (children2 === void 0)
-            children2 = mapChildren;
-    } else if (children2 === void 0) {
-        children2 = objectChildren;
+        if (children3 === void 0)
+            children3 = mapChildren2;
+    } else if (children3 === void 0) {
+        children3 = objectChildren2;
     }
-    var root3 = new Node2(data),
-        node, nodes = [root3],
+    var root5 = new Node4(data),
+        node, nodes = [root5],
         child, childs, i, n;
     while (node = nodes.pop()) {
-        if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
+        if ((childs = children3(node.data)) && (n = (childs = Array.from(childs)).length)) {
             node.children = childs;
             for (i = n - 1; i >= 0; --i) {
-                nodes.push(child = childs[i] = new Node2(childs[i]));
+                nodes.push(child = childs[i] = new Node4(childs[i]));
                 child.parent = node;
                 child.depth = node.depth + 1;
             }
         }
     }
-    return root3.eachBefore(computeHeight);
+    return root5.eachBefore(computeHeight2);
 }
 
-function node_copy() {
-    return hierarchy(this).eachBefore(copyData);
+function node_copy2() {
+    return hierarchy2(this).eachBefore(copyData2);
 }
 
-function objectChildren(d) {
+function objectChildren2(d) {
     return d.children;
 }
 
-function mapChildren(d) {
+function mapChildren2(d) {
     return Array.isArray(d) ? d[1] : null;
 }
 
-function copyData(node) {
+function copyData2(node) {
     if (node.data.value !== void 0)
         node.value = node.data.value;
     node.data = node.data.data;
 }
 
-function computeHeight(node) {
+function computeHeight2(node) {
     var height = 0;
     do
         node.height = height;
     while ((node = node.parent) && node.height < ++height);
 }
 
-function Node2(data) {
+function Node4(data) {
     this.data = data;
     this.depth = this.height = 0;
     this.parent = null;
 }
-Node2.prototype = hierarchy.prototype = {
-    constructor: Node2,
-    count: count_default,
-    each: each_default2,
-    eachAfter: eachAfter_default,
-    eachBefore: eachBefore_default,
-    find: find_default2,
-    sum: sum_default,
-    sort: sort_default2,
-    path: path_default2,
-    ancestors: ancestors_default,
-    descendants: descendants_default,
-    leaves: leaves_default,
-    links: links_default,
-    copy: node_copy,
-    [Symbol.iterator]: iterator_default2
-};
-
-// node_modules/d3-hierarchy/src/accessors.js
-function optional(f) {
-    return f == null ? null : required(f);
+Node4.prototype = hierarchy2.prototype = {
+    constructor: Node4,
+    count: count_default2,
+    each: each_default4,
+    eachAfter: eachAfter_default2,
+    eachBefore: eachBefore_default2,
+    find: find_default4,
+    sum: sum_default2,
+    sort: sort_default4,
+    path: path_default4,
+    ancestors: ancestors_default2,
+    descendants: descendants_default2,
+    leaves: leaves_default2,
+    links: links_default2,
+    copy: node_copy2,
+    [Symbol.iterator]: iterator_default4
+};
+
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/accessors.js
+function optional2(f) {
+    return f == null ? null : required2(f);
 }
 
-function required(f) {
+function required2(f) {
     if (typeof f !== "function")
         throw new Error();
     return f;
 }
 
-// node_modules/d3-hierarchy/src/constant.js
-function constantZero() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/constant.js
+function constantZero2() {
     return 0;
 }
 
-function constant_default9(x4) {
+function constant_default20(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
-// node_modules/d3-hierarchy/src/lcg.js
-var a2 = 1664525;
-var c2 = 1013904223;
-var m2 = 4294967296;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/lcg.js
+var a5 = 1664525;
+var c7 = 1013904223;
+var m4 = 4294967296;
 
-function lcg_default2() {
-    let s2 = 1;
-    return () => (s2 = (a2 * s2 + c2) % m2) / m2;
+function lcg_default4() {
+    let s3 = 1;
+    return () => (s3 = (a5 * s3 + c7) % m4) / m4;
 }
 
-// node_modules/d3-hierarchy/src/array.js
-function array_default2(x4) {
-    return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/array.js
+function array_default5(x7) {
+    return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
 }
 
-function shuffle(array4, random) {
-    let m3 = array4.length,
+function shuffle3(array7, random) {
+    let m5 = array7.length,
         t, i;
-    while (m3) {
-        i = random() * m3-- | 0;
-        t = array4[m3];
-        array4[m3] = array4[i];
-        array4[i] = t;
+    while (m5) {
+        i = random() * m5-- | 0;
+        t = array7[m5];
+        array7[m5] = array7[i];
+        array7[i] = t;
     }
-    return array4;
+    return array7;
 }
 
-// node_modules/d3-hierarchy/src/pack/enclose.js
-function enclose_default(circles) {
-    return packEncloseRandom(circles, lcg_default2());
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/pack/enclose.js
+function enclose_default2(circles) {
+    return packEncloseRandom2(circles, lcg_default4());
 }
 
-function packEncloseRandom(circles, random) {
+function packEncloseRandom2(circles, random) {
     var i = 0,
-        n = (circles = shuffle(Array.from(circles), random)).length,
-        B3 = [],
+        n = (circles = shuffle3(Array.from(circles), random)).length,
+        B5 = [],
         p, e;
     while (i < n) {
         p = circles[i];
-        if (e && enclosesWeak(e, p))
+        if (e && enclosesWeak2(e, p))
             ++i;
         else
-            e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;
+            e = encloseBasis4(B5 = extendBasis2(B5, p)), i = 0;
     }
     return e;
 }
 
-function extendBasis(B3, p) {
+function extendBasis2(B5, p) {
     var i, j;
-    if (enclosesWeakAll(p, B3))
+    if (enclosesWeakAll2(p, B5))
         return [p];
-    for (i = 0; i < B3.length; ++i) {
-        if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {
-            return [B3[i], p];
+    for (i = 0; i < B5.length; ++i) {
+        if (enclosesNot2(p, B5[i]) && enclosesWeakAll2(encloseBasis22(B5[i], p), B5)) {
+            return [B5[i], p];
         }
     }
-    for (i = 0; i < B3.length - 1; ++i) {
-        for (j = i + 1; j < B3.length; ++j) {
-            if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {
-                return [B3[i], B3[j], p];
+    for (i = 0; i < B5.length - 1; ++i) {
+        for (j = i + 1; j < B5.length; ++j) {
+            if (enclosesNot2(encloseBasis22(B5[i], B5[j]), p) && enclosesNot2(encloseBasis22(B5[i], p), B5[j]) && enclosesNot2(encloseBasis22(B5[j], p), B5[i]) && enclosesWeakAll2(encloseBasis32(B5[i], B5[j], p), B5)) {
+                return [B5[i], B5[j], p];
             }
         }
     }
     throw new Error();
 }
 
-function enclosesNot(a4, b) {
-    var dr = a4.r - b.r,
-        dx = b.x - a4.x,
-        dy = b.y - a4.y;
+function enclosesNot2(a7, b) {
+    var dr = a7.r - b.r,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
     return dr < 0 || dr * dr < dx * dx + dy * dy;
 }
 
-function enclosesWeak(a4, b) {
-    var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9,
-        dx = b.x - a4.x,
-        dy = b.y - a4.y;
+function enclosesWeak2(a7, b) {
+    var dr = a7.r - b.r + Math.max(a7.r, b.r, 1) * 1e-9,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
     return dr > 0 && dr * dr > dx * dx + dy * dy;
 }
 
-function enclosesWeakAll(a4, B3) {
-    for (var i = 0; i < B3.length; ++i) {
-        if (!enclosesWeak(a4, B3[i])) {
+function enclosesWeakAll2(a7, B5) {
+    for (var i = 0; i < B5.length; ++i) {
+        if (!enclosesWeak2(a7, B5[i])) {
             return false;
         }
     }
     return true;
 }
 
-function encloseBasis(B3) {
-    switch (B3.length) {
+function encloseBasis4(B5) {
+    switch (B5.length) {
         case 1:
-            return encloseBasis1(B3[0]);
+            return encloseBasis12(B5[0]);
         case 2:
-            return encloseBasis2(B3[0], B3[1]);
+            return encloseBasis22(B5[0], B5[1]);
         case 3:
-            return encloseBasis3(B3[0], B3[1], B3[2]);
+            return encloseBasis32(B5[0], B5[1], B5[2]);
     }
 }
 
-function encloseBasis1(a4) {
+function encloseBasis12(a7) {
     return {
-        x: a4.x,
-        y: a4.y,
-        r: a4.r
+        x: a7.x,
+        y: a7.y,
+        r: a7.r
     };
 }
 
-function encloseBasis2(a4, b) {
-    var x12 = a4.x,
-        y12 = a4.y,
-        r1 = a4.r,
+function encloseBasis22(a7, b) {
+    var x13 = a7.x,
+        y13 = a7.y,
+        r1 = a7.r,
         x22 = b.x,
         y22 = b.y,
         r2 = b.r,
-        x21 = x22 - x12,
-        y21 = y22 - y12,
+        x21 = x22 - x13,
+        y21 = y22 - y13,
         r21 = r2 - r1,
         l = Math.sqrt(x21 * x21 + y21 * y21);
     return {
-        x: (x12 + x22 + x21 / l * r21) / 2,
-        y: (y12 + y22 + y21 / l * r21) / 2,
+        x: (x13 + x22 + x21 / l * r21) / 2,
+        y: (y13 + y22 + y21 / l * r21) / 2,
         r: (l + r1 + r2) / 2
     };
 }
 
-function encloseBasis3(a4, b, c6) {
-    var x12 = a4.x,
-        y12 = a4.y,
-        r1 = a4.r,
+function encloseBasis32(a7, b, c11) {
+    var x13 = a7.x,
+        y13 = a7.y,
+        r1 = a7.r,
         x22 = b.x,
         y22 = b.y,
         r2 = b.r,
-        x32 = c6.x,
-        y32 = c6.y,
-        r3 = c6.r,
-        a22 = x12 - x22,
-        a32 = x12 - x32,
-        b22 = y12 - y22,
-        b32 = y12 - y32,
+        x32 = c11.x,
+        y32 = c11.y,
+        r3 = c11.r,
+        a22 = x13 - x22,
+        a32 = x13 - x32,
+        b23 = y13 - y22,
+        b33 = y13 - y32,
         c22 = r2 - r1,
         c32 = r3 - r1,
-        d1 = x12 * x12 + y12 * y12 - r1 * r1,
+        d1 = x13 * x13 + y13 * y13 - r1 * r1,
         d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2,
         d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3,
-        ab4 = a32 * b22 - a22 * b32,
-        xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12,
-        xb = (b32 * c22 - b22 * c32) / ab4,
-        ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12,
-        yb = (a22 * c32 - a32 * c22) / ab4,
-        A5 = xb * xb + yb * yb - 1,
-        B3 = 2 * (r1 + xa * xb + ya * yb),
-        C3 = xa * xa + ya * ya - r1 * r1,
-        r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
+        ab7 = a32 * b23 - a22 * b33,
+        xa = (b23 * d3 - b33 * d2) / (ab7 * 2) - x13,
+        xb = (b33 * c22 - b23 * c32) / ab7,
+        ya = (a32 * d2 - a22 * d3) / (ab7 * 2) - y13,
+        yb = (a22 * c32 - a32 * c22) / ab7,
+        A6 = xb * xb + yb * yb - 1,
+        B5 = 2 * (r1 + xa * xb + ya * yb),
+        C4 = xa * xa + ya * ya - r1 * r1,
+        r = -(Math.abs(A6) > 1e-6 ? (B5 + Math.sqrt(B5 * B5 - 4 * A6 * C4)) / (2 * A6) : C4 / B5);
     return {
-        x: x12 + xa + xb * r,
-        y: y12 + ya + yb * r,
+        x: x13 + xa + xb * r,
+        y: y13 + ya + yb * r,
         r
     };
 }
 
-// node_modules/d3-hierarchy/src/pack/siblings.js
-function place(b, a4, c6) {
-    var dx = b.x - a4.x,
-        x4, a22, dy = b.y - a4.y,
-        y4, b22, d2 = dx * dx + dy * dy;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/pack/siblings.js
+function place2(b, a7, c11) {
+    var dx = b.x - a7.x,
+        x7, a22, dy = b.y - a7.y,
+        y7, b23, d2 = dx * dx + dy * dy;
     if (d2) {
-        a22 = a4.r + c6.r, a22 *= a22;
-        b22 = b.r + c6.r, b22 *= b22;
-        if (a22 > b22) {
-            x4 = (d2 + b22 - a22) / (2 * d2);
-            y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));
-            c6.x = b.x - x4 * dx - y4 * dy;
-            c6.y = b.y - x4 * dy + y4 * dx;
+        a22 = a7.r + c11.r, a22 *= a22;
+        b23 = b.r + c11.r, b23 *= b23;
+        if (a22 > b23) {
+            x7 = (d2 + b23 - a22) / (2 * d2);
+            y7 = Math.sqrt(Math.max(0, b23 / d2 - x7 * x7));
+            c11.x = b.x - x7 * dx - y7 * dy;
+            c11.y = b.y - x7 * dy + y7 * dx;
         } else {
-            x4 = (d2 + a22 - b22) / (2 * d2);
-            y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));
-            c6.x = a4.x + x4 * dx - y4 * dy;
-            c6.y = a4.y + x4 * dy + y4 * dx;
+            x7 = (d2 + a22 - b23) / (2 * d2);
+            y7 = Math.sqrt(Math.max(0, a22 / d2 - x7 * x7));
+            c11.x = a7.x + x7 * dx - y7 * dy;
+            c11.y = a7.y + x7 * dy + y7 * dx;
         }
     } else {
-        c6.x = a4.x + c6.r;
-        c6.y = a4.y;
+        c11.x = a7.x + c11.r;
+        c11.y = a7.y;
     }
 }
 
-function intersects(a4, b) {
-    var dr = a4.r + b.r - 1e-6,
-        dx = b.x - a4.x,
-        dy = b.y - a4.y;
+function intersects2(a7, b) {
+    var dr = a7.r + b.r - 1e-6,
+        dx = b.x - a7.x,
+        dy = b.y - a7.y;
     return dr > 0 && dr * dr > dx * dx + dy * dy;
 }
 
-function score(node) {
-    var a4 = node._,
+function score2(node) {
+    var a7 = node._,
         b = node.next._,
-        ab4 = a4.r + b.r,
-        dx = (a4.x * b.r + b.x * a4.r) / ab4,
-        dy = (a4.y * b.r + b.y * a4.r) / ab4;
+        ab7 = a7.r + b.r,
+        dx = (a7.x * b.r + b.x * a7.r) / ab7,
+        dy = (a7.y * b.r + b.y * a7.r) / ab7;
     return dx * dx + dy * dy;
 }
 
-function Node3(circle2) {
-    this._ = circle2;
+function Node5(circle3) {
+    this._ = circle3;
     this.next = null;
     this.previous = null;
 }
 
-function packSiblingsRandom(circles, random) {
-    if (!(n = (circles = array_default2(circles)).length))
+function packSiblingsRandom2(circles, random) {
+    if (!(n = (circles = array_default5(circles)).length))
         return 0;
-    var a4, b, c6, n, aa2, ca3, i, j, k2, sj, sk;
-    a4 = circles[0], a4.x = 0, a4.y = 0;
+    var a7, b, c11, n, aa3, ca5, i, j, k3, sj, sk;
+    a7 = circles[0], a7.x = 0, a7.y = 0;
     if (!(n > 1))
-        return a4.r;
-    b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;
+        return a7.r;
+    b = circles[1], a7.x = -b.r, b.x = a7.r, b.y = 0;
     if (!(n > 2))
-        return a4.r + b.r;
-    place(b, a4, c6 = circles[2]);
-    a4 = new Node3(a4), b = new Node3(b), c6 = new Node3(c6);
-    a4.next = c6.previous = b;
-    b.next = a4.previous = c6;
-    c6.next = b.previous = a4;
+        return a7.r + b.r;
+    place2(b, a7, c11 = circles[2]);
+    a7 = new Node5(a7), b = new Node5(b), c11 = new Node5(c11);
+    a7.next = c11.previous = b;
+    b.next = a7.previous = c11;
+    c11.next = b.previous = a7;
     pack:
         for (i = 3; i < n; ++i) {
-            place(a4._, b._, c6 = circles[i]), c6 = new Node3(c6);
-            j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;
+            place2(a7._, b._, c11 = circles[i]), c11 = new Node5(c11);
+            j = b.next, k3 = a7.previous, sj = b._.r, sk = a7._.r;
             do {
                 if (sj <= sk) {
-                    if (intersects(j._, c6._)) {
-                        b = j, a4.next = b, b.previous = a4, --i;
+                    if (intersects2(j._, c11._)) {
+                        b = j, a7.next = b, b.previous = a7, --i;
                         continue pack;
                     }
                     sj += j._.r, j = j.next;
                 } else {
-                    if (intersects(k2._, c6._)) {
-                        a4 = k2, a4.next = b, b.previous = a4, --i;
+                    if (intersects2(k3._, c11._)) {
+                        a7 = k3, a7.next = b, b.previous = a7, --i;
                         continue pack;
                     }
-                    sk += k2._.r, k2 = k2.previous;
+                    sk += k3._.r, k3 = k3.previous;
                 }
-            } while (j !== k2.next);
-            c6.previous = a4, c6.next = b, a4.next = b.previous = b = c6;
-            aa2 = score(a4);
-            while ((c6 = c6.next) !== b) {
-                if ((ca3 = score(c6)) < aa2) {
-                    a4 = c6, aa2 = ca3;
-                }
-            }
-            b = a4.next;
-        }
-    a4 = [b._], c6 = b;
-    while ((c6 = c6.next) !== b)
-        a4.push(c6._);
-    c6 = packEncloseRandom(a4, random);
+            } while (j !== k3.next);
+            c11.previous = a7, c11.next = b, a7.next = b.previous = b = c11;
+            aa3 = score2(a7);
+            while ((c11 = c11.next) !== b) {
+                if ((ca5 = score2(c11)) < aa3) {
+                    a7 = c11, aa3 = ca5;
+                }
+            }
+            b = a7.next;
+        }
+    a7 = [b._], c11 = b;
+    while ((c11 = c11.next) !== b)
+        a7.push(c11._);
+    c11 = packEncloseRandom2(a7, random);
     for (i = 0; i < n; ++i)
-        a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;
-    return c6.r;
+        a7 = circles[i], a7.x -= c11.x, a7.y -= c11.y;
+    return c11.r;
 }
 
-function siblings_default(circles) {
-    packSiblingsRandom(circles, lcg_default2());
+function siblings_default2(circles) {
+    packSiblingsRandom2(circles, lcg_default4());
     return circles;
 }
 
-// node_modules/d3-hierarchy/src/pack/index.js
-function defaultRadius2(d) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/pack/index.js
+function defaultRadius5(d) {
     return Math.sqrt(d.value);
 }
 
-function pack_default() {
-    var radius2 = null,
+function pack_default2() {
+    var radius3 = null,
         dx = 1,
         dy = 1,
-        padding = constantZero;
+        padding = constantZero2;
 
-    function pack(root3) {
-        const random = lcg_default2();
-        root3.x = dx / 2, root3.y = dy / 2;
-        if (radius2) {
-            root3.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
+    function pack(root5) {
+        const random = lcg_default4();
+        root5.x = dx / 2, root5.y = dy / 2;
+        if (radius3) {
+            root5.eachBefore(radiusLeaf2(radius3)).eachAfter(packChildrenRandom2(padding, 0.5, random)).eachBefore(translateChild2(1));
         } else {
-            root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));
+            root5.eachBefore(radiusLeaf2(defaultRadius5)).eachAfter(packChildrenRandom2(constantZero2, 1, random)).eachAfter(packChildrenRandom2(padding, root5.r / Math.min(dx, dy), random)).eachBefore(translateChild2(Math.min(dx, dy) / (2 * root5.r)));
         }
-        return root3;
+        return root5;
     }
-    pack.radius = function(x4) {
-        return arguments.length ? (radius2 = optional(x4), pack) : radius2;
+    pack.radius = function(x7) {
+        return arguments.length ? (radius3 = optional2(x7), pack) : radius3;
     };
-    pack.size = function(x4) {
-        return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];
+    pack.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], pack) : [dx, dy];
     };
-    pack.padding = function(x4) {
-        return arguments.length ? (padding = typeof x4 === "function" ? x4 : constant_default9(+x4), pack) : padding;
+    pack.padding = function(x7) {
+        return arguments.length ? (padding = typeof x7 === "function" ? x7 : constant_default20(+x7), pack) : padding;
     };
     return pack;
 }
 
-function radiusLeaf(radius2) {
+function radiusLeaf2(radius3) {
     return function(node) {
         if (!node.children) {
-            node.r = Math.max(0, +radius2(node) || 0);
+            node.r = Math.max(0, +radius3(node) || 0);
         }
     };
 }
 
-function packChildrenRandom(padding, k2, random) {
+function packChildrenRandom2(padding, k3, random) {
     return function(node) {
-        if (children2 = node.children) {
-            var children2, i, n = children2.length,
-                r = padding(node) * k2 || 0,
+        if (children3 = node.children) {
+            var children3, i, n = children3.length,
+                r = padding(node) * k3 || 0,
                 e;
             if (r)
                 for (i = 0; i < n; ++i)
-                    children2[i].r += r;
-            e = packSiblingsRandom(children2, random);
+                    children3[i].r += r;
+            e = packSiblingsRandom2(children3, random);
             if (r)
                 for (i = 0; i < n; ++i)
-                    children2[i].r -= r;
+                    children3[i].r -= r;
             node.r = e + r;
         }
     };
 }
 
-function translateChild(k2) {
+function translateChild2(k3) {
     return function(node) {
         var parent = node.parent;
-        node.r *= k2;
+        node.r *= k3;
         if (parent) {
-            node.x = parent.x + k2 * node.x;
-            node.y = parent.y + k2 * node.y;
+            node.x = parent.x + k3 * node.x;
+            node.y = parent.y + k3 * node.y;
         }
     };
 }
 
-// node_modules/d3-hierarchy/src/treemap/round.js
-function round_default2(node) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/round.js
+function round_default4(node) {
     node.x0 = Math.round(node.x0);
     node.y0 = Math.round(node.y0);
     node.x1 = Math.round(node.x1);
     node.y1 = Math.round(node.y1);
 }
 
-// node_modules/d3-hierarchy/src/treemap/dice.js
-function dice_default(parent, x06, y06, x12, y12) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/dice.js
+function dice_default2(parent, x011, y011, x13, y13) {
     var nodes = parent.children,
         node, i = -1,
         n = nodes.length,
-        k2 = parent.value && (x12 - x06) / parent.value;
+        k3 = parent.value && (x13 - x011) / parent.value;
     while (++i < n) {
-        node = nodes[i], node.y0 = y06, node.y1 = y12;
-        node.x0 = x06, node.x1 = x06 += node.value * k2;
+        node = nodes[i], node.y0 = y011, node.y1 = y13;
+        node.x0 = x011, node.x1 = x011 += node.value * k3;
     }
 }
 
-// node_modules/d3-hierarchy/src/partition.js
-function partition_default() {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/partition.js
+function partition_default2() {
     var dx = 1,
         dy = 1,
         padding = 0,
-        round2 = false;
+        round3 = false;
 
-    function partition(root3) {
-        var n = root3.height + 1;
-        root3.x0 = root3.y0 = padding;
-        root3.x1 = dx;
-        root3.y1 = dy / n;
-        root3.eachBefore(positionNode(dy, n));
-        if (round2)
-            root3.eachBefore(round_default2);
-        return root3;
+    function partition(root5) {
+        var n = root5.height + 1;
+        root5.x0 = root5.y0 = padding;
+        root5.x1 = dx;
+        root5.y1 = dy / n;
+        root5.eachBefore(positionNode(dy, n));
+        if (round3)
+            root5.eachBefore(round_default4);
+        return root5;
     }
 
     function positionNode(dy2, n) {
         return function(node) {
             if (node.children) {
-                dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
+                dice_default2(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
             }
-            var x06 = node.x0,
-                y06 = node.y0,
-                x12 = node.x1 - padding,
-                y12 = node.y1 - padding;
-            if (x12 < x06)
-                x06 = x12 = (x06 + x12) / 2;
-            if (y12 < y06)
-                y06 = y12 = (y06 + y12) / 2;
-            node.x0 = x06;
-            node.y0 = y06;
-            node.x1 = x12;
-            node.y1 = y12;
+            var x011 = node.x0,
+                y011 = node.y0,
+                x13 = node.x1 - padding,
+                y13 = node.y1 - padding;
+            if (x13 < x011)
+                x011 = x13 = (x011 + x13) / 2;
+            if (y13 < y011)
+                y011 = y13 = (y011 + y13) / 2;
+            node.x0 = x011;
+            node.y0 = y011;
+            node.x1 = x13;
+            node.y1 = y13;
         };
     }
-    partition.round = function(x4) {
-        return arguments.length ? (round2 = !!x4, partition) : round2;
+    partition.round = function(x7) {
+        return arguments.length ? (round3 = !!x7, partition) : round3;
     };
-    partition.size = function(x4) {
-        return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];
+    partition.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], partition) : [dx, dy];
     };
-    partition.padding = function(x4) {
-        return arguments.length ? (padding = +x4, partition) : padding;
+    partition.padding = function(x7) {
+        return arguments.length ? (padding = +x7, partition) : padding;
     };
     return partition;
 }
 
-// node_modules/d3-hierarchy/src/stratify.js
-var preroot = {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/stratify.js
+var preroot2 = {
     depth: -1
 };
-var ambiguous = {};
-var imputed = {};
+var ambiguous2 = {};
+var imputed2 = {};
 
-function defaultId(d) {
+function defaultId2(d) {
     return d.id;
 }
 
-function defaultParentId(d) {
+function defaultParentId2(d) {
     return d.parentId;
 }
 
-function stratify_default() {
-    var id2 = defaultId,
-        parentId = defaultParentId,
-        path2;
+function stratify_default2() {
+    var id3 = defaultId2,
+        parentId = defaultParentId2,
+        path3;
 
     function stratify(data) {
         var nodes = Array.from(data),
-            currentId = id2,
+            currentId = id3,
             currentParentId = parentId,
-            n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
-        if (path2 != null) {
-            const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));
-            const P = I.map(parentof);
+            n, d, i, root5, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
+        if (path3 != null) {
+            const I = nodes.map((d2, i2) => normalize4(path3(d2, i2, data)));
+            const P = I.map(parentof2);
             const S = new Set(I).add("");
             for (const i2 of P) {
                 if (!S.has(i2)) {
                     S.add(i2);
                     I.push(i2);
-                    P.push(parentof(i2));
-                    nodes.push(imputed);
+                    P.push(parentof2(i2));
+                    nodes.push(imputed2);
                 }
             }
             currentId = (_, i2) => I[i2];
             currentParentId = (_, i2) => P[i2];
         }
         for (i = 0, n = nodes.length; i < n; ++i) {
-            d = nodes[i], node = nodes[i] = new Node2(d);
+            d = nodes[i], node = nodes[i] = new Node4(d);
             if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
                 nodeKey = node.id = nodeId;
-                nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
+                nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous2 : node);
             }
             if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
                 node.parent = nodeId;
             }
         }
         for (i = 0; i < n; ++i) {
             node = nodes[i];
             if (nodeId = node.parent) {
                 parent = nodeByKey.get(nodeId);
                 if (!parent)
                     throw new Error("missing: " + nodeId);
-                if (parent === ambiguous)
+                if (parent === ambiguous2)
                     throw new Error("ambiguous: " + nodeId);
                 if (parent.children)
                     parent.children.push(node);
                 else
                     parent.children = [node];
                 node.parent = parent;
             } else {
-                if (root3)
+                if (root5)
                     throw new Error("multiple roots");
-                root3 = node;
+                root5 = node;
             }
         }
-        if (!root3)
+        if (!root5)
             throw new Error("no root");
-        if (path2 != null) {
-            while (root3.data === imputed && root3.children.length === 1) {
-                root3 = root3.children[0], --n;
+        if (path3 != null) {
+            while (root5.data === imputed2 && root5.children.length === 1) {
+                root5 = root5.children[0], --n;
             }
             for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
                 node = nodes[i2];
-                if (node.data !== imputed)
+                if (node.data !== imputed2)
                     break;
                 node.data = null;
             }
         }
-        root3.parent = preroot;
-        root3.eachBefore(function(node2) {
+        root5.parent = preroot2;
+        root5.eachBefore(function(node2) {
             node2.depth = node2.parent.depth + 1;
             --n;
-        }).eachBefore(computeHeight);
-        root3.parent = null;
+        }).eachBefore(computeHeight2);
+        root5.parent = null;
         if (n > 0)
             throw new Error("cycle");
-        return root3;
+        return root5;
     }
-    stratify.id = function(x4) {
-        return arguments.length ? (id2 = optional(x4), stratify) : id2;
+    stratify.id = function(x7) {
+        return arguments.length ? (id3 = optional2(x7), stratify) : id3;
     };
-    stratify.parentId = function(x4) {
-        return arguments.length ? (parentId = optional(x4), stratify) : parentId;
+    stratify.parentId = function(x7) {
+        return arguments.length ? (parentId = optional2(x7), stratify) : parentId;
     };
-    stratify.path = function(x4) {
-        return arguments.length ? (path2 = optional(x4), stratify) : path2;
+    stratify.path = function(x7) {
+        return arguments.length ? (path3 = optional2(x7), stratify) : path3;
     };
     return stratify;
 }
 
-function normalize(path2) {
-    path2 = `${path2}`;
-    let i = path2.length;
-    if (slash(path2, i - 1) && !slash(path2, i - 2))
-        path2 = path2.slice(0, -1);
-    return path2[0] === "/" ? path2 : `/${path2}`;
+function normalize4(path3) {
+    path3 = `${path3}`;
+    let i = path3.length;
+    if (slash3(path3, i - 1) && !slash3(path3, i - 2))
+        path3 = path3.slice(0, -1);
+    return path3[0] === "/" ? path3 : `/${path3}`;
 }
 
-function parentof(path2) {
-    let i = path2.length;
+function parentof2(path3) {
+    let i = path3.length;
     if (i < 2)
         return "";
     while (--i > 1)
-        if (slash(path2, i))
+        if (slash3(path3, i))
             break;
-    return path2.slice(0, i);
+    return path3.slice(0, i);
 }
 
-function slash(path2, i) {
-    if (path2[i] === "/") {
-        let k2 = 0;
-        while (i > 0 && path2[--i] === "\\")
-            ++k2;
-        if ((k2 & 1) === 0)
+function slash3(path3, i) {
+    if (path3[i] === "/") {
+        let k3 = 0;
+        while (i > 0 && path3[--i] === "\\")
+            ++k3;
+        if ((k3 & 1) === 0)
             return true;
     }
     return false;
 }
 
-// node_modules/d3-hierarchy/src/tree.js
-function defaultSeparation2(a4, b) {
-    return a4.parent === b.parent ? 1 : 2;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/tree.js
+function defaultSeparation4(a7, b) {
+    return a7.parent === b.parent ? 1 : 2;
 }
 
-function nextLeft(v2) {
-    var children2 = v2.children;
-    return children2 ? children2[0] : v2.t;
+function nextLeft2(v3) {
+    var children3 = v3.children;
+    return children3 ? children3[0] : v3.t;
 }
 
-function nextRight(v2) {
-    var children2 = v2.children;
-    return children2 ? children2[children2.length - 1] : v2.t;
+function nextRight2(v3) {
+    var children3 = v3.children;
+    return children3 ? children3[children3.length - 1] : v3.t;
 }
 
-function moveSubtree(wm, wp, shift) {
+function moveSubtree2(wm, wp, shift) {
     var change = shift / (wp.i - wm.i);
     wp.c -= change;
     wp.s += shift;
     wm.c += change;
     wp.z += shift;
     wp.m += shift;
 }
 
-function executeShifts(v2) {
+function executeShifts2(v3) {
     var shift = 0,
         change = 0,
-        children2 = v2.children,
-        i = children2.length,
+        children3 = v3.children,
+        i = children3.length,
         w;
     while (--i >= 0) {
-        w = children2[i];
+        w = children3[i];
         w.z += shift;
         w.m += shift;
         shift += w.s + (change += w.c);
     }
 }
 
-function nextAncestor(vim, v2, ancestor) {
-    return vim.a.parent === v2.parent ? vim.a : ancestor;
+function nextAncestor2(vim, v3, ancestor) {
+    return vim.a.parent === v3.parent ? vim.a : ancestor;
 }
 
-function TreeNode(node, i) {
+function TreeNode2(node, i) {
     this._ = node;
     this.parent = null;
     this.children = null;
     this.A = null;
     this.a = this;
     this.z = 0;
     this.m = 0;
     this.c = 0;
     this.s = 0;
     this.t = null;
     this.i = i;
 }
-TreeNode.prototype = Object.create(Node2.prototype);
+TreeNode2.prototype = Object.create(Node4.prototype);
 
-function treeRoot(root3) {
-    var tree2 = new TreeNode(root3, 0),
-        node, nodes = [tree2],
-        child, children2, i, n;
+function treeRoot2(root5) {
+    var tree3 = new TreeNode2(root5, 0),
+        node, nodes = [tree3],
+        child, children3, i, n;
     while (node = nodes.pop()) {
-        if (children2 = node._.children) {
-            node.children = new Array(n = children2.length);
+        if (children3 = node._.children) {
+            node.children = new Array(n = children3.length);
             for (i = n - 1; i >= 0; --i) {
-                nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
+                nodes.push(child = node.children[i] = new TreeNode2(children3[i], i));
                 child.parent = node;
             }
         }
     }
-    (tree2.parent = new TreeNode(null, 0)).children = [tree2];
-    return tree2;
+    (tree3.parent = new TreeNode2(null, 0)).children = [tree3];
+    return tree3;
 }
 
-function tree_default() {
-    var separation = defaultSeparation2,
+function tree_default2() {
+    var separation = defaultSeparation4,
         dx = 1,
         dy = 1,
         nodeSize = null;
 
-    function tree2(root3) {
-        var t = treeRoot(root3);
+    function tree3(root5) {
+        var t = treeRoot2(root5);
         t.eachAfter(firstWalk), t.parent.m = -t.z;
         t.eachBefore(secondWalk);
         if (nodeSize)
-            root3.eachBefore(sizeNode);
+            root5.eachBefore(sizeNode);
         else {
-            var left2 = root3,
-                right2 = root3,
-                bottom2 = root3;
-            root3.eachBefore(function(node) {
-                if (node.x < left2.x)
-                    left2 = node;
-                if (node.x > right2.x)
-                    right2 = node;
-                if (node.depth > bottom2.depth)
-                    bottom2 = node;
-            });
-            var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2,
-                tx = s2 - left2.x,
-                kx2 = dx / (right2.x + s2 + tx),
-                ky2 = dy / (bottom2.depth || 1);
-            root3.eachBefore(function(node) {
-                node.x = (node.x + tx) * kx2;
-                node.y = node.depth * ky2;
-            });
-        }
-        return root3;
-    }
-
-    function firstWalk(v2) {
-        var children2 = v2.children,
-            siblings = v2.parent.children,
-            w = v2.i ? siblings[v2.i - 1] : null;
-        if (children2) {
-            executeShifts(v2);
-            var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
+            var left3 = root5,
+                right3 = root5,
+                bottom3 = root5;
+            root5.eachBefore(function(node) {
+                if (node.x < left3.x)
+                    left3 = node;
+                if (node.x > right3.x)
+                    right3 = node;
+                if (node.depth > bottom3.depth)
+                    bottom3 = node;
+            });
+            var s3 = left3 === right3 ? 1 : separation(left3, right3) / 2,
+                tx = s3 - left3.x,
+                kx3 = dx / (right3.x + s3 + tx),
+                ky3 = dy / (bottom3.depth || 1);
+            root5.eachBefore(function(node) {
+                node.x = (node.x + tx) * kx3;
+                node.y = node.depth * ky3;
+            });
+        }
+        return root5;
+    }
+
+    function firstWalk(v3) {
+        var children3 = v3.children,
+            siblings = v3.parent.children,
+            w = v3.i ? siblings[v3.i - 1] : null;
+        if (children3) {
+            executeShifts2(v3);
+            var midpoint = (children3[0].z + children3[children3.length - 1].z) / 2;
             if (w) {
-                v2.z = w.z + separation(v2._, w._);
-                v2.m = v2.z - midpoint;
+                v3.z = w.z + separation(v3._, w._);
+                v3.m = v3.z - midpoint;
             } else {
-                v2.z = midpoint;
+                v3.z = midpoint;
             }
         } else if (w) {
-            v2.z = w.z + separation(v2._, w._);
+            v3.z = w.z + separation(v3._, w._);
         }
-        v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);
+        v3.parent.A = apportion(v3, w, v3.parent.A || siblings[0]);
     }
 
-    function secondWalk(v2) {
-        v2._.x = v2.z + v2.parent.m;
-        v2.m += v2.parent.m;
+    function secondWalk(v3) {
+        v3._.x = v3.z + v3.parent.m;
+        v3.m += v3.parent.m;
     }
 
-    function apportion(v2, w, ancestor) {
+    function apportion(v3, w, ancestor) {
         if (w) {
-            var vip = v2,
-                vop = v2,
+            var vip = v3,
+                vop = v3,
                 vim = w,
                 vom = vip.parent.children[0],
                 sip = vip.m,
                 sop = vop.m,
                 sim = vim.m,
                 som = vom.m,
                 shift;
-            while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
-                vom = nextLeft(vom);
-                vop = nextRight(vop);
-                vop.a = v2;
+            while (vim = nextRight2(vim), vip = nextLeft2(vip), vim && vip) {
+                vom = nextLeft2(vom);
+                vop = nextRight2(vop);
+                vop.a = v3;
                 shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                 if (shift > 0) {
-                    moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
+                    moveSubtree2(nextAncestor2(vim, v3, ancestor), v3, shift);
                     sip += shift;
                     sop += shift;
                 }
                 sim += vim.m;
                 sip += vip.m;
                 som += vom.m;
                 sop += vop.m;
             }
-            if (vim && !nextRight(vop)) {
+            if (vim && !nextRight2(vop)) {
                 vop.t = vim;
                 vop.m += sim - sop;
             }
-            if (vip && !nextLeft(vom)) {
+            if (vip && !nextLeft2(vom)) {
                 vom.t = vip;
                 vom.m += sip - som;
-                ancestor = v2;
+                ancestor = v3;
             }
         }
         return ancestor;
     }
 
     function sizeNode(node) {
         node.x *= dx;
         node.y = node.depth * dy;
     }
-    tree2.separation = function(x4) {
-        return arguments.length ? (separation = x4, tree2) : separation;
+    tree3.separation = function(x7) {
+        return arguments.length ? (separation = x7, tree3) : separation;
     };
-    tree2.size = function(x4) {
-        return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? null : [dx, dy];
+    tree3.size = function(x7) {
+        return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], tree3) : nodeSize ? null : [dx, dy];
     };
-    tree2.nodeSize = function(x4) {
-        return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? [dx, dy] : null;
+    tree3.nodeSize = function(x7) {
+        return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], tree3) : nodeSize ? [dx, dy] : null;
     };
-    return tree2;
+    return tree3;
 }
 
-// node_modules/d3-hierarchy/src/treemap/slice.js
-function slice_default(parent, x06, y06, x12, y12) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/slice.js
+function slice_default2(parent, x011, y011, x13, y13) {
     var nodes = parent.children,
         node, i = -1,
         n = nodes.length,
-        k2 = parent.value && (y12 - y06) / parent.value;
+        k3 = parent.value && (y13 - y011) / parent.value;
     while (++i < n) {
-        node = nodes[i], node.x0 = x06, node.x1 = x12;
-        node.y0 = y06, node.y1 = y06 += node.value * k2;
+        node = nodes[i], node.x0 = x011, node.x1 = x13;
+        node.y0 = y011, node.y1 = y011 += node.value * k3;
     }
 }
 
-// node_modules/d3-hierarchy/src/treemap/squarify.js
-var phi = (1 + Math.sqrt(5)) / 2;
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/squarify.js
+var phi2 = (1 + Math.sqrt(5)) / 2;
 
-function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
+function squarifyRatio2(ratio, parent, x011, y011, x13, y13) {
     var rows = [],
         nodes = parent.children,
         row, nodeValue, i0 = 0,
         i1 = 0,
         n = nodes.length,
         dx, dy, value = parent.value,
         sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
     while (i0 < n) {
-        dx = x12 - x06, dy = y12 - y06;
+        dx = x13 - x011, dy = y13 - y011;
         do
             sumValue = nodes[i1++].value;
         while (!sumValue && i1 < n);
         minValue = maxValue = sumValue;
         alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
         beta = sumValue * sumValue * alpha;
         minRatio = Math.max(maxValue / beta, beta / minValue);
@@ -15724,289 +50430,289 @@
         }
         rows.push(row = {
             value: sumValue,
             dice: dx < dy,
             children: nodes.slice(i0, i1)
         });
         if (row.dice)
-            dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);
+            dice_default2(row, x011, y011, x13, value ? y011 += dy * sumValue / value : y13);
         else
-            slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);
+            slice_default2(row, x011, y011, value ? x011 += dx * sumValue / value : x13, y13);
         value -= sumValue, i0 = i1;
     }
     return rows;
 }
-var squarify_default = function custom10(ratio) {
-    function squarify(parent, x06, y06, x12, y12) {
-        squarifyRatio(ratio, parent, x06, y06, x12, y12);
+var squarify_default2 = function custom28(ratio) {
+    function squarify(parent, x011, y011, x13, y13) {
+        squarifyRatio2(ratio, parent, x011, y011, x13, y13);
     }
-    squarify.ratio = function(x4) {
-        return custom10((x4 = +x4) > 1 ? x4 : 1);
+    squarify.ratio = function(x7) {
+        return custom28((x7 = +x7) > 1 ? x7 : 1);
     };
     return squarify;
-}(phi);
+}(phi2);
 
-// node_modules/d3-hierarchy/src/treemap/index.js
-function treemap_default() {
-    var tile = squarify_default,
-        round2 = false,
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/index.js
+function treemap_default2() {
+    var tile = squarify_default2,
+        round3 = false,
         dx = 1,
         dy = 1,
         paddingStack = [0],
-        paddingInner = constantZero,
-        paddingTop = constantZero,
-        paddingRight = constantZero,
-        paddingBottom = constantZero,
-        paddingLeft = constantZero;
-
-    function treemap(root3) {
-        root3.x0 = root3.y0 = 0;
-        root3.x1 = dx;
-        root3.y1 = dy;
-        root3.eachBefore(positionNode);
+        paddingInner = constantZero2,
+        paddingTop = constantZero2,
+        paddingRight = constantZero2,
+        paddingBottom = constantZero2,
+        paddingLeft = constantZero2;
+
+    function treemap(root5) {
+        root5.x0 = root5.y0 = 0;
+        root5.x1 = dx;
+        root5.y1 = dy;
+        root5.eachBefore(positionNode);
         paddingStack = [0];
-        if (round2)
-            root3.eachBefore(round_default2);
-        return root3;
+        if (round3)
+            root5.eachBefore(round_default4);
+        return root5;
     }
 
     function positionNode(node) {
         var p = paddingStack[node.depth],
-            x06 = node.x0 + p,
-            y06 = node.y0 + p,
-            x12 = node.x1 - p,
-            y12 = node.y1 - p;
-        if (x12 < x06)
-            x06 = x12 = (x06 + x12) / 2;
-        if (y12 < y06)
-            y06 = y12 = (y06 + y12) / 2;
-        node.x0 = x06;
-        node.y0 = y06;
-        node.x1 = x12;
-        node.y1 = y12;
+            x011 = node.x0 + p,
+            y011 = node.y0 + p,
+            x13 = node.x1 - p,
+            y13 = node.y1 - p;
+        if (x13 < x011)
+            x011 = x13 = (x011 + x13) / 2;
+        if (y13 < y011)
+            y011 = y13 = (y011 + y13) / 2;
+        node.x0 = x011;
+        node.y0 = y011;
+        node.x1 = x13;
+        node.y1 = y13;
         if (node.children) {
             p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
-            x06 += paddingLeft(node) - p;
-            y06 += paddingTop(node) - p;
-            x12 -= paddingRight(node) - p;
-            y12 -= paddingBottom(node) - p;
-            if (x12 < x06)
-                x06 = x12 = (x06 + x12) / 2;
-            if (y12 < y06)
-                y06 = y12 = (y06 + y12) / 2;
-            tile(node, x06, y06, x12, y12);
+            x011 += paddingLeft(node) - p;
+            y011 += paddingTop(node) - p;
+            x13 -= paddingRight(node) - p;
+            y13 -= paddingBottom(node) - p;
+            if (x13 < x011)
+                x011 = x13 = (x011 + x13) / 2;
+            if (y13 < y011)
+                y011 = y13 = (y011 + y13) / 2;
+            tile(node, x011, y011, x13, y13);
         }
     }
-    treemap.round = function(x4) {
-        return arguments.length ? (round2 = !!x4, treemap) : round2;
+    treemap.round = function(x7) {
+        return arguments.length ? (round3 = !!x7, treemap) : round3;
     };
-    treemap.size = function(x4) {
-        return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
+    treemap.size = function(x7) {
+        return arguments.length ? (dx = +x7[0], dy = +x7[1], treemap) : [dx, dy];
     };
-    treemap.tile = function(x4) {
-        return arguments.length ? (tile = required(x4), treemap) : tile;
+    treemap.tile = function(x7) {
+        return arguments.length ? (tile = required2(x7), treemap) : tile;
     };
-    treemap.padding = function(x4) {
-        return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
+    treemap.padding = function(x7) {
+        return arguments.length ? treemap.paddingInner(x7).paddingOuter(x7) : treemap.paddingInner();
     };
-    treemap.paddingInner = function(x4) {
-        return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingInner;
+    treemap.paddingInner = function(x7) {
+        return arguments.length ? (paddingInner = typeof x7 === "function" ? x7 : constant_default20(+x7), treemap) : paddingInner;
     };
-    treemap.paddingOuter = function(x4) {
-        return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
+    treemap.paddingOuter = function(x7) {
+        return arguments.length ? treemap.paddingTop(x7).paddingRight(x7).paddingBottom(x7).paddingLeft(x7) : treemap.paddingTop();
     };
-    treemap.paddingTop = function(x4) {
-        return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingTop;
+    treemap.paddingTop = function(x7) {
+        return arguments.length ? (paddingTop = typeof x7 === "function" ? x7 : constant_default20(+x7), treemap) : paddingTop;
     };
-    treemap.paddingRight = function(x4) {
-        return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingRight;
+    treemap.paddingRight = function(x7) {
+        return arguments.length ? (paddingRight = typeof x7 === "function" ? x7 : constant_default20(+x7), treemap) : paddingRight;
     };
-    treemap.paddingBottom = function(x4) {
-        return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingBottom;
+    treemap.paddingBottom = function(x7) {
+        return arguments.length ? (paddingBottom = typeof x7 === "function" ? x7 : constant_default20(+x7), treemap) : paddingBottom;
     };
-    treemap.paddingLeft = function(x4) {
-        return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingLeft;
+    treemap.paddingLeft = function(x7) {
+        return arguments.length ? (paddingLeft = typeof x7 === "function" ? x7 : constant_default20(+x7), treemap) : paddingLeft;
     };
     return treemap;
 }
 
-// node_modules/d3-hierarchy/src/treemap/binary.js
-function binary_default(parent, x06, y06, x12, y12) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/binary.js
+function binary_default2(parent, x011, y011, x13, y13) {
     var nodes = parent.children,
         i, n = nodes.length,
-        sum5, sums = new Array(n + 1);
-    for (sums[0] = sum5 = i = 0; i < n; ++i) {
-        sums[i + 1] = sum5 += nodes[i].value;
+        sum8, sums = new Array(n + 1);
+    for (sums[0] = sum8 = i = 0; i < n; ++i) {
+        sums[i + 1] = sum8 += nodes[i].value;
     }
-    partition(0, n, parent.value, x06, y06, x12, y12);
+    partition(0, n, parent.value, x011, y011, x13, y13);
 
-    function partition(i2, j, value, x07, y07, x13, y13) {
+    function partition(i2, j, value, x012, y012, x14, y14) {
         if (i2 >= j - 1) {
             var node = nodes[i2];
-            node.x0 = x07, node.y0 = y07;
-            node.x1 = x13, node.y1 = y13;
+            node.x0 = x012, node.y0 = y012;
+            node.x1 = x14, node.y1 = y14;
             return;
         }
         var valueOffset = sums[i2],
             valueTarget = value / 2 + valueOffset,
-            k2 = i2 + 1,
+            k3 = i2 + 1,
             hi = j - 1;
-        while (k2 < hi) {
-            var mid2 = k2 + hi >>> 1;
-            if (sums[mid2] < valueTarget)
-                k2 = mid2 + 1;
+        while (k3 < hi) {
+            var mid3 = k3 + hi >>> 1;
+            if (sums[mid3] < valueTarget)
+                k3 = mid3 + 1;
             else
-                hi = mid2;
+                hi = mid3;
         }
-        if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
-            --k2;
-        var valueLeft = sums[k2] - valueOffset,
+        if (valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3)
+            --k3;
+        var valueLeft = sums[k3] - valueOffset,
             valueRight = value - valueLeft;
-        if (x13 - x07 > y13 - y07) {
-            var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;
-            partition(i2, k2, valueLeft, x07, y07, xk, y13);
-            partition(k2, j, valueRight, xk, y07, x13, y13);
-        } else {
-            var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;
-            partition(i2, k2, valueLeft, x07, y07, x13, yk);
-            partition(k2, j, valueRight, x07, yk, x13, y13);
+        if (x14 - x012 > y14 - y012) {
+            var xk = value ? (x012 * valueRight + x14 * valueLeft) / value : x14;
+            partition(i2, k3, valueLeft, x012, y012, xk, y14);
+            partition(k3, j, valueRight, xk, y012, x14, y14);
+        } else {
+            var yk = value ? (y012 * valueRight + y14 * valueLeft) / value : y14;
+            partition(i2, k3, valueLeft, x012, y012, x14, yk);
+            partition(k3, j, valueRight, x012, yk, x14, y14);
         }
     }
 }
 
-// node_modules/d3-hierarchy/src/treemap/sliceDice.js
-function sliceDice_default(parent, x06, y06, x12, y12) {
-    (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/sliceDice.js
+function sliceDice_default2(parent, x011, y011, x13, y13) {
+    (parent.depth & 1 ? slice_default2 : dice_default2)(parent, x011, y011, x13, y13);
 }
 
-// node_modules/d3-hierarchy/src/treemap/resquarify.js
-var resquarify_default = function custom11(ratio) {
-    function resquarify(parent, x06, y06, x12, y12) {
+// js/pyobsplot-js/node_modules/d3-hierarchy/src/treemap/resquarify.js
+var resquarify_default2 = function custom29(ratio) {
+    function resquarify(parent, x011, y011, x13, y13) {
         if ((rows = parent._squarify) && rows.ratio === ratio) {
             var rows, row, nodes, i, j = -1,
-                n, m3 = rows.length,
+                n, m5 = rows.length,
                 value = parent.value;
-            while (++j < m3) {
+            while (++j < m5) {
                 row = rows[j], nodes = row.children;
                 for (i = row.value = 0, n = nodes.length; i < n; ++i)
                     row.value += nodes[i].value;
                 if (row.dice)
-                    dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);
+                    dice_default2(row, x011, y011, x13, value ? y011 += (y13 - y011) * row.value / value : y13);
                 else
-                    slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);
+                    slice_default2(row, x011, y011, value ? x011 += (x13 - x011) * row.value / value : x13, y13);
                 value -= row.value;
             }
         } else {
-            parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
+            parent._squarify = rows = squarifyRatio2(ratio, parent, x011, y011, x13, y13);
             rows.ratio = ratio;
         }
     }
-    resquarify.ratio = function(x4) {
-        return custom11((x4 = +x4) > 1 ? x4 : 1);
+    resquarify.ratio = function(x7) {
+        return custom29((x7 = +x7) > 1 ? x7 : 1);
     };
     return resquarify;
-}(phi);
+}(phi2);
 
-// node_modules/d3-polygon/src/area.js
-function area_default4(polygon) {
+// js/pyobsplot-js/node_modules/d3-polygon/src/area.js
+function area_default9(polygon) {
     var i = -1,
         n = polygon.length,
-        a4, b = polygon[n - 1],
-        area2 = 0;
+        a7, b = polygon[n - 1],
+        area3 = 0;
     while (++i < n) {
-        a4 = b;
+        a7 = b;
         b = polygon[i];
-        area2 += a4[1] * b[0] - a4[0] * b[1];
+        area3 += a7[1] * b[0] - a7[0] * b[1];
     }
-    return area2 / 2;
+    return area3 / 2;
 }
 
-// node_modules/d3-polygon/src/centroid.js
-function centroid_default3(polygon) {
+// js/pyobsplot-js/node_modules/d3-polygon/src/centroid.js
+function centroid_default6(polygon) {
     var i = -1,
         n = polygon.length,
-        x4 = 0,
-        y4 = 0,
-        a4, b = polygon[n - 1],
-        c6, k2 = 0;
+        x7 = 0,
+        y7 = 0,
+        a7, b = polygon[n - 1],
+        c11, k3 = 0;
     while (++i < n) {
-        a4 = b;
+        a7 = b;
         b = polygon[i];
-        k2 += c6 = a4[0] * b[1] - b[0] * a4[1];
-        x4 += (a4[0] + b[0]) * c6;
-        y4 += (a4[1] + b[1]) * c6;
+        k3 += c11 = a7[0] * b[1] - b[0] * a7[1];
+        x7 += (a7[0] + b[0]) * c11;
+        y7 += (a7[1] + b[1]) * c11;
     }
-    return k2 *= 3, [x4 / k2, y4 / k2];
+    return k3 *= 3, [x7 / k3, y7 / k3];
 }
 
-// node_modules/d3-polygon/src/cross.js
-function cross_default(a4, b, c6) {
-    return (b[0] - a4[0]) * (c6[1] - a4[1]) - (b[1] - a4[1]) * (c6[0] - a4[0]);
+// js/pyobsplot-js/node_modules/d3-polygon/src/cross.js
+function cross_default3(a7, b, c11) {
+    return (b[0] - a7[0]) * (c11[1] - a7[1]) - (b[1] - a7[1]) * (c11[0] - a7[0]);
 }
 
-// node_modules/d3-polygon/src/hull.js
-function lexicographicOrder(a4, b) {
-    return a4[0] - b[0] || a4[1] - b[1];
+// js/pyobsplot-js/node_modules/d3-polygon/src/hull.js
+function lexicographicOrder2(a7, b) {
+    return a7[0] - b[0] || a7[1] - b[1];
 }
 
-function computeUpperHullIndexes(points) {
+function computeUpperHullIndexes2(points) {
     const n = points.length,
-        indexes2 = [0, 1];
+        indexes3 = [0, 1];
     let size = 2,
         i;
     for (i = 2; i < n; ++i) {
-        while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)
+        while (size > 1 && cross_default3(points[indexes3[size - 2]], points[indexes3[size - 1]], points[i]) <= 0)
             --size;
-        indexes2[size++] = i;
+        indexes3[size++] = i;
     }
-    return indexes2.slice(0, size);
+    return indexes3.slice(0, size);
 }
 
-function hull_default(points) {
+function hull_default2(points) {
     if ((n = points.length) < 3)
         return null;
     var i, n, sortedPoints = new Array(n),
         flippedPoints = new Array(n);
     for (i = 0; i < n; ++i)
         sortedPoints[i] = [+points[i][0], +points[i][1], i];
-    sortedPoints.sort(lexicographicOrder);
+    sortedPoints.sort(lexicographicOrder2);
     for (i = 0; i < n; ++i)
         flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
-    var upperIndexes = computeUpperHullIndexes(sortedPoints),
-        lowerIndexes = computeUpperHullIndexes(flippedPoints);
+    var upperIndexes = computeUpperHullIndexes2(sortedPoints),
+        lowerIndexes = computeUpperHullIndexes2(flippedPoints);
     var skipLeft = lowerIndexes[0] === upperIndexes[0],
         skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
-        hull2 = [];
+        hull3 = [];
     for (i = upperIndexes.length - 1; i >= 0; --i)
-        hull2.push(points[sortedPoints[upperIndexes[i]][2]]);
+        hull3.push(points[sortedPoints[upperIndexes[i]][2]]);
     for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
-        hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);
-    return hull2;
+        hull3.push(points[sortedPoints[lowerIndexes[i]][2]]);
+    return hull3;
 }
 
-// node_modules/d3-polygon/src/contains.js
-function contains_default3(polygon, point6) {
+// js/pyobsplot-js/node_modules/d3-polygon/src/contains.js
+function contains_default6(polygon, point11) {
     var n = polygon.length,
         p = polygon[n - 1],
-        x4 = point6[0],
-        y4 = point6[1],
-        x06 = p[0],
-        y06 = p[1],
-        x12, y12, inside = false;
+        x7 = point11[0],
+        y7 = point11[1],
+        x011 = p[0],
+        y011 = p[1],
+        x13, y13, inside = false;
     for (var i = 0; i < n; ++i) {
-        p = polygon[i], x12 = p[0], y12 = p[1];
-        if (y12 > y4 !== y06 > y4 && x4 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12)
+        p = polygon[i], x13 = p[0], y13 = p[1];
+        if (y13 > y7 !== y011 > y7 && x7 < (x011 - x13) * (y7 - y13) / (y011 - y13) + x13)
             inside = !inside;
-        x06 = x12, y06 = y12;
+        x011 = x13, y011 = y13;
     }
     return inside;
 }
 
-// node_modules/d3-polygon/src/length.js
-function length_default2(polygon) {
+// js/pyobsplot-js/node_modules/d3-polygon/src/length.js
+function length_default4(polygon) {
     var i = -1,
         n = polygon.length,
         b = polygon[n - 1],
         xa, ya, xb = b[0],
         yb = b[1],
         perimeter = 0;
     while (++i < n) {
@@ -16018,358 +50724,358 @@
         xa -= xb;
         ya -= yb;
         perimeter += Math.hypot(xa, ya);
     }
     return perimeter;
 }
 
-// node_modules/d3-random/src/defaultSource.js
-var defaultSource_default = Math.random;
+// js/pyobsplot-js/node_modules/d3-random/src/defaultSource.js
+var defaultSource_default2 = Math.random;
 
-// node_modules/d3-random/src/uniform.js
-var uniform_default = function sourceRandomUniform(source) {
-    function randomUniform(min4, max5) {
-        min4 = min4 == null ? 0 : +min4;
-        max5 = max5 == null ? 1 : +max5;
+// js/pyobsplot-js/node_modules/d3-random/src/uniform.js
+var uniform_default2 = function sourceRandomUniform2(source) {
+    function randomUniform(min7, max9) {
+        min7 = min7 == null ? 0 : +min7;
+        max9 = max9 == null ? 1 : +max9;
         if (arguments.length === 1)
-            max5 = min4, min4 = 0;
+            max9 = min7, min7 = 0;
         else
-            max5 -= min4;
+            max9 -= min7;
         return function() {
-            return source() * max5 + min4;
+            return source() * max9 + min7;
         };
     }
-    randomUniform.source = sourceRandomUniform;
+    randomUniform.source = sourceRandomUniform2;
     return randomUniform;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/int.js
-var int_default = function sourceRandomInt(source) {
-    function randomInt(min4, max5) {
+// js/pyobsplot-js/node_modules/d3-random/src/int.js
+var int_default2 = function sourceRandomInt2(source) {
+    function randomInt(min7, max9) {
         if (arguments.length < 2)
-            max5 = min4, min4 = 0;
-        min4 = Math.floor(min4);
-        max5 = Math.floor(max5) - min4;
+            max9 = min7, min7 = 0;
+        min7 = Math.floor(min7);
+        max9 = Math.floor(max9) - min7;
         return function() {
-            return Math.floor(source() * max5 + min4);
+            return Math.floor(source() * max9 + min7);
         };
     }
-    randomInt.source = sourceRandomInt;
+    randomInt.source = sourceRandomInt2;
     return randomInt;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/normal.js
-var normal_default = function sourceRandomNormal(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/normal.js
+var normal_default2 = function sourceRandomNormal2(source) {
     function randomNormal(mu, sigma) {
-        var x4, r;
+        var x7, r;
         mu = mu == null ? 0 : +mu;
         sigma = sigma == null ? 1 : +sigma;
         return function() {
-            var y4;
-            if (x4 != null)
-                y4 = x4, x4 = null;
+            var y7;
+            if (x7 != null)
+                y7 = x7, x7 = null;
             else
                 do {
-                    x4 = source() * 2 - 1;
-                    y4 = source() * 2 - 1;
-                    r = x4 * x4 + y4 * y4;
+                    x7 = source() * 2 - 1;
+                    y7 = source() * 2 - 1;
+                    r = x7 * x7 + y7 * y7;
                 } while (!r || r > 1);
-            return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);
+            return mu + sigma * y7 * Math.sqrt(-2 * Math.log(r) / r);
         };
     }
-    randomNormal.source = sourceRandomNormal;
+    randomNormal.source = sourceRandomNormal2;
     return randomNormal;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/logNormal.js
-var logNormal_default = function sourceRandomLogNormal(source) {
-    var N = normal_default.source(source);
+// js/pyobsplot-js/node_modules/d3-random/src/logNormal.js
+var logNormal_default2 = function sourceRandomLogNormal2(source) {
+    var N = normal_default2.source(source);
 
     function randomLogNormal() {
         var randomNormal = N.apply(this, arguments);
         return function() {
             return Math.exp(randomNormal());
         };
     }
-    randomLogNormal.source = sourceRandomLogNormal;
+    randomLogNormal.source = sourceRandomLogNormal2;
     return randomLogNormal;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/irwinHall.js
-var irwinHall_default = function sourceRandomIrwinHall(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/irwinHall.js
+var irwinHall_default2 = function sourceRandomIrwinHall2(source) {
     function randomIrwinHall(n) {
         if ((n = +n) <= 0)
             return () => 0;
         return function() {
-            for (var sum5 = 0, i = n; i > 1; --i)
-                sum5 += source();
-            return sum5 + i * source();
+            for (var sum8 = 0, i = n; i > 1; --i)
+                sum8 += source();
+            return sum8 + i * source();
         };
     }
-    randomIrwinHall.source = sourceRandomIrwinHall;
+    randomIrwinHall.source = sourceRandomIrwinHall2;
     return randomIrwinHall;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/bates.js
-var bates_default = function sourceRandomBates(source) {
-    var I = irwinHall_default.source(source);
+// js/pyobsplot-js/node_modules/d3-random/src/bates.js
+var bates_default2 = function sourceRandomBates2(source) {
+    var I = irwinHall_default2.source(source);
 
     function randomBates(n) {
         if ((n = +n) === 0)
             return source;
         var randomIrwinHall = I(n);
         return function() {
             return randomIrwinHall() / n;
         };
     }
-    randomBates.source = sourceRandomBates;
+    randomBates.source = sourceRandomBates2;
     return randomBates;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/exponential.js
-var exponential_default = function sourceRandomExponential(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/exponential.js
+var exponential_default2 = function sourceRandomExponential2(source) {
     function randomExponential(lambda) {
         return function() {
             return -Math.log1p(-source()) / lambda;
         };
     }
-    randomExponential.source = sourceRandomExponential;
+    randomExponential.source = sourceRandomExponential2;
     return randomExponential;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/pareto.js
-var pareto_default = function sourceRandomPareto(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/pareto.js
+var pareto_default2 = function sourceRandomPareto2(source) {
     function randomPareto(alpha) {
         if ((alpha = +alpha) < 0)
             throw new RangeError("invalid alpha");
         alpha = 1 / -alpha;
         return function() {
             return Math.pow(1 - source(), alpha);
         };
     }
-    randomPareto.source = sourceRandomPareto;
+    randomPareto.source = sourceRandomPareto2;
     return randomPareto;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/bernoulli.js
-var bernoulli_default = function sourceRandomBernoulli(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/bernoulli.js
+var bernoulli_default2 = function sourceRandomBernoulli2(source) {
     function randomBernoulli(p) {
         if ((p = +p) < 0 || p > 1)
             throw new RangeError("invalid p");
         return function() {
             return Math.floor(source() + p);
         };
     }
-    randomBernoulli.source = sourceRandomBernoulli;
+    randomBernoulli.source = sourceRandomBernoulli2;
     return randomBernoulli;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/geometric.js
-var geometric_default = function sourceRandomGeometric(source) {
+// js/pyobsplot-js/node_modules/d3-random/src/geometric.js
+var geometric_default2 = function sourceRandomGeometric2(source) {
     function randomGeometric(p) {
         if ((p = +p) < 0 || p > 1)
             throw new RangeError("invalid p");
         if (p === 0)
             return () => Infinity;
         if (p === 1)
             return () => 1;
         p = Math.log1p(-p);
         return function() {
             return 1 + Math.floor(Math.log1p(-source()) / p);
         };
     }
-    randomGeometric.source = sourceRandomGeometric;
+    randomGeometric.source = sourceRandomGeometric2;
     return randomGeometric;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/gamma.js
-var gamma_default = function sourceRandomGamma(source) {
-    var randomNormal = normal_default.source(source)();
+// js/pyobsplot-js/node_modules/d3-random/src/gamma.js
+var gamma_default2 = function sourceRandomGamma2(source) {
+    var randomNormal = normal_default2.source(source)();
 
-    function randomGamma(k2, theta) {
-        if ((k2 = +k2) < 0)
+    function randomGamma(k3, theta) {
+        if ((k3 = +k3) < 0)
             throw new RangeError("invalid k");
-        if (k2 === 0)
+        if (k3 === 0)
             return () => 0;
         theta = theta == null ? 1 : +theta;
-        if (k2 === 1)
+        if (k3 === 1)
             return () => -Math.log1p(-source()) * theta;
-        var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3,
-            c6 = 1 / (3 * Math.sqrt(d)),
-            multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
+        var d = (k3 < 1 ? k3 + 1 : k3) - 1 / 3,
+            c11 = 1 / (3 * Math.sqrt(d)),
+            multiplier = k3 < 1 ? () => Math.pow(source(), 1 / k3) : () => 1;
         return function() {
             do {
                 do {
-                    var x4 = randomNormal(),
-                        v2 = 1 + c6 * x4;
-                } while (v2 <= 0);
-                v2 *= v2 * v2;
-                var u4 = 1 - source();
-            } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));
-            return d * v2 * multiplier() * theta;
+                    var x7 = randomNormal(),
+                        v3 = 1 + c11 * x7;
+                } while (v3 <= 0);
+                v3 *= v3 * v3;
+                var u7 = 1 - source();
+            } while (u7 >= 1 - 0.0331 * x7 * x7 * x7 * x7 && Math.log(u7) >= 0.5 * x7 * x7 + d * (1 - v3 + Math.log(v3)));
+            return d * v3 * multiplier() * theta;
         };
     }
-    randomGamma.source = sourceRandomGamma;
+    randomGamma.source = sourceRandomGamma2;
     return randomGamma;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/beta.js
-var beta_default = function sourceRandomBeta(source) {
-    var G = gamma_default.source(source);
+// js/pyobsplot-js/node_modules/d3-random/src/beta.js
+var beta_default2 = function sourceRandomBeta2(source) {
+    var G = gamma_default2.source(source);
 
     function randomBeta(alpha, beta) {
-        var X3 = G(alpha),
-            Y3 = G(beta);
+        var X4 = G(alpha),
+            Y4 = G(beta);
         return function() {
-            var x4 = X3();
-            return x4 === 0 ? 0 : x4 / (x4 + Y3());
+            var x7 = X4();
+            return x7 === 0 ? 0 : x7 / (x7 + Y4());
         };
     }
-    randomBeta.source = sourceRandomBeta;
+    randomBeta.source = sourceRandomBeta2;
     return randomBeta;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/binomial.js
-var binomial_default = function sourceRandomBinomial(source) {
-    var G = geometric_default.source(source),
-        B3 = beta_default.source(source);
+// js/pyobsplot-js/node_modules/d3-random/src/binomial.js
+var binomial_default2 = function sourceRandomBinomial2(source) {
+    var G = geometric_default2.source(source),
+        B5 = beta_default2.source(source);
 
     function randomBinomial(n, p) {
         n = +n;
         if ((p = +p) >= 1)
             return () => n;
         if (p <= 0)
             return () => 0;
         return function() {
             var acc = 0,
                 nn = n,
                 pp = p;
             while (nn * pp > 16 && nn * (1 - pp) > 16) {
                 var i = Math.floor((nn + 1) * pp),
-                    y4 = B3(i, nn - i + 1)();
-                if (y4 <= pp) {
+                    y7 = B5(i, nn - i + 1)();
+                if (y7 <= pp) {
                     acc += i;
                     nn -= i;
-                    pp = (pp - y4) / (1 - y4);
+                    pp = (pp - y7) / (1 - y7);
                 } else {
                     nn = i - 1;
-                    pp /= y4;
+                    pp /= y7;
                 }
             }
-            var sign3 = pp < 0.5,
-                pFinal = sign3 ? pp : 1 - pp,
+            var sign5 = pp < 0.5,
+                pFinal = sign5 ? pp : 1 - pp,
                 g = G(pFinal);
-            for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)
-                s2 += g();
-            return acc + (sign3 ? k2 : nn - k2);
+            for (var s3 = g(), k3 = 0; s3 <= nn; ++k3)
+                s3 += g();
+            return acc + (sign5 ? k3 : nn - k3);
         };
     }
-    randomBinomial.source = sourceRandomBinomial;
+    randomBinomial.source = sourceRandomBinomial2;
     return randomBinomial;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/weibull.js
-var weibull_default = function sourceRandomWeibull(source) {
-    function randomWeibull(k2, a4, b) {
+// js/pyobsplot-js/node_modules/d3-random/src/weibull.js
+var weibull_default2 = function sourceRandomWeibull2(source) {
+    function randomWeibull(k3, a7, b) {
         var outerFunc;
-        if ((k2 = +k2) === 0) {
-            outerFunc = (x4) => -Math.log(x4);
+        if ((k3 = +k3) === 0) {
+            outerFunc = (x7) => -Math.log(x7);
         } else {
-            k2 = 1 / k2;
-            outerFunc = (x4) => Math.pow(x4, k2);
+            k3 = 1 / k3;
+            outerFunc = (x7) => Math.pow(x7, k3);
         }
-        a4 = a4 == null ? 0 : +a4;
+        a7 = a7 == null ? 0 : +a7;
         b = b == null ? 1 : +b;
         return function() {
-            return a4 + b * outerFunc(-Math.log1p(-source()));
+            return a7 + b * outerFunc(-Math.log1p(-source()));
         };
     }
-    randomWeibull.source = sourceRandomWeibull;
+    randomWeibull.source = sourceRandomWeibull2;
     return randomWeibull;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/cauchy.js
-var cauchy_default = function sourceRandomCauchy(source) {
-    function randomCauchy(a4, b) {
-        a4 = a4 == null ? 0 : +a4;
+// js/pyobsplot-js/node_modules/d3-random/src/cauchy.js
+var cauchy_default2 = function sourceRandomCauchy2(source) {
+    function randomCauchy(a7, b) {
+        a7 = a7 == null ? 0 : +a7;
         b = b == null ? 1 : +b;
         return function() {
-            return a4 + b * Math.tan(Math.PI * source());
+            return a7 + b * Math.tan(Math.PI * source());
         };
     }
-    randomCauchy.source = sourceRandomCauchy;
+    randomCauchy.source = sourceRandomCauchy2;
     return randomCauchy;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/logistic.js
-var logistic_default = function sourceRandomLogistic(source) {
-    function randomLogistic(a4, b) {
-        a4 = a4 == null ? 0 : +a4;
+// js/pyobsplot-js/node_modules/d3-random/src/logistic.js
+var logistic_default2 = function sourceRandomLogistic2(source) {
+    function randomLogistic(a7, b) {
+        a7 = a7 == null ? 0 : +a7;
         b = b == null ? 1 : +b;
         return function() {
-            var u4 = source();
-            return a4 + b * Math.log(u4 / (1 - u4));
+            var u7 = source();
+            return a7 + b * Math.log(u7 / (1 - u7));
         };
     }
-    randomLogistic.source = sourceRandomLogistic;
+    randomLogistic.source = sourceRandomLogistic2;
     return randomLogistic;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/poisson.js
-var poisson_default = function sourceRandomPoisson(source) {
-    var G = gamma_default.source(source),
-        B3 = binomial_default.source(source);
+// js/pyobsplot-js/node_modules/d3-random/src/poisson.js
+var poisson_default2 = function sourceRandomPoisson2(source) {
+    var G = gamma_default2.source(source),
+        B5 = binomial_default2.source(source);
 
     function randomPoisson(lambda) {
         return function() {
             var acc = 0,
                 l = lambda;
             while (l > 16) {
                 var n = Math.floor(0.875 * l),
                     t = G(n)();
                 if (t > l)
-                    return acc + B3(n - 1, l / t)();
+                    return acc + B5(n - 1, l / t)();
                 acc += n;
                 l -= t;
             }
-            for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)
-                s2 -= Math.log1p(-source());
-            return acc + k2;
+            for (var s3 = -Math.log1p(-source()), k3 = 0; s3 <= l; ++k3)
+                s3 -= Math.log1p(-source());
+            return acc + k3;
         };
     }
-    randomPoisson.source = sourceRandomPoisson;
+    randomPoisson.source = sourceRandomPoisson2;
     return randomPoisson;
-}(defaultSource_default);
+}(defaultSource_default2);
 
-// node_modules/d3-random/src/lcg.js
-var mul = 1664525;
-var inc = 1013904223;
-var eps = 1 / 4294967296;
+// js/pyobsplot-js/node_modules/d3-random/src/lcg.js
+var mul2 = 1664525;
+var inc2 = 1013904223;
+var eps2 = 1 / 4294967296;
 
-function lcg(seed = Math.random()) {
-    let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
-    return () => (state = mul * state + inc | 0, eps * (state >>> 0));
+function lcg2(seed = Math.random()) {
+    let state = (0 <= seed && seed < 1 ? seed / eps2 : Math.abs(seed)) | 0;
+    return () => (state = mul2 * state + inc2 | 0, eps2 * (state >>> 0));
 }
 
-// node_modules/d3-scale/src/init.js
-function initRange(domain, range5) {
+// js/pyobsplot-js/node_modules/d3-scale/src/init.js
+function initRange2(domain, range9) {
     switch (arguments.length) {
         case 0:
             break;
         case 1:
             this.range(domain);
             break;
         default:
-            this.range(range5).domain(domain);
+            this.range(range9).domain(domain);
             break;
     }
     return this;
 }
 
-function initInterpolator(domain, interpolator) {
+function initInterpolator2(domain, interpolator) {
     switch (arguments.length) {
         case 0:
             break;
         case 1: {
             if (typeof domain === "function")
                 this.interpolator(domain);
             else
@@ -16384,1297 +51090,1297 @@
                 this.range(interpolator);
             break;
         }
     }
     return this;
 }
 
-// node_modules/d3-scale/src/ordinal.js
-var implicit = Symbol("implicit");
+// js/pyobsplot-js/node_modules/d3-scale/src/ordinal.js
+var implicit2 = Symbol("implicit");
 
-function ordinal() {
-    var index3 = new InternMap(),
+function ordinal2() {
+    var index5 = new InternMap2(),
         domain = [],
-        range5 = [],
-        unknown = implicit;
+        range9 = [],
+        unknown = implicit2;
 
-    function scale3(d) {
-        let i = index3.get(d);
+    function scale5(d) {
+        let i = index5.get(d);
         if (i === void 0) {
-            if (unknown !== implicit)
+            if (unknown !== implicit2)
                 return unknown;
-            index3.set(d, i = domain.push(d) - 1);
+            index5.set(d, i = domain.push(d) - 1);
         }
-        return range5[i % range5.length];
+        return range9[i % range9.length];
     }
-    scale3.domain = function(_) {
+    scale5.domain = function(_) {
         if (!arguments.length)
             return domain.slice();
-        domain = [], index3 = new InternMap();
+        domain = [], index5 = new InternMap2();
         for (const value of _) {
-            if (index3.has(value))
+            if (index5.has(value))
                 continue;
-            index3.set(value, domain.push(value) - 1);
+            index5.set(value, domain.push(value) - 1);
         }
-        return scale3;
+        return scale5;
     };
-    scale3.range = function(_) {
-        return arguments.length ? (range5 = Array.from(_), scale3) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), scale5) : range9.slice();
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    scale3.copy = function() {
-        return ordinal(domain, range5).unknown(unknown);
+    scale5.copy = function() {
+        return ordinal2(domain, range9).unknown(unknown);
     };
-    initRange.apply(scale3, arguments);
-    return scale3;
+    initRange2.apply(scale5, arguments);
+    return scale5;
 }
 
-// node_modules/d3-scale/src/band.js
-function band() {
-    var scale3 = ordinal().unknown(void 0),
-        domain = scale3.domain,
-        ordinalRange2 = scale3.range,
+// js/pyobsplot-js/node_modules/d3-scale/src/band.js
+function band2() {
+    var scale5 = ordinal2().unknown(void 0),
+        domain = scale5.domain,
+        ordinalRange3 = scale5.range,
         r0 = 0,
         r1 = 1,
-        step, bandwidth, round2 = false,
+        step, bandwidth, round3 = false,
         paddingInner = 0,
         paddingOuter = 0,
         align = 0.5;
-    delete scale3.unknown;
+    delete scale5.unknown;
 
     function rescale() {
         var n = domain().length,
-            reverse3 = r1 < r0,
-            start2 = reverse3 ? r1 : r0,
-            stop = reverse3 ? r0 : r1;
-        step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
-        if (round2)
+            reverse5 = r1 < r0,
+            start3 = reverse5 ? r1 : r0,
+            stop = reverse5 ? r0 : r1;
+        step = (stop - start3) / Math.max(1, n - paddingInner + paddingOuter * 2);
+        if (round3)
             step = Math.floor(step);
-        start2 += (stop - start2 - step * (n - paddingInner)) * align;
+        start3 += (stop - start3 - step * (n - paddingInner)) * align;
         bandwidth = step * (1 - paddingInner);
-        if (round2)
-            start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
-        var values2 = range(n).map(function(i) {
-            return start2 + step * i;
+        if (round3)
+            start3 = Math.round(start3), bandwidth = Math.round(bandwidth);
+        var values3 = range5(n).map(function(i) {
+            return start3 + step * i;
         });
-        return ordinalRange2(reverse3 ? values2.reverse() : values2);
+        return ordinalRange3(reverse5 ? values3.reverse() : values3);
     }
-    scale3.domain = function(_) {
+    scale5.domain = function(_) {
         return arguments.length ? (domain(_), rescale()) : domain();
     };
-    scale3.range = function(_) {
+    scale5.range = function(_) {
         return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
     };
-    scale3.rangeRound = function(_) {
-        return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
+    scale5.rangeRound = function(_) {
+        return [r0, r1] = _, r0 = +r0, r1 = +r1, round3 = true, rescale();
     };
-    scale3.bandwidth = function() {
+    scale5.bandwidth = function() {
         return bandwidth;
     };
-    scale3.step = function() {
+    scale5.step = function() {
         return step;
     };
-    scale3.round = function(_) {
-        return arguments.length ? (round2 = !!_, rescale()) : round2;
+    scale5.round = function(_) {
+        return arguments.length ? (round3 = !!_, rescale()) : round3;
     };
-    scale3.padding = function(_) {
+    scale5.padding = function(_) {
         return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
     };
-    scale3.paddingInner = function(_) {
+    scale5.paddingInner = function(_) {
         return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
     };
-    scale3.paddingOuter = function(_) {
+    scale5.paddingOuter = function(_) {
         return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
     };
-    scale3.align = function(_) {
+    scale5.align = function(_) {
         return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
     };
-    scale3.copy = function() {
-        return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
+    scale5.copy = function() {
+        return band2(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
     };
-    return initRange.apply(rescale(), arguments);
+    return initRange2.apply(rescale(), arguments);
 }
 
-function pointish(scale3) {
-    var copy3 = scale3.copy;
-    scale3.padding = scale3.paddingOuter;
-    delete scale3.paddingInner;
-    delete scale3.paddingOuter;
-    scale3.copy = function() {
-        return pointish(copy3());
+function pointish2(scale5) {
+    var copy5 = scale5.copy;
+    scale5.padding = scale5.paddingOuter;
+    delete scale5.paddingInner;
+    delete scale5.paddingOuter;
+    scale5.copy = function() {
+        return pointish2(copy5());
     };
-    return scale3;
+    return scale5;
 }
 
-function point() {
-    return pointish(band.apply(null, arguments).paddingInner(1));
+function point6() {
+    return pointish2(band2.apply(null, arguments).paddingInner(1));
 }
 
-// node_modules/d3-scale/src/constant.js
-function constants(x4) {
+// js/pyobsplot-js/node_modules/d3-scale/src/constant.js
+function constants2(x7) {
     return function() {
-        return x4;
+        return x7;
     };
 }
 
-// node_modules/d3-scale/src/number.js
-function number3(x4) {
-    return +x4;
+// js/pyobsplot-js/node_modules/d3-scale/src/number.js
+function number9(x7) {
+    return +x7;
 }
 
-// node_modules/d3-scale/src/continuous.js
-var unit = [0, 1];
+// js/pyobsplot-js/node_modules/d3-scale/src/continuous.js
+var unit3 = [0, 1];
 
-function identity3(x4) {
-    return x4;
+function identity10(x7) {
+    return x7;
 }
 
-function normalize2(a4, b) {
-    return (b -= a4 = +a4) ? function(x4) {
-        return (x4 - a4) / b;
-    } : constants(isNaN(b) ? NaN : 0.5);
+function normalize5(a7, b) {
+    return (b -= a7 = +a7) ? function(x7) {
+        return (x7 - a7) / b;
+    } : constants2(isNaN(b) ? NaN : 0.5);
 }
 
-function clamper(a4, b) {
+function clamper2(a7, b) {
     var t;
-    if (a4 > b)
-        t = a4, a4 = b, b = t;
-    return function(x4) {
-        return Math.max(a4, Math.min(b, x4));
+    if (a7 > b)
+        t = a7, a7 = b, b = t;
+    return function(x7) {
+        return Math.max(a7, Math.min(b, x7));
     };
 }
 
-function bimap(domain, range5, interpolate) {
+function bimap2(domain, range9, interpolate) {
     var d0 = domain[0],
         d1 = domain[1],
-        r0 = range5[0],
-        r1 = range5[1];
+        r0 = range9[0],
+        r1 = range9[1];
     if (d1 < d0)
-        d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
+        d0 = normalize5(d1, d0), r0 = interpolate(r1, r0);
     else
-        d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
-    return function(x4) {
-        return r0(d0(x4));
+        d0 = normalize5(d0, d1), r0 = interpolate(r0, r1);
+    return function(x7) {
+        return r0(d0(x7));
     };
 }
 
-function polymap(domain, range5, interpolate) {
-    var j = Math.min(domain.length, range5.length) - 1,
+function polymap2(domain, range9, interpolate) {
+    var j = Math.min(domain.length, range9.length) - 1,
         d = new Array(j),
         r = new Array(j),
         i = -1;
     if (domain[j] < domain[0]) {
         domain = domain.slice().reverse();
-        range5 = range5.slice().reverse();
+        range9 = range9.slice().reverse();
     }
     while (++i < j) {
-        d[i] = normalize2(domain[i], domain[i + 1]);
-        r[i] = interpolate(range5[i], range5[i + 1]);
+        d[i] = normalize5(domain[i], domain[i + 1]);
+        r[i] = interpolate(range9[i], range9[i + 1]);
     }
-    return function(x4) {
-        var i2 = bisect_default(domain, x4, 1, j) - 1;
-        return r[i2](d[i2](x4));
+    return function(x7) {
+        var i2 = bisect_default2(domain, x7, 1, j) - 1;
+        return r[i2](d[i2](x7));
     };
 }
 
-function copy(source, target) {
+function copy3(source, target) {
     return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
 }
 
-function transformer2() {
-    var domain = unit,
-        range5 = unit,
-        interpolate = value_default,
-        transform2, untransform, unknown, clamp = identity3,
-        piecewise2, output, input;
+function transformer6() {
+    var domain = unit3,
+        range9 = unit3,
+        interpolate = value_default2,
+        transform3, untransform, unknown, clamp = identity10,
+        piecewise3, output, input;
 
     function rescale() {
-        var n = Math.min(domain.length, range5.length);
-        if (clamp !== identity3)
-            clamp = clamper(domain[0], domain[n - 1]);
-        piecewise2 = n > 2 ? polymap : bimap;
+        var n = Math.min(domain.length, range9.length);
+        if (clamp !== identity10)
+            clamp = clamper2(domain[0], domain[n - 1]);
+        piecewise3 = n > 2 ? polymap2 : bimap2;
         output = input = null;
-        return scale3;
+        return scale5;
     }
 
-    function scale3(x4) {
-        return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range5, interpolate)))(transform2(clamp(x4)));
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : (output || (output = piecewise3(domain.map(transform3), range9, interpolate)))(transform3(clamp(x7)));
     }
-    scale3.invert = function(y4) {
-        return clamp(untransform((input || (input = piecewise2(range5, domain.map(transform2), number_default)))(y4)));
+    scale5.invert = function(y7) {
+        return clamp(untransform((input || (input = piecewise3(range9, domain.map(transform3), number_default2)))(y7)));
     };
-    scale3.domain = function(_) {
-        return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
+    scale5.domain = function(_) {
+        return arguments.length ? (domain = Array.from(_, number9), rescale()) : domain.slice();
     };
-    scale3.range = function(_) {
-        return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), rescale()) : range9.slice();
     };
-    scale3.rangeRound = function(_) {
-        return range5 = Array.from(_), interpolate = round_default, rescale();
+    scale5.rangeRound = function(_) {
+        return range9 = Array.from(_), interpolate = round_default3, rescale();
     };
-    scale3.clamp = function(_) {
-        return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = _ ? true : identity10, rescale()) : clamp !== identity10;
     };
-    scale3.interpolate = function(_) {
+    scale5.interpolate = function(_) {
         return arguments.length ? (interpolate = _, rescale()) : interpolate;
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    return function(t, u4) {
-        transform2 = t, untransform = u4;
+    return function(t, u7) {
+        transform3 = t, untransform = u7;
         return rescale();
     };
 }
 
-function continuous() {
-    return transformer2()(identity3, identity3);
+function continuous2() {
+    return transformer6()(identity10, identity10);
 }
 
-// node_modules/d3-scale/src/tickFormat.js
-function tickFormat(start2, stop, count3, specifier) {
-    var step = tickStep(start2, stop, count3),
+// js/pyobsplot-js/node_modules/d3-scale/src/tickFormat.js
+function tickFormat2(start3, stop, count5, specifier) {
+    var step = tickStep2(start3, stop, count5),
         precision;
-    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
+    specifier = formatSpecifier2(specifier == null ? ",f" : specifier);
     switch (specifier.type) {
         case "s": {
-            var value = Math.max(Math.abs(start2), Math.abs(stop));
-            if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
+            var value = Math.max(Math.abs(start3), Math.abs(stop));
+            if (specifier.precision == null && !isNaN(precision = precisionPrefix_default2(step, value)))
                 specifier.precision = precision;
-            return formatPrefix(specifier, value);
+            return formatPrefix2(specifier, value);
         }
         case "":
         case "e":
         case "g":
         case "p":
         case "r": {
-            if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
+            if (specifier.precision == null && !isNaN(precision = precisionRound_default2(step, Math.max(Math.abs(start3), Math.abs(stop)))))
                 specifier.precision = precision - (specifier.type === "e");
             break;
         }
         case "f":
         case "%": {
-            if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
+            if (specifier.precision == null && !isNaN(precision = precisionFixed_default2(step)))
                 specifier.precision = precision - (specifier.type === "%") * 2;
             break;
         }
     }
-    return format(specifier);
+    return format3(specifier);
 }
 
-// node_modules/d3-scale/src/linear.js
-function linearish(scale3) {
-    var domain = scale3.domain;
-    scale3.ticks = function(count3) {
+// js/pyobsplot-js/node_modules/d3-scale/src/linear.js
+function linearish2(scale5) {
+    var domain = scale5.domain;
+    scale5.ticks = function(count5) {
         var d = domain();
-        return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
+        return ticks2(d[0], d[d.length - 1], count5 == null ? 10 : count5);
     };
-    scale3.tickFormat = function(count3, specifier) {
+    scale5.tickFormat = function(count5, specifier) {
         var d = domain();
-        return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
+        return tickFormat2(d[0], d[d.length - 1], count5 == null ? 10 : count5, specifier);
     };
-    scale3.nice = function(count3) {
-        if (count3 == null)
-            count3 = 10;
+    scale5.nice = function(count5) {
+        if (count5 == null)
+            count5 = 10;
         var d = domain();
         var i0 = 0;
         var i1 = d.length - 1;
-        var start2 = d[i0];
+        var start3 = d[i0];
         var stop = d[i1];
         var prestep;
         var step;
         var maxIter = 10;
-        if (stop < start2) {
-            step = start2, start2 = stop, stop = step;
+        if (stop < start3) {
+            step = start3, start3 = stop, stop = step;
             step = i0, i0 = i1, i1 = step;
         }
         while (maxIter-- > 0) {
-            step = tickIncrement(start2, stop, count3);
+            step = tickIncrement2(start3, stop, count5);
             if (step === prestep) {
-                d[i0] = start2;
+                d[i0] = start3;
                 d[i1] = stop;
                 return domain(d);
             } else if (step > 0) {
-                start2 = Math.floor(start2 / step) * step;
+                start3 = Math.floor(start3 / step) * step;
                 stop = Math.ceil(stop / step) * step;
             } else if (step < 0) {
-                start2 = Math.ceil(start2 * step) / step;
+                start3 = Math.ceil(start3 * step) / step;
                 stop = Math.floor(stop * step) / step;
             } else {
                 break;
             }
             prestep = step;
         }
-        return scale3;
+        return scale5;
     };
-    return scale3;
+    return scale5;
 }
 
-function linear3() {
-    var scale3 = continuous();
-    scale3.copy = function() {
-        return copy(scale3, linear3());
+function linear6() {
+    var scale5 = continuous2();
+    scale5.copy = function() {
+        return copy3(scale5, linear6());
     };
-    initRange.apply(scale3, arguments);
-    return linearish(scale3);
+    initRange2.apply(scale5, arguments);
+    return linearish2(scale5);
 }
 
-// node_modules/d3-scale/src/identity.js
-function identity4(domain) {
+// js/pyobsplot-js/node_modules/d3-scale/src/identity.js
+function identity11(domain) {
     var unknown;
 
-    function scale3(x4) {
-        return x4 == null || isNaN(x4 = +x4) ? unknown : x4;
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : x7;
     }
-    scale3.invert = scale3;
-    scale3.domain = scale3.range = function(_) {
-        return arguments.length ? (domain = Array.from(_, number3), scale3) : domain.slice();
+    scale5.invert = scale5;
+    scale5.domain = scale5.range = function(_) {
+        return arguments.length ? (domain = Array.from(_, number9), scale5) : domain.slice();
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    scale3.copy = function() {
-        return identity4(domain).unknown(unknown);
+    scale5.copy = function() {
+        return identity11(domain).unknown(unknown);
     };
-    domain = arguments.length ? Array.from(domain, number3) : [0, 1];
-    return linearish(scale3);
+    domain = arguments.length ? Array.from(domain, number9) : [0, 1];
+    return linearish2(scale5);
 }
 
-// node_modules/d3-scale/src/nice.js
-function nice2(domain, interval2) {
+// js/pyobsplot-js/node_modules/d3-scale/src/nice.js
+function nice4(domain, interval3) {
     domain = domain.slice();
     var i0 = 0,
         i1 = domain.length - 1,
-        x06 = domain[i0],
-        x12 = domain[i1],
+        x011 = domain[i0],
+        x13 = domain[i1],
         t;
-    if (x12 < x06) {
+    if (x13 < x011) {
         t = i0, i0 = i1, i1 = t;
-        t = x06, x06 = x12, x12 = t;
+        t = x011, x011 = x13, x13 = t;
     }
-    domain[i0] = interval2.floor(x06);
-    domain[i1] = interval2.ceil(x12);
+    domain[i0] = interval3.floor(x011);
+    domain[i1] = interval3.ceil(x13);
     return domain;
 }
 
-// node_modules/d3-scale/src/log.js
-function transformLog(x4) {
-    return Math.log(x4);
+// js/pyobsplot-js/node_modules/d3-scale/src/log.js
+function transformLog3(x7) {
+    return Math.log(x7);
 }
 
-function transformExp(x4) {
-    return Math.exp(x4);
+function transformExp2(x7) {
+    return Math.exp(x7);
 }
 
-function transformLogn(x4) {
-    return -Math.log(-x4);
+function transformLogn2(x7) {
+    return -Math.log(-x7);
 }
 
-function transformExpn(x4) {
-    return -Math.exp(-x4);
+function transformExpn2(x7) {
+    return -Math.exp(-x7);
 }
 
-function pow10(x4) {
-    return isFinite(x4) ? +("1e" + x4) : x4 < 0 ? 0 : x4;
+function pow102(x7) {
+    return isFinite(x7) ? +("1e" + x7) : x7 < 0 ? 0 : x7;
 }
 
-function powp(base) {
-    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);
+function powp2(base) {
+    return base === 10 ? pow102 : base === Math.E ? Math.exp : (x7) => Math.pow(base, x7);
 }
 
-function logp(base) {
-    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);
+function logp2(base) {
+    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x7) => Math.log(x7) / base);
 }
 
-function reflect(f) {
-    return (x4, k2) => -f(-x4, k2);
+function reflect2(f) {
+    return (x7, k3) => -f(-x7, k3);
 }
 
-function loggish(transform2) {
-    const scale3 = transform2(transformLog, transformExp);
-    const domain = scale3.domain;
+function loggish2(transform3) {
+    const scale5 = transform3(transformLog3, transformExp2);
+    const domain = scale5.domain;
     let base = 10;
     let logs;
     let pows;
 
     function rescale() {
-        logs = logp(base), pows = powp(base);
+        logs = logp2(base), pows = powp2(base);
         if (domain()[0] < 0) {
-            logs = reflect(logs), pows = reflect(pows);
-            transform2(transformLogn, transformExpn);
+            logs = reflect2(logs), pows = reflect2(pows);
+            transform3(transformLogn2, transformExpn2);
         } else {
-            transform2(transformLog, transformExp);
+            transform3(transformLog3, transformExp2);
         }
-        return scale3;
+        return scale5;
     }
-    scale3.base = function(_) {
+    scale5.base = function(_) {
         return arguments.length ? (base = +_, rescale()) : base;
     };
-    scale3.domain = function(_) {
+    scale5.domain = function(_) {
         return arguments.length ? (domain(_), rescale()) : domain();
     };
-    scale3.ticks = (count3) => {
+    scale5.ticks = (count5) => {
         const d = domain();
-        let u4 = d[0];
-        let v2 = d[d.length - 1];
-        const r = v2 < u4;
+        let u7 = d[0];
+        let v3 = d[d.length - 1];
+        const r = v3 < u7;
         if (r)
-            [u4, v2] = [v2, u4];
-        let i = logs(u4);
-        let j = logs(v2);
-        let k2;
+            [u7, v3] = [v3, u7];
+        let i = logs(u7);
+        let j = logs(v3);
+        let k3;
         let t;
-        const n = count3 == null ? 10 : +count3;
+        const n = count5 == null ? 10 : +count5;
         let z = [];
         if (!(base % 1) && j - i < n) {
             i = Math.floor(i), j = Math.ceil(j);
-            if (u4 > 0)
+            if (u7 > 0)
                 for (; i <= j; ++i) {
-                    for (k2 = 1; k2 < base; ++k2) {
-                        t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
-                        if (t < u4)
+                    for (k3 = 1; k3 < base; ++k3) {
+                        t = i < 0 ? k3 / pows(-i) : k3 * pows(i);
+                        if (t < u7)
                             continue;
-                        if (t > v2)
+                        if (t > v3)
                             break;
                         z.push(t);
                     }
                 }
             else
                 for (; i <= j; ++i) {
-                    for (k2 = base - 1; k2 >= 1; --k2) {
-                        t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
-                        if (t < u4)
+                    for (k3 = base - 1; k3 >= 1; --k3) {
+                        t = i > 0 ? k3 / pows(-i) : k3 * pows(i);
+                        if (t < u7)
                             continue;
-                        if (t > v2)
+                        if (t > v3)
                             break;
                         z.push(t);
                     }
                 }
             if (z.length * 2 < n)
-                z = ticks(u4, v2, n);
+                z = ticks2(u7, v3, n);
         } else {
-            z = ticks(i, j, Math.min(j - i, n)).map(pows);
+            z = ticks2(i, j, Math.min(j - i, n)).map(pows);
         }
         return r ? z.reverse() : z;
     };
-    scale3.tickFormat = (count3, specifier) => {
-        if (count3 == null)
-            count3 = 10;
+    scale5.tickFormat = (count5, specifier) => {
+        if (count5 == null)
+            count5 = 10;
         if (specifier == null)
             specifier = base === 10 ? "s" : ",";
         if (typeof specifier !== "function") {
-            if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
+            if (!(base % 1) && (specifier = formatSpecifier2(specifier)).precision == null)
                 specifier.trim = true;
-            specifier = format(specifier);
+            specifier = format3(specifier);
         }
-        if (count3 === Infinity)
+        if (count5 === Infinity)
             return specifier;
-        const k2 = Math.max(1, base * count3 / scale3.ticks().length);
+        const k3 = Math.max(1, base * count5 / scale5.ticks().length);
         return (d) => {
             let i = d / pows(Math.round(logs(d)));
             if (i * base < base - 0.5)
                 i *= base;
-            return i <= k2 ? specifier(d) : "";
+            return i <= k3 ? specifier(d) : "";
         };
     };
-    scale3.nice = () => {
-        return domain(nice2(domain(), {
-            floor: (x4) => pows(Math.floor(logs(x4))),
-            ceil: (x4) => pows(Math.ceil(logs(x4)))
+    scale5.nice = () => {
+        return domain(nice4(domain(), {
+            floor: (x7) => pows(Math.floor(logs(x7))),
+            ceil: (x7) => pows(Math.ceil(logs(x7)))
         }));
     };
-    return scale3;
+    return scale5;
 }
 
-function log2() {
-    const scale3 = loggish(transformer2()).domain([1, 10]);
-    scale3.copy = () => copy(scale3, log2()).base(scale3.base());
-    initRange.apply(scale3, arguments);
-    return scale3;
+function log4() {
+    const scale5 = loggish2(transformer6()).domain([1, 10]);
+    scale5.copy = () => copy3(scale5, log4()).base(scale5.base());
+    initRange2.apply(scale5, arguments);
+    return scale5;
 }
 
-// node_modules/d3-scale/src/symlog.js
-function transformSymlog(c6) {
-    return function(x4) {
-        return Math.sign(x4) * Math.log1p(Math.abs(x4 / c6));
+// js/pyobsplot-js/node_modules/d3-scale/src/symlog.js
+function transformSymlog3(c11) {
+    return function(x7) {
+        return Math.sign(x7) * Math.log1p(Math.abs(x7 / c11));
     };
 }
 
-function transformSymexp(c6) {
-    return function(x4) {
-        return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c6;
+function transformSymexp2(c11) {
+    return function(x7) {
+        return Math.sign(x7) * Math.expm1(Math.abs(x7)) * c11;
     };
 }
 
-function symlogish(transform2) {
-    var c6 = 1,
-        scale3 = transform2(transformSymlog(c6), transformSymexp(c6));
-    scale3.constant = function(_) {
-        return arguments.length ? transform2(transformSymlog(c6 = +_), transformSymexp(c6)) : c6;
+function symlogish2(transform3) {
+    var c11 = 1,
+        scale5 = transform3(transformSymlog3(c11), transformSymexp2(c11));
+    scale5.constant = function(_) {
+        return arguments.length ? transform3(transformSymlog3(c11 = +_), transformSymexp2(c11)) : c11;
     };
-    return linearish(scale3);
+    return linearish2(scale5);
 }
 
-function symlog() {
-    var scale3 = symlogish(transformer2());
-    scale3.copy = function() {
-        return copy(scale3, symlog()).constant(scale3.constant());
+function symlog2() {
+    var scale5 = symlogish2(transformer6());
+    scale5.copy = function() {
+        return copy3(scale5, symlog2()).constant(scale5.constant());
     };
-    return initRange.apply(scale3, arguments);
+    return initRange2.apply(scale5, arguments);
 }
 
-// node_modules/d3-scale/src/pow.js
-function transformPow(exponent2) {
-    return function(x4) {
-        return x4 < 0 ? -Math.pow(-x4, exponent2) : Math.pow(x4, exponent2);
+// js/pyobsplot-js/node_modules/d3-scale/src/pow.js
+function transformPow3(exponent3) {
+    return function(x7) {
+        return x7 < 0 ? -Math.pow(-x7, exponent3) : Math.pow(x7, exponent3);
     };
 }
 
-function transformSqrt(x4) {
-    return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);
+function transformSqrt3(x7) {
+    return x7 < 0 ? -Math.sqrt(-x7) : Math.sqrt(x7);
 }
 
-function transformSquare(x4) {
-    return x4 < 0 ? -x4 * x4 : x4 * x4;
+function transformSquare2(x7) {
+    return x7 < 0 ? -x7 * x7 : x7 * x7;
 }
 
-function powish(transform2) {
-    var scale3 = transform2(identity3, identity3),
-        exponent2 = 1;
+function powish2(transform3) {
+    var scale5 = transform3(identity10, identity10),
+        exponent3 = 1;
 
     function rescale() {
-        return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
+        return exponent3 === 1 ? transform3(identity10, identity10) : exponent3 === 0.5 ? transform3(transformSqrt3, transformSquare2) : transform3(transformPow3(exponent3), transformPow3(1 / exponent3));
     }
-    scale3.exponent = function(_) {
-        return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
+    scale5.exponent = function(_) {
+        return arguments.length ? (exponent3 = +_, rescale()) : exponent3;
     };
-    return linearish(scale3);
+    return linearish2(scale5);
 }
 
-function pow3() {
-    var scale3 = powish(transformer2());
-    scale3.copy = function() {
-        return copy(scale3, pow3()).exponent(scale3.exponent());
+function pow6() {
+    var scale5 = powish2(transformer6());
+    scale5.copy = function() {
+        return copy3(scale5, pow6()).exponent(scale5.exponent());
     };
-    initRange.apply(scale3, arguments);
-    return scale3;
+    initRange2.apply(scale5, arguments);
+    return scale5;
 }
 
-function sqrt2() {
-    return pow3.apply(null, arguments).exponent(0.5);
+function sqrt5() {
+    return pow6.apply(null, arguments).exponent(0.5);
 }
 
-// node_modules/d3-scale/src/radial.js
-function square(x4) {
-    return Math.sign(x4) * x4 * x4;
+// js/pyobsplot-js/node_modules/d3-scale/src/radial.js
+function square2(x7) {
+    return Math.sign(x7) * x7 * x7;
 }
 
-function unsquare(x4) {
-    return Math.sign(x4) * Math.sqrt(Math.abs(x4));
+function unsquare2(x7) {
+    return Math.sign(x7) * Math.sqrt(Math.abs(x7));
 }
 
-function radial() {
-    var squared = continuous(),
-        range5 = [0, 1],
-        round2 = false,
+function radial2() {
+    var squared = continuous2(),
+        range9 = [0, 1],
+        round3 = false,
         unknown;
 
-    function scale3(x4) {
-        var y4 = unsquare(squared(x4));
-        return isNaN(y4) ? unknown : round2 ? Math.round(y4) : y4;
+    function scale5(x7) {
+        var y7 = unsquare2(squared(x7));
+        return isNaN(y7) ? unknown : round3 ? Math.round(y7) : y7;
     }
-    scale3.invert = function(y4) {
-        return squared.invert(square(y4));
+    scale5.invert = function(y7) {
+        return squared.invert(square2(y7));
     };
-    scale3.domain = function(_) {
-        return arguments.length ? (squared.domain(_), scale3) : squared.domain();
+    scale5.domain = function(_) {
+        return arguments.length ? (squared.domain(_), scale5) : squared.domain();
     };
-    scale3.range = function(_) {
-        return arguments.length ? (squared.range((range5 = Array.from(_, number3)).map(square)), scale3) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (squared.range((range9 = Array.from(_, number9)).map(square2)), scale5) : range9.slice();
     };
-    scale3.rangeRound = function(_) {
-        return scale3.range(_).round(true);
+    scale5.rangeRound = function(_) {
+        return scale5.range(_).round(true);
     };
-    scale3.round = function(_) {
-        return arguments.length ? (round2 = !!_, scale3) : round2;
+    scale5.round = function(_) {
+        return arguments.length ? (round3 = !!_, scale5) : round3;
     };
-    scale3.clamp = function(_) {
-        return arguments.length ? (squared.clamp(_), scale3) : squared.clamp();
+    scale5.clamp = function(_) {
+        return arguments.length ? (squared.clamp(_), scale5) : squared.clamp();
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    scale3.copy = function() {
-        return radial(squared.domain(), range5).round(round2).clamp(squared.clamp()).unknown(unknown);
+    scale5.copy = function() {
+        return radial2(squared.domain(), range9).round(round3).clamp(squared.clamp()).unknown(unknown);
     };
-    initRange.apply(scale3, arguments);
-    return linearish(scale3);
+    initRange2.apply(scale5, arguments);
+    return linearish2(scale5);
 }
 
-// node_modules/d3-scale/src/quantile.js
-function quantile2() {
+// js/pyobsplot-js/node_modules/d3-scale/src/quantile.js
+function quantile4() {
     var domain = [],
-        range5 = [],
+        range9 = [],
         thresholds = [],
         unknown;
 
     function rescale() {
         var i = 0,
-            n = Math.max(1, range5.length);
+            n = Math.max(1, range9.length);
         thresholds = new Array(n - 1);
         while (++i < n)
-            thresholds[i - 1] = quantileSorted(domain, i / n);
-        return scale3;
+            thresholds[i - 1] = quantileSorted2(domain, i / n);
+        return scale5;
     }
 
-    function scale3(x4) {
-        return x4 == null || isNaN(x4 = +x4) ? unknown : range5[bisect_default(thresholds, x4)];
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : range9[bisect_default2(thresholds, x7)];
     }
-    scale3.invertExtent = function(y4) {
-        var i = range5.indexOf(y4);
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
         return i < 0 ? [NaN, NaN] : [
             i > 0 ? thresholds[i - 1] : domain[0],
             i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
         ];
     };
-    scale3.domain = function(_) {
+    scale5.domain = function(_) {
         if (!arguments.length)
             return domain.slice();
         domain = [];
         for (let d of _)
             if (d != null && !isNaN(d = +d))
                 domain.push(d);
-        domain.sort(ascending);
+        domain.sort(ascending3);
         return rescale();
     };
-    scale3.range = function(_) {
-        return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), rescale()) : range9.slice();
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    scale3.quantiles = function() {
+    scale5.quantiles = function() {
         return thresholds.slice();
     };
-    scale3.copy = function() {
-        return quantile2().domain(domain).range(range5).unknown(unknown);
+    scale5.copy = function() {
+        return quantile4().domain(domain).range(range9).unknown(unknown);
     };
-    return initRange.apply(scale3, arguments);
+    return initRange2.apply(scale5, arguments);
 }
 
-// node_modules/d3-scale/src/quantize.js
-function quantize() {
-    var x06 = 0,
-        x12 = 1,
+// js/pyobsplot-js/node_modules/d3-scale/src/quantize.js
+function quantize2() {
+    var x011 = 0,
+        x13 = 1,
         n = 1,
         domain = [0.5],
-        range5 = [0, 1],
+        range9 = [0, 1],
         unknown;
 
-    function scale3(x4) {
-        return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;
+    function scale5(x7) {
+        return x7 != null && x7 <= x7 ? range9[bisect_default2(domain, x7, 0, n)] : unknown;
     }
 
     function rescale() {
         var i = -1;
         domain = new Array(n);
         while (++i < n)
-            domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
-        return scale3;
+            domain[i] = ((i + 1) * x13 - (i - n) * x011) / (n + 1);
+        return scale5;
     }
-    scale3.domain = function(_) {
-        return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13] = _, x011 = +x011, x13 = +x13, rescale()) : [x011, x13];
     };
-    scale3.range = function(_) {
-        return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (n = (range9 = Array.from(_)).length - 1, rescale()) : range9.slice();
     };
-    scale3.invertExtent = function(y4) {
-        var i = range5.indexOf(y4);
-        return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
+        return i < 0 ? [NaN, NaN] : i < 1 ? [x011, domain[0]] : i >= n ? [domain[n - 1], x13] : [domain[i - 1], domain[i]];
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : scale3;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : scale5;
     };
-    scale3.thresholds = function() {
+    scale5.thresholds = function() {
         return domain.slice();
     };
-    scale3.copy = function() {
-        return quantize().domain([x06, x12]).range(range5).unknown(unknown);
+    scale5.copy = function() {
+        return quantize2().domain([x011, x13]).range(range9).unknown(unknown);
     };
-    return initRange.apply(linearish(scale3), arguments);
+    return initRange2.apply(linearish2(scale5), arguments);
 }
 
-// node_modules/d3-scale/src/threshold.js
-function threshold() {
+// js/pyobsplot-js/node_modules/d3-scale/src/threshold.js
+function threshold2() {
     var domain = [0.5],
-        range5 = [0, 1],
+        range9 = [0, 1],
         unknown, n = 1;
 
-    function scale3(x4) {
-        return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;
+    function scale5(x7) {
+        return x7 != null && x7 <= x7 ? range9[bisect_default2(domain, x7, 0, n)] : unknown;
     }
-    scale3.domain = function(_) {
-        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : domain.slice();
+    scale5.domain = function(_) {
+        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range9.length - 1), scale5) : domain.slice();
     };
-    scale3.range = function(_) {
-        return arguments.length ? (range5 = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : range5.slice();
+    scale5.range = function(_) {
+        return arguments.length ? (range9 = Array.from(_), n = Math.min(domain.length, range9.length - 1), scale5) : range9.slice();
     };
-    scale3.invertExtent = function(y4) {
-        var i = range5.indexOf(y4);
+    scale5.invertExtent = function(y7) {
+        var i = range9.indexOf(y7);
         return [domain[i - 1], domain[i]];
     };
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
-    scale3.copy = function() {
-        return threshold().domain(domain).range(range5).unknown(unknown);
+    scale5.copy = function() {
+        return threshold2().domain(domain).range(range9).unknown(unknown);
     };
-    return initRange.apply(scale3, arguments);
+    return initRange2.apply(scale5, arguments);
 }
 
-// node_modules/d3-time/src/interval.js
-var t02 = /* @__PURE__ */ new Date();
-var t12 = /* @__PURE__ */ new Date();
+// js/pyobsplot-js/node_modules/d3-time/src/interval.js
+var t04 = /* @__PURE__ */ new Date();
+var t14 = /* @__PURE__ */ new Date();
 
-function timeInterval(floori, offseti, count3, field2) {
-    function interval2(date2) {
-        return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
-    }
-    interval2.floor = (date2) => {
-        return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
-    };
-    interval2.ceil = (date2) => {
-        return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
-    };
-    interval2.round = (date2) => {
-        const d0 = interval2(date2),
-            d1 = interval2.ceil(date2);
-        return date2 - d0 < d1 - date2 ? d0 : d1;
-    };
-    interval2.offset = (date2, step) => {
-        return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
-    };
-    interval2.range = (start2, stop, step) => {
-        const range5 = [];
-        start2 = interval2.ceil(start2);
+function timeInterval2(floori, offseti, count5, field3) {
+    function interval3(date3) {
+        return floori(date3 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date3)), date3;
+    }
+    interval3.floor = (date3) => {
+        return floori(date3 = /* @__PURE__ */ new Date(+date3)), date3;
+    };
+    interval3.ceil = (date3) => {
+        return floori(date3 = new Date(date3 - 1)), offseti(date3, 1), floori(date3), date3;
+    };
+    interval3.round = (date3) => {
+        const d0 = interval3(date3),
+            d1 = interval3.ceil(date3);
+        return date3 - d0 < d1 - date3 ? d0 : d1;
+    };
+    interval3.offset = (date3, step) => {
+        return offseti(date3 = /* @__PURE__ */ new Date(+date3), step == null ? 1 : Math.floor(step)), date3;
+    };
+    interval3.range = (start3, stop, step) => {
+        const range9 = [];
+        start3 = interval3.ceil(start3);
         step = step == null ? 1 : Math.floor(step);
-        if (!(start2 < stop) || !(step > 0))
-            return range5;
+        if (!(start3 < stop) || !(step > 0))
+            return range9;
         let previous;
         do
-            range5.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
-        while (previous < start2 && start2 < stop);
-        return range5;
-    };
-    interval2.filter = (test) => {
-        return timeInterval((date2) => {
-            if (date2 >= date2)
-                while (floori(date2), !test(date2))
-                    date2.setTime(date2 - 1);
-        }, (date2, step) => {
-            if (date2 >= date2) {
+            range9.push(previous = /* @__PURE__ */ new Date(+start3)), offseti(start3, step), floori(start3);
+        while (previous < start3 && start3 < stop);
+        return range9;
+    };
+    interval3.filter = (test) => {
+        return timeInterval2((date3) => {
+            if (date3 >= date3)
+                while (floori(date3), !test(date3))
+                    date3.setTime(date3 - 1);
+        }, (date3, step) => {
+            if (date3 >= date3) {
                 if (step < 0)
                     while (++step <= 0) {
-                        while (offseti(date2, -1), !test(date2)) {}
+                        while (offseti(date3, -1), !test(date3)) {}
                     }
                 else
                     while (--step >= 0) {
-                        while (offseti(date2, 1), !test(date2)) {}
+                        while (offseti(date3, 1), !test(date3)) {}
                     }
             }
         });
     };
-    if (count3) {
-        interval2.count = (start2, end) => {
-            t02.setTime(+start2), t12.setTime(+end);
-            floori(t02), floori(t12);
-            return Math.floor(count3(t02, t12));
+    if (count5) {
+        interval3.count = (start3, end) => {
+            t04.setTime(+start3), t14.setTime(+end);
+            floori(t04), floori(t14);
+            return Math.floor(count5(t04, t14));
         };
-        interval2.every = (step) => {
+        interval3.every = (step) => {
             step = Math.floor(step);
-            return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
+            return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field3 ? (d) => field3(d) % step === 0 : (d) => interval3.count(0, d) % step === 0);
         };
     }
-    return interval2;
+    return interval3;
 }
 
-// node_modules/d3-time/src/millisecond.js
-var millisecond = timeInterval(() => {}, (date2, step) => {
-    date2.setTime(+date2 + step);
-}, (start2, end) => {
-    return end - start2;
-});
-millisecond.every = (k2) => {
-    k2 = Math.floor(k2);
-    if (!isFinite(k2) || !(k2 > 0))
+// js/pyobsplot-js/node_modules/d3-time/src/millisecond.js
+var millisecond2 = timeInterval2(() => {}, (date3, step) => {
+    date3.setTime(+date3 + step);
+}, (start3, end) => {
+    return end - start3;
+});
+millisecond2.every = (k3) => {
+    k3 = Math.floor(k3);
+    if (!isFinite(k3) || !(k3 > 0))
         return null;
-    if (!(k2 > 1))
-        return millisecond;
-    return timeInterval((date2) => {
-        date2.setTime(Math.floor(date2 / k2) * k2);
-    }, (date2, step) => {
-        date2.setTime(+date2 + step * k2);
-    }, (start2, end) => {
-        return (end - start2) / k2;
+    if (!(k3 > 1))
+        return millisecond2;
+    return timeInterval2((date3) => {
+        date3.setTime(Math.floor(date3 / k3) * k3);
+    }, (date3, step) => {
+        date3.setTime(+date3 + step * k3);
+    }, (start3, end) => {
+        return (end - start3) / k3;
     });
 };
-var milliseconds = millisecond.range;
-
-// node_modules/d3-time/src/duration.js
-var durationSecond = 1e3;
-var durationMinute = durationSecond * 60;
-var durationHour = durationMinute * 60;
-var durationDay = durationHour * 24;
-var durationWeek = durationDay * 7;
-var durationMonth = durationDay * 30;
-var durationYear = durationDay * 365;
+var milliseconds2 = millisecond2.range;
 
-// node_modules/d3-time/src/second.js
-var second = timeInterval((date2) => {
-    date2.setTime(date2 - date2.getMilliseconds());
-}, (date2, step) => {
-    date2.setTime(+date2 + step * durationSecond);
-}, (start2, end) => {
-    return (end - start2) / durationSecond;
-}, (date2) => {
-    return date2.getUTCSeconds();
+// js/pyobsplot-js/node_modules/d3-time/src/duration.js
+var durationSecond2 = 1e3;
+var durationMinute2 = durationSecond2 * 60;
+var durationHour2 = durationMinute2 * 60;
+var durationDay2 = durationHour2 * 24;
+var durationWeek2 = durationDay2 * 7;
+var durationMonth2 = durationDay2 * 30;
+var durationYear2 = durationDay2 * 365;
+
+// js/pyobsplot-js/node_modules/d3-time/src/second.js
+var second3 = timeInterval2((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds());
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationSecond2);
+}, (start3, end) => {
+    return (end - start3) / durationSecond2;
+}, (date3) => {
+    return date3.getUTCSeconds();
 });
-var seconds = second.range;
+var seconds2 = second3.range;
 
-// node_modules/d3-time/src/minute.js
-var timeMinute = timeInterval((date2) => {
-    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
-}, (date2, step) => {
-    date2.setTime(+date2 + step * durationMinute);
-}, (start2, end) => {
-    return (end - start2) / durationMinute;
-}, (date2) => {
-    return date2.getMinutes();
+// js/pyobsplot-js/node_modules/d3-time/src/minute.js
+var timeMinute2 = timeInterval2((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond2);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationMinute2);
+}, (start3, end) => {
+    return (end - start3) / durationMinute2;
+}, (date3) => {
+    return date3.getMinutes();
 });
-var timeMinutes = timeMinute.range;
-var utcMinute = timeInterval((date2) => {
-    date2.setUTCSeconds(0, 0);
-}, (date2, step) => {
-    date2.setTime(+date2 + step * durationMinute);
-}, (start2, end) => {
-    return (end - start2) / durationMinute;
-}, (date2) => {
-    return date2.getUTCMinutes();
+var timeMinutes2 = timeMinute2.range;
+var utcMinute2 = timeInterval2((date3) => {
+    date3.setUTCSeconds(0, 0);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationMinute2);
+}, (start3, end) => {
+    return (end - start3) / durationMinute2;
+}, (date3) => {
+    return date3.getUTCMinutes();
 });
-var utcMinutes = utcMinute.range;
+var utcMinutes2 = utcMinute2.range;
 
-// node_modules/d3-time/src/hour.js
-var timeHour = timeInterval((date2) => {
-    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
-}, (date2, step) => {
-    date2.setTime(+date2 + step * durationHour);
-}, (start2, end) => {
-    return (end - start2) / durationHour;
-}, (date2) => {
-    return date2.getHours();
+// js/pyobsplot-js/node_modules/d3-time/src/hour.js
+var timeHour2 = timeInterval2((date3) => {
+    date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond2 - date3.getMinutes() * durationMinute2);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationHour2);
+}, (start3, end) => {
+    return (end - start3) / durationHour2;
+}, (date3) => {
+    return date3.getHours();
 });
-var timeHours = timeHour.range;
-var utcHour = timeInterval((date2) => {
-    date2.setUTCMinutes(0, 0, 0);
-}, (date2, step) => {
-    date2.setTime(+date2 + step * durationHour);
-}, (start2, end) => {
-    return (end - start2) / durationHour;
-}, (date2) => {
-    return date2.getUTCHours();
+var timeHours2 = timeHour2.range;
+var utcHour2 = timeInterval2((date3) => {
+    date3.setUTCMinutes(0, 0, 0);
+}, (date3, step) => {
+    date3.setTime(+date3 + step * durationHour2);
+}, (start3, end) => {
+    return (end - start3) / durationHour2;
+}, (date3) => {
+    return date3.getUTCHours();
 });
-var utcHours = utcHour.range;
+var utcHours2 = utcHour2.range;
 
-// node_modules/d3-time/src/day.js
-var timeDay = timeInterval(
-    (date2) => date2.setHours(0, 0, 0, 0),
-    (date2, step) => date2.setDate(date2.getDate() + step),
-    (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
-    (date2) => date2.getDate() - 1
+// js/pyobsplot-js/node_modules/d3-time/src/day.js
+var timeDay2 = timeInterval2(
+    (date3) => date3.setHours(0, 0, 0, 0),
+    (date3, step) => date3.setDate(date3.getDate() + step),
+    (start3, end) => (end - start3 - (end.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute2) / durationDay2,
+    (date3) => date3.getDate() - 1
 );
-var timeDays = timeDay.range;
-var utcDay = timeInterval((date2) => {
-    date2.setUTCHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setUTCDate(date2.getUTCDate() + step);
-}, (start2, end) => {
-    return (end - start2) / durationDay;
-}, (date2) => {
-    return date2.getUTCDate() - 1;
+var timeDays2 = timeDay2.range;
+var utcDay2 = timeInterval2((date3) => {
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCDate(date3.getUTCDate() + step);
+}, (start3, end) => {
+    return (end - start3) / durationDay2;
+}, (date3) => {
+    return date3.getUTCDate() - 1;
 });
-var utcDays = utcDay.range;
-var unixDay = timeInterval((date2) => {
-    date2.setUTCHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setUTCDate(date2.getUTCDate() + step);
-}, (start2, end) => {
-    return (end - start2) / durationDay;
-}, (date2) => {
-    return Math.floor(date2 / durationDay);
+var utcDays2 = utcDay2.range;
+var unixDay2 = timeInterval2((date3) => {
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCDate(date3.getUTCDate() + step);
+}, (start3, end) => {
+    return (end - start3) / durationDay2;
+}, (date3) => {
+    return Math.floor(date3 / durationDay2);
 });
-var unixDays = unixDay.range;
+var unixDays2 = unixDay2.range;
 
-// node_modules/d3-time/src/week.js
-function timeWeekday(i) {
-    return timeInterval((date2) => {
-        date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
-        date2.setHours(0, 0, 0, 0);
-    }, (date2, step) => {
-        date2.setDate(date2.getDate() + step * 7);
-    }, (start2, end) => {
-        return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
+// js/pyobsplot-js/node_modules/d3-time/src/week.js
+function timeWeekday2(i) {
+    return timeInterval2((date3) => {
+        date3.setDate(date3.getDate() - (date3.getDay() + 7 - i) % 7);
+        date3.setHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setDate(date3.getDate() + step * 7);
+    }, (start3, end) => {
+        return (end - start3 - (end.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute2) / durationWeek2;
     });
 }
-var timeSunday = timeWeekday(0);
-var timeMonday = timeWeekday(1);
-var timeTuesday = timeWeekday(2);
-var timeWednesday = timeWeekday(3);
-var timeThursday = timeWeekday(4);
-var timeFriday = timeWeekday(5);
-var timeSaturday = timeWeekday(6);
-var timeSundays = timeSunday.range;
-var timeMondays = timeMonday.range;
-var timeTuesdays = timeTuesday.range;
-var timeWednesdays = timeWednesday.range;
-var timeThursdays = timeThursday.range;
-var timeFridays = timeFriday.range;
-var timeSaturdays = timeSaturday.range;
-
-function utcWeekday(i) {
-    return timeInterval((date2) => {
-        date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
-        date2.setUTCHours(0, 0, 0, 0);
-    }, (date2, step) => {
-        date2.setUTCDate(date2.getUTCDate() + step * 7);
-    }, (start2, end) => {
-        return (end - start2) / durationWeek;
+var timeSunday2 = timeWeekday2(0);
+var timeMonday2 = timeWeekday2(1);
+var timeTuesday2 = timeWeekday2(2);
+var timeWednesday2 = timeWeekday2(3);
+var timeThursday2 = timeWeekday2(4);
+var timeFriday2 = timeWeekday2(5);
+var timeSaturday2 = timeWeekday2(6);
+var timeSundays2 = timeSunday2.range;
+var timeMondays2 = timeMonday2.range;
+var timeTuesdays2 = timeTuesday2.range;
+var timeWednesdays2 = timeWednesday2.range;
+var timeThursdays2 = timeThursday2.range;
+var timeFridays2 = timeFriday2.range;
+var timeSaturdays2 = timeSaturday2.range;
+
+function utcWeekday2(i) {
+    return timeInterval2((date3) => {
+        date3.setUTCDate(date3.getUTCDate() - (date3.getUTCDay() + 7 - i) % 7);
+        date3.setUTCHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setUTCDate(date3.getUTCDate() + step * 7);
+    }, (start3, end) => {
+        return (end - start3) / durationWeek2;
     });
 }
-var utcSunday = utcWeekday(0);
-var utcMonday = utcWeekday(1);
-var utcTuesday = utcWeekday(2);
-var utcWednesday = utcWeekday(3);
-var utcThursday = utcWeekday(4);
-var utcFriday = utcWeekday(5);
-var utcSaturday = utcWeekday(6);
-var utcSundays = utcSunday.range;
-var utcMondays = utcMonday.range;
-var utcTuesdays = utcTuesday.range;
-var utcWednesdays = utcWednesday.range;
-var utcThursdays = utcThursday.range;
-var utcFridays = utcFriday.range;
-var utcSaturdays = utcSaturday.range;
-
-// node_modules/d3-time/src/month.js
-var timeMonth = timeInterval((date2) => {
-    date2.setDate(1);
-    date2.setHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setMonth(date2.getMonth() + step);
-}, (start2, end) => {
-    return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
-}, (date2) => {
-    return date2.getMonth();
+var utcSunday2 = utcWeekday2(0);
+var utcMonday2 = utcWeekday2(1);
+var utcTuesday2 = utcWeekday2(2);
+var utcWednesday2 = utcWeekday2(3);
+var utcThursday2 = utcWeekday2(4);
+var utcFriday2 = utcWeekday2(5);
+var utcSaturday2 = utcWeekday2(6);
+var utcSundays2 = utcSunday2.range;
+var utcMondays2 = utcMonday2.range;
+var utcTuesdays2 = utcTuesday2.range;
+var utcWednesdays2 = utcWednesday2.range;
+var utcThursdays2 = utcThursday2.range;
+var utcFridays2 = utcFriday2.range;
+var utcSaturdays2 = utcSaturday2.range;
+
+// js/pyobsplot-js/node_modules/d3-time/src/month.js
+var timeMonth2 = timeInterval2((date3) => {
+    date3.setDate(1);
+    date3.setHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setMonth(date3.getMonth() + step);
+}, (start3, end) => {
+    return end.getMonth() - start3.getMonth() + (end.getFullYear() - start3.getFullYear()) * 12;
+}, (date3) => {
+    return date3.getMonth();
 });
-var timeMonths = timeMonth.range;
-var utcMonth = timeInterval((date2) => {
-    date2.setUTCDate(1);
-    date2.setUTCHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setUTCMonth(date2.getUTCMonth() + step);
-}, (start2, end) => {
-    return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
-}, (date2) => {
-    return date2.getUTCMonth();
+var timeMonths2 = timeMonth2.range;
+var utcMonth2 = timeInterval2((date3) => {
+    date3.setUTCDate(1);
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCMonth(date3.getUTCMonth() + step);
+}, (start3, end) => {
+    return end.getUTCMonth() - start3.getUTCMonth() + (end.getUTCFullYear() - start3.getUTCFullYear()) * 12;
+}, (date3) => {
+    return date3.getUTCMonth();
 });
-var utcMonths = utcMonth.range;
+var utcMonths2 = utcMonth2.range;
 
-// node_modules/d3-time/src/year.js
-var timeYear = timeInterval((date2) => {
-    date2.setMonth(0, 1);
-    date2.setHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setFullYear(date2.getFullYear() + step);
-}, (start2, end) => {
-    return end.getFullYear() - start2.getFullYear();
-}, (date2) => {
-    return date2.getFullYear();
-});
-timeYear.every = (k2) => {
-    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
-        date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
-        date2.setMonth(0, 1);
-        date2.setHours(0, 0, 0, 0);
-    }, (date2, step) => {
-        date2.setFullYear(date2.getFullYear() + step * k2);
+// js/pyobsplot-js/node_modules/d3-time/src/year.js
+var timeYear2 = timeInterval2((date3) => {
+    date3.setMonth(0, 1);
+    date3.setHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setFullYear(date3.getFullYear() + step);
+}, (start3, end) => {
+    return end.getFullYear() - start3.getFullYear();
+}, (date3) => {
+    return date3.getFullYear();
+});
+timeYear2.every = (k3) => {
+    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval2((date3) => {
+        date3.setFullYear(Math.floor(date3.getFullYear() / k3) * k3);
+        date3.setMonth(0, 1);
+        date3.setHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setFullYear(date3.getFullYear() + step * k3);
     });
 };
-var timeYears = timeYear.range;
-var utcYear = timeInterval((date2) => {
-    date2.setUTCMonth(0, 1);
-    date2.setUTCHours(0, 0, 0, 0);
-}, (date2, step) => {
-    date2.setUTCFullYear(date2.getUTCFullYear() + step);
-}, (start2, end) => {
-    return end.getUTCFullYear() - start2.getUTCFullYear();
-}, (date2) => {
-    return date2.getUTCFullYear();
-});
-utcYear.every = (k2) => {
-    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
-        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
-        date2.setUTCMonth(0, 1);
-        date2.setUTCHours(0, 0, 0, 0);
-    }, (date2, step) => {
-        date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
+var timeYears2 = timeYear2.range;
+var utcYear2 = timeInterval2((date3) => {
+    date3.setUTCMonth(0, 1);
+    date3.setUTCHours(0, 0, 0, 0);
+}, (date3, step) => {
+    date3.setUTCFullYear(date3.getUTCFullYear() + step);
+}, (start3, end) => {
+    return end.getUTCFullYear() - start3.getUTCFullYear();
+}, (date3) => {
+    return date3.getUTCFullYear();
+});
+utcYear2.every = (k3) => {
+    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval2((date3) => {
+        date3.setUTCFullYear(Math.floor(date3.getUTCFullYear() / k3) * k3);
+        date3.setUTCMonth(0, 1);
+        date3.setUTCHours(0, 0, 0, 0);
+    }, (date3, step) => {
+        date3.setUTCFullYear(date3.getUTCFullYear() + step * k3);
     });
 };
-var utcYears = utcYear.range;
+var utcYears2 = utcYear2.range;
 
-// node_modules/d3-time/src/ticks.js
-function ticker(year, month, week, day, hour, minute) {
+// js/pyobsplot-js/node_modules/d3-time/src/ticks.js
+function ticker2(year, month, week, day, hour, minute) {
     const tickIntervals = [
-        [second, 1, durationSecond],
-        [second, 5, 5 * durationSecond],
-        [second, 15, 15 * durationSecond],
-        [second, 30, 30 * durationSecond],
-        [minute, 1, durationMinute],
-        [minute, 5, 5 * durationMinute],
-        [minute, 15, 15 * durationMinute],
-        [minute, 30, 30 * durationMinute],
-        [hour, 1, durationHour],
-        [hour, 3, 3 * durationHour],
-        [hour, 6, 6 * durationHour],
-        [hour, 12, 12 * durationHour],
-        [day, 1, durationDay],
-        [day, 2, 2 * durationDay],
-        [week, 1, durationWeek],
-        [month, 1, durationMonth],
-        [month, 3, 3 * durationMonth],
-        [year, 1, durationYear]
+        [second3, 1, durationSecond2],
+        [second3, 5, 5 * durationSecond2],
+        [second3, 15, 15 * durationSecond2],
+        [second3, 30, 30 * durationSecond2],
+        [minute, 1, durationMinute2],
+        [minute, 5, 5 * durationMinute2],
+        [minute, 15, 15 * durationMinute2],
+        [minute, 30, 30 * durationMinute2],
+        [hour, 1, durationHour2],
+        [hour, 3, 3 * durationHour2],
+        [hour, 6, 6 * durationHour2],
+        [hour, 12, 12 * durationHour2],
+        [day, 1, durationDay2],
+        [day, 2, 2 * durationDay2],
+        [week, 1, durationWeek2],
+        [month, 1, durationMonth2],
+        [month, 3, 3 * durationMonth2],
+        [year, 1, durationYear2]
     ];
 
-    function ticks2(start2, stop, count3) {
-        const reverse3 = stop < start2;
-        if (reverse3)
-            [start2, stop] = [stop, start2];
-        const interval2 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start2, stop, count3);
-        const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
-        return reverse3 ? ticks3.reverse() : ticks3;
+    function ticks3(start3, stop, count5) {
+        const reverse5 = stop < start3;
+        if (reverse5)
+            [start3, stop] = [stop, start3];
+        const interval3 = count5 && typeof count5.range === "function" ? count5 : tickInterval(start3, stop, count5);
+        const ticks4 = interval3 ? interval3.range(start3, +stop + 1) : [];
+        return reverse5 ? ticks4.reverse() : ticks4;
     }
 
-    function tickInterval(start2, stop, count3) {
-        const target = Math.abs(stop - start2) / count3;
-        const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
+    function tickInterval(start3, stop, count5) {
+        const target = Math.abs(stop - start3) / count5;
+        const i = bisector2(([, , step2]) => step2).right(tickIntervals, target);
         if (i === tickIntervals.length)
-            return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));
+            return year.every(tickStep2(start3 / durationYear2, stop / durationYear2, count5));
         if (i === 0)
-            return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));
+            return millisecond2.every(Math.max(tickStep2(start3, stop, count5), 1));
         const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
         return t.every(step);
     }
-    return [ticks2, tickInterval];
+    return [ticks3, tickInterval];
 }
-var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
-var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
+var [utcTicks2, utcTickInterval2] = ticker2(utcYear2, utcMonth2, utcSunday2, unixDay2, utcHour2, utcMinute2);
+var [timeTicks2, timeTickInterval2] = ticker2(timeYear2, timeMonth2, timeSunday2, timeDay2, timeHour2, timeMinute2);
 
-// node_modules/d3-time-format/src/locale.js
-function localDate(d) {
+// js/pyobsplot-js/node_modules/d3-time-format/src/locale.js
+function localDate2(d) {
     if (0 <= d.y && d.y < 100) {
-        var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
-        date2.setFullYear(d.y);
-        return date2;
+        var date3 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
+        date3.setFullYear(d.y);
+        return date3;
     }
     return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
 }
 
-function utcDate(d) {
+function utcDate2(d) {
     if (0 <= d.y && d.y < 100) {
-        var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
-        date2.setUTCFullYear(d.y);
-        return date2;
+        var date3 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
+        date3.setUTCFullYear(d.y);
+        return date3;
     }
     return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
 }
 
-function newDate(y4, m3, d) {
+function newDate2(y7, m5, d) {
     return {
-        y: y4,
-        m: m3,
+        y: y7,
+        m: m5,
         d,
         H: 0,
         M: 0,
         S: 0,
         L: 0
     };
 }
 
-function formatLocale(locale3) {
-    var locale_dateTime = locale3.dateTime,
-        locale_date = locale3.date,
-        locale_time = locale3.time,
-        locale_periods = locale3.periods,
-        locale_weekdays = locale3.days,
-        locale_shortWeekdays = locale3.shortDays,
-        locale_months = locale3.months,
-        locale_shortMonths = locale3.shortMonths;
-    var periodRe = formatRe(locale_periods),
-        periodLookup = formatLookup(locale_periods),
-        weekdayRe = formatRe(locale_weekdays),
-        weekdayLookup = formatLookup(locale_weekdays),
-        shortWeekdayRe = formatRe(locale_shortWeekdays),
-        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
-        monthRe = formatRe(locale_months),
-        monthLookup = formatLookup(locale_months),
-        shortMonthRe = formatRe(locale_shortMonths),
-        shortMonthLookup = formatLookup(locale_shortMonths);
+function formatLocale2(locale5) {
+    var locale_dateTime = locale5.dateTime,
+        locale_date = locale5.date,
+        locale_time = locale5.time,
+        locale_periods = locale5.periods,
+        locale_weekdays = locale5.days,
+        locale_shortWeekdays = locale5.shortDays,
+        locale_months = locale5.months,
+        locale_shortMonths = locale5.shortMonths;
+    var periodRe = formatRe2(locale_periods),
+        periodLookup = formatLookup2(locale_periods),
+        weekdayRe = formatRe2(locale_weekdays),
+        weekdayLookup = formatLookup2(locale_weekdays),
+        shortWeekdayRe = formatRe2(locale_shortWeekdays),
+        shortWeekdayLookup = formatLookup2(locale_shortWeekdays),
+        monthRe = formatRe2(locale_months),
+        monthLookup = formatLookup2(locale_months),
+        shortMonthRe = formatRe2(locale_shortMonths),
+        shortMonthLookup = formatLookup2(locale_shortMonths);
     var formats = {
         "a": formatShortWeekday,
-        "A": formatWeekday2,
+        "A": formatWeekday3,
         "b": formatShortMonth,
-        "B": formatMonth2,
+        "B": formatMonth3,
         "c": null,
-        "d": formatDayOfMonth,
-        "e": formatDayOfMonth,
-        "f": formatMicroseconds,
-        "g": formatYearISO,
-        "G": formatFullYearISO,
-        "H": formatHour24,
-        "I": formatHour12,
-        "j": formatDayOfYear,
-        "L": formatMilliseconds,
-        "m": formatMonthNumber,
-        "M": formatMinutes,
+        "d": formatDayOfMonth2,
+        "e": formatDayOfMonth2,
+        "f": formatMicroseconds2,
+        "g": formatYearISO2,
+        "G": formatFullYearISO2,
+        "H": formatHour242,
+        "I": formatHour122,
+        "j": formatDayOfYear2,
+        "L": formatMilliseconds2,
+        "m": formatMonthNumber2,
+        "M": formatMinutes2,
         "p": formatPeriod,
         "q": formatQuarter,
-        "Q": formatUnixTimestamp,
-        "s": formatUnixTimestampSeconds,
-        "S": formatSeconds,
-        "u": formatWeekdayNumberMonday,
-        "U": formatWeekNumberSunday,
-        "V": formatWeekNumberISO,
-        "w": formatWeekdayNumberSunday,
-        "W": formatWeekNumberMonday,
+        "Q": formatUnixTimestamp2,
+        "s": formatUnixTimestampSeconds2,
+        "S": formatSeconds2,
+        "u": formatWeekdayNumberMonday2,
+        "U": formatWeekNumberSunday2,
+        "V": formatWeekNumberISO2,
+        "w": formatWeekdayNumberSunday2,
+        "W": formatWeekNumberMonday2,
         "x": null,
         "X": null,
-        "y": formatYear2,
-        "Y": formatFullYear,
-        "Z": formatZone,
-        "%": formatLiteralPercent
+        "y": formatYear5,
+        "Y": formatFullYear2,
+        "Z": formatZone2,
+        "%": formatLiteralPercent2
     };
     var utcFormats = {
         "a": formatUTCShortWeekday,
         "A": formatUTCWeekday,
         "b": formatUTCShortMonth,
         "B": formatUTCMonth,
         "c": null,
-        "d": formatUTCDayOfMonth,
-        "e": formatUTCDayOfMonth,
-        "f": formatUTCMicroseconds,
-        "g": formatUTCYearISO,
-        "G": formatUTCFullYearISO,
-        "H": formatUTCHour24,
-        "I": formatUTCHour12,
-        "j": formatUTCDayOfYear,
-        "L": formatUTCMilliseconds,
-        "m": formatUTCMonthNumber,
-        "M": formatUTCMinutes,
+        "d": formatUTCDayOfMonth2,
+        "e": formatUTCDayOfMonth2,
+        "f": formatUTCMicroseconds2,
+        "g": formatUTCYearISO2,
+        "G": formatUTCFullYearISO2,
+        "H": formatUTCHour242,
+        "I": formatUTCHour122,
+        "j": formatUTCDayOfYear2,
+        "L": formatUTCMilliseconds2,
+        "m": formatUTCMonthNumber2,
+        "M": formatUTCMinutes2,
         "p": formatUTCPeriod,
         "q": formatUTCQuarter,
-        "Q": formatUnixTimestamp,
-        "s": formatUnixTimestampSeconds,
-        "S": formatUTCSeconds,
-        "u": formatUTCWeekdayNumberMonday,
-        "U": formatUTCWeekNumberSunday,
-        "V": formatUTCWeekNumberISO,
-        "w": formatUTCWeekdayNumberSunday,
-        "W": formatUTCWeekNumberMonday,
+        "Q": formatUnixTimestamp2,
+        "s": formatUnixTimestampSeconds2,
+        "S": formatUTCSeconds2,
+        "u": formatUTCWeekdayNumberMonday2,
+        "U": formatUTCWeekNumberSunday2,
+        "V": formatUTCWeekNumberISO2,
+        "w": formatUTCWeekdayNumberSunday2,
+        "W": formatUTCWeekNumberMonday2,
         "x": null,
         "X": null,
-        "y": formatUTCYear,
-        "Y": formatUTCFullYear,
-        "Z": formatUTCZone,
-        "%": formatLiteralPercent
+        "y": formatUTCYear2,
+        "Y": formatUTCFullYear2,
+        "Z": formatUTCZone2,
+        "%": formatLiteralPercent2
     };
     var parses = {
         "a": parseShortWeekday,
         "A": parseWeekday,
         "b": parseShortMonth,
         "B": parseMonth,
         "c": parseLocaleDateTime,
-        "d": parseDayOfMonth,
-        "e": parseDayOfMonth,
-        "f": parseMicroseconds,
-        "g": parseYear,
-        "G": parseFullYear,
-        "H": parseHour24,
-        "I": parseHour24,
-        "j": parseDayOfYear,
-        "L": parseMilliseconds,
-        "m": parseMonthNumber,
-        "M": parseMinutes,
+        "d": parseDayOfMonth2,
+        "e": parseDayOfMonth2,
+        "f": parseMicroseconds2,
+        "g": parseYear2,
+        "G": parseFullYear2,
+        "H": parseHour242,
+        "I": parseHour242,
+        "j": parseDayOfYear2,
+        "L": parseMilliseconds2,
+        "m": parseMonthNumber2,
+        "M": parseMinutes2,
         "p": parsePeriod,
-        "q": parseQuarter,
-        "Q": parseUnixTimestamp,
-        "s": parseUnixTimestampSeconds,
-        "S": parseSeconds,
-        "u": parseWeekdayNumberMonday,
-        "U": parseWeekNumberSunday,
-        "V": parseWeekNumberISO,
-        "w": parseWeekdayNumberSunday,
-        "W": parseWeekNumberMonday,
+        "q": parseQuarter2,
+        "Q": parseUnixTimestamp2,
+        "s": parseUnixTimestampSeconds2,
+        "S": parseSeconds2,
+        "u": parseWeekdayNumberMonday2,
+        "U": parseWeekNumberSunday2,
+        "V": parseWeekNumberISO2,
+        "w": parseWeekdayNumberSunday2,
+        "W": parseWeekNumberMonday2,
         "x": parseLocaleDate,
         "X": parseLocaleTime,
-        "y": parseYear,
-        "Y": parseFullYear,
-        "Z": parseZone,
-        "%": parseLiteralPercent
+        "y": parseYear2,
+        "Y": parseFullYear2,
+        "Z": parseZone2,
+        "%": parseLiteralPercent2
     };
     formats.x = newFormat(locale_date, formats);
     formats.X = newFormat(locale_time, formats);
     formats.c = newFormat(locale_dateTime, formats);
     utcFormats.x = newFormat(locale_date, utcFormats);
     utcFormats.X = newFormat(locale_time, utcFormats);
     utcFormats.c = newFormat(locale_dateTime, utcFormats);
 
     function newFormat(specifier, formats2) {
-        return function(date2) {
-            var string2 = [],
+        return function(date3) {
+            var string3 = [],
                 i = -1,
                 j = 0,
                 n = specifier.length,
-                c6, pad4, format3;
-            if (!(date2 instanceof Date))
-                date2 = /* @__PURE__ */ new Date(+date2);
+                c11, pad7, format5;
+            if (!(date3 instanceof Date))
+                date3 = /* @__PURE__ */ new Date(+date3);
             while (++i < n) {
                 if (specifier.charCodeAt(i) === 37) {
-                    string2.push(specifier.slice(j, i));
-                    if ((pad4 = pads[c6 = specifier.charAt(++i)]) != null)
-                        c6 = specifier.charAt(++i);
+                    string3.push(specifier.slice(j, i));
+                    if ((pad7 = pads2[c11 = specifier.charAt(++i)]) != null)
+                        c11 = specifier.charAt(++i);
                     else
-                        pad4 = c6 === "e" ? " " : "0";
-                    if (format3 = formats2[c6])
-                        c6 = format3(date2, pad4);
-                    string2.push(c6);
+                        pad7 = c11 === "e" ? " " : "0";
+                    if (format5 = formats2[c11])
+                        c11 = format5(date3, pad7);
+                    string3.push(c11);
                     j = i + 1;
                 }
             }
-            string2.push(specifier.slice(j, i));
-            return string2.join("");
+            string3.push(specifier.slice(j, i));
+            return string3.join("");
         };
     }
 
     function newParse(specifier, Z) {
-        return function(string2) {
-            var d = newDate(1900, void 0, 1),
-                i = parseSpecifier(d, specifier, string2 += "", 0),
+        return function(string3) {
+            var d = newDate2(1900, void 0, 1),
+                i = parseSpecifier(d, specifier, string3 += "", 0),
                 week, day;
-            if (i != string2.length)
+            if (i != string3.length)
                 return null;
             if ("Q" in d)
                 return new Date(d.Q);
             if ("s" in d)
                 return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
             if (Z && !("Z" in d))
                 d.Z = 0;
@@ -17684,115 +52390,115 @@
                 d.m = "q" in d ? d.q : 0;
             if ("V" in d) {
                 if (d.V < 1 || d.V > 53)
                     return null;
                 if (!("w" in d))
                     d.w = 1;
                 if ("Z" in d) {
-                    week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
-                    week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
-                    week = utcDay.offset(week, (d.V - 1) * 7);
+                    week = utcDate2(newDate2(d.y, 0, 1)), day = week.getUTCDay();
+                    week = day > 4 || day === 0 ? utcMonday2.ceil(week) : utcMonday2(week);
+                    week = utcDay2.offset(week, (d.V - 1) * 7);
                     d.y = week.getUTCFullYear();
                     d.m = week.getUTCMonth();
                     d.d = week.getUTCDate() + (d.w + 6) % 7;
                 } else {
-                    week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
-                    week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
-                    week = timeDay.offset(week, (d.V - 1) * 7);
+                    week = localDate2(newDate2(d.y, 0, 1)), day = week.getDay();
+                    week = day > 4 || day === 0 ? timeMonday2.ceil(week) : timeMonday2(week);
+                    week = timeDay2.offset(week, (d.V - 1) * 7);
                     d.y = week.getFullYear();
                     d.m = week.getMonth();
                     d.d = week.getDate() + (d.w + 6) % 7;
                 }
             } else if ("W" in d || "U" in d) {
                 if (!("w" in d))
                     d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
-                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
+                day = "Z" in d ? utcDate2(newDate2(d.y, 0, 1)).getUTCDay() : localDate2(newDate2(d.y, 0, 1)).getDay();
                 d.m = 0;
                 d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
             }
             if ("Z" in d) {
                 d.H += d.Z / 100 | 0;
                 d.M += d.Z % 100;
-                return utcDate(d);
+                return utcDate2(d);
             }
-            return localDate(d);
+            return localDate2(d);
         };
     }
 
-    function parseSpecifier(d, specifier, string2, j) {
+    function parseSpecifier(d, specifier, string3, j) {
         var i = 0,
             n = specifier.length,
-            m3 = string2.length,
-            c6, parse2;
+            m5 = string3.length,
+            c11, parse3;
         while (i < n) {
-            if (j >= m3)
+            if (j >= m5)
                 return -1;
-            c6 = specifier.charCodeAt(i++);
-            if (c6 === 37) {
-                c6 = specifier.charAt(i++);
-                parse2 = parses[c6 in pads ? specifier.charAt(i++) : c6];
-                if (!parse2 || (j = parse2(d, string2, j)) < 0)
+            c11 = specifier.charCodeAt(i++);
+            if (c11 === 37) {
+                c11 = specifier.charAt(i++);
+                parse3 = parses[c11 in pads2 ? specifier.charAt(i++) : c11];
+                if (!parse3 || (j = parse3(d, string3, j)) < 0)
                     return -1;
-            } else if (c6 != string2.charCodeAt(j++)) {
+            } else if (c11 != string3.charCodeAt(j++)) {
                 return -1;
             }
         }
         return j;
     }
 
-    function parsePeriod(d, string2, i) {
-        var n = periodRe.exec(string2.slice(i));
+    function parsePeriod(d, string3, i) {
+        var n = periodRe.exec(string3.slice(i));
         return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
     }
 
-    function parseShortWeekday(d, string2, i) {
-        var n = shortWeekdayRe.exec(string2.slice(i));
+    function parseShortWeekday(d, string3, i) {
+        var n = shortWeekdayRe.exec(string3.slice(i));
         return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
     }
 
-    function parseWeekday(d, string2, i) {
-        var n = weekdayRe.exec(string2.slice(i));
+    function parseWeekday(d, string3, i) {
+        var n = weekdayRe.exec(string3.slice(i));
         return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
     }
 
-    function parseShortMonth(d, string2, i) {
-        var n = shortMonthRe.exec(string2.slice(i));
+    function parseShortMonth(d, string3, i) {
+        var n = shortMonthRe.exec(string3.slice(i));
         return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
     }
 
-    function parseMonth(d, string2, i) {
-        var n = monthRe.exec(string2.slice(i));
+    function parseMonth(d, string3, i) {
+        var n = monthRe.exec(string3.slice(i));
         return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
     }
 
-    function parseLocaleDateTime(d, string2, i) {
-        return parseSpecifier(d, locale_dateTime, string2, i);
+    function parseLocaleDateTime(d, string3, i) {
+        return parseSpecifier(d, locale_dateTime, string3, i);
     }
 
-    function parseLocaleDate(d, string2, i) {
-        return parseSpecifier(d, locale_date, string2, i);
+    function parseLocaleDate(d, string3, i) {
+        return parseSpecifier(d, locale_date, string3, i);
     }
 
-    function parseLocaleTime(d, string2, i) {
-        return parseSpecifier(d, locale_time, string2, i);
+    function parseLocaleTime(d, string3, i) {
+        return parseSpecifier(d, locale_time, string3, i);
     }
 
     function formatShortWeekday(d) {
         return locale_shortWeekdays[d.getDay()];
     }
 
-    function formatWeekday2(d) {
+    function formatWeekday3(d) {
         return locale_weekdays[d.getDay()];
     }
 
     function formatShortMonth(d) {
         return locale_shortMonths[d.getMonth()];
     }
 
-    function formatMonth2(d) {
+    function formatMonth3(d) {
         return locale_months[d.getMonth()];
     }
 
     function formatPeriod(d) {
         return locale_periods[+(d.getHours() >= 12)];
     }
 
@@ -17850,1678 +52556,1678 @@
             p.toString = function() {
                 return specifier;
             };
             return p;
         }
     };
 }
-var pads = {
+var pads2 = {
     "-": "",
     "_": " ",
     "0": "0"
 };
-var numberRe = /^\s*\d+/;
-var percentRe = /^%/;
-var requoteRe = /[\\^$*+?|[\]().{}]/g;
+var numberRe2 = /^\s*\d+/;
+var percentRe2 = /^%/;
+var requoteRe2 = /[\\^$*+?|[\]().{}]/g;
 
-function pad2(value, fill, width) {
-    var sign3 = value < 0 ? "-" : "",
-        string2 = (sign3 ? -value : value) + "",
-        length4 = string2.length;
-    return sign3 + (length4 < width ? new Array(width - length4 + 1).join(fill) + string2 : string2);
+function pad5(value, fill, width) {
+    var sign5 = value < 0 ? "-" : "",
+        string3 = (sign5 ? -value : value) + "",
+        length7 = string3.length;
+    return sign5 + (length7 < width ? new Array(width - length7 + 1).join(fill) + string3 : string3);
 }
 
-function requote(s2) {
-    return s2.replace(requoteRe, "\\$&");
+function requote2(s3) {
+    return s3.replace(requoteRe2, "\\$&");
 }
 
-function formatRe(names) {
-    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
+function formatRe2(names) {
+    return new RegExp("^(?:" + names.map(requote2).join("|") + ")", "i");
 }
 
-function formatLookup(names) {
+function formatLookup2(names) {
     return new Map(names.map((name, i) => [name.toLowerCase(), i]));
 }
 
-function parseWeekdayNumberSunday(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 1));
+function parseWeekdayNumberSunday2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 1));
     return n ? (d.w = +n[0], i + n[0].length) : -1;
 }
 
-function parseWeekdayNumberMonday(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 1));
+function parseWeekdayNumberMonday2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 1));
     return n ? (d.u = +n[0], i + n[0].length) : -1;
 }
 
-function parseWeekNumberSunday(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseWeekNumberSunday2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.U = +n[0], i + n[0].length) : -1;
 }
 
-function parseWeekNumberISO(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseWeekNumberISO2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.V = +n[0], i + n[0].length) : -1;
 }
 
-function parseWeekNumberMonday(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseWeekNumberMonday2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.W = +n[0], i + n[0].length) : -1;
 }
 
-function parseFullYear(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 4));
+function parseFullYear2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 4));
     return n ? (d.y = +n[0], i + n[0].length) : -1;
 }
 
-function parseYear(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseYear2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
 }
 
-function parseZone(d, string2, i) {
-    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
+function parseZone2(d, string3, i) {
+    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string3.slice(i, i + 6));
     return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
 }
 
-function parseQuarter(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 1));
+function parseQuarter2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 1));
     return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
 }
 
-function parseMonthNumber(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseMonthNumber2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
 }
 
-function parseDayOfMonth(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseDayOfMonth2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.d = +n[0], i + n[0].length) : -1;
 }
 
-function parseDayOfYear(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 3));
+function parseDayOfYear2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 3));
     return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
 }
 
-function parseHour24(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseHour242(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.H = +n[0], i + n[0].length) : -1;
 }
 
-function parseMinutes(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseMinutes2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.M = +n[0], i + n[0].length) : -1;
 }
 
-function parseSeconds(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 2));
+function parseSeconds2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 2));
     return n ? (d.S = +n[0], i + n[0].length) : -1;
 }
 
-function parseMilliseconds(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 3));
+function parseMilliseconds2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 3));
     return n ? (d.L = +n[0], i + n[0].length) : -1;
 }
 
-function parseMicroseconds(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i, i + 6));
+function parseMicroseconds2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i, i + 6));
     return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
 }
 
-function parseLiteralPercent(d, string2, i) {
-    var n = percentRe.exec(string2.slice(i, i + 1));
+function parseLiteralPercent2(d, string3, i) {
+    var n = percentRe2.exec(string3.slice(i, i + 1));
     return n ? i + n[0].length : -1;
 }
 
-function parseUnixTimestamp(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i));
+function parseUnixTimestamp2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i));
     return n ? (d.Q = +n[0], i + n[0].length) : -1;
 }
 
-function parseUnixTimestampSeconds(d, string2, i) {
-    var n = numberRe.exec(string2.slice(i));
+function parseUnixTimestampSeconds2(d, string3, i) {
+    var n = numberRe2.exec(string3.slice(i));
     return n ? (d.s = +n[0], i + n[0].length) : -1;
 }
 
-function formatDayOfMonth(d, p) {
-    return pad2(d.getDate(), p, 2);
+function formatDayOfMonth2(d, p) {
+    return pad5(d.getDate(), p, 2);
 }
 
-function formatHour24(d, p) {
-    return pad2(d.getHours(), p, 2);
+function formatHour242(d, p) {
+    return pad5(d.getHours(), p, 2);
 }
 
-function formatHour12(d, p) {
-    return pad2(d.getHours() % 12 || 12, p, 2);
+function formatHour122(d, p) {
+    return pad5(d.getHours() % 12 || 12, p, 2);
 }
 
-function formatDayOfYear(d, p) {
-    return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
+function formatDayOfYear2(d, p) {
+    return pad5(1 + timeDay2.count(timeYear2(d), d), p, 3);
 }
 
-function formatMilliseconds(d, p) {
-    return pad2(d.getMilliseconds(), p, 3);
+function formatMilliseconds2(d, p) {
+    return pad5(d.getMilliseconds(), p, 3);
 }
 
-function formatMicroseconds(d, p) {
-    return formatMilliseconds(d, p) + "000";
+function formatMicroseconds2(d, p) {
+    return formatMilliseconds2(d, p) + "000";
 }
 
-function formatMonthNumber(d, p) {
-    return pad2(d.getMonth() + 1, p, 2);
+function formatMonthNumber2(d, p) {
+    return pad5(d.getMonth() + 1, p, 2);
 }
 
-function formatMinutes(d, p) {
-    return pad2(d.getMinutes(), p, 2);
+function formatMinutes2(d, p) {
+    return pad5(d.getMinutes(), p, 2);
 }
 
-function formatSeconds(d, p) {
-    return pad2(d.getSeconds(), p, 2);
+function formatSeconds2(d, p) {
+    return pad5(d.getSeconds(), p, 2);
 }
 
-function formatWeekdayNumberMonday(d) {
+function formatWeekdayNumberMonday2(d) {
     var day = d.getDay();
     return day === 0 ? 7 : day;
 }
 
-function formatWeekNumberSunday(d, p) {
-    return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
+function formatWeekNumberSunday2(d, p) {
+    return pad5(timeSunday2.count(timeYear2(d) - 1, d), p, 2);
 }
 
-function dISO(d) {
+function dISO2(d) {
     var day = d.getDay();
-    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
+    return day >= 4 || day === 0 ? timeThursday2(d) : timeThursday2.ceil(d);
 }
 
-function formatWeekNumberISO(d, p) {
-    d = dISO(d);
-    return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
+function formatWeekNumberISO2(d, p) {
+    d = dISO2(d);
+    return pad5(timeThursday2.count(timeYear2(d), d) + (timeYear2(d).getDay() === 4), p, 2);
 }
 
-function formatWeekdayNumberSunday(d) {
+function formatWeekdayNumberSunday2(d) {
     return d.getDay();
 }
 
-function formatWeekNumberMonday(d, p) {
-    return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
+function formatWeekNumberMonday2(d, p) {
+    return pad5(timeMonday2.count(timeYear2(d) - 1, d), p, 2);
 }
 
-function formatYear2(d, p) {
-    return pad2(d.getFullYear() % 100, p, 2);
+function formatYear5(d, p) {
+    return pad5(d.getFullYear() % 100, p, 2);
 }
 
-function formatYearISO(d, p) {
-    d = dISO(d);
-    return pad2(d.getFullYear() % 100, p, 2);
+function formatYearISO2(d, p) {
+    d = dISO2(d);
+    return pad5(d.getFullYear() % 100, p, 2);
 }
 
-function formatFullYear(d, p) {
-    return pad2(d.getFullYear() % 1e4, p, 4);
+function formatFullYear2(d, p) {
+    return pad5(d.getFullYear() % 1e4, p, 4);
 }
 
-function formatFullYearISO(d, p) {
+function formatFullYearISO2(d, p) {
     var day = d.getDay();
-    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
-    return pad2(d.getFullYear() % 1e4, p, 4);
+    d = day >= 4 || day === 0 ? timeThursday2(d) : timeThursday2.ceil(d);
+    return pad5(d.getFullYear() % 1e4, p, 4);
 }
 
-function formatZone(d) {
+function formatZone2(d) {
     var z = d.getTimezoneOffset();
-    return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
+    return (z > 0 ? "-" : (z *= -1, "+")) + pad5(z / 60 | 0, "0", 2) + pad5(z % 60, "0", 2);
 }
 
-function formatUTCDayOfMonth(d, p) {
-    return pad2(d.getUTCDate(), p, 2);
+function formatUTCDayOfMonth2(d, p) {
+    return pad5(d.getUTCDate(), p, 2);
 }
 
-function formatUTCHour24(d, p) {
-    return pad2(d.getUTCHours(), p, 2);
+function formatUTCHour242(d, p) {
+    return pad5(d.getUTCHours(), p, 2);
 }
 
-function formatUTCHour12(d, p) {
-    return pad2(d.getUTCHours() % 12 || 12, p, 2);
+function formatUTCHour122(d, p) {
+    return pad5(d.getUTCHours() % 12 || 12, p, 2);
 }
 
-function formatUTCDayOfYear(d, p) {
-    return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
+function formatUTCDayOfYear2(d, p) {
+    return pad5(1 + utcDay2.count(utcYear2(d), d), p, 3);
 }
 
-function formatUTCMilliseconds(d, p) {
-    return pad2(d.getUTCMilliseconds(), p, 3);
+function formatUTCMilliseconds2(d, p) {
+    return pad5(d.getUTCMilliseconds(), p, 3);
 }
 
-function formatUTCMicroseconds(d, p) {
-    return formatUTCMilliseconds(d, p) + "000";
+function formatUTCMicroseconds2(d, p) {
+    return formatUTCMilliseconds2(d, p) + "000";
 }
 
-function formatUTCMonthNumber(d, p) {
-    return pad2(d.getUTCMonth() + 1, p, 2);
+function formatUTCMonthNumber2(d, p) {
+    return pad5(d.getUTCMonth() + 1, p, 2);
 }
 
-function formatUTCMinutes(d, p) {
-    return pad2(d.getUTCMinutes(), p, 2);
+function formatUTCMinutes2(d, p) {
+    return pad5(d.getUTCMinutes(), p, 2);
 }
 
-function formatUTCSeconds(d, p) {
-    return pad2(d.getUTCSeconds(), p, 2);
+function formatUTCSeconds2(d, p) {
+    return pad5(d.getUTCSeconds(), p, 2);
 }
 
-function formatUTCWeekdayNumberMonday(d) {
+function formatUTCWeekdayNumberMonday2(d) {
     var dow = d.getUTCDay();
     return dow === 0 ? 7 : dow;
 }
 
-function formatUTCWeekNumberSunday(d, p) {
-    return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
+function formatUTCWeekNumberSunday2(d, p) {
+    return pad5(utcSunday2.count(utcYear2(d) - 1, d), p, 2);
 }
 
-function UTCdISO(d) {
+function UTCdISO2(d) {
     var day = d.getUTCDay();
-    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
+    return day >= 4 || day === 0 ? utcThursday2(d) : utcThursday2.ceil(d);
 }
 
-function formatUTCWeekNumberISO(d, p) {
-    d = UTCdISO(d);
-    return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
+function formatUTCWeekNumberISO2(d, p) {
+    d = UTCdISO2(d);
+    return pad5(utcThursday2.count(utcYear2(d), d) + (utcYear2(d).getUTCDay() === 4), p, 2);
 }
 
-function formatUTCWeekdayNumberSunday(d) {
+function formatUTCWeekdayNumberSunday2(d) {
     return d.getUTCDay();
 }
 
-function formatUTCWeekNumberMonday(d, p) {
-    return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
+function formatUTCWeekNumberMonday2(d, p) {
+    return pad5(utcMonday2.count(utcYear2(d) - 1, d), p, 2);
 }
 
-function formatUTCYear(d, p) {
-    return pad2(d.getUTCFullYear() % 100, p, 2);
+function formatUTCYear2(d, p) {
+    return pad5(d.getUTCFullYear() % 100, p, 2);
 }
 
-function formatUTCYearISO(d, p) {
-    d = UTCdISO(d);
-    return pad2(d.getUTCFullYear() % 100, p, 2);
+function formatUTCYearISO2(d, p) {
+    d = UTCdISO2(d);
+    return pad5(d.getUTCFullYear() % 100, p, 2);
 }
 
-function formatUTCFullYear(d, p) {
-    return pad2(d.getUTCFullYear() % 1e4, p, 4);
+function formatUTCFullYear2(d, p) {
+    return pad5(d.getUTCFullYear() % 1e4, p, 4);
 }
 
-function formatUTCFullYearISO(d, p) {
+function formatUTCFullYearISO2(d, p) {
     var day = d.getUTCDay();
-    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
-    return pad2(d.getUTCFullYear() % 1e4, p, 4);
+    d = day >= 4 || day === 0 ? utcThursday2(d) : utcThursday2.ceil(d);
+    return pad5(d.getUTCFullYear() % 1e4, p, 4);
 }
 
-function formatUTCZone() {
+function formatUTCZone2() {
     return "+0000";
 }
 
-function formatLiteralPercent() {
+function formatLiteralPercent2() {
     return "%";
 }
 
-function formatUnixTimestamp(d) {
+function formatUnixTimestamp2(d) {
     return +d;
 }
 
-function formatUnixTimestampSeconds(d) {
+function formatUnixTimestampSeconds2(d) {
     return Math.floor(+d / 1e3);
 }
 
-// node_modules/d3-time-format/src/defaultLocale.js
-var locale2;
-var timeFormat;
-var timeParse;
-var utcFormat;
-var utcParse;
-defaultLocale2({
+// js/pyobsplot-js/node_modules/d3-time-format/src/defaultLocale.js
+var locale4;
+var timeFormat2;
+var timeParse2;
+var utcFormat2;
+var utcParse2;
+defaultLocale4({
     dateTime: "%x, %X",
     date: "%-m/%-d/%Y",
     time: "%-I:%M:%S %p",
     periods: ["AM", "PM"],
     days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
     shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
     months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
     shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
 });
 
-function defaultLocale2(definition) {
-    locale2 = formatLocale(definition);
-    timeFormat = locale2.format;
-    timeParse = locale2.parse;
-    utcFormat = locale2.utcFormat;
-    utcParse = locale2.utcParse;
-    return locale2;
-}
-
-// node_modules/d3-time-format/src/isoFormat.js
-var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
-
-function formatIsoNative(date2) {
-    return date2.toISOString();
-}
-var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
-var isoFormat_default = formatIso;
-
-// node_modules/d3-time-format/src/isoParse.js
-function parseIsoNative(string2) {
-    var date2 = new Date(string2);
-    return isNaN(date2) ? null : date2;
+function defaultLocale4(definition) {
+    locale4 = formatLocale2(definition);
+    timeFormat2 = locale4.format;
+    timeParse2 = locale4.parse;
+    utcFormat2 = locale4.utcFormat;
+    utcParse2 = locale4.utcParse;
+    return locale4;
+}
+
+// js/pyobsplot-js/node_modules/d3-time-format/src/isoFormat.js
+var isoSpecifier2 = "%Y-%m-%dT%H:%M:%S.%LZ";
+
+function formatIsoNative2(date3) {
+    return date3.toISOString();
+}
+var formatIso2 = Date.prototype.toISOString ? formatIsoNative2 : utcFormat2(isoSpecifier2);
+var isoFormat_default2 = formatIso2;
+
+// js/pyobsplot-js/node_modules/d3-time-format/src/isoParse.js
+function parseIsoNative2(string3) {
+    var date3 = new Date(string3);
+    return isNaN(date3) ? null : date3;
 }
-var parseIso = + /* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
-var isoParse_default = parseIso;
+var parseIso2 = + /* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative2 : utcParse2(isoSpecifier2);
+var isoParse_default2 = parseIso2;
 
-// node_modules/d3-scale/src/time.js
-function date(t) {
+// js/pyobsplot-js/node_modules/d3-scale/src/time.js
+function date2(t) {
     return new Date(t);
 }
 
-function number4(t) {
+function number10(t) {
     return t instanceof Date ? +t : + /* @__PURE__ */ new Date(+t);
 }
 
-function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
-    var scale3 = continuous(),
-        invert = scale3.invert,
-        domain = scale3.domain;
-    var formatMillisecond = format3(".%L"),
-        formatSecond = format3(":%S"),
-        formatMinute = format3("%I:%M"),
-        formatHour = format3("%I %p"),
-        formatDay = format3("%a %d"),
-        formatWeek = format3("%b %d"),
-        formatMonth2 = format3("%B"),
-        formatYear4 = format3("%Y");
-
-    function tickFormat2(date2) {
-        return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear4)(date2);
+function calendar2(ticks3, tickInterval, year, month, week, day, hour, minute, second5, format5) {
+    var scale5 = continuous2(),
+        invert = scale5.invert,
+        domain = scale5.domain;
+    var formatMillisecond = format5(".%L"),
+        formatSecond = format5(":%S"),
+        formatMinute = format5("%I:%M"),
+        formatHour = format5("%I %p"),
+        formatDay = format5("%a %d"),
+        formatWeek = format5("%b %d"),
+        formatMonth3 = format5("%B"),
+        formatYear7 = format5("%Y");
+
+    function tickFormat3(date3) {
+        return (second5(date3) < date3 ? formatMillisecond : minute(date3) < date3 ? formatSecond : hour(date3) < date3 ? formatMinute : day(date3) < date3 ? formatHour : month(date3) < date3 ? week(date3) < date3 ? formatDay : formatWeek : year(date3) < date3 ? formatMonth3 : formatYear7)(date3);
     }
-    scale3.invert = function(y4) {
-        return new Date(invert(y4));
+    scale5.invert = function(y7) {
+        return new Date(invert(y7));
     };
-    scale3.domain = function(_) {
-        return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);
+    scale5.domain = function(_) {
+        return arguments.length ? domain(Array.from(_, number10)) : domain().map(date2);
     };
-    scale3.ticks = function(interval2) {
+    scale5.ticks = function(interval3) {
         var d = domain();
-        return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
+        return ticks3(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
     };
-    scale3.tickFormat = function(count3, specifier) {
-        return specifier == null ? tickFormat2 : format3(specifier);
+    scale5.tickFormat = function(count5, specifier) {
+        return specifier == null ? tickFormat3 : format5(specifier);
     };
-    scale3.nice = function(interval2) {
+    scale5.nice = function(interval3) {
         var d = domain();
-        if (!interval2 || typeof interval2.range !== "function")
-            interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
-        return interval2 ? domain(nice2(d, interval2)) : scale3;
+        if (!interval3 || typeof interval3.range !== "function")
+            interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
+        return interval3 ? domain(nice4(d, interval3)) : scale5;
     };
-    scale3.copy = function() {
-        return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
+    scale5.copy = function() {
+        return copy3(scale5, calendar2(ticks3, tickInterval, year, month, week, day, hour, minute, second5, format5));
     };
-    return scale3;
+    return scale5;
 }
 
-function time() {
-    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
+function time2() {
+    return initRange2.apply(calendar2(timeTicks2, timeTickInterval2, timeYear2, timeMonth2, timeSunday2, timeDay2, timeHour2, timeMinute2, second3, timeFormat2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
 }
 
-// node_modules/d3-scale/src/utcTime.js
-function utcTime() {
-    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
+// js/pyobsplot-js/node_modules/d3-scale/src/utcTime.js
+function utcTime2() {
+    return initRange2.apply(calendar2(utcTicks2, utcTickInterval2, utcYear2, utcMonth2, utcSunday2, utcDay2, utcHour2, utcMinute2, second3, utcFormat2).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
 }
 
-// node_modules/d3-scale/src/sequential.js
-function transformer3() {
-    var x06 = 0,
-        x12 = 1,
-        t03, t13, k10, transform2, interpolator = identity3,
+// js/pyobsplot-js/node_modules/d3-scale/src/sequential.js
+function transformer7() {
+    var x011 = 0,
+        x13 = 1,
+        t05, t15, k10, transform3, interpolator = identity10,
         clamp = false,
         unknown;
 
-    function scale3(x4) {
-        return x4 == null || isNaN(x4 = +x4) ? unknown : interpolator(k10 === 0 ? 0.5 : (x4 = (transform2(x4) - t03) * k10, clamp ? Math.max(0, Math.min(1, x4)) : x4));
+    function scale5(x7) {
+        return x7 == null || isNaN(x7 = +x7) ? unknown : interpolator(k10 === 0 ? 0.5 : (x7 = (transform3(x7) - t05) * k10, clamp ? Math.max(0, Math.min(1, x7)) : x7));
     }
-    scale3.domain = function(_) {
-        return arguments.length ? ([x06, x12] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale3) : [x06, x12];
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13] = _, t05 = transform3(x011 = +x011), t15 = transform3(x13 = +x13), k10 = t05 === t15 ? 0 : 1 / (t15 - t05), scale5) : [x011, x13];
     };
-    scale3.clamp = function(_) {
-        return arguments.length ? (clamp = !!_, scale3) : clamp;
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = !!_, scale5) : clamp;
     };
-    scale3.interpolator = function(_) {
-        return arguments.length ? (interpolator = _, scale3) : interpolator;
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
     };
 
-    function range5(interpolate) {
+    function range9(interpolate) {
         return function(_) {
             var r0, r1;
-            return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale3) : [interpolator(0), interpolator(1)];
+            return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale5) : [interpolator(0), interpolator(1)];
         };
     }
-    scale3.range = range5(value_default);
-    scale3.rangeRound = range5(round_default);
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.range = range9(value_default2);
+    scale5.rangeRound = range9(round_default3);
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
     return function(t) {
-        transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
-        return scale3;
+        transform3 = t, t05 = t(x011), t15 = t(x13), k10 = t05 === t15 ? 0 : 1 / (t15 - t05);
+        return scale5;
     };
 }
 
-function copy2(source, target) {
+function copy4(source, target) {
     return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
 }
 
-function sequential() {
-    var scale3 = linearish(transformer3()(identity3));
-    scale3.copy = function() {
-        return copy2(scale3, sequential());
+function sequential2() {
+    var scale5 = linearish2(transformer7()(identity10));
+    scale5.copy = function() {
+        return copy4(scale5, sequential2());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function sequentialLog() {
-    var scale3 = loggish(transformer3()).domain([1, 10]);
-    scale3.copy = function() {
-        return copy2(scale3, sequentialLog()).base(scale3.base());
+function sequentialLog2() {
+    var scale5 = loggish2(transformer7()).domain([1, 10]);
+    scale5.copy = function() {
+        return copy4(scale5, sequentialLog2()).base(scale5.base());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function sequentialSymlog() {
-    var scale3 = symlogish(transformer3());
-    scale3.copy = function() {
-        return copy2(scale3, sequentialSymlog()).constant(scale3.constant());
+function sequentialSymlog2() {
+    var scale5 = symlogish2(transformer7());
+    scale5.copy = function() {
+        return copy4(scale5, sequentialSymlog2()).constant(scale5.constant());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function sequentialPow() {
-    var scale3 = powish(transformer3());
-    scale3.copy = function() {
-        return copy2(scale3, sequentialPow()).exponent(scale3.exponent());
+function sequentialPow2() {
+    var scale5 = powish2(transformer7());
+    scale5.copy = function() {
+        return copy4(scale5, sequentialPow2()).exponent(scale5.exponent());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function sequentialSqrt() {
-    return sequentialPow.apply(null, arguments).exponent(0.5);
+function sequentialSqrt2() {
+    return sequentialPow2.apply(null, arguments).exponent(0.5);
 }
 
-// node_modules/d3-scale/src/sequentialQuantile.js
-function sequentialQuantile() {
+// js/pyobsplot-js/node_modules/d3-scale/src/sequentialQuantile.js
+function sequentialQuantile2() {
     var domain = [],
-        interpolator = identity3;
+        interpolator = identity10;
 
-    function scale3(x4) {
-        if (x4 != null && !isNaN(x4 = +x4))
-            return interpolator((bisect_default(domain, x4, 1) - 1) / (domain.length - 1));
+    function scale5(x7) {
+        if (x7 != null && !isNaN(x7 = +x7))
+            return interpolator((bisect_default2(domain, x7, 1) - 1) / (domain.length - 1));
     }
-    scale3.domain = function(_) {
+    scale5.domain = function(_) {
         if (!arguments.length)
             return domain.slice();
         domain = [];
         for (let d of _)
             if (d != null && !isNaN(d = +d))
                 domain.push(d);
-        domain.sort(ascending);
-        return scale3;
+        domain.sort(ascending3);
+        return scale5;
     };
-    scale3.interpolator = function(_) {
-        return arguments.length ? (interpolator = _, scale3) : interpolator;
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
     };
-    scale3.range = function() {
+    scale5.range = function() {
         return domain.map((d, i) => interpolator(i / (domain.length - 1)));
     };
-    scale3.quantiles = function(n) {
+    scale5.quantiles = function(n) {
         return Array.from({
             length: n + 1
-        }, (_, i) => quantile(domain, i / n));
+        }, (_, i) => quantile3(domain, i / n));
     };
-    scale3.copy = function() {
-        return sequentialQuantile(interpolator).domain(domain);
+    scale5.copy = function() {
+        return sequentialQuantile2(interpolator).domain(domain);
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-// node_modules/d3-scale/src/diverging.js
-function transformer4() {
-    var x06 = 0,
-        x12 = 0.5,
+// js/pyobsplot-js/node_modules/d3-scale/src/diverging.js
+function transformer8() {
+    var x011 = 0,
+        x13 = 0.5,
         x22 = 1,
-        s2 = 1,
-        t03, t13, t22, k10, k21, interpolator = identity3,
-        transform2, clamp = false,
+        s3 = 1,
+        t05, t15, t23, k10, k21, interpolator = identity10,
+        transform3, clamp = false,
         unknown;
 
-    function scale3(x4) {
-        return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform2(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));
+    function scale5(x7) {
+        return isNaN(x7 = +x7) ? unknown : (x7 = 0.5 + ((x7 = +transform3(x7)) - t15) * (s3 * x7 < s3 * t15 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x7)) : x7));
     }
-    scale3.domain = function(_) {
-        return arguments.length ? ([x06, x12, x22] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];
+    scale5.domain = function(_) {
+        return arguments.length ? ([x011, x13, x22] = _, t05 = transform3(x011 = +x011), t15 = transform3(x13 = +x13), t23 = transform3(x22 = +x22), k10 = t05 === t15 ? 0 : 0.5 / (t15 - t05), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t05 ? -1 : 1, scale5) : [x011, x13, x22];
     };
-    scale3.clamp = function(_) {
-        return arguments.length ? (clamp = !!_, scale3) : clamp;
+    scale5.clamp = function(_) {
+        return arguments.length ? (clamp = !!_, scale5) : clamp;
     };
-    scale3.interpolator = function(_) {
-        return arguments.length ? (interpolator = _, scale3) : interpolator;
+    scale5.interpolator = function(_) {
+        return arguments.length ? (interpolator = _, scale5) : interpolator;
     };
 
-    function range5(interpolate) {
+    function range9(interpolate) {
         return function(_) {
             var r0, r1, r2;
-            return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];
+            return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise2(interpolate, [r0, r1, r2]), scale5) : [interpolator(0), interpolator(0.5), interpolator(1)];
         };
     }
-    scale3.range = range5(value_default);
-    scale3.rangeRound = range5(round_default);
-    scale3.unknown = function(_) {
-        return arguments.length ? (unknown = _, scale3) : unknown;
+    scale5.range = range9(value_default2);
+    scale5.rangeRound = range9(round_default3);
+    scale5.unknown = function(_) {
+        return arguments.length ? (unknown = _, scale5) : unknown;
     };
     return function(t) {
-        transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
-        return scale3;
+        transform3 = t, t05 = t(x011), t15 = t(x13), t23 = t(x22), k10 = t05 === t15 ? 0 : 0.5 / (t15 - t05), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t05 ? -1 : 1;
+        return scale5;
     };
 }
 
-function diverging() {
-    var scale3 = linearish(transformer4()(identity3));
-    scale3.copy = function() {
-        return copy2(scale3, diverging());
+function diverging2() {
+    var scale5 = linearish2(transformer8()(identity10));
+    scale5.copy = function() {
+        return copy4(scale5, diverging2());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function divergingLog() {
-    var scale3 = loggish(transformer4()).domain([0.1, 1, 10]);
-    scale3.copy = function() {
-        return copy2(scale3, divergingLog()).base(scale3.base());
+function divergingLog2() {
+    var scale5 = loggish2(transformer8()).domain([0.1, 1, 10]);
+    scale5.copy = function() {
+        return copy4(scale5, divergingLog2()).base(scale5.base());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function divergingSymlog() {
-    var scale3 = symlogish(transformer4());
-    scale3.copy = function() {
-        return copy2(scale3, divergingSymlog()).constant(scale3.constant());
+function divergingSymlog2() {
+    var scale5 = symlogish2(transformer8());
+    scale5.copy = function() {
+        return copy4(scale5, divergingSymlog2()).constant(scale5.constant());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function divergingPow() {
-    var scale3 = powish(transformer4());
-    scale3.copy = function() {
-        return copy2(scale3, divergingPow()).exponent(scale3.exponent());
+function divergingPow2() {
+    var scale5 = powish2(transformer8());
+    scale5.copy = function() {
+        return copy4(scale5, divergingPow2()).exponent(scale5.exponent());
     };
-    return initInterpolator.apply(scale3, arguments);
+    return initInterpolator2.apply(scale5, arguments);
 }
 
-function divergingSqrt() {
-    return divergingPow.apply(null, arguments).exponent(0.5);
+function divergingSqrt2() {
+    return divergingPow2.apply(null, arguments).exponent(0.5);
 }
 
-// node_modules/d3-scale-chromatic/src/colors.js
-function colors_default(specifier) {
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/colors.js
+function colors_default2(specifier) {
     var n = specifier.length / 6 | 0,
         colors = new Array(n),
         i = 0;
     while (i < n)
         colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
     return colors;
 }
 
-// node_modules/d3-scale-chromatic/src/categorical/category10.js
-var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/category10.js
+var category10_default2 = colors_default2("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
 
-// node_modules/d3-scale-chromatic/src/categorical/Accent.js
-var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Accent.js
+var Accent_default2 = colors_default2("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
 
-// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
-var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Dark2.js
+var Dark2_default2 = colors_default2("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
 
-// node_modules/d3-scale-chromatic/src/categorical/Paired.js
-var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Paired.js
+var Paired_default2 = colors_default2("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
 
-// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
-var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
+var Pastel1_default2 = colors_default2("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
 
-// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
-var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
+var Pastel2_default2 = colors_default2("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
 
-// node_modules/d3-scale-chromatic/src/categorical/Set1.js
-var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Set1.js
+var Set1_default2 = colors_default2("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
 
-// node_modules/d3-scale-chromatic/src/categorical/Set2.js
-var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Set2.js
+var Set2_default2 = colors_default2("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
 
-// node_modules/d3-scale-chromatic/src/categorical/Set3.js
-var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Set3.js
+var Set3_default2 = colors_default2("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
 
-// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
-var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
+var Tableau10_default2 = colors_default2("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
 
-// node_modules/d3-scale-chromatic/src/ramp.js
-var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/ramp.js
+var ramp_default2 = (scheme55) => rgbBasis2(scheme55[scheme55.length - 1]);
 
-// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
-var scheme = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/BrBG.js
+var scheme28 = new Array(3).concat(
     "d8b365f5f5f55ab4ac",
     "a6611adfc27d80cdc1018571",
     "a6611adfc27df5f5f580cdc1018571",
     "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
     "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
     "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
     "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
     "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
     "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
-).map(colors_default);
-var BrBG_default = ramp_default(scheme);
+).map(colors_default2);
+var BrBG_default2 = ramp_default2(scheme28);
 
-// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
-var scheme2 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/PRGn.js
+var scheme29 = new Array(3).concat(
     "af8dc3f7f7f77fbf7b",
     "7b3294c2a5cfa6dba0008837",
     "7b3294c2a5cff7f7f7a6dba0008837",
     "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
     "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
     "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
     "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
     "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
     "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
-).map(colors_default);
-var PRGn_default = ramp_default(scheme2);
+).map(colors_default2);
+var PRGn_default2 = ramp_default2(scheme29);
 
-// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
-var scheme3 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/PiYG.js
+var scheme30 = new Array(3).concat(
     "e9a3c9f7f7f7a1d76a",
     "d01c8bf1b6dab8e1864dac26",
     "d01c8bf1b6daf7f7f7b8e1864dac26",
     "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
     "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
     "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
     "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
     "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
     "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
-).map(colors_default);
-var PiYG_default = ramp_default(scheme3);
+).map(colors_default2);
+var PiYG_default2 = ramp_default2(scheme30);
 
-// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
-var scheme4 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/PuOr.js
+var scheme31 = new Array(3).concat(
     "998ec3f7f7f7f1a340",
     "5e3c99b2abd2fdb863e66101",
     "5e3c99b2abd2f7f7f7fdb863e66101",
     "542788998ec3d8daebfee0b6f1a340b35806",
     "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
     "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
     "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
     "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
     "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
-).map(colors_default);
-var PuOr_default = ramp_default(scheme4);
+).map(colors_default2);
+var PuOr_default2 = ramp_default2(scheme31);
 
-// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
-var scheme5 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/RdBu.js
+var scheme32 = new Array(3).concat(
     "ef8a62f7f7f767a9cf",
     "ca0020f4a58292c5de0571b0",
     "ca0020f4a582f7f7f792c5de0571b0",
     "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
     "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
     "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
     "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
     "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
     "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
-).map(colors_default);
-var RdBu_default = ramp_default(scheme5);
+).map(colors_default2);
+var RdBu_default2 = ramp_default2(scheme32);
 
-// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
-var scheme6 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/RdGy.js
+var scheme33 = new Array(3).concat(
     "ef8a62ffffff999999",
     "ca0020f4a582bababa404040",
     "ca0020f4a582ffffffbababa404040",
     "b2182bef8a62fddbc7e0e0e09999994d4d4d",
     "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
     "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
     "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
     "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
     "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
-).map(colors_default);
-var RdGy_default = ramp_default(scheme6);
+).map(colors_default2);
+var RdGy_default2 = ramp_default2(scheme33);
 
-// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
-var scheme7 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
+var scheme34 = new Array(3).concat(
     "fc8d59ffffbf91bfdb",
     "d7191cfdae61abd9e92c7bb6",
     "d7191cfdae61ffffbfabd9e92c7bb6",
     "d73027fc8d59fee090e0f3f891bfdb4575b4",
     "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
     "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
     "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
     "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
     "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
-).map(colors_default);
-var RdYlBu_default = ramp_default(scheme7);
+).map(colors_default2);
+var RdYlBu_default2 = ramp_default2(scheme34);
 
-// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
-var scheme8 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
+var scheme35 = new Array(3).concat(
     "fc8d59ffffbf91cf60",
     "d7191cfdae61a6d96a1a9641",
     "d7191cfdae61ffffbfa6d96a1a9641",
     "d73027fc8d59fee08bd9ef8b91cf601a9850",
     "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
     "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
     "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
     "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
     "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
-).map(colors_default);
-var RdYlGn_default = ramp_default(scheme8);
+).map(colors_default2);
+var RdYlGn_default2 = ramp_default2(scheme35);
 
-// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
-var scheme9 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/diverging/Spectral.js
+var scheme36 = new Array(3).concat(
     "fc8d59ffffbf99d594",
     "d7191cfdae61abdda42b83ba",
     "d7191cfdae61ffffbfabdda42b83ba",
     "d53e4ffc8d59fee08be6f59899d5943288bd",
     "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
     "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
     "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
     "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
     "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
-).map(colors_default);
-var Spectral_default = ramp_default(scheme9);
+).map(colors_default2);
+var Spectral_default2 = ramp_default2(scheme36);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
-var scheme10 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
+var scheme37 = new Array(3).concat(
     "e5f5f999d8c92ca25f",
     "edf8fbb2e2e266c2a4238b45",
     "edf8fbb2e2e266c2a42ca25f006d2c",
     "edf8fbccece699d8c966c2a42ca25f006d2c",
     "edf8fbccece699d8c966c2a441ae76238b45005824",
     "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
     "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
-).map(colors_default);
-var BuGn_default = ramp_default(scheme10);
+).map(colors_default2);
+var BuGn_default2 = ramp_default2(scheme37);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
-var scheme11 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
+var scheme38 = new Array(3).concat(
     "e0ecf49ebcda8856a7",
     "edf8fbb3cde38c96c688419d",
     "edf8fbb3cde38c96c68856a7810f7c",
     "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
     "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
     "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
     "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
-).map(colors_default);
-var BuPu_default = ramp_default(scheme11);
+).map(colors_default2);
+var BuPu_default2 = ramp_default2(scheme38);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
-var scheme12 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
+var scheme39 = new Array(3).concat(
     "e0f3dba8ddb543a2ca",
     "f0f9e8bae4bc7bccc42b8cbe",
     "f0f9e8bae4bc7bccc443a2ca0868ac",
     "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
     "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
     "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
     "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
-).map(colors_default);
-var GnBu_default = ramp_default(scheme12);
+).map(colors_default2);
+var GnBu_default2 = ramp_default2(scheme39);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
-var scheme13 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
+var scheme40 = new Array(3).concat(
     "fee8c8fdbb84e34a33",
     "fef0d9fdcc8afc8d59d7301f",
     "fef0d9fdcc8afc8d59e34a33b30000",
     "fef0d9fdd49efdbb84fc8d59e34a33b30000",
     "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
     "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
     "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
-).map(colors_default);
-var OrRd_default = ramp_default(scheme13);
+).map(colors_default2);
+var OrRd_default2 = ramp_default2(scheme40);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
-var scheme14 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
+var scheme41 = new Array(3).concat(
     "ece2f0a6bddb1c9099",
     "f6eff7bdc9e167a9cf02818a",
     "f6eff7bdc9e167a9cf1c9099016c59",
     "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
     "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
     "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
     "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
-).map(colors_default);
-var PuBuGn_default = ramp_default(scheme14);
+).map(colors_default2);
+var PuBuGn_default2 = ramp_default2(scheme41);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
-var scheme15 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
+var scheme42 = new Array(3).concat(
     "ece7f2a6bddb2b8cbe",
     "f1eef6bdc9e174a9cf0570b0",
     "f1eef6bdc9e174a9cf2b8cbe045a8d",
     "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
     "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
     "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
     "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
-).map(colors_default);
-var PuBu_default = ramp_default(scheme15);
+).map(colors_default2);
+var PuBu_default2 = ramp_default2(scheme42);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
-var scheme16 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
+var scheme43 = new Array(3).concat(
     "e7e1efc994c7dd1c77",
     "f1eef6d7b5d8df65b0ce1256",
     "f1eef6d7b5d8df65b0dd1c77980043",
     "f1eef6d4b9dac994c7df65b0dd1c77980043",
     "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
     "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
     "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
-).map(colors_default);
-var PuRd_default = ramp_default(scheme16);
+).map(colors_default2);
+var PuRd_default2 = ramp_default2(scheme43);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
-var scheme17 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
+var scheme44 = new Array(3).concat(
     "fde0ddfa9fb5c51b8a",
     "feebe2fbb4b9f768a1ae017e",
     "feebe2fbb4b9f768a1c51b8a7a0177",
     "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
     "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
     "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
     "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
-).map(colors_default);
-var RdPu_default = ramp_default(scheme17);
+).map(colors_default2);
+var RdPu_default2 = ramp_default2(scheme44);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
-var scheme18 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
+var scheme45 = new Array(3).concat(
     "edf8b17fcdbb2c7fb8",
     "ffffcca1dab441b6c4225ea8",
     "ffffcca1dab441b6c42c7fb8253494",
     "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
     "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
     "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
     "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
-).map(colors_default);
-var YlGnBu_default = ramp_default(scheme18);
+).map(colors_default2);
+var YlGnBu_default2 = ramp_default2(scheme45);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
-var scheme19 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
+var scheme46 = new Array(3).concat(
     "f7fcb9addd8e31a354",
     "ffffccc2e69978c679238443",
     "ffffccc2e69978c67931a354006837",
     "ffffccd9f0a3addd8e78c67931a354006837",
     "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
     "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
     "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
-).map(colors_default);
-var YlGn_default = ramp_default(scheme19);
+).map(colors_default2);
+var YlGn_default2 = ramp_default2(scheme46);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
-var scheme20 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
+var scheme47 = new Array(3).concat(
     "fff7bcfec44fd95f0e",
     "ffffd4fed98efe9929cc4c02",
     "ffffd4fed98efe9929d95f0e993404",
     "ffffd4fee391fec44ffe9929d95f0e993404",
     "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
     "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
     "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
-).map(colors_default);
-var YlOrBr_default = ramp_default(scheme20);
+).map(colors_default2);
+var YlOrBr_default2 = ramp_default2(scheme47);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
-var scheme21 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
+var scheme48 = new Array(3).concat(
     "ffeda0feb24cf03b20",
     "ffffb2fecc5cfd8d3ce31a1c",
     "ffffb2fecc5cfd8d3cf03b20bd0026",
     "ffffb2fed976feb24cfd8d3cf03b20bd0026",
     "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
     "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
     "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
-).map(colors_default);
-var YlOrRd_default = ramp_default(scheme21);
+).map(colors_default2);
+var YlOrRd_default2 = ramp_default2(scheme48);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
-var scheme22 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
+var scheme49 = new Array(3).concat(
     "deebf79ecae13182bd",
     "eff3ffbdd7e76baed62171b5",
     "eff3ffbdd7e76baed63182bd08519c",
     "eff3ffc6dbef9ecae16baed63182bd08519c",
     "eff3ffc6dbef9ecae16baed64292c62171b5084594",
     "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
     "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
-).map(colors_default);
-var Blues_default = ramp_default(scheme22);
+).map(colors_default2);
+var Blues_default2 = ramp_default2(scheme49);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
-var scheme23 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
+var scheme50 = new Array(3).concat(
     "e5f5e0a1d99b31a354",
     "edf8e9bae4b374c476238b45",
     "edf8e9bae4b374c47631a354006d2c",
     "edf8e9c7e9c0a1d99b74c47631a354006d2c",
     "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
     "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
     "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
-).map(colors_default);
-var Greens_default = ramp_default(scheme23);
+).map(colors_default2);
+var Greens_default2 = ramp_default2(scheme50);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
-var scheme24 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
+var scheme51 = new Array(3).concat(
     "f0f0f0bdbdbd636363",
     "f7f7f7cccccc969696525252",
     "f7f7f7cccccc969696636363252525",
     "f7f7f7d9d9d9bdbdbd969696636363252525",
     "f7f7f7d9d9d9bdbdbd969696737373525252252525",
     "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
     "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
-).map(colors_default);
-var Greys_default = ramp_default(scheme24);
+).map(colors_default2);
+var Greys_default2 = ramp_default2(scheme51);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
-var scheme25 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
+var scheme52 = new Array(3).concat(
     "efedf5bcbddc756bb1",
     "f2f0f7cbc9e29e9ac86a51a3",
     "f2f0f7cbc9e29e9ac8756bb154278f",
     "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
     "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
     "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
     "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
-).map(colors_default);
-var Purples_default = ramp_default(scheme25);
+).map(colors_default2);
+var Purples_default2 = ramp_default2(scheme52);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
-var scheme26 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
+var scheme53 = new Array(3).concat(
     "fee0d2fc9272de2d26",
     "fee5d9fcae91fb6a4acb181d",
     "fee5d9fcae91fb6a4ade2d26a50f15",
     "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
     "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
     "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
     "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
-).map(colors_default);
-var Reds_default = ramp_default(scheme26);
+).map(colors_default2);
+var Reds_default2 = ramp_default2(scheme53);
 
-// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
-var scheme27 = new Array(3).concat(
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
+var scheme54 = new Array(3).concat(
     "fee6cefdae6be6550d",
     "feeddefdbe85fd8d3cd94701",
     "feeddefdbe85fd8d3ce6550da63603",
     "feeddefdd0a2fdae6bfd8d3ce6550da63603",
     "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
     "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
     "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
-).map(colors_default);
-var Oranges_default = ramp_default(scheme27);
+).map(colors_default2);
+var Oranges_default2 = ramp_default2(scheme54);
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
-function cividis_default(t) {
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
+function cividis_default2(t) {
     t = Math.max(0, Math.min(1, t));
     return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
 }
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
-var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
+var cubehelix_default4 = cubehelixLong2(cubehelix3(300, 0.5, 0), cubehelix3(-240, 0.5, 1));
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
-var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
-var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
-var c3 = cubehelix();
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
+var warm2 = cubehelixLong2(cubehelix3(-100, 0.75, 0.35), cubehelix3(80, 1.5, 0.8));
+var cool2 = cubehelixLong2(cubehelix3(260, 0.75, 0.35), cubehelix3(80, 1.5, 0.8));
+var c8 = cubehelix3();
 
-function rainbow_default(t) {
+function rainbow_default2(t) {
     if (t < 0 || t > 1)
         t -= Math.floor(t);
     var ts = Math.abs(t - 0.5);
-    c3.h = 360 * t - 100;
-    c3.s = 1.5 - 1.5 * ts;
-    c3.l = 0.8 - 0.9 * ts;
-    return c3 + "";
+    c8.h = 360 * t - 100;
+    c8.s = 1.5 - 1.5 * ts;
+    c8.l = 0.8 - 0.9 * ts;
+    return c8 + "";
 }
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
-var c4 = rgb();
-var pi_1_3 = Math.PI / 3;
-var pi_2_3 = Math.PI * 2 / 3;
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
+var c9 = rgb2();
+var pi_1_32 = Math.PI / 3;
+var pi_2_32 = Math.PI * 2 / 3;
 
-function sinebow_default(t) {
-    var x4;
+function sinebow_default2(t) {
+    var x7;
     t = (0.5 - t) * Math.PI;
-    c4.r = 255 * (x4 = Math.sin(t)) * x4;
-    c4.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;
-    c4.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;
-    return c4 + "";
+    c9.r = 255 * (x7 = Math.sin(t)) * x7;
+    c9.g = 255 * (x7 = Math.sin(t + pi_1_32)) * x7;
+    c9.b = 255 * (x7 = Math.sin(t + pi_2_32)) * x7;
+    return c9 + "";
 }
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
-function turbo_default(t) {
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
+function turbo_default2(t) {
     t = Math.max(0, Math.min(1, t));
     return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
 }
 
-// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
-function ramp(range5) {
-    var n = range5.length;
+// js/pyobsplot-js/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
+function ramp2(range9) {
+    var n = range9.length;
     return function(t) {
-        return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
+        return range9[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
     };
 }
-var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
-var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
-var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
-var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
+var viridis_default2 = ramp2(colors_default2("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
+var magma2 = ramp2(colors_default2("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
+var inferno2 = ramp2(colors_default2("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
+var plasma2 = ramp2(colors_default2("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
 
-// node_modules/d3-shape/src/constant.js
-function constant_default10(x4) {
-    return function constant3() {
-        return x4;
+// js/pyobsplot-js/node_modules/d3-shape/src/constant.js
+function constant_default21(x7) {
+    return function constant5() {
+        return x7;
     };
 }
 
-// node_modules/d3-shape/src/math.js
-var abs4 = Math.abs;
-var atan22 = Math.atan2;
-var cos3 = Math.cos;
-var max4 = Math.max;
-var min3 = Math.min;
-var sin3 = Math.sin;
-var sqrt3 = Math.sqrt;
-var epsilon8 = 1e-12;
-var pi5 = Math.PI;
-var halfPi4 = pi5 / 2;
-var tau6 = 2 * pi5;
+// js/pyobsplot-js/node_modules/d3-shape/src/math.js
+var abs8 = Math.abs;
+var atan24 = Math.atan2;
+var cos6 = Math.cos;
+var max8 = Math.max;
+var min6 = Math.min;
+var sin6 = Math.sin;
+var sqrt6 = Math.sqrt;
+var epsilon15 = 1e-12;
+var pi11 = Math.PI;
+var halfPi8 = pi11 / 2;
+var tau13 = 2 * pi11;
 
-function acos2(x4) {
-    return x4 > 1 ? 0 : x4 < -1 ? pi5 : Math.acos(x4);
+function acos4(x7) {
+    return x7 > 1 ? 0 : x7 < -1 ? pi11 : Math.acos(x7);
 }
 
-function asin2(x4) {
-    return x4 >= 1 ? halfPi4 : x4 <= -1 ? -halfPi4 : Math.asin(x4);
+function asin4(x7) {
+    return x7 >= 1 ? halfPi8 : x7 <= -1 ? -halfPi8 : Math.asin(x7);
 }
 
-// node_modules/d3-shape/src/path.js
-function withPath(shape) {
+// js/pyobsplot-js/node_modules/d3-shape/src/path.js
+function withPath2(shape) {
     let digits = 3;
     shape.digits = function(_) {
         if (!arguments.length)
             return digits;
         if (_ == null) {
             digits = null;
         } else {
             const d = Math.floor(_);
             if (!(d >= 0))
                 throw new RangeError(`invalid digits: ${_}`);
             digits = d;
         }
         return shape;
     };
-    return () => new Path(digits);
+    return () => new Path3(digits);
 }
 
-// node_modules/d3-shape/src/arc.js
-function arcInnerRadius(d) {
+// js/pyobsplot-js/node_modules/d3-shape/src/arc.js
+function arcInnerRadius2(d) {
     return d.innerRadius;
 }
 
-function arcOuterRadius(d) {
+function arcOuterRadius2(d) {
     return d.outerRadius;
 }
 
-function arcStartAngle(d) {
+function arcStartAngle2(d) {
     return d.startAngle;
 }
 
-function arcEndAngle(d) {
+function arcEndAngle2(d) {
     return d.endAngle;
 }
 
-function arcPadAngle(d) {
+function arcPadAngle2(d) {
     return d && d.padAngle;
 }
 
-function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
-    var x10 = x12 - x06,
-        y10 = y12 - y06,
+function intersect2(x011, y011, x13, y13, x22, y22, x32, y32) {
+    var x10 = x13 - x011,
+        y10 = y13 - y011,
         x322 = x32 - x22,
         y322 = y32 - y22,
         t = y322 * x10 - x322 * y10;
-    if (t * t < epsilon8)
+    if (t * t < epsilon15)
         return;
-    t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
-    return [x06 + t * x10, y06 + t * y10];
+    t = (x322 * (y011 - y22) - y322 * (x011 - x22)) / t;
+    return [x011 + t * x10, y011 + t * y10];
 }
 
-function cornerTangents(x06, y06, x12, y12, r1, rc, cw) {
-    var x01 = x06 - x12,
-        y01 = y06 - y12,
-        lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01),
-        ox2 = lo * y01,
-        oy2 = -lo * x01,
-        x11 = x06 + ox2,
-        y11 = y06 + oy2,
-        x10 = x12 + ox2,
-        y10 = y12 + oy2,
-        x004 = (x11 + x10) / 2,
-        y004 = (y11 + y10) / 2,
+function cornerTangents2(x011, y011, x13, y13, r1, rc, cw) {
+    var x01 = x011 - x13,
+        y01 = y011 - y13,
+        lo = (cw ? rc : -rc) / sqrt6(x01 * x01 + y01 * y01),
+        ox3 = lo * y01,
+        oy3 = -lo * x01,
+        x11 = x011 + ox3,
+        y11 = y011 + oy3,
+        x10 = x13 + ox3,
+        y10 = y13 + oy3,
+        x007 = (x11 + x10) / 2,
+        y007 = (y11 + y10) / 2,
         dx = x10 - x11,
         dy = y10 - y11,
         d2 = dx * dx + dy * dy,
         r = r1 - rc,
-        D3 = x11 * y10 - x10 * y11,
-        d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D3 * D3)),
-        cx0 = (D3 * dy - dx * d) / d2,
-        cy0 = (-D3 * dx - dy * d) / d2,
-        cx1 = (D3 * dy + dx * d) / d2,
-        cy1 = (-D3 * dx + dy * d) / d2,
-        dx0 = cx0 - x004,
-        dy0 = cy0 - y004,
-        dx1 = cx1 - x004,
-        dy1 = cy1 - y004;
+        D5 = x11 * y10 - x10 * y11,
+        d = (dy < 0 ? -1 : 1) * sqrt6(max8(0, r * r * d2 - D5 * D5)),
+        cx0 = (D5 * dy - dx * d) / d2,
+        cy0 = (-D5 * dx - dy * d) / d2,
+        cx1 = (D5 * dy + dx * d) / d2,
+        cy1 = (-D5 * dx + dy * d) / d2,
+        dx0 = cx0 - x007,
+        dy0 = cy0 - y007,
+        dx1 = cx1 - x007,
+        dy1 = cy1 - y007;
     if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
         cx0 = cx1, cy0 = cy1;
     return {
         cx: cx0,
         cy: cy0,
-        x01: -ox2,
-        y01: -oy2,
+        x01: -ox3,
+        y01: -oy3,
         x11: cx0 * (r1 / r - 1),
         y11: cy0 * (r1 / r - 1)
     };
 }
 
-function arc_default() {
-    var innerRadius = arcInnerRadius,
-        outerRadius = arcOuterRadius,
-        cornerRadius = constant_default10(0),
+function arc_default2() {
+    var innerRadius = arcInnerRadius2,
+        outerRadius = arcOuterRadius2,
+        cornerRadius = constant_default21(0),
         padRadius = null,
-        startAngle = arcStartAngle,
-        endAngle = arcEndAngle,
-        padAngle = arcPadAngle,
+        startAngle = arcStartAngle2,
+        endAngle = arcEndAngle2,
+        padAngle = arcPadAngle2,
         context = null,
-        path2 = withPath(arc);
+        path3 = withPath2(arc);
 
     function arc() {
         var buffer, r, r0 = +innerRadius.apply(this, arguments),
             r1 = +outerRadius.apply(this, arguments),
-            a0 = startAngle.apply(this, arguments) - halfPi4,
-            a1 = endAngle.apply(this, arguments) - halfPi4,
-            da2 = abs4(a1 - a0),
+            a0 = startAngle.apply(this, arguments) - halfPi8,
+            a1 = endAngle.apply(this, arguments) - halfPi8,
+            da3 = abs8(a1 - a0),
             cw = a1 > a0;
         if (!context)
-            context = buffer = path2();
+            context = buffer = path3();
         if (r1 < r0)
             r = r1, r1 = r0, r0 = r;
-        if (!(r1 > epsilon8))
+        if (!(r1 > epsilon15))
             context.moveTo(0, 0);
-        else if (da2 > tau6 - epsilon8) {
-            context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
+        else if (da3 > tau13 - epsilon15) {
+            context.moveTo(r1 * cos6(a0), r1 * sin6(a0));
             context.arc(0, 0, r1, a0, a1, !cw);
-            if (r0 > epsilon8) {
-                context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
+            if (r0 > epsilon15) {
+                context.moveTo(r0 * cos6(a1), r0 * sin6(a1));
                 context.arc(0, 0, r0, a1, a0, cw);
             }
         } else {
             var a01 = a0,
                 a11 = a1,
                 a00 = a0,
                 a10 = a1,
-                da0 = da2,
-                da1 = da2,
+                da0 = da3,
+                da1 = da3,
                 ap = padAngle.apply(this, arguments) / 2,
-                rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)),
-                rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
+                rp = ap > epsilon15 && (padRadius ? +padRadius.apply(this, arguments) : sqrt6(r0 * r0 + r1 * r1)),
+                rc = min6(abs8(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
                 rc0 = rc,
                 rc1 = rc,
-                t03, t13;
-            if (rp > epsilon8) {
-                var p02 = asin2(rp / r0 * sin3(ap)),
-                    p1 = asin2(rp / r1 * sin3(ap));
-                if ((da0 -= p02 * 2) > epsilon8)
-                    p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
+                t05, t15;
+            if (rp > epsilon15) {
+                var p03 = asin4(rp / r0 * sin6(ap)),
+                    p1 = asin4(rp / r1 * sin6(ap));
+                if ((da0 -= p03 * 2) > epsilon15)
+                    p03 *= cw ? 1 : -1, a00 += p03, a10 -= p03;
                 else
                     da0 = 0, a00 = a10 = (a0 + a1) / 2;
-                if ((da1 -= p1 * 2) > epsilon8)
+                if ((da1 -= p1 * 2) > epsilon15)
                     p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                 else
                     da1 = 0, a01 = a11 = (a0 + a1) / 2;
             }
-            var x01 = r1 * cos3(a01),
-                y01 = r1 * sin3(a01),
-                x10 = r0 * cos3(a10),
-                y10 = r0 * sin3(a10);
-            if (rc > epsilon8) {
-                var x11 = r1 * cos3(a11),
-                    y11 = r1 * sin3(a11),
-                    x004 = r0 * cos3(a00),
-                    y004 = r0 * sin3(a00),
+            var x01 = r1 * cos6(a01),
+                y01 = r1 * sin6(a01),
+                x10 = r0 * cos6(a10),
+                y10 = r0 * sin6(a10);
+            if (rc > epsilon15) {
+                var x11 = r1 * cos6(a11),
+                    y11 = r1 * sin6(a11),
+                    x007 = r0 * cos6(a00),
+                    y007 = r0 * sin6(a00),
                     oc;
-                if (da2 < pi5) {
-                    if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
+                if (da3 < pi11) {
+                    if (oc = intersect2(x01, y01, x007, y007, x11, y11, x10, y10)) {
                         var ax = x01 - oc[0],
                             ay = y01 - oc[1],
                             bx = x11 - oc[0],
                             by = y11 - oc[1],
-                            kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2),
-                            lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
-                        rc0 = min3(rc, (r0 - lc) / (kc - 1));
-                        rc1 = min3(rc, (r1 - lc) / (kc + 1));
+                            kc = 1 / sin6(acos4((ax * bx + ay * by) / (sqrt6(ax * ax + ay * ay) * sqrt6(bx * bx + by * by))) / 2),
+                            lc = sqrt6(oc[0] * oc[0] + oc[1] * oc[1]);
+                        rc0 = min6(rc, (r0 - lc) / (kc - 1));
+                        rc1 = min6(rc, (r1 - lc) / (kc + 1));
                     } else {
                         rc0 = rc1 = 0;
                     }
                 }
             }
-            if (!(da1 > epsilon8))
+            if (!(da1 > epsilon15))
                 context.moveTo(x01, y01);
-            else if (rc1 > epsilon8) {
-                t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
-                t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
-                context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
+            else if (rc1 > epsilon15) {
+                t05 = cornerTangents2(x007, y007, x01, y01, r1, rc1, cw);
+                t15 = cornerTangents2(x11, y11, x10, y10, r1, rc1, cw);
+                context.moveTo(t05.cx + t05.x01, t05.cy + t05.y01);
                 if (rc1 < rc)
-                    context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
+                    context.arc(t05.cx, t05.cy, rc1, atan24(t05.y01, t05.x01), atan24(t15.y01, t15.x01), !cw);
                 else {
-                    context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
-                    context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
-                    context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
+                    context.arc(t05.cx, t05.cy, rc1, atan24(t05.y01, t05.x01), atan24(t05.y11, t05.x11), !cw);
+                    context.arc(0, 0, r1, atan24(t05.cy + t05.y11, t05.cx + t05.x11), atan24(t15.cy + t15.y11, t15.cx + t15.x11), !cw);
+                    context.arc(t15.cx, t15.cy, rc1, atan24(t15.y11, t15.x11), atan24(t15.y01, t15.x01), !cw);
                 }
             } else
                 context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
-            if (!(r0 > epsilon8) || !(da0 > epsilon8))
+            if (!(r0 > epsilon15) || !(da0 > epsilon15))
                 context.lineTo(x10, y10);
-            else if (rc0 > epsilon8) {
-                t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
-                t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
-                context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
+            else if (rc0 > epsilon15) {
+                t05 = cornerTangents2(x10, y10, x11, y11, r0, -rc0, cw);
+                t15 = cornerTangents2(x01, y01, x007, y007, r0, -rc0, cw);
+                context.lineTo(t05.cx + t05.x01, t05.cy + t05.y01);
                 if (rc0 < rc)
-                    context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
+                    context.arc(t05.cx, t05.cy, rc0, atan24(t05.y01, t05.x01), atan24(t15.y01, t15.x01), !cw);
                 else {
-                    context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
-                    context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);
-                    context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
+                    context.arc(t05.cx, t05.cy, rc0, atan24(t05.y01, t05.x01), atan24(t05.y11, t05.x11), !cw);
+                    context.arc(0, 0, r0, atan24(t05.cy + t05.y11, t05.cx + t05.x11), atan24(t15.cy + t15.y11, t15.cx + t15.x11), cw);
+                    context.arc(t15.cx, t15.cy, rc0, atan24(t15.y11, t15.x11), atan24(t15.y01, t15.x01), !cw);
                 }
             } else
                 context.arc(0, 0, r0, a10, a00, cw);
         }
         context.closePath();
         if (buffer)
             return context = null, buffer + "" || null;
     }
     arc.centroid = function() {
         var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
-            a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;
-        return [cos3(a4) * r, sin3(a4) * r];
+            a7 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi11 / 2;
+        return [cos6(a7) * r, sin6(a7) * r];
     };
     arc.innerRadius = function(_) {
-        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : innerRadius;
+        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default21(+_), arc) : innerRadius;
     };
     arc.outerRadius = function(_) {
-        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : outerRadius;
+        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default21(+_), arc) : outerRadius;
     };
     arc.cornerRadius = function(_) {
-        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : cornerRadius;
+        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default21(+_), arc) : cornerRadius;
     };
     arc.padRadius = function(_) {
-        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), arc) : padRadius;
+        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default21(+_), arc) : padRadius;
     };
     arc.startAngle = function(_) {
-        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : startAngle;
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default21(+_), arc) : startAngle;
     };
     arc.endAngle = function(_) {
-        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : endAngle;
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default21(+_), arc) : endAngle;
     };
     arc.padAngle = function(_) {
-        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : padAngle;
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default21(+_), arc) : padAngle;
     };
     arc.context = function(_) {
         return arguments.length ? (context = _ == null ? null : _, arc) : context;
     };
     return arc;
 }
 
-// node_modules/d3-shape/src/array.js
-var slice4 = Array.prototype.slice;
+// js/pyobsplot-js/node_modules/d3-shape/src/array.js
+var slice10 = Array.prototype.slice;
 
-function array_default3(x4) {
-    return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
+function array_default6(x7) {
+    return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
 }
 
-// node_modules/d3-shape/src/curve/linear.js
-function Linear(context) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/linear.js
+function Linear2(context) {
     this._context = context;
 }
-Linear.prototype = {
+Linear2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
         this._point = 0;
     },
     lineEnd: function() {
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
             default:
-                this._context.lineTo(x4, y4);
+                this._context.lineTo(x7, y7);
                 break;
         }
     }
 };
 
-function linear_default(context) {
-    return new Linear(context);
+function linear_default2(context) {
+    return new Linear2(context);
 }
 
-// node_modules/d3-shape/src/point.js
-function x3(p) {
+// js/pyobsplot-js/node_modules/d3-shape/src/point.js
+function x6(p) {
     return p[0];
 }
 
-function y3(p) {
+function y6(p) {
     return p[1];
 }
 
-// node_modules/d3-shape/src/line.js
-function line_default2(x4, y4) {
-    var defined2 = constant_default10(true),
+// js/pyobsplot-js/node_modules/d3-shape/src/line.js
+function line_default4(x7, y7) {
+    var defined3 = constant_default21(true),
         context = null,
-        curve = linear_default,
+        curve = linear_default2,
         output = null,
-        path2 = withPath(line2);
-    x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x3 : constant_default10(x4);
-    y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);
+        path3 = withPath2(line3);
+    x7 = typeof x7 === "function" ? x7 : x7 === void 0 ? x6 : constant_default21(x7);
+    y7 = typeof y7 === "function" ? y7 : y7 === void 0 ? y6 : constant_default21(y7);
 
-    function line2(data) {
-        var i, n = (data = array_default3(data)).length,
+    function line3(data) {
+        var i, n = (data = array_default6(data)).length,
             d, defined0 = false,
             buffer;
         if (context == null)
-            output = curve(buffer = path2());
+            output = curve(buffer = path3());
         for (i = 0; i <= n; ++i) {
-            if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
+            if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
                 if (defined0 = !defined0)
                     output.lineStart();
                 else
                     output.lineEnd();
             }
             if (defined0)
-                output.point(+x4(d, i, data), +y4(d, i, data));
+                output.point(+x7(d, i, data), +y7(d, i, data));
         }
         if (buffer)
             return output = null, buffer + "" || null;
     }
-    line2.x = function(_) {
-        return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default10(+_), line2) : x4;
+    line3.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default21(+_), line3) : x7;
     };
-    line2.y = function(_) {
-        return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default10(+_), line2) : y4;
+    line3.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default21(+_), line3) : y7;
     };
-    line2.defined = function(_) {
-        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default10(!!_), line2) : defined2;
+    line3.defined = function(_) {
+        return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default21(!!_), line3) : defined3;
     };
-    line2.curve = function(_) {
-        return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
+    line3.curve = function(_) {
+        return arguments.length ? (curve = _, context != null && (output = curve(context)), line3) : curve;
     };
-    line2.context = function(_) {
-        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
+    line3.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line3) : context;
     };
-    return line2;
+    return line3;
 }
 
-// node_modules/d3-shape/src/area.js
-function area_default5(x06, y06, y12) {
-    var x12 = null,
-        defined2 = constant_default10(true),
+// js/pyobsplot-js/node_modules/d3-shape/src/area.js
+function area_default10(x011, y011, y13) {
+    var x13 = null,
+        defined3 = constant_default21(true),
         context = null,
-        curve = linear_default,
+        curve = linear_default2,
         output = null,
-        path2 = withPath(area2);
-    x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);
-    y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);
-    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);
+        path3 = withPath2(area3);
+    x011 = typeof x011 === "function" ? x011 : x011 === void 0 ? x6 : constant_default21(+x011);
+    y011 = typeof y011 === "function" ? y011 : y011 === void 0 ? constant_default21(0) : constant_default21(+y011);
+    y13 = typeof y13 === "function" ? y13 : y13 === void 0 ? y6 : constant_default21(+y13);
 
-    function area2(data) {
-        var i, j, k2, n = (data = array_default3(data)).length,
+    function area3(data) {
+        var i, j, k3, n = (data = array_default6(data)).length,
             d, defined0 = false,
             buffer, x0z = new Array(n),
             y0z = new Array(n);
         if (context == null)
-            output = curve(buffer = path2());
+            output = curve(buffer = path3());
         for (i = 0; i <= n; ++i) {
-            if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
+            if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
                 if (defined0 = !defined0) {
                     j = i;
                     output.areaStart();
                     output.lineStart();
                 } else {
                     output.lineEnd();
                     output.lineStart();
-                    for (k2 = i - 1; k2 >= j; --k2) {
-                        output.point(x0z[k2], y0z[k2]);
+                    for (k3 = i - 1; k3 >= j; --k3) {
+                        output.point(x0z[k3], y0z[k3]);
                     }
                     output.lineEnd();
                     output.areaEnd();
                 }
             }
             if (defined0) {
-                x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);
-                output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
+                x0z[i] = +x011(d, i, data), y0z[i] = +y011(d, i, data);
+                output.point(x13 ? +x13(d, i, data) : x0z[i], y13 ? +y13(d, i, data) : y0z[i]);
             }
         }
         if (buffer)
             return output = null, buffer + "" || null;
     }
 
     function arealine() {
-        return line_default2().defined(defined2).curve(curve).context(context);
+        return line_default4().defined(defined3).curve(curve).context(context);
     }
-    area2.x = function(_) {
-        return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default10(+_), x12 = null, area2) : x06;
+    area3.x = function(_) {
+        return arguments.length ? (x011 = typeof _ === "function" ? _ : constant_default21(+_), x13 = null, area3) : x011;
     };
-    area2.x0 = function(_) {
-        return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default10(+_), area2) : x06;
+    area3.x0 = function(_) {
+        return arguments.length ? (x011 = typeof _ === "function" ? _ : constant_default21(+_), area3) : x011;
     };
-    area2.x1 = function(_) {
-        return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area2) : x12;
+    area3.x1 = function(_) {
+        return arguments.length ? (x13 = _ == null ? null : typeof _ === "function" ? _ : constant_default21(+_), area3) : x13;
     };
-    area2.y = function(_) {
-        return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default10(+_), y12 = null, area2) : y06;
+    area3.y = function(_) {
+        return arguments.length ? (y011 = typeof _ === "function" ? _ : constant_default21(+_), y13 = null, area3) : y011;
     };
-    area2.y0 = function(_) {
-        return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default10(+_), area2) : y06;
+    area3.y0 = function(_) {
+        return arguments.length ? (y011 = typeof _ === "function" ? _ : constant_default21(+_), area3) : y011;
     };
-    area2.y1 = function(_) {
-        return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area2) : y12;
+    area3.y1 = function(_) {
+        return arguments.length ? (y13 = _ == null ? null : typeof _ === "function" ? _ : constant_default21(+_), area3) : y13;
     };
-    area2.lineX0 = area2.lineY0 = function() {
-        return arealine().x(x06).y(y06);
+    area3.lineX0 = area3.lineY0 = function() {
+        return arealine().x(x011).y(y011);
     };
-    area2.lineY1 = function() {
-        return arealine().x(x06).y(y12);
+    area3.lineY1 = function() {
+        return arealine().x(x011).y(y13);
     };
-    area2.lineX1 = function() {
-        return arealine().x(x12).y(y06);
+    area3.lineX1 = function() {
+        return arealine().x(x13).y(y011);
     };
-    area2.defined = function(_) {
-        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default10(!!_), area2) : defined2;
+    area3.defined = function(_) {
+        return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default21(!!_), area3) : defined3;
     };
-    area2.curve = function(_) {
-        return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
+    area3.curve = function(_) {
+        return arguments.length ? (curve = _, context != null && (output = curve(context)), area3) : curve;
     };
-    area2.context = function(_) {
-        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
+    area3.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area3) : context;
     };
-    return area2;
+    return area3;
 }
 
-// node_modules/d3-shape/src/descending.js
-function descending_default(a4, b) {
-    return b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
+// js/pyobsplot-js/node_modules/d3-shape/src/descending.js
+function descending_default3(a7, b) {
+    return b < a7 ? -1 : b > a7 ? 1 : b >= a7 ? 0 : NaN;
 }
 
-// node_modules/d3-shape/src/identity.js
-function identity_default5(d) {
+// js/pyobsplot-js/node_modules/d3-shape/src/identity.js
+function identity_default10(d) {
     return d;
 }
 
-// node_modules/d3-shape/src/pie.js
-function pie_default() {
-    var value = identity_default5,
-        sortValues = descending_default,
-        sort3 = null,
-        startAngle = constant_default10(0),
-        endAngle = constant_default10(tau6),
-        padAngle = constant_default10(0);
+// js/pyobsplot-js/node_modules/d3-shape/src/pie.js
+function pie_default2() {
+    var value = identity_default10,
+        sortValues = descending_default3,
+        sort5 = null,
+        startAngle = constant_default21(0),
+        endAngle = constant_default21(tau13),
+        padAngle = constant_default21(0);
 
     function pie(data) {
-        var i, n = (data = array_default3(data)).length,
-            j, k2, sum5 = 0,
-            index3 = new Array(n),
+        var i, n = (data = array_default6(data)).length,
+            j, k3, sum8 = 0,
+            index5 = new Array(n),
             arcs = new Array(n),
             a0 = +startAngle.apply(this, arguments),
-            da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)),
-            a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)),
-            pa = p * (da2 < 0 ? -1 : 1),
-            v2;
+            da3 = Math.min(tau13, Math.max(-tau13, endAngle.apply(this, arguments) - a0)),
+            a1, p = Math.min(Math.abs(da3) / n, padAngle.apply(this, arguments)),
+            pa = p * (da3 < 0 ? -1 : 1),
+            v3;
         for (i = 0; i < n; ++i) {
-            if ((v2 = arcs[index3[i] = i] = +value(data[i], i, data)) > 0) {
-                sum5 += v2;
+            if ((v3 = arcs[index5[i] = i] = +value(data[i], i, data)) > 0) {
+                sum8 += v3;
             }
         }
         if (sortValues != null)
-            index3.sort(function(i2, j2) {
+            index5.sort(function(i2, j2) {
                 return sortValues(arcs[i2], arcs[j2]);
             });
-        else if (sort3 != null)
-            index3.sort(function(i2, j2) {
-                return sort3(data[i2], data[j2]);
+        else if (sort5 != null)
+            index5.sort(function(i2, j2) {
+                return sort5(data[i2], data[j2]);
             });
-        for (i = 0, k2 = sum5 ? (da2 - n * pa) / sum5 : 0; i < n; ++i, a0 = a1) {
-            j = index3[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {
+        for (i = 0, k3 = sum8 ? (da3 - n * pa) / sum8 : 0; i < n; ++i, a0 = a1) {
+            j = index5[i], v3 = arcs[j], a1 = a0 + (v3 > 0 ? v3 * k3 : 0) + pa, arcs[j] = {
                 data: data[j],
                 index: i,
-                value: v2,
+                value: v3,
                 startAngle: a0,
                 endAngle: a1,
                 padAngle: p
             };
         }
         return arcs;
     }
     pie.value = function(_) {
-        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), pie) : value;
+        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default21(+_), pie) : value;
     };
     pie.sortValues = function(_) {
-        return arguments.length ? (sortValues = _, sort3 = null, pie) : sortValues;
+        return arguments.length ? (sortValues = _, sort5 = null, pie) : sortValues;
     };
     pie.sort = function(_) {
-        return arguments.length ? (sort3 = _, sortValues = null, pie) : sort3;
+        return arguments.length ? (sort5 = _, sortValues = null, pie) : sort5;
     };
     pie.startAngle = function(_) {
-        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : startAngle;
+        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default21(+_), pie) : startAngle;
     };
     pie.endAngle = function(_) {
-        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : endAngle;
+        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default21(+_), pie) : endAngle;
     };
     pie.padAngle = function(_) {
-        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : padAngle;
+        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default21(+_), pie) : padAngle;
     };
     return pie;
 }
 
-// node_modules/d3-shape/src/curve/radial.js
-var curveRadialLinear = curveRadial(linear_default);
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/radial.js
+var curveRadialLinear2 = curveRadial2(linear_default2);
 
-function Radial(curve) {
+function Radial2(curve) {
     this._curve = curve;
 }
-Radial.prototype = {
+Radial2.prototype = {
     areaStart: function() {
         this._curve.areaStart();
     },
     areaEnd: function() {
         this._curve.areaEnd();
     },
     lineStart: function() {
         this._curve.lineStart();
     },
     lineEnd: function() {
         this._curve.lineEnd();
     },
-    point: function(a4, r) {
-        this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
+    point: function(a7, r) {
+        this._curve.point(r * Math.sin(a7), r * -Math.cos(a7));
     }
 };
 
-function curveRadial(curve) {
-    function radial2(context) {
-        return new Radial(curve(context));
+function curveRadial2(curve) {
+    function radial3(context) {
+        return new Radial2(curve(context));
     }
-    radial2._curve = curve;
-    return radial2;
+    radial3._curve = curve;
+    return radial3;
 }
 
-// node_modules/d3-shape/src/lineRadial.js
-function lineRadial(l) {
-    var c6 = l.curve;
+// js/pyobsplot-js/node_modules/d3-shape/src/lineRadial.js
+function lineRadial2(l) {
+    var c11 = l.curve;
     l.angle = l.x, delete l.x;
     l.radius = l.y, delete l.y;
     l.curve = function(_) {
-        return arguments.length ? c6(curveRadial(_)) : c6()._curve;
+        return arguments.length ? c11(curveRadial2(_)) : c11()._curve;
     };
     return l;
 }
 
-function lineRadial_default() {
-    return lineRadial(line_default2().curve(curveRadialLinear));
-}
-
-// node_modules/d3-shape/src/areaRadial.js
-function areaRadial_default() {
-    var a4 = area_default5().curve(curveRadialLinear),
-        c6 = a4.curve,
-        x06 = a4.lineX0,
-        x12 = a4.lineX1,
-        y06 = a4.lineY0,
-        y12 = a4.lineY1;
-    a4.angle = a4.x, delete a4.x;
-    a4.startAngle = a4.x0, delete a4.x0;
-    a4.endAngle = a4.x1, delete a4.x1;
-    a4.radius = a4.y, delete a4.y;
-    a4.innerRadius = a4.y0, delete a4.y0;
-    a4.outerRadius = a4.y1, delete a4.y1;
-    a4.lineStartAngle = function() {
-        return lineRadial(x06());
-    }, delete a4.lineX0;
-    a4.lineEndAngle = function() {
-        return lineRadial(x12());
-    }, delete a4.lineX1;
-    a4.lineInnerRadius = function() {
-        return lineRadial(y06());
-    }, delete a4.lineY0;
-    a4.lineOuterRadius = function() {
-        return lineRadial(y12());
-    }, delete a4.lineY1;
-    a4.curve = function(_) {
-        return arguments.length ? c6(curveRadial(_)) : c6()._curve;
-    };
-    return a4;
-}
-
-// node_modules/d3-shape/src/pointRadial.js
-function pointRadial_default(x4, y4) {
-    return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];
+function lineRadial_default2() {
+    return lineRadial2(line_default4().curve(curveRadialLinear2));
 }
 
-// node_modules/d3-shape/src/curve/bump.js
-var Bump = class {
-    constructor(context, x4) {
+// js/pyobsplot-js/node_modules/d3-shape/src/areaRadial.js
+function areaRadial_default2() {
+    var a7 = area_default10().curve(curveRadialLinear2),
+        c11 = a7.curve,
+        x011 = a7.lineX0,
+        x13 = a7.lineX1,
+        y011 = a7.lineY0,
+        y13 = a7.lineY1;
+    a7.angle = a7.x, delete a7.x;
+    a7.startAngle = a7.x0, delete a7.x0;
+    a7.endAngle = a7.x1, delete a7.x1;
+    a7.radius = a7.y, delete a7.y;
+    a7.innerRadius = a7.y0, delete a7.y0;
+    a7.outerRadius = a7.y1, delete a7.y1;
+    a7.lineStartAngle = function() {
+        return lineRadial2(x011());
+    }, delete a7.lineX0;
+    a7.lineEndAngle = function() {
+        return lineRadial2(x13());
+    }, delete a7.lineX1;
+    a7.lineInnerRadius = function() {
+        return lineRadial2(y011());
+    }, delete a7.lineY0;
+    a7.lineOuterRadius = function() {
+        return lineRadial2(y13());
+    }, delete a7.lineY1;
+    a7.curve = function(_) {
+        return arguments.length ? c11(curveRadial2(_)) : c11()._curve;
+    };
+    return a7;
+}
+
+// js/pyobsplot-js/node_modules/d3-shape/src/pointRadial.js
+function pointRadial_default2(x7, y7) {
+    return [(y7 = +y7) * Math.cos(x7 -= Math.PI / 2), y7 * Math.sin(x7)];
+}
+
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/bump.js
+var Bump2 = class {
+    constructor(context, x7) {
         this._context = context;
-        this._x = x4;
+        this._x = x7;
     }
     areaStart() {
         this._line = 0;
     }
     areaEnd() {
         this._line = NaN;
     }
@@ -19529,168 +54235,168 @@
         this._point = 0;
     }
     lineEnd() {
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     }
-    point(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0: {
                 this._point = 1;
                 if (this._line)
-                    this._context.lineTo(x4, y4);
+                    this._context.lineTo(x7, y7);
                 else
-                    this._context.moveTo(x4, y4);
+                    this._context.moveTo(x7, y7);
                 break;
             }
             case 1:
                 this._point = 2;
             default: {
                 if (this._x)
-                    this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);
+                    this._context.bezierCurveTo(this._x0 = (this._x0 + x7) / 2, this._y0, this._x0, y7, x7, y7);
                 else
-                    this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);
+                    this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y7) / 2, x7, this._y0, x7, y7);
                 break;
             }
         }
-        this._x0 = x4, this._y0 = y4;
+        this._x0 = x7, this._y0 = y7;
     }
 };
-var BumpRadial = class {
+var BumpRadial2 = class {
     constructor(context) {
         this._context = context;
     }
     lineStart() {
         this._point = 0;
     }
     lineEnd() {}
-    point(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point(x7, y7) {
+        x7 = +x7, y7 = +y7;
         if (this._point === 0) {
             this._point = 1;
         } else {
-            const p02 = pointRadial_default(this._x0, this._y0);
-            const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y4) / 2);
-            const p2 = pointRadial_default(x4, this._y0);
-            const p3 = pointRadial_default(x4, y4);
-            this._context.moveTo(...p02);
+            const p03 = pointRadial_default2(this._x0, this._y0);
+            const p1 = pointRadial_default2(this._x0, this._y0 = (this._y0 + y7) / 2);
+            const p2 = pointRadial_default2(x7, this._y0);
+            const p3 = pointRadial_default2(x7, y7);
+            this._context.moveTo(...p03);
             this._context.bezierCurveTo(...p1, ...p2, ...p3);
         }
-        this._x0 = x4, this._y0 = y4;
+        this._x0 = x7, this._y0 = y7;
     }
 };
 
-function bumpX(context) {
-    return new Bump(context, true);
+function bumpX2(context) {
+    return new Bump2(context, true);
 }
 
-function bumpY(context) {
-    return new Bump(context, false);
+function bumpY2(context) {
+    return new Bump2(context, false);
 }
 
-function bumpRadial(context) {
-    return new BumpRadial(context);
+function bumpRadial2(context) {
+    return new BumpRadial2(context);
 }
 
-// node_modules/d3-shape/src/link.js
-function linkSource(d) {
+// js/pyobsplot-js/node_modules/d3-shape/src/link.js
+function linkSource2(d) {
     return d.source;
 }
 
-function linkTarget(d) {
+function linkTarget2(d) {
     return d.target;
 }
 
-function link2(curve) {
-    let source = linkSource,
-        target = linkTarget,
-        x4 = x3,
-        y4 = y3,
+function link5(curve) {
+    let source = linkSource2,
+        target = linkTarget2,
+        x7 = x6,
+        y7 = y6,
         context = null,
         output = null,
-        path2 = withPath(link4);
+        path3 = withPath2(link7);
 
-    function link4() {
+    function link7() {
         let buffer;
-        const argv = slice4.call(arguments);
-        const s2 = source.apply(this, argv);
+        const argv = slice10.call(arguments);
+        const s3 = source.apply(this, argv);
         const t = target.apply(this, argv);
         if (context == null)
-            output = curve(buffer = path2());
+            output = curve(buffer = path3());
         output.lineStart();
-        argv[0] = s2, output.point(+x4.apply(this, argv), +y4.apply(this, argv));
-        argv[0] = t, output.point(+x4.apply(this, argv), +y4.apply(this, argv));
+        argv[0] = s3, output.point(+x7.apply(this, argv), +y7.apply(this, argv));
+        argv[0] = t, output.point(+x7.apply(this, argv), +y7.apply(this, argv));
         output.lineEnd();
         if (buffer)
             return output = null, buffer + "" || null;
     }
-    link4.source = function(_) {
-        return arguments.length ? (source = _, link4) : source;
+    link7.source = function(_) {
+        return arguments.length ? (source = _, link7) : source;
     };
-    link4.target = function(_) {
-        return arguments.length ? (target = _, link4) : target;
+    link7.target = function(_) {
+        return arguments.length ? (target = _, link7) : target;
     };
-    link4.x = function(_) {
-        return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default10(+_), link4) : x4;
+    link7.x = function(_) {
+        return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default21(+_), link7) : x7;
     };
-    link4.y = function(_) {
-        return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default10(+_), link4) : y4;
+    link7.y = function(_) {
+        return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default21(+_), link7) : y7;
     };
-    link4.context = function(_) {
-        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link4) : context;
+    link7.context = function(_) {
+        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link7) : context;
     };
-    return link4;
+    return link7;
 }
 
-function linkHorizontal() {
-    return link2(bumpX);
+function linkHorizontal2() {
+    return link5(bumpX2);
 }
 
-function linkVertical() {
-    return link2(bumpY);
+function linkVertical2() {
+    return link5(bumpY2);
 }
 
-function linkRadial() {
-    const l = link2(bumpRadial);
+function linkRadial2() {
+    const l = link5(bumpRadial2);
     l.angle = l.x, delete l.x;
     l.radius = l.y, delete l.y;
     return l;
 }
 
-// node_modules/d3-shape/src/symbol/asterisk.js
-var sqrt32 = sqrt3(3);
-var asterisk_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/asterisk.js
+var sqrt36 = sqrt6(3);
+var asterisk_default2 = {
     draw(context, size) {
-        const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
+        const r = sqrt6(size + min6(size / 28, 0.75)) * 0.59436;
         const t = r / 2;
-        const u4 = t * sqrt32;
+        const u7 = t * sqrt36;
         context.moveTo(0, r);
         context.lineTo(0, -r);
-        context.moveTo(-u4, -t);
-        context.lineTo(u4, t);
-        context.moveTo(-u4, t);
-        context.lineTo(u4, -t);
+        context.moveTo(-u7, -t);
+        context.lineTo(u7, t);
+        context.moveTo(-u7, t);
+        context.lineTo(u7, -t);
     }
 };
 
-// node_modules/d3-shape/src/symbol/circle.js
-var circle_default3 = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/circle.js
+var circle_default6 = {
     draw(context, size) {
-        const r = sqrt3(size / pi5);
+        const r = sqrt6(size / pi11);
         context.moveTo(r, 0);
-        context.arc(0, 0, r, 0, tau6);
+        context.arc(0, 0, r, 0, tau13);
     }
 };
 
-// node_modules/d3-shape/src/symbol/cross.js
-var cross_default2 = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/cross.js
+var cross_default4 = {
     draw(context, size) {
-        const r = sqrt3(size / 5) / 2;
+        const r = sqrt6(size / 5) / 2;
         context.moveTo(-3 * r, -r);
         context.lineTo(-r, -r);
         context.lineTo(-r, -3 * r);
         context.lineTo(r, -3 * r);
         context.lineTo(r, -r);
         context.lineTo(3 * r, -r);
         context.lineTo(3 * r, r);
@@ -19699,280 +54405,280 @@
         context.lineTo(-r, 3 * r);
         context.lineTo(-r, r);
         context.lineTo(-3 * r, r);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/diamond.js
-var tan30 = sqrt3(1 / 3);
-var tan30_2 = tan30 * 2;
-var diamond_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/diamond.js
+var tan302 = sqrt6(1 / 3);
+var tan30_22 = tan302 * 2;
+var diamond_default2 = {
     draw(context, size) {
-        const y4 = sqrt3(size / tan30_2);
-        const x4 = y4 * tan30;
-        context.moveTo(0, -y4);
-        context.lineTo(x4, 0);
-        context.lineTo(0, y4);
-        context.lineTo(-x4, 0);
+        const y7 = sqrt6(size / tan30_22);
+        const x7 = y7 * tan302;
+        context.moveTo(0, -y7);
+        context.lineTo(x7, 0);
+        context.lineTo(0, y7);
+        context.lineTo(-x7, 0);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/diamond2.js
-var diamond2_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/diamond2.js
+var diamond2_default2 = {
     draw(context, size) {
-        const r = sqrt3(size) * 0.62625;
+        const r = sqrt6(size) * 0.62625;
         context.moveTo(0, -r);
         context.lineTo(r, 0);
         context.lineTo(0, r);
         context.lineTo(-r, 0);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/plus.js
-var plus_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/plus.js
+var plus_default2 = {
     draw(context, size) {
-        const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;
+        const r = sqrt6(size - min6(size / 7, 2)) * 0.87559;
         context.moveTo(-r, 0);
         context.lineTo(r, 0);
         context.moveTo(0, r);
         context.lineTo(0, -r);
     }
 };
 
-// node_modules/d3-shape/src/symbol/square.js
-var square_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/square.js
+var square_default2 = {
     draw(context, size) {
-        const w = sqrt3(size);
-        const x4 = -w / 2;
-        context.rect(x4, x4, w, w);
+        const w = sqrt6(size);
+        const x7 = -w / 2;
+        context.rect(x7, x7, w, w);
     }
 };
 
-// node_modules/d3-shape/src/symbol/square2.js
-var square2_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/square2.js
+var square2_default2 = {
     draw(context, size) {
-        const r = sqrt3(size) * 0.4431;
+        const r = sqrt6(size) * 0.4431;
         context.moveTo(r, r);
         context.lineTo(r, -r);
         context.lineTo(-r, -r);
         context.lineTo(-r, r);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/star.js
-var ka = 0.8908130915292852;
-var kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);
-var kx = sin3(tau6 / 10) * kr;
-var ky = -cos3(tau6 / 10) * kr;
-var star_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/star.js
+var ka2 = 0.8908130915292852;
+var kr2 = sin6(pi11 / 10) / sin6(7 * pi11 / 10);
+var kx2 = sin6(tau13 / 10) * kr2;
+var ky2 = -cos6(tau13 / 10) * kr2;
+var star_default2 = {
     draw(context, size) {
-        const r = sqrt3(size * ka);
-        const x4 = kx * r;
-        const y4 = ky * r;
+        const r = sqrt6(size * ka2);
+        const x7 = kx2 * r;
+        const y7 = ky2 * r;
         context.moveTo(0, -r);
-        context.lineTo(x4, y4);
+        context.lineTo(x7, y7);
         for (let i = 1; i < 5; ++i) {
-            const a4 = tau6 * i / 5;
-            const c6 = cos3(a4);
-            const s2 = sin3(a4);
-            context.lineTo(s2 * r, -c6 * r);
-            context.lineTo(c6 * x4 - s2 * y4, s2 * x4 + c6 * y4);
+            const a7 = tau13 * i / 5;
+            const c11 = cos6(a7);
+            const s3 = sin6(a7);
+            context.lineTo(s3 * r, -c11 * r);
+            context.lineTo(c11 * x7 - s3 * y7, s3 * x7 + c11 * y7);
         }
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/triangle.js
-var sqrt33 = sqrt3(3);
-var triangle_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/triangle.js
+var sqrt37 = sqrt6(3);
+var triangle_default2 = {
     draw(context, size) {
-        const y4 = -sqrt3(size / (sqrt33 * 3));
-        context.moveTo(0, y4 * 2);
-        context.lineTo(-sqrt33 * y4, -y4);
-        context.lineTo(sqrt33 * y4, -y4);
+        const y7 = -sqrt6(size / (sqrt37 * 3));
+        context.moveTo(0, y7 * 2);
+        context.lineTo(-sqrt37 * y7, -y7);
+        context.lineTo(sqrt37 * y7, -y7);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/triangle2.js
-var sqrt34 = sqrt3(3);
-var triangle2_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/triangle2.js
+var sqrt38 = sqrt6(3);
+var triangle2_default2 = {
     draw(context, size) {
-        const s2 = sqrt3(size) * 0.6824;
-        const t = s2 / 2;
-        const u4 = s2 * sqrt34 / 2;
-        context.moveTo(0, -s2);
-        context.lineTo(u4, t);
-        context.lineTo(-u4, t);
+        const s3 = sqrt6(size) * 0.6824;
+        const t = s3 / 2;
+        const u7 = s3 * sqrt38 / 2;
+        context.moveTo(0, -s3);
+        context.lineTo(u7, t);
+        context.lineTo(-u7, t);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/wye.js
-var c5 = -0.5;
-var s = sqrt3(3) / 2;
-var k = 1 / sqrt3(12);
-var a3 = (k / 2 + 1) * 3;
-var wye_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/wye.js
+var c10 = -0.5;
+var s2 = sqrt6(3) / 2;
+var k2 = 1 / sqrt6(12);
+var a6 = (k2 / 2 + 1) * 3;
+var wye_default2 = {
     draw(context, size) {
-        const r = sqrt3(size / a3);
-        const x06 = r / 2,
-            y06 = r * k;
-        const x12 = x06,
-            y12 = r * k + r;
-        const x22 = -x12,
-            y22 = y12;
-        context.moveTo(x06, y06);
-        context.lineTo(x12, y12);
+        const r = sqrt6(size / a6);
+        const x011 = r / 2,
+            y011 = r * k2;
+        const x13 = x011,
+            y13 = r * k2 + r;
+        const x22 = -x13,
+            y22 = y13;
+        context.moveTo(x011, y011);
+        context.lineTo(x13, y13);
         context.lineTo(x22, y22);
-        context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);
-        context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);
-        context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);
-        context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);
-        context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);
-        context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);
+        context.lineTo(c10 * x011 - s2 * y011, s2 * x011 + c10 * y011);
+        context.lineTo(c10 * x13 - s2 * y13, s2 * x13 + c10 * y13);
+        context.lineTo(c10 * x22 - s2 * y22, s2 * x22 + c10 * y22);
+        context.lineTo(c10 * x011 + s2 * y011, c10 * y011 - s2 * x011);
+        context.lineTo(c10 * x13 + s2 * y13, c10 * y13 - s2 * x13);
+        context.lineTo(c10 * x22 + s2 * y22, c10 * y22 - s2 * x22);
         context.closePath();
     }
 };
 
-// node_modules/d3-shape/src/symbol/times.js
-var times_default = {
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol/times.js
+var times_default2 = {
     draw(context, size) {
-        const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
+        const r = sqrt6(size - min6(size / 6, 1.7)) * 0.6189;
         context.moveTo(-r, -r);
         context.lineTo(r, r);
         context.moveTo(-r, r);
         context.lineTo(r, -r);
     }
 };
 
-// node_modules/d3-shape/src/symbol.js
-var symbolsFill = [
-    circle_default3,
-    cross_default2,
-    diamond_default,
-    square_default,
-    star_default,
-    triangle_default,
-    wye_default
+// js/pyobsplot-js/node_modules/d3-shape/src/symbol.js
+var symbolsFill2 = [
+    circle_default6,
+    cross_default4,
+    diamond_default2,
+    square_default2,
+    star_default2,
+    triangle_default2,
+    wye_default2
 ];
-var symbolsStroke = [
-    circle_default3,
-    plus_default,
-    times_default,
-    triangle2_default,
-    asterisk_default,
-    square2_default,
-    diamond2_default
+var symbolsStroke2 = [
+    circle_default6,
+    plus_default2,
+    times_default2,
+    triangle2_default2,
+    asterisk_default2,
+    square2_default2,
+    diamond2_default2
 ];
 
-function Symbol2(type2, size) {
+function Symbol3(type3, size) {
     let context = null,
-        path2 = withPath(symbol2);
-    type2 = typeof type2 === "function" ? type2 : constant_default10(type2 || circle_default3);
-    size = typeof size === "function" ? size : constant_default10(size === void 0 ? 64 : +size);
+        path3 = withPath2(symbol3);
+    type3 = typeof type3 === "function" ? type3 : constant_default21(type3 || circle_default6);
+    size = typeof size === "function" ? size : constant_default21(size === void 0 ? 64 : +size);
 
-    function symbol2() {
+    function symbol3() {
         let buffer;
         if (!context)
-            context = buffer = path2();
-        type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
+            context = buffer = path3();
+        type3.apply(this, arguments).draw(context, +size.apply(this, arguments));
         if (buffer)
             return context = null, buffer + "" || null;
     }
-    symbol2.type = function(_) {
-        return arguments.length ? (type2 = typeof _ === "function" ? _ : constant_default10(_), symbol2) : type2;
+    symbol3.type = function(_) {
+        return arguments.length ? (type3 = typeof _ === "function" ? _ : constant_default21(_), symbol3) : type3;
     };
-    symbol2.size = function(_) {
-        return arguments.length ? (size = typeof _ === "function" ? _ : constant_default10(+_), symbol2) : size;
+    symbol3.size = function(_) {
+        return arguments.length ? (size = typeof _ === "function" ? _ : constant_default21(+_), symbol3) : size;
     };
-    symbol2.context = function(_) {
-        return arguments.length ? (context = _ == null ? null : _, symbol2) : context;
+    symbol3.context = function(_) {
+        return arguments.length ? (context = _ == null ? null : _, symbol3) : context;
     };
-    return symbol2;
+    return symbol3;
 }
 
-// node_modules/d3-shape/src/noop.js
-function noop_default2() {}
+// js/pyobsplot-js/node_modules/d3-shape/src/noop.js
+function noop_default4() {}
 
-// node_modules/d3-shape/src/curve/basis.js
-function point2(that, x4, y4) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/basis.js
+function point7(that, x7, y7) {
     that._context.bezierCurveTo(
         (2 * that._x0 + that._x1) / 3,
         (2 * that._y0 + that._y1) / 3,
         (that._x0 + 2 * that._x1) / 3,
         (that._y0 + 2 * that._y1) / 3,
-        (that._x0 + 4 * that._x1 + x4) / 6,
-        (that._y0 + 4 * that._y1 + y4) / 6
+        (that._x0 + 4 * that._x1 + x7) / 6,
+        (that._y0 + 4 * that._y1 + y7) / 6
     );
 }
 
-function Basis(context) {
+function Basis2(context) {
     this._context = context;
 }
-Basis.prototype = {
+Basis2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
         this._x0 = this._x1 = this._y0 = this._y1 = NaN;
         this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 3:
-                point2(this, this._x1, this._y1);
+                point7(this, this._x1, this._y1);
             case 2:
                 this._context.lineTo(this._x1, this._y1);
                 break;
         }
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
                 this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
             default:
-                point2(this, x4, y4);
+                point7(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = x4;
-        this._y0 = this._y1, this._y1 = y4;
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
     }
 };
 
-function basis_default2(context) {
-    return new Basis(context);
+function basis_default4(context) {
+    return new Basis2(context);
 }
 
-// node_modules/d3-shape/src/curve/basisClosed.js
-function BasisClosed(context) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/basisClosed.js
+function BasisClosed2(context) {
     this._context = context;
 }
-BasisClosed.prototype = {
-    areaStart: noop_default2,
-    areaEnd: noop_default2,
+BasisClosed2.prototype = {
+    areaStart: noop_default4,
+    areaEnd: noop_default4,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
         this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
@@ -19990,48 +54696,48 @@
                 this.point(this._x2, this._y2);
                 this.point(this._x3, this._y3);
                 this.point(this._x4, this._y4);
                 break;
             }
         }
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._x2 = x4, this._y2 = y4;
+                this._x2 = x7, this._y2 = y7;
                 break;
             case 1:
                 this._point = 2;
-                this._x3 = x4, this._y3 = y4;
+                this._x3 = x7, this._y3 = y7;
                 break;
             case 2:
                 this._point = 3;
-                this._x4 = x4, this._y4 = y4;
-                this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
+                this._x4 = x7, this._y4 = y7;
+                this._context.moveTo((this._x0 + 4 * this._x1 + x7) / 6, (this._y0 + 4 * this._y1 + y7) / 6);
                 break;
             default:
-                point2(this, x4, y4);
+                point7(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = x4;
-        this._y0 = this._y1, this._y1 = y4;
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
     }
 };
 
-function basisClosed_default2(context) {
-    return new BasisClosed(context);
+function basisClosed_default4(context) {
+    return new BasisClosed2(context);
 }
 
-// node_modules/d3-shape/src/curve/basisOpen.js
-function BasisOpen(context) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/basisOpen.js
+function BasisOpen2(context) {
     this._context = context;
 }
-BasisOpen.prototype = {
+BasisOpen2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20039,109 +54745,109 @@
         this._point = 0;
     },
     lineEnd: function() {
         if (this._line || this._line !== 0 && this._point === 3)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
-                var x06 = (this._x0 + 4 * this._x1 + x4) / 6,
-                    y06 = (this._y0 + 4 * this._y1 + y4) / 6;
-                this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
+                var x011 = (this._x0 + 4 * this._x1 + x7) / 6,
+                    y011 = (this._y0 + 4 * this._y1 + y7) / 6;
+                this._line ? this._context.lineTo(x011, y011) : this._context.moveTo(x011, y011);
                 break;
             case 3:
                 this._point = 4;
             default:
-                point2(this, x4, y4);
+                point7(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = x4;
-        this._y0 = this._y1, this._y1 = y4;
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
     }
 };
 
-function basisOpen_default(context) {
-    return new BasisOpen(context);
+function basisOpen_default2(context) {
+    return new BasisOpen2(context);
 }
 
-// node_modules/d3-shape/src/curve/bundle.js
-function Bundle(context, beta) {
-    this._basis = new Basis(context);
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/bundle.js
+function Bundle2(context, beta) {
+    this._basis = new Basis2(context);
     this._beta = beta;
 }
-Bundle.prototype = {
+Bundle2.prototype = {
     lineStart: function() {
         this._x = [];
         this._y = [];
         this._basis.lineStart();
     },
     lineEnd: function() {
-        var x4 = this._x,
-            y4 = this._y,
-            j = x4.length - 1;
+        var x7 = this._x,
+            y7 = this._y,
+            j = x7.length - 1;
         if (j > 0) {
-            var x06 = x4[0],
-                y06 = y4[0],
-                dx = x4[j] - x06,
-                dy = y4[j] - y06,
+            var x011 = x7[0],
+                y011 = y7[0],
+                dx = x7[j] - x011,
+                dy = y7[j] - y011,
                 i = -1,
                 t;
             while (++i <= j) {
                 t = i / j;
                 this._basis.point(
-                    this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),
-                    this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)
+                    this._beta * x7[i] + (1 - this._beta) * (x011 + t * dx),
+                    this._beta * y7[i] + (1 - this._beta) * (y011 + t * dy)
                 );
             }
         }
         this._x = this._y = null;
         this._basis.lineEnd();
     },
-    point: function(x4, y4) {
-        this._x.push(+x4);
-        this._y.push(+y4);
+    point: function(x7, y7) {
+        this._x.push(+x7);
+        this._y.push(+y7);
     }
 };
-var bundle_default = function custom12(beta) {
+var bundle_default2 = function custom30(beta) {
     function bundle(context) {
-        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
+        return beta === 1 ? new Basis2(context) : new Bundle2(context, beta);
     }
     bundle.beta = function(beta2) {
-        return custom12(+beta2);
+        return custom30(+beta2);
     };
     return bundle;
 }(0.85);
 
-// node_modules/d3-shape/src/curve/cardinal.js
-function point3(that, x4, y4) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/cardinal.js
+function point8(that, x7, y7) {
     that._context.bezierCurveTo(
         that._x1 + that._k * (that._x2 - that._x0),
         that._y1 + that._k * (that._y2 - that._y0),
-        that._x2 + that._k * (that._x1 - x4),
-        that._y2 + that._k * (that._y1 - y4),
+        that._x2 + that._k * (that._x1 - x7),
+        that._y2 + that._k * (that._y1 - y7),
         that._x2,
         that._y2
     );
 }
 
-function Cardinal(context, tension) {
+function Cardinal2(context, tension) {
     this._context = context;
     this._k = (1 - tension) / 6;
 }
-Cardinal.prototype = {
+Cardinal2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20150,60 +54856,60 @@
     },
     lineEnd: function() {
         switch (this._point) {
             case 2:
                 this._context.lineTo(this._x2, this._y2);
                 break;
             case 3:
-                point3(this, this._x1, this._y1);
+                point8(this, this._x1, this._y1);
                 break;
         }
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
-                this._x1 = x4, this._y1 = y4;
+                this._x1 = x7, this._y1 = y7;
                 break;
             case 2:
                 this._point = 3;
             default:
-                point3(this, x4, y4);
+                point8(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var cardinal_default = function custom13(tension) {
+var cardinal_default2 = function custom31(tension) {
     function cardinal(context) {
-        return new Cardinal(context, tension);
+        return new Cardinal2(context, tension);
     }
     cardinal.tension = function(tension2) {
-        return custom13(+tension2);
+        return custom31(+tension2);
     };
     return cardinal;
 }(0);
 
-// node_modules/d3-shape/src/curve/cardinalClosed.js
-function CardinalClosed(context, tension) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/cardinalClosed.js
+function CardinalClosed2(context, tension) {
     this._context = context;
     this._k = (1 - tension) / 6;
 }
-CardinalClosed.prototype = {
-    areaStart: noop_default2,
-    areaEnd: noop_default2,
+CardinalClosed2.prototype = {
+    areaStart: noop_default4,
+    areaEnd: noop_default4,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
         this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
@@ -20220,53 +54926,53 @@
                 this.point(this._x3, this._y3);
                 this.point(this._x4, this._y4);
                 this.point(this._x5, this._y5);
                 break;
             }
         }
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._x3 = x4, this._y3 = y4;
+                this._x3 = x7, this._y3 = y7;
                 break;
             case 1:
                 this._point = 2;
-                this._context.moveTo(this._x4 = x4, this._y4 = y4);
+                this._context.moveTo(this._x4 = x7, this._y4 = y7);
                 break;
             case 2:
                 this._point = 3;
-                this._x5 = x4, this._y5 = y4;
+                this._x5 = x7, this._y5 = y7;
                 break;
             default:
-                point3(this, x4, y4);
+                point8(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var cardinalClosed_default = function custom14(tension) {
+var cardinalClosed_default2 = function custom32(tension) {
     function cardinal(context) {
-        return new CardinalClosed(context, tension);
+        return new CardinalClosed2(context, tension);
     }
     cardinal.tension = function(tension2) {
-        return custom14(+tension2);
+        return custom32(+tension2);
     };
     return cardinal;
 }(0);
 
-// node_modules/d3-shape/src/curve/cardinalOpen.js
-function CardinalOpen(context, tension) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/cardinalOpen.js
+function CardinalOpen2(context, tension) {
     this._context = context;
     this._k = (1 - tension) / 6;
 }
-CardinalOpen.prototype = {
+CardinalOpen2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20274,73 +54980,73 @@
         this._point = 0;
     },
     lineEnd: function() {
         if (this._line || this._line !== 0 && this._point === 3)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
                 this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                 break;
             case 3:
                 this._point = 4;
             default:
-                point3(this, x4, y4);
+                point8(this, x7, y7);
                 break;
         }
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var cardinalOpen_default = function custom15(tension) {
+var cardinalOpen_default2 = function custom33(tension) {
     function cardinal(context) {
-        return new CardinalOpen(context, tension);
+        return new CardinalOpen2(context, tension);
     }
     cardinal.tension = function(tension2) {
-        return custom15(+tension2);
+        return custom33(+tension2);
     };
     return cardinal;
 }(0);
 
-// node_modules/d3-shape/src/curve/catmullRom.js
-function point4(that, x4, y4) {
-    var x12 = that._x1,
-        y12 = that._y1,
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/catmullRom.js
+function point9(that, x7, y7) {
+    var x13 = that._x1,
+        y13 = that._y1,
         x22 = that._x2,
         y22 = that._y2;
-    if (that._l01_a > epsilon8) {
-        var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
+    if (that._l01_a > epsilon15) {
+        var a7 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
             n = 3 * that._l01_a * (that._l01_a + that._l12_a);
-        x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
-        y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
+        x13 = (x13 * a7 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
+        y13 = (y13 * a7 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
     }
-    if (that._l23_a > epsilon8) {
+    if (that._l23_a > epsilon15) {
         var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
-            m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
-        x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;
-        y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
+            m5 = 3 * that._l23_a * (that._l23_a + that._l12_a);
+        x22 = (x22 * b + that._x1 * that._l23_2a - x7 * that._l12_2a) / m5;
+        y22 = (y22 * b + that._y1 * that._l23_2a - y7 * that._l12_2a) / m5;
     }
-    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
+    that._context.bezierCurveTo(x13, y13, x22, y22, that._x2, that._y2);
 }
 
-function CatmullRom(context, alpha) {
+function CatmullRom2(context, alpha) {
     this._context = context;
     this._alpha = alpha;
 }
-CatmullRom.prototype = {
+CatmullRom2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20356,59 +55062,59 @@
                 this.point(this._x2, this._y2);
                 break;
         }
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         if (this._point) {
-            var x23 = this._x2 - x4,
-                y23 = this._y2 - y4;
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
             this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
             default:
-                point4(this, x4, y4);
+                point9(this, x7, y7);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a;
         this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var catmullRom_default = function custom16(alpha) {
+var catmullRom_default2 = function custom34(alpha) {
     function catmullRom(context) {
-        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
+        return alpha ? new CatmullRom2(context, alpha) : new Cardinal2(context, 0);
     }
     catmullRom.alpha = function(alpha2) {
-        return custom16(+alpha2);
+        return custom34(+alpha2);
     };
     return catmullRom;
 }(0.5);
 
-// node_modules/d3-shape/src/curve/catmullRomClosed.js
-function CatmullRomClosed(context, alpha) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/catmullRomClosed.js
+function CatmullRomClosed2(context, alpha) {
     this._context = context;
     this._alpha = alpha;
 }
-CatmullRomClosed.prototype = {
-    areaStart: noop_default2,
-    areaEnd: noop_default2,
+CatmullRomClosed2.prototype = {
+    areaStart: noop_default4,
+    areaEnd: noop_default4,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
         this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
@@ -20425,60 +55131,60 @@
                 this.point(this._x3, this._y3);
                 this.point(this._x4, this._y4);
                 this.point(this._x5, this._y5);
                 break;
             }
         }
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         if (this._point) {
-            var x23 = this._x2 - x4,
-                y23 = this._y2 - y4;
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
             this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._x3 = x4, this._y3 = y4;
+                this._x3 = x7, this._y3 = y7;
                 break;
             case 1:
                 this._point = 2;
-                this._context.moveTo(this._x4 = x4, this._y4 = y4);
+                this._context.moveTo(this._x4 = x7, this._y4 = y7);
                 break;
             case 2:
                 this._point = 3;
-                this._x5 = x4, this._y5 = y4;
+                this._x5 = x7, this._y5 = y7;
                 break;
             default:
-                point4(this, x4, y4);
+                point9(this, x7, y7);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a;
         this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var catmullRomClosed_default = function custom17(alpha) {
+var catmullRomClosed_default2 = function custom35(alpha) {
     function catmullRom(context) {
-        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
+        return alpha ? new CatmullRomClosed2(context, alpha) : new CardinalClosed2(context, 0);
     }
     catmullRom.alpha = function(alpha2) {
-        return custom17(+alpha2);
+        return custom35(+alpha2);
     };
     return catmullRom;
 }(0.5);
 
-// node_modules/d3-shape/src/curve/catmullRomOpen.js
-function CatmullRomOpen(context, alpha) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/catmullRomOpen.js
+function CatmullRomOpen2(context, alpha) {
     this._context = context;
     this._alpha = alpha;
 }
-CatmullRomOpen.prototype = {
+CatmullRomOpen2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20486,19 +55192,19 @@
         this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
     },
     lineEnd: function() {
         if (this._line || this._line !== 0 && this._point === 3)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         if (this._point) {
-            var x23 = this._x2 - x4,
-                y23 = this._y2 - y4;
+            var x23 = this._x2 - x7,
+                y23 = this._y2 - y7;
             this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1;
                 break;
             case 1:
@@ -20507,92 +55213,92 @@
             case 2:
                 this._point = 3;
                 this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                 break;
             case 3:
                 this._point = 4;
             default:
-                point4(this, x4, y4);
+                point9(this, x7, y7);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a;
         this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
-        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
-        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
+        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
+        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
     }
 };
-var catmullRomOpen_default = function custom18(alpha) {
+var catmullRomOpen_default2 = function custom36(alpha) {
     function catmullRom(context) {
-        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
+        return alpha ? new CatmullRomOpen2(context, alpha) : new CardinalOpen2(context, 0);
     }
     catmullRom.alpha = function(alpha2) {
-        return custom18(+alpha2);
+        return custom36(+alpha2);
     };
     return catmullRom;
 }(0.5);
 
-// node_modules/d3-shape/src/curve/linearClosed.js
-function LinearClosed(context) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/linearClosed.js
+function LinearClosed2(context) {
     this._context = context;
 }
-LinearClosed.prototype = {
-    areaStart: noop_default2,
-    areaEnd: noop_default2,
+LinearClosed2.prototype = {
+    areaStart: noop_default4,
+    areaEnd: noop_default4,
     lineStart: function() {
         this._point = 0;
     },
     lineEnd: function() {
         if (this._point)
             this._context.closePath();
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         if (this._point)
-            this._context.lineTo(x4, y4);
+            this._context.lineTo(x7, y7);
         else
-            this._point = 1, this._context.moveTo(x4, y4);
+            this._point = 1, this._context.moveTo(x7, y7);
     }
 };
 
-function linearClosed_default(context) {
-    return new LinearClosed(context);
+function linearClosed_default2(context) {
+    return new LinearClosed2(context);
 }
 
-// node_modules/d3-shape/src/curve/monotone.js
-function sign2(x4) {
-    return x4 < 0 ? -1 : 1;
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/monotone.js
+function sign4(x7) {
+    return x7 < 0 ? -1 : 1;
 }
 
-function slope3(that, x22, y22) {
+function slope32(that, x22, y22) {
     var h0 = that._x1 - that._x0,
         h1 = x22 - that._x1,
         s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
         s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0),
         p = (s0 * h1 + s1 * h0) / (h0 + h1);
-    return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
+    return (sign4(s0) + sign4(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
 }
 
-function slope2(that, t) {
+function slope22(that, t) {
     var h = that._x1 - that._x0;
     return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
 }
 
-function point5(that, t03, t13) {
-    var x06 = that._x0,
-        y06 = that._y0,
-        x12 = that._x1,
-        y12 = that._y1,
-        dx = (x12 - x06) / 3;
-    that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
+function point10(that, t05, t15) {
+    var x011 = that._x0,
+        y011 = that._y0,
+        x13 = that._x1,
+        y13 = that._y1,
+        dx = (x13 - x011) / 3;
+    that._context.bezierCurveTo(x011 + dx, y011 + dx * t05, x13 - dx, y13 - dx * t15, x13, y13);
 }
 
-function MonotoneX(context) {
+function MonotoneX2(context) {
     this._context = context;
 }
-MonotoneX.prototype = {
+MonotoneX2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20601,153 +55307,153 @@
     },
     lineEnd: function() {
         switch (this._point) {
             case 2:
                 this._context.lineTo(this._x1, this._y1);
                 break;
             case 3:
-                point5(this, this._t0, slope2(this, this._t0));
+                point10(this, this._t0, slope22(this, this._t0));
                 break;
         }
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        var t13 = NaN;
-        x4 = +x4, y4 = +y4;
-        if (x4 === this._x1 && y4 === this._y1)
+    point: function(x7, y7) {
+        var t15 = NaN;
+        x7 = +x7, y7 = +y7;
+        if (x7 === this._x1 && y7 === this._y1)
             return;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
-                point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);
+                point10(this, slope22(this, t15 = slope32(this, x7, y7)), t15);
                 break;
             default:
-                point5(this, this._t0, t13 = slope3(this, x4, y4));
+                point10(this, this._t0, t15 = slope32(this, x7, y7));
                 break;
         }
-        this._x0 = this._x1, this._x1 = x4;
-        this._y0 = this._y1, this._y1 = y4;
-        this._t0 = t13;
+        this._x0 = this._x1, this._x1 = x7;
+        this._y0 = this._y1, this._y1 = y7;
+        this._t0 = t15;
     }
 };
 
-function MonotoneY(context) {
-    this._context = new ReflectContext(context);
+function MonotoneY2(context) {
+    this._context = new ReflectContext2(context);
 }
-(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
-    MonotoneX.prototype.point.call(this, y4, x4);
+(MonotoneY2.prototype = Object.create(MonotoneX2.prototype)).point = function(x7, y7) {
+    MonotoneX2.prototype.point.call(this, y7, x7);
 };
 
-function ReflectContext(context) {
+function ReflectContext2(context) {
     this._context = context;
 }
-ReflectContext.prototype = {
-    moveTo: function(x4, y4) {
-        this._context.moveTo(y4, x4);
+ReflectContext2.prototype = {
+    moveTo: function(x7, y7) {
+        this._context.moveTo(y7, x7);
     },
     closePath: function() {
         this._context.closePath();
     },
-    lineTo: function(x4, y4) {
-        this._context.lineTo(y4, x4);
+    lineTo: function(x7, y7) {
+        this._context.lineTo(y7, x7);
     },
-    bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
-        this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);
+    bezierCurveTo: function(x13, y13, x22, y22, x7, y7) {
+        this._context.bezierCurveTo(y13, x13, y22, x22, y7, x7);
     }
 };
 
-function monotoneX(context) {
-    return new MonotoneX(context);
+function monotoneX2(context) {
+    return new MonotoneX2(context);
 }
 
-function monotoneY(context) {
-    return new MonotoneY(context);
+function monotoneY2(context) {
+    return new MonotoneY2(context);
 }
 
-// node_modules/d3-shape/src/curve/natural.js
-function Natural(context) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/natural.js
+function Natural2(context) {
     this._context = context;
 }
-Natural.prototype = {
+Natural2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
         this._x = [];
         this._y = [];
     },
     lineEnd: function() {
-        var x4 = this._x,
-            y4 = this._y,
-            n = x4.length;
+        var x7 = this._x,
+            y7 = this._y,
+            n = x7.length;
         if (n) {
-            this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
+            this._line ? this._context.lineTo(x7[0], y7[0]) : this._context.moveTo(x7[0], y7[0]);
             if (n === 2) {
-                this._context.lineTo(x4[1], y4[1]);
+                this._context.lineTo(x7[1], y7[1]);
             } else {
-                var px = controlPoints(x4),
-                    py = controlPoints(y4);
+                var px = controlPoints2(x7),
+                    py = controlPoints2(y7);
                 for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
-                    this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
+                    this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x7[i1], y7[i1]);
                 }
             }
         }
         if (this._line || this._line !== 0 && n === 1)
             this._context.closePath();
         this._line = 1 - this._line;
         this._x = this._y = null;
     },
-    point: function(x4, y4) {
-        this._x.push(+x4);
-        this._y.push(+y4);
+    point: function(x7, y7) {
+        this._x.push(+x7);
+        this._y.push(+y7);
     }
 };
 
-function controlPoints(x4) {
-    var i, n = x4.length - 1,
-        m3, a4 = new Array(n),
+function controlPoints2(x7) {
+    var i, n = x7.length - 1,
+        m5, a7 = new Array(n),
         b = new Array(n),
         r = new Array(n);
-    a4[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];
+    a7[0] = 0, b[0] = 2, r[0] = x7[0] + 2 * x7[1];
     for (i = 1; i < n - 1; ++i)
-        a4[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
-    a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
+        a7[i] = 1, b[i] = 4, r[i] = 4 * x7[i] + 2 * x7[i + 1];
+    a7[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x7[n - 1] + x7[n];
     for (i = 1; i < n; ++i)
-        m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
-    a4[n - 1] = r[n - 1] / b[n - 1];
+        m5 = a7[i] / b[i - 1], b[i] -= m5, r[i] -= m5 * r[i - 1];
+    a7[n - 1] = r[n - 1] / b[n - 1];
     for (i = n - 2; i >= 0; --i)
-        a4[i] = (r[i] - a4[i + 1]) / b[i];
-    b[n - 1] = (x4[n] + a4[n - 1]) / 2;
+        a7[i] = (r[i] - a7[i + 1]) / b[i];
+    b[n - 1] = (x7[n] + a7[n - 1]) / 2;
     for (i = 0; i < n - 1; ++i)
-        b[i] = 2 * x4[i + 1] - a4[i + 1];
-    return [a4, b];
+        b[i] = 2 * x7[i + 1] - a7[i + 1];
+    return [a7, b];
 }
 
-function natural_default(context) {
-    return new Natural(context);
+function natural_default2(context) {
+    return new Natural2(context);
 }
 
-// node_modules/d3-shape/src/curve/step.js
-function Step(context, t) {
+// js/pyobsplot-js/node_modules/d3-shape/src/curve/step.js
+function Step2(context, t) {
     this._context = context;
     this._t = t;
 }
-Step.prototype = {
+Step2.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -20758,364 +55464,364 @@
         if (0 < this._t && this._t < 1 && this._point === 2)
             this._context.lineTo(this._x, this._y);
         if (this._line || this._line !== 0 && this._point === 1)
             this._context.closePath();
         if (this._line >= 0)
             this._t = 1 - this._t, this._line = 1 - this._line;
     },
-    point: function(x4, y4) {
-        x4 = +x4, y4 = +y4;
+    point: function(x7, y7) {
+        x7 = +x7, y7 = +y7;
         switch (this._point) {
             case 0:
                 this._point = 1;
-                this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
+                this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
                 break;
             case 1:
                 this._point = 2;
             default: {
                 if (this._t <= 0) {
-                    this._context.lineTo(this._x, y4);
-                    this._context.lineTo(x4, y4);
+                    this._context.lineTo(this._x, y7);
+                    this._context.lineTo(x7, y7);
                 } else {
-                    var x12 = this._x * (1 - this._t) + x4 * this._t;
-                    this._context.lineTo(x12, this._y);
-                    this._context.lineTo(x12, y4);
+                    var x13 = this._x * (1 - this._t) + x7 * this._t;
+                    this._context.lineTo(x13, this._y);
+                    this._context.lineTo(x13, y7);
                 }
                 break;
             }
         }
-        this._x = x4, this._y = y4;
+        this._x = x7, this._y = y7;
     }
 };
 
-function step_default(context) {
-    return new Step(context, 0.5);
+function step_default2(context) {
+    return new Step2(context, 0.5);
 }
 
-function stepBefore(context) {
-    return new Step(context, 0);
+function stepBefore2(context) {
+    return new Step2(context, 0);
 }
 
-function stepAfter(context) {
-    return new Step(context, 1);
+function stepAfter2(context) {
+    return new Step2(context, 1);
 }
 
-// node_modules/d3-shape/src/offset/none.js
-function none_default(series, order) {
+// js/pyobsplot-js/node_modules/d3-shape/src/offset/none.js
+function none_default3(series, order) {
     if (!((n = series.length) > 1))
         return;
-    for (var i = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {
+    for (var i = 1, j, s0, s1 = series[order[0]], n, m5 = s1.length; i < n; ++i) {
         s0 = s1, s1 = series[order[i]];
-        for (j = 0; j < m3; ++j) {
+        for (j = 0; j < m5; ++j) {
             s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
         }
     }
 }
 
-// node_modules/d3-shape/src/order/none.js
-function none_default2(series) {
+// js/pyobsplot-js/node_modules/d3-shape/src/order/none.js
+function none_default4(series) {
     var n = series.length,
         o = new Array(n);
     while (--n >= 0)
         o[n] = n;
     return o;
 }
 
-// node_modules/d3-shape/src/stack.js
-function stackValue(d, key) {
+// js/pyobsplot-js/node_modules/d3-shape/src/stack.js
+function stackValue2(d, key) {
     return d[key];
 }
 
-function stackSeries(key) {
+function stackSeries2(key) {
     const series = [];
     series.key = key;
     return series;
 }
 
-function stack_default() {
-    var keys = constant_default10([]),
-        order = none_default2,
-        offset2 = none_default,
-        value = stackValue;
+function stack_default2() {
+    var keys = constant_default21([]),
+        order = none_default4,
+        offset3 = none_default3,
+        value = stackValue2;
 
-    function stack2(data) {
-        var sz = Array.from(keys.apply(this, arguments), stackSeries),
+    function stack3(data) {
+        var sz = Array.from(keys.apply(this, arguments), stackSeries2),
             i, n = sz.length,
             j = -1,
             oz;
         for (const d of data) {
             for (i = 0, ++j; i < n; ++i) {
                 (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
             }
         }
-        for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {
+        for (i = 0, oz = array_default6(order(sz)); i < n; ++i) {
             sz[oz[i]].index = i;
         }
-        offset2(sz, oz);
+        offset3(sz, oz);
         return sz;
     }
-    stack2.keys = function(_) {
-        return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack2) : keys;
+    stack3.keys = function(_) {
+        return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default21(Array.from(_)), stack3) : keys;
     };
-    stack2.value = function(_) {
-        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), stack2) : value;
+    stack3.value = function(_) {
+        return arguments.length ? (value = typeof _ === "function" ? _ : constant_default21(+_), stack3) : value;
     };
-    stack2.order = function(_) {
-        return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack2) : order;
+    stack3.order = function(_) {
+        return arguments.length ? (order = _ == null ? none_default4 : typeof _ === "function" ? _ : constant_default21(Array.from(_)), stack3) : order;
     };
-    stack2.offset = function(_) {
-        return arguments.length ? (offset2 = _ == null ? none_default : _, stack2) : offset2;
+    stack3.offset = function(_) {
+        return arguments.length ? (offset3 = _ == null ? none_default3 : _, stack3) : offset3;
     };
-    return stack2;
+    return stack3;
 }
 
-// node_modules/d3-shape/src/offset/expand.js
-function expand_default(series, order) {
+// js/pyobsplot-js/node_modules/d3-shape/src/offset/expand.js
+function expand_default2(series, order) {
     if (!((n = series.length) > 0))
         return;
-    for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {
-        for (y4 = i = 0; i < n; ++i)
-            y4 += series[i][j][1] || 0;
-        if (y4)
+    for (var i, n, j = 0, m5 = series[0].length, y7; j < m5; ++j) {
+        for (y7 = i = 0; i < n; ++i)
+            y7 += series[i][j][1] || 0;
+        if (y7)
             for (i = 0; i < n; ++i)
-                series[i][j][1] /= y4;
+                series[i][j][1] /= y7;
     }
-    none_default(series, order);
+    none_default3(series, order);
 }
 
-// node_modules/d3-shape/src/offset/diverging.js
-function diverging_default(series, order) {
+// js/pyobsplot-js/node_modules/d3-shape/src/offset/diverging.js
+function diverging_default2(series, order) {
     if (!((n = series.length) > 0))
         return;
-    for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {
+    for (var i, j = 0, d, dy, yp, yn, n, m5 = series[order[0]].length; j < m5; ++j) {
         for (yp = yn = 0, i = 0; i < n; ++i) {
             if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
                 d[0] = yp, d[1] = yp += dy;
             } else if (dy < 0) {
                 d[1] = yn, d[0] = yn += dy;
             } else {
                 d[0] = 0, d[1] = dy;
             }
         }
     }
 }
 
-// node_modules/d3-shape/src/offset/silhouette.js
-function silhouette_default(series, order) {
+// js/pyobsplot-js/node_modules/d3-shape/src/offset/silhouette.js
+function silhouette_default2(series, order) {
     if (!((n = series.length) > 0))
         return;
-    for (var j = 0, s0 = series[order[0]], n, m3 = s0.length; j < m3; ++j) {
-        for (var i = 0, y4 = 0; i < n; ++i)
-            y4 += series[i][j][1] || 0;
-        s0[j][1] += s0[j][0] = -y4 / 2;
+    for (var j = 0, s0 = series[order[0]], n, m5 = s0.length; j < m5; ++j) {
+        for (var i = 0, y7 = 0; i < n; ++i)
+            y7 += series[i][j][1] || 0;
+        s0[j][1] += s0[j][0] = -y7 / 2;
     }
-    none_default(series, order);
+    none_default3(series, order);
 }
 
-// node_modules/d3-shape/src/offset/wiggle.js
-function wiggle_default(series, order) {
-    if (!((n = series.length) > 0) || !((m3 = (s0 = series[order[0]]).length) > 0))
+// js/pyobsplot-js/node_modules/d3-shape/src/offset/wiggle.js
+function wiggle_default2(series, order) {
+    if (!((n = series.length) > 0) || !((m5 = (s0 = series[order[0]]).length) > 0))
         return;
-    for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {
-        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
+    for (var y7 = 0, j = 1, s0, m5, n; j < m5; ++j) {
+        for (var i = 0, s1 = 0, s22 = 0; i < n; ++i) {
             var si = series[order[i]],
                 sij0 = si[j][1] || 0,
                 sij1 = si[j - 1][1] || 0,
                 s3 = (sij0 - sij1) / 2;
-            for (var k2 = 0; k2 < i; ++k2) {
-                var sk = series[order[k2]],
+            for (var k3 = 0; k3 < i; ++k3) {
+                var sk = series[order[k3]],
                     skj0 = sk[j][1] || 0,
                     skj1 = sk[j - 1][1] || 0;
                 s3 += skj0 - skj1;
             }
-            s1 += sij0, s2 += s3 * sij0;
+            s1 += sij0, s22 += s3 * sij0;
         }
-        s0[j - 1][1] += s0[j - 1][0] = y4;
+        s0[j - 1][1] += s0[j - 1][0] = y7;
         if (s1)
-            y4 -= s2 / s1;
+            y7 -= s22 / s1;
     }
-    s0[j - 1][1] += s0[j - 1][0] = y4;
-    none_default(series, order);
+    s0[j - 1][1] += s0[j - 1][0] = y7;
+    none_default3(series, order);
 }
 
-// node_modules/d3-shape/src/order/appearance.js
-function appearance_default(series) {
-    var peaks = series.map(peak);
-    return none_default2(series).sort(function(a4, b) {
-        return peaks[a4] - peaks[b];
+// js/pyobsplot-js/node_modules/d3-shape/src/order/appearance.js
+function appearance_default2(series) {
+    var peaks = series.map(peak2);
+    return none_default4(series).sort(function(a7, b) {
+        return peaks[a7] - peaks[b];
     });
 }
 
-function peak(series) {
+function peak2(series) {
     var i = -1,
         j = 0,
         n = series.length,
         vi, vj = -Infinity;
     while (++i < n)
         if ((vi = +series[i][1]) > vj)
             vj = vi, j = i;
     return j;
 }
 
-// node_modules/d3-shape/src/order/ascending.js
-function ascending_default2(series) {
-    var sums = series.map(sum3);
-    return none_default2(series).sort(function(a4, b) {
-        return sums[a4] - sums[b];
+// js/pyobsplot-js/node_modules/d3-shape/src/order/ascending.js
+function ascending_default4(series) {
+    var sums = series.map(sum6);
+    return none_default4(series).sort(function(a7, b) {
+        return sums[a7] - sums[b];
     });
 }
 
-function sum3(series) {
-    var s2 = 0,
+function sum6(series) {
+    var s3 = 0,
         i = -1,
         n = series.length,
-        v2;
+        v3;
     while (++i < n)
-        if (v2 = +series[i][1])
-            s2 += v2;
-    return s2;
+        if (v3 = +series[i][1])
+            s3 += v3;
+    return s3;
 }
 
-// node_modules/d3-shape/src/order/descending.js
-function descending_default2(series) {
-    return ascending_default2(series).reverse();
+// js/pyobsplot-js/node_modules/d3-shape/src/order/descending.js
+function descending_default4(series) {
+    return ascending_default4(series).reverse();
 }
 
-// node_modules/d3-shape/src/order/insideOut.js
-function insideOut_default(series) {
+// js/pyobsplot-js/node_modules/d3-shape/src/order/insideOut.js
+function insideOut_default2(series) {
     var n = series.length,
-        i, j, sums = series.map(sum3),
-        order = appearance_default(series),
-        top2 = 0,
-        bottom2 = 0,
+        i, j, sums = series.map(sum6),
+        order = appearance_default2(series),
+        top3 = 0,
+        bottom3 = 0,
         tops = [],
         bottoms = [];
     for (i = 0; i < n; ++i) {
         j = order[i];
-        if (top2 < bottom2) {
-            top2 += sums[j];
+        if (top3 < bottom3) {
+            top3 += sums[j];
             tops.push(j);
         } else {
-            bottom2 += sums[j];
+            bottom3 += sums[j];
             bottoms.push(j);
         }
     }
     return bottoms.reverse().concat(tops);
 }
 
-// node_modules/d3-shape/src/order/reverse.js
-function reverse_default(series) {
-    return none_default2(series).reverse();
+// js/pyobsplot-js/node_modules/d3-shape/src/order/reverse.js
+function reverse_default2(series) {
+    return none_default4(series).reverse();
 }
 
-// node_modules/d3-zoom/src/constant.js
-var constant_default11 = (x4) => () => x4;
+// js/pyobsplot-js/node_modules/d3-zoom/src/constant.js
+var constant_default22 = (x7) => () => x7;
 
-// node_modules/d3-zoom/src/event.js
-function ZoomEvent(type2, {
+// js/pyobsplot-js/node_modules/d3-zoom/src/event.js
+function ZoomEvent2(type3, {
     sourceEvent,
     target,
-    transform: transform2,
-    dispatch: dispatch2
+    transform: transform3,
+    dispatch: dispatch3
 }) {
     Object.defineProperties(this, {
         type: {
-            value: type2,
+            value: type3,
             enumerable: true,
             configurable: true
         },
         sourceEvent: {
             value: sourceEvent,
             enumerable: true,
             configurable: true
         },
         target: {
             value: target,
             enumerable: true,
             configurable: true
         },
         transform: {
-            value: transform2,
+            value: transform3,
             enumerable: true,
             configurable: true
         },
         _: {
-            value: dispatch2
+            value: dispatch3
         }
     });
 }
 
-// node_modules/d3-zoom/src/transform.js
-function Transform(k2, x4, y4) {
-    this.k = k2;
-    this.x = x4;
-    this.y = y4;
-}
-Transform.prototype = {
-    constructor: Transform,
-    scale: function(k2) {
-        return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
+// js/pyobsplot-js/node_modules/d3-zoom/src/transform.js
+function Transform2(k3, x7, y7) {
+    this.k = k3;
+    this.x = x7;
+    this.y = y7;
+}
+Transform2.prototype = {
+    constructor: Transform2,
+    scale: function(k3) {
+        return k3 === 1 ? this : new Transform2(this.k * k3, this.x, this.y);
     },
-    translate: function(x4, y4) {
-        return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);
+    translate: function(x7, y7) {
+        return x7 === 0 & y7 === 0 ? this : new Transform2(this.k, this.x + this.k * x7, this.y + this.k * y7);
     },
-    apply: function(point6) {
-        return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
+    apply: function(point11) {
+        return [point11[0] * this.k + this.x, point11[1] * this.k + this.y];
     },
-    applyX: function(x4) {
-        return x4 * this.k + this.x;
+    applyX: function(x7) {
+        return x7 * this.k + this.x;
     },
-    applyY: function(y4) {
-        return y4 * this.k + this.y;
+    applyY: function(y7) {
+        return y7 * this.k + this.y;
     },
     invert: function(location) {
         return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
     },
-    invertX: function(x4) {
-        return (x4 - this.x) / this.k;
+    invertX: function(x7) {
+        return (x7 - this.x) / this.k;
     },
-    invertY: function(y4) {
-        return (y4 - this.y) / this.k;
+    invertY: function(y7) {
+        return (y7 - this.y) / this.k;
     },
-    rescaleX: function(x4) {
-        return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));
+    rescaleX: function(x7) {
+        return x7.copy().domain(x7.range().map(this.invertX, this).map(x7.invert, x7));
     },
-    rescaleY: function(y4) {
-        return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
+    rescaleY: function(y7) {
+        return y7.copy().domain(y7.range().map(this.invertY, this).map(y7.invert, y7));
     },
     toString: function() {
         return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
     }
 };
-var identity5 = new Transform(1, 0, 0);
-transform.prototype = Transform.prototype;
+var identity12 = new Transform2(1, 0, 0);
+transform2.prototype = Transform2.prototype;
 
-function transform(node) {
+function transform2(node) {
     while (!node.__zoom)
         if (!(node = node.parentNode))
-            return identity5;
+            return identity12;
     return node.__zoom;
 }
 
-// node_modules/d3-zoom/src/noevent.js
-function nopropagation3(event) {
+// js/pyobsplot-js/node_modules/d3-zoom/src/noevent.js
+function nopropagation6(event) {
     event.stopImmediatePropagation();
 }
 
-function noevent_default3(event) {
+function noevent_default6(event) {
     event.preventDefault();
     event.stopImmediatePropagation();
 }
 
-// node_modules/d3-zoom/src/zoom.js
-function defaultFilter3(event) {
+// js/pyobsplot-js/node_modules/d3-zoom/src/zoom.js
+function defaultFilter6(event) {
     return (!event.ctrlKey || event.type === "wheel") && !event.button;
 }
 
-function defaultExtent2() {
+function defaultExtent4() {
     var e = this;
     if (e instanceof SVGElement) {
         e = e.ownerSVGElement || e;
         if (e.hasAttribute("viewBox")) {
             e = e.viewBox.baseVal;
             return [
                 [e.x, e.y],
@@ -21129,146 +55835,146 @@
     }
     return [
         [0, 0],
         [e.clientWidth, e.clientHeight]
     ];
 }
 
-function defaultTransform() {
-    return this.__zoom || identity5;
+function defaultTransform2() {
+    return this.__zoom || identity12;
 }
 
-function defaultWheelDelta(event) {
+function defaultWheelDelta2(event) {
     return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
 }
 
-function defaultTouchable3() {
+function defaultTouchable6() {
     return navigator.maxTouchPoints || "ontouchstart" in this;
 }
 
-function defaultConstrain(transform2, extent3, translateExtent) {
-    var dx0 = transform2.invertX(extent3[0][0]) - translateExtent[0][0],
-        dx1 = transform2.invertX(extent3[1][0]) - translateExtent[1][0],
-        dy0 = transform2.invertY(extent3[0][1]) - translateExtent[0][1],
-        dy1 = transform2.invertY(extent3[1][1]) - translateExtent[1][1];
-    return transform2.translate(
+function defaultConstrain2(transform3, extent5, translateExtent) {
+    var dx0 = transform3.invertX(extent5[0][0]) - translateExtent[0][0],
+        dx1 = transform3.invertX(extent5[1][0]) - translateExtent[1][0],
+        dy0 = transform3.invertY(extent5[0][1]) - translateExtent[0][1],
+        dy1 = transform3.invertY(extent5[1][1]) - translateExtent[1][1];
+    return transform3.translate(
         dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
         dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
     );
 }
 
-function zoom_default2() {
-    var filter4 = defaultFilter3,
-        extent3 = defaultExtent2,
-        constrain = defaultConstrain,
-        wheelDelta = defaultWheelDelta,
-        touchable = defaultTouchable3,
+function zoom_default4() {
+    var filter7 = defaultFilter6,
+        extent5 = defaultExtent4,
+        constrain = defaultConstrain2,
+        wheelDelta = defaultWheelDelta2,
+        touchable = defaultTouchable6,
         scaleExtent = [0, Infinity],
         translateExtent = [
             [-Infinity, -Infinity],
             [Infinity, Infinity]
         ],
         duration = 250,
-        interpolate = zoom_default,
-        listeners = dispatch_default("start", "zoom", "end"),
+        interpolate = zoom_default3,
+        listeners = dispatch_default3("start", "zoom", "end"),
         touchstarting, touchfirst, touchending, touchDelay = 500,
         wheelDelay = 150,
         clickDistance2 = 0,
         tapDistance = 10;
 
-    function zoom(selection2) {
-        selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
+    function zoom(selection3) {
+        selection3.property("__zoom", defaultTransform2).on("wheel.zoom", wheeled, {
             passive: false
         }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
     }
-    zoom.transform = function(collection, transform2, point6, event) {
-        var selection2 = collection.selection ? collection.selection() : collection;
-        selection2.property("__zoom", defaultTransform);
-        if (collection !== selection2) {
-            schedule(collection, transform2, point6, event);
+    zoom.transform = function(collection, transform3, point11, event) {
+        var selection3 = collection.selection ? collection.selection() : collection;
+        selection3.property("__zoom", defaultTransform2);
+        if (collection !== selection3) {
+            schedule(collection, transform3, point11, event);
         } else {
-            selection2.interrupt().each(function() {
-                gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
+            selection3.interrupt().each(function() {
+                gesture(this, arguments).event(event).start().zoom(null, typeof transform3 === "function" ? transform3.apply(this, arguments) : transform3).end();
             });
         }
     };
-    zoom.scaleBy = function(selection2, k2, p, event) {
-        zoom.scaleTo(selection2, function() {
+    zoom.scaleBy = function(selection3, k3, p, event) {
+        zoom.scaleTo(selection3, function() {
             var k0 = this.__zoom.k,
-                k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
+                k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
             return k0 * k1;
         }, p, event);
     };
-    zoom.scaleTo = function(selection2, k2, p, event) {
-        zoom.transform(selection2, function() {
-            var e = extent3.apply(this, arguments),
-                t03 = this.__zoom,
-                p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p,
-                p1 = t03.invert(p02),
-                k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
-            return constrain(translate(scale3(t03, k1), p02, p1), e, translateExtent);
+    zoom.scaleTo = function(selection3, k3, p, event) {
+        zoom.transform(selection3, function() {
+            var e = extent5.apply(this, arguments),
+                t05 = this.__zoom,
+                p03 = p == null ? centroid3(e) : typeof p === "function" ? p.apply(this, arguments) : p,
+                p1 = t05.invert(p03),
+                k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
+            return constrain(translate(scale5(t05, k1), p03, p1), e, translateExtent);
         }, p, event);
     };
-    zoom.translateBy = function(selection2, x4, y4, event) {
-        zoom.transform(selection2, function() {
+    zoom.translateBy = function(selection3, x7, y7, event) {
+        zoom.transform(selection3, function() {
             return constrain(this.__zoom.translate(
-                typeof x4 === "function" ? x4.apply(this, arguments) : x4,
-                typeof y4 === "function" ? y4.apply(this, arguments) : y4
-            ), extent3.apply(this, arguments), translateExtent);
+                typeof x7 === "function" ? x7.apply(this, arguments) : x7,
+                typeof y7 === "function" ? y7.apply(this, arguments) : y7
+            ), extent5.apply(this, arguments), translateExtent);
         }, null, event);
     };
-    zoom.translateTo = function(selection2, x4, y4, p, event) {
-        zoom.transform(selection2, function() {
-            var e = extent3.apply(this, arguments),
+    zoom.translateTo = function(selection3, x7, y7, p, event) {
+        zoom.transform(selection3, function() {
+            var e = extent5.apply(this, arguments),
                 t = this.__zoom,
-                p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p;
-            return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(
-                typeof x4 === "function" ? -x4.apply(this, arguments) : -x4,
-                typeof y4 === "function" ? -y4.apply(this, arguments) : -y4
+                p03 = p == null ? centroid3(e) : typeof p === "function" ? p.apply(this, arguments) : p;
+            return constrain(identity12.translate(p03[0], p03[1]).scale(t.k).translate(
+                typeof x7 === "function" ? -x7.apply(this, arguments) : -x7,
+                typeof y7 === "function" ? -y7.apply(this, arguments) : -y7
             ), e, translateExtent);
         }, p, event);
     };
 
-    function scale3(transform2, k2) {
-        k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
-        return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
+    function scale5(transform3, k3) {
+        k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k3));
+        return k3 === transform3.k ? transform3 : new Transform2(k3, transform3.x, transform3.y);
     }
 
-    function translate(transform2, p02, p1) {
-        var x4 = p02[0] - p1[0] * transform2.k,
-            y4 = p02[1] - p1[1] * transform2.k;
-        return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);
+    function translate(transform3, p03, p1) {
+        var x7 = p03[0] - p1[0] * transform3.k,
+            y7 = p03[1] - p1[1] * transform3.k;
+        return x7 === transform3.x && y7 === transform3.y ? transform3 : new Transform2(transform3.k, x7, y7);
     }
 
-    function centroid2(extent4) {
-        return [(+extent4[0][0] + +extent4[1][0]) / 2, (+extent4[0][1] + +extent4[1][1]) / 2];
+    function centroid3(extent6) {
+        return [(+extent6[0][0] + +extent6[1][0]) / 2, (+extent6[0][1] + +extent6[1][1]) / 2];
     }
 
-    function schedule(transition2, transform2, point6, event) {
-        transition2.on("start.zoom", function() {
+    function schedule(transition3, transform3, point11, event) {
+        transition3.on("start.zoom", function() {
             gesture(this, arguments).event(event).start();
         }).on("interrupt.zoom end.zoom", function() {
             gesture(this, arguments).event(event).end();
         }).tween("zoom", function() {
             var that = this,
                 args = arguments,
                 g = gesture(that, args).event(event),
-                e = extent3.apply(that, args),
-                p = point6 == null ? centroid2(e) : typeof point6 === "function" ? point6.apply(that, args) : point6,
+                e = extent5.apply(that, args),
+                p = point11 == null ? centroid3(e) : typeof point11 === "function" ? point11.apply(that, args) : point11,
                 w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
-                a4 = that.__zoom,
-                b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2,
-                i = interpolate(a4.invert(p).concat(w / a4.k), b.invert(p).concat(w / b.k));
+                a7 = that.__zoom,
+                b = typeof transform3 === "function" ? transform3.apply(that, args) : transform3,
+                i = interpolate(a7.invert(p).concat(w / a7.k), b.invert(p).concat(w / b.k));
             return function(t) {
                 if (t === 1)
                     t = b;
                 else {
                     var l = i(t),
-                        k2 = w / l[2];
-                    t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
+                        k3 = w / l[2];
+                    t = new Transform2(k3, p[0] - l[0] * k3, p[1] - l[1] * k3);
                 }
                 g.zoom(null, t);
             };
         });
     }
 
     function gesture(that, args, clean) {
@@ -21276,15 +55982,15 @@
     }
 
     function Gesture(that, args) {
         this.that = that;
         this.args = args;
         this.active = 0;
         this.sourceEvent = null;
-        this.extent = extent3.apply(that, args);
+        this.extent = extent5.apply(that, args);
         this.taps = 0;
     }
     Gesture.prototype = {
         event: function(event) {
             if (event)
                 this.sourceEvent = event;
             return this;
@@ -21292,179 +55998,179 @@
         start: function() {
             if (++this.active === 1) {
                 this.that.__zooming = this;
                 this.emit("start");
             }
             return this;
         },
-        zoom: function(key, transform2) {
+        zoom: function(key, transform3) {
             if (this.mouse && key !== "mouse")
-                this.mouse[1] = transform2.invert(this.mouse[0]);
+                this.mouse[1] = transform3.invert(this.mouse[0]);
             if (this.touch0 && key !== "touch")
-                this.touch0[1] = transform2.invert(this.touch0[0]);
+                this.touch0[1] = transform3.invert(this.touch0[0]);
             if (this.touch1 && key !== "touch")
-                this.touch1[1] = transform2.invert(this.touch1[0]);
-            this.that.__zoom = transform2;
+                this.touch1[1] = transform3.invert(this.touch1[0]);
+            this.that.__zoom = transform3;
             this.emit("zoom");
             return this;
         },
         end: function() {
             if (--this.active === 0) {
                 delete this.that.__zooming;
                 this.emit("end");
             }
             return this;
         },
-        emit: function(type2) {
-            var d = select_default2(this.that).datum();
+        emit: function(type3) {
+            var d = select_default5(this.that).datum();
             listeners.call(
-                type2,
+                type3,
                 this.that,
-                new ZoomEvent(type2, {
+                new ZoomEvent2(type3, {
                     sourceEvent: this.sourceEvent,
                     target: zoom,
-                    type: type2,
+                    type: type3,
                     transform: this.that.__zoom,
                     dispatch: listeners
                 }),
                 d
             );
         }
     };
 
     function wheeled(event, ...args) {
-        if (!filter4.apply(this, arguments))
+        if (!filter7.apply(this, arguments))
             return;
         var g = gesture(this, args).event(event),
             t = this.__zoom,
-            k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
-            p = pointer_default(event);
+            k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
+            p = pointer_default2(event);
         if (g.wheel) {
             if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
                 g.mouse[1] = t.invert(g.mouse[0] = p);
             }
             clearTimeout(g.wheel);
-        } else if (t.k === k2)
+        } else if (t.k === k3)
             return;
         else {
             g.mouse = [p, t.invert(p)];
-            interrupt_default(this);
+            interrupt_default3(this);
             g.start();
         }
-        noevent_default3(event);
+        noevent_default6(event);
         g.wheel = setTimeout(wheelidled, wheelDelay);
-        g.zoom("mouse", constrain(translate(scale3(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
+        g.zoom("mouse", constrain(translate(scale5(t, k3), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
 
         function wheelidled() {
             g.wheel = null;
             g.end();
         }
     }
 
     function mousedowned(event, ...args) {
-        if (touchending || !filter4.apply(this, arguments))
+        if (touchending || !filter7.apply(this, arguments))
             return;
         var currentTarget = event.currentTarget,
             g = gesture(this, args, true).event(event),
-            v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
-            p = pointer_default(event, currentTarget),
-            x06 = event.clientX,
-            y06 = event.clientY;
-        nodrag_default(event.view);
-        nopropagation3(event);
+            v3 = select_default5(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
+            p = pointer_default2(event, currentTarget),
+            x011 = event.clientX,
+            y011 = event.clientY;
+        nodrag_default2(event.view);
+        nopropagation6(event);
         g.mouse = [p, this.__zoom.invert(p)];
-        interrupt_default(this);
+        interrupt_default3(this);
         g.start();
 
         function mousemoved(event2) {
-            noevent_default3(event2);
+            noevent_default6(event2);
             if (!g.moved) {
-                var dx = event2.clientX - x06,
-                    dy = event2.clientY - y06;
+                var dx = event2.clientX - x011,
+                    dy = event2.clientY - y011;
                 g.moved = dx * dx + dy * dy > clickDistance2;
             }
-            g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
+            g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default2(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
         }
 
         function mouseupped(event2) {
-            v2.on("mousemove.zoom mouseup.zoom", null);
-            yesdrag(event2.view, g.moved);
-            noevent_default3(event2);
+            v3.on("mousemove.zoom mouseup.zoom", null);
+            yesdrag2(event2.view, g.moved);
+            noevent_default6(event2);
             g.event(event2).end();
         }
     }
 
     function dblclicked(event, ...args) {
-        if (!filter4.apply(this, arguments))
+        if (!filter7.apply(this, arguments))
             return;
-        var t03 = this.__zoom,
-            p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this),
-            p1 = t03.invert(p02),
-            k1 = t03.k * (event.shiftKey ? 0.5 : 2),
-            t13 = constrain(translate(scale3(t03, k1), p02, p1), extent3.apply(this, args), translateExtent);
-        noevent_default3(event);
+        var t05 = this.__zoom,
+            p03 = pointer_default2(event.changedTouches ? event.changedTouches[0] : event, this),
+            p1 = t05.invert(p03),
+            k1 = t05.k * (event.shiftKey ? 0.5 : 2),
+            t15 = constrain(translate(scale5(t05, k1), p03, p1), extent5.apply(this, args), translateExtent);
+        noevent_default6(event);
         if (duration > 0)
-            select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);
+            select_default5(this).transition().duration(duration).call(schedule, t15, p03, event);
         else
-            select_default2(this).call(zoom.transform, t13, p02, event);
+            select_default5(this).call(zoom.transform, t15, p03, event);
     }
 
     function touchstarted(event, ...args) {
-        if (!filter4.apply(this, arguments))
+        if (!filter7.apply(this, arguments))
             return;
         var touches = event.touches,
             n = touches.length,
             g = gesture(this, args, event.changedTouches.length === n).event(event),
             started, i, t, p;
-        nopropagation3(event);
+        nopropagation6(event);
         for (i = 0; i < n; ++i) {
-            t = touches[i], p = pointer_default(t, this);
+            t = touches[i], p = pointer_default2(t, this);
             p = [p, this.__zoom.invert(p), t.identifier];
             if (!g.touch0)
                 g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
             else if (!g.touch1 && g.touch0[2] !== p[2])
                 g.touch1 = p, g.taps = 0;
         }
         if (touchstarting)
             touchstarting = clearTimeout(touchstarting);
         if (started) {
             if (g.taps < 2)
                 touchfirst = p[0], touchstarting = setTimeout(function() {
                     touchstarting = null;
                 }, touchDelay);
-            interrupt_default(this);
+            interrupt_default3(this);
             g.start();
         }
     }
 
     function touchmoved(event, ...args) {
         if (!this.__zooming)
             return;
         var g = gesture(this, args).event(event),
             touches = event.changedTouches,
             n = touches.length,
             i, t, p, l;
-        noevent_default3(event);
+        noevent_default6(event);
         for (i = 0; i < n; ++i) {
-            t = touches[i], p = pointer_default(t, this);
+            t = touches[i], p = pointer_default2(t, this);
             if (g.touch0 && g.touch0[2] === t.identifier)
                 g.touch0[0] = p;
             else if (g.touch1 && g.touch1[2] === t.identifier)
                 g.touch1[0] = p;
         }
         t = g.that.__zoom;
         if (g.touch1) {
-            var p02 = g.touch0[0],
+            var p03 = g.touch0[0],
                 l0 = g.touch0[1],
                 p1 = g.touch1[0],
                 l1 = g.touch1[1],
-                dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp,
+                dp = (dp = p1[0] - p03[0]) * dp + (dp = p1[1] - p03[1]) * dp,
                 dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
-            t = scale3(t, Math.sqrt(dp / dl));
-            p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
+            t = scale5(t, Math.sqrt(dp / dl));
+            p = [(p03[0] + p1[0]) / 2, (p03[1] + p1[1]) / 2];
             l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
         } else if (g.touch0)
             p = g.touch0[0], l = g.touch0[1];
         else
             return;
         g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
     }
@@ -21472,15 +56178,15 @@
     function touchended(event, ...args) {
         if (!this.__zooming)
             return;
         var g = gesture(this, args).event(event),
             touches = event.changedTouches,
             n = touches.length,
             i, t;
-        nopropagation3(event);
+        nopropagation6(event);
         if (touchending)
             clearTimeout(touchending);
         touchending = setTimeout(function() {
             touchending = null;
         }, touchDelay);
         for (i = 0; i < n; ++i) {
             t = touches[i];
@@ -21492,37 +56198,37 @@
         if (g.touch1 && !g.touch0)
             g.touch0 = g.touch1, delete g.touch1;
         if (g.touch0)
             g.touch0[1] = this.__zoom.invert(g.touch0[0]);
         else {
             g.end();
             if (g.taps === 2) {
-                t = pointer_default(t, this);
+                t = pointer_default2(t, this);
                 if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
-                    var p = select_default2(this).on("dblclick.zoom");
+                    var p = select_default5(this).on("dblclick.zoom");
                     if (p)
                         p.apply(this, arguments);
                 }
             }
         }
     }
     zoom.wheelDelta = function(_) {
-        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default11(+_), zoom) : wheelDelta;
+        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default22(+_), zoom) : wheelDelta;
     };
     zoom.filter = function(_) {
-        return arguments.length ? (filter4 = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : filter4;
+        return arguments.length ? (filter7 = typeof _ === "function" ? _ : constant_default22(!!_), zoom) : filter7;
     };
     zoom.touchable = function(_) {
-        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : touchable;
+        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default22(!!_), zoom) : touchable;
     };
     zoom.extent = function(_) {
-        return arguments.length ? (extent3 = typeof _ === "function" ? _ : constant_default11([
+        return arguments.length ? (extent5 = typeof _ === "function" ? _ : constant_default22([
             [+_[0][0], +_[0][1]],
             [+_[1][0], +_[1][1]]
-        ]), zoom) : extent3;
+        ]), zoom) : extent5;
     };
     zoom.scaleExtent = function(_) {
         return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
     };
     zoom.translateExtent = function(_) {
         return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [
             [translateExtent[0][0], translateExtent[0][1]],
@@ -21547,276 +56253,276 @@
     };
     zoom.tapDistance = function(_) {
         return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
     };
     return zoom;
 }
 
-// node_modules/@observablehq/plot/src/defined.js
-function defined(x4) {
-    return x4 != null && !Number.isNaN(x4);
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/defined.js
+function defined2(x7) {
+    return x7 != null && !Number.isNaN(x7);
 }
 
-function ascendingDefined2(a4, b) {
-    return +defined(b) - +defined(a4) || ascending(a4, b);
+function ascendingDefined4(a7, b) {
+    return +defined2(b) - +defined2(a7) || ascending3(a7, b);
 }
 
-function descendingDefined(a4, b) {
-    return +defined(b) - +defined(a4) || descending(a4, b);
+function descendingDefined2(a7, b) {
+    return +defined2(b) - +defined2(a7) || descending2(a7, b);
 }
 
-function nonempty(x4) {
-    return x4 != null && `${x4}` !== "";
+function nonempty2(x7) {
+    return x7 != null && `${x7}` !== "";
 }
 
-function finite2(x4) {
-    return isFinite(x4) ? x4 : NaN;
+function finite5(x7) {
+    return isFinite(x7) ? x7 : NaN;
 }
 
-function positive(x4) {
-    return x4 > 0 && isFinite(x4) ? x4 : NaN;
+function positive2(x7) {
+    return x7 > 0 && isFinite(x7) ? x7 : NaN;
 }
 
-function negative(x4) {
-    return x4 < 0 && isFinite(x4) ? x4 : NaN;
+function negative2(x7) {
+    return x7 < 0 && isFinite(x7) ? x7 : NaN;
 }
 
-// node_modules/isoformat/src/format.js
-function format2(date2, fallback) {
-    if (!(date2 instanceof Date))
-        date2 = /* @__PURE__ */ new Date(+date2);
-    if (isNaN(date2))
-        return typeof fallback === "function" ? fallback(date2) : fallback;
-    const hours = date2.getUTCHours();
-    const minutes = date2.getUTCMinutes();
-    const seconds2 = date2.getUTCSeconds();
-    const milliseconds2 = date2.getUTCMilliseconds();
-    return `${formatYear3(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
+// js/pyobsplot-js/node_modules/isoformat/src/format.js
+function format4(date3, fallback) {
+    if (!(date3 instanceof Date))
+        date3 = /* @__PURE__ */ new Date(+date3);
+    if (isNaN(date3))
+        return typeof fallback === "function" ? fallback(date3) : fallback;
+    const hours = date3.getUTCHours();
+    const minutes = date3.getUTCMinutes();
+    const seconds3 = date3.getUTCSeconds();
+    const milliseconds3 = date3.getUTCMilliseconds();
+    return `${formatYear6(date3.getUTCFullYear(), 4)}-${pad6(date3.getUTCMonth() + 1, 2)}-${pad6(date3.getUTCDate(), 2)}${hours || minutes || seconds3 || milliseconds3 ? `T${pad6(hours, 2)}:${pad6(minutes, 2)}${seconds3 || milliseconds3 ? `:${pad6(seconds3, 2)}${milliseconds3 ? `.${pad6(milliseconds3, 3)}` : ``}` : ``}Z` : ``}`;
 }
 
-function formatYear3(year) {
-    return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);
+function formatYear6(year) {
+    return year < 0 ? `-${pad6(-year, 6)}` : year > 9999 ? `+${pad6(year, 6)}` : pad6(year, 4);
 }
 
-function pad3(value, width) {
+function pad6(value, width) {
     return `${value}`.padStart(width, "0");
 }
 
-// node_modules/isoformat/src/parse.js
-var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
-
-function parse(string2, fallback) {
-    if (!re2.test(string2 += ""))
-        return typeof fallback === "function" ? fallback(string2) : fallback;
-    return new Date(string2);
-}
+// js/pyobsplot-js/node_modules/isoformat/src/parse.js
+var re4 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
 
-// node_modules/@observablehq/plot/src/time.js
-var timeIntervals = /* @__PURE__ */ new Map([
-    ["second", second],
-    ["minute", timeMinute],
-    ["hour", timeHour],
-    ["day", timeDay],
-    ["week", timeSunday],
-    ["month", timeMonth],
-    ["quarter", timeMonth.every(3)],
-    ["half", timeMonth.every(6)],
-    ["year", timeYear],
-    ["monday", timeMonday],
-    ["tuesday", timeTuesday],
-    ["wednesday", timeWednesday],
-    ["thursday", timeThursday],
-    ["friday", timeFriday],
-    ["saturday", timeSaturday],
-    ["sunday", timeSunday]
+function parse2(string3, fallback) {
+    if (!re4.test(string3 += ""))
+        return typeof fallback === "function" ? fallback(string3) : fallback;
+    return new Date(string3);
+}
+
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/time.js
+var timeIntervals2 = /* @__PURE__ */ new Map([
+    ["second", second3],
+    ["minute", timeMinute2],
+    ["hour", timeHour2],
+    ["day", timeDay2],
+    ["week", timeSunday2],
+    ["month", timeMonth2],
+    ["quarter", timeMonth2.every(3)],
+    ["half", timeMonth2.every(6)],
+    ["year", timeYear2],
+    ["monday", timeMonday2],
+    ["tuesday", timeTuesday2],
+    ["wednesday", timeWednesday2],
+    ["thursday", timeThursday2],
+    ["friday", timeFriday2],
+    ["saturday", timeSaturday2],
+    ["sunday", timeSunday2]
 ]);
-var utcIntervals = /* @__PURE__ */ new Map([
-    ["second", second],
-    ["minute", utcMinute],
-    ["hour", utcHour],
-    ["day", utcDay],
-    ["week", utcSunday],
-    ["month", utcMonth],
-    ["quarter", utcMonth.every(3)],
-    ["half", utcMonth.every(6)],
-    ["year", utcYear],
-    ["monday", utcMonday],
-    ["tuesday", utcTuesday],
-    ["wednesday", utcWednesday],
-    ["thursday", utcThursday],
-    ["friday", utcFriday],
-    ["saturday", utcSaturday],
-    ["sunday", utcSunday]
+var utcIntervals2 = /* @__PURE__ */ new Map([
+    ["second", second3],
+    ["minute", utcMinute2],
+    ["hour", utcHour2],
+    ["day", utcDay2],
+    ["week", utcSunday2],
+    ["month", utcMonth2],
+    ["quarter", utcMonth2.every(3)],
+    ["half", utcMonth2.every(6)],
+    ["year", utcYear2],
+    ["monday", utcMonday2],
+    ["tuesday", utcTuesday2],
+    ["wednesday", utcWednesday2],
+    ["thursday", utcThursday2],
+    ["friday", utcFriday2],
+    ["saturday", utcSaturday2],
+    ["sunday", utcSunday2]
 ]);
 
-function maybeTimeInterval(interval2) {
-    const i = timeIntervals.get(`${interval2}`.toLowerCase());
+function maybeTimeInterval2(interval3) {
+    const i = timeIntervals2.get(`${interval3}`.toLowerCase());
     if (!i)
-        throw new Error(`unknown interval: ${interval2}`);
+        throw new Error(`unknown interval: ${interval3}`);
     return i;
 }
 
-function maybeUtcInterval(interval2) {
-    const i = utcIntervals.get(`${interval2}`.toLowerCase());
+function maybeUtcInterval2(interval3) {
+    const i = utcIntervals2.get(`${interval3}`.toLowerCase());
     if (!i)
-        throw new Error(`unknown interval: ${interval2}`);
+        throw new Error(`unknown interval: ${interval3}`);
     return i;
 }
 
-// node_modules/@observablehq/plot/src/options.js
-var TypedArray = Object.getPrototypeOf(Uint8Array);
-var objectToString = Object.prototype.toString;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/options.js
+var TypedArray2 = Object.getPrototypeOf(Uint8Array);
+var objectToString2 = Object.prototype.toString;
 
-function valueof(data, value, type2) {
+function valueof2(data, value, type3) {
     const valueType = typeof value;
-    return valueType === "string" ? maybeTypedMap(data, field(value), type2) : valueType === "function" ? maybeTypedMap(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map4(data, constant2(value), type2) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type2) : maybeTypedArrayify(value, type2);
+    return valueType === "string" ? maybeTypedMap2(data, field2(value), type3) : valueType === "function" ? maybeTypedMap2(data, value, type3) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map9(data, constant4(value), type3) : typeof value?.transform === "function" ? maybeTypedArrayify2(value.transform(data), type3) : maybeTypedArrayify2(value, type3);
 }
 
-function maybeTypedMap(data, f, type2) {
-    return map4(data, type2?.prototype instanceof TypedArray ? floater(f) : f, type2);
+function maybeTypedMap2(data, f, type3) {
+    return map9(data, type3?.prototype instanceof TypedArray2 ? floater2(f) : f, type3);
 }
 
-function maybeTypedArrayify(data, type2) {
-    return type2 === void 0 ? arrayify2(data) : data instanceof type2 ? data : type2.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type2.from(data, coerceNumber) : type2.from(data);
+function maybeTypedArrayify2(data, type3) {
+    return type3 === void 0 ? arrayify4(data) : data instanceof type3 ? data : type3.prototype instanceof TypedArray2 && !(data instanceof TypedArray2) ? type3.from(data, coerceNumber2) : type3.from(data);
 }
 
-function floater(f) {
-    return (d, i) => coerceNumber(f(d, i));
+function floater2(f) {
+    return (d, i) => coerceNumber2(f(d, i));
 }
-var field = (name) => (d) => d[name];
-var indexOf = (d, i) => i;
-var identity6 = {
+var field2 = (name) => (d) => d[name];
+var indexOf2 = (d, i) => i;
+var identity13 = {
     transform: (d) => d
 };
-var one2 = () => 1;
-var yes = () => true;
-var string = (x4) => x4 == null ? x4 : `${x4}`;
-var number5 = (x4) => x4 == null ? x4 : +x4;
-var first = (x4) => x4 ? x4[0] : void 0;
-var second2 = (x4) => x4 ? x4[1] : void 0;
-var third = (x4) => x4 ? x4[2] : void 0;
-var constant2 = (x4) => () => x4;
+var one4 = () => 1;
+var yes2 = () => true;
+var string2 = (x7) => x7 == null ? x7 : `${x7}`;
+var number11 = (x7) => x7 == null ? x7 : +x7;
+var first2 = (x7) => x7 ? x7[0] : void 0;
+var second4 = (x7) => x7 ? x7[1] : void 0;
+var third2 = (x7) => x7 ? x7[2] : void 0;
+var constant4 = (x7) => () => x7;
 
-function percentile(reduce2) {
-    const p = +`${reduce2}`.slice(1) / 100;
-    return (I, f) => quantile(I, p, f);
+function percentile2(reduce3) {
+    const p = +`${reduce3}`.slice(1) / 100;
+    return (I, f) => quantile3(I, p, f);
 }
 
-function coerceNumbers(values2) {
-    return values2 instanceof TypedArray ? values2 : map4(values2, coerceNumber, Float64Array);
+function coerceNumbers2(values3) {
+    return values3 instanceof TypedArray2 ? values3 : map9(values3, coerceNumber2, Float64Array);
 }
 
-function coerceNumber(x4) {
-    return x4 == null ? NaN : Number(x4);
+function coerceNumber2(x7) {
+    return x7 == null ? NaN : Number(x7);
 }
 
-function coerceDates(values2) {
-    return map4(values2, coerceDate);
+function coerceDates2(values3) {
+    return map9(values3, coerceDate2);
 }
 
-function coerceDate(x4) {
-    return x4 instanceof Date && !isNaN(x4) ? x4 : typeof x4 === "string" ? parse(x4) : x4 == null || isNaN(x4 = +x4) ? void 0 : new Date(x4);
+function coerceDate2(x7) {
+    return x7 instanceof Date && !isNaN(x7) ? x7 : typeof x7 === "string" ? parse2(x7) : x7 == null || isNaN(x7 = +x7) ? void 0 : new Date(x7);
 }
 
-function maybeColorChannel(value, defaultValue) {
+function maybeColorChannel2(value, defaultValue) {
     if (value === void 0)
         value = defaultValue;
-    return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
+    return value === null ? [void 0, "none"] : isColor2(value) ? [void 0, value] : [value, void 0];
 }
 
-function maybeNumberChannel(value, defaultValue) {
+function maybeNumberChannel2(value, defaultValue) {
     if (value === void 0)
         value = defaultValue;
     return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
 }
 
-function maybeKeyword(input, name, allowed) {
+function maybeKeyword2(input, name, allowed) {
     if (input != null)
-        return keyword(input, name, allowed);
+        return keyword2(input, name, allowed);
 }
 
-function keyword(input, name, allowed) {
+function keyword2(input, name, allowed) {
     const i = `${input}`.toLowerCase();
     if (!allowed.includes(i))
         throw new Error(`invalid ${name}: ${input}`);
     return i;
 }
 
-function arrayify2(data) {
-    return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
+function arrayify4(data) {
+    return data == null || data instanceof Array || data instanceof TypedArray2 ? data : Array.from(data);
 }
 
-function map4(values2, f, type2 = Array) {
-    return values2 == null ? values2 : values2 instanceof type2 ? values2.map(f) : type2.from(values2, f);
+function map9(values3, f, type3 = Array) {
+    return values3 == null ? values3 : values3 instanceof type3 ? values3.map(f) : type3.from(values3, f);
 }
 
-function slice5(values2, type2 = Array) {
-    return values2 instanceof type2 ? values2.slice() : type2.from(values2);
+function slice11(values3, type3 = Array) {
+    return values3 instanceof type3 ? values3.slice() : type3.from(values3);
 }
 
-function isObject(option) {
-    return option?.toString === objectToString;
+function isObject2(option) {
+    return option?.toString === objectToString2;
 }
 
-function isScaleOptions(option) {
-    return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
+function isScaleOptions2(option) {
+    return isObject2(option) && (option.type !== void 0 || option.domain !== void 0);
 }
 
-function isOptions(option) {
-    return isObject(option) && typeof option.transform !== "function";
+function isOptions2(option) {
+    return isObject2(option) && typeof option.transform !== "function";
 }
 
-function isDomainSort(sort3) {
-    return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
+function isDomainSort2(sort5) {
+    return isOptions2(sort5) && sort5.value === void 0 && sort5.channel === void 0;
 }
 
-function maybeZero(x4, x12, x22, x32 = identity6) {
-    if (x12 === void 0 && x22 === void 0) {
-        x12 = 0, x22 = x4 === void 0 ? x32 : x4;
-    } else if (x12 === void 0) {
-        x12 = x4 === void 0 ? 0 : x4;
+function maybeZero2(x7, x13, x22, x32 = identity13) {
+    if (x13 === void 0 && x22 === void 0) {
+        x13 = 0, x22 = x7 === void 0 ? x32 : x7;
+    } else if (x13 === void 0) {
+        x13 = x7 === void 0 ? 0 : x7;
     } else if (x22 === void 0) {
-        x22 = x4 === void 0 ? 0 : x4;
+        x22 = x7 === void 0 ? 0 : x7;
     }
-    return [x12, x22];
+    return [x13, x22];
 }
 
-function maybeTuple(x4, y4) {
-    return x4 === void 0 && y4 === void 0 ? [first, second2] : [x4, y4];
+function maybeTuple2(x7, y7) {
+    return x7 === void 0 && y7 === void 0 ? [first2, second4] : [x7, y7];
 }
 
-function maybeZ({
+function maybeZ2({
     z,
     fill,
     stroke
 } = {}) {
     if (z === void 0)
-        [z] = maybeColorChannel(fill);
+        [z] = maybeColorChannel2(fill);
     if (z === void 0)
-        [z] = maybeColorChannel(stroke);
+        [z] = maybeColorChannel2(stroke);
     return z;
 }
 
-function range4(data) {
+function range8(data) {
     const n = data.length;
     const r = new Uint32Array(n);
     for (let i = 0; i < n; ++i)
         r[i] = i;
     return r;
 }
 
-function take(values2, index3) {
-    return map4(index3, (i) => values2[i]);
+function take2(values3, index5) {
+    return map9(index5, (i) => values3[i]);
 }
 
-function keyof2(value) {
+function keyof4(value) {
     return value !== null && typeof value === "object" ? value.valueOf() : value;
 }
 
-function maybeInput(key, options) {
+function maybeInput2(key, options) {
     if (options[key] !== void 0)
         return options[key];
     switch (key) {
         case "x1":
         case "x2":
             key = "x";
             break;
@@ -21824,237 +56530,237 @@
         case "y2":
             key = "y";
             break;
     }
     return options[key];
 }
 
-function column(source) {
+function column2(source) {
     let value;
     return [{
             transform: () => value,
-            label: labelof(source)
+            label: labelof2(source)
         },
-        (v2) => value = v2
+        (v3) => value = v3
     ];
 }
 
-function maybeColumn(source) {
-    return source == null ? [source] : column(source);
+function maybeColumn2(source) {
+    return source == null ? [source] : column2(source);
 }
 
-function labelof(value, defaultValue) {
+function labelof2(value, defaultValue) {
     return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
 }
 
-function mid(x12, x22) {
+function mid2(x13, x22) {
     return {
         transform(data) {
-            const X13 = x12.transform(data);
-            const X23 = x22.transform(data);
-            return isTemporal(X13) || isTemporal(X23) ? map4(X13, (_, i) => new Date((+X13[i] + +X23[i]) / 2)) : map4(X13, (_, i) => (+X13[i] + +X23[i]) / 2, Float64Array);
+            const X15 = x13.transform(data);
+            const X25 = x22.transform(data);
+            return isTemporal2(X15) || isTemporal2(X25) ? map9(X15, (_, i) => new Date((+X15[i] + +X25[i]) / 2)) : map9(X15, (_, i) => (+X15[i] + +X25[i]) / 2, Float64Array);
         },
-        label: x12.label
+        label: x13.label
     };
 }
 
-function maybeInterval(interval2, type2) {
-    if (interval2 == null)
+function maybeInterval2(interval3, type3) {
+    if (interval3 == null)
         return;
-    if (typeof interval2 === "number") {
-        const n = interval2;
+    if (typeof interval3 === "number") {
+        const n = interval3;
         return {
             floor: (d) => n * Math.floor(d / n),
             offset: (d) => d + n,
             // note: no optional step for simplicity
-            range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x4) => n * x4)
+            range: (lo, hi) => range5(Math.ceil(lo / n), hi / n).map((x7) => n * x7)
         };
     }
-    if (typeof interval2 === "string")
-        return (type2 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
-    if (typeof interval2.floor !== "function")
+    if (typeof interval3 === "string")
+        return (type3 === "time" ? maybeTimeInterval2 : maybeUtcInterval2)(interval3);
+    if (typeof interval3.floor !== "function")
         throw new Error("invalid interval; missing floor method");
-    if (typeof interval2.offset !== "function")
+    if (typeof interval3.offset !== "function")
         throw new Error("invalid interval; missing offset method");
-    return interval2;
+    return interval3;
 }
 
-function maybeRangeInterval(interval2, type2) {
-    interval2 = maybeInterval(interval2, type2);
-    if (interval2 && typeof interval2.range !== "function")
+function maybeRangeInterval2(interval3, type3) {
+    interval3 = maybeInterval2(interval3, type3);
+    if (interval3 && typeof interval3.range !== "function")
         throw new Error("invalid interval: missing range method");
-    return interval2;
+    return interval3;
 }
 
-function maybeNiceInterval(interval2, type2) {
-    interval2 = maybeRangeInterval(interval2, type2);
-    if (interval2 && typeof interval2.ceil !== "function")
+function maybeNiceInterval2(interval3, type3) {
+    interval3 = maybeRangeInterval2(interval3, type3);
+    if (interval3 && typeof interval3.ceil !== "function")
         throw new Error("invalid interval: missing ceil method");
-    return interval2;
+    return interval3;
 }
 
-function maybeValue(value) {
-    return value === void 0 || isOptions(value) ? value : {
+function maybeValue2(value) {
+    return value === void 0 || isOptions2(value) ? value : {
         value
     };
 }
 
-function numberChannel(source) {
+function numberChannel2(source) {
     return source == null ? null : {
-        transform: (data) => valueof(data, source, Float64Array),
-        label: labelof(source)
+        transform: (data) => valueof2(data, source, Float64Array),
+        label: labelof2(source)
     };
 }
 
-function isTuples(data) {
-    if (!isIterable(data))
+function isTuples2(data) {
+    if (!isIterable2(data))
         return false;
     for (const d of data) {
         if (d == null)
             continue;
         return typeof d === "object" && "0" in d && "1" in d;
     }
 }
 
-function isIterable(value) {
+function isIterable2(value) {
     return value && typeof value[Symbol.iterator] === "function";
 }
 
-function isTextual(values2) {
-    for (const value of values2) {
+function isTextual2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
         return typeof value !== "object" || value instanceof Date;
     }
 }
 
-function isOrdinal(values2) {
-    for (const value of values2) {
+function isOrdinal2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
-        const type2 = typeof value;
-        return type2 === "string" || type2 === "boolean";
+        const type3 = typeof value;
+        return type3 === "string" || type3 === "boolean";
     }
 }
 
-function isTemporal(values2) {
-    for (const value of values2) {
+function isTemporal2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
         return value instanceof Date;
     }
 }
 
-function isTemporalString(values2) {
-    for (const value of values2) {
+function isTemporalString2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
-        return typeof value === "string" && isNaN(value) && parse(value);
+        return typeof value === "string" && isNaN(value) && parse2(value);
     }
 }
 
-function isNumericString(values2) {
-    for (const value of values2) {
+function isNumericString2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
         if (typeof value !== "string")
             return false;
         if (!value.trim())
             continue;
         return !isNaN(value);
     }
 }
 
-function isNumeric(values2) {
-    for (const value of values2) {
+function isNumeric2(values3) {
+    for (const value of values3) {
         if (value == null)
             continue;
         return typeof value === "number";
     }
 }
 
-function isEvery(values2, is) {
-    let every2;
-    for (const value of values2) {
+function isEvery2(values3, is) {
+    let every3;
+    for (const value of values3) {
         if (value == null)
             continue;
         if (!is(value))
             return false;
-        every2 = true;
+        every3 = true;
     }
-    return every2;
+    return every3;
 }
 
-function isColor(value) {
+function isColor2(value) {
     if (typeof value !== "string")
         return false;
     value = value.toLowerCase().trim();
     return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || // <funciri>, e.g. pattern or gradient
         value.startsWith("var(") && value.endsWith(")") || // CSS variable
-        color(value) !== null;
+        color3(value) !== null;
 }
 
-function isOpacity(value) {
+function isOpacity2(value) {
     return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
 }
 
-function isNoneish(value) {
-    return value == null || isNone(value);
+function isNoneish2(value) {
+    return value == null || isNone2(value);
 }
 
-function isNone(value) {
+function isNone2(value) {
     return /^\s*none\s*$/i.test(value);
 }
 
-function isRound(value) {
+function isRound2(value) {
     return /^\s*round\s*$/i.test(value);
 }
 
-function maybeFrameAnchor(value = "middle") {
-    return keyword(value, "frameAnchor", [
+function maybeFrameAnchor2(value = "middle") {
+    return keyword2(value, "frameAnchor", [
         "middle",
         "top-left",
         "top",
         "top-right",
         "right",
         "bottom-right",
         "bottom",
         "bottom-left",
         "left"
     ]);
 }
 
-function orderof(values2) {
-    if (values2 == null)
+function orderof2(values3) {
+    if (values3 == null)
         return;
-    const first2 = values2[0];
-    const last = values2[values2.length - 1];
-    return descending(first2, last);
+    const first3 = values3[0];
+    const last = values3[values3.length - 1];
+    return descending2(first3, last);
 }
 
-function inherit2(options = {}, ...rest) {
+function inherit4(options = {}, ...rest) {
     let o = options;
-    for (const defaults21 of rest) {
-        for (const key in defaults21) {
+    for (const defaults41 of rest) {
+        for (const key in defaults41) {
             if (o[key] === void 0) {
-                const value = defaults21[key];
+                const value = defaults41[key];
                 if (o === options)
                     o = {
                         ...o,
                         [key]: value
                     };
                 else
                     o[key] = value;
             }
         }
     }
     return o;
 }
 
-function named2(things) {
+function named4(things) {
     console.warn("named iterables are deprecated; please use an object instead");
     const names = /* @__PURE__ */ new Set();
     return Object.fromEntries(
         Array.from(things, (thing) => {
             const {
                 name
             } = thing;
@@ -22067,170 +56773,170 @@
                 throw new Error(`duplicate name: ${key}`);
             names.add(key);
             return [name, thing];
         })
     );
 }
 
-function maybeNamed(things) {
-    return isIterable(things) ? named2(things) : things;
+function maybeNamed2(things) {
+    return isIterable2(things) ? named4(things) : things;
 }
 
-// node_modules/@observablehq/plot/src/scales/index.js
-var position = Symbol("position");
-var color2 = Symbol("color");
-var radius = Symbol("radius");
-var length3 = Symbol("length");
-var opacity = Symbol("opacity");
-var symbol = Symbol("symbol");
-var registry = /* @__PURE__ */ new Map([
-    ["x", position],
-    ["y", position],
-    ["fx", position],
-    ["fy", position],
-    ["r", radius],
-    ["color", color2],
-    ["opacity", opacity],
-    ["symbol", symbol],
-    ["length", length3]
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/index.js
+var position2 = Symbol("position");
+var color4 = Symbol("color");
+var radius2 = Symbol("radius");
+var length6 = Symbol("length");
+var opacity2 = Symbol("opacity");
+var symbol2 = Symbol("symbol");
+var registry2 = /* @__PURE__ */ new Map([
+    ["x", position2],
+    ["y", position2],
+    ["fx", position2],
+    ["fy", position2],
+    ["r", radius2],
+    ["color", color4],
+    ["opacity", opacity2],
+    ["symbol", symbol2],
+    ["length", length6]
 ]);
 
-// node_modules/@observablehq/plot/src/symbol.js
-var sqrt35 = Math.sqrt(3);
-var sqrt4_3 = 2 / sqrt35;
-var symbolHexagon = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/symbol.js
+var sqrt39 = Math.sqrt(3);
+var sqrt4_32 = 2 / sqrt39;
+var symbolHexagon2 = {
     draw(context, size) {
         const rx = Math.sqrt(size / Math.PI),
-            ry = rx * sqrt4_3,
+            ry = rx * sqrt4_32,
             hy = ry / 2;
         context.moveTo(0, ry);
         context.lineTo(rx, hy);
         context.lineTo(rx, -hy);
         context.lineTo(0, -ry);
         context.lineTo(-rx, -hy);
         context.lineTo(-rx, hy);
         context.closePath();
     }
 };
-var symbols = /* @__PURE__ */ new Map([
-    ["asterisk", asterisk_default],
-    ["circle", circle_default3],
-    ["cross", cross_default2],
-    ["diamond", diamond_default],
-    ["diamond2", diamond2_default],
-    ["hexagon", symbolHexagon],
-    ["plus", plus_default],
-    ["square", square_default],
-    ["square2", square2_default],
-    ["star", star_default],
-    ["times", times_default],
-    ["triangle", triangle_default],
-    ["triangle2", triangle2_default],
-    ["wye", wye_default]
+var symbols2 = /* @__PURE__ */ new Map([
+    ["asterisk", asterisk_default2],
+    ["circle", circle_default6],
+    ["cross", cross_default4],
+    ["diamond", diamond_default2],
+    ["diamond2", diamond2_default2],
+    ["hexagon", symbolHexagon2],
+    ["plus", plus_default2],
+    ["square", square_default2],
+    ["square2", square2_default2],
+    ["star", star_default2],
+    ["times", times_default2],
+    ["triangle", triangle_default2],
+    ["triangle2", triangle2_default2],
+    ["wye", wye_default2]
 ]);
 
-function isSymbolObject(value) {
+function isSymbolObject2(value) {
     return value && typeof value.draw === "function";
 }
 
-function isSymbol(value) {
-    if (isSymbolObject(value))
+function isSymbol2(value) {
+    if (isSymbolObject2(value))
         return true;
     if (typeof value !== "string")
         return false;
-    return symbols.has(value.toLowerCase());
+    return symbols2.has(value.toLowerCase());
 }
 
-function maybeSymbol(symbol2) {
-    if (symbol2 == null || isSymbolObject(symbol2))
-        return symbol2;
-    const value = symbols.get(`${symbol2}`.toLowerCase());
+function maybeSymbol2(symbol3) {
+    if (symbol3 == null || isSymbolObject2(symbol3))
+        return symbol3;
+    const value = symbols2.get(`${symbol3}`.toLowerCase());
     if (value)
         return value;
-    throw new Error(`invalid symbol: ${symbol2}`);
+    throw new Error(`invalid symbol: ${symbol3}`);
 }
 
-function maybeSymbolChannel(symbol2) {
-    if (symbol2 == null || isSymbolObject(symbol2))
-        return [void 0, symbol2];
-    if (typeof symbol2 === "string") {
-        const value = symbols.get(`${symbol2}`.toLowerCase());
+function maybeSymbolChannel2(symbol3) {
+    if (symbol3 == null || isSymbolObject2(symbol3))
+        return [void 0, symbol3];
+    if (typeof symbol3 === "string") {
+        const value = symbols2.get(`${symbol3}`.toLowerCase());
         if (value)
             return [void 0, value];
     }
-    return [symbol2, void 0];
+    return [symbol3, void 0];
 }
 
-// node_modules/@observablehq/plot/src/transforms/basic.js
-function basic({
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/basic.js
+function basic2({
     filter: f1,
     sort: s1,
     reverse: r1,
-    transform: t13,
+    transform: t15,
     initializer: i1,
     ...options
-} = {}, transform2) {
-    if (t13 === void 0) {
+} = {}, transform3) {
+    if (t15 === void 0) {
         if (f1 != null)
-            t13 = filterTransform(f1);
-        if (s1 != null && !isDomainSort(s1))
-            t13 = composeTransform(t13, sortTransform(s1));
+            t15 = filterTransform2(f1);
+        if (s1 != null && !isDomainSort2(s1))
+            t15 = composeTransform2(t15, sortTransform2(s1));
         if (r1)
-            t13 = composeTransform(t13, reverseTransform);
+            t15 = composeTransform2(t15, reverseTransform2);
     }
-    if (transform2 != null && i1 != null)
+    if (transform3 != null && i1 != null)
         throw new Error("transforms cannot be applied after initializers");
     return {
         ...options,
-        ...(s1 === null || isDomainSort(s1)) && {
+        ...(s1 === null || isDomainSort2(s1)) && {
             sort: s1
         },
-        transform: composeTransform(t13, transform2)
+        transform: composeTransform2(t15, transform3)
     };
 }
 
-function initializer({
+function initializer2({
     filter: f1,
     sort: s1,
     reverse: r1,
     initializer: i1,
     ...options
-} = {}, initializer2) {
+} = {}, initializer3) {
     if (i1 === void 0) {
         if (f1 != null)
-            i1 = filterTransform(f1);
-        if (s1 != null && !isDomainSort(s1))
-            i1 = composeInitializer(i1, sortTransform(s1));
+            i1 = filterTransform2(f1);
+        if (s1 != null && !isDomainSort2(s1))
+            i1 = composeInitializer2(i1, sortTransform2(s1));
         if (r1)
-            i1 = composeInitializer(i1, reverseTransform);
+            i1 = composeInitializer2(i1, reverseTransform2);
     }
     return {
         ...options,
-        ...(s1 === null || isDomainSort(s1)) && {
+        ...(s1 === null || isDomainSort2(s1)) && {
             sort: s1
         },
-        initializer: composeInitializer(i1, initializer2)
+        initializer: composeInitializer2(i1, initializer3)
     };
 }
 
-function composeTransform(t13, t22) {
-    if (t13 == null)
-        return t22 === null ? void 0 : t22;
-    if (t22 == null)
-        return t13 === null ? void 0 : t13;
+function composeTransform2(t15, t23) {
+    if (t15 == null)
+        return t23 === null ? void 0 : t23;
+    if (t23 == null)
+        return t15 === null ? void 0 : t15;
     return function(data, facets) {
         ({
             data,
             facets
-        } = t13.call(this, data, facets));
-        return t22.call(this, arrayify2(data), facets);
+        } = t15.call(this, data, facets));
+        return t23.call(this, arrayify4(data), facets);
     };
 }
 
-function composeInitializer(i1, i2) {
+function composeInitializer2(i1, i2) {
     if (i1 == null)
         return i2 === null ? void 0 : i2;
     if (i2 == null)
         return i1 === null ? void 0 : i1;
     return function(data, facets, channels, ...args) {
         let c1, d1, f1, c22, d2, f2;
         ({
@@ -22253,1843 +56959,1843 @@
                 ...c1,
                 ...c22
             }
         };
     };
 }
 
-function apply(options, t) {
-    return (options.initializer != null ? initializer : basic)(options, t);
+function apply2(options, t) {
+    return (options.initializer != null ? initializer2 : basic2)(options, t);
 }
 
-function filter3(test, options) {
-    return apply(options, filterTransform(test));
+function filter6(test, options) {
+    return apply2(options, filterTransform2(test));
 }
 
-function filterTransform(value) {
+function filterTransform2(value) {
     return (data, facets) => {
-        const V = valueof(data, value);
+        const V = valueof2(data, value);
         return {
             data,
             facets: facets.map((I) => I.filter((i) => V[i]))
         };
     };
 }
 
-function reverse2({
-    sort: sort3,
+function reverse4({
+    sort: sort5,
     ...options
 } = {}) {
     return {
-        ...apply(options, reverseTransform),
-        sort: isDomainSort(sort3) ? sort3 : null
+        ...apply2(options, reverseTransform2),
+        sort: isDomainSort2(sort5) ? sort5 : null
     };
 }
 
-function reverseTransform(data, facets) {
+function reverseTransform2(data, facets) {
     return {
         data,
         facets: facets.map((I) => I.slice().reverse())
     };
 }
 
-function shuffle2({
+function shuffle4({
     seed,
-    sort: sort3,
+    sort: sort5,
     ...options
 } = {}) {
     return {
-        ...apply(options, sortValue(seed == null ? Math.random : lcg(seed))),
-        sort: isDomainSort(sort3) ? sort3 : null
+        ...apply2(options, sortValue2(seed == null ? Math.random : lcg2(seed))),
+        sort: isDomainSort2(sort5) ? sort5 : null
     };
 }
 
-function sort2(order, {
-    sort: sort3,
+function sort4(order, {
+    sort: sort5,
     ...options
 } = {}) {
     return {
-        ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
-        sort: isDomainSort(sort3) ? sort3 : null
+        ...(isOptions2(order) && order.channel !== void 0 ? initializer2 : apply2)(options, sortTransform2(order)),
+        sort: isDomainSort2(sort5) ? sort5 : null
     };
 }
 
-function sortTransform(value) {
-    return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
+function sortTransform2(value) {
+    return (typeof value === "function" && value.length !== 1 ? sortData2 : sortValue2)(value);
 }
 
-function sortData(compare) {
+function sortData2(compare) {
     return (data, facets) => {
         const compareData = (i, j) => compare(data[i], data[j]);
         return {
             data,
             facets: facets.map((I) => I.slice().sort(compareData))
         };
     };
 }
 
-function sortValue(value) {
+function sortValue2(value) {
     let channel, order;
     ({
         channel,
         value,
-        order = ascendingDefined2
+        order = ascendingDefined4
     } = {
-        ...maybeValue(value)
+        ...maybeValue2(value)
     });
     if (typeof order !== "function") {
         switch (`${order}`.toLowerCase()) {
             case "ascending":
-                order = ascendingDefined2;
+                order = ascendingDefined4;
                 break;
             case "descending":
-                order = descendingDefined;
+                order = descendingDefined2;
                 break;
             default:
                 throw new Error(`invalid order: ${order}`);
         }
     }
     return (data, facets, channels) => {
         let V;
         if (channel === void 0) {
-            V = valueof(data, value);
+            V = valueof2(data, value);
         } else {
             if (channels === void 0)
                 throw new Error("channel sort requires an initializer");
             V = channels[channel];
             if (!V)
                 return {};
             V = V.value;
         }
-        const compareValue2 = (i, j) => order(V[i], V[j]);
+        const compareValue3 = (i, j) => order(V[i], V[j]);
         return {
             data,
-            facets: facets.map((I) => I.slice().sort(compareValue2))
+            facets: facets.map((I) => I.slice().sort(compareValue3))
         };
     };
 }
 
-// node_modules/@observablehq/plot/src/transforms/group.js
-function groupZ(outputs, options) {
-    return groupn(null, null, outputs, options);
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/group.js
+function groupZ3(outputs, options) {
+    return groupn2(null, null, outputs, options);
 }
 
-function groupX(outputs = {
+function groupX2(outputs = {
     y: "count"
 }, options = {}) {
     const {
-        x: x4 = identity6
+        x: x7 = identity13
     } = options;
-    if (x4 == null)
+    if (x7 == null)
         throw new Error("missing channel: x");
-    return groupn(x4, null, outputs, options);
+    return groupn2(x7, null, outputs, options);
 }
 
-function groupY(outputs = {
+function groupY2(outputs = {
     x: "count"
 }, options = {}) {
     const {
-        y: y4 = identity6
+        y: y7 = identity13
     } = options;
-    if (y4 == null)
+    if (y7 == null)
         throw new Error("missing channel: y");
-    return groupn(null, y4, outputs, options);
+    return groupn2(null, y7, outputs, options);
 }
 
-function group2(outputs = {
+function group4(outputs = {
     fill: "count"
 }, options = {}) {
     let {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = options;
-    [x4, y4] = maybeTuple(x4, y4);
-    if (x4 == null)
+    [x7, y7] = maybeTuple2(x7, y7);
+    if (x7 == null)
         throw new Error("missing channel: x");
-    if (y4 == null)
+    if (y7 == null)
         throw new Error("missing channel: y");
-    return groupn(x4, y4, outputs, options);
+    return groupn2(x7, y7, outputs, options);
 }
 
-function groupn(x4, y4, {
-    data: reduceData = reduceIdentity,
-    filter: filter4,
-    sort: sort3,
-    reverse: reverse3,
+function groupn2(x7, y7, {
+    data: reduceData = reduceIdentity2,
+    filter: filter7,
+    sort: sort5,
+    reverse: reverse5,
     ...outputs
     // output channel definitions
 } = {}, inputs = {}) {
-    outputs = maybeOutputs(outputs, inputs);
-    reduceData = maybeReduce(reduceData, identity6);
-    sort3 = sort3 == null ? void 0 : maybeOutput("sort", sort3, inputs);
-    filter4 = filter4 == null ? void 0 : maybeEvaluator("filter", filter4, inputs);
-    const [GX, setGX] = maybeColumn(x4);
-    const [GY, setGY] = maybeColumn(y4);
+    outputs = maybeOutputs2(outputs, inputs);
+    reduceData = maybeReduce3(reduceData, identity13);
+    sort5 = sort5 == null ? void 0 : maybeOutput2("sort", sort5, inputs);
+    filter7 = filter7 == null ? void 0 : maybeEvaluator2("filter", filter7, inputs);
+    const [GX, setGX] = maybeColumn2(x7);
+    const [GY, setGY] = maybeColumn2(y7);
     const {
         z,
         fill,
         stroke,
-        x1: x12,
+        x1: x13,
         x2: x22,
         // consumed if x is an output
-        y1: y12,
+        y1: y13,
         y2: y22,
         // consumed if y is an output
         ...options
     } = inputs;
-    const [GZ, setGZ] = maybeColumn(z);
-    const [vfill] = maybeColorChannel(fill);
-    const [vstroke] = maybeColorChannel(stroke);
-    const [GF, setGF] = maybeColumn(vfill);
-    const [GS, setGS] = maybeColumn(vstroke);
+    const [GZ, setGZ] = maybeColumn2(z);
+    const [vfill] = maybeColorChannel2(fill);
+    const [vstroke] = maybeColorChannel2(stroke);
+    const [GF, setGF] = maybeColumn2(vfill);
+    const [GS, setGS] = maybeColumn2(vstroke);
     return {
         ..."z" in inputs && {
             z: GZ || z
         },
         ..."fill" in inputs && {
             fill: GF || fill
         },
         ..."stroke" in inputs && {
             stroke: GS || stroke
         },
-        ...basic(options, (data, facets) => {
-            const X3 = valueof(data, x4);
-            const Y3 = valueof(data, y4);
-            const Z = valueof(data, z);
-            const F = valueof(data, vfill);
-            const S = valueof(data, vstroke);
-            const G = maybeSubgroup(outputs, {
+        ...basic2(options, (data, facets) => {
+            const X4 = valueof2(data, x7);
+            const Y4 = valueof2(data, y7);
+            const Z = valueof2(data, z);
+            const F = valueof2(data, vfill);
+            const S = valueof2(data, vstroke);
+            const G = maybeSubgroup2(outputs, {
                 z: Z,
                 fill: F,
                 stroke: S
             });
             const groupFacets = [];
             const groupData = [];
-            const GX2 = X3 && setGX([]);
-            const GY2 = Y3 && setGY([]);
+            const GX2 = X4 && setGX([]);
+            const GY2 = Y4 && setGY([]);
             const GZ2 = Z && setGZ([]);
             const GF2 = F && setGF([]);
             const GS2 = S && setGS([]);
             let i = 0;
             for (const o of outputs)
                 o.initialize(data);
-            if (sort3)
-                sort3.initialize(data);
-            if (filter4)
-                filter4.initialize(data);
+            if (sort5)
+                sort5.initialize(data);
+            if (filter7)
+                filter7.initialize(data);
             for (const facet of facets) {
                 const groupFacet = [];
                 for (const o of outputs)
                     o.scope("facet", facet);
-                if (sort3)
-                    sort3.scope("facet", facet);
-                if (filter4)
-                    filter4.scope("facet", facet);
-                for (const [f, I] of maybeGroup(facet, G)) {
-                    for (const [y5, gg] of maybeGroup(I, Y3)) {
-                        for (const [x5, g] of maybeGroup(gg, X3)) {
-                            if (filter4 && !filter4.reduce(g))
+                if (sort5)
+                    sort5.scope("facet", facet);
+                if (filter7)
+                    filter7.scope("facet", facet);
+                for (const [f, I] of maybeGroup2(facet, G)) {
+                    for (const [y8, gg] of maybeGroup2(I, Y4)) {
+                        for (const [x8, g] of maybeGroup2(gg, X4)) {
+                            if (filter7 && !filter7.reduce(g))
                                 continue;
                             groupFacet.push(i++);
                             groupData.push(reduceData.reduceIndex(g, data));
-                            if (X3)
-                                GX2.push(x5);
-                            if (Y3)
-                                GY2.push(y5);
+                            if (X4)
+                                GX2.push(x8);
+                            if (Y4)
+                                GY2.push(y8);
                             if (Z)
                                 GZ2.push(G === Z ? f : Z[g[0]]);
                             if (F)
                                 GF2.push(G === F ? f : F[g[0]]);
                             if (S)
                                 GS2.push(G === S ? f : S[g[0]]);
                             for (const o of outputs)
                                 o.reduce(g);
-                            if (sort3)
-                                sort3.reduce(g);
+                            if (sort5)
+                                sort5.reduce(g);
                         }
                     }
                 }
                 groupFacets.push(groupFacet);
             }
-            maybeSort(groupFacets, sort3, reverse3);
+            maybeSort2(groupFacets, sort5, reverse5);
             return {
                 data: groupData,
                 facets: groupFacets
             };
         }),
-        ...!hasOutput(outputs, "x") && (GX ? {
+        ...!hasOutput2(outputs, "x") && (GX ? {
             x: GX
         } : {
-            x1: x12,
+            x1: x13,
             x2: x22
         }),
-        ...!hasOutput(outputs, "y") && (GY ? {
+        ...!hasOutput2(outputs, "y") && (GY ? {
             y: GY
         } : {
-            y1: y12,
+            y1: y13,
             y2: y22
         }),
         ...Object.fromEntries(outputs.map(({
             name,
             output
         }) => [name, output]))
     };
 }
 
-function hasOutput(outputs, ...names) {
+function hasOutput2(outputs, ...names) {
     for (const {
             name
         }
         of outputs) {
         if (names.includes(name)) {
             return true;
         }
     }
     return false;
 }
 
-function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
+function maybeOutputs2(outputs, inputs, asOutput = maybeOutput2) {
     const entries = Object.entries(outputs);
     if (inputs.title != null && outputs.title === void 0)
-        entries.push(["title", reduceTitle]);
+        entries.push(["title", reduceTitle2]);
     if (inputs.href != null && outputs.href === void 0)
-        entries.push(["href", reduceFirst]);
-    return entries.filter(([, reduce2]) => reduce2 !== void 0).map(([name, reduce2]) => reduce2 === null ? nullOutput(name) : asOutput(name, reduce2, inputs));
+        entries.push(["href", reduceFirst3]);
+    return entries.filter(([, reduce3]) => reduce3 !== void 0).map(([name, reduce3]) => reduce3 === null ? nullOutput2(name) : asOutput(name, reduce3, inputs));
 }
 
-function maybeOutput(name, reduce2, inputs, asEvaluator = maybeEvaluator) {
-    let scale3;
-    if (isObject(reduce2) && "reduce" in reduce2)
-        scale3 = reduce2.scale, reduce2 = reduce2.reduce;
-    const evaluator = asEvaluator(name, reduce2, inputs);
-    const [output, setOutput] = column(evaluator.label);
+function maybeOutput2(name, reduce3, inputs, asEvaluator = maybeEvaluator2) {
+    let scale5;
+    if (isObject2(reduce3) && "reduce" in reduce3)
+        scale5 = reduce3.scale, reduce3 = reduce3.reduce;
+    const evaluator = asEvaluator(name, reduce3, inputs);
+    const [output, setOutput] = column2(evaluator.label);
     let O;
     return {
         name,
-        output: scale3 === void 0 ? output : {
+        output: scale5 === void 0 ? output : {
             value: output,
-            scale: scale3
+            scale: scale5
         },
         initialize(data) {
             evaluator.initialize(data);
             O = setOutput([]);
         },
         scope(scope, I) {
             evaluator.scope(scope, I);
         },
-        reduce(I, extent3) {
-            O.push(evaluator.reduce(I, extent3));
+        reduce(I, extent5) {
+            O.push(evaluator.reduce(I, extent5));
         }
     };
 }
 
-function nullOutput(name) {
+function nullOutput2(name) {
     return {
         name,
         initialize() {},
         scope() {},
         reduce() {}
     };
 }
 
-function maybeEvaluator(name, reduce2, inputs, asReduce = maybeReduce) {
-    const input = maybeInput(name, inputs);
-    const reducer2 = asReduce(reduce2, input);
+function maybeEvaluator2(name, reduce3, inputs, asReduce = maybeReduce3) {
+    const input = maybeInput2(name, inputs);
+    const reducer3 = asReduce(reduce3, input);
     let V, context;
     return {
-        label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),
+        label: labelof2(reducer3 === reduceCount2 ? null : input, reducer3.label),
         initialize(data) {
-            V = input === void 0 ? data : valueof(data, input);
-            if (reducer2.scope === "data") {
-                context = reducer2.reduceIndex(range4(data), V);
+            V = input === void 0 ? data : valueof2(data, input);
+            if (reducer3.scope === "data") {
+                context = reducer3.reduceIndex(range8(data), V);
             }
         },
         scope(scope, I) {
-            if (reducer2.scope === scope) {
-                context = reducer2.reduceIndex(I, V);
+            if (reducer3.scope === scope) {
+                context = reducer3.reduceIndex(I, V);
             }
         },
-        reduce(I, extent3) {
-            return reducer2.scope == null ? reducer2.reduceIndex(I, V, extent3) : reducer2.reduceIndex(I, V, context, extent3);
+        reduce(I, extent5) {
+            return reducer3.scope == null ? reducer3.reduceIndex(I, V, extent5) : reducer3.reduceIndex(I, V, context, extent5);
         }
     };
 }
 
-function maybeGroup(I, X3) {
-    return X3 ? sort(
-        group(I, (i) => X3[i]),
-        first
+function maybeGroup2(I, X4) {
+    return X4 ? sort3(
+        group3(I, (i) => X4[i]),
+        first2
     ) : [
         [, I]
     ];
 }
 
-function maybeReduce(reduce2, value, fallback = invalidReduce) {
-    if (reduce2 == null)
-        return fallback(reduce2);
-    if (typeof reduce2.reduceIndex === "function")
-        return reduce2;
-    if (typeof reduce2.reduce === "function" && isObject(reduce2))
-        return reduceReduce(reduce2);
-    if (typeof reduce2 === "function")
-        return reduceFunction(reduce2);
-    if (/^p\d{2}$/i.test(reduce2))
-        return reduceAccessor(percentile(reduce2));
-    switch (`${reduce2}`.toLowerCase()) {
+function maybeReduce3(reduce3, value, fallback = invalidReduce2) {
+    if (reduce3 == null)
+        return fallback(reduce3);
+    if (typeof reduce3.reduceIndex === "function")
+        return reduce3;
+    if (typeof reduce3.reduce === "function" && isObject2(reduce3))
+        return reduceReduce2(reduce3);
+    if (typeof reduce3 === "function")
+        return reduceFunction2(reduce3);
+    if (/^p\d{2}$/i.test(reduce3))
+        return reduceAccessor2(percentile2(reduce3));
+    switch (`${reduce3}`.toLowerCase()) {
         case "first":
-            return reduceFirst;
+            return reduceFirst3;
         case "last":
-            return reduceLast;
+            return reduceLast3;
         case "identity":
-            return reduceIdentity;
+            return reduceIdentity2;
         case "count":
-            return reduceCount;
+            return reduceCount2;
         case "distinct":
-            return reduceDistinct;
+            return reduceDistinct2;
         case "sum":
-            return value == null ? reduceCount : reduceSum;
+            return value == null ? reduceCount2 : reduceSum3;
         case "proportion":
-            return reduceProportion(value, "data");
+            return reduceProportion2(value, "data");
         case "proportion-facet":
-            return reduceProportion(value, "facet");
+            return reduceProportion2(value, "facet");
         case "deviation":
-            return reduceAccessor(deviation);
+            return reduceAccessor2(deviation2);
         case "min":
-            return reduceAccessor(min);
+            return reduceAccessor2(min4);
         case "min-index":
-            return reduceAccessor(minIndex);
+            return reduceAccessor2(minIndex2);
         case "max":
-            return reduceAccessor(max);
+            return reduceAccessor2(max5);
         case "max-index":
-            return reduceAccessor(maxIndex);
+            return reduceAccessor2(maxIndex2);
         case "mean":
-            return reduceMaybeTemporalAccessor(mean);
+            return reduceMaybeTemporalAccessor2(mean2);
         case "median":
-            return reduceMaybeTemporalAccessor(median);
+            return reduceMaybeTemporalAccessor2(median2);
         case "variance":
-            return reduceAccessor(variance);
+            return reduceAccessor2(variance2);
         case "mode":
-            return reduceAccessor(mode);
+            return reduceAccessor2(mode2);
     }
-    return fallback(reduce2);
+    return fallback(reduce3);
 }
 
-function invalidReduce(reduce2) {
-    throw new Error(`invalid reduce: ${reduce2}`);
+function invalidReduce2(reduce3) {
+    throw new Error(`invalid reduce: ${reduce3}`);
 }
 
-function maybeSubgroup(outputs, inputs) {
+function maybeSubgroup2(outputs, inputs) {
     for (const name in inputs) {
         const value = inputs[name];
         if (value !== void 0 && !outputs.some((o) => o.name === name)) {
             return value;
         }
     }
 }
 
-function maybeSort(facets, sort3, reverse3) {
-    if (sort3) {
-        const S = sort3.output.transform();
-        const compare = (i, j) => ascendingDefined2(S[i], S[j]);
+function maybeSort2(facets, sort5, reverse5) {
+    if (sort5) {
+        const S = sort5.output.transform();
+        const compare = (i, j) => ascendingDefined4(S[i], S[j]);
         facets.forEach((f) => f.sort(compare));
     }
-    if (reverse3) {
+    if (reverse5) {
         facets.forEach((f) => f.reverse());
     }
 }
 
-function reduceReduce(reduce2) {
+function reduceReduce2(reduce3) {
     console.warn("deprecated reduce interface; implement reduceIndex instead.");
     return {
-        ...reduce2,
-        reduceIndex: reduce2.reduce.bind(reduce2)
+        ...reduce3,
+        reduceIndex: reduce3.reduce.bind(reduce3)
     };
 }
 
-function reduceFunction(f) {
+function reduceFunction2(f) {
     return {
-        reduceIndex(I, X3, extent3) {
-            return f(take(X3, I), extent3);
+        reduceIndex(I, X4, extent5) {
+            return f(take2(X4, I), extent5);
         }
     };
 }
 
-function reduceAccessor(f) {
+function reduceAccessor2(f) {
     return {
-        reduceIndex(I, X3) {
-            return f(I, (i) => X3[i]);
+        reduceIndex(I, X4) {
+            return f(I, (i) => X4[i]);
         }
     };
 }
 
-function reduceMaybeTemporalAccessor(f) {
+function reduceMaybeTemporalAccessor2(f) {
     return {
-        reduceIndex(I, X3) {
-            const x4 = f(I, (i) => X3[i]);
-            return isTemporal(X3) ? new Date(x4) : x4;
+        reduceIndex(I, X4) {
+            const x7 = f(I, (i) => X4[i]);
+            return isTemporal2(X4) ? new Date(x7) : x7;
         }
     };
 }
-var reduceIdentity = {
-    reduceIndex(I, X3) {
-        return take(X3, I);
+var reduceIdentity2 = {
+    reduceIndex(I, X4) {
+        return take2(X4, I);
     }
 };
-var reduceFirst = {
-    reduceIndex(I, X3) {
-        return X3[I[0]];
+var reduceFirst3 = {
+    reduceIndex(I, X4) {
+        return X4[I[0]];
     }
 };
-var reduceTitle = {
-    reduceIndex(I, X3) {
+var reduceTitle2 = {
+    reduceIndex(I, X4) {
         const n = 5;
-        const groups2 = sort(
-            rollup(
+        const groups3 = sort3(
+            rollup2(
                 I,
                 (V) => V.length,
-                (i) => X3[i]
+                (i) => X4[i]
             ),
-            second2
+            second4
         );
-        const top2 = groups2.slice(-n).reverse();
-        if (top2.length < groups2.length) {
-            const bottom2 = groups2.slice(0, 1 - n);
-            top2[n - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second2)];
+        const top3 = groups3.slice(-n).reverse();
+        if (top3.length < groups3.length) {
+            const bottom3 = groups3.slice(0, 1 - n);
+            top3[n - 1] = [`\u2026 ${bottom3.length.toLocaleString("en-US")} more`, sum4(bottom3, second4)];
         }
-        return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
+        return top3.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
     }
 };
-var reduceLast = {
-    reduceIndex(I, X3) {
-        return X3[I[I.length - 1]];
+var reduceLast3 = {
+    reduceIndex(I, X4) {
+        return X4[I[I.length - 1]];
     }
 };
-var reduceCount = {
+var reduceCount2 = {
     label: "Frequency",
     reduceIndex(I) {
         return I.length;
     }
 };
-var reduceDistinct = {
+var reduceDistinct2 = {
     label: "Distinct",
-    reduceIndex(I, X3) {
-        const s2 = new InternSet();
+    reduceIndex(I, X4) {
+        const s3 = new InternSet2();
         for (const i of I)
-            s2.add(X3[i]);
-        return s2.size;
+            s3.add(X4[i]);
+        return s3.size;
     }
 };
-var reduceSum = reduceAccessor(sum);
+var reduceSum3 = reduceAccessor2(sum4);
 
-function reduceProportion(value, scope) {
+function reduceProportion2(value, scope) {
     return value == null ? {
         scope,
         label: "Frequency",
-        reduceIndex: (I, V, basis2 = 1) => I.length / basis2
+        reduceIndex: (I, V, basis3 = 1) => I.length / basis3
     } : {
         scope,
-        reduceIndex: (I, V, basis2 = 1) => sum(I, (i) => V[i]) / basis2
+        reduceIndex: (I, V, basis3 = 1) => sum4(I, (i) => V[i]) / basis3
     };
 }
 
-// node_modules/@observablehq/plot/src/channel.js
-function createChannel(data, {
-    scale: scale3,
-    type: type2,
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/channel.js
+function createChannel2(data, {
+    scale: scale5,
+    type: type3,
     value,
-    filter: filter4,
+    filter: filter7,
     hint
 }, name) {
-    return inferChannelScale(name, {
-        scale: scale3,
-        type: type2,
-        value: valueof(data, value),
-        label: labelof(value),
-        filter: filter4,
+    return inferChannelScale2(name, {
+        scale: scale5,
+        type: type3,
+        value: valueof2(data, value),
+        label: labelof2(value),
+        filter: filter7,
         hint
     });
 }
 
-function createChannels(channels, data) {
+function createChannels2(channels, data) {
     return Object.fromEntries(
-        Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
+        Object.entries(channels).map(([name, channel]) => [name, createChannel2(data, channel, name)])
     );
 }
 
-function valueObject(channels, scales) {
-    const values2 = Object.fromEntries(
+function valueObject2(channels, scales) {
+    const values3 = Object.fromEntries(
         Object.entries(channels).map(([name, {
             scale: scaleName,
             value
         }]) => {
-            const scale3 = scaleName == null ? null : scales[scaleName];
-            return [name, scale3 == null ? value : map4(value, scale3)];
+            const scale5 = scaleName == null ? null : scales[scaleName];
+            return [name, scale5 == null ? value : map9(value, scale5)];
         })
     );
-    values2.channels = channels;
-    return values2;
+    values3.channels = channels;
+    return values3;
 }
 
-function inferChannelScale(name, channel) {
+function inferChannelScale2(name, channel) {
     const {
-        scale: scale3,
+        scale: scale5,
         value
     } = channel;
-    if (scale3 === true || scale3 === "auto") {
+    if (scale5 === true || scale5 === "auto") {
         switch (name) {
             case "fill":
             case "stroke":
             case "color":
-                channel.scale = scale3 !== true && isEvery(value, isColor) ? null : "color";
+                channel.scale = scale5 !== true && isEvery2(value, isColor2) ? null : "color";
                 break;
             case "fillOpacity":
             case "strokeOpacity":
-                channel.scale = scale3 !== true && isEvery(value, isOpacity) ? null : "opacity";
+                channel.scale = scale5 !== true && isEvery2(value, isOpacity2) ? null : "opacity";
                 break;
             case "symbol":
-                if (scale3 !== true && isEvery(value, isSymbol)) {
+                if (scale5 !== true && isEvery2(value, isSymbol2)) {
                     channel.scale = null;
-                    channel.value = map4(value, maybeSymbol);
+                    channel.value = map9(value, maybeSymbol2);
                 } else {
                     channel.scale = "symbol";
                 }
                 break;
             default:
-                channel.scale = registry.has(name) ? name : null;
+                channel.scale = registry2.has(name) ? name : null;
                 break;
         }
-    } else if (scale3 === false) {
+    } else if (scale5 === false) {
         channel.scale = null;
-    } else if (scale3 != null && !registry.has(scale3)) {
-        throw new Error(`unknown scale: ${scale3}`);
+    } else if (scale5 != null && !registry2.has(scale5)) {
+        throw new Error(`unknown scale: ${scale5}`);
     }
     return channel;
 }
 
-function channelDomain(data, facets, channels, facetChannels, options) {
+function channelDomain2(data, facets, channels, facetChannels, options) {
     const {
         reverse: defaultReverse,
         reduce: defaultReduce = true,
         limit: defaultLimit
     } = options;
-    for (const x4 in options) {
-        if (!registry.has(x4))
+    for (const x7 in options) {
+        if (!registry2.has(x7))
             continue;
         let {
-            value: y4,
-            reverse: reverse3 = defaultReverse,
-            reduce: reduce2 = defaultReduce,
+            value: y7,
+            reverse: reverse5 = defaultReverse,
+            reduce: reduce3 = defaultReduce,
             limit = defaultLimit
-        } = maybeValue(options[x4]);
-        if (reverse3 === void 0)
-            reverse3 = y4 === "width" || y4 === "height";
-        if (reduce2 == null || reduce2 === false)
+        } = maybeValue2(options[x7]);
+        if (reverse5 === void 0)
+            reverse5 = y7 === "width" || y7 === "height";
+        if (reduce3 == null || reduce3 === false)
             continue;
-        const X3 = x4 === "fx" || x4 === "fy" ? reindexFacetChannel(facets, facetChannels[x4]) : findScaleChannel(channels, x4);
-        if (!X3)
-            throw new Error(`missing channel for scale: ${x4}`);
-        const XV = X3.value;
-        const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
-        if (y4 == null) {
-            X3.domain = () => {
-                let domain = Array.from(new InternSet(XV));
-                if (reverse3)
+        const X4 = x7 === "fx" || x7 === "fy" ? reindexFacetChannel2(facets, facetChannels[x7]) : findScaleChannel2(channels, x7);
+        if (!X4)
+            throw new Error(`missing channel for scale: ${x7}`);
+        const XV = X4.value;
+        const [lo = 0, hi = Infinity] = isIterable2(limit) ? limit : limit < 0 ? [limit] : [0, limit];
+        if (y7 == null) {
+            X4.domain = () => {
+                let domain = Array.from(new InternSet2(XV));
+                if (reverse5)
                     domain = domain.reverse();
                 if (lo !== 0 || hi !== Infinity)
                     domain = domain.slice(lo, hi);
                 return domain;
             };
         } else {
-            const YV = y4 === "data" ? data : y4 === "height" ? difference2(channels, "y1", "y2") : y4 === "width" ? difference2(channels, "x1", "x2") : values(channels, y4, y4 === "y" ? "y2" : y4 === "x" ? "x2" : void 0);
-            const reducer2 = maybeReduce(reduce2 === true ? "max" : reduce2, YV);
-            X3.domain = () => {
-                let domain = rollup(
-                    range4(XV),
-                    (I) => reducer2.reduceIndex(I, YV),
+            const YV = y7 === "data" ? data : y7 === "height" ? difference4(channels, "y1", "y2") : y7 === "width" ? difference4(channels, "x1", "x2") : values2(channels, y7, y7 === "y" ? "y2" : y7 === "x" ? "x2" : void 0);
+            const reducer3 = maybeReduce3(reduce3 === true ? "max" : reduce3, YV);
+            X4.domain = () => {
+                let domain = rollup2(
+                    range8(XV),
+                    (I) => reducer3.reduceIndex(I, YV),
                     (i) => XV[i]
                 );
-                domain = sort(domain, reverse3 ? descendingGroup : ascendingGroup);
+                domain = sort3(domain, reverse5 ? descendingGroup2 : ascendingGroup2);
                 if (lo !== 0 || hi !== Infinity)
                     domain = domain.slice(lo, hi);
-                return domain.map(first);
+                return domain.map(first2);
             };
         }
     }
 }
 
-function findScaleChannel(channels, scale3) {
+function findScaleChannel2(channels, scale5) {
     for (const name in channels) {
         const channel = channels[name];
-        if (channel.scale === scale3)
+        if (channel.scale === scale5)
             return channel;
     }
 }
 
-function reindexFacetChannel(facets, channel) {
+function reindexFacetChannel2(facets, channel) {
     const originalFacets = facets.original;
     if (originalFacets === facets)
         return channel;
     const V1 = channel.value;
     const V2 = channel.value = [];
     for (let i = 0; i < originalFacets.length; ++i) {
         const vi = V1[originalFacets[i][0]];
         for (const j of facets[i])
             V2[j] = vi;
     }
     return channel;
 }
 
-function difference2(channels, k1, k2) {
-    const X13 = values(channels, k1);
-    const X23 = values(channels, k2);
-    return map4(X23, (x22, i) => Math.abs(x22 - X13[i]), Float64Array);
+function difference4(channels, k1, k22) {
+    const X15 = values2(channels, k1);
+    const X25 = values2(channels, k22);
+    return map9(X25, (x22, i) => Math.abs(x22 - X15[i]), Float64Array);
 }
 
-function values(channels, name, alias) {
+function values2(channels, name, alias) {
     let channel = channels[name];
     if (!channel && alias !== void 0)
         channel = channels[alias];
     if (channel)
         return channel.value;
     throw new Error(`missing channel: ${name}`);
 }
 
-function ascendingGroup([ak, av], [bk, bv]) {
-    return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
+function ascendingGroup2([ak, av], [bk, bv]) {
+    return ascendingDefined4(av, bv) || ascendingDefined4(ak, bk);
 }
 
-function descendingGroup([ak, av], [bk, bv]) {
-    return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
+function descendingGroup2([ak, av], [bk, bv]) {
+    return descendingDefined2(av, bv) || ascendingDefined4(ak, bk);
 }
 
-// node_modules/@observablehq/plot/src/warnings.js
-var warnings = 0;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/warnings.js
+var warnings2 = 0;
 
-function consumeWarnings() {
-    const w = warnings;
-    warnings = 0;
+function consumeWarnings2() {
+    const w = warnings2;
+    warnings2 = 0;
     return w;
 }
 
-function warn(message) {
+function warn2(message) {
     console.warn(message);
-    ++warnings;
+    ++warnings2;
 }
 
-// node_modules/@observablehq/plot/src/projection.js
-var pi6 = Math.PI;
-var tau7 = 2 * pi6;
-var defaultAspectRatio = 0.618;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/projection.js
+var pi12 = Math.PI;
+var tau14 = 2 * pi12;
+var defaultAspectRatio2 = 0.618;
 
-function createProjection({
-    projection: projection2,
+function createProjection2({
+    projection: projection3,
     inset: globalInset = 0,
     insetTop = globalInset,
     insetRight = globalInset,
     insetBottom = globalInset,
     insetLeft = globalInset
 } = {}, dimensions) {
-    if (projection2 == null)
+    if (projection3 == null)
         return;
-    if (typeof projection2.stream === "function")
-        return projection2;
+    if (typeof projection3.stream === "function")
+        return projection3;
     let options;
     let domain;
     let clip = "frame";
-    if (isObject(projection2)) {
+    if (isObject2(projection3)) {
         let inset;
         ({
-            type: projection2,
+            type: projection3,
             domain,
             inset,
             insetTop = inset !== void 0 ? inset : insetTop,
             insetRight = inset !== void 0 ? inset : insetRight,
             insetBottom = inset !== void 0 ? inset : insetBottom,
             insetLeft = inset !== void 0 ? inset : insetLeft,
             clip = clip,
             ...options
-        } = projection2);
-        if (projection2 == null)
+        } = projection3);
+        if (projection3 == null)
             return;
     }
-    if (typeof projection2 !== "function")
+    if (typeof projection3 !== "function")
         ({
-            type: projection2
-        } = namedProjection(projection2));
+            type: projection3
+        } = namedProjection2(projection3));
     const {
         width,
         height,
         marginLeft,
         marginRight,
         marginTop,
         marginBottom
     } = dimensions;
     const dx = width - marginLeft - marginRight - insetLeft - insetRight;
     const dy = height - marginTop - marginBottom - insetTop - insetBottom;
-    projection2 = projection2?.({
+    projection3 = projection3?.({
         width: dx,
         height: dy,
         clip,
         ...options
     });
-    if (projection2 == null)
+    if (projection3 == null)
         return;
-    clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
+    clip = maybePostClip2(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
     let tx = marginLeft + insetLeft;
     let ty = marginTop + insetTop;
-    let transform2;
+    let transform3;
     if (domain != null) {
         const [
-            [x06, y06],
-            [x12, y12]
-        ] = path_default(projection2).bounds(domain);
-        const k2 = Math.min(dx / (x12 - x06), dy / (y12 - y06));
-        if (k2 > 0) {
-            tx -= (k2 * (x06 + x12) - dx) / 2;
-            ty -= (k2 * (y06 + y12) - dy) / 2;
-            transform2 = transform_default({
-                point(x4, y4) {
-                    this.stream.point(x4 * k2 + tx, y4 * k2 + ty);
+            [x011, y011],
+            [x13, y13]
+        ] = path_default3(projection3).bounds(domain);
+        const k3 = Math.min(dx / (x13 - x011), dy / (y13 - y011));
+        if (k3 > 0) {
+            tx -= (k3 * (x011 + x13) - dx) / 2;
+            ty -= (k3 * (y011 + y13) - dy) / 2;
+            transform3 = transform_default2({
+                point(x7, y7) {
+                    this.stream.point(x7 * k3 + tx, y7 * k3 + ty);
                 }
             });
         } else {
-            warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
+            warn2(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
         }
     }
-    transform2 ??= tx === 0 && ty === 0 ? identity7() : transform_default({
-        point(x4, y4) {
-            this.stream.point(x4 + tx, y4 + ty);
+    transform3 ??= tx === 0 && ty === 0 ? identity14() : transform_default2({
+        point(x7, y7) {
+            this.stream.point(x7 + tx, y7 + ty);
         }
     });
     return {
-        stream: (s2) => projection2.stream(transform2.stream(clip(s2)))
+        stream: (s3) => projection3.stream(transform3.stream(clip(s3)))
     };
 }
 
-function namedProjection(projection2) {
-    switch (`${projection2}`.toLowerCase()) {
+function namedProjection2(projection3) {
+    switch (`${projection3}`.toLowerCase()) {
         case "albers-usa":
-            return scaleProjection(albersUsa_default, 0.7463, 0.4673);
+            return scaleProjection3(albersUsa_default2, 0.7463, 0.4673);
         case "albers":
-            return conicProjection2(albers_default, 0.7463, 0.4673);
+            return conicProjection4(albers_default2, 0.7463, 0.4673);
         case "azimuthal-equal-area":
-            return scaleProjection(azimuthalEqualArea_default, 4, 4);
+            return scaleProjection3(azimuthalEqualArea_default2, 4, 4);
         case "azimuthal-equidistant":
-            return scaleProjection(azimuthalEquidistant_default, tau7, tau7);
+            return scaleProjection3(azimuthalEquidistant_default2, tau14, tau14);
         case "conic-conformal":
-            return conicProjection2(conicConformal_default, tau7, tau7);
+            return conicProjection4(conicConformal_default2, tau14, tau14);
         case "conic-equal-area":
-            return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
+            return conicProjection4(conicEqualArea_default2, 6.1702, 2.9781);
         case "conic-equidistant":
-            return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
+            return conicProjection4(conicEquidistant_default2, 7.312, 3.6282);
         case "equal-earth":
-            return scaleProjection(equalEarth_default, 5.4133, 2.6347);
+            return scaleProjection3(equalEarth_default2, 5.4133, 2.6347);
         case "equirectangular":
-            return scaleProjection(equirectangular_default, tau7, pi6);
+            return scaleProjection3(equirectangular_default2, tau14, pi12);
         case "gnomonic":
-            return scaleProjection(gnomonic_default, 3.4641, 3.4641);
+            return scaleProjection3(gnomonic_default2, 3.4641, 3.4641);
         case "identity":
             return {
-                type: identity7
+                type: identity14
             };
         case "reflect-y":
             return {
-                type: reflectY
+                type: reflectY2
             };
         case "mercator":
-            return scaleProjection(mercator_default, tau7, tau7);
+            return scaleProjection3(mercator_default2, tau14, tau14);
         case "orthographic":
-            return scaleProjection(orthographic_default, 2, 2);
+            return scaleProjection3(orthographic_default2, 2, 2);
         case "stereographic":
-            return scaleProjection(stereographic_default, 2, 2);
+            return scaleProjection3(stereographic_default2, 2, 2);
         case "transverse-mercator":
-            return scaleProjection(transverseMercator_default, tau7, tau7);
+            return scaleProjection3(transverseMercator_default2, tau14, tau14);
         default:
-            throw new Error(`unknown projection type: ${projection2}`);
+            throw new Error(`unknown projection type: ${projection3}`);
     }
 }
 
-function maybePostClip(clip, x12, y12, x22, y22) {
+function maybePostClip2(clip, x13, y13, x22, y22) {
     if (clip === false || clip == null || typeof clip === "number")
-        return (s2) => s2;
+        return (s3) => s3;
     if (clip === true)
         clip = "frame";
     switch (`${clip}`.toLowerCase()) {
         case "frame":
-            return clipRectangle(x12, y12, x22, y22);
+            return clipRectangle2(x13, y13, x22, y22);
         default:
             throw new Error(`unknown projection clip type: ${clip}`);
     }
 }
 
-function scaleProjection(createProjection2, kx2, ky2) {
+function scaleProjection3(createProjection3, kx3, ky3) {
     return {
         type: ({
             width,
             height,
             rotate,
             precision = 0.15,
             clip
         }) => {
-            const projection2 = createProjection2();
+            const projection3 = createProjection3();
             if (precision != null)
-                projection2.precision?.(precision);
+                projection3.precision?.(precision);
             if (rotate != null)
-                projection2.rotate?.(rotate);
+                projection3.rotate?.(rotate);
             if (typeof clip === "number")
-                projection2.clipAngle?.(clip);
-            projection2.scale(Math.min(width / kx2, height / ky2));
-            projection2.translate([width / 2, height / 2]);
-            return projection2;
+                projection3.clipAngle?.(clip);
+            projection3.scale(Math.min(width / kx3, height / ky3));
+            projection3.translate([width / 2, height / 2]);
+            return projection3;
         },
-        aspectRatio: ky2 / kx2
+        aspectRatio: ky3 / kx3
     };
 }
 
-function conicProjection2(createProjection2, kx2, ky2) {
+function conicProjection4(createProjection3, kx3, ky3) {
     const {
-        type: type2,
+        type: type3,
         aspectRatio
-    } = scaleProjection(createProjection2, kx2, ky2);
+    } = scaleProjection3(createProjection3, kx3, ky3);
     return {
         type: (options) => {
             const {
                 parallels,
                 domain,
                 width,
                 height
             } = options;
-            const projection2 = type2(options);
+            const projection3 = type3(options);
             if (parallels != null) {
-                projection2.parallels(parallels);
+                projection3.parallels(parallels);
                 if (domain === void 0) {
-                    projection2.fitSize([width, height], {
+                    projection3.fitSize([width, height], {
                         type: "Sphere"
                     });
                 }
             }
-            return projection2;
+            return projection3;
         },
         aspectRatio
     };
 }
-var identity7 = constant2({
+var identity14 = constant4({
     stream: (stream) => stream
 });
-var reflectY = constant2(
-    transform_default({
-        point(x4, y4) {
-            this.stream.point(x4, -y4);
+var reflectY2 = constant4(
+    transform_default2({
+        point(x7, y7) {
+            this.stream.point(x7, -y7);
         }
     })
 );
 
-function maybeProject(cx, cy, channels, values2, context) {
-    const x4 = channels[cx] && channels[cx].scale === "x";
-    const y4 = channels[cy] && channels[cy].scale === "y";
-    if (x4 && y4) {
-        project(cx, cy, values2, context.projection);
-    } else if (x4) {
+function maybeProject2(cx, cy, channels, values3, context) {
+    const x7 = channels[cx] && channels[cx].scale === "x";
+    const y7 = channels[cy] && channels[cy].scale === "y";
+    if (x7 && y7) {
+        project2(cx, cy, values3, context.projection);
+    } else if (x7) {
         throw new Error(`projection requires paired x and y channels; ${cx} is missing ${cy}`);
-    } else if (y4) {
+    } else if (y7) {
         throw new Error(`projection requires paired x and y channels; ${cy} is missing ${cx}`);
     }
 }
 
-function project(cx, cy, values2, projection2) {
-    const x4 = values2[cx];
-    const y4 = values2[cy];
-    const n = x4.length;
-    const X3 = values2[cx] = new Float64Array(n).fill(NaN);
-    const Y3 = values2[cy] = new Float64Array(n).fill(NaN);
+function project2(cx, cy, values3, projection3) {
+    const x7 = values3[cx];
+    const y7 = values3[cy];
+    const n = x7.length;
+    const X4 = values3[cx] = new Float64Array(n).fill(NaN);
+    const Y4 = values3[cy] = new Float64Array(n).fill(NaN);
     let i;
-    const stream = projection2.stream({
-        point(x5, y5) {
-            X3[i] = x5;
-            Y3[i] = y5;
+    const stream = projection3.stream({
+        point(x8, y8) {
+            X4[i] = x8;
+            Y4[i] = y8;
         }
     });
     for (i = 0; i < n; ++i) {
-        stream.point(x4[i], y4[i]);
+        stream.point(x7[i], y7[i]);
     }
 }
 
-function projectionAspectRatio(projection2, marks2) {
-    if (typeof projection2?.stream === "function")
-        return defaultAspectRatio;
-    if (isObject(projection2))
-        projection2 = projection2.type;
-    if (projection2 == null)
-        return hasGeometry(marks2) ? defaultAspectRatio : void 0;
-    if (typeof projection2 !== "function") {
+function projectionAspectRatio2(projection3, marks3) {
+    if (typeof projection3?.stream === "function")
+        return defaultAspectRatio2;
+    if (isObject2(projection3))
+        projection3 = projection3.type;
+    if (projection3 == null)
+        return hasGeometry2(marks3) ? defaultAspectRatio2 : void 0;
+    if (typeof projection3 !== "function") {
         const {
             aspectRatio
-        } = namedProjection(projection2);
+        } = namedProjection2(projection3);
         if (aspectRatio)
             return aspectRatio;
     }
-    return defaultAspectRatio;
+    return defaultAspectRatio2;
 }
 
-function applyPosition(channels, scales, context) {
+function applyPosition2(channels, scales, context) {
     const {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = channels;
-    let position2 = {};
-    if (x4)
-        position2.x = x4;
-    if (y4)
-        position2.y = y4;
-    position2 = valueObject(position2, scales);
+    let position3 = {};
+    if (x7)
+        position3.x = x7;
+    if (y7)
+        position3.y = y7;
+    position3 = valueObject2(position3, scales);
     if (context.projection)
-        maybeProject("x", "y", channels, position2, context);
-    if (x4)
-        position2.x = coerceNumbers(position2.x);
-    if (y4)
-        position2.y = coerceNumbers(position2.y);
-    return position2;
+        maybeProject2("x", "y", channels, position3, context);
+    if (x7)
+        position3.x = coerceNumbers2(position3.x);
+    if (y7)
+        position3.y = coerceNumbers2(position3.y);
+    return position3;
 }
 
-function hasGeometry(marks2) {
-    for (const mark of marks2)
+function hasGeometry2(marks3) {
+    for (const mark of marks3)
         if (mark.channels.geometry)
             return true;
     return false;
 }
 
-// node_modules/@observablehq/plot/src/context.js
-function createContext(options = {}, dimensions) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/context.js
+function createContext2(options = {}, dimensions) {
     const {
         document: document2 = typeof window !== "undefined" ? window.document : void 0
     } = options;
     return {
         document: document2,
-        projection: createProjection(options, dimensions)
+        projection: createProjection2(options, dimensions)
     };
 }
 
-function create2(name, {
+function create4(name, {
     document: document2
 }) {
-    return select_default2(creator_default(name).call(document2.documentElement));
+    return select_default5(creator_default2(name).call(document2.documentElement));
 }
 
-// node_modules/@observablehq/plot/src/scales/schemes.js
-var ordinalSchemes = /* @__PURE__ */ new Map([
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/schemes.js
+var ordinalSchemes2 = /* @__PURE__ */ new Map([
     // categorical
-    ["accent", Accent_default],
-    ["category10", category10_default],
-    ["dark2", Dark2_default],
-    ["paired", Paired_default],
-    ["pastel1", Pastel1_default],
-    ["pastel2", Pastel2_default],
-    ["set1", Set1_default],
-    ["set2", Set2_default],
-    ["set3", Set3_default],
-    ["tableau10", Tableau10_default],
+    ["accent", Accent_default2],
+    ["category10", category10_default2],
+    ["dark2", Dark2_default2],
+    ["paired", Paired_default2],
+    ["pastel1", Pastel1_default2],
+    ["pastel2", Pastel2_default2],
+    ["set1", Set1_default2],
+    ["set2", Set2_default2],
+    ["set3", Set3_default2],
+    ["tableau10", Tableau10_default2],
     // diverging
-    ["brbg", scheme112(scheme, BrBG_default)],
-    ["prgn", scheme112(scheme2, PRGn_default)],
-    ["piyg", scheme112(scheme3, PiYG_default)],
-    ["puor", scheme112(scheme4, PuOr_default)],
-    ["rdbu", scheme112(scheme5, RdBu_default)],
-    ["rdgy", scheme112(scheme6, RdGy_default)],
-    ["rdylbu", scheme112(scheme7, RdYlBu_default)],
-    ["rdylgn", scheme112(scheme8, RdYlGn_default)],
-    ["spectral", scheme112(scheme9, Spectral_default)],
+    ["brbg", scheme113(scheme28, BrBG_default2)],
+    ["prgn", scheme113(scheme29, PRGn_default2)],
+    ["piyg", scheme113(scheme30, PiYG_default2)],
+    ["puor", scheme113(scheme31, PuOr_default2)],
+    ["rdbu", scheme113(scheme32, RdBu_default2)],
+    ["rdgy", scheme113(scheme33, RdGy_default2)],
+    ["rdylbu", scheme113(scheme34, RdYlBu_default2)],
+    ["rdylgn", scheme113(scheme35, RdYlGn_default2)],
+    ["spectral", scheme113(scheme36, Spectral_default2)],
     // reversed diverging (for temperature data)
-    ["burd", scheme11r(scheme5, RdBu_default)],
-    ["buylrd", scheme11r(scheme7, RdYlBu_default)],
+    ["burd", scheme11r2(scheme32, RdBu_default2)],
+    ["buylrd", scheme11r2(scheme34, RdYlBu_default2)],
     // sequential (single-hue)
-    ["blues", scheme92(scheme22, Blues_default)],
-    ["greens", scheme92(scheme23, Greens_default)],
-    ["greys", scheme92(scheme24, Greys_default)],
-    ["oranges", scheme92(scheme27, Oranges_default)],
-    ["purples", scheme92(scheme25, Purples_default)],
-    ["reds", scheme92(scheme26, Reds_default)],
+    ["blues", scheme93(scheme49, Blues_default2)],
+    ["greens", scheme93(scheme50, Greens_default2)],
+    ["greys", scheme93(scheme51, Greys_default2)],
+    ["oranges", scheme93(scheme54, Oranges_default2)],
+    ["purples", scheme93(scheme52, Purples_default2)],
+    ["reds", scheme93(scheme53, Reds_default2)],
     // sequential (multi-hue)
-    ["turbo", schemei(turbo_default)],
-    ["viridis", schemei(viridis_default)],
-    ["magma", schemei(magma)],
-    ["inferno", schemei(inferno)],
-    ["plasma", schemei(plasma)],
-    ["cividis", schemei(cividis_default)],
-    ["cubehelix", schemei(cubehelix_default2)],
-    ["warm", schemei(warm)],
-    ["cool", schemei(cool)],
-    ["bugn", scheme92(scheme10, BuGn_default)],
-    ["bupu", scheme92(scheme11, BuPu_default)],
-    ["gnbu", scheme92(scheme12, GnBu_default)],
-    ["orrd", scheme92(scheme13, OrRd_default)],
-    ["pubu", scheme92(scheme15, PuBu_default)],
-    ["pubugn", scheme92(scheme14, PuBuGn_default)],
-    ["purd", scheme92(scheme16, PuRd_default)],
-    ["rdpu", scheme92(scheme17, RdPu_default)],
-    ["ylgn", scheme92(scheme19, YlGn_default)],
-    ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
-    ["ylorbr", scheme92(scheme20, YlOrBr_default)],
-    ["ylorrd", scheme92(scheme21, YlOrRd_default)],
+    ["turbo", schemei2(turbo_default2)],
+    ["viridis", schemei2(viridis_default2)],
+    ["magma", schemei2(magma2)],
+    ["inferno", schemei2(inferno2)],
+    ["plasma", schemei2(plasma2)],
+    ["cividis", schemei2(cividis_default2)],
+    ["cubehelix", schemei2(cubehelix_default4)],
+    ["warm", schemei2(warm2)],
+    ["cool", schemei2(cool2)],
+    ["bugn", scheme93(scheme37, BuGn_default2)],
+    ["bupu", scheme93(scheme38, BuPu_default2)],
+    ["gnbu", scheme93(scheme39, GnBu_default2)],
+    ["orrd", scheme93(scheme40, OrRd_default2)],
+    ["pubu", scheme93(scheme42, PuBu_default2)],
+    ["pubugn", scheme93(scheme41, PuBuGn_default2)],
+    ["purd", scheme93(scheme43, PuRd_default2)],
+    ["rdpu", scheme93(scheme44, RdPu_default2)],
+    ["ylgn", scheme93(scheme46, YlGn_default2)],
+    ["ylgnbu", scheme93(scheme45, YlGnBu_default2)],
+    ["ylorbr", scheme93(scheme47, YlOrBr_default2)],
+    ["ylorrd", scheme93(scheme48, YlOrRd_default2)],
     // cyclical
-    ["rainbow", schemeicyclical(rainbow_default)],
-    ["sinebow", schemeicyclical(sinebow_default)]
+    ["rainbow", schemeicyclical2(rainbow_default2)],
+    ["sinebow", schemeicyclical2(sinebow_default2)]
 ]);
 
-function scheme92(scheme28, interpolate) {
+function scheme93(scheme55, interpolate) {
     return ({
         length: n
     }) => {
         if (n === 1)
-            return [scheme28[3][1]];
+            return [scheme55[3][1]];
         if (n === 2)
-            return [scheme28[3][1], scheme28[3][2]];
+            return [scheme55[3][1], scheme55[3][2]];
         n = Math.max(3, Math.floor(n));
-        return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
+        return n > 9 ? quantize_default2(interpolate, n) : scheme55[n];
     };
 }
 
-function scheme112(scheme28, interpolate) {
+function scheme113(scheme55, interpolate) {
     return ({
         length: n
     }) => {
         if (n === 2)
-            return [scheme28[3][0], scheme28[3][2]];
+            return [scheme55[3][0], scheme55[3][2]];
         n = Math.max(3, Math.floor(n));
-        return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
+        return n > 11 ? quantize_default2(interpolate, n) : scheme55[n];
     };
 }
 
-function scheme11r(scheme28, interpolate) {
+function scheme11r2(scheme55, interpolate) {
     return ({
         length: n
     }) => {
         if (n === 2)
-            return [scheme28[3][2], scheme28[3][0]];
+            return [scheme55[3][2], scheme55[3][0]];
         n = Math.max(3, Math.floor(n));
-        return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
+        return n > 11 ? quantize_default2((t) => interpolate(1 - t), n) : scheme55[n].slice().reverse();
     };
 }
 
-function schemei(interpolate) {
+function schemei2(interpolate) {
     return ({
         length: n
-    }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
+    }) => quantize_default2(interpolate, Math.max(2, Math.floor(n)));
 }
 
-function schemeicyclical(interpolate) {
+function schemeicyclical2(interpolate) {
     return ({
         length: n
-    }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
+    }) => quantize_default2(interpolate, Math.floor(n) + 1).slice(0, -1);
+}
+
+function ordinalScheme2(scheme55) {
+    const s3 = `${scheme55}`.toLowerCase();
+    if (!ordinalSchemes2.has(s3))
+        throw new Error(`unknown ordinal scheme: ${s3}`);
+    return ordinalSchemes2.get(s3);
+}
+
+function ordinalRange2(scheme55, length7) {
+    const s3 = ordinalScheme2(scheme55);
+    const r = typeof s3 === "function" ? s3({
+        length: length7
+    }) : s3;
+    return r.length !== length7 ? r.slice(0, length7) : r;
 }
 
-function ordinalScheme(scheme28) {
-    const s2 = `${scheme28}`.toLowerCase();
-    if (!ordinalSchemes.has(s2))
-        throw new Error(`unknown ordinal scheme: ${s2}`);
-    return ordinalSchemes.get(s2);
-}
-
-function ordinalRange(scheme28, length4) {
-    const s2 = ordinalScheme(scheme28);
-    const r = typeof s2 === "function" ? s2({
-        length: length4
-    }) : s2;
-    return r.length !== length4 ? r.slice(0, length4) : r;
-}
-
-function maybeBooleanRange(domain, scheme28 = "greys") {
-    const range5 = /* @__PURE__ */ new Set();
-    const [f, t] = ordinalRange(scheme28, 2);
+function maybeBooleanRange2(domain, scheme55 = "greys") {
+    const range9 = /* @__PURE__ */ new Set();
+    const [f, t] = ordinalRange2(scheme55, 2);
     for (const value of domain) {
         if (value == null)
             continue;
         if (value === true)
-            range5.add(t);
+            range9.add(t);
         else if (value === false)
-            range5.add(f);
+            range9.add(f);
         else
             return;
     }
-    return [...range5];
+    return [...range9];
 }
-var quantitativeSchemes = /* @__PURE__ */ new Map([
+var quantitativeSchemes2 = /* @__PURE__ */ new Map([
     // diverging
-    ["brbg", BrBG_default],
-    ["prgn", PRGn_default],
-    ["piyg", PiYG_default],
-    ["puor", PuOr_default],
-    ["rdbu", RdBu_default],
-    ["rdgy", RdGy_default],
-    ["rdylbu", RdYlBu_default],
-    ["rdylgn", RdYlGn_default],
-    ["spectral", Spectral_default],
+    ["brbg", BrBG_default2],
+    ["prgn", PRGn_default2],
+    ["piyg", PiYG_default2],
+    ["puor", PuOr_default2],
+    ["rdbu", RdBu_default2],
+    ["rdgy", RdGy_default2],
+    ["rdylbu", RdYlBu_default2],
+    ["rdylgn", RdYlGn_default2],
+    ["spectral", Spectral_default2],
     // reversed diverging (for temperature data)
-    ["burd", (t) => RdBu_default(1 - t)],
-    ["buylrd", (t) => RdYlBu_default(1 - t)],
+    ["burd", (t) => RdBu_default2(1 - t)],
+    ["buylrd", (t) => RdYlBu_default2(1 - t)],
     // sequential (single-hue)
-    ["blues", Blues_default],
-    ["greens", Greens_default],
-    ["greys", Greys_default],
-    ["purples", Purples_default],
-    ["reds", Reds_default],
-    ["oranges", Oranges_default],
+    ["blues", Blues_default2],
+    ["greens", Greens_default2],
+    ["greys", Greys_default2],
+    ["purples", Purples_default2],
+    ["reds", Reds_default2],
+    ["oranges", Oranges_default2],
     // sequential (multi-hue)
-    ["turbo", turbo_default],
-    ["viridis", viridis_default],
-    ["magma", magma],
-    ["inferno", inferno],
-    ["plasma", plasma],
-    ["cividis", cividis_default],
-    ["cubehelix", cubehelix_default2],
-    ["warm", warm],
-    ["cool", cool],
-    ["bugn", BuGn_default],
-    ["bupu", BuPu_default],
-    ["gnbu", GnBu_default],
-    ["orrd", OrRd_default],
-    ["pubugn", PuBuGn_default],
-    ["pubu", PuBu_default],
-    ["purd", PuRd_default],
-    ["rdpu", RdPu_default],
-    ["ylgnbu", YlGnBu_default],
-    ["ylgn", YlGn_default],
-    ["ylorbr", YlOrBr_default],
-    ["ylorrd", YlOrRd_default],
+    ["turbo", turbo_default2],
+    ["viridis", viridis_default2],
+    ["magma", magma2],
+    ["inferno", inferno2],
+    ["plasma", plasma2],
+    ["cividis", cividis_default2],
+    ["cubehelix", cubehelix_default4],
+    ["warm", warm2],
+    ["cool", cool2],
+    ["bugn", BuGn_default2],
+    ["bupu", BuPu_default2],
+    ["gnbu", GnBu_default2],
+    ["orrd", OrRd_default2],
+    ["pubugn", PuBuGn_default2],
+    ["pubu", PuBu_default2],
+    ["purd", PuRd_default2],
+    ["rdpu", RdPu_default2],
+    ["ylgnbu", YlGnBu_default2],
+    ["ylgn", YlGn_default2],
+    ["ylorbr", YlOrBr_default2],
+    ["ylorrd", YlOrRd_default2],
     // cyclical
-    ["rainbow", rainbow_default],
-    ["sinebow", sinebow_default]
+    ["rainbow", rainbow_default2],
+    ["sinebow", sinebow_default2]
 ]);
 
-function quantitativeScheme(scheme28) {
-    const s2 = `${scheme28}`.toLowerCase();
-    if (!quantitativeSchemes.has(s2))
-        throw new Error(`unknown quantitative scheme: ${s2}`);
-    return quantitativeSchemes.get(s2);
+function quantitativeScheme2(scheme55) {
+    const s3 = `${scheme55}`.toLowerCase();
+    if (!quantitativeSchemes2.has(s3))
+        throw new Error(`unknown quantitative scheme: ${s3}`);
+    return quantitativeSchemes2.get(s3);
 }
-var divergingSchemes = /* @__PURE__ */ new Set([
+var divergingSchemes2 = /* @__PURE__ */ new Set([
     "brbg",
     "prgn",
     "piyg",
     "puor",
     "rdbu",
     "rdgy",
     "rdylbu",
     "rdylgn",
     "spectral",
     "burd",
     "buylrd"
 ]);
 
-function isDivergingScheme(scheme28) {
-    return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
+function isDivergingScheme2(scheme55) {
+    return scheme55 != null && divergingSchemes2.has(`${scheme55}`.toLowerCase());
 }
 
-// node_modules/@observablehq/plot/src/scales/quantitative.js
-var flip = (i) => (t) => i(1 - t);
-var unit2 = [0, 1];
-var interpolators = /* @__PURE__ */ new Map([
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/quantitative.js
+var flip2 = (i) => (t) => i(1 - t);
+var unit4 = [0, 1];
+var interpolators2 = /* @__PURE__ */ new Map([
     // numbers
-    ["number", number_default],
+    ["number", number_default2],
     // color spaces
-    ["rgb", rgb_default],
-    ["hsl", hsl_default],
-    ["hcl", hcl_default],
-    ["lab", lab2]
+    ["rgb", rgb_default2],
+    ["hsl", hsl_default2],
+    ["hcl", hcl_default2],
+    ["lab", lab4]
 ]);
 
-function maybeInterpolator(interpolate) {
+function maybeInterpolator2(interpolate) {
     const i = `${interpolate}`.toLowerCase();
-    if (!interpolators.has(i))
+    if (!interpolators2.has(i))
         throw new Error(`unknown interpolator: ${i}`);
-    return interpolators.get(i);
+    return interpolators2.get(i);
 }
 
-function createScaleQ(key, scale3, channels, {
-    type: type2,
-    nice: nice3,
+function createScaleQ2(key, scale5, channels, {
+    type: type3,
+    nice: nice5,
     clamp,
-    zero: zero3,
-    domain = inferAutoDomain(key, channels),
+    zero: zero5,
+    domain = inferAutoDomain2(key, channels),
     unknown,
-    round: round2,
-    scheme: scheme28,
-    interval: interval2,
-    range: range5 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
-    interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round2 ? round_default : number_default,
-    reverse: reverse3
-}) {
-    interval2 = maybeRangeInterval(interval2, type2);
-    if (type2 === "cyclical" || type2 === "sequential")
-        type2 = "linear";
-    reverse3 = !!reverse3;
+    round: round3,
+    scheme: scheme55,
+    interval: interval3,
+    range: range9 = registry2.get(key) === radius2 ? inferRadialRange2(channels, domain) : registry2.get(key) === length6 ? inferLengthRange2(channels, domain) : registry2.get(key) === opacity2 ? unit4 : void 0,
+    interpolate = registry2.get(key) === color4 ? scheme55 == null && range9 !== void 0 ? rgb_default2 : quantitativeScheme2(scheme55 !== void 0 ? scheme55 : type3 === "cyclical" ? "rainbow" : "turbo") : round3 ? round_default3 : number_default2,
+    reverse: reverse5
+}) {
+    interval3 = maybeRangeInterval2(interval3, type3);
+    if (type3 === "cyclical" || type3 === "sequential")
+        type3 = "linear";
+    reverse5 = !!reverse5;
     if (typeof interpolate !== "function") {
-        interpolate = maybeInterpolator(interpolate);
+        interpolate = maybeInterpolator2(interpolate);
     }
     if (interpolate.length === 1) {
-        if (reverse3) {
-            interpolate = flip(interpolate);
-            reverse3 = false;
+        if (reverse5) {
+            interpolate = flip2(interpolate);
+            reverse5 = false;
+        }
+        if (range9 === void 0) {
+            range9 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
+            if (range9.length === 2)
+                range9 = unit4;
         }
-        if (range5 === void 0) {
-            range5 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
-            if (range5.length === 2)
-                range5 = unit2;
-        }
-        scale3.interpolate((range5 === unit2 ? constant2 : interpolatePiecewise)(interpolate));
+        scale5.interpolate((range9 === unit4 ? constant4 : interpolatePiecewise2)(interpolate));
     } else {
-        scale3.interpolate(interpolate);
+        scale5.interpolate(interpolate);
     }
-    if (zero3) {
-        const [min4, max5] = extent(domain);
-        if (min4 > 0 || max5 < 0) {
-            domain = slice5(domain);
-            if (orderof(domain) !== Math.sign(min4))
+    if (zero5) {
+        const [min7, max9] = extent3(domain);
+        if (min7 > 0 || max9 < 0) {
+            domain = slice11(domain);
+            if (orderof2(domain) !== Math.sign(min7))
                 domain[domain.length - 1] = 0;
             else
                 domain[0] = 0;
         }
     }
-    if (reverse3)
-        domain = reverse(domain);
-    scale3.domain(domain).unknown(unknown);
-    if (nice3)
-        scale3.nice(maybeNice(nice3, type2)), domain = scale3.domain();
-    if (range5 !== void 0)
-        scale3.range(range5);
+    if (reverse5)
+        domain = reverse3(domain);
+    scale5.domain(domain).unknown(unknown);
+    if (nice5)
+        scale5.nice(maybeNice2(nice5, type3)), domain = scale5.domain();
+    if (range9 !== void 0)
+        scale5.range(range9);
     if (clamp)
-        scale3.clamp(clamp);
+        scale5.clamp(clamp);
     return {
-        type: type2,
+        type: type3,
         domain,
-        range: range5,
-        scale: scale3,
+        range: range9,
+        scale: scale5,
         interpolate,
-        interval: interval2
+        interval: interval3
     };
 }
 
-function maybeNice(nice3, type2) {
-    return nice3 === true ? void 0 : typeof nice3 === "number" ? nice3 : maybeNiceInterval(nice3, type2);
+function maybeNice2(nice5, type3) {
+    return nice5 === true ? void 0 : typeof nice5 === "number" ? nice5 : maybeNiceInterval2(nice5, type3);
 }
 
-function createScaleLinear(key, channels, options) {
-    return createScaleQ(key, linear3(), channels, options);
+function createScaleLinear2(key, channels, options) {
+    return createScaleQ2(key, linear6(), channels, options);
 }
 
-function createScaleSqrt(key, channels, options) {
-    return createScalePow(key, channels, {
+function createScaleSqrt2(key, channels, options) {
+    return createScalePow2(key, channels, {
         ...options,
         exponent: 0.5
     });
 }
 
-function createScalePow(key, channels, {
-    exponent: exponent2 = 1,
+function createScalePow2(key, channels, {
+    exponent: exponent3 = 1,
     ...options
 }) {
-    return createScaleQ(key, pow3().exponent(exponent2), channels, {
+    return createScaleQ2(key, pow6().exponent(exponent3), channels, {
         ...options,
         type: "pow"
     });
 }
 
-function createScaleLog(key, channels, {
+function createScaleLog2(key, channels, {
     base = 10,
-    domain = inferLogDomain(channels),
+    domain = inferLogDomain2(channels),
     ...options
 }) {
-    return createScaleQ(key, log2().base(base), channels, {
+    return createScaleQ2(key, log4().base(base), channels, {
         ...options,
         domain
     });
 }
 
-function createScaleSymlog(key, channels, {
-    constant: constant3 = 1,
+function createScaleSymlog2(key, channels, {
+    constant: constant5 = 1,
     ...options
 }) {
-    return createScaleQ(key, symlog().constant(constant3), channels, options);
+    return createScaleQ2(key, symlog2().constant(constant5), channels, options);
 }
 
-function createScaleQuantile(key, channels, {
-    range: range5,
-    quantiles = range5 === void 0 ? 5 : (range5 = [...range5]).length,
+function createScaleQuantile2(key, channels, {
+    range: range9,
+    quantiles = range9 === void 0 ? 5 : (range9 = [...range9]).length,
     // deprecated; use n instead
     n = quantiles,
-    scheme: scheme28 = "rdylbu",
-    domain = inferQuantileDomain(channels),
+    scheme: scheme55 = "rdylbu",
+    domain = inferQuantileDomain2(channels),
     unknown,
     interpolate,
-    reverse: reverse3
+    reverse: reverse5
 }) {
-    if (range5 === void 0) {
-        range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
+    if (range9 === void 0) {
+        range9 = interpolate !== void 0 ? quantize_default2(interpolate, n) : registry2.get(key) === color4 ? ordinalRange2(scheme55, n) : void 0;
     }
     if (domain.length > 0) {
-        domain = quantile2(domain, range5 === void 0 ? {
+        domain = quantile4(domain, range9 === void 0 ? {
             length: n
-        } : range5).quantiles();
+        } : range9).quantiles();
     }
-    return createScaleThreshold(key, channels, {
+    return createScaleThreshold2(key, channels, {
         domain,
-        range: range5,
-        reverse: reverse3,
+        range: range9,
+        reverse: reverse5,
         unknown
     });
 }
 
-function createScaleQuantize(key, channels, {
-    range: range5,
-    n = range5 === void 0 ? 5 : (range5 = [...range5]).length,
-    scheme: scheme28 = "rdylbu",
-    domain = inferAutoDomain(key, channels),
+function createScaleQuantize2(key, channels, {
+    range: range9,
+    n = range9 === void 0 ? 5 : (range9 = [...range9]).length,
+    scheme: scheme55 = "rdylbu",
+    domain = inferAutoDomain2(key, channels),
     unknown,
     interpolate,
-    reverse: reverse3
+    reverse: reverse5
 }) {
-    const [min4, max5] = extent(domain);
+    const [min7, max9] = extent3(domain);
     let thresholds;
-    if (range5 === void 0) {
-        thresholds = ticks(min4, max5, n);
-        if (thresholds[0] <= min4)
+    if (range9 === void 0) {
+        thresholds = ticks2(min7, max9, n);
+        if (thresholds[0] <= min7)
             thresholds.splice(0, 1);
-        if (thresholds[thresholds.length - 1] >= max5)
+        if (thresholds[thresholds.length - 1] >= max9)
             thresholds.pop();
         n = thresholds.length + 1;
-        range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
+        range9 = interpolate !== void 0 ? quantize_default2(interpolate, n) : registry2.get(key) === color4 ? ordinalRange2(scheme55, n) : void 0;
     } else {
-        thresholds = quantize_default(number_default(min4, max5), n + 1).slice(1, -1);
-        if (min4 instanceof Date)
-            thresholds = thresholds.map((x4) => new Date(x4));
+        thresholds = quantize_default2(number_default2(min7, max9), n + 1).slice(1, -1);
+        if (min7 instanceof Date)
+            thresholds = thresholds.map((x7) => new Date(x7));
     }
-    if (orderof(arrayify2(domain)) < 0)
+    if (orderof2(arrayify4(domain)) < 0)
         thresholds.reverse();
-    return createScaleThreshold(key, channels, {
+    return createScaleThreshold2(key, channels, {
         domain: thresholds,
-        range: range5,
-        reverse: reverse3,
+        range: range9,
+        reverse: reverse5,
         unknown
     });
 }
 
-function createScaleThreshold(key, channels, {
+function createScaleThreshold2(key, channels, {
     domain = [0],
     // explicit thresholds in ascending order
     unknown,
-    scheme: scheme28 = "rdylbu",
+    scheme: scheme55 = "rdylbu",
     interpolate,
-    range: range5 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
-    reverse: reverse3
+    range: range9 = interpolate !== void 0 ? quantize_default2(interpolate, domain.length + 1) : registry2.get(key) === color4 ? ordinalRange2(scheme55, domain.length + 1) : void 0,
+    reverse: reverse5
 }) {
-    domain = arrayify2(domain);
-    const sign3 = orderof(domain);
-    if (!isNaN(sign3) && !isOrdered(domain, sign3))
+    domain = arrayify4(domain);
+    const sign5 = orderof2(domain);
+    if (!isNaN(sign5) && !isOrdered2(domain, sign5))
         throw new Error(`the ${key} scale has a non-monotonic domain`);
-    if (reverse3)
-        range5 = reverse(range5);
+    if (reverse5)
+        range9 = reverse3(range9);
     return {
         type: "threshold",
-        scale: threshold(sign3 < 0 ? reverse(domain) : domain, range5 === void 0 ? [] : range5).unknown(unknown),
+        scale: threshold2(sign5 < 0 ? reverse3(domain) : domain, range9 === void 0 ? [] : range9).unknown(unknown),
         domain,
-        range: range5
+        range: range9
     };
 }
 
-function isOrdered(domain, sign3) {
+function isOrdered2(domain, sign5) {
     for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
-        const s2 = descending(d, d = domain[i]);
-        if (s2 !== 0 && s2 !== sign3)
+        const s3 = descending2(d, d = domain[i]);
+        if (s3 !== 0 && s3 !== sign5)
             return false;
     }
     return true;
 }
 
-function createScaleIdentity() {
+function createScaleIdentity2() {
     return {
         type: "identity",
-        scale: identity4()
+        scale: identity11()
     };
 }
 
-function inferDomain(channels, f = finite2) {
+function inferDomain3(channels, f = finite5) {
     return channels.length ? [
-        min(channels, ({
+        min4(channels, ({
             value
-        }) => value === void 0 ? value : min(value, f)),
-        max(channels, ({
+        }) => value === void 0 ? value : min4(value, f)),
+        max5(channels, ({
             value
-        }) => value === void 0 ? value : max(value, f))
+        }) => value === void 0 ? value : max5(value, f))
     ] : [0, 1];
 }
 
-function inferAutoDomain(key, channels) {
-    const type2 = registry.get(key);
-    return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);
+function inferAutoDomain2(key, channels) {
+    const type3 = registry2.get(key);
+    return (type3 === radius2 || type3 === opacity2 || type3 === length6 ? inferZeroDomain2 : inferDomain3)(channels);
 }
 
-function inferZeroDomain(channels) {
-    return [0, channels.length ? max(channels, ({
+function inferZeroDomain2(channels) {
+    return [0, channels.length ? max5(channels, ({
         value
-    }) => value === void 0 ? value : max(value, finite2)) : 1];
+    }) => value === void 0 ? value : max5(value, finite5)) : 1];
 }
 
-function inferRadialRange(channels, domain) {
+function inferRadialRange2(channels, domain) {
     const hint = channels.find(({
-        radius: radius2
-    }) => radius2 !== void 0);
+        radius: radius3
+    }) => radius3 !== void 0);
     if (hint !== void 0)
         return [0, hint.radius];
-    const h25 = quantile(channels, 0.5, ({
+    const h25 = quantile3(channels, 0.5, ({
         value
-    }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
-    const range5 = domain.map((d) => 3 * Math.sqrt(d / h25));
-    const k2 = 30 / max(range5);
-    return k2 < 1 ? range5.map((r) => r * k2) : range5;
+    }) => value === void 0 ? NaN : quantile3(value, 0.25, positive2));
+    const range9 = domain.map((d) => 3 * Math.sqrt(d / h25));
+    const k3 = 30 / max5(range9);
+    return k3 < 1 ? range9.map((r) => r * k3) : range9;
 }
 
-function inferLengthRange(channels, domain) {
-    const h50 = median(channels, ({
+function inferLengthRange2(channels, domain) {
+    const h50 = median2(channels, ({
         value
-    }) => value === void 0 ? NaN : median(value, Math.abs));
-    const range5 = domain.map((d) => 12 * d / h50);
-    const k2 = 60 / max(range5);
-    return k2 < 1 ? range5.map((r) => r * k2) : range5;
+    }) => value === void 0 ? NaN : median2(value, Math.abs));
+    const range9 = domain.map((d) => 12 * d / h50);
+    const k3 = 60 / max5(range9);
+    return k3 < 1 ? range9.map((r) => r * k3) : range9;
 }
 
-function inferLogDomain(channels) {
+function inferLogDomain2(channels) {
     for (const {
             value
         }
         of channels) {
         if (value !== void 0) {
-            for (let v2 of value) {
-                if (v2 > 0)
-                    return inferDomain(channels, positive);
-                if (v2 < 0)
-                    return inferDomain(channels, negative);
+            for (let v3 of value) {
+                if (v3 > 0)
+                    return inferDomain3(channels, positive2);
+                if (v3 < 0)
+                    return inferDomain3(channels, negative2);
             }
         }
     }
     return [1, 10];
 }
 
-function inferQuantileDomain(channels) {
+function inferQuantileDomain2(channels) {
     const domain = [];
     for (const {
             value
         }
         of channels) {
         if (value === void 0)
             continue;
-        for (const v2 of value)
-            domain.push(v2);
+        for (const v3 of value)
+            domain.push(v3);
     }
     return domain;
 }
 
-function interpolatePiecewise(interpolate) {
+function interpolatePiecewise2(interpolate) {
     return (i, j) => (t) => interpolate(i + t * (j - i));
 }
 
-// node_modules/@observablehq/plot/src/scales/diverging.js
-function createScaleD(key, scale3, transform2, channels, {
-    type: type2,
-    nice: nice3,
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/diverging.js
+function createScaleD2(key, scale5, transform3, channels, {
+    type: type3,
+    nice: nice5,
     clamp,
-    domain = inferDomain(channels),
+    domain = inferDomain3(channels),
     unknown,
     pivot = 0,
-    scheme: scheme28,
-    range: range5,
+    scheme: scheme55,
+    range: range9,
     symmetric = true,
-    interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
-    reverse: reverse3
+    interpolate = registry2.get(key) === color4 ? scheme55 == null && range9 !== void 0 ? rgb_default2 : quantitativeScheme2(scheme55 !== void 0 ? scheme55 : "rdbu") : number_default2,
+    reverse: reverse5
 }) {
     pivot = +pivot;
-    let [min4, max5] = domain;
-    if (descending(min4, max5) < 0)
-        [min4, max5] = [max5, min4], reverse3 = !reverse3;
-    min4 = Math.min(min4, pivot);
-    max5 = Math.max(max5, pivot);
+    let [min7, max9] = domain;
+    if (descending2(min7, max9) < 0)
+        [min7, max9] = [max9, min7], reverse5 = !reverse5;
+    min7 = Math.min(min7, pivot);
+    max9 = Math.max(max9, pivot);
     if (typeof interpolate !== "function") {
-        interpolate = maybeInterpolator(interpolate);
+        interpolate = maybeInterpolator2(interpolate);
     }
-    if (range5 !== void 0) {
-        interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range5) : piecewise(interpolate, range5);
+    if (range9 !== void 0) {
+        interpolate = interpolate.length === 1 ? interpolatePiecewise2(interpolate)(...range9) : piecewise2(interpolate, range9);
     }
-    if (reverse3)
-        interpolate = flip(interpolate);
+    if (reverse5)
+        interpolate = flip2(interpolate);
     if (symmetric) {
-        const mid2 = transform2.apply(pivot);
-        const mindelta = mid2 - transform2.apply(min4);
-        const maxdelta = transform2.apply(max5) - mid2;
+        const mid3 = transform3.apply(pivot);
+        const mindelta = mid3 - transform3.apply(min7);
+        const maxdelta = transform3.apply(max9) - mid3;
         if (mindelta < maxdelta)
-            min4 = transform2.invert(mid2 - maxdelta);
+            min7 = transform3.invert(mid3 - maxdelta);
         else if (mindelta > maxdelta)
-            max5 = transform2.invert(mid2 + mindelta);
+            max9 = transform3.invert(mid3 + mindelta);
     }
-    scale3.domain([min4, pivot, max5]).unknown(unknown).interpolator(interpolate);
+    scale5.domain([min7, pivot, max9]).unknown(unknown).interpolator(interpolate);
     if (clamp)
-        scale3.clamp(clamp);
-    if (nice3)
-        scale3.nice(nice3);
+        scale5.clamp(clamp);
+    if (nice5)
+        scale5.nice(nice5);
     return {
-        type: type2,
-        domain: [min4, max5],
+        type: type3,
+        domain: [min7, max9],
         pivot,
         interpolate,
-        scale: scale3
+        scale: scale5
     };
 }
 
-function createScaleDiverging(key, channels, options) {
-    return createScaleD(key, diverging(), transformIdentity, channels, options);
+function createScaleDiverging2(key, channels, options) {
+    return createScaleD2(key, diverging2(), transformIdentity2, channels, options);
 }
 
-function createScaleDivergingSqrt(key, channels, options) {
-    return createScaleDivergingPow(key, channels, {
+function createScaleDivergingSqrt2(key, channels, options) {
+    return createScaleDivergingPow2(key, channels, {
         ...options,
         exponent: 0.5
     });
 }
 
-function createScaleDivergingPow(key, channels, {
-    exponent: exponent2 = 1,
+function createScaleDivergingPow2(key, channels, {
+    exponent: exponent3 = 1,
     ...options
 }) {
-    return createScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow2(exponent2), channels, {
+    return createScaleD2(key, divergingPow2().exponent(exponent3 = +exponent3), transformPow4(exponent3), channels, {
         ...options,
         type: "diverging-pow"
     });
 }
 
-function createScaleDivergingLog(key, channels, {
+function createScaleDivergingLog2(key, channels, {
     base = 10,
     pivot = 1,
-    domain = inferDomain(channels, pivot < 0 ? negative : positive),
+    domain = inferDomain3(channels, pivot < 0 ? negative2 : positive2),
     ...options
 }) {
-    return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
+    return createScaleD2(key, divergingLog2().base(base = +base), transformLog4, channels, {
         domain,
         pivot,
         ...options
     });
 }
 
-function createScaleDivergingSymlog(key, channels, {
-    constant: constant3 = 1,
+function createScaleDivergingSymlog2(key, channels, {
+    constant: constant5 = 1,
     ...options
 }) {
-    return createScaleD(
+    return createScaleD2(
         key,
-        divergingSymlog().constant(constant3 = +constant3),
-        transformSymlog2(constant3),
+        divergingSymlog2().constant(constant5 = +constant5),
+        transformSymlog4(constant5),
         channels,
         options
     );
 }
-var transformIdentity = {
-    apply(x4) {
-        return x4;
+var transformIdentity2 = {
+    apply(x7) {
+        return x7;
     },
-    invert(x4) {
-        return x4;
+    invert(x7) {
+        return x7;
     }
 };
-var transformLog2 = {
+var transformLog4 = {
     apply: Math.log,
     invert: Math.exp
 };
-var transformSqrt2 = {
-    apply(x4) {
-        return Math.sign(x4) * Math.sqrt(Math.abs(x4));
+var transformSqrt4 = {
+    apply(x7) {
+        return Math.sign(x7) * Math.sqrt(Math.abs(x7));
     },
-    invert(x4) {
-        return Math.sign(x4) * (x4 * x4);
+    invert(x7) {
+        return Math.sign(x7) * (x7 * x7);
     }
 };
 
-function transformPow2(exponent2) {
-    return exponent2 === 0.5 ? transformSqrt2 : {
-        apply(x4) {
-            return Math.sign(x4) * Math.pow(Math.abs(x4), exponent2);
+function transformPow4(exponent3) {
+    return exponent3 === 0.5 ? transformSqrt4 : {
+        apply(x7) {
+            return Math.sign(x7) * Math.pow(Math.abs(x7), exponent3);
         },
-        invert(x4) {
-            return Math.sign(x4) * Math.pow(Math.abs(x4), 1 / exponent2);
+        invert(x7) {
+            return Math.sign(x7) * Math.pow(Math.abs(x7), 1 / exponent3);
         }
     };
 }
 
-function transformSymlog2(constant3) {
+function transformSymlog4(constant5) {
     return {
-        apply(x4) {
-            return Math.sign(x4) * Math.log1p(Math.abs(x4 / constant3));
+        apply(x7) {
+            return Math.sign(x7) * Math.log1p(Math.abs(x7 / constant5));
         },
-        invert(x4) {
-            return Math.sign(x4) * Math.expm1(Math.abs(x4)) * constant3;
+        invert(x7) {
+            return Math.sign(x7) * Math.expm1(Math.abs(x7)) * constant5;
         }
     };
 }
 
-// node_modules/@observablehq/plot/src/scales/temporal.js
-function createScaleT(key, scale3, channels, options) {
-    return createScaleQ(key, scale3, channels, options);
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/temporal.js
+function createScaleT2(key, scale5, channels, options) {
+    return createScaleQ2(key, scale5, channels, options);
 }
 
-function createScaleTime(key, channels, options) {
-    return createScaleT(key, time(), channels, options);
+function createScaleTime2(key, channels, options) {
+    return createScaleT2(key, time2(), channels, options);
 }
 
-function createScaleUtc(key, channels, options) {
-    return createScaleT(key, utcTime(), channels, options);
+function createScaleUtc2(key, channels, options) {
+    return createScaleT2(key, utcTime2(), channels, options);
 }
 
-// node_modules/@observablehq/plot/src/scales/ordinal.js
-var ordinalImplicit = Symbol("ordinal");
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales/ordinal.js
+var ordinalImplicit2 = Symbol("ordinal");
 
-function createScaleO(key, scale3, channels, {
-    type: type2,
-    interval: interval2,
+function createScaleO2(key, scale5, channels, {
+    type: type3,
+    interval: interval3,
     domain,
-    range: range5,
-    reverse: reverse3,
+    range: range9,
+    reverse: reverse5,
     hint
 }) {
-    interval2 = maybeRangeInterval(interval2, type2);
+    interval3 = maybeRangeInterval2(interval3, type3);
     if (domain === void 0)
-        domain = inferDomain2(channels, interval2, key);
-    if (type2 === "categorical" || type2 === ordinalImplicit)
-        type2 = "ordinal";
-    if (reverse3)
-        domain = reverse(domain);
-    scale3.domain(domain);
-    if (range5 !== void 0) {
-        if (typeof range5 === "function")
-            range5 = range5(domain);
-        scale3.range(range5);
+        domain = inferDomain4(channels, interval3, key);
+    if (type3 === "categorical" || type3 === ordinalImplicit2)
+        type3 = "ordinal";
+    if (reverse5)
+        domain = reverse3(domain);
+    scale5.domain(domain);
+    if (range9 !== void 0) {
+        if (typeof range9 === "function")
+            range9 = range9(domain);
+        scale5.range(range9);
     }
     return {
-        type: type2,
+        type: type3,
         domain,
-        range: range5,
-        scale: scale3,
+        range: range9,
+        scale: scale5,
         hint,
-        interval: interval2
+        interval: interval3
     };
 }
 
-function createScaleOrdinal(key, channels, {
-    type: type2,
-    interval: interval2,
+function createScaleOrdinal2(key, channels, {
+    type: type3,
+    interval: interval3,
     domain,
-    range: range5,
-    scheme: scheme28,
+    range: range9,
+    scheme: scheme55,
     unknown,
     ...options
 }) {
-    interval2 = maybeRangeInterval(interval2, type2);
+    interval3 = maybeRangeInterval2(interval3, type3);
     if (domain === void 0)
-        domain = inferDomain2(channels, interval2, key);
+        domain = inferDomain4(channels, interval3, key);
     let hint;
-    if (registry.get(key) === symbol) {
-        hint = inferSymbolHint(channels);
-        range5 = range5 === void 0 ? inferSymbolRange(hint) : map4(range5, maybeSymbol);
-    } else if (registry.get(key) === color2) {
-        if (range5 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
-            range5 = maybeBooleanRange(domain, scheme28);
-            if (range5 !== void 0)
-                scheme28 = void 0;
-        }
-        if (scheme28 === void 0 && range5 === void 0) {
-            scheme28 = type2 === "ordinal" ? "turbo" : "tableau10";
-        }
-        if (scheme28 !== void 0) {
-            if (range5 !== void 0) {
-                const interpolate = quantitativeScheme(scheme28);
-                const t03 = range5[0],
-                    d = range5[1] - range5[0];
-                range5 = ({
+    if (registry2.get(key) === symbol2) {
+        hint = inferSymbolHint2(channels);
+        range9 = range9 === void 0 ? inferSymbolRange2(hint) : map9(range9, maybeSymbol2);
+    } else if (registry2.get(key) === color4) {
+        if (range9 === void 0 && (type3 === "ordinal" || type3 === ordinalImplicit2)) {
+            range9 = maybeBooleanRange2(domain, scheme55);
+            if (range9 !== void 0)
+                scheme55 = void 0;
+        }
+        if (scheme55 === void 0 && range9 === void 0) {
+            scheme55 = type3 === "ordinal" ? "turbo" : "tableau10";
+        }
+        if (scheme55 !== void 0) {
+            if (range9 !== void 0) {
+                const interpolate = quantitativeScheme2(scheme55);
+                const t05 = range9[0],
+                    d = range9[1] - range9[0];
+                range9 = ({
                     length: n
-                }) => quantize_default((t) => interpolate(t03 + d * t), n);
+                }) => quantize_default2((t) => interpolate(t05 + d * t), n);
             } else {
-                range5 = ordinalScheme(scheme28);
+                range9 = ordinalScheme2(scheme55);
             }
         }
     }
-    if (unknown === implicit) {
+    if (unknown === implicit2) {
         throw new Error(`implicit unknown on ${key} scale is not supported`);
     }
-    return createScaleO(key, ordinal().unknown(unknown), channels, {
+    return createScaleO2(key, ordinal2().unknown(unknown), channels, {
         ...options,
-        type: type2,
+        type: type3,
         domain,
-        range: range5,
+        range: range9,
         hint
     });
 }
 
-function createScalePoint(key, channels, {
+function createScalePoint2(key, channels, {
     align = 0.5,
     padding = 0.5,
     ...options
 }) {
-    return maybeRound(point().align(align).padding(padding), channels, options, key);
+    return maybeRound2(point6().align(align).padding(padding), channels, options, key);
 }
 
-function createScaleBand(key, channels, {
+function createScaleBand2(key, channels, {
     align = 0.5,
     padding = 0.1,
     paddingInner = padding,
     paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
     ...options
 }) {
-    return maybeRound(
-        band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
+    return maybeRound2(
+        band2().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
         channels,
         options,
         key
     );
 }
 
-function maybeRound(scale3, channels, options, key) {
+function maybeRound2(scale5, channels, options, key) {
     let {
-        round: round2
+        round: round3
     } = options;
-    if (round2 !== void 0)
-        scale3.round(round2 = !!round2);
-    scale3 = createScaleO(key, scale3, channels, options);
-    scale3.round = round2;
-    return scale3;
+    if (round3 !== void 0)
+        scale5.round(round3 = !!round3);
+    scale5 = createScaleO2(key, scale5, channels, options);
+    scale5.round = round3;
+    return scale5;
 }
 
-function inferDomain2(channels, interval2, key) {
-    const values2 = new InternSet();
+function inferDomain4(channels, interval3, key) {
+    const values3 = new InternSet2();
     for (const {
             value,
             domain
         }
         of channels) {
         if (domain !== void 0)
             return domain();
         if (value === void 0)
             continue;
-        for (const v2 of value)
-            values2.add(v2);
+        for (const v3 of value)
+            values3.add(v3);
     }
-    if (interval2 !== void 0) {
-        const [min4, max5] = extent(values2).map(interval2.floor, interval2);
-        return interval2.range(min4, interval2.offset(max5));
+    if (interval3 !== void 0) {
+        const [min7, max9] = extent3(values3).map(interval3.floor, interval3);
+        return interval3.range(min7, interval3.offset(max9));
     }
-    if (values2.size > 1e4 && registry.get(key) === position) {
+    if (values3.size > 1e4 && registry2.get(key) === position2) {
         throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
     }
-    return sort(values2, ascendingDefined2);
+    return sort3(values3, ascendingDefined4);
 }
 
-function inferHint(channels, key) {
+function inferHint2(channels, key) {
     let value;
     for (const {
             hint
         }
         of channels) {
         const candidate = hint?.[key];
         if (candidate === void 0)
@@ -24098,159 +58804,159 @@
             value = candidate;
         else if (value !== candidate)
             return;
     }
     return value;
 }
 
-function inferSymbolHint(channels) {
+function inferSymbolHint2(channels) {
     return {
-        fill: inferHint(channels, "fill"),
-        stroke: inferHint(channels, "stroke")
+        fill: inferHint2(channels, "fill"),
+        stroke: inferHint2(channels, "stroke")
     };
 }
 
-function inferSymbolRange(hint) {
-    return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
+function inferSymbolRange2(hint) {
+    return isNoneish2(hint.fill) ? symbolsStroke2 : symbolsFill2;
 }
 
-// node_modules/@observablehq/plot/src/scales.js
-function createScales(channelsByScale, {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/scales.js
+function createScales2(channelsByScale, {
     label: globalLabel,
     inset: globalInset = 0,
     insetTop: globalInsetTop = globalInset,
     insetRight: globalInsetRight = globalInset,
     insetBottom: globalInsetBottom = globalInset,
     insetLeft: globalInsetLeft = globalInset,
-    round: round2,
-    nice: nice3,
+    round: round3,
+    nice: nice5,
     clamp,
-    zero: zero3,
+    zero: zero5,
     align,
     padding,
-    projection: projection2,
+    projection: projection3,
     facet: {
         label: facetLabel = globalLabel
     } = {},
     ...options
 } = {}) {
     const scales = {};
     for (const [key, channels] of channelsByScale) {
         const scaleOptions = options[key];
-        const scale3 = createScale(key, channels, {
-            round: registry.get(key) === position ? round2 : void 0,
+        const scale5 = createScale2(key, channels, {
+            round: registry2.get(key) === position2 ? round3 : void 0,
             // only for position
-            nice: nice3,
+            nice: nice5,
             clamp,
-            zero: zero3,
+            zero: zero5,
             align,
             padding,
-            projection: projection2,
+            projection: projection3,
             ...scaleOptions
         });
-        if (scale3) {
+        if (scale5) {
             let {
                 label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
                     percent,
-                    transform: transform2,
+                    transform: transform3,
                     inset,
                     insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
                     // not fy
                     insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
                     // not fx
                     insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
                     // not fy
                     insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
                 // not fx
             } = scaleOptions || {};
-            if (transform2 == null)
-                transform2 = void 0;
-            else if (typeof transform2 !== "function")
+            if (transform3 == null)
+                transform3 = void 0;
+            else if (typeof transform3 !== "function")
                 throw new Error("invalid scale transform; not a function");
-            scale3.percent = !!percent;
-            scale3.label = label === void 0 ? inferScaleLabel(channels, scale3) : label;
-            scale3.transform = transform2;
+            scale5.percent = !!percent;
+            scale5.label = label === void 0 ? inferScaleLabel2(channels, scale5) : label;
+            scale5.transform = transform3;
             if (key === "x" || key === "fx") {
-                scale3.insetLeft = +insetLeft;
-                scale3.insetRight = +insetRight;
+                scale5.insetLeft = +insetLeft;
+                scale5.insetRight = +insetRight;
             } else if (key === "y" || key === "fy") {
-                scale3.insetTop = +insetTop;
-                scale3.insetBottom = +insetBottom;
+                scale5.insetTop = +insetTop;
+                scale5.insetBottom = +insetBottom;
             }
-            scales[key] = scale3;
+            scales[key] = scale5;
         }
     }
     return scales;
 }
 
-function createScaleFunctions(scales) {
+function createScaleFunctions2(scales) {
     return Object.fromEntries(
         Object.entries(scales).filter(([, {
-            scale: scale3
-        }]) => scale3).map(([name, {
-            scale: scale3,
-            type: type2,
-            interval: interval2,
+            scale: scale5
+        }]) => scale5).map(([name, {
+            scale: scale5,
+            type: type3,
+            interval: interval3,
             label
         }]) => {
-            scale3.type = type2;
-            if (interval2 != null)
-                scale3.interval = interval2;
+            scale5.type = type3;
+            if (interval3 != null)
+                scale5.interval = interval3;
             if (label != null)
-                scale3.label = label;
-            return [name, scale3];
+                scale5.label = label;
+            return [name, scale5];
         })
     );
 }
 
-function autoScaleRange(scales, dimensions) {
+function autoScaleRange2(scales, dimensions) {
     const {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         fx,
         fy
     } = scales;
-    const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
+    const superdimensions = fx || fy ? outerDimensions2(dimensions) : dimensions;
     if (fx)
-        autoScaleRangeX(fx, superdimensions);
+        autoScaleRangeX2(fx, superdimensions);
     if (fy)
-        autoScaleRangeY(fy, superdimensions);
-    const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
-    if (x4)
-        autoScaleRangeX(x4, subdimensions);
-    if (y4)
-        autoScaleRangeY(y4, subdimensions);
+        autoScaleRangeY2(fy, superdimensions);
+    const subdimensions = fx || fy ? innerDimensions2(scales, dimensions) : dimensions;
+    if (x7)
+        autoScaleRangeX2(x7, subdimensions);
+    if (y7)
+        autoScaleRangeY2(y7, subdimensions);
 }
 
-function inferScaleLabel(channels = [], scale3) {
+function inferScaleLabel2(channels = [], scale5) {
     let label;
     for (const {
             label: l
         }
         of channels) {
         if (l === void 0)
             continue;
         if (label === void 0)
             label = l;
         else if (label !== l)
             return;
     }
     if (label === void 0)
         return;
-    if (isTemporalScale(scale3) && /^(date|time|year)$/i.test(label))
+    if (isTemporalScale2(scale5) && /^(date|time|year)$/i.test(label))
         return;
-    if (!isOrdinalScale(scale3) && scale3.percent)
+    if (!isOrdinalScale2(scale5) && scale5.percent)
         label = `${label} (%)`;
     return {
         inferred: true,
         toString: () => label
     };
 }
 
-function outerDimensions(dimensions) {
+function outerDimensions2(dimensions) {
     const {
         marginTop,
         marginRight,
         marginBottom,
         marginLeft,
         width,
         height,
@@ -24267,546 +58973,546 @@
         marginBottom: Math.max(marginBottom, facetMarginBottom),
         marginLeft: Math.max(marginLeft, facetMarginLeft),
         width,
         height
     };
 }
 
-function innerDimensions({
+function innerDimensions2({
     fx,
     fy
 }, dimensions) {
     const {
         marginTop,
         marginRight,
         marginBottom,
         marginLeft,
         width,
         height
-    } = outerDimensions(dimensions);
+    } = outerDimensions2(dimensions);
     return {
         marginTop,
         marginRight,
         marginBottom,
         marginLeft,
         width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
         height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height
     };
 }
 
-function autoScaleRangeX(scale3, dimensions) {
-    if (scale3.range === void 0) {
+function autoScaleRangeX2(scale5, dimensions) {
+    if (scale5.range === void 0) {
         const {
             insetLeft,
             insetRight
-        } = scale3;
+        } = scale5;
         const {
             width,
             marginLeft = 0,
             marginRight = 0
         } = dimensions;
-        const left2 = marginLeft + insetLeft;
-        const right2 = width - marginRight - insetRight;
-        scale3.range = [left2, Math.max(left2, right2)];
-        if (!isOrdinalScale(scale3))
-            scale3.range = piecewiseRange(scale3);
-        scale3.scale.range(scale3.range);
+        const left3 = marginLeft + insetLeft;
+        const right3 = width - marginRight - insetRight;
+        scale5.range = [left3, Math.max(left3, right3)];
+        if (!isOrdinalScale2(scale5))
+            scale5.range = piecewiseRange2(scale5);
+        scale5.scale.range(scale5.range);
     }
-    autoScaleRound(scale3);
+    autoScaleRound2(scale5);
 }
 
-function autoScaleRangeY(scale3, dimensions) {
-    if (scale3.range === void 0) {
+function autoScaleRangeY2(scale5, dimensions) {
+    if (scale5.range === void 0) {
         const {
             insetTop,
             insetBottom
-        } = scale3;
+        } = scale5;
         const {
             height,
             marginTop = 0,
             marginBottom = 0
         } = dimensions;
-        const top2 = marginTop + insetTop;
-        const bottom2 = height - marginBottom - insetBottom;
-        scale3.range = [Math.max(top2, bottom2), top2];
-        if (!isOrdinalScale(scale3))
-            scale3.range = piecewiseRange(scale3);
+        const top3 = marginTop + insetTop;
+        const bottom3 = height - marginBottom - insetBottom;
+        scale5.range = [Math.max(top3, bottom3), top3];
+        if (!isOrdinalScale2(scale5))
+            scale5.range = piecewiseRange2(scale5);
         else
-            scale3.range.reverse();
-        scale3.scale.range(scale3.range);
+            scale5.range.reverse();
+        scale5.scale.range(scale5.range);
     }
-    autoScaleRound(scale3);
+    autoScaleRound2(scale5);
 }
 
-function autoScaleRound(scale3) {
-    if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {
-        scale3.scale.round(true);
+function autoScaleRound2(scale5) {
+    if (scale5.round === void 0 && isBandScale2(scale5) && roundError2(scale5) <= 30) {
+        scale5.scale.round(true);
     }
 }
 
-function roundError({
-    scale: scale3
+function roundError2({
+    scale: scale5
 }) {
-    const n = scale3.domain().length;
-    const [start2, stop] = scale3.range();
-    const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;
-    const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();
-    const m3 = n - paddingInner;
-    const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);
-    return (step - Math.floor(step)) * m3;
-}
-
-function piecewiseRange(scale3) {
-    const length4 = scale3.scale.domain().length + isThresholdScale(scale3);
-    if (!(length4 > 2))
-        return scale3.range;
-    const [start2, end] = scale3.range;
+    const n = scale5.domain().length;
+    const [start3, stop] = scale5.range();
+    const paddingInner = scale5.paddingInner ? scale5.paddingInner() : 1;
+    const paddingOuter = scale5.paddingOuter ? scale5.paddingOuter() : scale5.padding();
+    const m5 = n - paddingInner;
+    const step = Math.abs(stop - start3) / Math.max(1, m5 + paddingOuter * 2);
+    return (step - Math.floor(step)) * m5;
+}
+
+function piecewiseRange2(scale5) {
+    const length7 = scale5.scale.domain().length + isThresholdScale2(scale5);
+    if (!(length7 > 2))
+        return scale5.range;
+    const [start3, end] = scale5.range;
     return Array.from({
-        length: length4
-    }, (_, i) => start2 + i / (length4 - 1) * (end - start2));
+        length: length7
+    }, (_, i) => start3 + i / (length7 - 1) * (end - start3));
 }
 
-function normalizeScale(key, scale3, hint) {
-    return createScale(key, hint === void 0 ? void 0 : [{
+function normalizeScale2(key, scale5, hint) {
+    return createScale2(key, hint === void 0 ? void 0 : [{
         hint
     }], {
-        ...scale3
+        ...scale5
     });
 }
 
-function createScale(key, channels = [], options = {}) {
-    const type2 = inferScaleType(key, channels, options);
-    if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({
-            type: type2
+function createScale2(key, channels = [], options = {}) {
+    const type3 = inferScaleType2(key, channels, options);
+    if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale2({
+            type: type3
         })) {
-        const values2 = channels.map(({
+        const values3 = channels.map(({
             value
         }) => value).filter((value) => value !== void 0);
-        if (values2.some(isTemporal))
-            warn(
-                `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
-          type2
-        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
-          type2
+        if (values3.some(isTemporal2))
+            warn2(
+                `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType2(
+          type3
+        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType2(
+          type3
         )}".`
             );
-        else if (values2.some(isTemporalString))
-            warn(
-                `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
-          type2
-        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
-          type2
+        else if (values3.some(isTemporalString2))
+            warn2(
+                `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType2(
+          type3
+        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType2(
+          type3
         )}".`
             );
-        else if (values2.some(isNumericString))
-            warn(
-                `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
-          type2
-        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
-          type2
+        else if (values3.some(isNumericString2))
+            warn2(
+                `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType2(
+          type3
+        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType2(
+          type3
         )}".`
             );
     }
-    options.type = type2;
-    switch (type2) {
+    options.type = type3;
+    switch (type3) {
         case "diverging":
         case "diverging-sqrt":
         case "diverging-pow":
         case "diverging-log":
         case "diverging-symlog":
         case "cyclical":
         case "sequential":
         case "linear":
         case "sqrt":
         case "threshold":
         case "quantile":
         case "pow":
         case "log":
         case "symlog":
-            options = coerceType(channels, options, coerceNumbers);
+            options = coerceType2(channels, options, coerceNumbers2);
             break;
         case "identity":
-            switch (registry.get(key)) {
-                case position:
-                    options = coerceType(channels, options, coerceNumbers);
+            switch (registry2.get(key)) {
+                case position2:
+                    options = coerceType2(channels, options, coerceNumbers2);
                     break;
-                case symbol:
-                    options = coerceType(channels, options, coerceSymbols);
+                case symbol2:
+                    options = coerceType2(channels, options, coerceSymbols2);
                     break;
             }
             break;
         case "utc":
         case "time":
-            options = coerceType(channels, options, coerceDates);
+            options = coerceType2(channels, options, coerceDates2);
             break;
     }
-    switch (type2) {
+    switch (type3) {
         case "diverging":
-            return createScaleDiverging(key, channels, options);
+            return createScaleDiverging2(key, channels, options);
         case "diverging-sqrt":
-            return createScaleDivergingSqrt(key, channels, options);
+            return createScaleDivergingSqrt2(key, channels, options);
         case "diverging-pow":
-            return createScaleDivergingPow(key, channels, options);
+            return createScaleDivergingPow2(key, channels, options);
         case "diverging-log":
-            return createScaleDivergingLog(key, channels, options);
+            return createScaleDivergingLog2(key, channels, options);
         case "diverging-symlog":
-            return createScaleDivergingSymlog(key, channels, options);
+            return createScaleDivergingSymlog2(key, channels, options);
         case "categorical":
         case "ordinal":
-        case ordinalImplicit:
-            return createScaleOrdinal(key, channels, options);
+        case ordinalImplicit2:
+            return createScaleOrdinal2(key, channels, options);
         case "cyclical":
         case "sequential":
         case "linear":
-            return createScaleLinear(key, channels, options);
+            return createScaleLinear2(key, channels, options);
         case "sqrt":
-            return createScaleSqrt(key, channels, options);
+            return createScaleSqrt2(key, channels, options);
         case "threshold":
-            return createScaleThreshold(key, channels, options);
+            return createScaleThreshold2(key, channels, options);
         case "quantile":
-            return createScaleQuantile(key, channels, options);
+            return createScaleQuantile2(key, channels, options);
         case "quantize":
-            return createScaleQuantize(key, channels, options);
+            return createScaleQuantize2(key, channels, options);
         case "pow":
-            return createScalePow(key, channels, options);
+            return createScalePow2(key, channels, options);
         case "log":
-            return createScaleLog(key, channels, options);
+            return createScaleLog2(key, channels, options);
         case "symlog":
-            return createScaleSymlog(key, channels, options);
+            return createScaleSymlog2(key, channels, options);
         case "utc":
-            return createScaleUtc(key, channels, options);
+            return createScaleUtc2(key, channels, options);
         case "time":
-            return createScaleTime(key, channels, options);
+            return createScaleTime2(key, channels, options);
         case "point":
-            return createScalePoint(key, channels, options);
+            return createScalePoint2(key, channels, options);
         case "band":
-            return createScaleBand(key, channels, options);
+            return createScaleBand2(key, channels, options);
         case "identity":
-            return registry.get(key) === position ? createScaleIdentity() : {
+            return registry2.get(key) === position2 ? createScaleIdentity2() : {
                 type: "identity"
             };
         case void 0:
             return;
         default:
-            throw new Error(`unknown scale type: ${type2}`);
+            throw new Error(`unknown scale type: ${type3}`);
     }
 }
 
-function formatScaleType(type2) {
-    return typeof type2 === "symbol" ? type2.description : type2;
+function formatScaleType2(type3) {
+    return typeof type3 === "symbol" ? type3.description : type3;
 }
-var typeProjection = {
+var typeProjection2 = {
     toString: () => "projection"
 };
 
-function inferScaleType(key, channels, {
-    type: type2,
+function inferScaleType2(key, channels, {
+    type: type3,
     domain,
-    range: range5,
-    scheme: scheme28,
+    range: range9,
+    scheme: scheme55,
     pivot,
-    projection: projection2
+    projection: projection3
 }) {
     if (key === "fx" || key === "fy")
         return "band";
-    if ((key === "x" || key === "y") && projection2 != null)
-        type2 = typeProjection;
+    if ((key === "x" || key === "y") && projection3 != null)
+        type3 = typeProjection2;
     for (const {
             type: t
         }
         of channels) {
         if (t === void 0)
             continue;
-        else if (type2 === void 0)
-            type2 = t;
-        else if (type2 !== t)
-            throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);
+        else if (type3 === void 0)
+            type3 = t;
+        else if (type3 !== t)
+            throw new Error(`scale incompatible with channel: ${type3} !== ${t}`);
     }
-    if (type2 === typeProjection)
+    if (type3 === typeProjection2)
         return;
-    if (type2 !== void 0)
-        return type2;
+    if (type3 !== void 0)
+        return type3;
     if (domain === void 0 && !channels.some(({
             value
         }) => value !== void 0))
         return;
-    const kind = registry.get(key);
-    if (kind === radius)
+    const kind = registry2.get(key);
+    if (kind === radius2)
         return "sqrt";
-    if (kind === opacity || kind === length3)
+    if (kind === opacity2 || kind === length6)
         return "linear";
-    if (kind === symbol)
+    if (kind === symbol2)
         return "ordinal";
-    if ((domain || range5 || []).length > 2)
-        return asOrdinalType(kind);
+    if ((domain || range9 || []).length > 2)
+        return asOrdinalType2(kind);
     if (domain !== void 0) {
-        if (isOrdinal(domain))
-            return asOrdinalType(kind);
-        if (isTemporal(domain))
+        if (isOrdinal2(domain))
+            return asOrdinalType2(kind);
+        if (isTemporal2(domain))
             return "utc";
-        if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))
+        if (kind === color4 && (pivot != null || isDivergingScheme2(scheme55)))
             return "diverging";
         return "linear";
     }
-    const values2 = channels.map(({
+    const values3 = channels.map(({
         value
     }) => value).filter((value) => value !== void 0);
-    if (values2.some(isOrdinal))
-        return asOrdinalType(kind);
-    if (values2.some(isTemporal))
+    if (values3.some(isOrdinal2))
+        return asOrdinalType2(kind);
+    if (values3.some(isTemporal2))
         return "utc";
-    if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))
+    if (kind === color4 && (pivot != null || isDivergingScheme2(scheme55)))
         return "diverging";
     return "linear";
 }
 
-function asOrdinalType(kind) {
+function asOrdinalType2(kind) {
     switch (kind) {
-        case position:
+        case position2:
             return "point";
-        case color2:
-            return ordinalImplicit;
+        case color4:
+            return ordinalImplicit2;
         default:
             return "ordinal";
     }
 }
 
-function isTemporalScale({
-    type: type2
+function isTemporalScale2({
+    type: type3
 }) {
-    return type2 === "time" || type2 === "utc";
+    return type3 === "time" || type3 === "utc";
 }
 
-function isOrdinalScale({
-    type: type2
+function isOrdinalScale2({
+    type: type3
 }) {
-    return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
+    return type3 === "ordinal" || type3 === "point" || type3 === "band" || type3 === ordinalImplicit2;
 }
 
-function isThresholdScale({
-    type: type2
+function isThresholdScale2({
+    type: type3
 }) {
-    return type2 === "threshold";
+    return type3 === "threshold";
 }
 
-function isBandScale({
-    type: type2
+function isBandScale2({
+    type: type3
 }) {
-    return type2 === "point" || type2 === "band";
+    return type3 === "point" || type3 === "band";
 }
 
-function isCollapsed(scale3) {
-    if (scale3 === void 0)
+function isCollapsed2(scale5) {
+    if (scale5 === void 0)
         return true;
-    const domain = scale3.domain();
-    const value = scale3(domain[0]);
+    const domain = scale5.domain();
+    const value = scale5(domain[0]);
     for (let i = 1, n = domain.length; i < n; ++i) {
-        if (scale3(domain[i]) - value) {
+        if (scale5(domain[i]) - value) {
             return false;
         }
     }
     return true;
 }
 
-function coerceType(channels, {
+function coerceType2(channels, {
     domain,
     ...options
 }, coerceValues) {
-    for (const c6 of channels) {
-        if (c6.value !== void 0) {
-            c6.value = coerceValues(c6.value);
+    for (const c11 of channels) {
+        if (c11.value !== void 0) {
+            c11.value = coerceValues(c11.value);
         }
     }
     return {
         domain: domain === void 0 ? domain : coerceValues(domain),
         ...options
     };
 }
 
-function coerceSymbols(values2) {
-    return map4(values2, maybeSymbol);
+function coerceSymbols2(values3) {
+    return map9(values3, maybeSymbol2);
 }
 
-function scale2(options = {}) {
-    let scale3;
+function scale4(options = {}) {
+    let scale5;
     for (const key in options) {
-        if (!registry.has(key))
+        if (!registry2.has(key))
             continue;
-        if (!isScaleOptions(options[key]))
+        if (!isScaleOptions2(options[key]))
             continue;
-        if (scale3 !== void 0)
+        if (scale5 !== void 0)
             throw new Error("ambiguous scale definition; multiple scales found");
-        scale3 = exposeScale(normalizeScale(key, options[key]));
+        scale5 = exposeScale2(normalizeScale2(key, options[key]));
     }
-    if (scale3 === void 0)
+    if (scale5 === void 0)
         throw new Error("invalid scale definition; no scale found");
-    return scale3;
+    return scale5;
 }
 
-function exposeScales(scaleDescriptors) {
+function exposeScales2(scaleDescriptors) {
     return (key) => {
-        if (!registry.has(key = `${key}`))
+        if (!registry2.has(key = `${key}`))
             throw new Error(`unknown scale: ${key}`);
-        return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;
+        return key in scaleDescriptors ? exposeScale2(scaleDescriptors[key]) : void 0;
     };
 }
 
-function exposeScale({
-    scale: scale3,
-    type: type2,
+function exposeScale2({
+    scale: scale5,
+    type: type3,
     domain,
-    range: range5,
+    range: range9,
     interpolate,
-    interval: interval2,
-    transform: transform2,
+    interval: interval3,
+    transform: transform3,
     percent,
     pivot
 }) {
-    if (type2 === "identity")
+    if (type3 === "identity")
         return {
             type: "identity",
             apply: (d) => d,
             invert: (d) => d
         };
-    const unknown = scale3.unknown ? scale3.unknown() : void 0;
+    const unknown = scale5.unknown ? scale5.unknown() : void 0;
     return {
-        type: type2,
-        domain: slice5(domain),
+        type: type3,
+        domain: slice11(domain),
         // defensive copy
-        ...range5 !== void 0 && {
-            range: slice5(range5)
+        ...range9 !== void 0 && {
+            range: slice11(range9)
         },
         // defensive copy
-        ...transform2 !== void 0 && {
-            transform: transform2
+        ...transform3 !== void 0 && {
+            transform: transform3
         },
         ...percent && {
             percent
         },
         // only exposed if truthy
         ...unknown !== void 0 && {
             unknown
         },
-        ...interval2 !== void 0 && {
-            interval: interval2
+        ...interval3 !== void 0 && {
+            interval: interval3
         },
         // quantitative
         ...interpolate !== void 0 && {
             interpolate
         },
-        ...scale3.clamp && {
-            clamp: scale3.clamp()
+        ...scale5.clamp && {
+            clamp: scale5.clamp()
         },
         // diverging (always asymmetric; we never want to apply the symmetric transform twice)
         ...pivot !== void 0 && {
             pivot,
             symmetric: false
         },
         // log, diverging-log
-        ...scale3.base && {
-            base: scale3.base()
+        ...scale5.base && {
+            base: scale5.base()
         },
         // pow, diverging-pow
-        ...scale3.exponent && {
-            exponent: scale3.exponent()
+        ...scale5.exponent && {
+            exponent: scale5.exponent()
         },
         // symlog, diverging-symlog
-        ...scale3.constant && {
-            constant: scale3.constant()
+        ...scale5.constant && {
+            constant: scale5.constant()
         },
         // band, point
-        ...scale3.align && {
-            align: scale3.align(),
-            round: scale3.round()
-        },
-        ...scale3.padding && (scale3.paddingInner ? {
-            paddingInner: scale3.paddingInner(),
-            paddingOuter: scale3.paddingOuter()
+        ...scale5.align && {
+            align: scale5.align(),
+            round: scale5.round()
+        },
+        ...scale5.padding && (scale5.paddingInner ? {
+            paddingInner: scale5.paddingInner(),
+            paddingOuter: scale5.paddingOuter()
         } : {
-            padding: scale3.padding()
+            padding: scale5.padding()
         }),
-        ...scale3.bandwidth && {
-            bandwidth: scale3.bandwidth(),
-            step: scale3.step()
+        ...scale5.bandwidth && {
+            bandwidth: scale5.bandwidth(),
+            step: scale5.step()
         },
         // utilities
-        apply: (t) => scale3(t),
-        ...scale3.invert && {
-            invert: (t) => scale3.invert(t)
+        apply: (t) => scale5(t),
+        ...scale5.invert && {
+            invert: (t) => scale5.invert(t)
         }
     };
 }
 
-// node_modules/@observablehq/plot/src/memoize.js
-function memoize1(compute) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/memoize.js
+function memoize12(compute) {
     let cacheValue, cacheKeys;
     return (...keys) => {
-        if (cacheKeys?.length !== keys.length || cacheKeys.some((k2, i) => k2 !== keys[i])) {
+        if (cacheKeys?.length !== keys.length || cacheKeys.some((k3, i) => k3 !== keys[i])) {
             cacheKeys = keys;
             cacheValue = compute(...keys);
         }
         return cacheValue;
     };
 }
 
-// node_modules/@observablehq/plot/src/format.js
-var numberFormat = memoize1((locale3) => {
-    return new Intl.NumberFormat(locale3);
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/format.js
+var numberFormat2 = memoize12((locale5) => {
+    return new Intl.NumberFormat(locale5);
 });
-var monthFormat = memoize1((locale3, month) => {
-    return new Intl.DateTimeFormat(locale3, {
+var monthFormat2 = memoize12((locale5, month) => {
+    return new Intl.DateTimeFormat(locale5, {
         timeZone: "UTC",
         ...month && {
             month
         }
     });
 });
-var weekdayFormat = memoize1((locale3, weekday) => {
-    return new Intl.DateTimeFormat(locale3, {
+var weekdayFormat2 = memoize12((locale5, weekday) => {
+    return new Intl.DateTimeFormat(locale5, {
         timeZone: "UTC",
         ...weekday && {
             weekday
         }
     });
 });
 
-function formatNumber(locale3 = "en-US") {
-    const format3 = numberFormat(locale3);
-    return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;
+function formatNumber2(locale5 = "en-US") {
+    const format5 = numberFormat2(locale5);
+    return (i) => i != null && !isNaN(i) ? format5.format(i) : void 0;
 }
 
-function formatMonth(locale3 = "en-US", format3 = "short") {
-    const fmt = monthFormat(locale3, format3);
+function formatMonth2(locale5 = "en-US", format5 = "short") {
+    const fmt = monthFormat2(locale5, format5);
     return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;
 }
 
-function formatWeekday(locale3 = "en-US", format3 = "short") {
-    const fmt = weekdayFormat(locale3, format3);
+function formatWeekday2(locale5 = "en-US", format5 = "short") {
+    const fmt = weekdayFormat2(locale5, format5);
     return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;
 }
 
-function formatIsoDate(date2) {
-    return format2(date2, "Invalid Date");
+function formatIsoDate2(date3) {
+    return format4(date3, "Invalid Date");
 }
 
-function formatAuto(locale3 = "en-US") {
-    const number7 = formatNumber(locale3);
-    return (v2) => (v2 instanceof Date ? formatIsoDate : typeof v2 === "number" ? number7 : string)(v2);
+function formatAuto2(locale5 = "en-US") {
+    const number14 = formatNumber2(locale5);
+    return (v3) => (v3 instanceof Date ? formatIsoDate2 : typeof v3 === "number" ? number14 : string2)(v3);
 }
-var formatDefault = formatAuto();
+var formatDefault2 = formatAuto2();
 
-// node_modules/@observablehq/plot/src/style.js
-var offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5;
-var nextClipId = 0;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/style.js
+var offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5;
+var nextClipId2 = 0;
 
-function getClipId() {
-    return `plot-clip-${++nextClipId}`;
+function getClipId2() {
+    return `plot-clip-${++nextClipId2}`;
 }
 
-function styles(mark, {
+function styles2(mark, {
     title,
     href,
     ariaLabel: variaLabel,
     ariaDescription,
     ariaHidden,
     target,
     fill,
@@ -24815,15 +59521,15 @@
     strokeWidth,
     strokeOpacity,
     strokeLinejoin,
     strokeLinecap,
     strokeMiterlimit,
     strokeDasharray,
     strokeDashoffset,
-    opacity: opacity2,
+    opacity: opacity3,
     mixBlendMode,
     paintOrder,
     pointerEvents,
     shapeRendering
 }, {
     ariaLabel: cariaLabel,
     fill: defaultFill = "currentColor",
@@ -24840,62 +59546,62 @@
         fill = null;
         fillOpacity = null;
     }
     if (defaultStroke === null) {
         stroke = null;
         strokeOpacity = null;
     }
-    if (isNoneish(defaultFill)) {
-        if (!isNoneish(defaultStroke) && !isNoneish(fill))
+    if (isNoneish2(defaultFill)) {
+        if (!isNoneish2(defaultStroke) && !isNoneish2(fill))
             defaultStroke = "none";
     } else {
-        if (isNoneish(defaultStroke) && !isNoneish(stroke))
+        if (isNoneish2(defaultStroke) && !isNoneish2(stroke))
             defaultFill = "none";
     }
-    const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
-    const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
-    const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
-    const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
-    const [vopacity, copacity] = maybeNumberChannel(opacity2);
-    if (!isNone(cstroke)) {
+    const [vfill, cfill] = maybeColorChannel2(fill, defaultFill);
+    const [vfillOpacity, cfillOpacity] = maybeNumberChannel2(fillOpacity, defaultFillOpacity);
+    const [vstroke, cstroke] = maybeColorChannel2(stroke, defaultStroke);
+    const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel2(strokeOpacity, defaultStrokeOpacity);
+    const [vopacity, copacity] = maybeNumberChannel2(opacity3);
+    if (!isNone2(cstroke)) {
         if (strokeWidth === void 0)
             strokeWidth = defaultStrokeWidth;
         if (strokeLinecap === void 0)
             strokeLinecap = defaultStrokeLinecap;
         if (strokeLinejoin === void 0)
             strokeLinejoin = defaultStrokeLinejoin;
-        if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
+        if (strokeMiterlimit === void 0 && !isRound2(strokeLinejoin))
             strokeMiterlimit = defaultStrokeMiterlimit;
-        if (!isNone(cfill) && paintOrder === void 0)
+        if (!isNone2(cfill) && paintOrder === void 0)
             paintOrder = defaultPaintOrder;
     }
-    const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
+    const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel2(strokeWidth);
     if (defaultFill !== null) {
-        mark.fill = impliedString(cfill, "currentColor");
-        mark.fillOpacity = impliedNumber(cfillOpacity, 1);
+        mark.fill = impliedString2(cfill, "currentColor");
+        mark.fillOpacity = impliedNumber2(cfillOpacity, 1);
     }
     if (defaultStroke !== null) {
-        mark.stroke = impliedString(cstroke, "none");
-        mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
-        mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
-        mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
-        mark.strokeLinecap = impliedString(strokeLinecap, "butt");
-        mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
-        mark.strokeDasharray = impliedString(strokeDasharray, "none");
-        mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
-    }
-    mark.target = string(target);
-    mark.ariaLabel = string(cariaLabel);
-    mark.ariaDescription = string(ariaDescription);
-    mark.ariaHidden = string(ariaHidden);
-    mark.opacity = impliedNumber(copacity, 1);
-    mark.mixBlendMode = impliedString(mixBlendMode, "normal");
-    mark.paintOrder = impliedString(paintOrder, "normal");
-    mark.pointerEvents = impliedString(pointerEvents, "auto");
-    mark.shapeRendering = impliedString(shapeRendering, "auto");
+        mark.stroke = impliedString2(cstroke, "none");
+        mark.strokeWidth = impliedNumber2(cstrokeWidth, 1);
+        mark.strokeOpacity = impliedNumber2(cstrokeOpacity, 1);
+        mark.strokeLinejoin = impliedString2(strokeLinejoin, "miter");
+        mark.strokeLinecap = impliedString2(strokeLinecap, "butt");
+        mark.strokeMiterlimit = impliedNumber2(strokeMiterlimit, 4);
+        mark.strokeDasharray = impliedString2(strokeDasharray, "none");
+        mark.strokeDashoffset = impliedString2(strokeDashoffset, "0");
+    }
+    mark.target = string2(target);
+    mark.ariaLabel = string2(cariaLabel);
+    mark.ariaDescription = string2(ariaDescription);
+    mark.ariaHidden = string2(ariaHidden);
+    mark.opacity = impliedNumber2(copacity, 1);
+    mark.mixBlendMode = impliedString2(mixBlendMode, "normal");
+    mark.paintOrder = impliedString2(paintOrder, "normal");
+    mark.pointerEvents = impliedString2(pointerEvents, "auto");
+    mark.shapeRendering = impliedString2(shapeRendering, "auto");
     return {
         title: {
             value: title,
             optional: true
         },
         href: {
             value: href,
@@ -24933,304 +59639,304 @@
             value: vopacity,
             scale: "auto",
             optional: true
         }
     };
 }
 
-function applyTitle(selection2, L) {
+function applyTitle2(selection3, L) {
     if (L)
-        selection2.filter((i) => nonempty(L[i])).append("title").call(applyText, L);
+        selection3.filter((i) => nonempty2(L[i])).append("title").call(applyText2, L);
 }
 
-function applyTitleGroup(selection2, L) {
+function applyTitleGroup2(selection3, L) {
     if (L)
-        selection2.filter(([i]) => nonempty(L[i])).append("title").call(applyTextGroup, L);
+        selection3.filter(([i]) => nonempty2(L[i])).append("title").call(applyTextGroup2, L);
 }
 
-function applyText(selection2, T) {
+function applyText2(selection3, T) {
     if (T)
-        selection2.text((i) => formatDefault(T[i]));
+        selection3.text((i) => formatDefault2(T[i]));
 }
 
-function applyTextGroup(selection2, T) {
+function applyTextGroup2(selection3, T) {
     if (T)
-        selection2.text(([i]) => formatDefault(T[i]));
+        selection3.text(([i]) => formatDefault2(T[i]));
 }
 
-function applyChannelStyles(selection2, {
+function applyChannelStyles2(selection3, {
     target
 }, {
     ariaLabel: AL,
     title: T,
     fill: F,
     fillOpacity: FO,
     stroke: S,
     strokeOpacity: SO,
     strokeWidth: SW,
     opacity: O,
     href: H
 }) {
     if (AL)
-        applyAttr(selection2, "aria-label", (i) => AL[i]);
+        applyAttr2(selection3, "aria-label", (i) => AL[i]);
     if (F)
-        applyAttr(selection2, "fill", (i) => F[i]);
+        applyAttr2(selection3, "fill", (i) => F[i]);
     if (FO)
-        applyAttr(selection2, "fill-opacity", (i) => FO[i]);
+        applyAttr2(selection3, "fill-opacity", (i) => FO[i]);
     if (S)
-        applyAttr(selection2, "stroke", (i) => S[i]);
+        applyAttr2(selection3, "stroke", (i) => S[i]);
     if (SO)
-        applyAttr(selection2, "stroke-opacity", (i) => SO[i]);
+        applyAttr2(selection3, "stroke-opacity", (i) => SO[i]);
     if (SW)
-        applyAttr(selection2, "stroke-width", (i) => SW[i]);
+        applyAttr2(selection3, "stroke-width", (i) => SW[i]);
     if (O)
-        applyAttr(selection2, "opacity", (i) => O[i]);
+        applyAttr2(selection3, "opacity", (i) => O[i]);
     if (H)
-        applyHref(selection2, (i) => H[i], target);
-    applyTitle(selection2, T);
+        applyHref2(selection3, (i) => H[i], target);
+    applyTitle2(selection3, T);
 }
 
-function applyGroupedChannelStyles(selection2, {
+function applyGroupedChannelStyles2(selection3, {
     target
 }, {
     ariaLabel: AL,
     title: T,
     fill: F,
     fillOpacity: FO,
     stroke: S,
     strokeOpacity: SO,
     strokeWidth: SW,
     opacity: O,
     href: H
 }) {
     if (AL)
-        applyAttr(selection2, "aria-label", ([i]) => AL[i]);
+        applyAttr2(selection3, "aria-label", ([i]) => AL[i]);
     if (F)
-        applyAttr(selection2, "fill", ([i]) => F[i]);
+        applyAttr2(selection3, "fill", ([i]) => F[i]);
     if (FO)
-        applyAttr(selection2, "fill-opacity", ([i]) => FO[i]);
+        applyAttr2(selection3, "fill-opacity", ([i]) => FO[i]);
     if (S)
-        applyAttr(selection2, "stroke", ([i]) => S[i]);
+        applyAttr2(selection3, "stroke", ([i]) => S[i]);
     if (SO)
-        applyAttr(selection2, "stroke-opacity", ([i]) => SO[i]);
+        applyAttr2(selection3, "stroke-opacity", ([i]) => SO[i]);
     if (SW)
-        applyAttr(selection2, "stroke-width", ([i]) => SW[i]);
+        applyAttr2(selection3, "stroke-width", ([i]) => SW[i]);
     if (O)
-        applyAttr(selection2, "opacity", ([i]) => O[i]);
+        applyAttr2(selection3, "opacity", ([i]) => O[i]);
     if (H)
-        applyHref(selection2, ([i]) => H[i], target);
-    applyTitleGroup(selection2, T);
+        applyHref2(selection3, ([i]) => H[i], target);
+    applyTitleGroup2(selection3, T);
 }
 
-function groupAesthetics({
+function groupAesthetics2({
     ariaLabel: AL,
     title: T,
     fill: F,
     fillOpacity: FO,
     stroke: S,
     strokeOpacity: SO,
     strokeWidth: SW,
     opacity: O,
     href: H
 }) {
-    return [AL, T, F, FO, S, SO, SW, O, H].filter((c6) => c6 !== void 0);
+    return [AL, T, F, FO, S, SO, SW, O, H].filter((c11) => c11 !== void 0);
 }
 
-function groupZ2(I, Z, z) {
-    const G = group(I, (i) => Z[i]);
+function groupZ4(I, Z, z) {
+    const G = group3(I, (i) => Z[i]);
     if (z === void 0 && G.size > I.length >> 1) {
-        warn(
+        warn2(
             `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
         );
     }
     return G.values();
 }
 
-function* groupIndex(I, position2, {
+function* groupIndex2(I, position3, {
     z
 }, channels) {
     const {
         z: Z
     } = channels;
-    const A5 = groupAesthetics(channels);
-    const C3 = [...position2, ...A5];
-    for (const G of Z ? groupZ2(I, Z, z) : [I]) {
+    const A6 = groupAesthetics2(channels);
+    const C4 = [...position3, ...A6];
+    for (const G of Z ? groupZ4(I, Z, z) : [I]) {
         let Ag;
         let Gg;
         out:
             for (const i of G) {
-                for (const c6 of C3) {
-                    if (!defined(c6[i])) {
+                for (const c11 of C4) {
+                    if (!defined2(c11[i])) {
                         if (Gg)
                             Gg.push(-1);
                         continue out;
                     }
                 }
                 if (Ag === void 0) {
                     if (Gg)
                         yield Gg;
-                    Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];
+                    Ag = A6.map((c11) => keyof4(c11[i])), Gg = [i];
                     continue;
                 }
                 Gg.push(i);
-                for (let j = 0; j < A5.length; ++j) {
-                    const k2 = keyof2(A5[j][i]);
-                    if (k2 !== Ag[j]) {
+                for (let j = 0; j < A6.length; ++j) {
+                    const k3 = keyof4(A6[j][i]);
+                    if (k3 !== Ag[j]) {
                         yield Gg;
-                        Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];
+                        Ag = A6.map((c11) => keyof4(c11[i])), Gg = [i];
                         continue out;
                     }
                 }
             }
         if (Gg)
             yield Gg;
     }
 }
 
-function maybeClip(clip) {
+function maybeClip2(clip) {
     if (clip === true)
         clip = "frame";
     else if (clip === false)
         clip = null;
-    return maybeKeyword(clip, "clip", ["frame", "sphere"]);
+    return maybeKeyword2(clip, "clip", ["frame", "sphere"]);
 }
 
-function applyClip(selection2, mark, dimensions, context) {
+function applyClip2(selection3, mark, dimensions, context) {
     let clipUrl;
     switch (mark.clip) {
         case "frame": {
             const {
                 width,
                 height,
                 marginLeft,
                 marginRight,
                 marginTop,
                 marginBottom
             } = dimensions;
-            const id2 = getClipId();
-            clipUrl = `url(#${id2})`;
-            selection2 = create2("svg:g", context).call(
-                (g) => g.append("svg:clipPath").attr("id", id2).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
+            const id3 = getClipId2();
+            clipUrl = `url(#${id3})`;
+            selection3 = create4("svg:g", context).call(
+                (g) => g.append("svg:clipPath").attr("id", id3).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
             ).each(function() {
-                this.appendChild(selection2.node());
-                selection2.node = () => this;
+                this.appendChild(selection3.node());
+                selection3.node = () => this;
             });
             break;
         }
         case "sphere": {
             const {
-                projection: projection2
+                projection: projection3
             } = context;
-            if (!projection2)
+            if (!projection3)
                 throw new Error(`the "sphere" clip option requires a projection`);
-            const id2 = getClipId();
-            clipUrl = `url(#${id2})`;
-            selection2.append("clipPath").attr("id", id2).append("path").attr("d", path_default(projection2)({
+            const id3 = getClipId2();
+            clipUrl = `url(#${id3})`;
+            selection3.append("clipPath").attr("id", id3).append("path").attr("d", path_default3(projection3)({
                 type: "Sphere"
             }));
             break;
         }
     }
-    applyAttr(selection2, "aria-label", mark.ariaLabel);
-    applyAttr(selection2, "aria-description", mark.ariaDescription);
-    applyAttr(selection2, "aria-hidden", mark.ariaHidden);
-    applyAttr(selection2, "clip-path", clipUrl);
-}
-
-function applyIndirectStyles(selection2, mark, dimensions, context) {
-    applyClip(selection2, mark, dimensions, context);
-    applyAttr(selection2, "fill", mark.fill);
-    applyAttr(selection2, "fill-opacity", mark.fillOpacity);
-    applyAttr(selection2, "stroke", mark.stroke);
-    applyAttr(selection2, "stroke-width", mark.strokeWidth);
-    applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
-    applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
-    applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
-    applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
-    applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
-    applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
-    applyAttr(selection2, "shape-rendering", mark.shapeRendering);
-    applyAttr(selection2, "paint-order", mark.paintOrder);
-    applyAttr(selection2, "pointer-events", mark.pointerEvents);
-}
-
-function applyDirectStyles(selection2, mark) {
-    applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
-    applyAttr(selection2, "opacity", mark.opacity);
+    applyAttr2(selection3, "aria-label", mark.ariaLabel);
+    applyAttr2(selection3, "aria-description", mark.ariaDescription);
+    applyAttr2(selection3, "aria-hidden", mark.ariaHidden);
+    applyAttr2(selection3, "clip-path", clipUrl);
+}
+
+function applyIndirectStyles2(selection3, mark, dimensions, context) {
+    applyClip2(selection3, mark, dimensions, context);
+    applyAttr2(selection3, "fill", mark.fill);
+    applyAttr2(selection3, "fill-opacity", mark.fillOpacity);
+    applyAttr2(selection3, "stroke", mark.stroke);
+    applyAttr2(selection3, "stroke-width", mark.strokeWidth);
+    applyAttr2(selection3, "stroke-opacity", mark.strokeOpacity);
+    applyAttr2(selection3, "stroke-linejoin", mark.strokeLinejoin);
+    applyAttr2(selection3, "stroke-linecap", mark.strokeLinecap);
+    applyAttr2(selection3, "stroke-miterlimit", mark.strokeMiterlimit);
+    applyAttr2(selection3, "stroke-dasharray", mark.strokeDasharray);
+    applyAttr2(selection3, "stroke-dashoffset", mark.strokeDashoffset);
+    applyAttr2(selection3, "shape-rendering", mark.shapeRendering);
+    applyAttr2(selection3, "paint-order", mark.paintOrder);
+    applyAttr2(selection3, "pointer-events", mark.pointerEvents);
+}
+
+function applyDirectStyles2(selection3, mark) {
+    applyStyle2(selection3, "mix-blend-mode", mark.mixBlendMode);
+    applyAttr2(selection3, "opacity", mark.opacity);
 }
 
-function applyHref(selection2, href, target) {
-    selection2.each(function(i) {
+function applyHref2(selection3, href, target) {
+    selection3.each(function(i) {
         const h = href(i);
         if (h != null) {
-            const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
-            a4.setAttribute("fill", "inherit");
-            a4.setAttributeNS(namespaces_default.xlink, "href", h);
+            const a7 = this.ownerDocument.createElementNS(namespaces_default2.svg, "a");
+            a7.setAttribute("fill", "inherit");
+            a7.setAttributeNS(namespaces_default2.xlink, "href", h);
             if (target != null)
-                a4.setAttribute("target", target);
-            this.parentNode.insertBefore(a4, this).appendChild(this);
+                a7.setAttribute("target", target);
+            this.parentNode.insertBefore(a7, this).appendChild(this);
         }
     });
 }
 
-function applyAttr(selection2, name, value) {
+function applyAttr2(selection3, name, value) {
     if (value != null)
-        selection2.attr(name, value);
+        selection3.attr(name, value);
 }
 
-function applyStyle(selection2, name, value) {
+function applyStyle2(selection3, name, value) {
     if (value != null)
-        selection2.style(name, value);
+        selection3.style(name, value);
 }
 
-function applyTransform(selection2, mark, {
-    x: x4,
-    y: y4
-}, tx = offset, ty = offset) {
+function applyTransform2(selection3, mark, {
+    x: x7,
+    y: y7
+}, tx = offset2, ty = offset2) {
     tx += mark.dx;
     ty += mark.dy;
-    if (x4?.bandwidth)
-        tx += x4.bandwidth() / 2;
-    if (y4?.bandwidth)
-        ty += y4.bandwidth() / 2;
+    if (x7?.bandwidth)
+        tx += x7.bandwidth() / 2;
+    if (y7?.bandwidth)
+        ty += y7.bandwidth() / 2;
     if (tx || ty)
-        selection2.attr("transform", `translate(${tx},${ty})`);
+        selection3.attr("transform", `translate(${tx},${ty})`);
 }
 
-function impliedString(value, impliedValue) {
-    if ((value = string(value)) !== impliedValue)
+function impliedString2(value, impliedValue) {
+    if ((value = string2(value)) !== impliedValue)
         return value;
 }
 
-function impliedNumber(value, impliedValue) {
-    if ((value = number5(value)) !== impliedValue)
+function impliedNumber2(value, impliedValue) {
+    if ((value = number11(value)) !== impliedValue)
         return value;
 }
-var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
+var validClassName2 = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
 
-function maybeClassName(name) {
+function maybeClassName2(name) {
     if (name === void 0)
         return `plot-${Math.random().toString(16).slice(2)}`;
     name = `${name}`;
-    if (!validClassName.test(name))
+    if (!validClassName2.test(name))
         throw new Error(`invalid class name: ${name}`);
     return name;
 }
 
-function applyInlineStyles(selection2, style) {
+function applyInlineStyles2(selection3, style) {
     if (typeof style === "string") {
-        selection2.property("style", style);
+        selection3.property("style", style);
     } else if (style != null) {
-        for (const element of selection2) {
+        for (const element of selection3) {
             Object.assign(element.style, style);
         }
     }
 }
 
-function applyFrameAnchor({
+function applyFrameAnchor2({
     frameAnchor
 }, {
     width,
     height,
     marginTop,
     marginRight,
     marginBottom,
@@ -25238,27 +59944,27 @@
 }) {
     return [
         /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
         /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
     ];
 }
 
-// node_modules/@observablehq/plot/src/dimensions.js
-function createDimensions(scales, marks2, options = {}) {
-    let marginTopDefault = 0.5 - offset,
-        marginRightDefault = 0.5 + offset,
-        marginBottomDefault = 0.5 + offset,
-        marginLeftDefault = 0.5 - offset;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/dimensions.js
+function createDimensions2(scales, marks3, options = {}) {
+    let marginTopDefault = 0.5 - offset2,
+        marginRightDefault = 0.5 + offset2,
+        marginBottomDefault = 0.5 + offset2,
+        marginLeftDefault = 0.5 - offset2;
     for (const {
             marginTop: marginTop2,
             marginRight: marginRight2,
             marginBottom: marginBottom2,
             marginLeft: marginLeft2
         }
-        of marks2) {
+        of marks3) {
         if (marginTop2 > marginTopDefault)
             marginTopDefault = marginTop2;
         if (marginRight2 > marginRightDefault)
             marginRightDefault = marginRight2;
         if (marginBottom2 > marginBottomDefault)
             marginBottomDefault = marginBottom2;
         if (marginLeft2 > marginLeftDefault)
@@ -25273,15 +59979,15 @@
     } = options;
     marginTop = +marginTop;
     marginRight = +marginRight;
     marginBottom = +marginBottom;
     marginLeft = +marginLeft;
     let {
         width = 640,
-            height = autoHeight(scales, marks2, options, {
+            height = autoHeight2(scales, marks3, options, {
                 width,
                 marginTopDefault,
                 marginRightDefault,
                 marginBottomDefault,
                 marginLeftDefault
             }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
     } = options;
@@ -25313,465 +60019,465 @@
             marginBottom: facetMarginBottom,
             marginLeft: facetMarginLeft
         };
     }
     return dimensions;
 }
 
-function autoHeight({
-    x: x4,
-    y: y4,
+function autoHeight2({
+    x: x7,
+    y: y7,
     fy,
     fx
-}, marks2, {
-    projection: projection2,
+}, marks3, {
+    projection: projection3,
     aspectRatio
 }, {
     width,
     marginTopDefault,
     marginRightDefault,
     marginBottomDefault,
     marginLeftDefault
 }) {
     const nfy = fy ? fy.scale.domain().length : 1;
-    const ar = projectionAspectRatio(projection2, marks2);
+    const ar = projectionAspectRatio2(projection3, marks3);
     if (ar) {
         const nfx = fx ? fx.scale.domain().length : 1;
         const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
         const lar = Math.max(0.1, Math.min(10, far));
         return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
     }
-    const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;
+    const ny = y7 ? isOrdinalScale2(y7) ? y7.scale.domain().length : Math.max(7, 17 / nfy) : 1;
     if (aspectRatio != null) {
         aspectRatio = +aspectRatio;
         if (!(isFinite(aspectRatio) && aspectRatio > 0))
             throw new Error(`invalid aspectRatio: ${aspectRatio}`);
-        const ratio = aspectRatioLength("y", y4) / (aspectRatioLength("x", x4) * aspectRatio);
+        const ratio = aspectRatioLength2("y", y7) / (aspectRatioLength2("x", x7) * aspectRatio);
         const fxb = fx ? fx.scale.bandwidth() : 1;
         const fyb = fy ? fy.scale.bandwidth() : 1;
-        const w = fxb * (width - marginLeftDefault - marginRightDefault) - x4.insetLeft - x4.insetRight;
-        return (ratio * w + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
+        const w = fxb * (width - marginLeftDefault - marginRightDefault) - x7.insetLeft - x7.insetRight;
+        return (ratio * w + y7.insetTop + y7.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
     }
-    return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
+    return !!(y7 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
 }
 
-function aspectRatioLength(k2, scale3) {
-    if (!scale3)
-        throw new Error(`aspectRatio requires ${k2} scale`);
+function aspectRatioLength2(k3, scale5) {
+    if (!scale5)
+        throw new Error(`aspectRatio requires ${k3} scale`);
     const {
-        type: type2,
+        type: type3,
         domain
-    } = scale3;
-    let transform2;
-    switch (type2) {
+    } = scale5;
+    let transform3;
+    switch (type3) {
         case "linear":
         case "utc":
         case "time":
-            transform2 = Number;
+            transform3 = Number;
             break;
         case "pow": {
-            const exponent2 = scale3.scale.exponent();
-            transform2 = (x4) => Math.pow(x4, exponent2);
+            const exponent3 = scale5.scale.exponent();
+            transform3 = (x7) => Math.pow(x7, exponent3);
             break;
         }
         case "log":
-            transform2 = Math.log;
+            transform3 = Math.log;
             break;
         case "point":
         case "band":
             return domain.length;
         default:
-            throw new Error(`unsupported ${k2} scale for aspectRatio: ${type2}`);
+            throw new Error(`unsupported ${k3} scale for aspectRatio: ${type3}`);
     }
-    const [min4, max5] = extent(domain);
-    return Math.abs(transform2(max5) - transform2(min4));
+    const [min7, max9] = extent3(domain);
+    return Math.abs(transform3(max9) - transform3(min7));
 }
 
-// node_modules/@observablehq/plot/src/facet.js
-function createFacets(channelsByScale, options) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/facet.js
+function createFacets2(channelsByScale, options) {
     const {
         fx,
         fy
-    } = createScales(channelsByScale, options);
+    } = createScales2(channelsByScale, options);
     const fxDomain = fx?.scale.domain();
     const fyDomain = fy?.scale.domain();
-    return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x4, y4], i) => ({
-        x: x4,
-        y: y4,
+    return fxDomain && fyDomain ? cross2(fxDomain, fyDomain).map(([x7, y7], i) => ({
+        x: x7,
+        y: y7,
         i
-    })) : fxDomain ? fxDomain.map((x4, i) => ({
-        x: x4,
+    })) : fxDomain ? fxDomain.map((x7, i) => ({
+        x: x7,
         i
-    })) : fyDomain ? fyDomain.map((y4, i) => ({
-        y: y4,
+    })) : fyDomain ? fyDomain.map((y7, i) => ({
+        y: y7,
         i
     })) : void 0;
 }
 
-function facetOrder({
-    x: X3,
-    y: Y3
+function facetOrder2({
+    x: X4,
+    y: Y4
 }) {
-    const xi = X3 && new Map(X3.map((v2, i) => [v2, i]));
-    const yi = Y3 && new Map(Y3.map((v2, i) => [v2, i]));
-    return X3 && Y3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) || yi.get(a4.y) - yi.get(b.y) : X3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) : (a4, b) => yi.get(a4.y) - yi.get(b.y);
+    const xi = X4 && new Map(X4.map((v3, i) => [v3, i]));
+    const yi = Y4 && new Map(Y4.map((v3, i) => [v3, i]));
+    return X4 && Y4 ? (a7, b) => xi.get(a7.x) - xi.get(b.x) || yi.get(a7.y) - yi.get(b.y) : X4 ? (a7, b) => xi.get(a7.x) - xi.get(b.x) : (a7, b) => yi.get(a7.y) - yi.get(b.y);
 }
 
-function facetGroups(data, {
+function facetGroups2(data, {
     fx,
     fy
 }) {
-    const I = range4(data);
+    const I = range8(data);
     const FX = fx?.value;
     const FY = fy?.value;
-    return fx && fy ? rollup(
+    return fx && fy ? rollup2(
         I,
         (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
         (i) => FX[i],
         (i) => FY[i]
-    ) : fx ? rollup(
+    ) : fx ? rollup2(
         I,
         (G) => (G.fx = FX[G[0]], G),
         (i) => FX[i]
-    ) : rollup(
+    ) : rollup2(
         I,
         (G) => (G.fy = FY[G[0]], G),
         (i) => FY[i]
     );
 }
 
-function facetTranslate(fx, fy, {
+function facetTranslate2(fx, fy, {
     marginTop,
     marginLeft
 }) {
     return fx && fy ? ({
-        x: x4,
-        y: y4
-    }) => `translate(${fx(x4) - marginLeft},${fy(y4) - marginTop})` : fx ? ({
-        x: x4
-    }) => `translate(${fx(x4) - marginLeft},0)` : ({
-        y: y4
-    }) => `translate(0,${fy(y4) - marginTop})`;
+        x: x7,
+        y: y7
+    }) => `translate(${fx(x7) - marginLeft},${fy(y7) - marginTop})` : fx ? ({
+        x: x7
+    }) => `translate(${fx(x7) - marginLeft},0)` : ({
+        y: y7
+    }) => `translate(0,${fy(y7) - marginTop})`;
 }
 
-function facetExclude(index3) {
+function facetExclude2(index5) {
     const ex = [];
-    const e = new Uint32Array(sum(index3, (d) => d.length));
-    for (const i of index3) {
+    const e = new Uint32Array(sum4(index5, (d) => d.length));
+    for (const i of index5) {
         let n = 0;
-        for (const j of index3) {
+        for (const j of index5) {
             if (i === j)
                 continue;
             e.set(j, n);
             n += j.length;
         }
         ex.push(e.slice(0, n));
     }
     return ex;
 }
-var facetAnchors = /* @__PURE__ */ new Map([
-    ["top", facetAnchorTop],
-    ["right", facetAnchorRight],
-    ["bottom", facetAnchorBottom],
-    ["left", facetAnchorLeft],
-    ["top-left", and(facetAnchorTop, facetAnchorLeft)],
-    ["top-right", and(facetAnchorTop, facetAnchorRight)],
-    ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
-    ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
-    ["top-empty", facetAnchorTopEmpty],
-    ["right-empty", facetAnchorRightEmpty],
-    ["bottom-empty", facetAnchorBottomEmpty],
-    ["left-empty", facetAnchorLeftEmpty],
-    ["empty", facetAnchorEmpty]
+var facetAnchors2 = /* @__PURE__ */ new Map([
+    ["top", facetAnchorTop2],
+    ["right", facetAnchorRight2],
+    ["bottom", facetAnchorBottom2],
+    ["left", facetAnchorLeft2],
+    ["top-left", and2(facetAnchorTop2, facetAnchorLeft2)],
+    ["top-right", and2(facetAnchorTop2, facetAnchorRight2)],
+    ["bottom-left", and2(facetAnchorBottom2, facetAnchorLeft2)],
+    ["bottom-right", and2(facetAnchorBottom2, facetAnchorRight2)],
+    ["top-empty", facetAnchorTopEmpty2],
+    ["right-empty", facetAnchorRightEmpty2],
+    ["bottom-empty", facetAnchorBottomEmpty2],
+    ["left-empty", facetAnchorLeftEmpty2],
+    ["empty", facetAnchorEmpty2]
 ]);
 
-function maybeFacetAnchor(facetAnchor) {
+function maybeFacetAnchor2(facetAnchor) {
     if (facetAnchor == null)
         return null;
-    const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
+    const anchor = facetAnchors2.get(`${facetAnchor}`.toLowerCase());
     if (anchor)
         return anchor;
     throw new Error(`invalid facet anchor: ${facetAnchor}`);
 }
 
-function facetAnchorTop(facets, {
-    y: Y3
+function facetAnchorTop2(facets, {
+    y: Y4
 }, {
-    y: y4
+    y: y7
 }) {
-    return Y3 ? Y3.indexOf(y4) === 0 : true;
+    return Y4 ? Y4.indexOf(y7) === 0 : true;
 }
 
-function facetAnchorBottom(facets, {
-    y: Y3
+function facetAnchorBottom2(facets, {
+    y: Y4
 }, {
-    y: y4
+    y: y7
 }) {
-    return Y3 ? Y3.indexOf(y4) === Y3.length - 1 : true;
+    return Y4 ? Y4.indexOf(y7) === Y4.length - 1 : true;
 }
 
-function facetAnchorLeft(facets, {
-    x: X3
+function facetAnchorLeft2(facets, {
+    x: X4
 }, {
-    x: x4
+    x: x7
 }) {
-    return X3 ? X3.indexOf(x4) === 0 : true;
+    return X4 ? X4.indexOf(x7) === 0 : true;
 }
 
-function facetAnchorRight(facets, {
-    x: X3
+function facetAnchorRight2(facets, {
+    x: X4
 }, {
-    x: x4
+    x: x7
 }) {
-    return X3 ? X3.indexOf(x4) === X3.length - 1 : true;
+    return X4 ? X4.indexOf(x7) === X4.length - 1 : true;
 }
 
-function facetAnchorTopEmpty(facets, {
-    y: Y3
+function facetAnchorTopEmpty2(facets, {
+    y: Y4
 }, {
-    x: x4,
-    y: y4,
-    empty: empty4
+    x: x7,
+    y: y7,
+    empty: empty7
 }) {
-    if (empty4)
+    if (empty7)
         return false;
-    const i = Y3?.indexOf(y4);
+    const i = Y4?.indexOf(y7);
     if (i > 0) {
-        const y5 = Y3[i - 1];
-        return facets.find((f) => f.x === x4 && f.y === y5)?.empty;
+        const y8 = Y4[i - 1];
+        return facets.find((f) => f.x === x7 && f.y === y8)?.empty;
     }
 }
 
-function facetAnchorBottomEmpty(facets, {
-    y: Y3
+function facetAnchorBottomEmpty2(facets, {
+    y: Y4
 }, {
-    x: x4,
-    y: y4,
-    empty: empty4
+    x: x7,
+    y: y7,
+    empty: empty7
 }) {
-    if (empty4)
+    if (empty7)
         return false;
-    const i = Y3?.indexOf(y4);
-    if (i < Y3?.length - 1) {
-        const y5 = Y3[i + 1];
-        return facets.find((f) => f.x === x4 && f.y === y5)?.empty;
+    const i = Y4?.indexOf(y7);
+    if (i < Y4?.length - 1) {
+        const y8 = Y4[i + 1];
+        return facets.find((f) => f.x === x7 && f.y === y8)?.empty;
     }
 }
 
-function facetAnchorLeftEmpty(facets, {
-    x: X3
+function facetAnchorLeftEmpty2(facets, {
+    x: X4
 }, {
-    x: x4,
-    y: y4,
-    empty: empty4
+    x: x7,
+    y: y7,
+    empty: empty7
 }) {
-    if (empty4)
+    if (empty7)
         return false;
-    const i = X3?.indexOf(x4);
+    const i = X4?.indexOf(x7);
     if (i > 0) {
-        const x5 = X3[i - 1];
-        return facets.find((f) => f.x === x5 && f.y === y4)?.empty;
+        const x8 = X4[i - 1];
+        return facets.find((f) => f.x === x8 && f.y === y7)?.empty;
     }
 }
 
-function facetAnchorRightEmpty(facets, {
-    x: X3
+function facetAnchorRightEmpty2(facets, {
+    x: X4
 }, {
-    x: x4,
-    y: y4,
-    empty: empty4
+    x: x7,
+    y: y7,
+    empty: empty7
 }) {
-    if (empty4)
+    if (empty7)
         return false;
-    const i = X3?.indexOf(x4);
-    if (i < X3?.length - 1) {
-        const x5 = X3[i + 1];
-        return facets.find((f) => f.x === x5 && f.y === y4)?.empty;
+    const i = X4?.indexOf(x7);
+    if (i < X4?.length - 1) {
+        const x8 = X4[i + 1];
+        return facets.find((f) => f.x === x8 && f.y === y7)?.empty;
     }
 }
 
-function facetAnchorEmpty(facets, channels, {
-    empty: empty4
+function facetAnchorEmpty2(facets, channels, {
+    empty: empty7
 }) {
-    return empty4;
+    return empty7;
 }
 
-function and(a4, b) {
+function and2(a7, b) {
     return function() {
-        return a4.apply(null, arguments) && b.apply(null, arguments);
+        return a7.apply(null, arguments) && b.apply(null, arguments);
     };
 }
 
-function facetFilter(facets, {
+function facetFilter2(facets, {
     channels: {
         fx,
         fy
     },
-    groups: groups2
+    groups: groups3
 }) {
     return fx && fy ? facets.map(({
-        x: x4,
-        y: y4
-    }) => groups2.get(x4)?.get(y4) ?? []) : fx ? facets.map(({
-        x: x4
-    }) => groups2.get(x4) ?? []) : facets.map(({
-        y: y4
-    }) => groups2.get(y4) ?? []);
+        x: x7,
+        y: y7
+    }) => groups3.get(x7)?.get(y7) ?? []) : fx ? facets.map(({
+        x: x7
+    }) => groups3.get(x7) ?? []) : facets.map(({
+        y: y7
+    }) => groups3.get(y7) ?? []);
 }
 
-// node_modules/@observablehq/plot/src/axes.js
-function inferFontVariant(scale3) {
-    return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : "tabular-nums";
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/axes.js
+function inferFontVariant4(scale5) {
+    return isOrdinalScale2(scale5) && scale5.interval === void 0 ? void 0 : "tabular-nums";
 }
 
-function maybeAutoTickFormat(tickFormat2, domain) {
-    return tickFormat2 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat2 === "function" ? tickFormat2 : (typeof tickFormat2 === "string" ? isTemporal(domain) ? utcFormat : format : constant2)(tickFormat2);
+function maybeAutoTickFormat2(tickFormat3, domain) {
+    return tickFormat3 === void 0 ? isTemporal2(domain) ? formatIsoDate2 : string2 : typeof tickFormat3 === "function" ? tickFormat3 : (typeof tickFormat3 === "string" ? isTemporal2(domain) ? utcFormat2 : format3 : constant4)(tickFormat3);
 }
 
-// node_modules/@observablehq/plot/src/legends/ramp.js
-function legendRamp(color3, options) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/legends/ramp.js
+function legendRamp2(color5, options) {
     let {
-        label = color3.label,
+        label = color5.label,
             tickSize = 6,
             width = 240,
             height = 44 + tickSize,
             marginTop = 18,
             marginRight = 0,
             marginBottom = 16 + tickSize,
             marginLeft = 0,
             style,
-            ticks: ticks2 = (width - marginLeft - marginRight) / 64,
-            tickFormat: tickFormat2,
-            fontVariant = inferFontVariant(color3),
-            round: round2 = true,
-            opacity: opacity2,
+            ticks: ticks3 = (width - marginLeft - marginRight) / 64,
+            tickFormat: tickFormat3,
+            fontVariant = inferFontVariant4(color5),
+            round: round3 = true,
+            opacity: opacity3,
             className
     } = options;
-    const context = createContext(options);
-    className = maybeClassName(className);
-    opacity2 = maybeNumberChannel(opacity2)[1];
-    if (tickFormat2 === null)
-        tickFormat2 = () => null;
-    const svg2 = create2("svg", context).attr("class", className).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
-        (svg3) => svg3.append("style").text(`
+    const context = createContext2(options);
+    className = maybeClassName2(className);
+    opacity3 = maybeNumberChannel2(opacity3)[1];
+    if (tickFormat3 === null)
+        tickFormat3 = () => null;
+    const svg3 = create4("svg", context).attr("class", className).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
+        (svg4) => svg4.append("style").text(`
         .${className} {
           display: block;
           background: white;
           height: auto;
           height: intrinsic;
           max-width: 100%;
           overflow: visible;
         }
         .${className} text {
           white-space: pre;
         }
       `)
-    ).call(applyInlineStyles, style);
+    ).call(applyInlineStyles2, style);
     let tickAdjust = (g) => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
-    let x4;
-    const applyRange = round2 ? (x5, range6) => x5.rangeRound(range6) : (x5, range6) => x5.range(range6);
+    let x7;
+    const applyRange = round3 ? (x8, range10) => x8.rangeRound(range10) : (x8, range10) => x8.range(range10);
     const {
-        type: type2,
+        type: type3,
         domain,
-        range: range5,
+        range: range9,
         interpolate,
-        scale: scale3,
+        scale: scale5,
         pivot
-    } = color3;
+    } = color5;
     if (interpolate) {
-        const interpolator = range5 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range5);
-        x4 = applyRange(
-            scale3.copy(),
-            quantize_default(
-                number_default(marginLeft, width - marginRight),
-                Math.min(domain.length + (pivot !== void 0), range5 === void 0 ? Infinity : range5.length)
+        const interpolator = range9 === void 0 ? interpolate : piecewise2(interpolate.length === 1 ? interpolatePiecewise2(interpolate) : interpolate, range9);
+        x7 = applyRange(
+            scale5.copy(),
+            quantize_default2(
+                number_default2(marginLeft, width - marginRight),
+                Math.min(domain.length + (pivot !== void 0), range9 === void 0 ? Infinity : range9.length)
             )
         );
         const n = 256;
         const canvas = context.document.createElement("canvas");
         canvas.width = n;
         canvas.height = 1;
         const context2 = canvas.getContext("2d");
         for (let i = 0, j = n - 1; i < n; ++i) {
             context2.fillStyle = interpolator(i / j);
             context2.fillRect(i, 0, 1, 1);
         }
-        svg2.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
-    } else if (type2 === "threshold") {
+        svg3.append("image").attr("opacity", opacity3).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
+    } else if (type3 === "threshold") {
         const thresholds = domain;
-        const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
-        x4 = applyRange(linear3().domain([-1, range5.length - 1]), [marginLeft, width - marginRight]);
-        svg2.append("g").attr("fill-opacity", opacity2).selectAll().data(range5).enter().append("rect").attr("x", (d, i) => x4(i - 1)).attr("y", marginTop).attr("width", (d, i) => x4(i) - x4(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
-        ticks2 = map4(thresholds, (_, i) => i);
-        tickFormat2 = (i) => thresholdFormat(thresholds[i], i);
+        const thresholdFormat = tickFormat3 === void 0 ? (d) => d : typeof tickFormat3 === "string" ? format3(tickFormat3) : tickFormat3;
+        x7 = applyRange(linear6().domain([-1, range9.length - 1]), [marginLeft, width - marginRight]);
+        svg3.append("g").attr("fill-opacity", opacity3).selectAll().data(range9).enter().append("rect").attr("x", (d, i) => x7(i - 1)).attr("y", marginTop).attr("width", (d, i) => x7(i) - x7(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
+        ticks3 = map9(thresholds, (_, i) => i);
+        tickFormat3 = (i) => thresholdFormat(thresholds[i], i);
     } else {
-        x4 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
-        svg2.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x4).attr("y", marginTop).attr("width", Math.max(0, x4.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale3);
+        x7 = applyRange(band2().domain(domain), [marginLeft, width - marginRight]);
+        svg3.append("g").attr("fill-opacity", opacity3).selectAll().data(domain).enter().append("rect").attr("x", x7).attr("y", marginTop).attr("width", Math.max(0, x7.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale5);
         tickAdjust = () => {};
     }
-    svg2.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
-        axisBottom(x4).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
-    ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
+    svg3.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
+        axisBottom2(x7).ticks(Array.isArray(ticks3) ? null : ticks3, typeof tickFormat3 === "string" ? tickFormat3 : void 0).tickFormat(typeof tickFormat3 === "function" ? tickFormat3 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks3) ? ticks3 : null)
+    ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString2(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
     if (label !== void 0) {
-        svg2.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
+        svg3.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
     }
-    return svg2.node();
+    return svg3.node();
 }
 
-// node_modules/@observablehq/plot/src/legends/swatches.js
-function maybeScale(scale3, key) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/legends/swatches.js
+function maybeScale2(scale5, key) {
     if (key == null)
         return key;
-    const s2 = scale3(key);
-    if (!s2)
+    const s3 = scale5(key);
+    if (!s3)
         throw new Error(`scale not found: ${key}`);
-    return s2;
+    return s3;
 }
 
-function legendSwatches(color3, {
-    opacity: opacity2,
+function legendSwatches2(color5, {
+    opacity: opacity3,
     ...options
 } = {}) {
-    if (!isOrdinalScale(color3) && !isThresholdScale(color3))
-        throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
-    return legendItems(
-        color3,
+    if (!isOrdinalScale2(color5) && !isThresholdScale2(color5))
+        throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color5.type})`);
+    return legendItems2(
+        color5,
         options,
-        (selection2, scale3) => selection2.append("svg").attr("fill", scale3.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%"),
+        (selection3, scale5) => selection3.append("svg").attr("fill", scale5.scale).attr("fill-opacity", maybeNumberChannel2(opacity3)[1]).append("rect").attr("width", "100%").attr("height", "100%"),
         (className) => `.${className}-swatch svg {
         width: var(--swatchWidth);
         height: var(--swatchHeight);
         margin-right: 0.5em;
       }`
     );
 }
 
-function legendSymbols(symbol2, {
-    fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none",
+function legendSymbols2(symbol3, {
+    fill = symbol3.hint?.fill !== void 0 ? symbol3.hint.fill : "none",
     fillOpacity = 1,
-    stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
+    stroke = symbol3.hint?.stroke !== void 0 ? symbol3.hint.stroke : isNoneish2(fill) ? "currentColor" : "none",
     strokeOpacity = 1,
     strokeWidth = 1.5,
     r = 4.5,
     ...options
-} = {}, scale3) {
-    const [vf, cf] = maybeColorChannel(fill);
-    const [vs, cs] = maybeColorChannel(stroke);
-    const sf = maybeScale(scale3, vf);
-    const ss = maybeScale(scale3, vs);
+} = {}, scale5) {
+    const [vf, cf] = maybeColorChannel2(fill);
+    const [vs, cs] = maybeColorChannel2(stroke);
+    const sf = maybeScale2(scale5, vf);
+    const ss = maybeScale2(scale5, vs);
     const size = r * r * Math.PI;
-    fillOpacity = maybeNumberChannel(fillOpacity)[1];
-    strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
-    strokeWidth = maybeNumberChannel(strokeWidth)[1];
-    return legendItems(
-        symbol2,
+    fillOpacity = maybeNumberChannel2(fillOpacity)[1];
+    strokeOpacity = maybeNumberChannel2(strokeOpacity)[1];
+    strokeWidth = maybeNumberChannel2(strokeWidth)[1];
+    return legendItems2(
+        symbol3,
         options,
-        (selection2) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("fill", vf === "color" ? (d) => sf.scale(d) : null).attr("stroke", vs === "color" ? (d) => ss.scale(d) : null).append("path").attr("d", (d) => {
-            const p = pathRound();
-            symbol2.scale(d).draw(p, size);
+        (selection3) => selection3.append("svg").attr("viewBox", "-8 -8 16 16").attr("fill", vf === "color" ? (d) => sf.scale(d) : null).attr("stroke", vs === "color" ? (d) => ss.scale(d) : null).append("path").attr("d", (d) => {
+            const p = pathRound2();
+            symbol3.scale(d).draw(p, size);
             return p;
         }),
         (className) => `.${className}-swatch > svg {
         width: var(--swatchWidth);
         height: var(--swatchHeight);
         margin-right: 0.5em;
         overflow: visible;
@@ -25780,32 +60486,32 @@
         stroke: ${cs};
         stroke-width: ${strokeWidth}px;
         stroke-opacity: ${strokeOpacity};
       }`
     );
 }
 
-function legendItems(scale3, options = {}, swatch, swatchStyle) {
+function legendItems2(scale5, options = {}, swatch, swatchStyle) {
     let {
         columns,
-        tickFormat: tickFormat2,
-        fontVariant = inferFontVariant(scale3),
+        tickFormat: tickFormat3,
+        fontVariant = inferFontVariant4(scale5),
         // TODO label,
         swatchSize = 15,
         swatchWidth = swatchSize,
         swatchHeight = swatchSize,
         marginLeft = 0,
         className,
         style,
         width
     } = options;
-    const context = createContext(options);
-    className = maybeClassName(className);
-    tickFormat2 = maybeAutoTickFormat(tickFormat2, scale3.domain);
-    const swatches = create2("div", context).attr("class", className).attr(
+    const context = createContext2(options);
+    className = maybeClassName2(className);
+    tickFormat3 = maybeAutoTickFormat2(tickFormat3, scale5.domain);
+    const swatches = create4("div", context).attr("class", className).attr(
         "style",
         `
         --swatchWidth: ${+swatchWidth}px;
         --swatchHeight: ${+swatchHeight}px;
       `
     );
     let extraStyle;
@@ -25822,16 +60528,16 @@
       }
       .${className}-label {
         white-space: nowrap;
         overflow: hidden;
         text-overflow: ellipsis;
       }
     `;
-        swatches.style("columns", columns).selectAll().data(scale3.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale3).call(
-            (item) => item.append("div").attr("class", `${className}-label`).attr("title", tickFormat2).text(tickFormat2)
+        swatches.style("columns", columns).selectAll().data(scale5.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale5).call(
+            (item) => item.append("div").attr("class", `${className}-label`).attr("title", tickFormat3).text(tickFormat3)
         );
     } else {
         extraStyle = `
       .${className} {
         display: flex;
         align-items: center;
         min-height: 33px;
@@ -25839,862 +60545,862 @@
       }
       .${className}-swatch {
         display: inline-flex;
         align-items: center;
         margin-right: 1em;
       }
     `;
-        swatches.selectAll().data(scale3.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale3).append(function() {
-            return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
+        swatches.selectAll().data(scale5.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale5).append(function() {
+            return this.ownerDocument.createTextNode(tickFormat3.apply(this, arguments));
         });
     }
     return swatches.call(
         (div) => div.insert("style", "*").text(`
         .${className} {
           font-family: system-ui, sans-serif;
           font-size: 10px;
           margin-bottom: 0.5em;${marginLeft === void 0 ? "" : `
           margin-left: ${+marginLeft}px;`}${width === void 0 ? "" : `
           width: ${width}px;`}
         }
         ${swatchStyle(className)}
         ${extraStyle}
       `)
-    ).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
+    ).style("font-variant", impliedString2(fontVariant, "normal")).call(applyInlineStyles2, style).node();
 }
 
-// node_modules/@observablehq/plot/src/legends.js
-var legendRegistry = /* @__PURE__ */ new Map([
-    ["symbol", legendSymbols],
-    ["color", legendColor],
-    ["opacity", legendOpacity]
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/legends.js
+var legendRegistry2 = /* @__PURE__ */ new Map([
+    ["symbol", legendSymbols2],
+    ["color", legendColor2],
+    ["opacity", legendOpacity2]
 ]);
 
-function legend(options = {}) {
-    for (const [key, value] of legendRegistry) {
-        const scale3 = options[key];
-        if (isScaleOptions(scale3)) {
-            const context = createContext(options);
+function legend2(options = {}) {
+    for (const [key, value] of legendRegistry2) {
+        const scale5 = options[key];
+        if (isScaleOptions2(scale5)) {
+            const context = createContext2(options);
             let hint;
             if (key === "symbol") {
                 const {
                     fill,
-                    stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0
+                    stroke = fill === void 0 && isScaleOptions2(options.color) ? "color" : void 0
                 } = options;
                 hint = {
                     fill,
                     stroke
                 };
             }
             return value(
-                normalizeScale(key, scale3, hint),
-                legendOptions(context, scale3, options),
-                (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
+                normalizeScale2(key, scale5, hint),
+                legendOptions2(context, scale5, options),
+                (key2) => isScaleOptions2(options[key2]) ? normalizeScale2(key2, options[key2]) : null
             );
         }
     }
     throw new Error("unknown legend type; no scale found");
 }
 
-function exposeLegends(scales, context, defaults21 = {}) {
+function exposeLegends2(scales, context, defaults41 = {}) {
     return (key, options) => {
-        if (!legendRegistry.has(key))
+        if (!legendRegistry2.has(key))
             throw new Error(`unknown legend type: ${key}`);
         if (!(key in scales))
             return;
-        return legendRegistry.get(key)(scales[key], legendOptions(context, defaults21[key], options), (key2) => scales[key2]);
+        return legendRegistry2.get(key)(scales[key], legendOptions2(context, defaults41[key], options), (key2) => scales[key2]);
     };
 }
 
-function legendOptions(context, {
+function legendOptions2(context, {
     label,
-    ticks: ticks2,
-    tickFormat: tickFormat2
+    ticks: ticks3,
+    tickFormat: tickFormat3
 } = {}, options) {
-    return inherit2(options, context, {
+    return inherit4(options, context, {
         label,
-        ticks: ticks2,
-        tickFormat: tickFormat2
+        ticks: ticks3,
+        tickFormat: tickFormat3
     });
 }
 
-function legendColor(color3, {
-    legend: legend2 = true,
+function legendColor2(color5, {
+    legend: legend3 = true,
     ...options
 }) {
-    if (legend2 === true)
-        legend2 = color3.type === "ordinal" ? "swatches" : "ramp";
-    if (color3.domain === void 0)
+    if (legend3 === true)
+        legend3 = color5.type === "ordinal" ? "swatches" : "ramp";
+    if (color5.domain === void 0)
         return;
-    switch (`${legend2}`.toLowerCase()) {
+    switch (`${legend3}`.toLowerCase()) {
         case "swatches":
-            return legendSwatches(color3, options);
+            return legendSwatches2(color5, options);
         case "ramp":
-            return legendRamp(color3, options);
+            return legendRamp2(color5, options);
         default:
-            throw new Error(`unknown legend type: ${legend2}`);
+            throw new Error(`unknown legend type: ${legend3}`);
     }
 }
 
-function legendOpacity({
-    type: type2,
+function legendOpacity2({
+    type: type3,
     interpolate,
-    ...scale3
+    ...scale5
 }, {
-    legend: legend2 = true,
-    color: color3 = rgb(0, 0, 0),
+    legend: legend3 = true,
+    color: color5 = rgb2(0, 0, 0),
     ...options
 }) {
     if (!interpolate)
-        throw new Error(`${type2} opacity scales are not supported`);
-    if (legend2 === true)
-        legend2 = "ramp";
-    if (`${legend2}`.toLowerCase() !== "ramp")
-        throw new Error(`${legend2} opacity legends are not supported`);
-    return legendColor({
-        type: type2,
-        ...scale3,
-        interpolate: interpolateOpacity(color3)
+        throw new Error(`${type3} opacity scales are not supported`);
+    if (legend3 === true)
+        legend3 = "ramp";
+    if (`${legend3}`.toLowerCase() !== "ramp")
+        throw new Error(`${legend3} opacity legends are not supported`);
+    return legendColor2({
+        type: type3,
+        ...scale5,
+        interpolate: interpolateOpacity2(color5)
     }, {
-        legend: legend2,
+        legend: legend3,
         ...options
     });
 }
 
-function interpolateOpacity(color3) {
+function interpolateOpacity2(color5) {
     const {
         r,
         g,
         b
-    } = rgb(color3) || rgb(0, 0, 0);
+    } = rgb2(color5) || rgb2(0, 0, 0);
     return (t) => `rgba(${r},${g},${b},${t})`;
 }
 
-function createLegends(scales, context, options) {
+function createLegends2(scales, context, options) {
     const legends = [];
-    for (const [key, value] of legendRegistry) {
+    for (const [key, value] of legendRegistry2) {
         const o = options[key];
         if (o?.legend && key in scales) {
-            const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);
-            if (legend2 != null)
-                legends.push(legend2);
+            const legend3 = value(scales[key], legendOptions2(context, scales[key], o), (key2) => scales[key2]);
+            if (legend3 != null)
+                legends.push(legend3);
         }
     }
     return legends;
 }
 
-// node_modules/@observablehq/plot/src/mark.js
-var Mark = class {
-    constructor(data, channels = {}, options = {}, defaults21) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/mark.js
+var Mark2 = class {
+    constructor(data, channels = {}, options = {}, defaults41) {
         const {
             facet = "auto",
                 facetAnchor,
                 fx,
                 fy,
-                sort: sort3,
+                sort: sort5,
                 dx = 0,
                 dy = 0,
                 margin = 0,
                 marginTop = margin,
                 marginRight = margin,
                 marginBottom = margin,
                 marginLeft = margin,
                 clip,
                 channels: extraChannels
         } = options;
         this.data = data;
-        this.sort = isDomainSort(sort3) ? sort3 : null;
-        this.initializer = initializer(options).initializer;
-        this.transform = this.initializer ? options.transform : basic(options).transform;
+        this.sort = isDomainSort2(sort5) ? sort5 : null;
+        this.initializer = initializer2(options).initializer;
+        this.transform = this.initializer ? options.transform : basic2(options).transform;
         if (facet === null || facet === false) {
             this.facet = null;
         } else {
-            this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
+            this.facet = keyword2(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
             this.fx = fx;
             this.fy = fy;
         }
-        this.facetAnchor = maybeFacetAnchor(facetAnchor);
-        channels = maybeNamed(channels);
+        this.facetAnchor = maybeFacetAnchor2(facetAnchor);
+        channels = maybeNamed2(channels);
         if (extraChannels !== void 0)
             channels = {
-                ...maybeNamed(extraChannels),
+                ...maybeNamed2(extraChannels),
                 ...channels
             };
-        if (defaults21 !== void 0)
+        if (defaults41 !== void 0)
             channels = {
-                ...styles(this, options, defaults21),
+                ...styles2(this, options, defaults41),
                 ...channels
             };
         this.channels = Object.fromEntries(
             Object.entries(channels).map(([name, channel]) => {
                 const {
                     value
                 } = channel;
-                if (isOptions(value)) {
+                if (isOptions2(value)) {
                     channel = {
                         ...channel,
                         value: value.value
                     };
                     if (value.scale !== void 0)
                         channel.scale = value.scale;
                 }
                 return [name, channel];
             }).filter(([name, {
                 value,
-                optional: optional2
+                optional: optional3
             }]) => {
                 if (value != null)
                     return true;
-                if (optional2)
+                if (optional3)
                     return false;
                 throw new Error(`missing channel value: ${name}`);
             })
         );
         this.dx = +dx;
         this.dy = +dy;
         this.marginTop = +marginTop;
         this.marginRight = +marginRight;
         this.marginBottom = +marginBottom;
         this.marginLeft = +marginLeft;
-        this.clip = maybeClip(clip);
+        this.clip = maybeClip2(clip);
         if (this.facet === "super") {
             if (fx || fy)
                 throw new Error(`super-faceting cannot use fx or fy`);
             for (const name in this.channels) {
                 const {
-                    scale: scale3
+                    scale: scale5
                 } = channels[name];
-                if (scale3 !== "x" && scale3 !== "y")
+                if (scale5 !== "x" && scale5 !== "y")
                     continue;
                 throw new Error(`super-faceting cannot use x or y`);
             }
         }
     }
     initialize(facets, facetChannels) {
-        let data = arrayify2(this.data);
+        let data = arrayify4(this.data);
         if (facets === void 0 && data != null)
-            facets = [range4(data)];
+            facets = [range8(data)];
         const originalFacets = facets;
         if (this.transform != null)
             ({
                 facets,
                 data
-            } = this.transform(data, facets)), data = arrayify2(data);
+            } = this.transform(data, facets)), data = arrayify4(data);
         if (facets !== void 0)
             facets.original = originalFacets;
-        const channels = createChannels(this.channels, data);
+        const channels = createChannels2(this.channels, data);
         if (this.sort != null)
-            channelDomain(data, facets, channels, facetChannels, this.sort);
+            channelDomain2(data, facets, channels, facetChannels, this.sort);
         return {
             data,
             facets,
             channels
         };
     }
-    filter(index3, channels, values2) {
+    filter(index5, channels, values3) {
         for (const name in channels) {
             const {
-                filter: filter4 = defined
+                filter: filter7 = defined2
             } = channels[name];
-            if (filter4 !== null) {
-                const value = values2[name];
-                index3 = index3.filter((i) => filter4(value[i]));
+            if (filter7 !== null) {
+                const value = values3[name];
+                index5 = index5.filter((i) => filter7(value[i]));
             }
         }
-        return index3;
+        return index5;
     }
     // If there is a projection, and there are both x and y channels (or x1 and
     // y1, or x2 and y2 channels), and those channels are associated with the x
     // and y scale respectively (and not already in screen coordinates as with an
     // initializer), then apply the projection, replacing the x and y values. Note
     // that the x and y scales themselves don‚Äôt exist if there is a projection,
     // but whether the channels are associated with scales still determines
     // whether the projection should apply; think of the projection as a
     // combination xy-scale.
-    project(channels, values2, context) {
-        maybeProject("x", "y", channels, values2, context);
-        maybeProject("x1", "y1", channels, values2, context);
-        maybeProject("x2", "y2", channels, values2, context);
+    project(channels, values3, context) {
+        maybeProject2("x", "y", channels, values3, context);
+        maybeProject2("x1", "y1", channels, values3, context);
+        maybeProject2("x2", "y2", channels, values3, context);
     }
     scale(channels, scales, context) {
-        const values2 = valueObject(channels, scales);
+        const values3 = valueObject2(channels, scales);
         if (context.projection)
-            this.project(channels, values2, context);
-        return values2;
+            this.project(channels, values3, context);
+        return values3;
     }
 };
 
-function marks(...marks2) {
-    marks2.plot = Mark.prototype.plot;
-    return marks2;
+function marks2(...marks3) {
+    marks3.plot = Mark2.prototype.plot;
+    return marks3;
 }
 
-// node_modules/@observablehq/plot/src/math.js
-var radians3 = Math.PI / 180;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/math.js
+var radians6 = Math.PI / 180;
 
-// node_modules/@observablehq/plot/src/transforms/inset.js
-function maybeInsetX({
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/inset.js
+function maybeInsetX2({
     inset,
     insetLeft,
     insetRight,
     ...options
 } = {}) {
-    [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
+    [insetLeft, insetRight] = maybeInset2(inset, insetLeft, insetRight);
     return {
         inset,
         insetLeft,
         insetRight,
         ...options
     };
 }
 
-function maybeInsetY({
+function maybeInsetY2({
     inset,
     insetTop,
     insetBottom,
     ...options
 } = {}) {
-    [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
+    [insetTop, insetBottom] = maybeInset2(inset, insetTop, insetBottom);
     return {
         inset,
         insetTop,
         insetBottom,
         ...options
     };
 }
 
-function maybeInset(inset, inset1, inset2) {
-    return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
+function maybeInset2(inset, inset1, inset2) {
+    return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset2 ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
 }
 
-// node_modules/@observablehq/plot/src/transforms/interval.js
-function maybeIntervalValue(value, {
-    interval: interval2
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/interval.js
+function maybeIntervalValue2(value, {
+    interval: interval3
 }) {
     value = {
-        ...maybeValue(value)
+        ...maybeValue2(value)
     };
-    value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
+    value.interval = maybeInterval2(value.interval === void 0 ? interval3 : value.interval);
     return value;
 }
 
-function maybeIntervalK(k2, maybeInsetK, options, trivial) {
+function maybeIntervalK2(k3, maybeInsetK, options, trivial) {
     const {
-        [k2]: v2, [`${k2}1`]: v1, [`${k2}2`]: v22
+        [k3]: v3, [`${k3}1`]: v1, [`${k3}2`]: v22
     } = options;
     const {
         value,
-        interval: interval2
-    } = maybeIntervalValue(v2, options);
-    if (value == null || interval2 == null && !trivial)
+        interval: interval3
+    } = maybeIntervalValue2(v3, options);
+    if (value == null || interval3 == null && !trivial)
         return options;
-    const label = labelof(v2);
-    if (interval2 == null) {
+    const label = labelof2(v3);
+    if (interval3 == null) {
         let V;
         const kv = {
-            transform: (data) => V || (V = valueof(data, value)),
+            transform: (data) => V || (V = valueof2(data, value)),
             label
         };
         return {
             ...options,
-            [k2]: void 0,
-            [`${k2}1`]: v1 === void 0 ? kv : v1,
-            [`${k2}2`]: v22 === void 0 ? kv : v22
+            [k3]: void 0,
+            [`${k3}1`]: v1 === void 0 ? kv : v1,
+            [`${k3}2`]: v22 === void 0 ? kv : v22
         };
     }
     let D1, V1;
 
-    function transform2(data) {
+    function transform3(data) {
         if (V1 !== void 0 && data === D1)
             return V1;
-        return V1 = map4(valueof(D1 = data, value), (v3) => interval2.floor(v3));
+        return V1 = map9(valueof2(D1 = data, value), (v4) => interval3.floor(v4));
     }
     return maybeInsetK({
         ...options,
-        [k2]: void 0,
-        [`${k2}1`]: v1 === void 0 ? {
-            transform: transform2,
+        [k3]: void 0,
+        [`${k3}1`]: v1 === void 0 ? {
+            transform: transform3,
             label
         } : v1,
-        [`${k2}2`]: v22 === void 0 ? {
-            transform: (data) => transform2(data).map((v3) => interval2.offset(v3)),
+        [`${k3}2`]: v22 === void 0 ? {
+            transform: (data) => transform3(data).map((v4) => interval3.offset(v4)),
             label
         } : v22
     });
 }
 
-function maybeIntervalMidK(k2, maybeInsetK, options) {
+function maybeIntervalMidK2(k3, maybeInsetK, options) {
     const {
-        [k2]: v2
+        [k3]: v3
     } = options;
     const {
         value,
-        interval: interval2
-    } = maybeIntervalValue(v2, options);
-    if (value == null || interval2 == null)
+        interval: interval3
+    } = maybeIntervalValue2(v3, options);
+    if (value == null || interval3 == null)
         return options;
     return maybeInsetK({
         ...options,
-        [k2]: {
-            label: labelof(v2),
+        [k3]: {
+            label: labelof2(v3),
             transform: (data) => {
-                const V1 = map4(valueof(data, value), (v3) => interval2.floor(v3));
-                const V2 = V1.map((v3) => interval2.offset(v3));
+                const V1 = map9(valueof2(data, value), (v4) => interval3.floor(v4));
+                const V2 = V1.map((v4) => interval3.offset(v4));
                 return V1.map(
-                    isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
+                    isTemporal2(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
                 );
             }
         }
     });
 }
 
-function maybeTrivialIntervalX(options = {}) {
-    return maybeIntervalK("x", maybeInsetX, options, true);
+function maybeTrivialIntervalX2(options = {}) {
+    return maybeIntervalK2("x", maybeInsetX2, options, true);
 }
 
-function maybeTrivialIntervalY(options = {}) {
-    return maybeIntervalK("y", maybeInsetY, options, true);
+function maybeTrivialIntervalY2(options = {}) {
+    return maybeIntervalK2("y", maybeInsetY2, options, true);
 }
 
-function maybeIntervalX(options = {}) {
-    return maybeIntervalK("x", maybeInsetX, options);
+function maybeIntervalX2(options = {}) {
+    return maybeIntervalK2("x", maybeInsetX2, options);
 }
 
-function maybeIntervalY(options = {}) {
-    return maybeIntervalK("y", maybeInsetY, options);
+function maybeIntervalY2(options = {}) {
+    return maybeIntervalK2("y", maybeInsetY2, options);
 }
 
-function maybeIntervalMidX(options = {}) {
-    return maybeIntervalMidK("x", maybeInsetX, options);
+function maybeIntervalMidX2(options = {}) {
+    return maybeIntervalMidK2("x", maybeInsetX2, options);
 }
 
-function maybeIntervalMidY(options = {}) {
-    return maybeIntervalMidK("y", maybeInsetY, options);
+function maybeIntervalMidY2(options = {}) {
+    return maybeIntervalMidK2("y", maybeInsetY2, options);
 }
 
-// node_modules/@observablehq/plot/src/marks/rule.js
-var defaults = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/rule.js
+var defaults21 = {
     ariaLabel: "rule",
     fill: null,
     stroke: "currentColor"
 };
-var RuleX = class extends Mark {
+var RuleX2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y1: y12,
+            x: x7,
+            y1: y13,
             y2: y22,
             inset = 0,
             insetTop = inset,
             insetBottom = inset
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y",
                     optional: true
                 },
                 y2: {
                     value: y22,
                     scale: "y",
                     optional: true
                 }
             },
             options,
-            defaults
+            defaults21
         );
-        this.insetTop = number5(insetTop);
-        this.insetBottom = number5(insetBottom);
+        this.insetTop = number11(insetTop);
+        this.insetBottom = number11(insetBottom);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y1: Y13,
-            y2: Y23
+            x: X4,
+            y1: Y15,
+            y2: Y25
         } = channels;
         const {
             width,
             height,
             marginTop,
             marginRight,
             marginLeft,
             marginBottom
         } = dimensions;
         const {
             insetTop,
             insetBottom
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions).call(applyTransform, this, {
-            x: X3 && x4
-        }, offset, 0).call(
-            (g) => g.selectAll().data(index3).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr("x2", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr("y1", Y13 && !isCollapsed(y4) ? (i) => Y13[i] + insetTop : marginTop + insetTop).attr(
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions).call(applyTransform2, this, {
+            x: X4 && x7
+        }, offset2, 0).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles2, this).attr("x1", X4 ? (i) => X4[i] : (marginLeft + width - marginRight) / 2).attr("x2", X4 ? (i) => X4[i] : (marginLeft + width - marginRight) / 2).attr("y1", Y15 && !isCollapsed2(y7) ? (i) => Y15[i] + insetTop : marginTop + insetTop).attr(
                 "y2",
-                Y23 && !isCollapsed(y4) ? y4.bandwidth ? (i) => Y23[i] + y4.bandwidth() - insetBottom : (i) => Y23[i] - insetBottom : height - marginBottom - insetBottom
-            ).call(applyChannelStyles, this, channels)
+                Y25 && !isCollapsed2(y7) ? y7.bandwidth ? (i) => Y25[i] + y7.bandwidth() - insetBottom : (i) => Y25[i] - insetBottom : height - marginBottom - insetBottom
+            ).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
-var RuleY = class extends Mark {
+var RuleY2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
+            x1: x13,
             x2: x22,
-            y: y4,
+            y: y7,
             inset = 0,
             insetRight = inset,
             insetLeft = inset
         } = options;
         super(
             data, {
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x",
                     optional: true
                 },
                 x2: {
                     value: x22,
                     scale: "x",
                     optional: true
                 }
             },
             options,
-            defaults
+            defaults21
         );
-        this.insetRight = number5(insetRight);
-        this.insetLeft = number5(insetLeft);
+        this.insetRight = number11(insetRight);
+        this.insetLeft = number11(insetLeft);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            y: Y3,
-            x1: X13,
-            x2: X23
+            y: Y4,
+            x1: X15,
+            x2: X25
         } = channels;
         const {
             width,
             height,
             marginTop,
             marginRight,
             marginLeft,
             marginBottom
         } = dimensions;
         const {
             insetLeft,
             insetRight
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            y: Y3 && y4
-        }, 0, offset).call(
-            (g) => g.selectAll().data(index3).enter().append("line").call(applyDirectStyles, this).attr("x1", X13 && !isCollapsed(x4) ? (i) => X13[i] + insetLeft : marginLeft + insetLeft).attr(
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            y: Y4 && y7
+        }, 0, offset2).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles2, this).attr("x1", X15 && !isCollapsed2(x7) ? (i) => X15[i] + insetLeft : marginLeft + insetLeft).attr(
                 "x2",
-                X23 && !isCollapsed(x4) ? x4.bandwidth ? (i) => X23[i] + x4.bandwidth() - insetRight : (i) => X23[i] - insetRight : width - marginRight - insetRight
-            ).attr("y1", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).attr("y2", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)
+                X25 && !isCollapsed2(x7) ? x7.bandwidth ? (i) => X25[i] + x7.bandwidth() - insetRight : (i) => X25[i] - insetRight : width - marginRight - insetRight
+            ).attr("y1", Y4 ? (i) => Y4[i] : (marginTop + height - marginBottom) / 2).attr("y2", Y4 ? (i) => Y4[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function ruleX(data, options) {
+function ruleX2(data, options) {
     let {
-        x: x4 = identity6,
-        y: y4,
-        y1: y12,
+        x: x7 = identity13,
+        y: y7,
+        y1: y13,
         y2: y22,
         ...rest
-    } = maybeIntervalY(options);
-    [y12, y22] = maybeOptionalZero(y4, y12, y22);
-    return new RuleX(data, {
+    } = maybeIntervalY2(options);
+    [y13, y22] = maybeOptionalZero2(y7, y13, y22);
+    return new RuleX2(data, {
         ...rest,
-        x: x4,
-        y1: y12,
+        x: x7,
+        y1: y13,
         y2: y22
     });
 }
 
-function ruleY(data, options) {
+function ruleY2(data, options) {
     let {
-        y: y4 = identity6,
-        x: x4,
-        x1: x12,
+        y: y7 = identity13,
+        x: x7,
+        x1: x13,
         x2: x22,
         ...rest
-    } = maybeIntervalX(options);
-    [x12, x22] = maybeOptionalZero(x4, x12, x22);
-    return new RuleY(data, {
+    } = maybeIntervalX2(options);
+    [x13, x22] = maybeOptionalZero2(x7, x13, x22);
+    return new RuleY2(data, {
         ...rest,
-        y: y4,
-        x1: x12,
+        y: y7,
+        x1: x13,
         x2: x22
     });
 }
 
-function maybeOptionalZero(x4, x12, x22) {
-    if (x4 === void 0) {
-        if (x12 === void 0) {
+function maybeOptionalZero2(x7, x13, x22) {
+    if (x7 === void 0) {
+        if (x13 === void 0) {
             if (x22 !== void 0)
                 return [0, x22];
         } else {
             if (x22 === void 0)
-                return [0, x12];
+                return [0, x13];
         }
-    } else if (x12 === void 0) {
-        return x22 === void 0 ? [0, x4] : [x4, x22];
+    } else if (x13 === void 0) {
+        return x22 === void 0 ? [0, x7] : [x7, x22];
     } else if (x22 === void 0) {
-        return [x4, x12];
+        return [x7, x13];
     }
-    return [x12, x22];
+    return [x13, x22];
 }
 
-// node_modules/@observablehq/plot/src/template.js
-function template(strings, ...parts) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/template.js
+function template2(strings, ...parts) {
     let n = parts.length;
-    for (let j = 0, copy3 = true; j < n; ++j) {
+    for (let j = 0, copy5 = true; j < n; ++j) {
         if (typeof parts[j] !== "function") {
-            if (copy3) {
+            if (copy5) {
                 strings = strings.slice();
-                copy3 = false;
+                copy5 = false;
             }
             strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);
             parts.splice(j, 1);
             --j, --n;
         }
     }
     return (i) => {
-        let s2 = strings[0];
+        let s3 = strings[0];
         for (let j = 0; j < n; ++j) {
-            s2 += parts[j](i) + strings[j + 1];
+            s3 += parts[j](i) + strings[j + 1];
         }
-        return s2;
+        return s3;
     };
 }
 
-// node_modules/@observablehq/plot/src/marks/text.js
-var defaults2 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/text.js
+var defaults22 = {
     ariaLabel: "text",
     strokeLinejoin: "round",
     strokeWidth: 3,
     paintOrder: "stroke"
 };
-var softHyphen = "\xAD";
-var Text = class extends Mark {
+var softHyphen2 = "\xAD";
+var Text2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
-            text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf,
+            x: x7,
+            y: y7,
+            text: text3 = isIterable2(data) && isTextual2(data) ? identity13 : indexOf2,
             frameAnchor,
             textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
             lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
             lineHeight = 1,
             lineWidth = Infinity,
             textOverflow,
             monospace,
             fontFamily = monospace ? "ui-monospace, monospace" : void 0,
             fontSize,
             fontStyle,
             fontVariant,
             fontWeight,
             rotate
         } = options;
-        const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
-        const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
+        const [vrotate, crotate] = maybeNumberChannel2(rotate, 0);
+        const [vfontSize, cfontSize] = maybeFontSizeChannel2(fontSize);
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 fontSize: {
                     value: vfontSize,
                     optional: true
                 },
                 rotate: {
-                    value: numberChannel(vrotate),
+                    value: numberChannel2(vrotate),
                     optional: true
                 },
                 text: {
-                    value: text2,
-                    filter: nonempty,
+                    value: text3,
+                    filter: nonempty2,
                     optional: true
                 }
             },
             options,
-            defaults2
+            defaults22
         );
         this.rotate = crotate;
-        this.textAnchor = impliedString(textAnchor, "middle");
-        this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
+        this.textAnchor = impliedString2(textAnchor, "middle");
+        this.lineAnchor = keyword2(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
         this.lineHeight = +lineHeight;
         this.lineWidth = +lineWidth;
-        this.textOverflow = maybeTextOverflow(textOverflow);
+        this.textOverflow = maybeTextOverflow2(textOverflow);
         this.monospace = !!monospace;
-        this.fontFamily = string(fontFamily);
+        this.fontFamily = string2(fontFamily);
         this.fontSize = cfontSize;
-        this.fontStyle = string(fontStyle);
-        this.fontVariant = string(fontVariant);
-        this.fontWeight = string(fontWeight);
-        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        this.fontStyle = string2(fontStyle);
+        this.fontVariant = string2(fontVariant);
+        this.fontWeight = string2(fontWeight);
+        this.frameAnchor = maybeFrameAnchor2(frameAnchor);
         if (!(this.lineWidth >= 0))
             throw new Error(`invalid lineWidth: ${lineWidth}`);
-        this.splitLines = splitter2(this);
-        this.clipLine = clipper(this);
+        this.splitLines = splitter4(this);
+        this.clipLine = clipper2(this);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             rotate: R,
             text: T,
             title: TL,
             fontSize: FS
         } = channels;
         const {
             rotate
         } = this;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyIndirectTextStyles2, this, T, dimensions).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            (g) => g.selectAll().data(index3).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(
+            (g) => g.selectAll().data(index5).enter().append("text").call(applyDirectStyles2, this).call(applyMultilineText2, this, T, TL).attr(
                 "transform",
-                template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`
-            ).call(applyAttr, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)
+                template2`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`
+            ).call(applyAttr2, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function maybeTextOverflow(textOverflow) {
-    return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
+function maybeTextOverflow2(textOverflow) {
+    return textOverflow == null ? null : keyword2(textOverflow, "textOverflow", [
         "clip",
         // shorthand for clip-end
         "ellipsis",
         // ‚Ä¶ ellipsis-end
         "clip-start",
         "clip-end",
         "ellipsis-start",
         "ellipsis-middle",
         "ellipsis-end"
     ]).replace(/^(clip|ellipsis)$/, "$1-end");
 }
 
-function applyMultilineText(selection2, mark, T, TL) {
+function applyMultilineText2(selection3, mark, T, TL) {
     if (!T)
         return;
     const {
         lineAnchor,
         lineHeight,
         textOverflow,
         splitLines,
         clipLine
     } = mark;
-    selection2.each(function(i) {
-        const lines = splitLines(formatDefault(T[i]) ?? "").map(clipLine);
+    selection3.each(function(i) {
+        const lines = splitLines(formatDefault2(T[i]) ?? "").map(clipLine);
         const n = lines.length;
-        const y4 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
+        const y7 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
         if (n > 1) {
             for (let i2 = 0; i2 < n; ++i2) {
                 if (!lines[i2])
                     continue;
-                const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
+                const tspan = this.ownerDocument.createElementNS(namespaces_default2.svg, "tspan");
                 tspan.setAttribute("x", 0);
-                tspan.setAttribute("y", `${(y4 + i2) * lineHeight}em`);
+                tspan.setAttribute("y", `${(y7 + i2) * lineHeight}em`);
                 tspan.textContent = lines[i2];
                 this.appendChild(tspan);
             }
         } else {
-            if (y4)
-                this.setAttribute("y", `${y4 * lineHeight}em`);
+            if (y7)
+                this.setAttribute("y", `${y7 * lineHeight}em`);
             this.textContent = lines[0];
         }
         if (textOverflow && !TL && lines[0] !== T[i]) {
-            const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
+            const title = this.ownerDocument.createElementNS(namespaces_default2.svg, "title");
             title.textContent = T[i];
             this.appendChild(title);
         }
     });
 }
 
-function text(data, options = {}) {
+function text2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
     if (options.frameAnchor === void 0)
-        [x4, y4] = maybeTuple(x4, y4);
-    return new Text(data, {
+        [x7, y7] = maybeTuple2(x7, y7);
+    return new Text2(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function textX(data, options = {}) {
+function textX2(data, options = {}) {
     const {
-        x: x4 = identity6,
+        x: x7 = identity13,
         ...remainingOptions
     } = options;
-    return new Text(data, maybeIntervalMidY({
+    return new Text2(data, maybeIntervalMidY2({
         ...remainingOptions,
-        x: x4
+        x: x7
     }));
 }
 
-function textY(data, options = {}) {
+function textY2(data, options = {}) {
     const {
-        y: y4 = identity6,
+        y: y7 = identity13,
         ...remainingOptions
     } = options;
-    return new Text(data, maybeIntervalMidX({
+    return new Text2(data, maybeIntervalMidX2({
         ...remainingOptions,
-        y: y4
+        y: y7
     }));
 }
 
-function applyIndirectTextStyles(selection2, mark, T) {
-    applyAttr(selection2, "text-anchor", mark.textAnchor);
-    applyAttr(selection2, "font-family", mark.fontFamily);
-    applyAttr(selection2, "font-size", mark.fontSize);
-    applyAttr(selection2, "font-style", mark.fontStyle);
-    applyAttr(selection2, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);
-    applyAttr(selection2, "font-weight", mark.fontWeight);
+function applyIndirectTextStyles2(selection3, mark, T) {
+    applyAttr2(selection3, "text-anchor", mark.textAnchor);
+    applyAttr2(selection3, "font-family", mark.fontFamily);
+    applyAttr2(selection3, "font-size", mark.fontSize);
+    applyAttr2(selection3, "font-style", mark.fontStyle);
+    applyAttr2(selection3, "font-variant", mark.fontVariant === void 0 ? inferFontVariant5(T) : mark.fontVariant);
+    applyAttr2(selection3, "font-weight", mark.fontWeight);
 }
 
-function inferFontVariant2(T) {
-    return isNumeric(T) || isTemporal(T) ? "tabular-nums" : void 0;
+function inferFontVariant5(T) {
+    return isNumeric2(T) || isTemporal2(T) ? "tabular-nums" : void 0;
 }
-var fontSizes = /* @__PURE__ */ new Set([
+var fontSizes2 = /* @__PURE__ */ new Set([
     // global keywords
     "inherit",
     "initial",
     "revert",
     "unset",
     // absolute keywords
     "xx-small",
@@ -26706,78 +61412,78 @@
     "xx-large",
     "xxx-large",
     // relative keywords
     "larger",
     "smaller"
 ]);
 
-function maybeFontSizeChannel(fontSize) {
+function maybeFontSizeChannel2(fontSize) {
     if (fontSize == null || typeof fontSize === "number")
         return [void 0, fontSize];
     if (typeof fontSize !== "string")
         return [fontSize, void 0];
     fontSize = fontSize.trim().toLowerCase();
-    return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
+    return fontSizes2.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
 }
 
-function lineWrap(input, maxWidth, widthof) {
+function lineWrap2(input, maxWidth, widthof) {
     const lines = [];
     let lineStart, lineEnd = 0;
-    for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {
+    for (const [wordStart, wordEnd, required3] of lineBreaks2(input)) {
         if (lineStart === void 0)
             lineStart = wordStart;
         if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
-            lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
+            lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen2 ? "-" : ""));
             lineStart = wordStart;
         }
-        if (required2) {
+        if (required3) {
             lines.push(input.slice(lineStart, wordEnd));
             lineStart = void 0;
             continue;
         }
         lineEnd = wordEnd;
     }
     return lines;
 }
 
-function* lineBreaks(input) {
+function* lineBreaks2(input) {
     let i = 0,
         j = 0;
     const n = input.length;
     while (j < n) {
-        let k2 = 1;
+        let k3 = 1;
         switch (input[j]) {
-            case softHyphen:
+            case softHyphen2:
             case "-":
                 ++j;
                 yield [i, j, false];
                 i = j;
                 break;
             case " ":
                 yield [i, j, false];
                 while (input[++j] === " ")
                 ;
                 i = j;
                 break;
             case "\r":
                 if (input[j + 1] === "\n")
-                    ++k2;
+                    ++k3;
             case "\n":
                 yield [i, j, true];
-                j += k2;
+                j += k3;
                 i = j;
                 break;
             default:
                 ++j;
                 break;
         }
     }
     yield [i, j, true];
 }
-var defaultWidthMap = {
+var defaultWidthMap2 = {
     a: 56,
     b: 63,
     c: 57,
     d: 63,
     e: 58,
     f: 37,
     g: 62,
@@ -26852,962 +61558,962 @@
     "\u2018": 31,
     "\u2019": 31,
     "\u201C": 47,
     "\u201D": 47,
     "\u2026": 82
 };
 
-function defaultWidth(text2, start2 = 0, end = text2.length) {
-    let sum5 = 0;
-    for (let i = start2; i < end; i = readCharacter(text2, i)) {
-        sum5 += defaultWidthMap[text2[i]] ?? (isPictographic(text2, i) ? 120 : defaultWidthMap.e);
+function defaultWidth2(text3, start3 = 0, end = text3.length) {
+    let sum8 = 0;
+    for (let i = start3; i < end; i = readCharacter2(text3, i)) {
+        sum8 += defaultWidthMap2[text3[i]] ?? (isPictographic2(text3, i) ? 120 : defaultWidthMap2.e);
     }
-    return sum5;
+    return sum8;
 }
 
-function monospaceWidth(text2, start2 = 0, end = text2.length) {
-    let sum5 = 0;
-    for (let i = start2; i < end; i = readCharacter(text2, i)) {
-        sum5 += isPictographic(text2, i) ? 200 : 100;
+function monospaceWidth2(text3, start3 = 0, end = text3.length) {
+    let sum8 = 0;
+    for (let i = start3; i < end; i = readCharacter2(text3, i)) {
+        sum8 += isPictographic2(text3, i) ? 200 : 100;
     }
-    return sum5;
+    return sum8;
 }
 
-function splitter2({
+function splitter4({
     monospace,
     lineWidth,
     textOverflow
 }) {
     if (textOverflow != null || lineWidth == Infinity)
-        return (text2) => text2.split(/\r\n?|\n/g);
-    const widthof = monospace ? monospaceWidth : defaultWidth;
+        return (text3) => text3.split(/\r\n?|\n/g);
+    const widthof = monospace ? monospaceWidth2 : defaultWidth2;
     const maxWidth = lineWidth * 100;
-    return (text2) => lineWrap(text2, maxWidth, widthof);
+    return (text3) => lineWrap2(text3, maxWidth, widthof);
 }
 
-function clipper({
+function clipper2({
     monospace,
     lineWidth,
     textOverflow
 }) {
     if (textOverflow == null || lineWidth == Infinity)
-        return (text2) => text2;
-    const widthof = monospace ? monospaceWidth : defaultWidth;
+        return (text3) => text3;
+    const widthof = monospace ? monospaceWidth2 : defaultWidth2;
     const maxWidth = lineWidth * 100;
     switch (textOverflow) {
         case "clip-start":
-            return (text2) => clipStart(text2, maxWidth, widthof, "");
+            return (text3) => clipStart2(text3, maxWidth, widthof, "");
         case "clip-end":
-            return (text2) => clipEnd(text2, maxWidth, widthof, "");
+            return (text3) => clipEnd2(text3, maxWidth, widthof, "");
         case "ellipsis-start":
-            return (text2) => clipStart(text2, maxWidth, widthof, "\u2026");
+            return (text3) => clipStart2(text3, maxWidth, widthof, "\u2026");
         case "ellipsis-middle":
-            return (text2) => clipMiddle(text2, maxWidth, widthof, "\u2026");
+            return (text3) => clipMiddle2(text3, maxWidth, widthof, "\u2026");
         case "ellipsis-end":
-            return (text2) => clipEnd(text2, maxWidth, widthof, "\u2026");
+            return (text3) => clipEnd2(text3, maxWidth, widthof, "\u2026");
     }
 }
 
-function cut(text2, width, widthof, inset) {
+function cut2(text3, width, widthof, inset) {
     const I = [];
     let w = 0;
-    for (let i = 0, j = 0, n = text2.length; i < n; i = j) {
-        j = readCharacter(text2, i);
-        const l = widthof(text2, i, j);
+    for (let i = 0, j = 0, n = text3.length; i < n; i = j) {
+        j = readCharacter2(text3, i);
+        const l = widthof(text3, i, j);
         if (w + l > width) {
             w += inset;
             while (w > width && i > 0)
-                j = i, i = I.pop(), w -= widthof(text2, i, j);
+                j = i, i = I.pop(), w -= widthof(text3, i, j);
             return [i, width - w];
         }
         w += l;
         I.push(i);
     }
     return [-1, 0];
 }
 
-function clipEnd(text2, width, widthof, ellipsis) {
-    text2 = text2.trim();
+function clipEnd2(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
     const e = widthof(ellipsis);
-    const [i] = cut(text2, width, widthof, e);
-    return i < 0 ? text2 : text2.slice(0, i).trimEnd() + ellipsis;
+    const [i] = cut2(text3, width, widthof, e);
+    return i < 0 ? text3 : text3.slice(0, i).trimEnd() + ellipsis;
 }
 
-function clipMiddle(text2, width, widthof, ellipsis) {
-    text2 = text2.trim();
-    const w = widthof(text2);
+function clipMiddle2(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
+    const w = widthof(text3);
     if (w <= width)
-        return text2;
+        return text3;
     const e = widthof(ellipsis) / 2;
-    const [i, ei] = cut(text2, width / 2, widthof, e);
-    const [j] = cut(text2, w - width / 2 - ei + e, widthof, -e);
-    return j < 0 ? ellipsis : text2.slice(0, i).trimEnd() + ellipsis + text2.slice(readCharacter(text2, j)).trimStart();
+    const [i, ei] = cut2(text3, width / 2, widthof, e);
+    const [j] = cut2(text3, w - width / 2 - ei + e, widthof, -e);
+    return j < 0 ? ellipsis : text3.slice(0, i).trimEnd() + ellipsis + text3.slice(readCharacter2(text3, j)).trimStart();
 }
 
-function clipStart(text2, width, widthof, ellipsis) {
-    text2 = text2.trim();
-    const w = widthof(text2);
+function clipStart2(text3, width, widthof, ellipsis) {
+    text3 = text3.trim();
+    const w = widthof(text3);
     if (w <= width)
-        return text2;
+        return text3;
     const e = widthof(ellipsis);
-    const [j] = cut(text2, w - width + e, widthof, -e);
-    return j < 0 ? ellipsis : ellipsis + text2.slice(readCharacter(text2, j)).trimStart();
+    const [j] = cut2(text3, w - width + e, widthof, -e);
+    return j < 0 ? ellipsis : ellipsis + text3.slice(readCharacter2(text3, j)).trimStart();
 }
-var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
-var rePictographic = /\p{Extended_Pictographic}/uy;
+var reCombiner2 = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
+var rePictographic2 = /\p{Extended_Pictographic}/uy;
 
-function readCharacter(text2, i) {
-    i += isSurrogatePair(text2, i) ? 2 : 1;
-    if (isCombiner(text2, i))
-        i = reCombiner.lastIndex;
-    if (isZeroWidthJoiner(text2, i))
-        return readCharacter(text2, i + 1);
+function readCharacter2(text3, i) {
+    i += isSurrogatePair2(text3, i) ? 2 : 1;
+    if (isCombiner2(text3, i))
+        i = reCombiner2.lastIndex;
+    if (isZeroWidthJoiner2(text3, i))
+        return readCharacter2(text3, i + 1);
     return i;
 }
 
-function isAscii(text2, i) {
-    return text2.charCodeAt(i) < 128;
+function isAscii2(text3, i) {
+    return text3.charCodeAt(i) < 128;
 }
 
-function isSurrogatePair(text2, i) {
-    const hi = text2.charCodeAt(i);
+function isSurrogatePair2(text3, i) {
+    const hi = text3.charCodeAt(i);
     if (hi >= 55296 && hi < 56320) {
-        const lo = text2.charCodeAt(i + 1);
+        const lo = text3.charCodeAt(i + 1);
         return lo >= 56320 && lo < 57344;
     }
     return false;
 }
 
-function isZeroWidthJoiner(text2, i) {
-    return text2.charCodeAt(i) === 8205;
+function isZeroWidthJoiner2(text3, i) {
+    return text3.charCodeAt(i) === 8205;
 }
 
-function isCombiner(text2, i) {
-    return isAscii(text2, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text2));
+function isCombiner2(text3, i) {
+    return isAscii2(text3, i) ? false : (reCombiner2.lastIndex = i, reCombiner2.test(text3));
 }
 
-function isPictographic(text2, i) {
-    return isAscii(text2, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text2));
+function isPictographic2(text3, i) {
+    return isAscii2(text3, i) ? false : (rePictographic2.lastIndex = i, rePictographic2.test(text3));
 }
 
-// node_modules/@observablehq/plot/src/marks/vector.js
-var defaults3 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/vector.js
+var defaults23 = {
     ariaLabel: "vector",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeLinejoin: "round",
     strokeLinecap: "round"
 };
-var defaultRadius3 = 3.5;
-var wingRatio = defaultRadius3 * 5;
-var shapeArrow = {
+var defaultRadius6 = 3.5;
+var wingRatio2 = defaultRadius6 * 5;
+var shapeArrow2 = {
     draw(context, l, r) {
-        const wing = l * r / wingRatio;
+        const wing = l * r / wingRatio2;
         context.moveTo(0, 0);
         context.lineTo(0, -l);
         context.moveTo(-wing, wing - l);
         context.lineTo(0, -l);
         context.lineTo(wing, wing - l);
     }
 };
-var shapeSpike = {
+var shapeSpike2 = {
     draw(context, l, r) {
         context.moveTo(-r, 0);
         context.lineTo(0, -l);
         context.lineTo(r, 0);
     }
 };
-var shapes = /* @__PURE__ */ new Map([
-    ["arrow", shapeArrow],
-    ["spike", shapeSpike]
+var shapes2 = /* @__PURE__ */ new Map([
+    ["arrow", shapeArrow2],
+    ["spike", shapeSpike2]
 ]);
 
-function isShapeObject(value) {
+function isShapeObject2(value) {
     return value && typeof value.draw === "function";
 }
 
-function maybeShape(shape) {
-    if (isShapeObject(shape))
+function maybeShape2(shape) {
+    if (isShapeObject2(shape))
         return shape;
-    const value = shapes.get(`${shape}`.toLowerCase());
+    const value = shapes2.get(`${shape}`.toLowerCase());
     if (value)
         return value;
     throw new Error(`invalid shape: ${shape}`);
 }
-var Vector = class extends Mark {
+var Vector2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
-            r = defaultRadius3,
-            length: length4,
+            x: x7,
+            y: y7,
+            r = defaultRadius6,
+            length: length7,
             rotate,
-            shape = shapeArrow,
+            shape = shapeArrow2,
             anchor = "middle",
             frameAnchor
         } = options;
-        const [vl, cl] = maybeNumberChannel(length4, 12);
-        const [vr, cr] = maybeNumberChannel(rotate, 0);
+        const [vl, cl] = maybeNumberChannel2(length7, 12);
+        const [vr, cr] = maybeNumberChannel2(rotate, 0);
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 length: {
                     value: vl,
                     scale: "length",
                     optional: true
                 },
                 rotate: {
                     value: vr,
                     optional: true
                 }
             },
             options,
-            defaults3
+            defaults23
         );
         this.r = +r;
         this.length = cl;
         this.rotate = cr;
-        this.shape = maybeShape(shape);
-        this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
-        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        this.shape = maybeShape2(shape);
+        this.anchor = keyword2(anchor, "anchor", ["start", "middle", "end"]);
+        this.frameAnchor = maybeFrameAnchor2(frameAnchor);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             length: L,
-            rotate: A5
+            rotate: A6
         } = channels;
         const {
-            length: length4,
+            length: length7,
             rotate,
             anchor,
             shape,
             r
         } = this;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            (g) => g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).attr(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).attr(
                 "transform",
-                template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length4})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length4 / 2})`}`
+                template2`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${A6 ? (i) => ` rotate(${A6[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length7})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length7 / 2})`}`
             ).attr(
                 "d",
                 L ? (i) => {
-                    const p = pathRound();
+                    const p = pathRound2();
                     shape.draw(p, L[i], r);
                     return p;
                 } : (() => {
-                    const p = pathRound();
-                    shape.draw(p, length4, r);
+                    const p = pathRound2();
+                    shape.draw(p, length7, r);
                     return p;
                 })()
-            ).call(applyChannelStyles, this, channels)
+            ).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function vector(data, options = {}) {
+function vector2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...rest
     } = options;
     if (options.frameAnchor === void 0)
-        [x4, y4] = maybeTuple(x4, y4);
-    return new Vector(data, {
+        [x7, y7] = maybeTuple2(x7, y7);
+    return new Vector2(data, {
         ...rest,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function vectorX(data, options = {}) {
+function vectorX2(data, options = {}) {
     const {
-        x: x4 = identity6,
+        x: x7 = identity13,
         ...rest
     } = options;
-    return new Vector(data, {
+    return new Vector2(data, {
         ...rest,
-        x: x4
+        x: x7
     });
 }
 
-function vectorY(data, options = {}) {
+function vectorY2(data, options = {}) {
     const {
-        y: y4 = identity6,
+        y: y7 = identity13,
         ...rest
     } = options;
-    return new Vector(data, {
+    return new Vector2(data, {
         ...rest,
-        y: y4
+        y: y7
     });
 }
 
-function spike(data, options = {}) {
+function spike2(data, options = {}) {
     const {
-        shape = shapeSpike,
-            stroke = defaults3.stroke,
+        shape = shapeSpike2,
+            stroke = defaults23.stroke,
             strokeWidth = 1,
             fill = stroke,
             fillOpacity = 0.3,
             anchor = "start",
             ...rest
     } = options;
-    return vector(data, {
+    return vector2(data, {
         ...rest,
         shape,
         stroke,
         strokeWidth,
         fill,
         fillOpacity,
         anchor
     });
 }
 
-// node_modules/@observablehq/plot/src/marks/axis.js
-function maybeData(data, options) {
-    if (arguments.length < 2 && !isIterable(data))
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/axis.js
+function maybeData2(data, options) {
+    if (arguments.length < 2 && !isIterable2(data))
         options = data, data = null;
     if (options === void 0)
         options = {};
     return [data, options];
 }
 
-function maybeAnchor({
+function maybeAnchor4({
     anchor
 } = {}, anchors) {
-    return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
+    return anchor === void 0 ? anchors[0] : keyword2(anchor, "anchor", anchors);
 }
 
-function anchorY(options) {
-    return maybeAnchor(options, ["left", "right"]);
+function anchorY2(options) {
+    return maybeAnchor4(options, ["left", "right"]);
 }
 
-function anchorFy(options) {
-    return maybeAnchor(options, ["right", "left"]);
+function anchorFy2(options) {
+    return maybeAnchor4(options, ["right", "left"]);
 }
 
-function anchorX(options) {
-    return maybeAnchor(options, ["bottom", "top"]);
+function anchorX2(options) {
+    return maybeAnchor4(options, ["bottom", "top"]);
 }
 
-function anchorFx(options) {
-    return maybeAnchor(options, ["top", "bottom"]);
+function anchorFx2(options) {
+    return maybeAnchor4(options, ["top", "bottom"]);
 }
 
-function axisY() {
-    const [data, options] = maybeData(...arguments);
-    return axisKy("y", anchorY(options), data, options);
+function axisY2() {
+    const [data, options] = maybeData2(...arguments);
+    return axisKy2("y", anchorY2(options), data, options);
 }
 
-function axisFy() {
-    const [data, options] = maybeData(...arguments);
-    return axisKy("fy", anchorFy(options), data, options);
+function axisFy2() {
+    const [data, options] = maybeData2(...arguments);
+    return axisKy2("fy", anchorFy2(options), data, options);
 }
 
-function axisX() {
-    const [data, options] = maybeData(...arguments);
-    return axisKx("x", anchorX(options), data, options);
+function axisX2() {
+    const [data, options] = maybeData2(...arguments);
+    return axisKx2("x", anchorX2(options), data, options);
 }
 
-function axisFx() {
-    const [data, options] = maybeData(...arguments);
-    return axisKx("fx", anchorFx(options), data, options);
+function axisFx2() {
+    const [data, options] = maybeData2(...arguments);
+    return axisKx2("fx", anchorFx2(options), data, options);
 }
 
-function axisKy(k2, anchor, data, {
-    color: color3 = "currentColor",
-    opacity: opacity2 = 1,
-    stroke = color3,
-    strokeOpacity = opacity2,
+function axisKy2(k3, anchor, data, {
+    color: color5 = "currentColor",
+    opacity: opacity3 = 1,
+    stroke = color5,
+    strokeOpacity = opacity3,
     strokeWidth = 1,
-    fill = color3,
-    fillOpacity = opacity2,
+    fill = color5,
+    fillOpacity = opacity3,
     textAnchor,
     textStroke,
     textStrokeOpacity,
     textStrokeWidth,
-    tickSize = k2 === "y" ? 6 : 0,
+    tickSize = k3 === "y" ? 6 : 0,
     tickPadding,
     tickRotate,
-    x: x4,
+    x: x7,
     marginTop = 20,
     marginRight = anchor === "right" ? 40 : 0,
     marginBottom = 20,
     marginLeft = anchor === "left" ? 40 : 0,
     label,
     labelOffset,
     labelAnchor,
     ...options
 }) {
-    tickSize = number5(tickSize);
-    tickPadding = number5(tickPadding);
-    tickRotate = number5(tickRotate);
+    tickSize = number11(tickSize);
+    tickPadding = number11(tickPadding);
+    tickRotate = number11(tickRotate);
     if (labelAnchor !== void 0)
-        labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
-    return marks(
-        tickSize && !isNoneish(stroke) ? axisTickKy(k2, anchor, data, {
+        labelAnchor = keyword2(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
+    return marks2(
+        tickSize && !isNoneish2(stroke) ? axisTickKy2(k3, anchor, data, {
             stroke,
             strokeOpacity,
             strokeWidth,
             tickSize,
             tickPadding,
             tickRotate,
-            x: x4,
+            x: x7,
             ...options
         }) : null,
-        !isNoneish(fill) ? axisTextKy(k2, anchor, data, {
+        !isNoneish2(fill) ? axisTextKy2(k3, anchor, data, {
             fill,
             fillOpacity,
             stroke: textStroke,
             strokeOpacity: textStrokeOpacity,
             strokeWidth: textStrokeWidth,
             textAnchor,
             tickSize,
             tickPadding,
             tickRotate,
-            x: x4,
+            x: x7,
             marginTop,
             marginRight,
             marginBottom,
             marginLeft,
             ...options
         }) : null,
-        !isNoneish(fill) && label !== null ? text([], {
+        !isNoneish2(fill) && label !== null ? text2([], {
             fill,
             fillOpacity,
             ...options,
             lineWidth: void 0,
             textOverflow: void 0,
             facet: "super",
             x: null,
             y: null,
             initializer: function(data2, facets, channels, scales, dimensions) {
-                const scale3 = scales[k2];
+                const scale5 = scales[k3];
                 const {
                     marginTop: marginTop2,
                     marginRight: marginRight2,
                     marginBottom: marginBottom2,
                     marginLeft: marginLeft2
-                } = k2 === "y" && dimensions.inset || dimensions;
-                const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "top");
+                } = k3 === "y" && dimensions.inset || dimensions;
+                const cla = labelAnchor ?? (scale5.bandwidth ? "center" : "top");
                 const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
                 if (cla === "center") {
                     this.textAnchor = void 0;
                     this.lineAnchor = anchor === "right" ? "bottom" : "top";
                     this.frameAnchor = anchor;
                     this.rotate = -90;
                 } else {
                     this.textAnchor = anchor === "right" ? "end" : "start";
                     this.lineAnchor = cla;
                     this.frameAnchor = `${cla}-${anchor}`;
                     this.rotate = 0;
                 }
                 this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
                 this.dx = anchor === "right" ? clo : -clo;
-                this.ariaLabel = `${k2}-axis label`;
+                this.ariaLabel = `${k3}-axis label`;
                 return {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]
+                            value: [label === void 0 ? inferAxisLabel2(k3, scale5, cla) : label]
                         }
                     }
                 };
             }
         }) : null
     );
 }
 
-function axisKx(k2, anchor, data, {
-    color: color3 = "currentColor",
-    opacity: opacity2 = 1,
-    stroke = color3,
-    strokeOpacity = opacity2,
+function axisKx2(k3, anchor, data, {
+    color: color5 = "currentColor",
+    opacity: opacity3 = 1,
+    stroke = color5,
+    strokeOpacity = opacity3,
     strokeWidth = 1,
-    fill = color3,
-    fillOpacity = opacity2,
+    fill = color5,
+    fillOpacity = opacity3,
     textAnchor,
     textStroke,
     textStrokeOpacity,
     textStrokeWidth,
-    tickSize = k2 === "x" ? 6 : 0,
+    tickSize = k3 === "x" ? 6 : 0,
     tickPadding,
     tickRotate,
-    y: y4,
+    y: y7,
     marginTop = anchor === "top" ? 30 : 0,
     marginRight = 20,
     marginBottom = anchor === "bottom" ? 30 : 0,
     marginLeft = 20,
     label,
     labelAnchor,
     labelOffset,
     ...options
 }) {
-    tickSize = number5(tickSize);
-    tickPadding = number5(tickPadding);
-    tickRotate = number5(tickRotate);
+    tickSize = number11(tickSize);
+    tickPadding = number11(tickPadding);
+    tickRotate = number11(tickRotate);
     if (labelAnchor !== void 0)
-        labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
-    return marks(
-        tickSize && !isNoneish(stroke) ? axisTickKx(k2, anchor, data, {
+        labelAnchor = keyword2(labelAnchor, "labelAnchor", ["center", "left", "right"]);
+    return marks2(
+        tickSize && !isNoneish2(stroke) ? axisTickKx2(k3, anchor, data, {
             stroke,
             strokeOpacity,
             strokeWidth,
             tickSize,
             tickPadding,
             tickRotate,
-            y: y4,
+            y: y7,
             ...options
         }) : null,
-        !isNoneish(fill) ? axisTextKx(k2, anchor, data, {
+        !isNoneish2(fill) ? axisTextKx2(k3, anchor, data, {
             fill,
             fillOpacity,
             stroke: textStroke,
             strokeOpacity: textStrokeOpacity,
             strokeWidth: textStrokeWidth,
             textAnchor,
             tickSize,
             tickPadding,
             tickRotate,
-            y: y4,
+            y: y7,
             marginTop,
             marginRight,
             marginBottom,
             marginLeft,
             ...options
         }) : null,
-        !isNoneish(fill) && label !== null ? text([], {
+        !isNoneish2(fill) && label !== null ? text2([], {
             fill,
             fillOpacity,
             ...options,
             lineWidth: void 0,
             textOverflow: void 0,
             facet: "super",
             x: null,
             y: null,
             initializer: function(data2, facets, channels, scales, dimensions) {
-                const scale3 = scales[k2];
+                const scale5 = scales[k3];
                 const {
                     marginTop: marginTop2,
                     marginRight: marginRight2,
                     marginBottom: marginBottom2,
                     marginLeft: marginLeft2
-                } = k2 === "x" && dimensions.inset || dimensions;
-                const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "right");
+                } = k3 === "x" && dimensions.inset || dimensions;
+                const cla = labelAnchor ?? (scale5.bandwidth ? "center" : "right");
                 const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
                 if (cla === "center") {
                     this.frameAnchor = anchor;
                     this.textAnchor = void 0;
                 } else {
                     this.frameAnchor = `${anchor}-${cla}`;
                     this.textAnchor = cla === "right" ? "end" : "start";
                 }
                 this.lineAnchor = anchor;
                 this.dy = anchor === "top" ? -clo : clo;
                 this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
-                this.ariaLabel = `${k2}-axis label`;
+                this.ariaLabel = `${k3}-axis label`;
                 return {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]
+                            value: [label === void 0 ? inferAxisLabel2(k3, scale5, cla) : label]
                         }
                     }
                 };
             }
         }) : null
     );
 }
 
-function axisTickKy(k2, anchor, data, {
+function axisTickKy2(k3, anchor, data, {
     strokeWidth = 1,
     strokeLinecap = null,
     strokeLinejoin = null,
-    facetAnchor = anchor + (k2 === "y" ? "-empty" : ""),
+    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
     frameAnchor = anchor,
     tickSize,
     inset = 0,
     insetLeft = inset,
     insetRight = inset,
     dx = 0,
-    y: y4 = k2 === "y" ? void 0 : null,
+    y: y7 = k3 === "y" ? void 0 : null,
     ...options
 }) {
-    return axisMark(vectorY, k2, `${k2}-axis tick`, data, {
+    return axisMark2(vectorY2, k3, `${k3}-axis tick`, data, {
         strokeWidth,
         strokeLinecap,
         strokeLinejoin,
         facetAnchor,
         frameAnchor,
-        y: y4,
+        y: y7,
         ...options,
-        dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
+        dx: anchor === "left" ? +dx - offset2 + +insetLeft : +dx + offset2 - insetRight,
         anchor: "start",
         length: tickSize,
-        shape: anchor === "left" ? shapeTickLeft : shapeTickRight
+        shape: anchor === "left" ? shapeTickLeft2 : shapeTickRight2
     });
 }
 
-function axisTickKx(k2, anchor, data, {
+function axisTickKx2(k3, anchor, data, {
     strokeWidth = 1,
     strokeLinecap = null,
     strokeLinejoin = null,
-    facetAnchor = anchor + (k2 === "x" ? "-empty" : ""),
+    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
     frameAnchor = anchor,
     tickSize,
     inset = 0,
     insetTop = inset,
     insetBottom = inset,
     dy = 0,
-    x: x4 = k2 === "x" ? void 0 : null,
+    x: x7 = k3 === "x" ? void 0 : null,
     ...options
 }) {
-    return axisMark(vectorX, k2, `${k2}-axis tick`, data, {
+    return axisMark2(vectorX2, k3, `${k3}-axis tick`, data, {
         strokeWidth,
         strokeLinejoin,
         strokeLinecap,
         facetAnchor,
         frameAnchor,
-        x: x4,
+        x: x7,
         ...options,
-        dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
+        dy: anchor === "bottom" ? +dy - offset2 - insetBottom : +dy + offset2 + +insetTop,
         anchor: "start",
         length: tickSize,
-        shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
+        shape: anchor === "bottom" ? shapeTickBottom2 : shapeTickTop2
     });
 }
 
-function axisTextKy(k2, anchor, data, {
-    facetAnchor = anchor + (k2 === "y" ? "-empty" : ""),
+function axisTextKy2(k3, anchor, data, {
+    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
     frameAnchor = anchor,
     tickSize,
     tickRotate = 0,
-    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
-    tickFormat: tickFormat2,
-    text: text2 = typeof tickFormat2 === "function" ? tickFormat2 : void 0,
+    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians6) : 0),
+    tickFormat: tickFormat3,
+    text: text3 = typeof tickFormat3 === "function" ? tickFormat3 : void 0,
     textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
     lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
     fontVariant,
     inset = 0,
     insetLeft = inset,
     insetRight = inset,
     dx = 0,
-    y: y4 = k2 === "y" ? void 0 : null,
+    y: y7 = k3 === "y" ? void 0 : null,
     ...options
 }) {
-    return axisMark(
-        textY,
-        k2,
-        `${k2}-axis tick label`,
+    return axisMark2(
+        textY2,
+        k3,
+        `${k3}-axis tick label`,
         data, {
             facetAnchor,
             frameAnchor,
-            text: text2 === void 0 ? null : text2,
+            text: text3 === void 0 ? null : text3,
             textAnchor,
             lineAnchor,
             fontVariant,
             rotate: tickRotate,
-            y: y4,
+            y: y7,
             ...options,
             dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
         },
-        function(scale3, ticks2, channels) {
+        function(scale5, ticks3, channels) {
             if (fontVariant === void 0)
-                this.fontVariant = inferFontVariant3(scale3);
-            if (text2 === void 0)
-                channels.text = inferTextChannel(scale3, ticks2, tickFormat2);
+                this.fontVariant = inferFontVariant6(scale5);
+            if (text3 === void 0)
+                channels.text = inferTextChannel2(scale5, ticks3, tickFormat3);
         }
     );
 }
 
-function axisTextKx(k2, anchor, data, {
-    facetAnchor = anchor + (k2 === "x" ? "-empty" : ""),
+function axisTextKx2(k3, anchor, data, {
+    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
     frameAnchor = anchor,
     tickSize,
     tickRotate = 0,
-    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
-    tickFormat: tickFormat2,
-    text: text2 = typeof tickFormat2 === "function" ? tickFormat2 : void 0,
+    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians6) : 0),
+    tickFormat: tickFormat3,
+    text: text3 = typeof tickFormat3 === "function" ? tickFormat3 : void 0,
     textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
     lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
     fontVariant,
     inset = 0,
     insetTop = inset,
     insetBottom = inset,
     dy = 0,
-    x: x4 = k2 === "x" ? void 0 : null,
+    x: x7 = k3 === "x" ? void 0 : null,
     ...options
 }) {
-    return axisMark(
-        textX,
-        k2,
-        `${k2}-axis tick label`,
+    return axisMark2(
+        textX2,
+        k3,
+        `${k3}-axis tick label`,
         data, {
             facetAnchor,
             frameAnchor,
-            text: text2 === void 0 ? null : text2,
+            text: text3 === void 0 ? null : text3,
             textAnchor,
             lineAnchor,
             fontVariant,
             rotate: tickRotate,
-            x: x4,
+            x: x7,
             ...options,
             dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
         },
-        function(scale3, ticks2, channels) {
+        function(scale5, ticks3, channels) {
             if (fontVariant === void 0)
-                this.fontVariant = inferFontVariant3(scale3);
-            if (text2 === void 0)
-                channels.text = inferTextChannel(scale3, ticks2, tickFormat2);
+                this.fontVariant = inferFontVariant6(scale5);
+            if (text3 === void 0)
+                channels.text = inferTextChannel2(scale5, ticks3, tickFormat3);
         }
     );
 }
 
-function gridY() {
-    const [data, options] = maybeData(...arguments);
-    return gridKy("y", anchorY(options), data, options);
+function gridY2() {
+    const [data, options] = maybeData2(...arguments);
+    return gridKy2("y", anchorY2(options), data, options);
 }
 
-function gridFy() {
-    const [data, options] = maybeData(...arguments);
-    return gridKy("fy", anchorFy(options), data, options);
+function gridFy2() {
+    const [data, options] = maybeData2(...arguments);
+    return gridKy2("fy", anchorFy2(options), data, options);
 }
 
-function gridX() {
-    const [data, options] = maybeData(...arguments);
-    return gridKx("x", anchorX(options), data, options);
+function gridX2() {
+    const [data, options] = maybeData2(...arguments);
+    return gridKx2("x", anchorX2(options), data, options);
 }
 
-function gridFx() {
-    const [data, options] = maybeData(...arguments);
-    return gridKx("fx", anchorFx(options), data, options);
+function gridFx2() {
+    const [data, options] = maybeData2(...arguments);
+    return gridKx2("fx", anchorFx2(options), data, options);
 }
 
-function gridKy(k2, anchor, data, {
-    y: y4 = k2 === "y" ? void 0 : null,
-    x: x4 = null,
-    x1: x12 = anchor === "left" ? x4 : null,
-    x2: x22 = anchor === "right" ? x4 : null,
+function gridKy2(k3, anchor, data, {
+    y: y7 = k3 === "y" ? void 0 : null,
+    x: x7 = null,
+    x1: x13 = anchor === "left" ? x7 : null,
+    x2: x22 = anchor === "right" ? x7 : null,
     ...options
 }) {
-    return axisMark(ruleY, k2, `${k2}-grid`, data, {
-        y: y4,
-        x1: x12,
+    return axisMark2(ruleY2, k3, `${k3}-grid`, data, {
+        y: y7,
+        x1: x13,
         x2: x22,
-        ...gridDefaults(options)
+        ...gridDefaults2(options)
     });
 }
 
-function gridKx(k2, anchor, data, {
-    x: x4 = k2 === "x" ? void 0 : null,
-    y: y4 = null,
-    y1: y12 = anchor === "top" ? y4 : null,
-    y2: y22 = anchor === "bottom" ? y4 : null,
+function gridKx2(k3, anchor, data, {
+    x: x7 = k3 === "x" ? void 0 : null,
+    y: y7 = null,
+    y1: y13 = anchor === "top" ? y7 : null,
+    y2: y22 = anchor === "bottom" ? y7 : null,
     ...options
 }) {
-    return axisMark(ruleX, k2, `${k2}-grid`, data, {
-        x: x4,
-        y1: y12,
+    return axisMark2(ruleX2, k3, `${k3}-grid`, data, {
+        x: x7,
+        y1: y13,
         y2: y22,
-        ...gridDefaults(options)
+        ...gridDefaults2(options)
     });
 }
 
-function gridDefaults({
-    color: color3 = "currentColor",
-    opacity: opacity2 = 0.1,
-    stroke = color3,
-    strokeOpacity = opacity2,
+function gridDefaults2({
+    color: color5 = "currentColor",
+    opacity: opacity3 = 0.1,
+    stroke = color5,
+    strokeOpacity = opacity3,
     strokeWidth = 1,
     ...options
 }) {
     return {
         stroke,
         strokeOpacity,
         strokeWidth,
         ...options
     };
 }
 
-function axisMark(mark, k2, ariaLabel, data, options, initialize) {
+function axisMark2(mark, k3, ariaLabel, data, options, initialize) {
     let channels;
-    const m3 = mark(
+    const m5 = mark(
         data,
-        initializer(options, function(data2, facets, _channels, scales) {
+        initializer2(options, function(data2, facets, _channels, scales) {
             const {
-                [k2]: scale3
+                [k3]: scale5
             } = scales;
-            if (!scale3)
-                throw new Error(`missing scale: ${k2}`);
+            if (!scale5)
+                throw new Error(`missing scale: ${k3}`);
             let {
-                ticks: ticks2,
+                ticks: ticks3,
                 tickSpacing,
-                interval: interval2
+                interval: interval3
             } = options;
-            if (isTemporalScale(scale3) && typeof ticks2 === "string")
-                interval2 = ticks2, ticks2 = void 0;
+            if (isTemporalScale2(scale5) && typeof ticks3 === "string")
+                interval3 = ticks3, ticks3 = void 0;
             if (data2 == null) {
-                if (isIterable(ticks2)) {
-                    data2 = arrayify2(ticks2);
-                } else if (scale3.ticks) {
-                    if (ticks2 !== void 0) {
-                        data2 = scale3.ticks(ticks2);
+                if (isIterable2(ticks3)) {
+                    data2 = arrayify4(ticks3);
+                } else if (scale5.ticks) {
+                    if (ticks3 !== void 0) {
+                        data2 = scale5.ticks(ticks3);
                     } else {
-                        interval2 = maybeRangeInterval(interval2 === void 0 ? scale3.interval : interval2, scale3.type);
-                        if (interval2 !== void 0) {
-                            const [min4, max5] = extent(scale3.domain());
-                            data2 = interval2.range(min4, interval2.offset(interval2.floor(max5)));
+                        interval3 = maybeRangeInterval2(interval3 === void 0 ? scale5.interval : interval3, scale5.type);
+                        if (interval3 !== void 0) {
+                            const [min7, max9] = extent3(scale5.domain());
+                            data2 = interval3.range(min7, interval3.offset(interval3.floor(max9)));
                         } else {
-                            const [min4, max5] = extent(scale3.range());
-                            ticks2 = (max5 - min4) / (tickSpacing === void 0 ? k2 === "x" ? 80 : 35 : tickSpacing);
-                            data2 = scale3.ticks(ticks2);
+                            const [min7, max9] = extent3(scale5.range());
+                            ticks3 = (max9 - min7) / (tickSpacing === void 0 ? k3 === "x" ? 80 : 35 : tickSpacing);
+                            data2 = scale5.ticks(ticks3);
                         }
                     }
                 } else {
-                    data2 = scale3.domain();
+                    data2 = scale5.domain();
                 }
-                if (k2 === "y" || k2 === "x") {
-                    facets = [range4(data2)];
+                if (k3 === "y" || k3 === "x") {
+                    facets = [range8(data2)];
                 } else {
-                    channels[k2] = {
-                        scale: k2,
-                        value: identity6
+                    channels[k3] = {
+                        scale: k3,
+                        value: identity13
                     };
                     facets = void 0;
                 }
             }
-            initialize?.call(this, scale3, ticks2, channels);
+            initialize?.call(this, scale5, ticks3, channels);
             return {
                 data: data2,
                 facets,
                 channels: Object.fromEntries(
                     Object.entries(channels).map(([name, channel]) => [name, {
                         ...channel,
-                        value: valueof(data2, channel.value)
+                        value: valueof2(data2, channel.value)
                     }])
                 )
             };
         })
     );
     if (data == null) {
-        channels = m3.channels;
-        m3.channels = {};
+        channels = m5.channels;
+        m5.channels = {};
     } else {
         channels = {};
     }
-    m3.ariaLabel = ariaLabel;
-    return m3;
+    m5.ariaLabel = ariaLabel;
+    return m5;
 }
 
-function inferTextChannel(scale3, ticks2, tickFormat2) {
+function inferTextChannel2(scale5, ticks3, tickFormat3) {
     return {
-        value: inferTickFormat(scale3, ticks2, tickFormat2)
+        value: inferTickFormat2(scale5, ticks3, tickFormat3)
     };
 }
 
-function inferTickFormat(scale3, ticks2, tickFormat2) {
-    return scale3.tickFormat ? scale3.tickFormat(isIterable(ticks2) ? null : ticks2, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === "string" ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : constant2(tickFormat2);
+function inferTickFormat2(scale5, ticks3, tickFormat3) {
+    return scale5.tickFormat ? scale5.tickFormat(isIterable2(ticks3) ? null : ticks3, tickFormat3) : tickFormat3 === void 0 ? formatDefault2 : typeof tickFormat3 === "string" ? (isTemporal2(scale5.domain()) ? utcFormat2 : format3)(tickFormat3) : constant4(tickFormat3);
 }
-var shapeTickBottom = {
+var shapeTickBottom2 = {
     draw(context, l) {
         context.moveTo(0, 0);
         context.lineTo(0, l);
     }
 };
-var shapeTickTop = {
+var shapeTickTop2 = {
     draw(context, l) {
         context.moveTo(0, 0);
         context.lineTo(0, -l);
     }
 };
-var shapeTickLeft = {
+var shapeTickLeft2 = {
     draw(context, l) {
         context.moveTo(0, 0);
         context.lineTo(-l, 0);
     }
 };
-var shapeTickRight = {
+var shapeTickRight2 = {
     draw(context, l) {
         context.moveTo(0, 0);
         context.lineTo(l, 0);
     }
 };
 
-function inferFontVariant3(scale3) {
-    return scale3.bandwidth && scale3.interval === void 0 ? void 0 : "tabular-nums";
+function inferFontVariant6(scale5) {
+    return scale5.bandwidth && scale5.interval === void 0 ? void 0 : "tabular-nums";
 }
 
-function inferScaleOrder(scale3) {
-    return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));
+function inferScaleOrder2(scale5) {
+    return Math.sign(orderof2(scale5.domain())) * Math.sign(orderof2(scale5.range()));
 }
 
-function inferAxisLabel(key, scale3, labelAnchor) {
-    const label = scale3.label;
-    if (scale3.bandwidth || !label?.inferred)
+function inferAxisLabel2(key, scale5, labelAnchor) {
+    const label = scale5.label;
+    if (scale5.bandwidth || !label?.inferred)
         return label;
-    const order = inferScaleOrder(scale3);
+    const order = inferScaleOrder2(scale5);
     return order ? key === "x" || labelAnchor === "center" ? key === "x" === order < 0 ? `\u2190 ${label}` : `${label} \u2192` : `${order < 0 ? "\u2191 " : "\u2193 "}${label}` : label;
 }
 
-// node_modules/@observablehq/plot/src/marks/frame.js
-var defaults4 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/frame.js
+var defaults24 = {
     ariaLabel: "frame",
     fill: "none",
     stroke: "currentColor"
 };
-var lineDefaults = {
+var lineDefaults2 = {
     ariaLabel: "frame",
     fill: null,
     stroke: "currentColor",
     strokeLinecap: "square"
 };
-var Frame = class extends Mark {
+var Frame2 = class extends Mark2 {
     constructor(options = {}) {
         const {
             anchor = null,
                 inset = 0,
                 insetTop = inset,
                 insetRight = inset,
                 insetBottom = inset,
                 insetLeft = inset,
                 rx,
                 ry
         } = options;
-        super(void 0, void 0, options, anchor == null ? defaults4 : lineDefaults);
-        this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
-        this.insetTop = number5(insetTop);
-        this.insetRight = number5(insetRight);
-        this.insetBottom = number5(insetBottom);
-        this.insetLeft = number5(insetLeft);
-        this.rx = number5(rx);
-        this.ry = number5(ry);
+        super(void 0, void 0, options, anchor == null ? defaults24 : lineDefaults2);
+        this.anchor = maybeKeyword2(anchor, "anchor", ["top", "right", "bottom", "left"]);
+        this.insetTop = number11(insetTop);
+        this.insetRight = number11(insetRight);
+        this.insetBottom = number11(insetBottom);
+        this.insetLeft = number11(insetLeft);
+        this.rx = number11(rx);
+        this.ry = number11(ry);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             marginTop,
             marginRight,
             marginBottom,
             marginLeft,
             width,
             height
@@ -27817,647 +62523,647 @@
             insetTop,
             insetRight,
             insetBottom,
             insetLeft,
             rx,
             ry
         } = this;
-        const x12 = marginLeft + insetLeft;
+        const x13 = marginLeft + insetLeft;
         const x22 = width - marginRight - insetRight;
-        const y12 = marginTop + insetTop;
+        const y13 = marginTop + insetTop;
         const y22 = height - marginBottom - insetBottom;
-        return create2(anchor ? "svg:line" : "svg:rect", context).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyTransform, this, {}).call(
-            anchor === "left" ? (line2) => line2.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line2) => line2.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect2) => rect2.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
+        return create4(anchor ? "svg:line" : "svg:rect", context).call(applyIndirectStyles2, this, dimensions, context).call(applyDirectStyles2, this).call(applyTransform2, this, {}).call(
+            anchor === "left" ? (line3) => line3.attr("x1", x13).attr("x2", x13).attr("y1", y13).attr("y2", y22) : anchor === "right" ? (line3) => line3.attr("x1", x22).attr("x2", x22).attr("y1", y13).attr("y2", y22) : anchor === "top" ? (line3) => line3.attr("x1", x13).attr("x2", x22).attr("y1", y13).attr("y2", y13) : anchor === "bottom" ? (line3) => line3.attr("x1", x13).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect3) => rect3.attr("x", x13).attr("y", y13).attr("width", x22 - x13).attr("height", y22 - y13).attr("rx", rx).attr("ry", ry)
         ).node();
     }
 };
 
-function frame2(options) {
-    return new Frame(options);
+function frame4(options) {
+    return new Frame2(options);
 }
 
-// node_modules/@observablehq/plot/src/plot.js
-function plot(options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/plot.js
+function plot2(options = {}) {
     const {
         facet,
         style,
         caption,
         ariaLabel,
         ariaDescription
     } = options;
-    const className = maybeClassName(options.className);
-    const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
-    const topFacetState = maybeTopFacet(facet, options);
+    const className = maybeClassName2(options.className);
+    const marks3 = options.marks === void 0 ? [] : flatMarks2(options.marks);
+    const topFacetState = maybeTopFacet2(facet, options);
     const facetStateByMark = /* @__PURE__ */ new Map();
-    for (const mark of marks2) {
-        const facetState = maybeMarkFacet(mark, topFacetState, options);
+    for (const mark of marks3) {
+        const facetState = maybeMarkFacet2(mark, topFacetState, options);
         if (facetState)
             facetStateByMark.set(mark, facetState);
     }
     const channelsByScale = /* @__PURE__ */ new Map();
     if (topFacetState)
-        addScaleChannels(channelsByScale, [topFacetState]);
-    addScaleChannels(channelsByScale, facetStateByMark);
-    const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
+        addScaleChannels2(channelsByScale, [topFacetState]);
+    addScaleChannels2(channelsByScale, facetStateByMark);
+    const axes = flatMarks2(inferAxes2(marks3, channelsByScale, options));
     for (const mark of axes) {
-        const facetState = maybeMarkFacet(mark, topFacetState, options);
+        const facetState = maybeMarkFacet2(mark, topFacetState, options);
         if (facetState)
             facetStateByMark.set(mark, facetState);
     }
-    marks2.unshift(...axes);
-    const facets = createFacets(channelsByScale, options);
+    marks3.unshift(...axes);
+    const facets = createFacets2(channelsByScale, options);
     if (facets !== void 0) {
-        const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
-        for (const mark of marks2) {
+        const topFacetsIndex = topFacetState ? facetFilter2(facets, topFacetState) : void 0;
+        for (const mark of marks3) {
             if (mark.facet === null || mark.facet === "super")
                 continue;
             const facetState = facetStateByMark.get(mark);
             if (facetState === void 0)
                 continue;
-            facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
+            facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter2(facets, facetState) : topFacetsIndex;
         }
         const nonEmpty = /* @__PURE__ */ new Set();
         for (const {
                 facetsIndex
             }
             of facetStateByMark.values()) {
-            facetsIndex?.forEach((index3, i) => {
-                if (index3?.length > 0) {
+            facetsIndex?.forEach((index5, i) => {
+                if (index5?.length > 0) {
                     nonEmpty.add(i);
                 }
             });
         }
         facets.forEach(
             0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false
         );
-        for (const mark of marks2) {
+        for (const mark of marks3) {
             if (mark.facet === "exclude") {
                 const facetState = facetStateByMark.get(mark);
                 if (facetState !== void 0)
-                    facetState.facetsIndex = facetExclude(facetState.facetsIndex);
+                    facetState.facetsIndex = facetExclude2(facetState.facetsIndex);
             }
         }
     }
-    for (const key of registry.keys()) {
-        if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
+    for (const key of registry2.keys()) {
+        if (isScaleOptions2(options[key]) && key !== "fx" && key !== "fy") {
             channelsByScale.set(key, []);
         }
     }
     const stateByMark = /* @__PURE__ */ new Map();
-    for (const mark of marks2) {
+    for (const mark of marks3) {
         if (stateByMark.has(mark))
             throw new Error("duplicate mark; each mark must be unique");
         const {
             facetsIndex,
             channels: facetChannels
         } = facetStateByMark.get(mark) ?? {};
         const {
             data,
             facets: facets2,
             channels
         } = mark.initialize(facetsIndex, facetChannels);
-        applyScaleTransforms(channels, options);
+        applyScaleTransforms2(channels, options);
         stateByMark.set(mark, {
             data,
             facets: facets2,
             channels
         });
     }
-    const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark), options);
-    const scales = createScaleFunctions(scaleDescriptors);
-    const dimensions = createDimensions(scaleDescriptors, marks2, options);
-    autoScaleRange(scaleDescriptors, dimensions);
+    const scaleDescriptors = createScales2(addScaleChannels2(channelsByScale, stateByMark), options);
+    const scales = createScaleFunctions2(scaleDescriptors);
+    const dimensions = createDimensions2(scaleDescriptors, marks3, options);
+    autoScaleRange2(scaleDescriptors, dimensions);
     const {
         fx,
         fy
     } = scales;
-    const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
-    const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
-    const context = createContext(options, subdimensions, scaleDescriptors);
+    const subdimensions = fx || fy ? innerDimensions2(scaleDescriptors, dimensions) : dimensions;
+    const superdimensions = fx || fy ? actualDimensions2(scales, dimensions) : dimensions;
+    const context = createContext2(options, subdimensions, scaleDescriptors);
     const newByScale = /* @__PURE__ */ new Set();
     for (const [mark, state] of stateByMark) {
         if (mark.initializer != null) {
             const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
             const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
             if (update.data !== void 0) {
                 state.data = update.data;
             }
             if (update.facets !== void 0) {
                 state.facets = update.facets;
             }
             if (update.channels !== void 0) {
-                inferChannelScales(update.channels);
+                inferChannelScales2(update.channels);
                 Object.assign(state.channels, update.channels);
                 for (const channel of Object.values(update.channels)) {
                     const {
-                        scale: scale3
+                        scale: scale5
                     } = channel;
-                    if (scale3 != null && registry.get(scale3) !== position) {
-                        applyScaleTransform(channel, options);
-                        newByScale.add(scale3);
+                    if (scale5 != null && registry2.get(scale5) !== position2) {
+                        applyScaleTransform2(channel, options);
+                        newByScale.add(scale5);
                     }
                 }
                 const {
                     fx: fx2,
                     fy: fy2
                 } = update.channels;
                 if (fx2 != null || fy2 != null) {
                     const facetState = facetStateByMark.get(mark) ?? {
                         channels: {}
                     };
                     if (fx2 != null)
                         facetState.channels.fx = fx2;
                     if (fy2 != null)
                         facetState.channels.fy = fy2;
-                    facetState.groups = facetGroups(state.data, facetState.channels);
-                    facetState.facetsIndex = state.facets = facetFilter(facets, facetState);
+                    facetState.groups = facetGroups2(state.data, facetState.channels);
+                    facetState.facetsIndex = state.facets = facetFilter2(facets, facetState);
                     facetStateByMark.set(mark, facetState);
                 }
             }
         }
     }
     if (newByScale.size) {
         const newChannelsByScale = /* @__PURE__ */ new Map();
-        addScaleChannels(newChannelsByScale, stateByMark, (key) => newByScale.has(key));
-        addScaleChannels(channelsByScale, stateByMark, (key) => newByScale.has(key));
-        const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
-        const newScales = createScaleFunctions(newScaleDescriptors);
+        addScaleChannels2(newChannelsByScale, stateByMark, (key) => newByScale.has(key));
+        addScaleChannels2(channelsByScale, stateByMark, (key) => newByScale.has(key));
+        const newScaleDescriptors = inheritScaleLabels2(createScales2(newChannelsByScale, options), scaleDescriptors);
+        const newScales = createScaleFunctions2(newScaleDescriptors);
         Object.assign(scaleDescriptors, newScaleDescriptors);
         Object.assign(scales, newScales);
     }
     for (const [mark, state] of stateByMark) {
         state.values = mark.scale(state.channels, scales, context);
     }
     const {
         width,
         height
     } = dimensions;
-    const svg2 = create2("svg", context).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
-        (svg3) => svg3.append("style").text(`
+    const svg3 = create4("svg", context).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
+        (svg4) => svg4.append("style").text(`
         .${className} {
           display: block;
           background: white;
           height: auto;
           height: intrinsic;
           max-width: 100%;
         }
         .${className} text,
         .${className} tspan {
           white-space: pre;
         }
       `)
-    ).call(applyInlineStyles, style).node();
+    ).call(applyInlineStyles2, style).node();
     if (facets !== void 0) {
         const facetDomains = {
             x: fx?.domain(),
             y: fy?.domain()
         };
-        facets.sort(facetOrder(facetDomains));
-        select_default2(svg2).selectAll().data(facets).enter().append("g").attr("aria-label", "facet").attr("transform", facetTranslate(fx, fy, dimensions)).each(function(f) {
-            let empty4 = true;
-            for (const mark of marks2) {
+        facets.sort(facetOrder2(facetDomains));
+        select_default5(svg3).selectAll().data(facets).enter().append("g").attr("aria-label", "facet").attr("transform", facetTranslate2(fx, fy, dimensions)).each(function(f) {
+            let empty7 = true;
+            for (const mark of marks3) {
                 if (mark.facet === "super")
                     continue;
                 const {
                     channels,
-                    values: values2,
-                    facets: indexes2
+                    values: values3,
+                    facets: indexes3
                 } = stateByMark.get(mark);
                 if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty))
                     continue;
-                let index3 = null;
-                if (indexes2) {
-                    index3 = indexes2[facetStateByMark.has(mark) ? f.i : 0];
-                    index3 = mark.filter(index3, channels, values2);
-                    if (index3.length === 0)
+                let index5 = null;
+                if (indexes3) {
+                    index5 = indexes3[facetStateByMark.has(mark) ? f.i : 0];
+                    index5 = mark.filter(index5, channels, values3);
+                    if (index5.length === 0)
                         continue;
-                    index3.fi = f.i;
+                    index5.fi = f.i;
                 }
-                const node = mark.render(index3, scales, values2, subdimensions, context);
+                const node = mark.render(index5, scales, values3, subdimensions, context);
                 if (node == null)
                     continue;
-                empty4 = false;
+                empty7 = false;
                 this.appendChild(node);
             }
-            if (empty4)
+            if (empty7)
                 this.remove();
         });
     }
-    for (const mark of marks2) {
+    for (const mark of marks3) {
         if (facets !== void 0 && mark.facet !== "super")
             continue;
         const {
             channels,
-            values: values2,
-            facets: indexes2
+            values: values3,
+            facets: indexes3
         } = stateByMark.get(mark);
-        let index3 = null;
-        if (indexes2) {
-            index3 = indexes2[0];
-            index3 = mark.filter(index3, channels, values2);
-            if (index3.length === 0)
+        let index5 = null;
+        if (indexes3) {
+            index5 = indexes3[0];
+            index5 = mark.filter(index5, channels, values3);
+            if (index5.length === 0)
                 continue;
         }
-        const node = mark.render(index3, scales, values2, superdimensions, context);
+        const node = mark.render(index5, scales, values3, superdimensions, context);
         if (node != null)
-            svg2.appendChild(node);
+            svg3.appendChild(node);
     }
-    let figure = svg2;
-    const legends = createLegends(scaleDescriptors, context, options);
+    let figure = svg3;
+    const legends = createLegends2(scaleDescriptors, context, options);
     if (caption != null || legends.length > 0) {
         const {
             document: document2
         } = context;
         figure = document2.createElement("figure");
         figure.style.maxWidth = "initial";
-        for (const legend2 of legends)
-            figure.appendChild(legend2);
-        figure.appendChild(svg2);
+        for (const legend3 of legends)
+            figure.appendChild(legend3);
+        figure.appendChild(svg3);
         if (caption != null) {
             const figcaption = document2.createElement("figcaption");
             figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));
             figure.appendChild(figcaption);
         }
     }
-    figure.scale = exposeScales(scaleDescriptors);
-    figure.legend = exposeLegends(scaleDescriptors, context, options);
-    const w = consumeWarnings();
+    figure.scale = exposeScales2(scaleDescriptors);
+    figure.legend = exposeLegends2(scaleDescriptors, context, options);
+    const w = consumeWarnings2();
     if (w > 0) {
-        select_default2(svg2).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
+        select_default5(svg3).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
     }
     return figure;
 }
 
-function plotThis({
-    marks: marks2 = [],
+function plotThis2({
+    marks: marks3 = [],
     ...options
 } = {}) {
-    return plot({
+    return plot2({
         ...options,
-        marks: [...marks2, this]
+        marks: [...marks3, this]
     });
 }
-Mark.prototype.plot = plotThis;
+Mark2.prototype.plot = plotThis2;
 
-function flatMarks(marks2) {
-    return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
+function flatMarks2(marks3) {
+    return marks3.flat(Infinity).filter((mark) => mark != null).map(markify2);
 }
 
-function markify(mark) {
-    return typeof mark.render === "function" ? mark : new Render(mark);
+function markify2(mark) {
+    return typeof mark.render === "function" ? mark : new Render2(mark);
 }
-var Render = class extends Mark {
+var Render2 = class extends Mark2 {
     constructor(render2) {
         if (typeof render2 !== "function")
             throw new TypeError("invalid mark; missing render function");
         super();
         this.render = render2;
     }
     render() {}
 };
 
-function applyScaleTransforms(channels, options) {
+function applyScaleTransforms2(channels, options) {
     for (const name in channels)
-        applyScaleTransform(channels[name], options);
+        applyScaleTransform2(channels[name], options);
     return channels;
 }
 
-function applyScaleTransform(channel, options) {
+function applyScaleTransform2(channel, options) {
     const {
-        scale: scale3
+        scale: scale5
     } = channel;
-    if (scale3 == null)
+    if (scale5 == null)
         return;
     const {
-        type: type2,
+        type: type3,
         percent,
-        interval: interval2,
-        transform: transform2 = percent ? (x4) => x4 * 100 : maybeInterval(interval2, type2)?.floor
-    } = options[scale3] ?? {};
-    if (transform2 != null)
-        channel.value = map4(channel.value, transform2);
+        interval: interval3,
+        transform: transform3 = percent ? (x7) => x7 * 100 : maybeInterval2(interval3, type3)?.floor
+    } = options[scale5] ?? {};
+    if (transform3 != null)
+        channel.value = map9(channel.value, transform3);
 }
 
-function inferChannelScales(channels) {
+function inferChannelScales2(channels) {
     for (const name in channels) {
-        inferChannelScale(name, channels[name]);
+        inferChannelScale2(name, channels[name]);
     }
 }
 
-function addScaleChannels(channelsByScale, stateByMark, filter4 = yes) {
+function addScaleChannels2(channelsByScale, stateByMark, filter7 = yes2) {
     for (const {
             channels
         }
         of stateByMark.values()) {
         for (const name in channels) {
             const channel = channels[name];
             const {
-                scale: scale3
+                scale: scale5
             } = channel;
-            if (scale3 != null && filter4(scale3)) {
-                const scaleChannels = channelsByScale.get(scale3);
+            if (scale5 != null && filter7(scale5)) {
+                const scaleChannels = channelsByScale.get(scale5);
                 if (scaleChannels !== void 0)
                     scaleChannels.push(channel);
                 else
-                    channelsByScale.set(scale3, [channel]);
+                    channelsByScale.set(scale5, [channel]);
             }
         }
     }
     return channelsByScale;
 }
 
-function maybeTopFacet(facet, options) {
+function maybeTopFacet2(facet, options) {
     if (facet == null)
         return;
     const {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = facet;
-    if (x4 == null && y4 == null)
+    if (x7 == null && y7 == null)
         return;
-    const data = arrayify2(facet.data ?? x4 ?? y4);
+    const data = arrayify4(facet.data ?? x7 ?? y7);
     if (data === void 0)
         throw new Error(`missing facet data`);
     const channels = {};
-    if (x4 != null)
-        channels.fx = createChannel(data, {
-            value: x4,
+    if (x7 != null)
+        channels.fx = createChannel2(data, {
+            value: x7,
             scale: "fx"
         });
-    if (y4 != null)
-        channels.fy = createChannel(data, {
-            value: y4,
+    if (y7 != null)
+        channels.fy = createChannel2(data, {
+            value: y7,
             scale: "fy"
         });
-    applyScaleTransforms(channels, options);
-    const groups2 = facetGroups(data, channels);
+    applyScaleTransforms2(channels, options);
+    const groups3 = facetGroups2(data, channels);
     return {
         channels,
-        groups: groups2,
+        groups: groups3,
         data: facet.data
     };
 }
 
-function maybeMarkFacet(mark, topFacetState, options) {
+function maybeMarkFacet2(mark, topFacetState, options) {
     if (mark.facet === null || mark.facet === "super")
         return;
     const {
         fx,
         fy
     } = mark;
     if (fx != null || fy != null) {
-        const data2 = arrayify2(mark.data ?? fx ?? fy);
+        const data2 = arrayify4(mark.data ?? fx ?? fy);
         if (data2 === void 0)
             throw new Error(`missing facet data in ${mark.ariaLabel}`);
         if (data2 === null)
             return;
         const channels2 = {};
         if (fx != null)
-            channels2.fx = createChannel(data2, {
+            channels2.fx = createChannel2(data2, {
                 value: fx,
                 scale: "fx"
             });
         if (fy != null)
-            channels2.fy = createChannel(data2, {
+            channels2.fy = createChannel2(data2, {
                 value: fy,
                 scale: "fy"
             });
-        applyScaleTransforms(channels2, options);
+        applyScaleTransforms2(channels2, options);
         return {
             channels: channels2,
-            groups: facetGroups(data2, channels2)
+            groups: facetGroups2(data2, channels2)
         };
     }
     if (topFacetState === void 0)
         return;
     const {
         channels,
-        groups: groups2,
+        groups: groups3,
         data
     } = topFacetState;
     if (mark.facet !== "auto" || mark.data === data)
         return {
             channels,
-            groups: groups2
+            groups: groups3
         };
-    if ((groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {
-        warn(
+    if ((groups3.size > 1 || groups3.size === 1 && channels.fx && channels.fy && [...groups3][0][1].size > 1) && arrayify4(mark.data)?.length === data.length) {
+        warn2(
             `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
         );
     }
 }
 
-function inferAxes(marks2, channelsByScale, options) {
+function inferAxes2(marks3, channelsByScale, options) {
     let {
-        projection: projection2,
-        x: x4 = {},
-        y: y4 = {},
+        projection: projection3,
+        x: x7 = {},
+        y: y7 = {},
         fx = {},
         fy = {},
-        axis: axis2,
+        axis: axis3,
         grid,
         facet = {},
         facet: {
-            axis: facetAxis = axis2,
+            axis: facetAxis = axis3,
             grid: facetGrid
         } = facet,
         x: {
-            axis: xAxis = axis2,
+            axis: xAxis = axis3,
             grid: xGrid = xAxis === null ? null : grid
-        } = x4,
+        } = x7,
         y: {
-            axis: yAxis = axis2,
+            axis: yAxis = axis3,
             grid: yGrid = yAxis === null ? null : grid
-        } = y4,
+        } = y7,
         fx: {
             axis: fxAxis = facetAxis,
             grid: fxGrid = fxAxis === null ? null : facetGrid
         } = fx,
         fy: {
             axis: fyAxis = facetAxis,
             grid: fyGrid = fyAxis === null ? null : facetGrid
         } = fy
     } = options;
-    if (projection2 || !isScaleOptions(x4) && !hasScaleChannel("x", marks2))
+    if (projection3 || !isScaleOptions2(x7) && !hasScaleChannel2("x", marks3))
         xAxis = xGrid = null;
-    if (projection2 || !isScaleOptions(y4) && !hasScaleChannel("y", marks2))
+    if (projection3 || !isScaleOptions2(y7) && !hasScaleChannel2("y", marks3))
         yAxis = yGrid = null;
     if (!channelsByScale.has("fx"))
         fxAxis = fxGrid = null;
     if (!channelsByScale.has("fy"))
         fyAxis = fyGrid = null;
     if (xAxis === void 0)
-        xAxis = !hasAxis(marks2, "x");
+        xAxis = !hasAxis2(marks3, "x");
     if (yAxis === void 0)
-        yAxis = !hasAxis(marks2, "y");
+        yAxis = !hasAxis2(marks3, "y");
     if (fxAxis === void 0)
-        fxAxis = !hasAxis(marks2, "fx");
+        fxAxis = !hasAxis2(marks3, "fx");
     if (fyAxis === void 0)
-        fyAxis = !hasAxis(marks2, "fy");
+        fyAxis = !hasAxis2(marks3, "fy");
     if (xAxis === true)
         xAxis = "bottom";
     if (yAxis === true)
         yAxis = "left";
     if (fxAxis === true)
         fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
     if (fyAxis === true)
         fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
     const axes = [];
-    maybeGrid(axes, fyGrid, gridFy, fy);
-    maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
-    maybeGrid(axes, fxGrid, gridFx, fx);
-    maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
-    maybeGrid(axes, yGrid, gridY, y4);
-    maybeAxis(axes, yAxis, axisY, "left", "right", options, y4);
-    maybeGrid(axes, xGrid, gridX, x4);
-    maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x4);
+    maybeGrid2(axes, fyGrid, gridFy2, fy);
+    maybeAxis2(axes, fyAxis, axisFy2, "right", "left", facet, fy);
+    maybeGrid2(axes, fxGrid, gridFx2, fx);
+    maybeAxis2(axes, fxAxis, axisFx2, "top", "bottom", facet, fx);
+    maybeGrid2(axes, yGrid, gridY2, y7);
+    maybeAxis2(axes, yAxis, axisY2, "left", "right", options, y7);
+    maybeGrid2(axes, xGrid, gridX2, x7);
+    maybeAxis2(axes, xAxis, axisX2, "bottom", "top", options, x7);
     return axes;
 }
 
-function maybeAxis(axes, axis2, axisType, primary, secondary, defaults21, options) {
-    if (!axis2)
+function maybeAxis2(axes, axis3, axisType, primary, secondary, defaults41, options) {
+    if (!axis3)
         return;
-    const both = isBoth(axis2);
-    options = axisOptions(both ? primary : axis2, defaults21, options);
+    const both = isBoth2(axis3);
+    options = axisOptions2(both ? primary : axis3, defaults41, options);
     const {
-        line: line2
+        line: line3
     } = options;
-    if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2))
-        axes.push(frame2(lineOptions(options)));
+    if ((axisType === axisY2 || axisType === axisX2) && line3 && !isNone2(line3))
+        axes.push(frame4(lineOptions2(options)));
     axes.push(axisType(options));
     if (both)
         axes.push(axisType({
             ...options,
             anchor: secondary,
             label: null
         }));
 }
 
-function maybeGrid(axes, grid, gridType, options) {
-    if (!grid || isNone(grid))
+function maybeGrid2(axes, grid, gridType, options) {
+    if (!grid || isNone2(grid))
         return;
-    axes.push(gridType(gridOptions(grid, options)));
+    axes.push(gridType(gridOptions2(grid, options)));
 }
 
-function isBoth(value) {
+function isBoth2(value) {
     return /^\s*both\s*$/i.test(value);
 }
 
-function axisOptions(anchor, defaults21, {
-    line: line2 = defaults21.line,
-    ticks: ticks2,
+function axisOptions2(anchor, defaults41, {
+    line: line3 = defaults41.line,
+    ticks: ticks3,
     tickSize,
     tickSpacing,
     tickPadding,
-    tickFormat: tickFormat2,
+    tickFormat: tickFormat3,
     tickRotate,
     fontVariant,
     ariaLabel,
     ariaDescription,
-    label = defaults21.label,
+    label = defaults41.label,
     labelAnchor,
     labelOffset
 }) {
     return {
         anchor,
-        line: line2,
-        ticks: ticks2,
+        line: line3,
+        ticks: ticks3,
         tickSize,
         tickSpacing,
         tickPadding,
-        tickFormat: tickFormat2,
+        tickFormat: tickFormat3,
         tickRotate,
         fontVariant,
         ariaLabel,
         ariaDescription,
         label,
         labelAnchor,
         labelOffset
     };
 }
 
-function lineOptions(options) {
+function lineOptions2(options) {
     const {
         anchor,
-        line: line2
+        line: line3
     } = options;
     return {
         anchor,
         facetAnchor: anchor + "-empty",
-        stroke: line2 === true ? void 0 : line2
+        stroke: line3 === true ? void 0 : line3
     };
 }
 
-function gridOptions(grid, {
-    stroke = isColor(grid) ? grid : void 0,
-    ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
+function gridOptions2(grid, {
+    stroke = isColor2(grid) ? grid : void 0,
+    ticks: ticks3 = isGridTicks2(grid) ? grid : void 0,
     tickSpacing,
     ariaLabel,
     ariaDescription
 }) {
     return {
         stroke,
-        ticks: ticks2,
+        ticks: ticks3,
         tickSpacing,
         ariaLabel,
         ariaDescription
     };
 }
 
-function isGridTicks(grid) {
+function isGridTicks2(grid) {
     switch (typeof grid) {
         case "number":
             return true;
         case "string":
-            return !isColor(grid);
+            return !isColor2(grid);
     }
-    return isIterable(grid) || typeof grid?.range === "function";
+    return isIterable2(grid) || typeof grid?.range === "function";
 }
 
-function hasAxis(marks2, k2) {
-    const prefix = `${k2}-axis `;
-    return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));
+function hasAxis2(marks3, k3) {
+    const prefix = `${k3}-axis `;
+    return marks3.some((m5) => m5.ariaLabel?.startsWith(prefix));
 }
 
-function hasScaleChannel(k2, marks2) {
-    for (const mark of marks2) {
+function hasScaleChannel2(k3, marks3) {
+    for (const mark of marks3) {
         for (const key in mark.channels) {
-            if (mark.channels[key].scale === k2) {
+            if (mark.channels[key].scale === k3) {
                 return true;
             }
         }
     }
     return false;
 }
 
-function inheritScaleLabels(newScales, scales) {
+function inheritScaleLabels2(newScales, scales) {
     for (const key in newScales) {
         const newScale = newScales[key];
-        const scale3 = scales[key];
-        if (newScale.label === void 0 && scale3) {
-            newScale.label = scale3.label;
+        const scale5 = scales[key];
+        if (newScale.label === void 0 && scale5) {
+            newScale.label = scale5.label;
         }
     }
     return newScales;
 }
 
-function actualDimensions({
+function actualDimensions2({
     fx,
     fy
 }, dimensions) {
     const {
         marginTop,
         marginRight,
         marginBottom,
         marginLeft,
         width,
         height
-    } = outerDimensions(dimensions);
-    const fxr = fx && outerRange(fx);
-    const fyr = fy && outerRange(fy);
+    } = outerDimensions2(dimensions);
+    const fxr = fx && outerRange2(fx);
+    const fyr = fy && outerRange2(fy);
     return {
         marginTop: fy ? fyr[0] : marginTop,
         marginRight: fx ? width - fxr[1] : marginRight,
         marginBottom: fy ? height - fyr[1] : marginBottom,
         marginLeft: fx ? fxr[0] : marginLeft,
         // Some marks, namely the x- and y-axis labels, want to know what the
         // desired (rather than actual) margins are for positioning.
@@ -28468,1925 +63174,1925 @@
             marginLeft: dimensions.marginLeft
         },
         width,
         height
     };
 }
 
-function outerRange(scale3) {
-    const domain = scale3.domain();
-    let x12 = scale3(domain[0]);
-    let x22 = scale3(domain[domain.length - 1]);
-    if (x22 < x12)
-        [x12, x22] = [x22, x12];
-    return [x12, x22 + scale3.bandwidth()];
-}
-
-// node_modules/@observablehq/plot/src/curve.js
-var curves = /* @__PURE__ */ new Map([
-    ["basis", basis_default2],
-    ["basis-closed", basisClosed_default2],
-    ["basis-open", basisOpen_default],
-    ["bundle", bundle_default],
-    ["bump-x", bumpX],
-    ["bump-y", bumpY],
-    ["cardinal", cardinal_default],
-    ["cardinal-closed", cardinalClosed_default],
-    ["cardinal-open", cardinalOpen_default],
-    ["catmull-rom", catmullRom_default],
-    ["catmull-rom-closed", catmullRomClosed_default],
-    ["catmull-rom-open", catmullRomOpen_default],
-    ["linear", linear_default],
-    ["linear-closed", linearClosed_default],
-    ["monotone-x", monotoneX],
-    ["monotone-y", monotoneY],
-    ["natural", natural_default],
-    ["step", step_default],
-    ["step-after", stepAfter],
-    ["step-before", stepBefore]
+function outerRange2(scale5) {
+    const domain = scale5.domain();
+    let x13 = scale5(domain[0]);
+    let x22 = scale5(domain[domain.length - 1]);
+    if (x22 < x13)
+        [x13, x22] = [x22, x13];
+    return [x13, x22 + scale5.bandwidth()];
+}
+
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/curve.js
+var curves2 = /* @__PURE__ */ new Map([
+    ["basis", basis_default4],
+    ["basis-closed", basisClosed_default4],
+    ["basis-open", basisOpen_default2],
+    ["bundle", bundle_default2],
+    ["bump-x", bumpX2],
+    ["bump-y", bumpY2],
+    ["cardinal", cardinal_default2],
+    ["cardinal-closed", cardinalClosed_default2],
+    ["cardinal-open", cardinalOpen_default2],
+    ["catmull-rom", catmullRom_default2],
+    ["catmull-rom-closed", catmullRomClosed_default2],
+    ["catmull-rom-open", catmullRomOpen_default2],
+    ["linear", linear_default2],
+    ["linear-closed", linearClosed_default2],
+    ["monotone-x", monotoneX2],
+    ["monotone-y", monotoneY2],
+    ["natural", natural_default2],
+    ["step", step_default2],
+    ["step-after", stepAfter2],
+    ["step-before", stepBefore2]
 ]);
 
-function maybeCurve(curve = linear_default, tension) {
+function maybeCurve2(curve = linear_default2, tension) {
     if (typeof curve === "function")
         return curve;
-    const c6 = curves.get(`${curve}`.toLowerCase());
-    if (!c6)
+    const c11 = curves2.get(`${curve}`.toLowerCase());
+    if (!c11)
         throw new Error(`unknown curve: ${curve}`);
     if (tension !== void 0) {
-        if ("beta" in c6) {
-            return c6.beta(tension);
-        } else if ("tension" in c6) {
-            return c6.tension(tension);
-        } else if ("alpha" in c6) {
-            return c6.alpha(tension);
+        if ("beta" in c11) {
+            return c11.beta(tension);
+        } else if ("tension" in c11) {
+            return c11.tension(tension);
+        } else if ("alpha" in c11) {
+            return c11.alpha(tension);
         }
     }
-    return c6;
+    return c11;
 }
 
-function maybeCurveAuto(curve = curveAuto, tension) {
-    return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
+function maybeCurveAuto2(curve = curveAuto2, tension) {
+    return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto2 : maybeCurve2(curve, tension);
 }
 
-function curveAuto(context) {
-    return linear_default(context);
+function curveAuto2(context) {
+    return linear_default2(context);
 }
 
-// node_modules/@observablehq/plot/src/transforms/bin.js
-function binX(outputs = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/bin.js
+function binX2(outputs = {
     y: "count"
 }, options = {}) {
-    [outputs, options] = mergeOptions(outputs, options);
+    [outputs, options] = mergeOptions4(outputs, options);
     const {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = options;
-    return binn(maybeBinValue(x4, options, identity6), null, null, y4, outputs, maybeInsetX(options));
+    return binn2(maybeBinValue2(x7, options, identity13), null, null, y7, outputs, maybeInsetX2(options));
 }
 
-function binY(outputs = {
+function binY2(outputs = {
     x: "count"
 }, options = {}) {
-    [outputs, options] = mergeOptions(outputs, options);
+    [outputs, options] = mergeOptions4(outputs, options);
     const {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = options;
-    return binn(null, maybeBinValue(y4, options, identity6), x4, null, outputs, maybeInsetY(options));
+    return binn2(null, maybeBinValue2(y7, options, identity13), x7, null, outputs, maybeInsetY2(options));
 }
 
-function bin2(outputs = {
+function bin4(outputs = {
     fill: "count"
 }, options = {}) {
-    [outputs, options] = mergeOptions(outputs, options);
+    [outputs, options] = mergeOptions4(outputs, options);
     const {
-        x: x4,
-        y: y4
-    } = maybeBinValueTuple(options);
-    return binn(x4, y4, null, null, outputs, maybeInsetX(maybeInsetY(options)));
+        x: x7,
+        y: y7
+    } = maybeBinValueTuple2(options);
+    return binn2(x7, y7, null, null, outputs, maybeInsetX2(maybeInsetY2(options)));
 }
 
-function maybeDenseInterval(bin3, k2, options = {}) {
-    return options?.interval == null ? options : bin3({
-        [k2]: options?.reduce === void 0 ? reduceFirst : options.reduce,
+function maybeDenseInterval2(bin5, k3, options = {}) {
+    return options?.interval == null ? options : bin5({
+        [k3]: options?.reduce === void 0 ? reduceFirst3 : options.reduce,
         filter: null
     }, options);
 }
 
-function maybeDenseIntervalX(options) {
-    return maybeDenseInterval(binX, "y", options);
+function maybeDenseIntervalX2(options) {
+    return maybeDenseInterval2(binX2, "y", options);
 }
 
-function maybeDenseIntervalY(options) {
-    return maybeDenseInterval(binY, "x", options);
+function maybeDenseIntervalY2(options) {
+    return maybeDenseInterval2(binY2, "x", options);
 }
 
-function binn(bx, by, gx, gy, {
-    data: reduceData = reduceIdentity,
+function binn2(bx, by, gx, gy, {
+    data: reduceData = reduceIdentity2,
     // TODO avoid materializing when unused?
-    filter: filter4 = reduceCount,
+    filter: filter7 = reduceCount2,
     // return only non-empty bins by default
-    sort: sort3,
-    reverse: reverse3,
+    sort: sort5,
+    reverse: reverse5,
     ...outputs
     // output channel definitions
 } = {}, inputs = {}) {
-    bx = maybeBin(bx);
-    by = maybeBin(by);
-    outputs = maybeBinOutputs(outputs, inputs);
-    reduceData = maybeBinReduce(reduceData, identity6);
-    sort3 = sort3 == null ? void 0 : maybeBinOutput("sort", sort3, inputs);
-    filter4 = filter4 == null ? void 0 : maybeBinEvaluator("filter", filter4, inputs);
-    if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
+    bx = maybeBin2(bx);
+    by = maybeBin2(by);
+    outputs = maybeBinOutputs2(outputs, inputs);
+    reduceData = maybeBinReduce2(reduceData, identity13);
+    sort5 = sort5 == null ? void 0 : maybeBinOutput2("sort", sort5, inputs);
+    filter7 = filter7 == null ? void 0 : maybeBinEvaluator2("filter", filter7, inputs);
+    if (gx != null && hasOutput2(outputs, "x", "x1", "x2"))
         gx = null;
-    if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
+    if (gy != null && hasOutput2(outputs, "y", "y1", "y2"))
         gy = null;
-    const [BX1, setBX1] = maybeColumn(bx);
-    const [BX2, setBX2] = maybeColumn(bx);
-    const [BY1, setBY1] = maybeColumn(by);
-    const [BY2, setBY2] = maybeColumn(by);
-    const [k2, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
-    const [GK, setGK] = maybeColumn(k2);
+    const [BX1, setBX1] = maybeColumn2(bx);
+    const [BX2, setBX2] = maybeColumn2(bx);
+    const [BY1, setBY1] = maybeColumn2(by);
+    const [BY2, setBY2] = maybeColumn2(by);
+    const [k3, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
+    const [GK, setGK] = maybeColumn2(k3);
     const {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         z,
         fill,
         stroke,
-        x1: x12,
+        x1: x13,
         x2: x22,
         // consumed if x is an output
-        y1: y12,
+        y1: y13,
         y2: y22,
         // consumed if y is an output
         domain,
         cumulative,
         thresholds,
-        interval: interval2,
+        interval: interval3,
         ...options
     } = inputs;
-    const [GZ, setGZ] = maybeColumn(z);
-    const [vfill] = maybeColorChannel(fill);
-    const [vstroke] = maybeColorChannel(stroke);
-    const [GF, setGF] = maybeColumn(vfill);
-    const [GS, setGS] = maybeColumn(vstroke);
+    const [GZ, setGZ] = maybeColumn2(z);
+    const [vfill] = maybeColorChannel2(fill);
+    const [vstroke] = maybeColorChannel2(stroke);
+    const [GF, setGF] = maybeColumn2(vfill);
+    const [GS, setGS] = maybeColumn2(vstroke);
     return {
         ..."z" in inputs && {
             z: GZ || z
         },
         ..."fill" in inputs && {
             fill: GF || fill
         },
         ..."stroke" in inputs && {
             stroke: GS || stroke
         },
-        ...basic(options, (data, facets) => {
-            const K2 = valueof(data, k2);
-            const Z = valueof(data, z);
-            const F = valueof(data, vfill);
-            const S = valueof(data, vstroke);
-            const G = maybeSubgroup(outputs, {
+        ...basic2(options, (data, facets) => {
+            const K3 = valueof2(data, k3);
+            const Z = valueof2(data, z);
+            const F = valueof2(data, vfill);
+            const S = valueof2(data, vstroke);
+            const G = maybeSubgroup2(outputs, {
                 z: Z,
                 fill: F,
                 stroke: S
             });
             const groupFacets = [];
             const groupData = [];
-            const GK2 = K2 && setGK([]);
+            const GK2 = K3 && setGK([]);
             const GZ2 = Z && setGZ([]);
             const GF2 = F && setGF([]);
             const GS2 = S && setGS([]);
             const BX12 = bx && setBX1([]);
             const BX22 = bx && setBX2([]);
             const BY12 = by && setBY1([]);
             const BY22 = by && setBY2([]);
-            const bin3 = bing(bx?.(data), by?.(data));
+            const bin5 = bing2(bx?.(data), by?.(data));
             let i = 0;
             for (const o of outputs)
                 o.initialize(data);
-            if (sort3)
-                sort3.initialize(data);
-            if (filter4)
-                filter4.initialize(data);
+            if (sort5)
+                sort5.initialize(data);
+            if (filter7)
+                filter7.initialize(data);
             for (const facet of facets) {
                 const groupFacet = [];
                 for (const o of outputs)
                     o.scope("facet", facet);
-                if (sort3)
-                    sort3.scope("facet", facet);
-                if (filter4)
-                    filter4.scope("facet", facet);
-                for (const [f, I] of maybeGroup(facet, G)) {
-                    for (const [k3, g] of maybeGroup(I, K2)) {
-                        for (const [b, extent3] of bin3(g)) {
-                            if (filter4 && !filter4.reduce(b, extent3))
+                if (sort5)
+                    sort5.scope("facet", facet);
+                if (filter7)
+                    filter7.scope("facet", facet);
+                for (const [f, I] of maybeGroup2(facet, G)) {
+                    for (const [k4, g] of maybeGroup2(I, K3)) {
+                        for (const [b, extent5] of bin5(g)) {
+                            if (filter7 && !filter7.reduce(b, extent5))
                                 continue;
                             groupFacet.push(i++);
-                            groupData.push(reduceData.reduceIndex(b, data, extent3));
-                            if (K2)
-                                GK2.push(k3);
+                            groupData.push(reduceData.reduceIndex(b, data, extent5));
+                            if (K3)
+                                GK2.push(k4);
                             if (Z)
                                 GZ2.push(G === Z ? f : Z[b[0]]);
                             if (F)
                                 GF2.push(G === F ? f : F[b[0]]);
                             if (S)
                                 GS2.push(G === S ? f : S[b[0]]);
                             if (BX12)
-                                BX12.push(extent3.x1), BX22.push(extent3.x2);
+                                BX12.push(extent5.x1), BX22.push(extent5.x2);
                             if (BY12)
-                                BY12.push(extent3.y1), BY22.push(extent3.y2);
+                                BY12.push(extent5.y1), BY22.push(extent5.y2);
                             for (const o of outputs)
-                                o.reduce(b, extent3);
-                            if (sort3)
-                                sort3.reduce(b);
+                                o.reduce(b, extent5);
+                            if (sort5)
+                                sort5.reduce(b);
                         }
                     }
                 }
                 groupFacets.push(groupFacet);
             }
-            maybeSort(groupFacets, sort3, reverse3);
+            maybeSort2(groupFacets, sort5, reverse5);
             return {
                 data: groupData,
                 facets: groupFacets
             };
         }),
-        ...!hasOutput(outputs, "x") && (BX1 ? {
+        ...!hasOutput2(outputs, "x") && (BX1 ? {
             x1: BX1,
             x2: BX2,
-            x: mid(BX1, BX2)
+            x: mid2(BX1, BX2)
         } : {
-            x: x4,
-            x1: x12,
+            x: x7,
+            x1: x13,
             x2: x22
         }),
-        ...!hasOutput(outputs, "y") && (BY1 ? {
+        ...!hasOutput2(outputs, "y") && (BY1 ? {
             y1: BY1,
             y2: BY2,
-            y: mid(BY1, BY2)
+            y: mid2(BY1, BY2)
         } : {
-            y: y4,
-            y1: y12,
+            y: y7,
+            y1: y13,
             y2: y22
         }),
         ...GK && {
             [gk]: GK
         },
         ...Object.fromEntries(outputs.map(({
             name,
             output
         }) => [name, output]))
     };
 }
 
-function mergeOptions({
+function mergeOptions4({
     cumulative,
     domain,
     thresholds,
-    interval: interval2,
+    interval: interval3,
     ...outputs
 }, options) {
     return [outputs, {
         cumulative,
         domain,
         thresholds,
-        interval: interval2,
+        interval: interval3,
         ...options
     }];
 }
 
-function maybeBinValue(value, {
+function maybeBinValue2(value, {
     cumulative,
     domain,
     thresholds,
-    interval: interval2
+    interval: interval3
 }, defaultValue) {
     value = {
-        ...maybeValue(value)
+        ...maybeValue2(value)
     };
     if (value.domain === void 0)
         value.domain = domain;
     if (value.cumulative === void 0)
         value.cumulative = cumulative;
     if (value.thresholds === void 0)
         value.thresholds = thresholds;
     if (value.interval === void 0)
-        value.interval = interval2;
+        value.interval = interval3;
     if (value.value === void 0)
         value.value = defaultValue;
-    value.thresholds = maybeThresholds(value.thresholds, value.interval);
+    value.thresholds = maybeThresholds2(value.thresholds, value.interval);
     return value;
 }
 
-function maybeBinValueTuple(options) {
+function maybeBinValueTuple2(options) {
     let {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     } = options;
-    x4 = maybeBinValue(x4, options);
-    y4 = maybeBinValue(y4, options);
-    [x4.value, y4.value] = maybeTuple(x4.value, y4.value);
+    x7 = maybeBinValue2(x7, options);
+    y7 = maybeBinValue2(y7, options);
+    [x7.value, y7.value] = maybeTuple2(x7.value, y7.value);
     return {
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     };
 }
 
-function maybeBin(options) {
+function maybeBin2(options) {
     if (options == null)
         return;
     const {
         value,
         cumulative,
-        domain = extent,
+        domain = extent3,
         thresholds
     } = options;
-    const bin3 = (data) => {
-        let V = valueof(data, value);
+    const bin5 = (data) => {
+        let V = valueof2(data, value);
         let T;
-        if (isTemporal(V) || isTimeThresholds(thresholds)) {
-            V = map4(V, coerceDate, Float64Array);
-            let [min4, max5] = typeof domain === "function" ? domain(V) : domain;
-            let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;
+        if (isTemporal2(V) || isTimeThresholds2(thresholds)) {
+            V = map9(V, coerceDate2, Float64Array);
+            let [min7, max9] = typeof domain === "function" ? domain(V) : domain;
+            let t = typeof thresholds === "function" && !isInterval2(thresholds) ? thresholds(V, min7, max9) : thresholds;
             if (typeof t === "number")
-                t = utcTickInterval(min4, max5, t);
-            if (isInterval(t)) {
-                if (domain === extent) {
-                    min4 = t.floor(min4);
-                    max5 = t.offset(t.floor(max5));
+                t = utcTickInterval2(min7, max9, t);
+            if (isInterval2(t)) {
+                if (domain === extent3) {
+                    min7 = t.floor(min7);
+                    max9 = t.offset(t.floor(max9));
                 }
-                t = t.range(min4, t.offset(max5));
+                t = t.range(min7, t.offset(max9));
             }
             T = t;
         } else {
-            V = coerceNumbers(V);
-            let [min4, max5] = typeof domain === "function" ? domain(V) : domain;
-            let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;
+            V = coerceNumbers2(V);
+            let [min7, max9] = typeof domain === "function" ? domain(V) : domain;
+            let t = typeof thresholds === "function" && !isInterval2(thresholds) ? thresholds(V, min7, max9) : thresholds;
             if (typeof t === "number") {
-                if (domain === extent) {
-                    let step = tickIncrement(min4, max5, t);
+                if (domain === extent3) {
+                    let step = tickIncrement2(min7, max9, t);
                     if (isFinite(step)) {
                         if (step > 0) {
-                            let r0 = Math.round(min4 / step);
-                            let r1 = Math.round(max5 / step);
-                            if (!(r0 * step <= min4))
+                            let r0 = Math.round(min7 / step);
+                            let r1 = Math.round(max9 / step);
+                            if (!(r0 * step <= min7))
                                 --r0;
-                            if (!(r1 * step > max5))
+                            if (!(r1 * step > max9))
                                 ++r1;
                             let n = r1 - r0 + 1;
                             t = new Float64Array(n);
                             for (let i = 0; i < n; ++i)
                                 t[i] = (r0 + i) * step;
                         } else if (step < 0) {
                             step = -step;
-                            let r0 = Math.round(min4 * step);
-                            let r1 = Math.round(max5 * step);
-                            if (!(r0 / step <= min4))
+                            let r0 = Math.round(min7 * step);
+                            let r1 = Math.round(max9 * step);
+                            if (!(r0 / step <= min7))
                                 --r0;
-                            if (!(r1 / step > max5))
+                            if (!(r1 / step > max9))
                                 ++r1;
                             let n = r1 - r0 + 1;
                             t = new Float64Array(n);
                             for (let i = 0; i < n; ++i)
                                 t[i] = (r0 + i) / step;
                         } else {
-                            t = [min4];
+                            t = [min7];
                         }
                     } else {
-                        t = [min4];
+                        t = [min7];
                     }
                 } else {
-                    t = ticks(min4, max5, t);
+                    t = ticks2(min7, max9, t);
                 }
-            } else if (isInterval(t)) {
-                if (domain === extent) {
-                    min4 = t.floor(min4);
-                    max5 = t.offset(t.floor(max5));
+            } else if (isInterval2(t)) {
+                if (domain === extent3) {
+                    min7 = t.floor(min7);
+                    max9 = t.offset(t.floor(max9));
                 }
-                t = t.range(min4, t.offset(max5));
+                t = t.range(min7, t.offset(max9));
             }
             T = t;
         }
-        const E2 = [];
+        const E3 = [];
         if (T.length === 1)
-            E2.push([T[0], T[0]]);
+            E3.push([T[0], T[0]]);
         else
             for (let i = 1; i < T.length; ++i)
-                E2.push([T[i - 1], T[i]]);
-        E2.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E2, T, V);
-        return E2;
+                E3.push([T[i - 1], T[i]]);
+        E3.bin = (cumulative < 0 ? bin1cn2 : cumulative > 0 ? bin1cp2 : bin12)(E3, T, V);
+        return E3;
     };
-    bin3.label = labelof(value);
-    return bin3;
+    bin5.label = labelof2(value);
+    return bin5;
 }
 
-function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
+function maybeThresholds2(thresholds, interval3, defaultThresholds = thresholdAuto2) {
     if (thresholds === void 0) {
-        return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
+        return interval3 === void 0 ? defaultThresholds : maybeRangeInterval2(interval3);
     }
     if (typeof thresholds === "string") {
         switch (thresholds.toLowerCase()) {
             case "freedman-diaconis":
-                return thresholdFreedmanDiaconis;
+                return thresholdFreedmanDiaconis2;
             case "scott":
-                return thresholdScott;
+                return thresholdScott2;
             case "sturges":
-                return thresholdSturges;
+                return thresholdSturges2;
             case "auto":
-                return thresholdAuto;
+                return thresholdAuto2;
         }
-        return maybeUtcInterval(thresholds);
+        return maybeUtcInterval2(thresholds);
     }
     return thresholds;
 }
 
-function maybeBinOutputs(outputs, inputs) {
-    return maybeOutputs(outputs, inputs, maybeBinOutput);
+function maybeBinOutputs2(outputs, inputs) {
+    return maybeOutputs2(outputs, inputs, maybeBinOutput2);
 }
 
-function maybeBinOutput(name, reduce2, inputs) {
-    return maybeOutput(name, reduce2, inputs, maybeBinEvaluator);
+function maybeBinOutput2(name, reduce3, inputs) {
+    return maybeOutput2(name, reduce3, inputs, maybeBinEvaluator2);
 }
 
-function maybeBinEvaluator(name, reduce2, inputs) {
-    return maybeEvaluator(name, reduce2, inputs, maybeBinReduce);
+function maybeBinEvaluator2(name, reduce3, inputs) {
+    return maybeEvaluator2(name, reduce3, inputs, maybeBinReduce2);
 }
 
-function maybeBinReduce(reduce2, value) {
-    return maybeReduce(reduce2, value, maybeBinReduceFallback);
+function maybeBinReduce2(reduce3, value) {
+    return maybeReduce3(reduce3, value, maybeBinReduceFallback2);
 }
 
-function maybeBinReduceFallback(reduce2) {
-    switch (`${reduce2}`.toLowerCase()) {
+function maybeBinReduceFallback2(reduce3) {
+    switch (`${reduce3}`.toLowerCase()) {
         case "x":
-            return reduceX;
+            return reduceX3;
         case "x1":
-            return reduceX1;
+            return reduceX12;
         case "x2":
-            return reduceX2;
+            return reduceX22;
         case "y":
-            return reduceY;
+            return reduceY3;
         case "y1":
-            return reduceY1;
+            return reduceY12;
         case "y2":
-            return reduceY2;
+            return reduceY22;
     }
-    throw new Error(`invalid bin reduce: ${reduce2}`);
+    throw new Error(`invalid bin reduce: ${reduce3}`);
 }
 
-function thresholdAuto(values2, min4, max5) {
-    return Math.min(200, thresholdScott(values2, min4, max5));
+function thresholdAuto2(values3, min7, max9) {
+    return Math.min(200, thresholdScott2(values3, min7, max9));
 }
 
-function isTimeThresholds(t) {
-    return isTimeInterval(t) || isIterable(t) && isTemporal(t);
+function isTimeThresholds2(t) {
+    return isTimeInterval2(t) || isIterable2(t) && isTemporal2(t);
 }
 
-function isTimeInterval(t) {
-    return isInterval(t) && typeof t === "function" && t() instanceof Date;
+function isTimeInterval2(t) {
+    return isInterval2(t) && typeof t === "function" && t() instanceof Date;
 }
 
-function isInterval(t) {
+function isInterval2(t) {
     return typeof t?.range === "function";
 }
 
-function bing(EX, EY) {
+function bing2(EX, EY) {
     return EX && EY ? function*(I) {
-        const X3 = EX.bin(I);
-        for (const [ix, [x12, x22]] of EX.entries()) {
-            const Y3 = EY.bin(X3[ix]);
-            for (const [iy, [y12, y22]] of EY.entries()) {
-                yield [Y3[iy], {
-                    x1: x12,
-                    y1: y12,
+        const X4 = EX.bin(I);
+        for (const [ix, [x13, x22]] of EX.entries()) {
+            const Y4 = EY.bin(X4[ix]);
+            for (const [iy, [y13, y22]] of EY.entries()) {
+                yield [Y4[iy], {
+                    x1: x13,
+                    y1: y13,
                     x2: x22,
                     y2: y22
                 }];
             }
         }
     } : EX ? function*(I) {
-        const X3 = EX.bin(I);
-        for (const [i, [x12, x22]] of EX.entries()) {
-            yield [X3[i], {
-                x1: x12,
+        const X4 = EX.bin(I);
+        for (const [i, [x13, x22]] of EX.entries()) {
+            yield [X4[i], {
+                x1: x13,
                 x2: x22
             }];
         }
     } : function*(I) {
-        const Y3 = EY.bin(I);
-        for (const [i, [y12, y22]] of EY.entries()) {
-            yield [Y3[i], {
-                y1: y12,
+        const Y4 = EY.bin(I);
+        for (const [i, [y13, y22]] of EY.entries()) {
+            yield [Y4[i], {
+                y1: y13,
                 y2: y22
             }];
         }
     };
 }
 
-function bin1(E2, T, V) {
-    T = coerceNumbers(T);
+function bin12(E3, T, V) {
+    T = coerceNumbers2(T);
     return (I) => {
-        const B3 = E2.map(() => []);
+        const B5 = E3.map(() => []);
         for (const i of I)
-            B3[bisect_default(T, V[i]) - 1]?.push(i);
-        return B3;
+            B5[bisect_default2(T, V[i]) - 1]?.push(i);
+        return B5;
     };
 }
 
-function bin1cp(E2, T, V) {
-    const bin3 = bin1(E2, T, V);
+function bin1cp2(E3, T, V) {
+    const bin5 = bin12(E3, T, V);
     return (I) => {
-        const B3 = bin3(I);
-        for (let i = 1, n = B3.length; i < n; ++i) {
-            const C3 = B3[i - 1];
-            const b = B3[i];
-            for (const j of C3)
+        const B5 = bin5(I);
+        for (let i = 1, n = B5.length; i < n; ++i) {
+            const C4 = B5[i - 1];
+            const b = B5[i];
+            for (const j of C4)
                 b.push(j);
         }
-        return B3;
+        return B5;
     };
 }
 
-function bin1cn(E2, T, V) {
-    const bin3 = bin1(E2, T, V);
+function bin1cn2(E3, T, V) {
+    const bin5 = bin12(E3, T, V);
     return (I) => {
-        const B3 = bin3(I);
-        for (let i = B3.length - 2; i >= 0; --i) {
-            const C3 = B3[i + 1];
-            const b = B3[i];
-            for (const j of C3)
+        const B5 = bin5(I);
+        for (let i = B5.length - 2; i >= 0; --i) {
+            const C4 = B5[i + 1];
+            const b = B5[i];
+            for (const j of C4)
                 b.push(j);
         }
-        return B3;
+        return B5;
     };
 }
 
-function mid1(x12, x22) {
-    const m3 = (+x12 + +x22) / 2;
-    return x12 instanceof Date ? new Date(m3) : m3;
+function mid12(x13, x22) {
+    const m5 = (+x13 + +x22) / 2;
+    return x13 instanceof Date ? new Date(m5) : m5;
 }
-var reduceX = {
-    reduceIndex(I, X3, {
-        x1: x12,
+var reduceX3 = {
+    reduceIndex(I, X4, {
+        x1: x13,
         x2: x22
     }) {
-        return mid1(x12, x22);
+        return mid12(x13, x22);
     }
 };
-var reduceY = {
-    reduceIndex(I, X3, {
-        y1: y12,
+var reduceY3 = {
+    reduceIndex(I, X4, {
+        y1: y13,
         y2: y22
     }) {
-        return mid1(y12, y22);
+        return mid12(y13, y22);
     }
 };
-var reduceX1 = {
-    reduceIndex(I, X3, {
-        x1: x12
+var reduceX12 = {
+    reduceIndex(I, X4, {
+        x1: x13
     }) {
-        return x12;
+        return x13;
     }
 };
-var reduceX2 = {
-    reduceIndex(I, X3, {
+var reduceX22 = {
+    reduceIndex(I, X4, {
         x2: x22
     }) {
         return x22;
     }
 };
-var reduceY1 = {
-    reduceIndex(I, X3, {
-        y1: y12
+var reduceY12 = {
+    reduceIndex(I, X4, {
+        y1: y13
     }) {
-        return y12;
+        return y13;
     }
 };
-var reduceY2 = {
-    reduceIndex(I, X3, {
+var reduceY22 = {
+    reduceIndex(I, X4, {
         y2: y22
     }) {
         return y22;
     }
 };
 
-// node_modules/@observablehq/plot/src/transforms/identity.js
-function maybeIdentityX(options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/identity.js
+function maybeIdentityX2(options = {}) {
     const {
-        x: x4,
-        x1: x12,
+        x: x7,
+        x1: x13,
         x2: x22
     } = options;
-    return x12 === void 0 && x22 === void 0 && x4 === void 0 ? {
+    return x13 === void 0 && x22 === void 0 && x7 === void 0 ? {
         ...options,
-        x: identity6
+        x: identity13
     } : options;
 }
 
-function maybeIdentityY(options = {}) {
+function maybeIdentityY2(options = {}) {
     const {
-        y: y4,
-        y1: y12,
+        y: y7,
+        y1: y13,
         y2: y22
     } = options;
-    return y12 === void 0 && y22 === void 0 && y4 === void 0 ? {
+    return y13 === void 0 && y22 === void 0 && y7 === void 0 ? {
         ...options,
-        y: identity6
+        y: identity13
     } : options;
 }
 
-// node_modules/@observablehq/plot/src/transforms/stack.js
-function stackX(stack2 = {}, options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/stack.js
+function stackX3(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        y1: y12,
-        y: y4 = y12,
-        x: x4,
+        y1: y13,
+        y: y7 = y13,
+        x: x7,
         ...rest
     } = options;
-    const [transform2, Y3, x12, x22] = stackAlias(y4, x4, "x", stack2, rest);
+    const [transform3, Y4, x13, x22] = stackAlias2(y7, x7, "x", stack3, rest);
     return {
-        ...transform2,
-        y1: y12,
-        y: Y3,
-        x1: x12,
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x1: x13,
         x2: x22,
-        x: mid(x12, x22)
+        x: mid2(x13, x22)
     };
 }
 
-function stackX1(stack2 = {}, options = {}) {
+function stackX12(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        y1: y12,
-        y: y4 = y12,
-        x: x4
+        y1: y13,
+        y: y7 = y13,
+        x: x7
     } = options;
-    const [transform2, Y3, X3] = stackAlias(y4, x4, "x", stack2, options);
+    const [transform3, Y4, X4] = stackAlias2(y7, x7, "x", stack3, options);
     return {
-        ...transform2,
-        y1: y12,
-        y: Y3,
-        x: X3
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x: X4
     };
 }
 
-function stackX2(stack2 = {}, options = {}) {
+function stackX22(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        y1: y12,
-        y: y4 = y12,
-        x: x4
+        y1: y13,
+        y: y7 = y13,
+        x: x7
     } = options;
-    const [transform2, Y3, , X3] = stackAlias(y4, x4, "x", stack2, options);
+    const [transform3, Y4, , X4] = stackAlias2(y7, x7, "x", stack3, options);
     return {
-        ...transform2,
-        y1: y12,
-        y: Y3,
-        x: X3
+        ...transform3,
+        y1: y13,
+        y: Y4,
+        x: X4
     };
 }
 
-function stackY(stack2 = {}, options = {}) {
+function stackY3(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        x1: x12,
-        x: x4 = x12,
-        y: y4,
+        x1: x13,
+        x: x7 = x13,
+        y: y7,
         ...rest
     } = options;
-    const [transform2, X3, y12, y22] = stackAlias(x4, y4, "y", stack2, rest);
+    const [transform3, X4, y13, y22] = stackAlias2(x7, y7, "y", stack3, rest);
     return {
-        ...transform2,
-        x1: x12,
-        x: X3,
-        y1: y12,
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y1: y13,
         y2: y22,
-        y: mid(y12, y22)
+        y: mid2(y13, y22)
     };
 }
 
-function stackY1(stack2 = {}, options = {}) {
+function stackY12(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        x1: x12,
-        x: x4 = x12,
-        y: y4
+        x1: x13,
+        x: x7 = x13,
+        y: y7
     } = options;
-    const [transform2, X3, Y3] = stackAlias(x4, y4, "y", stack2, options);
+    const [transform3, X4, Y4] = stackAlias2(x7, y7, "y", stack3, options);
     return {
-        ...transform2,
-        x1: x12,
-        x: X3,
-        y: Y3
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y: Y4
     };
 }
 
-function stackY2(stack2 = {}, options = {}) {
+function stackY22(stack3 = {}, options = {}) {
     if (arguments.length === 1)
-        [stack2, options] = mergeOptions2(stack2);
+        [stack3, options] = mergeOptions5(stack3);
     const {
-        x1: x12,
-        x: x4 = x12,
-        y: y4
-    } = options;
-    const [transform2, X3, , Y3] = stackAlias(x4, y4, "y", stack2, options);
-    return {
-        ...transform2,
-        x1: x12,
-        x: X3,
-        y: Y3
+        x1: x13,
+        x: x7 = x13,
+        y: y7
+    } = options;
+    const [transform3, X4, , Y4] = stackAlias2(x7, y7, "y", stack3, options);
+    return {
+        ...transform3,
+        x1: x13,
+        x: X4,
+        y: Y4
     };
 }
 
-function maybeStackX({
-    x: x4,
-    x1: x12,
+function maybeStackX2({
+    x: x7,
+    x1: x13,
     x2: x22,
     ...options
 } = {}) {
-    if (x12 === void 0 && x22 === void 0)
-        return stackX({
-            x: x4,
+    if (x13 === void 0 && x22 === void 0)
+        return stackX3({
+            x: x7,
             ...options
         });
-    [x12, x22] = maybeZero(x4, x12, x22);
+    [x13, x22] = maybeZero2(x7, x13, x22);
     return {
         ...options,
-        x1: x12,
+        x1: x13,
         x2: x22
     };
 }
 
-function maybeStackY({
-    y: y4,
-    y1: y12,
+function maybeStackY2({
+    y: y7,
+    y1: y13,
     y2: y22,
     ...options
 } = {}) {
-    if (y12 === void 0 && y22 === void 0)
-        return stackY({
-            y: y4,
+    if (y13 === void 0 && y22 === void 0)
+        return stackY3({
+            y: y7,
             ...options
         });
-    [y12, y22] = maybeZero(y4, y12, y22);
+    [y13, y22] = maybeZero2(y7, y13, y22);
     return {
         ...options,
-        y1: y12,
+        y1: y13,
         y2: y22
     };
 }
 
-function mergeOptions2(options) {
+function mergeOptions5(options) {
     const {
-        offset: offset2,
+        offset: offset3,
         order,
-        reverse: reverse3,
+        reverse: reverse5,
         ...rest
     } = options;
     return [{
-        offset: offset2,
+        offset: offset3,
         order,
-        reverse: reverse3
+        reverse: reverse5
     }, rest];
 }
 
-function stack(x4, y4 = one2, ky2, {
-    offset: offset2,
+function stack2(x7, y7 = one4, ky3, {
+    offset: offset3,
     order,
-    reverse: reverse3
+    reverse: reverse5
 }, options) {
-    const z = maybeZ(options);
-    const [X3, setX] = maybeColumn(x4);
-    const [Y13, setY1] = column(y4);
-    const [Y23, setY2] = column(y4);
-    offset2 = maybeOffset(offset2);
-    order = maybeOrder(order, offset2, ky2);
+    const z = maybeZ2(options);
+    const [X4, setX] = maybeColumn2(x7);
+    const [Y15, setY1] = column2(y7);
+    const [Y25, setY2] = column2(y7);
+    offset3 = maybeOffset2(offset3);
+    order = maybeOrder2(order, offset3, ky3);
     return [
-        basic(options, (data, facets) => {
-            const X4 = x4 == null ? void 0 : setX(valueof(data, x4));
-            const Y3 = valueof(data, y4, Float64Array);
-            const Z = valueof(data, z);
-            const O = order && order(data, X4, Y3, Z);
+        basic2(options, (data, facets) => {
+            const X5 = x7 == null ? void 0 : setX(valueof2(data, x7));
+            const Y4 = valueof2(data, y7, Float64Array);
+            const Z = valueof2(data, z);
+            const O = order && order(data, X5, Y4, Z);
             const n = data.length;
-            const Y14 = setY1(new Float64Array(n));
-            const Y24 = setY2(new Float64Array(n));
+            const Y16 = setY1(new Float64Array(n));
+            const Y26 = setY2(new Float64Array(n));
             const facetstacks = [];
             for (const facet of facets) {
-                const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];
+                const stacks = X5 ? Array.from(group3(facet, (i) => X5[i]).values()) : [facet];
                 if (O)
-                    applyOrder(stacks, O);
-                for (const stack2 of stacks) {
+                    applyOrder2(stacks, O);
+                for (const stack3 of stacks) {
                     let yn = 0,
                         yp = 0;
-                    if (reverse3)
-                        stack2.reverse();
-                    for (const i of stack2) {
-                        const y5 = Y3[i];
-                        if (y5 < 0)
-                            yn = Y24[i] = (Y14[i] = yn) + y5;
-                        else if (y5 > 0)
-                            yp = Y24[i] = (Y14[i] = yp) + y5;
+                    if (reverse5)
+                        stack3.reverse();
+                    for (const i of stack3) {
+                        const y8 = Y4[i];
+                        if (y8 < 0)
+                            yn = Y26[i] = (Y16[i] = yn) + y8;
+                        else if (y8 > 0)
+                            yp = Y26[i] = (Y16[i] = yp) + y8;
                         else
-                            Y24[i] = Y14[i] = yp;
+                            Y26[i] = Y16[i] = yp;
                     }
                 }
                 facetstacks.push(stacks);
             }
-            if (offset2)
-                offset2(facetstacks, Y14, Y24, Z);
+            if (offset3)
+                offset3(facetstacks, Y16, Y26, Z);
             return {
                 data,
                 facets
             };
         }),
-        X3,
-        Y13,
-        Y23
+        X4,
+        Y15,
+        Y25
     ];
 }
-var stackAlias = stack;
+var stackAlias2 = stack2;
 
-function maybeOffset(offset2) {
-    if (offset2 == null)
+function maybeOffset2(offset3) {
+    if (offset3 == null)
         return;
-    if (typeof offset2 === "function")
-        return offset2;
-    switch (`${offset2}`.toLowerCase()) {
+    if (typeof offset3 === "function")
+        return offset3;
+    switch (`${offset3}`.toLowerCase()) {
         case "expand":
         case "normalize":
-            return offsetExpand;
+            return offsetExpand2;
         case "center":
         case "silhouette":
-            return offsetCenter;
+            return offsetCenter2;
         case "wiggle":
-            return offsetWiggle;
+            return offsetWiggle2;
     }
-    throw new Error(`unknown offset: ${offset2}`);
+    throw new Error(`unknown offset: ${offset3}`);
 }
 
-function extent2(stack2, Y23) {
-    let min4 = 0,
-        max5 = 0;
-    for (const i of stack2) {
-        const y4 = Y23[i];
-        if (y4 < min4)
-            min4 = y4;
-        if (y4 > max5)
-            max5 = y4;
+function extent4(stack3, Y25) {
+    let min7 = 0,
+        max9 = 0;
+    for (const i of stack3) {
+        const y7 = Y25[i];
+        if (y7 < min7)
+            min7 = y7;
+        if (y7 > max9)
+            max9 = y7;
     }
-    return [min4, max5];
+    return [min7, max9];
 }
 
-function offsetExpand(facetstacks, Y13, Y23) {
+function offsetExpand2(facetstacks, Y15, Y25) {
     for (const stacks of facetstacks) {
-        for (const stack2 of stacks) {
-            const [yn, yp] = extent2(stack2, Y23);
-            for (const i of stack2) {
-                const m3 = 1 / (yp - yn || 1);
-                Y13[i] = m3 * (Y13[i] - yn);
-                Y23[i] = m3 * (Y23[i] - yn);
+        for (const stack3 of stacks) {
+            const [yn, yp] = extent4(stack3, Y25);
+            for (const i of stack3) {
+                const m5 = 1 / (yp - yn || 1);
+                Y15[i] = m5 * (Y15[i] - yn);
+                Y25[i] = m5 * (Y25[i] - yn);
             }
         }
     }
 }
 
-function offsetCenter(facetstacks, Y13, Y23) {
+function offsetCenter2(facetstacks, Y15, Y25) {
     for (const stacks of facetstacks) {
-        for (const stack2 of stacks) {
-            const [yn, yp] = extent2(stack2, Y23);
-            for (const i of stack2) {
-                const m3 = (yp + yn) / 2;
-                Y13[i] -= m3;
-                Y23[i] -= m3;
+        for (const stack3 of stacks) {
+            const [yn, yp] = extent4(stack3, Y25);
+            for (const i of stack3) {
+                const m5 = (yp + yn) / 2;
+                Y15[i] -= m5;
+                Y25[i] -= m5;
             }
         }
-        offsetZero(stacks, Y13, Y23);
+        offsetZero2(stacks, Y15, Y25);
     }
-    offsetCenterFacets(facetstacks, Y13, Y23);
+    offsetCenterFacets2(facetstacks, Y15, Y25);
 }
 
-function offsetWiggle(facetstacks, Y13, Y23, Z) {
+function offsetWiggle2(facetstacks, Y15, Y25, Z) {
     for (const stacks of facetstacks) {
-        const prev = new InternMap();
-        let y4 = 0;
-        for (const stack2 of stacks) {
+        const prev = new InternMap2();
+        let y7 = 0;
+        for (const stack3 of stacks) {
             let j = -1;
-            const Fi = stack2.map((i) => Math.abs(Y23[i] - Y13[i]));
-            const Df = stack2.map((i) => {
+            const Fi = stack3.map((i) => Math.abs(Y25[i] - Y15[i]));
+            const Df = stack3.map((i) => {
                 j = Z ? Z[i] : ++j;
-                const value = Y23[i] - Y13[i];
+                const value = Y25[i] - Y15[i];
                 const diff = prev.has(j) ? value - prev.get(j) : 0;
                 prev.set(j, value);
                 return diff;
             });
-            const Cf1 = [0, ...cumsum(Df)];
-            for (const i of stack2) {
-                Y13[i] += y4;
-                Y23[i] += y4;
+            const Cf1 = [0, ...cumsum2(Df)];
+            for (const i of stack3) {
+                Y15[i] += y7;
+                Y25[i] += y7;
             }
-            const s1 = sum(Fi);
+            const s1 = sum4(Fi);
             if (s1)
-                y4 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
+                y7 -= sum4(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
         }
-        offsetZero(stacks, Y13, Y23);
+        offsetZero2(stacks, Y15, Y25);
     }
-    offsetCenterFacets(facetstacks, Y13, Y23);
+    offsetCenterFacets2(facetstacks, Y15, Y25);
 }
 
-function offsetZero(stacks, Y13, Y23) {
-    const m3 = min(stacks, (stack2) => min(stack2, (i) => Y13[i]));
-    for (const stack2 of stacks) {
-        for (const i of stack2) {
-            Y13[i] -= m3;
-            Y23[i] -= m3;
+function offsetZero2(stacks, Y15, Y25) {
+    const m5 = min4(stacks, (stack3) => min4(stack3, (i) => Y15[i]));
+    for (const stack3 of stacks) {
+        for (const i of stack3) {
+            Y15[i] -= m5;
+            Y25[i] -= m5;
         }
     }
 }
 
-function offsetCenterFacets(facetstacks, Y13, Y23) {
+function offsetCenterFacets2(facetstacks, Y15, Y25) {
     const n = facetstacks.length;
     if (n === 1)
         return;
     const facets = facetstacks.map((stacks) => stacks.flat());
-    const m3 = facets.map((I) => (min(I, (i) => Y13[i]) + max(I, (i) => Y23[i])) / 2);
-    const m0 = min(m3);
+    const m5 = facets.map((I) => (min4(I, (i) => Y15[i]) + max5(I, (i) => Y25[i])) / 2);
+    const m0 = min4(m5);
     for (let j = 0; j < n; j++) {
-        const p = m0 - m3[j];
+        const p = m0 - m5[j];
         for (const i of facets[j]) {
-            Y13[i] += p;
-            Y23[i] += p;
+            Y15[i] += p;
+            Y25[i] += p;
         }
     }
 }
 
-function maybeOrder(order, offset2, ky2) {
-    if (order === void 0 && offset2 === offsetWiggle)
-        return orderInsideOut;
+function maybeOrder2(order, offset3, ky3) {
+    if (order === void 0 && offset3 === offsetWiggle2)
+        return orderInsideOut2;
     if (order == null)
         return;
     if (typeof order === "string") {
         switch (order.toLowerCase()) {
             case "value":
-            case ky2:
-                return orderY;
+            case ky3:
+                return orderY2;
             case "z":
-                return orderZ;
+                return orderZ2;
             case "sum":
-                return orderSum;
+                return orderSum2;
             case "appearance":
-                return orderAppearance;
+                return orderAppearance2;
             case "inside-out":
-                return orderInsideOut;
+                return orderInsideOut2;
         }
-        return orderFunction(field(order));
+        return orderFunction2(field2(order));
     }
     if (typeof order === "function")
-        return orderFunction(order);
+        return orderFunction2(order);
     if (Array.isArray(order))
-        return orderGiven(order);
+        return orderGiven2(order);
     throw new Error(`invalid order: ${order}`);
 }
 
-function orderY(data, X3, Y3) {
-    return Y3;
+function orderY2(data, X4, Y4) {
+    return Y4;
 }
 
-function orderZ(order, X3, Y3, Z) {
+function orderZ2(order, X4, Y4, Z) {
     return Z;
 }
 
-function orderSum(data, X3, Y3, Z) {
-    return orderZDomain(
+function orderSum2(data, X4, Y4, Z) {
+    return orderZDomain2(
         Z,
-        groupSort(
-            range4(data),
-            (I) => sum(I, (i) => Y3[i]),
+        groupSort2(
+            range8(data),
+            (I) => sum4(I, (i) => Y4[i]),
             (i) => Z[i]
         )
     );
 }
 
-function orderAppearance(data, X3, Y3, Z) {
-    return orderZDomain(
+function orderAppearance2(data, X4, Y4, Z) {
+    return orderZDomain2(
         Z,
-        groupSort(
-            range4(data),
-            (I) => X3[greatest(I, (i) => Y3[i])],
+        groupSort2(
+            range8(data),
+            (I) => X4[greatest2(I, (i) => Y4[i])],
             (i) => Z[i]
         )
     );
 }
 
-function orderInsideOut(data, X3, Y3, Z) {
-    const I = range4(data);
-    const K2 = groupSort(
+function orderInsideOut2(data, X4, Y4, Z) {
+    const I = range8(data);
+    const K3 = groupSort2(
         I,
-        (I2) => X3[greatest(I2, (i) => Y3[i])],
+        (I2) => X4[greatest2(I2, (i) => Y4[i])],
         (i) => Z[i]
     );
-    const sums = rollup(
+    const sums = rollup2(
         I,
-        (I2) => sum(I2, (i) => Y3[i]),
+        (I2) => sum4(I2, (i) => Y4[i]),
         (i) => Z[i]
     );
     const Kp = [],
         Kn = [];
-    let s2 = 0;
-    for (const k2 of K2) {
-        if (s2 < 0) {
-            s2 += sums.get(k2);
-            Kp.push(k2);
+    let s3 = 0;
+    for (const k3 of K3) {
+        if (s3 < 0) {
+            s3 += sums.get(k3);
+            Kp.push(k3);
         } else {
-            s2 -= sums.get(k2);
-            Kn.push(k2);
+            s3 -= sums.get(k3);
+            Kn.push(k3);
         }
     }
-    return orderZDomain(Z, Kn.reverse().concat(Kp));
+    return orderZDomain2(Z, Kn.reverse().concat(Kp));
 }
 
-function orderFunction(f) {
-    return (data) => valueof(data, f);
+function orderFunction2(f) {
+    return (data) => valueof2(data, f);
 }
 
-function orderGiven(domain) {
-    return (data, X3, Y3, Z) => orderZDomain(Z, domain);
+function orderGiven2(domain) {
+    return (data, X4, Y4, Z) => orderZDomain2(Z, domain);
 }
 
-function orderZDomain(Z, domain) {
+function orderZDomain2(Z, domain) {
     if (!Z)
         throw new Error("missing channel: z");
-    domain = new InternMap(domain.map((d, i) => [d, i]));
+    domain = new InternMap2(domain.map((d, i) => [d, i]));
     return Z.map((z) => domain.get(z));
 }
 
-function applyOrder(stacks, O) {
-    for (const stack2 of stacks) {
-        stack2.sort((i, j) => ascendingDefined2(O[i], O[j]));
+function applyOrder2(stacks, O) {
+    for (const stack3 of stacks) {
+        stack3.sort((i, j) => ascendingDefined4(O[i], O[j]));
     }
 }
 
-// node_modules/@observablehq/plot/src/marks/area.js
-var defaults5 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/area.js
+var defaults25 = {
     ariaLabel: "area",
     strokeWidth: 1,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-var Area = class extends Mark {
+var Area2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
-            y1: y12,
+            x1: x13,
+            y1: y13,
             x2: x22,
             y2: y22,
             z,
             curve,
             tension
         } = options;
         super(
             data, {
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x"
                 },
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y"
                 },
                 x2: {
                     value: x22,
                     scale: "x",
                     optional: true
                 },
                 y2: {
                     value: y22,
                     scale: "y",
                     optional: true
                 },
                 z: {
-                    value: maybeZ(options),
+                    value: maybeZ2(options),
                     optional: true
                 }
             },
             options,
-            defaults5
+            defaults25
         );
         this.z = z;
-        this.curve = maybeCurve(curve, tension);
+        this.curve = maybeCurve2(curve, tension);
     }
-    filter(index3) {
-        return index3;
+    filter(index5) {
+        return index5;
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x1: X13,
-            y1: Y13,
-            x2: X23 = X13,
-            y2: Y23 = Y13
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15
         } = channels;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
-            (g) => g.selectAll().data(groupIndex(index3, [X13, Y13, X23, Y23], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales, 0, 0).call(
+            (g) => g.selectAll().data(groupIndex2(index5, [X15, Y15, X25, Y25], this, channels)).enter().append("path").call(applyDirectStyles2, this).call(applyGroupedChannelStyles2, this, channels).attr(
                 "d",
-                area_default5().curve(this.curve).defined((i) => i >= 0).x0((i) => X13[i]).y0((i) => Y13[i]).x1((i) => X23[i]).y1((i) => Y23[i])
+                area_default10().curve(this.curve).defined((i) => i >= 0).x0((i) => X15[i]).y0((i) => Y15[i]).x1((i) => X25[i]).y1((i) => Y25[i])
             )
         ).node();
     }
 };
 
-function area(data, options) {
+function area2(data, options) {
     if (options === void 0)
-        return areaY(data, {
-            x: first,
-            y: second2
+        return areaY2(data, {
+            x: first2,
+            y: second4
         });
-    return new Area(data, options);
+    return new Area2(data, options);
 }
 
-function areaX(data, options) {
+function areaX2(data, options) {
     const {
-        y: y4 = indexOf,
+        y: y7 = indexOf2,
         ...rest
-    } = maybeDenseIntervalY(options);
-    return new Area(data, maybeStackX(maybeIdentityX({
+    } = maybeDenseIntervalY2(options);
+    return new Area2(data, maybeStackX2(maybeIdentityX2({
         ...rest,
-        y1: y4,
+        y1: y7,
         y2: void 0
     })));
 }
 
-function areaY(data, options) {
+function areaY2(data, options) {
     const {
-        x: x4 = indexOf,
+        x: x7 = indexOf2,
         ...rest
-    } = maybeDenseIntervalX(options);
-    return new Area(data, maybeStackY(maybeIdentityY({
+    } = maybeDenseIntervalX2(options);
+    return new Area2(data, maybeStackY2(maybeIdentityY2({
         ...rest,
-        x1: x4,
+        x1: x7,
         x2: void 0
     })));
 }
 
-// node_modules/@observablehq/plot/src/marker.js
-function markers(mark, {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marker.js
+function markers2(mark, {
     marker,
     markerStart = marker,
     markerMid = marker,
     markerEnd = marker
 } = {}) {
-    mark.markerStart = maybeMarker(markerStart);
-    mark.markerMid = maybeMarker(markerMid);
-    mark.markerEnd = maybeMarker(markerEnd);
+    mark.markerStart = maybeMarker2(markerStart);
+    mark.markerMid = maybeMarker2(markerMid);
+    mark.markerEnd = maybeMarker2(markerEnd);
 }
 
-function maybeMarker(marker) {
+function maybeMarker2(marker) {
     if (marker == null || marker === false)
         return null;
     if (marker === true)
-        return markerCircleFill;
+        return markerCircleFill2;
     if (typeof marker === "function")
         return marker;
     switch (`${marker}`.toLowerCase()) {
         case "none":
             return null;
         case "arrow":
-            return markerArrow;
+            return markerArrow2;
         case "dot":
-            return markerDot;
+            return markerDot2;
         case "circle":
         case "circle-fill":
-            return markerCircleFill;
+            return markerCircleFill2;
         case "circle-stroke":
-            return markerCircleStroke;
+            return markerCircleStroke2;
     }
     throw new Error(`invalid marker: ${marker}`);
 }
 
-function markerArrow(color3, context) {
-    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", "auto").attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
+function markerArrow2(color5, context) {
+    return create4("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", "auto").attr("fill", "none").attr("stroke", color5).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
 }
 
-function markerDot(color3, context) {
-    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
+function markerDot2(color5, context) {
+    return create4("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color5).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
 }
 
-function markerCircleFill(color3, context) {
-    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
+function markerCircleFill2(color5, context) {
+    return create4("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color5).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
 }
 
-function markerCircleStroke(color3, context) {
-    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
+function markerCircleStroke2(color5, context) {
+    return create4("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color5).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
 }
-var nextMarkerId = 0;
+var nextMarkerId2 = 0;
 
-function applyMarkers(path2, mark, {
+function applyMarkers2(path3, mark, {
     stroke: S
 }, context) {
-    return applyMarkersColor(path2, mark, S && ((i) => S[i]), context);
+    return applyMarkersColor2(path3, mark, S && ((i) => S[i]), context);
 }
 
-function applyGroupedMarkers(path2, mark, {
+function applyGroupedMarkers2(path3, mark, {
     stroke: S
 }, context) {
-    return applyMarkersColor(path2, mark, S && (([i]) => S[i]), context);
+    return applyMarkersColor2(path3, mark, S && (([i]) => S[i]), context);
 }
 
-function applyMarkersColor(path2, {
+function applyMarkersColor2(path3, {
     markerStart,
     markerMid,
     markerEnd,
     stroke
 }, strokeof = () => stroke, context) {
     const iriByMarkerColor = /* @__PURE__ */ new Map();
 
     function applyMarker(marker) {
         return function(i) {
-            const color3 = strokeof(i);
+            const color5 = strokeof(i);
             let iriByColor = iriByMarkerColor.get(marker);
             if (!iriByColor)
                 iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
-            let iri = iriByColor.get(color3);
+            let iri = iriByColor.get(color5);
             if (!iri) {
-                const node = this.parentNode.insertBefore(marker(color3, context), this);
-                const id2 = `plot-marker-${++nextMarkerId}`;
-                node.setAttribute("id", id2);
-                iriByColor.set(color3, iri = `url(#${id2})`);
+                const node = this.parentNode.insertBefore(marker(color5, context), this);
+                const id3 = `plot-marker-${++nextMarkerId2}`;
+                node.setAttribute("id", id3);
+                iriByColor.set(color5, iri = `url(#${id3})`);
             }
             return iri;
         };
     }
     if (markerStart)
-        path2.attr("marker-start", applyMarker(markerStart));
+        path3.attr("marker-start", applyMarker(markerStart));
     if (markerMid)
-        path2.attr("marker-mid", applyMarker(markerMid));
+        path3.attr("marker-mid", applyMarker(markerMid));
     if (markerEnd)
-        path2.attr("marker-end", applyMarker(markerEnd));
+        path3.attr("marker-end", applyMarker(markerEnd));
 }
 
-// node_modules/@observablehq/plot/src/marks/link.js
-var defaults6 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/link.js
+var defaults26 = {
     ariaLabel: "link",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-var Link = class extends Mark {
+var Link2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
-            y1: y12,
+            x1: x13,
+            y1: y13,
             x2: x22,
             y2: y22,
             curve,
             tension
         } = options;
         super(
             data, {
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x"
                 },
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y"
                 },
                 x2: {
                     value: x22,
                     scale: "x",
                     optional: true
                 },
                 y2: {
                     value: y22,
                     scale: "y",
                     optional: true
                 }
             },
             options,
-            defaults6
+            defaults26
         );
-        this.curve = maybeCurveAuto(curve, tension);
-        markers(this, options);
+        this.curve = maybeCurveAuto2(curve, tension);
+        markers2(this, options);
     }
-    project(channels, values2, context) {
-        if (this.curve !== curveAuto) {
-            super.project(channels, values2, context);
+    project(channels, values3, context) {
+        if (this.curve !== curveAuto2) {
+            super.project(channels, values3, context);
         }
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x1: X13,
-            y1: Y13,
-            x2: X23 = X13,
-            y2: Y23 = Y13
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15
         } = channels;
         const {
             curve
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
-            (g) => g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).attr(
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).attr(
                 "d",
-                curve === curveAuto && context.projection ? sphereLink(context.projection, X13, Y13, X23, Y23) : (i) => {
-                    const p = pathRound();
-                    const c6 = curve(p);
-                    c6.lineStart();
-                    c6.point(X13[i], Y13[i]);
-                    c6.point(X23[i], Y23[i]);
-                    c6.lineEnd();
+                curve === curveAuto2 && context.projection ? sphereLink2(context.projection, X15, Y15, X25, Y25) : (i) => {
+                    const p = pathRound2();
+                    const c11 = curve(p);
+                    c11.lineStart();
+                    c11.point(X15[i], Y15[i]);
+                    c11.point(X25[i], Y25[i]);
+                    c11.lineEnd();
                     return p;
                 }
-            ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
+            ).call(applyChannelStyles2, this, channels).call(applyMarkers2, this, channels, context)
         ).node();
     }
 };
 
-function sphereLink(projection2, X13, Y13, X23, Y23) {
-    const path2 = path_default(projection2);
-    X13 = coerceNumbers(X13);
-    Y13 = coerceNumbers(Y13);
-    X23 = coerceNumbers(X23);
-    Y23 = coerceNumbers(Y23);
-    return (i) => path2({
+function sphereLink2(projection3, X15, Y15, X25, Y25) {
+    const path3 = path_default3(projection3);
+    X15 = coerceNumbers2(X15);
+    Y15 = coerceNumbers2(Y15);
+    X25 = coerceNumbers2(X25);
+    Y25 = coerceNumbers2(Y25);
+    return (i) => path3({
         type: "LineString",
         coordinates: [
-            [X13[i], Y13[i]],
-            [X23[i], Y23[i]]
+            [X15[i], Y15[i]],
+            [X25[i], Y25[i]]
         ]
     });
 }
 
-function link3(data, options = {}) {
+function link6(data, options = {}) {
     let {
-        x: x4,
-        x1: x12,
+        x: x7,
+        x1: x13,
         x2: x22,
-        y: y4,
-        y1: y12,
+        y: y7,
+        y1: y13,
         y2: y22,
         ...remainingOptions
     } = options;
-    [x12, x22] = maybeSameValue(x4, x12, x22);
-    [y12, y22] = maybeSameValue(y4, y12, y22);
-    return new Link(data, {
+    [x13, x22] = maybeSameValue2(x7, x13, x22);
+    [y13, y22] = maybeSameValue2(y7, y13, y22);
+    return new Link2(data, {
         ...remainingOptions,
-        x1: x12,
+        x1: x13,
         x2: x22,
-        y1: y12,
+        y1: y13,
         y2: y22
     });
 }
 
-function maybeSameValue(x4, x12, x22) {
-    if (x4 === void 0) {
-        if (x12 === void 0) {
+function maybeSameValue2(x7, x13, x22) {
+    if (x7 === void 0) {
+        if (x13 === void 0) {
             if (x22 !== void 0)
                 return [x22];
         } else {
             if (x22 === void 0)
-                return [x12];
+                return [x13];
         }
-    } else if (x12 === void 0) {
-        return x22 === void 0 ? [x4] : [x4, x22];
+    } else if (x13 === void 0) {
+        return x22 === void 0 ? [x7] : [x7, x22];
     } else if (x22 === void 0) {
-        return [x4, x12];
+        return [x7, x13];
     }
-    return [x12, x22];
+    return [x13, x22];
 }
 
-// node_modules/@observablehq/plot/src/marks/arrow.js
-var defaults7 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/arrow.js
+var defaults27 = {
     ariaLabel: "arrow",
     fill: "none",
     stroke: "currentColor",
     strokeLinecap: "round",
     strokeMiterlimit: 1,
     strokeWidth: 1.5
 };
-var Arrow = class extends Mark {
+var Arrow2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
-            y1: y12,
+            x1: x13,
+            y1: y13,
             x2: x22,
             y2: y22,
             bend = 0,
             headAngle = 60,
             headLength = 8,
             // Disable the arrow with headLength = 0; or, use Plot.link.
             inset = 0,
             insetStart = inset,
             insetEnd = inset
         } = options;
         super(
             data, {
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x"
                 },
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y"
                 },
                 x2: {
                     value: x22,
                     scale: "x",
                     optional: true
                 },
                 y2: {
                     value: y22,
                     scale: "y",
                     optional: true
                 }
             },
             options,
-            defaults7
+            defaults27
         );
         this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
         this.headAngle = +headAngle;
         this.headLength = +headLength;
         this.insetStart = +insetStart;
         this.insetEnd = +insetEnd;
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x1: X13,
-            y1: Y13,
-            x2: X23 = X13,
-            y2: Y23 = Y13,
+            x1: X15,
+            y1: Y15,
+            x2: X25 = X15,
+            y2: Y25 = Y15,
             SW
         } = channels;
         const {
             strokeWidth,
             bend,
             headAngle,
             headLength,
             insetStart,
             insetEnd
         } = this;
-        const sw = SW ? (i) => SW[i] : constant2(strokeWidth === void 0 ? 1 : strokeWidth);
-        const bendAngle = bend * radians3;
-        const wingAngle = headAngle * radians3 / 2;
+        const sw = SW ? (i) => SW[i] : constant4(strokeWidth === void 0 ? 1 : strokeWidth);
+        const bendAngle = bend * radians6;
+        const wingAngle = headAngle * radians6 / 2;
         const wingScale = headLength / 1.5;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
-            (g) => g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
-                let x12 = X13[i],
-                    y12 = Y13[i],
-                    x22 = X23[i],
-                    y22 = Y23[i];
-                const lineLength = Math.hypot(x22 - x12, y22 - y12);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).attr("d", (i) => {
+                let x13 = X15[i],
+                    y13 = Y15[i],
+                    x22 = X25[i],
+                    y22 = Y25[i];
+                const lineLength = Math.hypot(x22 - x13, y22 - y13);
                 if (lineLength <= insetStart + insetEnd)
                     return null;
-                let lineAngle = Math.atan2(y22 - y12, x22 - x12);
+                let lineAngle = Math.atan2(y22 - y13, x22 - x13);
                 const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);
                 const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
                 if (insetStart || insetEnd) {
                     if (r < 1e5) {
-                        const sign3 = Math.sign(bendAngle);
-                        const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r, sign3);
+                        const sign5 = Math.sign(bendAngle);
+                        const [cx, cy] = pointPointCenter2([x13, y13], [x22, y22], r, sign5);
                         if (insetStart) {
-                            [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));
+                            [x13, y13] = circleCircleIntersect2([cx, cy, r], [x13, y13, insetStart], -sign5 * Math.sign(insetStart));
                         }
                         if (insetEnd) {
-                            const [x5, y5] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign3 * Math.sign(insetEnd));
-                            lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);
-                            x22 = x5, y22 = y5;
+                            const [x7, y7] = circleCircleIntersect2([cx, cy, r], [x22, y22, insetEnd], sign5 * Math.sign(insetEnd));
+                            lineAngle += Math.atan2(y7 - cy, x7 - cx) - Math.atan2(y22 - cy, x22 - cx);
+                            x22 = x7, y22 = y7;
                         }
                     } else {
-                        const dx = x22 - x12,
-                            dy = y22 - y12,
+                        const dx = x22 - x13,
+                            dy = y22 - y13,
                             d = Math.hypot(dx, dy);
                         if (insetStart)
-                            x12 += dx / d * insetStart, y12 += dy / d * insetStart;
+                            x13 += dx / d * insetStart, y13 += dy / d * insetStart;
                         if (insetEnd)
                             x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;
                     }
                 }
                 const endAngle = lineAngle + bendAngle;
                 const leftAngle = endAngle + wingAngle;
                 const rightAngle = endAngle - wingAngle;
                 const x32 = x22 - headLength2 * Math.cos(leftAngle);
                 const y32 = y22 - headLength2 * Math.sin(leftAngle);
-                const x4 = x22 - headLength2 * Math.cos(rightAngle);
-                const y4 = y22 - headLength2 * Math.sin(rightAngle);
-                return `M${x12},${y12}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x4},${y4}`;
-            }).call(applyChannelStyles, this, channels)
+                const x42 = x22 - headLength2 * Math.cos(rightAngle);
+                const y42 = y22 - headLength2 * Math.sin(rightAngle);
+                return `M${x13},${y13}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x42},${y42}`;
+            }).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function pointPointCenter([ax, ay], [bx, by], r, sign3) {
+function pointPointCenter2([ax, ay], [bx, by], r, sign5) {
     const dx = bx - ax,
         dy = by - ay,
         d = Math.hypot(dx, dy);
-    const k2 = sign3 * Math.sqrt(r * r - d * d / 4) / d;
-    return [(ax + bx) / 2 - dy * k2, (ay + by) / 2 + dx * k2];
+    const k3 = sign5 * Math.sqrt(r * r - d * d / 4) / d;
+    return [(ax + bx) / 2 - dy * k3, (ay + by) / 2 + dx * k3];
 }
 
-function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {
+function circleCircleIntersect2([ax, ay, ar], [bx, by, br], sign5) {
     const dx = bx - ax,
         dy = by - ay,
         d = Math.hypot(dx, dy);
-    const x4 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
-    const y4 = sign3 * Math.sqrt(ar * ar - x4 * x4);
-    return [ax + (dx * x4 + dy * y4) / d, ay + (dy * x4 - dx * y4) / d];
+    const x7 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
+    const y7 = sign5 * Math.sqrt(ar * ar - x7 * x7);
+    return [ax + (dx * x7 + dy * y7) / d, ay + (dy * x7 - dx * y7) / d];
 }
 
-function arrow(data, options = {}) {
+function arrow2(data, options = {}) {
     let {
-        x: x4,
-        x1: x12,
+        x: x7,
+        x1: x13,
         x2: x22,
-        y: y4,
-        y1: y12,
+        y: y7,
+        y1: y13,
         y2: y22,
         ...remainingOptions
     } = options;
-    [x12, x22] = maybeSameValue(x4, x12, x22);
-    [y12, y22] = maybeSameValue(y4, y12, y22);
-    return new Arrow(data, {
+    [x13, x22] = maybeSameValue2(x7, x13, x22);
+    [y13, y22] = maybeSameValue2(y7, y13, y22);
+    return new Arrow2(data, {
         ...remainingOptions,
-        x1: x12,
+        x1: x13,
         x2: x22,
-        y1: y12,
+        y1: y13,
         y2: y22
     });
 }
 
-// node_modules/@observablehq/plot/src/marks/bar.js
-var AbstractBar = class extends Mark {
-    constructor(data, channels, options = {}, defaults21) {
-        super(data, channels, options, defaults21);
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/bar.js
+var AbstractBar2 = class extends Mark2 {
+    constructor(data, channels, options = {}, defaults41) {
+        super(data, channels, options, defaults41);
         const {
             inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry
         } = options;
-        this.insetTop = number5(insetTop);
-        this.insetRight = number5(insetRight);
-        this.insetBottom = number5(insetBottom);
-        this.insetLeft = number5(insetLeft);
-        this.rx = impliedString(rx, "auto");
-        this.ry = impliedString(ry, "auto");
+        this.insetTop = number11(insetTop);
+        this.insetRight = number11(insetRight);
+        this.insetBottom = number11(insetBottom);
+        this.insetLeft = number11(insetLeft);
+        this.rx = impliedString2(rx, "auto");
+        this.ry = impliedString2(ry, "auto");
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             rx,
             ry
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
-            (g) => g.selectAll().data(index3).enter().append("rect").call(applyDirectStyles, this).attr("x", this._x(scales, channels, dimensions)).attr("width", this._width(scales, channels, dimensions)).attr("y", this._y(scales, channels, dimensions)).attr("height", this._height(scales, channels, dimensions)).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(this._transform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("rect").call(applyDirectStyles2, this).attr("x", this._x(scales, channels, dimensions)).attr("width", this._width(scales, channels, dimensions)).attr("y", this._y(scales, channels, dimensions)).attr("height", this._height(scales, channels, dimensions)).call(applyAttr2, "rx", rx).call(applyAttr2, "ry", ry).call(applyChannelStyles2, this, channels)
         ).node();
     }
     _x(scales, {
-        x: X3
+        x: X4
     }, {
         marginLeft
     }) {
         const {
             insetLeft
         } = this;
-        return X3 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;
+        return X4 ? (i) => X4[i] + insetLeft : marginLeft + insetLeft;
     }
     _y(scales, {
-        y: Y3
+        y: Y4
     }, {
         marginTop
     }) {
         const {
             insetTop
         } = this;
-        return Y3 ? (i) => Y3[i] + insetTop : marginTop + insetTop;
+        return Y4 ? (i) => Y4[i] + insetTop : marginTop + insetTop;
     }
     _width({
-        x: x4
+        x: x7
     }, {
-        x: X3
+        x: X4
     }, {
         marginRight,
         marginLeft,
         width
     }) {
         const {
             insetLeft,
             insetRight
         } = this;
-        const bandwidth = X3 && x4 ? x4.bandwidth() : width - marginRight - marginLeft;
+        const bandwidth = X4 && x7 ? x7.bandwidth() : width - marginRight - marginLeft;
         return Math.max(0, bandwidth - insetLeft - insetRight);
     }
     _height({
-        y: y4
+        y: y7
     }, {
-        y: Y3
+        y: Y4
     }, {
         marginTop,
         marginBottom,
         height
     }) {
         const {
             insetTop,
             insetBottom
         } = this;
-        const bandwidth = Y3 && y4 ? y4.bandwidth() : height - marginTop - marginBottom;
+        const bandwidth = Y4 && y7 ? y7.bandwidth() : height - marginTop - marginBottom;
         return Math.max(0, bandwidth - insetTop - insetBottom);
     }
 };
-var defaults8 = {
+var defaults28 = {
     ariaLabel: "bar"
 };
-var BarX = class extends AbstractBar {
+var BarX2 = class extends AbstractBar2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
+            x1: x13,
             x2: x22,
-            y: y4
+            y: y7
         } = options;
         super(
             data, {
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x"
                 },
                 x2: {
                     value: x22,
                     scale: "x"
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     type: "band",
                     optional: true
                 }
             },
             options,
-            defaults8
+            defaults28
         );
     }
-    _transform(selection2, mark, {
-        x: x4
+    _transform(selection3, mark, {
+        x: x7
     }) {
-        selection2.call(applyTransform, mark, {
-            x: x4
+        selection3.call(applyTransform2, mark, {
+            x: x7
         }, 0, 0);
     }
     _x({
-        x: x4
+        x: x7
     }, {
-        x1: X13,
-        x2: X23
+        x1: X15,
+        x2: X25
     }, {
         marginLeft
     }) {
         const {
             insetLeft
         } = this;
-        return isCollapsed(x4) ? marginLeft + insetLeft : (i) => Math.min(X13[i], X23[i]) + insetLeft;
+        return isCollapsed2(x7) ? marginLeft + insetLeft : (i) => Math.min(X15[i], X25[i]) + insetLeft;
     }
     _width({
-        x: x4
+        x: x7
     }, {
-        x1: X13,
-        x2: X23
+        x1: X15,
+        x2: X25
     }, {
         marginRight,
         marginLeft,
         width
     }) {
         const {
             insetLeft,
             insetRight
         } = this;
-        return isCollapsed(x4) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight);
+        return isCollapsed2(x7) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X25[i] - X15[i]) - insetLeft - insetRight);
     }
 };
-var BarY = class extends AbstractBar {
+var BarY2 = class extends AbstractBar2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y1: y12,
+            x: x7,
+            y1: y13,
             y2: y22
         } = options;
         super(
             data, {
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y"
                 },
                 y2: {
                     value: y22,
                     scale: "y"
                 },
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     type: "band",
                     optional: true
                 }
             },
             options,
-            defaults8
+            defaults28
         );
     }
-    _transform(selection2, mark, {
-        y: y4
+    _transform(selection3, mark, {
+        y: y7
     }) {
-        selection2.call(applyTransform, mark, {
-            y: y4
+        selection3.call(applyTransform2, mark, {
+            y: y7
         }, 0, 0);
     }
     _y({
-        y: y4
+        y: y7
     }, {
-        y1: Y13,
-        y2: Y23
+        y1: Y15,
+        y2: Y25
     }, {
         marginTop
     }) {
         const {
             insetTop
         } = this;
-        return isCollapsed(y4) ? marginTop + insetTop : (i) => Math.min(Y13[i], Y23[i]) + insetTop;
+        return isCollapsed2(y7) ? marginTop + insetTop : (i) => Math.min(Y15[i], Y25[i]) + insetTop;
     }
     _height({
-        y: y4
+        y: y7
     }, {
-        y1: Y13,
-        y2: Y23
+        y1: Y15,
+        y2: Y25
     }, {
         marginTop,
         marginBottom,
         height
     }) {
         const {
             insetTop,
             insetBottom
         } = this;
-        return isCollapsed(y4) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y23[i] - Y13[i]) - insetTop - insetBottom);
+        return isCollapsed2(y7) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y25[i] - Y15[i]) - insetTop - insetBottom);
     }
 };
 
-function barX(data, options = {
-    y: indexOf,
-    x2: identity6
+function barX2(data, options = {
+    y: indexOf2,
+    x2: identity13
 }) {
-    return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
+    return new BarX2(data, maybeStackX2(maybeIntervalX2(maybeIdentityX2(options))));
 }
 
-function barY(data, options = {
-    x: indexOf,
-    y2: identity6
+function barY2(data, options = {
+    x: indexOf2,
+    y2: identity13
 }) {
-    return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
+    return new BarY2(data, maybeStackY2(maybeIntervalY2(maybeIdentityY2(options))));
 }
 
-// node_modules/@observablehq/plot/src/marks/cell.js
-var defaults9 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/cell.js
+var defaults29 = {
     ariaLabel: "cell"
 };
-var Cell = class extends AbstractBar {
+var Cell2 = class extends AbstractBar2 {
     constructor(data, {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...options
     } = {}) {
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     type: "band",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     type: "band",
                     optional: true
                 }
             },
             options,
-            defaults9
+            defaults29
         );
     }
-    _transform(selection2, mark) {
-        selection2.call(applyTransform, mark, {}, 0, 0);
+    _transform(selection3, mark) {
+        selection3.call(applyTransform2, mark, {}, 0, 0);
     }
 };
 
-function cell(data, options = {}) {
+function cell2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
-    [x4, y4] = maybeTuple(x4, y4);
-    return new Cell(data, {
+    [x7, y7] = maybeTuple2(x7, y7);
+    return new Cell2(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function cellX(data, options = {}) {
+function cellX2(data, options = {}) {
     let {
-        x: x4 = indexOf,
+        x: x7 = indexOf2,
         fill,
         stroke,
         ...remainingOptions
     } = options;
-    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
-        fill = identity6;
-    return new Cell(data, {
+    if (fill === void 0 && maybeColorChannel2(stroke)[0] === void 0)
+        fill = identity13;
+    return new Cell2(data, {
         ...remainingOptions,
-        x: x4,
+        x: x7,
         fill,
         stroke
     });
 }
 
-function cellY(data, options = {}) {
+function cellY2(data, options = {}) {
     let {
-        y: y4 = indexOf,
+        y: y7 = indexOf2,
         fill,
         stroke,
         ...remainingOptions
     } = options;
-    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
-        fill = identity6;
-    return new Cell(data, {
+    if (fill === void 0 && maybeColorChannel2(stroke)[0] === void 0)
+        fill = identity13;
+    return new Cell2(data, {
         ...remainingOptions,
-        y: y4,
+        y: y7,
         fill,
         stroke
     });
 }
 
-// node_modules/@observablehq/plot/src/marks/dot.js
-var defaults10 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/dot.js
+var defaults30 = {
     ariaLabel: "dot",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5
 };
 
-function withDefaultSort(options) {
-    return options.sort === void 0 && options.reverse === void 0 ? sort2({
+function withDefaultSort2(options) {
+    return options.sort === void 0 && options.reverse === void 0 ? sort4({
         channel: "r",
         order: "descending"
     }, options) : options;
 }
-var Dot = class extends Mark {
+var Dot2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             r,
             rotate,
-            symbol: symbol2 = circle_default3,
+            symbol: symbol3 = circle_default6,
             frameAnchor
         } = options;
-        const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
-        const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);
-        const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);
+        const [vrotate, crotate] = maybeNumberChannel2(rotate, 0);
+        const [vsymbol, csymbol] = maybeSymbolChannel2(symbol3);
+        const [vr, cr] = maybeNumberChannel2(r, vsymbol == null ? 3 : 4.5);
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 r: {
                     value: vr,
                     scale: "r",
-                    filter: positive,
+                    filter: positive2,
                     optional: true
                 },
                 rotate: {
                     value: vrotate,
                     optional: true
                 },
                 symbol: {
                     value: vsymbol,
                     scale: "auto",
                     optional: true
                 }
             },
-            withDefaultSort(options),
-            defaults10
+            withDefaultSort2(options),
+            defaults30
         );
         this.r = cr;
         this.rotate = crotate;
         this.symbol = csymbol;
-        this.frameAnchor = maybeFrameAnchor(frameAnchor);
+        this.frameAnchor = maybeFrameAnchor2(frameAnchor);
         const {
             channels
         } = this;
         const {
             symbol: symbolChannel
         } = channels;
         if (symbolChannel) {
@@ -30396,280 +65102,280 @@
             } = channels;
             symbolChannel.hint = {
                 fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill,
                 stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke
             };
         }
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             r: R,
-            rotate: A5,
+            rotate: A6,
             symbol: S
         } = channels;
         const {
             r,
             rotate,
-            symbol: symbol2
+            symbol: symbol3
         } = this;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        const circle2 = this.symbol === circle_default3;
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        const circle3 = this.symbol === circle_default6;
         const size = R ? void 0 : r * r * Math.PI;
-        if (negative(r))
-            index3 = [];
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        if (negative2(r))
+            index5 = [];
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            (g) => g.selectAll().data(index3).enter().append(circle2 ? "circle" : "path").call(applyDirectStyles, this).call(
-                circle2 ? (selection2) => {
-                    selection2.attr("cx", X3 ? (i) => X3[i] : cx).attr("cy", Y3 ? (i) => Y3[i] : cy).attr("r", R ? (i) => R[i] : r);
-                } : (selection2) => {
-                    selection2.attr(
+            (g) => g.selectAll().data(index5).enter().append(circle3 ? "circle" : "path").call(applyDirectStyles2, this).call(
+                circle3 ? (selection3) => {
+                    selection3.attr("cx", X4 ? (i) => X4[i] : cx).attr("cy", Y4 ? (i) => Y4[i] : cy).attr("r", R ? (i) => R[i] : r);
+                } : (selection3) => {
+                    selection3.attr(
                         "transform",
-                        template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}`
+                        template2`translate(${X4 ? (i) => X4[i] : cx},${Y4 ? (i) => Y4[i] : cy})${A6 ? (i) => ` rotate(${A6[i]})` : rotate ? ` rotate(${rotate})` : ``}`
                     ).attr(
                         "d",
                         R && S ? (i) => {
-                            const p = pathRound();
+                            const p = pathRound2();
                             S[i].draw(p, R[i] * R[i] * Math.PI);
                             return p;
                         } : R ? (i) => {
-                            const p = pathRound();
-                            symbol2.draw(p, R[i] * R[i] * Math.PI);
+                            const p = pathRound2();
+                            symbol3.draw(p, R[i] * R[i] * Math.PI);
                             return p;
                         } : S ? (i) => {
-                            const p = pathRound();
+                            const p = pathRound2();
                             S[i].draw(p, size);
                             return p;
                         } : (() => {
-                            const p = pathRound();
-                            symbol2.draw(p, size);
+                            const p = pathRound2();
+                            symbol3.draw(p, size);
                             return p;
                         })()
                     );
                 }
-            ).call(applyChannelStyles, this, channels)
+            ).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function dot(data, options = {}) {
+function dot2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
     if (options.frameAnchor === void 0)
-        [x4, y4] = maybeTuple(x4, y4);
-    return new Dot(data, {
+        [x7, y7] = maybeTuple2(x7, y7);
+    return new Dot2(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function dotX(data, options = {}) {
+function dotX2(data, options = {}) {
     const {
-        x: x4 = identity6,
+        x: x7 = identity13,
         ...remainingOptions
     } = options;
-    return new Dot(data, maybeIntervalMidY({
+    return new Dot2(data, maybeIntervalMidY2({
         ...remainingOptions,
-        x: x4
+        x: x7
     }));
 }
 
-function dotY(data, options = {}) {
+function dotY2(data, options = {}) {
     const {
-        y: y4 = identity6,
+        y: y7 = identity13,
         ...remainingOptions
     } = options;
-    return new Dot(data, maybeIntervalMidX({
+    return new Dot2(data, maybeIntervalMidX2({
         ...remainingOptions,
-        y: y4
+        y: y7
     }));
 }
 
-function circle(data, options) {
-    return dot(data, {
+function circle2(data, options) {
+    return dot2(data, {
         ...options,
         symbol: "circle"
     });
 }
 
-function hexagon(data, options) {
-    return dot(data, {
+function hexagon2(data, options) {
+    return dot2(data, {
         ...options,
         symbol: "hexagon"
     });
 }
 
-// node_modules/@observablehq/plot/src/marks/line.js
-var defaults11 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/line.js
+var defaults31 = {
     ariaLabel: "line",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-var Line = class extends Mark {
+var Line2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             z,
             curve,
             tension
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x"
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y"
                 },
                 z: {
-                    value: maybeZ(options),
+                    value: maybeZ2(options),
                     optional: true
                 }
             },
             options,
-            defaults11
+            defaults31
         );
         this.z = z;
-        this.curve = maybeCurveAuto(curve, tension);
-        markers(this, options);
+        this.curve = maybeCurveAuto2(curve, tension);
+        markers2(this, options);
     }
-    filter(index3) {
-        return index3;
+    filter(index5) {
+        return index5;
     }
-    project(channels, values2, context) {
-        if (this.curve !== curveAuto) {
-            super.project(channels, values2, context);
+    project(channels, values3, context) {
+        if (this.curve !== curveAuto2) {
+            super.project(channels, values3, context);
         }
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: X3,
-            y: Y3
+            x: X4,
+            y: Y4
         } = channels;
         const {
             curve
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
-            (g) => g.selectAll().data(groupIndex(index3, [X3, Y3], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call(
+            (g) => g.selectAll().data(groupIndex2(index5, [X4, Y4], this, channels)).enter().append("path").call(applyDirectStyles2, this).call(applyGroupedChannelStyles2, this, channels).call(applyGroupedMarkers2, this, channels, context).attr(
                 "d",
-                curve === curveAuto && context.projection ? sphereLine(context.projection, X3, Y3) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i])
+                curve === curveAuto2 && context.projection ? sphereLine2(context.projection, X4, Y4) : line_default4().curve(curve).defined((i) => i >= 0).x((i) => X4[i]).y((i) => Y4[i])
             )
         ).node();
     }
 };
 
-function sphereLine(projection2, X3, Y3) {
-    const path2 = path_default(projection2);
-    X3 = coerceNumbers(X3);
-    Y3 = coerceNumbers(Y3);
+function sphereLine2(projection3, X4, Y4) {
+    const path3 = path_default3(projection3);
+    X4 = coerceNumbers2(X4);
+    Y4 = coerceNumbers2(Y4);
     return (I) => {
-        let line2 = [];
-        const lines = [line2];
+        let line3 = [];
+        const lines = [line3];
         for (const i of I) {
             if (i === -1) {
-                line2 = [];
-                lines.push(line2);
+                line3 = [];
+                lines.push(line3);
             } else {
-                line2.push([X3[i], Y3[i]]);
+                line3.push([X4[i], Y4[i]]);
             }
         }
-        return path2({
+        return path3({
             type: "MultiLineString",
             coordinates: lines
         });
     };
 }
 
-function line(data, options = {}) {
+function line2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
-    [x4, y4] = maybeTuple(x4, y4);
-    return new Line(data, {
+    [x7, y7] = maybeTuple2(x7, y7);
+    return new Line2(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function lineX(data, options = {}) {
+function lineX2(data, options = {}) {
     const {
-        x: x4 = identity6,
-        y: y4 = indexOf,
+        x: x7 = identity13,
+        y: y7 = indexOf2,
         ...remainingOptions
     } = options;
-    return new Line(data, maybeDenseIntervalY({
+    return new Line2(data, maybeDenseIntervalY2({
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     }));
 }
 
-function lineY(data, options = {}) {
+function lineY2(data, options = {}) {
     const {
-        x: x4 = indexOf,
-        y: y4 = identity6,
+        x: x7 = indexOf2,
+        y: y7 = identity13,
         ...remainingOptions
     } = options;
-    return new Line(data, maybeDenseIntervalX({
+    return new Line2(data, maybeDenseIntervalX2({
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     }));
 }
 
-// node_modules/@observablehq/plot/src/marks/rect.js
-var defaults12 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/rect.js
+var defaults32 = {
     ariaLabel: "rect"
 };
-var Rect = class extends Mark {
+var Rect2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x1: x12,
-            y1: y12,
+            x1: x13,
+            y1: y13,
             x2: x22,
             y2: y22,
             inset = 0,
             insetTop = inset,
             insetRight = inset,
             insetBottom = inset,
             insetLeft = inset,
             rx,
             ry
         } = options;
         super(
             data, {
                 x1: {
-                    value: x12,
+                    value: x13,
                     scale: "x",
                     optional: true
                 },
                 y1: {
-                    value: y12,
+                    value: y13,
                     scale: "y",
                     optional: true
                 },
                 x2: {
                     value: x22,
                     scale: "x",
                     optional: true
@@ -30677,128 +65383,128 @@
                 y2: {
                     value: y22,
                     scale: "y",
                     optional: true
                 }
             },
             options,
-            defaults12
+            defaults32
         );
-        this.insetTop = number5(insetTop);
-        this.insetRight = number5(insetRight);
-        this.insetBottom = number5(insetBottom);
-        this.insetLeft = number5(insetLeft);
-        this.rx = impliedString(rx, "auto");
-        this.ry = impliedString(ry, "auto");
+        this.insetTop = number11(insetTop);
+        this.insetRight = number11(insetRight);
+        this.insetBottom = number11(insetBottom);
+        this.insetLeft = number11(insetLeft);
+        this.rx = impliedString2(rx, "auto");
+        this.ry = impliedString2(ry, "auto");
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x1: X13,
-            y1: Y13,
-            x2: X23,
-            y2: Y23
+            x1: X15,
+            y1: Y15,
+            x2: X25,
+            y2: Y25
         } = channels;
         const {
             marginTop,
             marginRight,
             marginBottom,
             marginLeft,
             width,
             height
         } = dimensions;
         const {
-            projection: projection2
+            projection: projection3
         } = context;
         const {
             insetTop,
             insetRight,
             insetBottom,
             insetLeft,
             rx,
             ry
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X13 && X23 && x4,
-            y: Y13 && Y23 && y4
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X15 && X25 && x7,
+            y: Y15 && Y25 && y7
         }, 0, 0).call(
-            (g) => g.selectAll().data(index3).enter().append("rect").call(applyDirectStyles, this).attr(
+            (g) => g.selectAll().data(index5).enter().append("rect").call(applyDirectStyles2, this).attr(
                 "x",
-                X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.min(X13[i], X23[i]) + insetLeft : marginLeft + insetLeft
+                X15 && X25 && (projection3 || !isCollapsed2(x7)) ? (i) => Math.min(X15[i], X25[i]) + insetLeft : marginLeft + insetLeft
             ).attr(
                 "y",
-                Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.min(Y13[i], Y23[i]) + insetTop : marginTop + insetTop
+                Y15 && Y25 && (projection3 || !isCollapsed2(y7)) ? (i) => Math.min(Y15[i], Y25[i]) + insetTop : marginTop + insetTop
             ).attr(
                 "width",
-                X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft
+                X15 && X25 && (projection3 || !isCollapsed2(x7)) ? (i) => Math.max(0, Math.abs(X25[i] - X15[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft
             ).attr(
                 "height",
-                Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.max(0, Math.abs(Y13[i] - Y23[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom
-            ).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
+                Y15 && Y25 && (projection3 || !isCollapsed2(y7)) ? (i) => Math.max(0, Math.abs(Y15[i] - Y25[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom
+            ).call(applyAttr2, "rx", rx).call(applyAttr2, "ry", ry).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function rect(data, options) {
-    return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
+function rect2(data, options) {
+    return new Rect2(data, maybeTrivialIntervalX2(maybeTrivialIntervalY2(options)));
 }
 
-function rectX(data, options = {
-    y: indexOf,
+function rectX2(data, options = {
+    y: indexOf2,
     interval: 1,
-    x2: identity6
+    x2: identity13
 }) {
-    return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
+    return new Rect2(data, maybeStackX2(maybeTrivialIntervalY2(maybeIdentityX2(options))));
 }
 
-function rectY(data, options = {
-    x: indexOf,
+function rectY2(data, options = {
+    x: indexOf2,
     interval: 1,
-    y2: identity6
+    y2: identity13
 }) {
-    return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
+    return new Rect2(data, maybeStackY2(maybeTrivialIntervalX2(maybeIdentityY2(options))));
 }
 
-// node_modules/@observablehq/plot/src/marks/auto.js
-function autoSpec(data, options) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/auto.js
+function autoSpec2(data, options) {
     const {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         fx,
         fy,
-        color: color3,
+        color: color5,
         size,
         mark
-    } = autoImpl(data, options);
+    } = autoImpl2(data, options);
     return {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         fx,
         fy,
-        color: color3,
+        color: color5,
         size,
         mark
     };
 }
 
-function autoImpl(data, options) {
-    options = normalizeOptions(options);
+function autoImpl2(data, options) {
+    options = normalizeOptions2(options);
     const {
-        x: x4,
-        y: y4,
-        color: color3,
+        x: x7,
+        y: y7,
+        color: color5,
         size
     } = options;
-    const X3 = materializeValue(data, x4);
-    const Y3 = materializeValue(data, y4);
-    const C3 = materializeValue(data, color3);
-    const S = materializeValue(data, size);
+    const X4 = materializeValue2(data, x7);
+    const Y4 = materializeValue2(data, y7);
+    const C4 = materializeValue2(data, color5);
+    const S = materializeValue2(data, size);
     let {
         fx,
         fy,
         x: {
             value: xValue,
             reduce: xReduce,
             zero: xZero,
@@ -30822,109 +65528,109 @@
         // TODO constant radius?
         mark
     } = options;
     if (xReduce === void 0)
         xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? "count" : null;
     if (yReduce === void 0)
         yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? "count" : null;
-    if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3)) && (yValue == null || isOrdinal(Y3))) {
+    if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal2(X4)) && (yValue == null || isOrdinal2(Y4))) {
         sizeReduce = "count";
     }
     if (xZero === void 0)
-        xZero = isZeroReducer(xReduce) ? true : void 0;
+        xZero = isZeroReducer2(xReduce) ? true : void 0;
     if (yZero === void 0)
-        yZero = isZeroReducer(yReduce) ? true : void 0;
+        yZero = isZeroReducer2(yReduce) ? true : void 0;
     if (xValue == null && yValue == null)
         throw new Error("must specify x or y");
     if (xReduce != null && yValue == null)
         throw new Error("reducing x requires y");
     if (yReduce != null && xValue == null)
         throw new Error("reducing y requires x");
     if (mark === void 0) {
-        mark = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal(X3) || isOrdinal(Y3) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
+        mark = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer2(xReduce) || isZeroReducer2(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal2(X4) || isOrdinal2(Y4) || xReduce == null && yReduce == null && !isMonotonic2(X4) && !isMonotonic2(Y4) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
     }
     let Z;
     let colorMode;
     let markImpl;
     switch (mark) {
         case "dot":
-            markImpl = dot;
+            markImpl = dot2;
             colorMode = "stroke";
             break;
         case "line":
-            markImpl = X3 && Y3 ? line : X3 ? lineX : lineY;
+            markImpl = X4 && Y4 ? line2 : X4 ? lineX2 : lineY2;
             colorMode = "stroke";
-            if (isHighCardinality(C3))
+            if (isHighCardinality2(C4))
                 Z = null;
             break;
         case "area":
-            markImpl = yZero ? areaY : xZero || Y3 && isMonotonic(Y3) ? areaX : areaY;
+            markImpl = yZero ? areaY2 : xZero || Y4 && isMonotonic2(Y4) ? areaX2 : areaY2;
             colorMode = "fill";
-            if (isHighCardinality(C3))
+            if (isHighCardinality2(C4))
                 Z = null;
             break;
         case "rule":
-            markImpl = X3 ? ruleX : ruleY;
+            markImpl = X4 ? ruleX2 : ruleY2;
             colorMode = "stroke";
             break;
         case "bar":
-            markImpl = yZero ? isOrdinalReduced(xReduce, X3) ? barY : rectY : xZero ? isOrdinalReduced(yReduce, Y3) ? barX : rectX : isOrdinalReduced(xReduce, X3) && isOrdinalReduced(yReduce, Y3) ? cell : isOrdinalReduced(xReduce, X3) ? barY : isOrdinalReduced(yReduce, Y3) ? barX : rectY;
+            markImpl = yZero ? isOrdinalReduced2(xReduce, X4) ? barY2 : rectY2 : xZero ? isOrdinalReduced2(yReduce, Y4) ? barX2 : rectX2 : isOrdinalReduced2(xReduce, X4) && isOrdinalReduced2(yReduce, Y4) ? cell2 : isOrdinalReduced2(xReduce, X4) ? barY2 : isOrdinalReduced2(yReduce, Y4) ? barX2 : rectY2;
             colorMode = "fill";
             break;
         default:
             throw new Error(`invalid mark: ${mark}`);
     }
     let markOptions = {
         fx,
         fy,
-        x: X3 ?? void 0,
+        x: X4 ?? void 0,
         // treat null x as undefined for implicit stack
-        y: Y3 ?? void 0,
+        y: Y4 ?? void 0,
         // treat null y as undefined for implicit stack
-        [colorMode]: C3 ?? colorColor,
+        [colorMode]: C4 ?? colorColor,
         z: Z,
         r: S ?? void 0
         // treat null size as undefined for default constant radius
     };
     let transformImpl;
     let transformOptions = {
         [colorMode]: colorReduce ?? void 0,
         r: sizeReduce ?? void 0
     };
     if (xReduce != null && yReduce != null) {
         throw new Error(`cannot reduce both x and y`);
     } else if (yReduce != null) {
         transformOptions.y = yReduce;
-        transformImpl = isOrdinal(X3) ? groupX : binX;
+        transformImpl = isOrdinal2(X4) ? groupX2 : binX2;
     } else if (xReduce != null) {
         transformOptions.x = xReduce;
-        transformImpl = isOrdinal(Y3) ? groupY : binY;
+        transformImpl = isOrdinal2(Y4) ? groupY2 : binY2;
     } else if (colorReduce != null || sizeReduce != null) {
-        if (X3 && Y3) {
-            transformImpl = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin2;
-        } else if (X3) {
-            transformImpl = isOrdinal(X3) ? groupX : binX;
-        } else if (Y3) {
-            transformImpl = isOrdinal(Y3) ? groupY : binY;
+        if (X4 && Y4) {
+            transformImpl = isOrdinal2(X4) && isOrdinal2(Y4) ? group4 : isOrdinal2(X4) ? binY2 : isOrdinal2(Y4) ? binX2 : bin4;
+        } else if (X4) {
+            transformImpl = isOrdinal2(X4) ? groupX2 : binX2;
+        } else if (Y4) {
+            transformImpl = isOrdinal2(Y4) ? groupY2 : binY2;
         }
     }
-    if (transformImpl === bin2 || transformImpl === binX)
+    if (transformImpl === bin4 || transformImpl === binX2)
         markOptions.x = {
-            value: X3,
+            value: X4,
             ...xOptions
         };
-    if (transformImpl === bin2 || transformImpl === binY)
+    if (transformImpl === bin4 || transformImpl === binY2)
         markOptions.y = {
-            value: Y3,
+            value: Y4,
             ...yOptions
         };
     if (xZero === void 0)
-        xZero = X3 && !(transformImpl === bin2 || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);
+        xZero = X4 && !(transformImpl === bin4 || transformImpl === binX2) && (markImpl === barX2 || markImpl === areaX2 || markImpl === rectX2 || markImpl === ruleY2);
     if (yZero === void 0)
-        yZero = Y3 && !(transformImpl === bin2 || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);
+        yZero = Y4 && !(transformImpl === bin4 || transformImpl === binY2) && (markImpl === barY2 || markImpl === areaY2 || markImpl === rectY2 || markImpl === ruleX2);
     return {
         fx: fx ?? null,
         fy: fy ?? null,
         x: {
             value: xValue ?? null,
             reduce: xReduce ?? null,
             zero: !!xZero,
@@ -30952,136 +65658,136 @@
         markOptions,
         transformImpl,
         transformOptions,
         colorMode
     };
 }
 
-function auto(data, options) {
+function auto2(data, options) {
     const {
         fx,
         fy,
         x: {
             zero: xZero
         },
         y: {
             zero: yZero
         },
         markImpl,
         markOptions,
         transformImpl,
         transformOptions,
         colorMode
-    } = autoImpl(data, options);
-    const frames = fx != null || fy != null ? frame2({
+    } = autoImpl2(data, options);
+    const frames = fx != null || fy != null ? frame4({
         strokeOpacity: 0.1
     }) : null;
-    const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];
+    const rules = [xZero ? ruleX2([0]) : null, yZero ? ruleY2([0]) : null];
     const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions) : markOptions);
-    return colorMode === "stroke" ? marks(frames, rules, mark) : marks(frames, mark, rules);
+    return colorMode === "stroke" ? marks2(frames, rules, mark) : marks2(frames, mark, rules);
 }
 
-function isMonotonic(values2) {
+function isMonotonic2(values3) {
     let previous;
     let previousOrder;
-    for (const value of values2) {
+    for (const value of values3) {
         if (value == null)
             continue;
         if (previous === void 0) {
             previous = value;
             continue;
         }
-        const order = Math.sign(ascending(previous, value));
+        const order = Math.sign(ascending3(previous, value));
         if (!order)
             continue;
         if (previousOrder !== void 0 && order !== previousOrder)
             return false;
         previous = value;
         previousOrder = order;
     }
     return true;
 }
 
-function normalizeOptions({
-    x: x4,
-    y: y4,
-    color: color3,
+function normalizeOptions2({
+    x: x7,
+    y: y7,
+    color: color5,
     size,
     fx,
     fy,
     mark
 } = {}) {
-    if (!isOptions(x4))
-        x4 = makeOptions(x4);
-    if (!isOptions(y4))
-        y4 = makeOptions(y4);
-    if (!isOptions(color3))
-        color3 = isColor(color3) ? {
-            color: color3
-        } : makeOptions(color3);
-    if (!isOptions(size))
-        size = makeOptions(size);
-    if (isOptions(fx))
+    if (!isOptions2(x7))
+        x7 = makeOptions2(x7);
+    if (!isOptions2(y7))
+        y7 = makeOptions2(y7);
+    if (!isOptions2(color5))
+        color5 = isColor2(color5) ? {
+            color: color5
+        } : makeOptions2(color5);
+    if (!isOptions2(size))
+        size = makeOptions2(size);
+    if (isOptions2(fx))
         ({
             value: fx
-        } = makeOptions(fx));
-    if (isOptions(fy))
+        } = makeOptions2(fx));
+    if (isOptions2(fy))
         ({
             value: fy
-        } = makeOptions(fy));
+        } = makeOptions2(fy));
     if (mark != null)
         mark = `${mark}`.toLowerCase();
     return {
-        x: x4,
-        y: y4,
-        color: color3,
+        x: x7,
+        y: y7,
+        color: color5,
         size,
         fx,
         fy,
         mark
     };
 }
 
-function materializeValue(data, options) {
-    const V = valueof(data, options.value);
+function materializeValue2(data, options) {
+    const V = valueof2(data, options.value);
     if (V)
-        V.label = labelof(options.value);
+        V.label = labelof2(options.value);
     return V;
 }
 
-function makeOptions(value) {
-    return isReducer(value) ? {
+function makeOptions2(value) {
+    return isReducer2(value) ? {
         reduce: value
     } : {
         value
     };
 }
 
-function isZeroReducer(reduce2) {
-    return /^(?:distinct|count|sum|proportion)$/i.test(reduce2);
+function isZeroReducer2(reduce3) {
+    return /^(?:distinct|count|sum|proportion)$/i.test(reduce3);
 }
 
-function isSelectReducer(reduce2) {
-    return /^(?:first|last|mode)$/i.test(reduce2);
+function isSelectReducer2(reduce3) {
+    return /^(?:first|last|mode)$/i.test(reduce3);
 }
 
-function isOrdinalReduced(reduce2, value) {
-    return reduce2 != null && !isSelectReducer(reduce2) || !value ? false : isOrdinal(value);
+function isOrdinalReduced2(reduce3, value) {
+    return reduce3 != null && !isSelectReducer2(reduce3) || !value ? false : isOrdinal2(value);
 }
 
-function isReducer(reduce2) {
-    if (reduce2 == null)
+function isReducer2(reduce3) {
+    if (reduce3 == null)
         return false;
-    if (typeof reduce2.reduceIndex === "function")
+    if (typeof reduce3.reduceIndex === "function")
         return true;
-    if (typeof reduce2.reduce === "function" && isObject(reduce2))
+    if (typeof reduce3.reduce === "function" && isObject2(reduce3))
         return true;
-    if (/^p\d{2}$/i.test(reduce2))
+    if (/^p\d{2}$/i.test(reduce3))
         return true;
-    switch (`${reduce2}`.toLowerCase()) {
+    switch (`${reduce3}`.toLowerCase()) {
         case "first":
         case "last":
         case "count":
         case "distinct":
         case "sum":
         case "proportion":
         case "proportion-facet":
@@ -31095,525 +65801,525 @@
         case "variance":
         case "mode":
             return true;
     }
     return false;
 }
 
-function isHighCardinality(value) {
-    return value ? new InternSet(value).size > value.length >> 1 : false;
+function isHighCardinality2(value) {
+    return value ? new InternSet2(value).size > value.length >> 1 : false;
 }
 
-// node_modules/@observablehq/plot/src/transforms/map.js
-function mapX(map6, options = {}) {
-    return mapAlias(
-        Object.fromEntries(["x", "x1", "x2"].filter((key) => options[key] != null).map((key) => [key, map6])),
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/map.js
+function mapX2(map11, options = {}) {
+    return mapAlias2(
+        Object.fromEntries(["x", "x1", "x2"].filter((key) => options[key] != null).map((key) => [key, map11])),
         options
     );
 }
 
-function mapY(map6, options = {}) {
-    return mapAlias(
-        Object.fromEntries(["y", "y1", "y2"].filter((key) => options[key] != null).map((key) => [key, map6])),
+function mapY2(map11, options = {}) {
+    return mapAlias2(
+        Object.fromEntries(["y", "y1", "y2"].filter((key) => options[key] != null).map((key) => [key, map11])),
         options
     );
 }
 
-function map5(outputs = {}, options = {}) {
-    const z = maybeZ(options);
-    const channels = Object.entries(outputs).map(([key, map6]) => {
-        const input = maybeInput(key, options);
+function map10(outputs = {}, options = {}) {
+    const z = maybeZ2(options);
+    const channels = Object.entries(outputs).map(([key, map11]) => {
+        const input = maybeInput2(key, options);
         if (input == null)
             throw new Error(`missing channel: ${key}`);
-        const [output, setOutput] = column(input);
+        const [output, setOutput] = column2(input);
         return {
             key,
             input,
             output,
             setOutput,
-            map: maybeMap(map6)
+            map: maybeMap2(map11)
         };
     });
     return {
-        ...basic(options, (data, facets) => {
-            const Z = valueof(data, z);
-            const X3 = channels.map(({
+        ...basic2(options, (data, facets) => {
+            const Z = valueof2(data, z);
+            const X4 = channels.map(({
                 input
-            }) => valueof(data, input));
+            }) => valueof2(data, input));
             const MX = channels.map(({
                 setOutput
             }) => setOutput(new Array(data.length)));
             for (const facet of facets) {
-                for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
+                for (const I of Z ? group3(facet, (i) => Z[i]).values() : [facet]) {
                     channels.forEach(({
-                        map: map6
-                    }, i) => map6.mapIndex(I, X3[i], MX[i]));
+                        map: map11
+                    }, i) => map11.mapIndex(I, X4[i], MX[i]));
                 }
             }
             return {
                 data,
                 facets
             };
         }),
         ...Object.fromEntries(channels.map(({
             key,
             output
         }) => [key, output]))
     };
 }
-var mapAlias = map5;
+var mapAlias2 = map10;
 
-function maybeMap(map6) {
-    if (map6 == null)
+function maybeMap2(map11) {
+    if (map11 == null)
         throw new Error("missing map");
-    if (typeof map6.mapIndex === "function")
-        return map6;
-    if (typeof map6.map === "function" && isObject(map6))
-        return mapMap(map6);
-    if (typeof map6 === "function")
-        return mapFunction(map6);
-    switch (`${map6}`.toLowerCase()) {
+    if (typeof map11.mapIndex === "function")
+        return map11;
+    if (typeof map11.map === "function" && isObject2(map11))
+        return mapMap2(map11);
+    if (typeof map11 === "function")
+        return mapFunction2(map11);
+    switch (`${map11}`.toLowerCase()) {
         case "cumsum":
-            return mapCumsum;
+            return mapCumsum2;
         case "rank":
-            return mapFunction(rank);
+            return mapFunction2(rank2);
         case "quantile":
-            return mapFunction(rankQuantile);
+            return mapFunction2(rankQuantile2);
     }
-    throw new Error(`invalid map: ${map6}`);
+    throw new Error(`invalid map: ${map11}`);
 }
 
-function mapMap(map6) {
+function mapMap2(map11) {
     console.warn("deprecated map interface; implement mapIndex instead.");
     return {
-        mapIndex: map6.map.bind(map6)
+        mapIndex: map11.map.bind(map11)
     };
 }
 
-function rankQuantile(V) {
-    const n = count(V) - 1;
-    return rank(V).map((r) => r / n);
+function rankQuantile2(V) {
+    const n = count3(V) - 1;
+    return rank2(V).map((r) => r / n);
 }
 
-function mapFunction(f) {
+function mapFunction2(f) {
     return {
         mapIndex(I, S, T) {
-            const M2 = f(take(S, I));
-            if (M2.length !== I.length)
+            const M3 = f(take2(S, I));
+            if (M3.length !== I.length)
                 throw new Error("map function returned a mismatched length");
             for (let i = 0, n = I.length; i < n; ++i)
-                T[I[i]] = M2[i];
+                T[I[i]] = M3[i];
         }
     };
 }
-var mapCumsum = {
+var mapCumsum2 = {
     mapIndex(I, S, T) {
-        let sum5 = 0;
+        let sum8 = 0;
         for (const i of I)
-            T[i] = sum5 += S[i];
+            T[i] = sum8 += S[i];
     }
 };
 
-// node_modules/@observablehq/plot/src/marks/tick.js
-var defaults13 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/tick.js
+var defaults33 = {
     ariaLabel: "tick",
     fill: null,
     stroke: "currentColor"
 };
-var AbstractTick = class extends Mark {
+var AbstractTick2 = class extends Mark2 {
     constructor(data, channels, options) {
-        super(data, channels, options, defaults13);
+        super(data, channels, options, defaults33);
     }
-    render(index3, scales, channels, dimensions, context) {
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
-            (g) => g.selectAll().data(index3).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)
+    render(index5, scales, channels, dimensions, context) {
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(this._transform, this, scales).call(
+            (g) => g.selectAll().data(index5).enter().append("line").call(applyDirectStyles2, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
-var TickX = class extends AbstractTick {
+var TickX2 = class extends AbstractTick2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             inset = 0,
             insetTop = inset,
             insetBottom = inset
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x"
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     type: "band",
                     optional: true
                 }
             },
             options
         );
-        this.insetTop = number5(insetTop);
-        this.insetBottom = number5(insetBottom);
+        this.insetTop = number11(insetTop);
+        this.insetBottom = number11(insetBottom);
     }
-    _transform(selection2, mark, {
-        x: x4
+    _transform(selection3, mark, {
+        x: x7
     }) {
-        selection2.call(applyTransform, mark, {
-            x: x4
-        }, offset, 0);
+        selection3.call(applyTransform2, mark, {
+            x: x7
+        }, offset2, 0);
     }
     _x1(scales, {
-        x: X3
+        x: X4
     }) {
-        return (i) => X3[i];
+        return (i) => X4[i];
     }
     _x2(scales, {
-        x: X3
+        x: X4
     }) {
-        return (i) => X3[i];
+        return (i) => X4[i];
     }
     _y1({
-        y: y4
+        y: y7
     }, {
-        y: Y3
+        y: Y4
     }, {
         marginTop
     }) {
         const {
             insetTop
         } = this;
-        return Y3 && y4 ? (i) => Y3[i] + insetTop : marginTop + insetTop;
+        return Y4 && y7 ? (i) => Y4[i] + insetTop : marginTop + insetTop;
     }
     _y2({
-        y: y4
+        y: y7
     }, {
-        y: Y3
+        y: Y4
     }, {
         height,
         marginBottom
     }) {
         const {
             insetBottom
         } = this;
-        return Y3 && y4 ? (i) => Y3[i] + y4.bandwidth() - insetBottom : height - marginBottom - insetBottom;
+        return Y4 && y7 ? (i) => Y4[i] + y7.bandwidth() - insetBottom : height - marginBottom - insetBottom;
     }
 };
-var TickY = class extends AbstractTick {
+var TickY2 = class extends AbstractTick2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             inset = 0,
             insetRight = inset,
             insetLeft = inset
         } = options;
         super(
             data, {
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y"
                 },
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     type: "band",
                     optional: true
                 }
             },
             options
         );
-        this.insetRight = number5(insetRight);
-        this.insetLeft = number5(insetLeft);
+        this.insetRight = number11(insetRight);
+        this.insetLeft = number11(insetLeft);
     }
-    _transform(selection2, mark, {
-        y: y4
+    _transform(selection3, mark, {
+        y: y7
     }) {
-        selection2.call(applyTransform, mark, {
-            y: y4
-        }, 0, offset);
+        selection3.call(applyTransform2, mark, {
+            y: y7
+        }, 0, offset2);
     }
     _x1({
-        x: x4
+        x: x7
     }, {
-        x: X3
+        x: X4
     }, {
         marginLeft
     }) {
         const {
             insetLeft
         } = this;
-        return X3 && x4 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;
+        return X4 && x7 ? (i) => X4[i] + insetLeft : marginLeft + insetLeft;
     }
     _x2({
-        x: x4
+        x: x7
     }, {
-        x: X3
+        x: X4
     }, {
         width,
         marginRight
     }) {
         const {
             insetRight
         } = this;
-        return X3 && x4 ? (i) => X3[i] + x4.bandwidth() - insetRight : width - marginRight - insetRight;
+        return X4 && x7 ? (i) => X4[i] + x7.bandwidth() - insetRight : width - marginRight - insetRight;
     }
     _y1(scales, {
-        y: Y3
+        y: Y4
     }) {
-        return (i) => Y3[i];
+        return (i) => Y4[i];
     }
     _y2(scales, {
-        y: Y3
+        y: Y4
     }) {
-        return (i) => Y3[i];
+        return (i) => Y4[i];
     }
 };
 
-function tickX(data, options = {}) {
+function tickX2(data, options = {}) {
     const {
-        x: x4 = identity6,
+        x: x7 = identity13,
         ...remainingOptions
     } = options;
-    return new TickX(data, {
+    return new TickX2(data, {
         ...remainingOptions,
-        x: x4
+        x: x7
     });
 }
 
-function tickY(data, options = {}) {
+function tickY2(data, options = {}) {
     const {
-        y: y4 = identity6,
+        y: y7 = identity13,
         ...remainingOptions
     } = options;
-    return new TickY(data, {
+    return new TickY2(data, {
         ...remainingOptions,
-        y: y4
+        y: y7
     });
 }
 
-// node_modules/@observablehq/plot/src/marks/box.js
-function boxX(data, options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/box.js
+function boxX2(data, options = {}) {
     const {
-        x: x4 = identity6,
-        y: y4 = null,
+        x: x7 = identity13,
+        y: y7 = null,
         fill = "#ccc",
         fillOpacity,
         stroke = "currentColor",
         strokeOpacity,
         strokeWidth = 2,
-        sort: sort3,
+        sort: sort5,
         ...remainingOptions
     } = options;
-    const group3 = y4 != null ? groupY : groupZ;
-    return marks(
-        ruleY(data, group3({
-            x1: loqr1,
-            x2: hiqr2
+    const group5 = y7 != null ? groupY2 : groupZ3;
+    return marks2(
+        ruleY2(data, group5({
+            x1: loqr12,
+            x2: hiqr22
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             stroke,
             strokeOpacity,
             ...remainingOptions
         })),
-        barX(data, group3({
+        barX2(data, group5({
             x1: "p25",
             x2: "p75"
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             fill,
             fillOpacity,
             ...remainingOptions
         })),
-        tickX(data, group3({
+        tickX2(data, group5({
             x: "p50"
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             stroke,
             strokeOpacity,
             strokeWidth,
-            sort: sort3,
+            sort: sort5,
             ...remainingOptions
         })),
-        dot(data, map5({
-            x: oqr
+        dot2(data, map10({
+            x: oqr2
         }, {
-            x: x4,
-            y: y4,
-            z: y4,
+            x: x7,
+            y: y7,
+            z: y7,
             stroke,
             strokeOpacity,
             ...remainingOptions
         }))
     );
 }
 
-function boxY(data, options = {}) {
+function boxY2(data, options = {}) {
     const {
-        y: y4 = identity6,
-        x: x4 = null,
+        y: y7 = identity13,
+        x: x7 = null,
         fill = "#ccc",
         fillOpacity,
         stroke = "currentColor",
         strokeOpacity,
         strokeWidth = 2,
-        sort: sort3,
+        sort: sort5,
         ...remainingOptions
     } = options;
-    const group3 = x4 != null ? groupX : groupZ;
-    return marks(
-        ruleX(data, group3({
-            y1: loqr1,
-            y2: hiqr2
+    const group5 = x7 != null ? groupX2 : groupZ3;
+    return marks2(
+        ruleX2(data, group5({
+            y1: loqr12,
+            y2: hiqr22
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             stroke,
             strokeOpacity,
             ...remainingOptions
         })),
-        barY(data, group3({
+        barY2(data, group5({
             y1: "p25",
             y2: "p75"
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             fill,
             fillOpacity,
             ...remainingOptions
         })),
-        tickY(data, group3({
+        tickY2(data, group5({
             y: "p50"
         }, {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             stroke,
             strokeOpacity,
             strokeWidth,
-            sort: sort3,
+            sort: sort5,
             ...remainingOptions
         })),
-        dot(data, map5({
-            y: oqr
+        dot2(data, map10({
+            y: oqr2
         }, {
-            x: x4,
-            y: y4,
-            z: x4,
+            x: x7,
+            y: y7,
+            z: x7,
             stroke,
             strokeOpacity,
             ...remainingOptions
         }))
     );
 }
 
-function oqr(values2) {
-    const r1 = loqr1(values2);
-    const r2 = hiqr2(values2);
-    return values2.map((v2) => v2 < r1 || v2 > r2 ? v2 : NaN);
+function oqr2(values3) {
+    const r1 = loqr12(values3);
+    const r2 = hiqr22(values3);
+    return values3.map((v3) => v3 < r1 || v3 > r2 ? v3 : NaN);
 }
 
-function loqr1(values2) {
-    const lo = quartile1(values2) * 2.5 - quartile3(values2) * 1.5;
-    return min(values2, (d) => d >= lo ? d : NaN);
+function loqr12(values3) {
+    const lo = quartile12(values3) * 2.5 - quartile32(values3) * 1.5;
+    return min4(values3, (d) => d >= lo ? d : NaN);
 }
 
-function hiqr2(values2) {
-    const hi = quartile3(values2) * 2.5 - quartile1(values2) * 1.5;
-    return max(values2, (d) => d <= hi ? d : NaN);
+function hiqr22(values3) {
+    const hi = quartile32(values3) * 2.5 - quartile12(values3) * 1.5;
+    return max5(values3, (d) => d <= hi ? d : NaN);
 }
 
-function quartile1(values2) {
-    return quantile(values2, 0.25);
+function quartile12(values3) {
+    return quantile3(values3, 0.25);
 }
 
-function quartile3(values2) {
-    return quantile(values2, 0.75);
+function quartile32(values3) {
+    return quantile3(values3, 0.75);
 }
 
-// node_modules/@observablehq/plot/src/marks/raster.js
-var defaults14 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/raster.js
+var defaults34 = {
     ariaLabel: "raster",
     stroke: null,
     pixelSize: 1
 };
 
-function number6(input, name) {
-    const x4 = +input;
-    if (isNaN(x4))
+function number13(input, name) {
+    const x7 = +input;
+    if (isNaN(x7))
         throw new Error(`invalid ${name}: ${input}`);
-    return x4;
+    return x7;
 }
 
-function integer(input, name) {
-    const x4 = Math.floor(input);
-    if (isNaN(x4))
+function integer2(input, name) {
+    const x7 = Math.floor(input);
+    if (isNaN(x7))
         throw new Error(`invalid ${name}: ${input}`);
-    return x4;
+    return x7;
 }
-var AbstractRaster = class extends Mark {
-    constructor(data, channels, options = {}, defaults21) {
+var AbstractRaster2 = class extends Mark2 {
+    constructor(data, channels, options = {}, defaults41) {
         let {
             width,
             height,
-            x: x4,
-            y: y4,
-            x1: x12 = x4 == null ? 0 : void 0,
-            y1: y12 = y4 == null ? 0 : void 0,
-            x2: x22 = x4 == null ? width : void 0,
-            y2: y22 = y4 == null ? height : void 0,
-            pixelSize = defaults21.pixelSize,
-            blur: blur3 = 0,
+            x: x7,
+            y: y7,
+            x1: x13 = x7 == null ? 0 : void 0,
+            y1: y13 = y7 == null ? 0 : void 0,
+            x2: x22 = x7 == null ? width : void 0,
+            y2: y22 = y7 == null ? height : void 0,
+            pixelSize = defaults41.pixelSize,
+            blur: blur4 = 0,
             interpolate
         } = options;
         if (width != null)
-            width = integer(width, "width");
+            width = integer2(width, "width");
         if (height != null)
-            height = integer(height, "height");
-        if (x12 != null)
-            x12 = number6(x12, "x1");
-        if (y12 != null)
-            y12 = number6(y12, "y1");
+            height = integer2(height, "height");
+        if (x13 != null)
+            x13 = number13(x13, "x1");
+        if (y13 != null)
+            y13 = number13(y13, "y1");
         if (x22 != null)
-            x22 = number6(x22, "x2");
+            x22 = number13(x22, "x2");
         if (y22 != null)
-            y22 = number6(y22, "y2");
-        if (x4 == null && (x12 == null || x22 == null))
+            y22 = number13(y22, "y2");
+        if (x7 == null && (x13 == null || x22 == null))
             throw new Error("missing x");
-        if (y4 == null && (y12 == null || y22 == null))
+        if (y7 == null && (y13 == null || y22 == null))
             throw new Error("missing y");
         if (data != null && width != null && height != null) {
-            if (x4 === void 0 && x12 != null && x22 != null)
-                x4 = denseX(x12, x22, width, height);
-            if (y4 === void 0 && y12 != null && y22 != null)
-                y4 = denseY(y12, y22, width, height);
+            if (x7 === void 0 && x13 != null && x22 != null)
+                x7 = denseX2(x13, x22, width, height);
+            if (y7 === void 0 && y13 != null && y22 != null)
+                y7 = denseY2(y13, y22, width, height);
         }
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 x1: {
-                    value: x12 == null ? null : [x12],
+                    value: x13 == null ? null : [x13],
                     scale: "x",
                     optional: true,
                     filter: null
                 },
                 y1: {
-                    value: y12 == null ? null : [y12],
+                    value: y13 == null ? null : [y13],
                     scale: "y",
                     optional: true,
                     filter: null
                 },
                 x2: {
                     value: x22 == null ? null : [x22],
                     scale: "x",
@@ -31625,239 +66331,239 @@
                     scale: "y",
                     optional: true,
                     filter: null
                 },
                 ...channels
             },
             options,
-            defaults21
+            defaults41
         );
         this.width = width;
         this.height = height;
-        this.pixelSize = number6(pixelSize, "pixelSize");
-        this.blur = number6(blur3, "blur");
-        this.interpolate = x4 == null || y4 == null ? null : maybeInterpolate(interpolate);
+        this.pixelSize = number13(pixelSize, "pixelSize");
+        this.blur = number13(blur4, "blur");
+        this.interpolate = x7 == null || y7 == null ? null : maybeInterpolate2(interpolate);
     }
 };
-var Raster = class extends AbstractRaster {
+var Raster2 = class extends AbstractRaster2 {
     constructor(data, options = {}) {
         const {
             imageRendering
         } = options;
         if (data == null) {
             const {
                 fill,
                 fillOpacity
             } = options;
-            if (maybeNumberChannel(fillOpacity)[0] !== void 0)
-                options = sampler("fillOpacity", options);
-            if (maybeColorChannel(fill)[0] !== void 0)
-                options = sampler("fill", options);
+            if (maybeNumberChannel2(fillOpacity)[0] !== void 0)
+                options = sampler2("fillOpacity", options);
+            if (maybeColorChannel2(fill)[0] !== void 0)
+                options = sampler2("fill", options);
         }
-        super(data, void 0, options, defaults14);
-        this.imageRendering = impliedString(imageRendering, "auto");
+        super(data, void 0, options, defaults34);
+        this.imageRendering = impliedString2(imageRendering, "auto");
     }
     // Ignore the color scale, so the fill channel is returned unscaled.
     scale(channels, {
-        color: color3,
+        color: color5,
         ...scales
     }, context) {
         return super.scale(channels, scales, context);
     }
-    render(index3, scales, values2, dimensions, context) {
-        const color3 = scales[values2.channels.fill?.scale] ?? ((x4) => x4);
+    render(index5, scales, values3, dimensions, context) {
+        const color5 = scales[values3.channels.fill?.scale] ?? ((x7) => x7);
         const {
-            x: X3,
-            y: Y3
-        } = values2;
+            x: X4,
+            y: Y4
+        } = values3;
         const {
             document: document2
         } = context;
-        const [x12, y12, x22, y22] = renderBounds(values2, dimensions, context);
-        const dx = x22 - x12;
-        const dy = y22 - y12;
-        const {
-            pixelSize: k2,
-            width: w = Math.round(Math.abs(dx) / k2),
-            height: h = Math.round(Math.abs(dy) / k2)
+        const [x13, y13, x22, y22] = renderBounds2(values3, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
+        const {
+            pixelSize: k3,
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
         } = this;
         const n = w * h;
         let {
             fill: F,
             fillOpacity: FO
-        } = values2;
-        let offset2 = 0;
+        } = values3;
+        let offset3 = 0;
         if (this.interpolate) {
-            const kx2 = w / dx;
-            const ky2 = h / dy;
-            const IX = map4(X3, (x4) => (x4 - x12) * kx2, Float64Array);
-            const IY = map4(Y3, (y4) => (y4 - y12) * ky2, Float64Array);
+            const kx3 = w / dx;
+            const ky3 = h / dy;
+            const IX = map9(X4, (x7) => (x7 - x13) * kx3, Float64Array);
+            const IY = map9(Y4, (y7) => (y7 - y13) * ky3, Float64Array);
             if (F)
-                F = this.interpolate(index3, w, h, IX, IY, F);
+                F = this.interpolate(index5, w, h, IX, IY, F);
             if (FO)
-                FO = this.interpolate(index3, w, h, IX, IY, FO);
-        } else if (this.data == null && index3)
-            offset2 = index3.fi * n;
+                FO = this.interpolate(index5, w, h, IX, IY, FO);
+        } else if (this.data == null && index5)
+            offset3 = index5.fi * n;
         const canvas = document2.createElement("canvas");
         canvas.width = w;
         canvas.height = h;
         const context2d = canvas.getContext("2d");
-        const image2 = context2d.createImageData(w, h);
-        const imageData = image2.data;
+        const image3 = context2d.createImageData(w, h);
+        const imageData = image3.data;
         let {
             r,
             g,
             b
-        } = rgb(this.fill) ?? {
+        } = rgb2(this.fill) ?? {
             r: 0,
             g: 0,
             b: 0
         };
-        let a4 = (this.fillOpacity ?? 1) * 255;
+        let a7 = (this.fillOpacity ?? 1) * 255;
         for (let i = 0; i < n; ++i) {
             const j = i << 2;
             if (F) {
-                const fi = color3(F[i + offset2]);
+                const fi = color5(F[i + offset3]);
                 if (fi == null) {
                     imageData[j + 3] = 0;
                     continue;
                 }
                 ({
                     r,
                     g,
                     b
-                } = rgb(fi));
+                } = rgb2(fi));
             }
             if (FO)
-                a4 = FO[i + offset2] * 255;
+                a7 = FO[i + offset3] * 255;
             imageData[j + 0] = r;
             imageData[j + 1] = g;
             imageData[j + 2] = b;
-            imageData[j + 3] = a4;
+            imageData[j + 3] = a7;
         }
         if (this.blur > 0)
-            blurImage(image2, this.blur);
-        context2d.putImageData(image2, 0, 0);
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
-            (g2) => g2.append("image").attr("transform", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr, "image-rendering", this.imageRendering).call(applyDirectStyles, this).attr("xlink:href", canvas.toDataURL())
+            blurImage2(image3, this.blur);
+        context2d.putImageData(image3, 0, 0);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call(
+            (g2) => g2.append("image").attr("transform", `translate(${x13},${y13}) scale(${Math.sign(x22 - x13)},${Math.sign(y22 - y13)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr2, "image-rendering", this.imageRendering).call(applyDirectStyles2, this).attr("xlink:href", canvas.toDataURL())
         ).node();
     }
 };
 
-function maybeTuples(k2, data, options) {
+function maybeTuples2(k3, data, options) {
     if (arguments.length < 3)
         options = data, data = null;
     let {
-        x: x4,
-        y: y4,
-        [k2]: z,
+        x: x7,
+        y: y7,
+        [k3]: z,
         ...rest
     } = options;
-    if (x4 === void 0 && y4 === void 0 && isTuples(data)) {
-        x4 = first, y4 = second2;
+    if (x7 === void 0 && y7 === void 0 && isTuples2(data)) {
+        x7 = first2, y7 = second4;
         if (z === void 0)
-            z = third;
+            z = third2;
     }
     return [data, {
         ...rest,
-        x: x4,
-        y: y4,
-        [k2]: z
+        x: x7,
+        y: y7,
+        [k3]: z
     }];
 }
 
-function raster() {
-    const [data, options] = maybeTuples("fill", ...arguments);
-    return new Raster(
+function raster2() {
+    const [data, options] = maybeTuples2("fill", ...arguments);
+    return new Raster2(
         data,
         data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : {
             ...options,
-            fill: identity6
+            fill: identity13
         }
     );
 }
 
-function renderBounds({
-    x1: x12,
-    y1: y12,
+function renderBounds2({
+    x1: x13,
+    y1: y13,
     x2: x22,
     y2: y22
 }, dimensions, {
-    projection: projection2
+    projection: projection3
 }) {
     const {
         width,
         height,
         marginTop,
         marginRight,
         marginBottom,
         marginLeft
     } = dimensions;
     return [
-        x12 && projection2 == null ? x12[0] : marginLeft,
-        y12 && projection2 == null ? y12[0] : marginTop,
-        x22 && projection2 == null ? x22[0] : width - marginRight,
-        y22 && projection2 == null ? y22[0] : height - marginBottom
+        x13 && projection3 == null ? x13[0] : marginLeft,
+        y13 && projection3 == null ? y13[0] : marginTop,
+        x22 && projection3 == null ? x22[0] : width - marginRight,
+        y22 && projection3 == null ? y22[0] : height - marginBottom
     ];
 }
 
-function rasterBounds({
-    x1: x12,
-    y1: y12,
+function rasterBounds2({
+    x1: x13,
+    y1: y13,
     x2: x22,
     y2: y22
 }, scales, dimensions, context) {
     const channels = {};
-    if (x12)
-        channels.x1 = x12;
-    if (y12)
-        channels.y1 = y12;
+    if (x13)
+        channels.x1 = x13;
+    if (y13)
+        channels.y1 = y13;
     if (x22)
         channels.x2 = x22;
     if (y22)
         channels.y2 = y22;
-    return renderBounds(valueObject(channels, scales), dimensions, context);
+    return renderBounds2(valueObject2(channels, scales), dimensions, context);
 }
 
-function sampler(name, options = {}) {
+function sampler2(name, options = {}) {
     const {
         [name]: value
     } = options;
     if (typeof value !== "function")
         throw new Error(`invalid ${name}: not a function`);
-    return initializer({
+    return initializer2({
         ...options,
         [name]: void 0
     }, function(data, facets, channels, scales, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
-        if (!x4)
+        if (!x7)
             throw new Error("missing scale: x");
-        if (!y4)
+        if (!y7)
             throw new Error("missing scale: y");
-        const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);
-        const dx = x22 - x12;
-        const dy = y22 - y12;
+        const [x13, y13, x22, y22] = rasterBounds2(channels, scales, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
         const {
-            pixelSize: k2
+            pixelSize: k3
         } = this;
         const {
-            width: w = Math.round(Math.abs(dx) / k2),
-            height: h = Math.round(Math.abs(dy) / k2)
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
         } = options;
         const V = new Array(w * h * (facets ? facets.length : 1));
-        const kx2 = dx / w;
-        const ky2 = dy / h;
+        const kx3 = dx / w;
+        const ky3 = dy / h;
         let i = 0;
         for (const facet of facets ?? [void 0]) {
             for (let yi = 0.5; yi < h; ++yi) {
                 for (let xi = 0.5; xi < w; ++xi, ++i) {
-                    V[i] = value(x4.invert(x12 + xi * kx2), y4.invert(y12 + yi * ky2), facet);
+                    V[i] = value(x7.invert(x13 + xi * kx3), y7.invert(y13 + yi * ky3), facet);
                 }
             }
         }
         return {
             data: V,
             facets,
             channels: {
@@ -31866,889 +66572,889 @@
                     scale: "auto"
                 }
             }
         };
     });
 }
 
-function maybeInterpolate(interpolate) {
+function maybeInterpolate2(interpolate) {
     if (typeof interpolate === "function")
         return interpolate;
     if (interpolate == null)
-        return interpolateNone;
+        return interpolateNone2;
     switch (`${interpolate}`.toLowerCase()) {
         case "none":
-            return interpolateNone;
+            return interpolateNone2;
         case "nearest":
-            return interpolateNearest;
+            return interpolateNearest2;
         case "barycentric":
-            return interpolatorBarycentric();
+            return interpolatorBarycentric2();
         case "random-walk":
-            return interpolatorRandomWalk();
+            return interpolatorRandomWalk2();
     }
     throw new Error(`invalid interpolate: ${interpolate}`);
 }
 
-function interpolateNone(index3, width, height, X3, Y3, V) {
+function interpolateNone2(index5, width, height, X4, Y4, V) {
     const W = new Array(width * height);
-    for (const i of index3) {
-        if (X3[i] < 0 || X3[i] >= width || Y3[i] < 0 || Y3[i] >= height)
+    for (const i of index5) {
+        if (X4[i] < 0 || X4[i] >= width || Y4[i] < 0 || Y4[i] >= height)
             continue;
-        W[Math.floor(Y3[i]) * width + Math.floor(X3[i])] = V[i];
+        W[Math.floor(Y4[i]) * width + Math.floor(X4[i])] = V[i];
     }
     return W;
 }
 
-function interpolatorBarycentric({
-    random = lcg(42)
+function interpolatorBarycentric2({
+    random = lcg2(42)
 } = {}) {
-    return (index3, width, height, X3, Y3, V) => {
-        const n = index3.length;
+    return (index5, width, height, X4, Y4, V) => {
+        const n = index5.length;
         const nw = width >> 2;
         const nh = (height >> 2) - 1;
-        const m3 = n + nw * 2 + nh * 2;
-        const XY2 = new Float64Array(m3 * 2);
+        const m5 = n + nw * 2 + nh * 2;
+        const XY3 = new Float64Array(m5 * 2);
         for (let i2 = 0; i2 < n; ++i2)
-            XY2[i2 * 2] = X3[index3[i2]], XY2[i2 * 2 + 1] = Y3[index3[i2]];
+            XY3[i2 * 2] = X4[index5[i2]], XY3[i2 * 2 + 1] = Y4[index5[i2]];
         let i = n;
-        const addPoint = (x4, y4) => (XY2[i * 2] = x4, XY2[i * 2 + 1] = y4, i++);
+        const addPoint = (x7, y7) => (XY3[i * 2] = x7, XY3[i * 2 + 1] = y7, i++);
         for (let j = 0; j <= nw; ++j)
             addPoint(j / nw * width, 0), addPoint(j / nw * width, height);
         for (let j = 0; j < nh; ++j)
             addPoint(width, j / nh * height), addPoint(0, j / nh * height);
-        V = take(V, index3);
-        const delaunay = new Delaunay(XY2.subarray(0, n * 2));
-        for (let j = n, ij; j < m3; ++j)
-            V[j] = V[ij = delaunay.find(XY2[j * 2], XY2[j * 2 + 1], ij)];
+        V = take2(V, index5);
+        const delaunay = new Delaunay2(XY3.subarray(0, n * 2));
+        for (let j = n, ij; j < m5; ++j)
+            V[j] = V[ij = delaunay.find(XY3[j * 2], XY3[j * 2 + 1], ij)];
         const {
             points,
             triangles
-        } = new Delaunay(XY2);
+        } = new Delaunay2(XY3);
         const W = new V.constructor(width * height);
-        const mix = mixer(V, random);
+        const mix = mixer2(V, random);
         for (let i2 = 0; i2 < triangles.length; i2 += 3) {
             const ta = triangles[i2];
             const tb = triangles[i2 + 1];
             const tc = triangles[i2 + 2];
             const Ax = points[2 * ta];
             const Bx = points[2 * tb];
             const Cx = points[2 * tc];
             const Ay = points[2 * ta + 1];
             const By = points[2 * tb + 1];
             const Cy = points[2 * tc + 1];
-            const x12 = Math.min(Ax, Bx, Cx);
+            const x13 = Math.min(Ax, Bx, Cx);
             const x22 = Math.max(Ax, Bx, Cx);
-            const y12 = Math.min(Ay, By, Cy);
+            const y13 = Math.min(Ay, By, Cy);
             const y22 = Math.max(Ay, By, Cy);
             const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);
             if (!z)
                 continue;
             const va = V[ta];
             const vb = V[tb];
             const vc = V[tc];
-            for (let x4 = Math.floor(x12); x4 < x22; ++x4) {
-                for (let y4 = Math.floor(y12); y4 < y22; ++y4) {
-                    if (x4 < 0 || x4 >= width || y4 < 0 || y4 >= height)
+            for (let x7 = Math.floor(x13); x7 < x22; ++x7) {
+                for (let y7 = Math.floor(y13); y7 < y22; ++y7) {
+                    if (x7 < 0 || x7 >= width || y7 < 0 || y7 >= height)
                         continue;
-                    const xp = x4 + 0.5;
-                    const yp = y4 + 0.5;
+                    const xp = x7 + 0.5;
+                    const yp = y7 + 0.5;
                     const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z;
                     if (ga < 0)
                         continue;
                     const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z;
                     if (gb < 0)
                         continue;
                     const gc = 1 - ga - gb;
                     if (gc < 0)
                         continue;
-                    W[x4 + width * y4] = mix(va, ga, vb, gb, vc, gc, x4, y4);
+                    W[x7 + width * y7] = mix(va, ga, vb, gb, vc, gc, x7, y7);
                 }
             }
         }
         return W;
     };
 }
 
-function interpolateNearest(index3, width, height, X3, Y3, V) {
+function interpolateNearest2(index5, width, height, X4, Y4, V) {
     const W = new V.constructor(width * height);
-    const delaunay = Delaunay.from(
-        index3,
-        (i) => X3[i],
-        (i) => Y3[i]
+    const delaunay = Delaunay2.from(
+        index5,
+        (i) => X4[i],
+        (i) => Y4[i]
     );
     let iy, ix;
-    for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {
+    for (let y7 = 0.5, k3 = 0; y7 < height; ++y7) {
         ix = iy;
-        for (let x4 = 0.5; x4 < width; ++x4, ++k2) {
-            ix = delaunay.find(x4, y4, ix);
-            if (x4 === 0.5)
+        for (let x7 = 0.5; x7 < width; ++x7, ++k3) {
+            ix = delaunay.find(x7, y7, ix);
+            if (x7 === 0.5)
                 iy = ix;
-            W[k2] = V[index3[ix]];
+            W[k3] = V[index5[ix]];
         }
     }
     return W;
 }
 
-function interpolatorRandomWalk({
-    random = lcg(42),
+function interpolatorRandomWalk2({
+    random = lcg2(42),
     minDistance = 0.5,
     maxSteps = 2
 } = {}) {
-    return (index3, width, height, X3, Y3, V) => {
+    return (index5, width, height, X4, Y4, V) => {
         const W = new V.constructor(width * height);
-        const delaunay = Delaunay.from(
-            index3,
-            (i) => X3[i],
-            (i) => Y3[i]
+        const delaunay = Delaunay2.from(
+            index5,
+            (i) => X4[i],
+            (i) => Y4[i]
         );
         let iy, ix, iw;
-        for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {
+        for (let y7 = 0.5, k3 = 0; y7 < height; ++y7) {
             ix = iy;
-            for (let x4 = 0.5; x4 < width; ++x4, ++k2) {
-                let cx = x4;
-                let cy = y4;
+            for (let x7 = 0.5; x7 < width; ++x7, ++k3) {
+                let cx = x7;
+                let cy = y7;
                 iw = ix = delaunay.find(cx, cy, ix);
-                if (x4 === 0.5)
+                if (x7 === 0.5)
                     iy = ix;
                 let distance;
                 let step = 0;
-                while ((distance = Math.hypot(X3[index3[iw]] - cx, Y3[index3[iw]] - cy)) > minDistance && step < maxSteps) {
-                    const angle2 = random(x4, y4, step) * 2 * Math.PI;
-                    cx += Math.cos(angle2) * distance;
-                    cy += Math.sin(angle2) * distance;
+                while ((distance = Math.hypot(X4[index5[iw]] - cx, Y4[index5[iw]] - cy)) > minDistance && step < maxSteps) {
+                    const angle3 = random(x7, y7, step) * 2 * Math.PI;
+                    cx += Math.cos(angle3) * distance;
+                    cy += Math.sin(angle3) * distance;
                     iw = delaunay.find(cx, cy, iw);
                     ++step;
                 }
-                W[k2] = V[index3[iw]];
+                W[k3] = V[index5[iw]];
             }
         }
         return W;
     };
 }
 
-function blend(a4, ca3, b, cb, c6, cc2) {
-    return ca3 * a4 + cb * b + cc2 * c6;
+function blend2(a7, ca5, b, cb, c11, cc3) {
+    return ca5 * a7 + cb * b + cc3 * c11;
 }
 
-function pick(random) {
-    return (a4, ca3, b, cb, c6, cc2, x4, y4) => {
-        const u4 = random(x4, y4);
-        return u4 < ca3 ? a4 : u4 < ca3 + cb ? b : c6;
+function pick2(random) {
+    return (a7, ca5, b, cb, c11, cc3, x7, y7) => {
+        const u7 = random(x7, y7);
+        return u7 < ca5 ? a7 : u7 < ca5 + cb ? b : c11;
     };
 }
 
-function mixer(F, random) {
-    return isNumeric(F) || isTemporal(F) ? blend : pick(random);
+function mixer2(F, random) {
+    return isNumeric2(F) || isTemporal2(F) ? blend2 : pick2(random);
 }
 
-function denseX(x12, x22, width) {
+function denseX2(x13, x22, width) {
     return {
         transform(data) {
             const n = data.length;
-            const X3 = new Float64Array(n);
-            const kx2 = (x22 - x12) / width;
-            const x06 = x12 + kx2 / 2;
+            const X4 = new Float64Array(n);
+            const kx3 = (x22 - x13) / width;
+            const x011 = x13 + kx3 / 2;
             for (let i = 0; i < n; ++i)
-                X3[i] = i % width * kx2 + x06;
-            return X3;
+                X4[i] = i % width * kx3 + x011;
+            return X4;
         }
     };
 }
 
-function denseY(y12, y22, width, height) {
+function denseY2(y13, y22, width, height) {
     return {
         transform(data) {
             const n = data.length;
-            const Y3 = new Float64Array(n);
-            const ky2 = (y22 - y12) / height;
-            const y06 = y12 + ky2 / 2;
+            const Y4 = new Float64Array(n);
+            const ky3 = (y22 - y13) / height;
+            const y011 = y13 + ky3 / 2;
             for (let i = 0; i < n; ++i)
-                Y3[i] = Math.floor(i / width) % height * ky2 + y06;
-            return Y3;
+                Y4[i] = Math.floor(i / width) % height * ky3 + y011;
+            return Y4;
         }
     };
 }
 
-// node_modules/@observablehq/plot/src/marks/contour.js
-var defaults15 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/contour.js
+var defaults35 = {
     ariaLabel: "contour",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1,
     pixelSize: 2
 };
-var Contour = class extends AbstractRaster {
+var Contour2 = class extends AbstractRaster2 {
     constructor(data, {
         smooth = true,
         value,
         ...options
     } = {}) {
-        const channels = styles({}, options, defaults15);
+        const channels = styles2({}, options, defaults35);
         if (value === void 0) {
             for (const key in channels) {
                 if (channels[key].value != null) {
                     if (value !== void 0)
                         throw new Error("ambiguous contour value");
                     value = options[key];
                     options[key] = "value";
                 }
             }
         }
         if (value != null) {
-            const v2 = {
-                transform: (D3) => D3.map((d) => d.value),
-                label: labelof(value)
+            const v3 = {
+                transform: (D5) => D5.map((d) => d.value),
+                label: labelof2(value)
             };
             for (const key in channels) {
                 if (options[key] === "value") {
-                    options[key] = v2;
+                    options[key] = v3;
                 }
             }
         }
         if (data == null) {
             if (value == null)
                 throw new Error("missing contour value");
-            options = sampler("value", {
+            options = sampler2("value", {
                 value,
                 ...options
             });
             value = null;
         } else {
             let {
                 interpolate
             } = options;
             if (value === void 0)
-                value = identity6;
+                value = identity13;
             if (interpolate === void 0)
                 options.interpolate = "nearest";
         }
         super(data, {
             value: {
                 value,
                 optional: true
             }
-        }, contourGeometry(options), defaults15);
+        }, contourGeometry2(options), defaults35);
         const contourChannels = {
             geometry: {
-                value: identity6
+                value: identity13
             }
         };
         for (const key in this.channels) {
             const channel = this.channels[key];
             const {
-                scale: scale3
+                scale: scale5
             } = channel;
-            if (scale3 === "x" || scale3 === "y" || key === "value")
+            if (scale5 === "x" || scale5 === "y" || key === "value")
                 continue;
             contourChannels[key] = channel;
             delete this.channels[key];
         }
         this.contourChannels = contourChannels;
         this.smooth = !!smooth;
     }
-    filter(index3, {
-        x: x4,
-        y: y4,
+    filter(index5, {
+        x: x7,
+        y: y7,
         value,
         ...channels
-    }, values2) {
-        return super.filter(index3, channels, values2);
+    }, values3) {
+        return super.filter(index5, channels, values3);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             geometry: G
         } = channels;
-        const path2 = path_default();
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
-            g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => path2(G[i])).call(applyChannelStyles, this, channels);
+        const path3 = path_default3();
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call((g) => {
+            g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).attr("d", (i) => path3(G[i])).call(applyChannelStyles2, this, channels);
         }).node();
     }
 };
 
-function contourGeometry({
+function contourGeometry2({
     thresholds,
-    interval: interval2,
+    interval: interval3,
     ...options
 }) {
-    thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);
-    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
-        const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);
-        const dx = x22 - x12;
-        const dy = y22 - y12;
-        const {
-            pixelSize: k2,
-            width: w = Math.round(Math.abs(dx) / k2),
-            height: h = Math.round(Math.abs(dy) / k2)
+    thresholds = maybeThresholds2(thresholds, interval3, thresholdSturges2);
+    return initializer2(options, function(data, facets, channels, scales, dimensions, context) {
+        const [x13, y13, x22, y22] = rasterBounds2(channels, scales, dimensions, context);
+        const dx = x22 - x13;
+        const dy = y22 - y13;
+        const {
+            pixelSize: k3,
+            width: w = Math.round(Math.abs(dx) / k3),
+            height: h = Math.round(Math.abs(dy) / k3)
         } = this;
-        const kx2 = w / dx;
-        const ky2 = h / dy;
+        const kx3 = w / dx;
+        const ky3 = h / dy;
         const V = channels.value.value;
         const VV = [];
         if (this.interpolate) {
             const {
-                x: X3,
-                y: Y3
-            } = applyPosition(channels, scales, context);
-            const IX = map4(X3, (x4) => (x4 - x12) * kx2, Float64Array);
-            const IY = map4(Y3, (y4) => (y4 - y12) * ky2, Float64Array);
+                x: X4,
+                y: Y4
+            } = applyPosition2(channels, scales, context);
+            const IX = map9(X4, (x7) => (x7 - x13) * kx3, Float64Array);
+            const IY = map9(Y4, (y7) => (y7 - y13) * ky3, Float64Array);
             const ichannels = [channels.x, channels.y, channels.value];
             const ivalues = [IX, IY, V];
             for (const facet of facets) {
-                const index3 = this.filter(facet, ichannels, ivalues);
-                VV.push(this.interpolate(index3, w, h, IX, IY, V));
+                const index5 = this.filter(facet, ichannels, ivalues);
+                VV.push(this.interpolate(index5, w, h, IX, IY, V));
             }
         } else if (facets) {
             const n = w * h;
-            const m3 = facets.length;
-            for (let i = 0; i < m3; ++i)
+            const m5 = facets.length;
+            for (let i = 0; i < m5; ++i)
                 VV.push(V.slice(i * n, i * n + n));
         } else {
             VV.push(V);
         }
         if (this.blur > 0)
             for (const V2 of VV)
-                blur2({
+                blur22({
                     data: V2,
                     width: w,
                     height: h
                 }, this.blur);
-        const T = maybeTicks(thresholds, V, ...finiteExtent(VV));
+        const T = maybeTicks2(thresholds, V, ...finiteExtent2(VV));
         if (T === null)
             throw new Error(`unsupported thresholds: ${thresholds}`);
         const {
-            contour: contour2
-        } = contours_default().size([w, h]).smooth(this.smooth);
+            contour: contour3
+        } = contours_default2().size([w, h]).smooth(this.smooth);
         const contourData = [];
         const contourFacets = [];
         for (const V2 of VV) {
-            contourFacets.push(range(contourData.length, contourData.push(...map4(T, (t) => contour2(V2, t)))));
+            contourFacets.push(range5(contourData.length, contourData.push(...map9(T, (t) => contour3(V2, t)))));
         }
         for (const {
-                coordinates: coordinates2
+                coordinates: coordinates3
             }
             of contourData) {
-            for (const rings of coordinates2) {
+            for (const rings of coordinates3) {
                 for (const ring of rings) {
-                    for (const point6 of ring) {
-                        point6[0] = point6[0] / kx2 + x12;
-                        point6[1] = point6[1] / ky2 + y12;
+                    for (const point11 of ring) {
+                        point11[0] = point11[0] / kx3 + x13;
+                        point11[1] = point11[1] / ky3 + y13;
                     }
                 }
             }
         }
         return {
             data: contourData,
             facets: contourFacets,
-            channels: createChannels(this.contourChannels, contourData)
+            channels: createChannels2(this.contourChannels, contourData)
         };
     });
 }
 
-function maybeTicks(thresholds, V, min4, max5) {
+function maybeTicks2(thresholds, V, min7, max9) {
     if (typeof thresholds?.range === "function")
-        return thresholds.range(thresholds.floor(min4), max5);
+        return thresholds.range(thresholds.floor(min7), max9);
     if (typeof thresholds === "function")
-        thresholds = thresholds(V, min4, max5);
+        thresholds = thresholds(V, min7, max9);
     if (typeof thresholds !== "number")
-        return arrayify2(thresholds);
-    const tz = ticks(...nice(min4, max5, thresholds), thresholds);
-    while (tz[tz.length - 1] >= max5)
+        return arrayify4(thresholds);
+    const tz = ticks2(...nice3(min7, max9, thresholds), thresholds);
+    while (tz[tz.length - 1] >= max9)
         tz.pop();
-    while (tz[1] < min4)
+    while (tz[1] < min7)
         tz.shift();
     return tz;
 }
 
-function contour() {
-    return new Contour(...maybeTuples("value", ...arguments));
+function contour2() {
+    return new Contour2(...maybeTuples2("value", ...arguments));
 }
 
-function finiteExtent(VV) {
-    return [min(VV, (V) => min(V, finite3)), max(VV, (V) => max(V, finite3))];
+function finiteExtent2(VV) {
+    return [min4(VV, (V) => min4(V, finite6)), max5(VV, (V) => max5(V, finite6))];
 }
 
-function finite3(x4) {
-    return isFinite(x4) ? x4 : NaN;
+function finite6(x7) {
+    return isFinite(x7) ? x7 : NaN;
 }
 
-// node_modules/@observablehq/plot/src/marks/delaunay.js
-var delaunayLinkDefaults = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/delaunay.js
+var delaunayLinkDefaults2 = {
     ariaLabel: "delaunay link",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-var delaunayMeshDefaults = {
+var delaunayMeshDefaults2 = {
     ariaLabel: "delaunay mesh",
     fill: null,
     stroke: "currentColor",
     strokeOpacity: 0.2
 };
-var hullDefaults = {
+var hullDefaults2 = {
     ariaLabel: "hull",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeMiterlimit: 1
 };
-var voronoiDefaults = {
+var voronoiDefaults2 = {
     ariaLabel: "voronoi",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-var voronoiMeshDefaults = {
+var voronoiMeshDefaults2 = {
     ariaLabel: "voronoi mesh",
     fill: null,
     stroke: "currentColor",
     strokeOpacity: 0.2
 };
-var DelaunayLink = class extends Mark {
+var DelaunayLink2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             z,
             curve,
             tension
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 z: {
                     value: z,
                     optional: true
                 }
             },
             options,
-            delaunayLinkDefaults
+            delaunayLinkDefaults2
         );
-        this.curve = maybeCurve(curve, tension);
-        markers(this, options);
+        this.curve = maybeCurve2(curve, tension);
+        markers2(this, options);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             z: Z
         } = channels;
         const {
             curve
         } = this;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        const xi = X3 ? (i) => X3[i] : constant2(cx);
-        const yi = Y3 ? (i) => Y3[i] : constant2(cy);
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant4(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant4(cy);
         const mark = this;
 
-        function links(index4) {
+        function links(index6) {
             let i = -1;
             const newIndex = [];
             const newChannels = {};
-            for (const k2 in channels)
-                newChannels[k2] = [];
-            const X13 = [];
-            const X23 = [];
-            const Y13 = [];
-            const Y23 = [];
-
-            function link4(ti, tj) {
-                ti = index4[ti];
-                tj = index4[tj];
+            for (const k3 in channels)
+                newChannels[k3] = [];
+            const X15 = [];
+            const X25 = [];
+            const Y15 = [];
+            const Y25 = [];
+
+            function link7(ti, tj) {
+                ti = index6[ti];
+                tj = index6[tj];
                 newIndex.push(++i);
-                X13[i] = xi(ti);
-                Y13[i] = yi(ti);
-                X23[i] = xi(tj);
-                Y23[i] = yi(tj);
-                for (const k2 in channels)
-                    newChannels[k2].push(channels[k2][tj]);
+                X15[i] = xi(ti);
+                Y15[i] = yi(ti);
+                X25[i] = xi(tj);
+                Y25[i] = yi(tj);
+                for (const k3 in channels)
+                    newChannels[k3].push(channels[k3][tj]);
             }
             const {
                 halfedges,
-                hull: hull2,
+                hull: hull3,
                 triangles
-            } = Delaunay.from(index4, xi, yi);
+            } = Delaunay2.from(index6, xi, yi);
             for (let i2 = 0; i2 < halfedges.length; ++i2) {
                 const j = halfedges[i2];
                 if (j > i2)
-                    link4(triangles[i2], triangles[j]);
+                    link7(triangles[i2], triangles[j]);
             }
-            for (let i2 = 0; i2 < hull2.length; ++i2) {
-                link4(hull2[i2], hull2[(i2 + 1) % hull2.length]);
+            for (let i2 = 0; i2 < hull3.length; ++i2) {
+                link7(hull3[i2], hull3[(i2 + 1) % hull3.length]);
             }
-            select_default2(this).selectAll().data(newIndex).join("path").call(applyDirectStyles, mark).attr("d", (i2) => {
-                const p = pathRound();
-                const c6 = curve(p);
-                c6.lineStart();
-                c6.point(X13[i2], Y13[i2]);
-                c6.point(X23[i2], Y23[i2]);
-                c6.lineEnd();
+            select_default5(this).selectAll().data(newIndex).join("path").call(applyDirectStyles2, mark).attr("d", (i2) => {
+                const p = pathRound2();
+                const c11 = curve(p);
+                c11.lineStart();
+                c11.point(X15[i2], Y15[i2]);
+                c11.point(X25[i2], Y25[i2]);
+                c11.lineEnd();
                 return p;
-            }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels, context);
+            }).call(applyChannelStyles2, mark, newChannels).call(applyMarkers2, mark, newChannels, context);
         }
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append("g").each(links) : (g) => g.datum(index3).each(links)
+            Z ? (g) => g.selectAll().data(group3(index5, (i) => Z[i]).values()).enter().append("g").each(links) : (g) => g.datum(index5).each(links)
         ).node();
     }
 };
-var AbstractDelaunayMark = class extends Mark {
-    constructor(data, options = {}, defaults21, zof = ({
+var AbstractDelaunayMark2 = class extends Mark2 {
+    constructor(data, options = {}, defaults41, zof = ({
         z
     }) => z) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 z: {
                     value: zof(options),
                     optional: true
                 }
             },
             options,
-            defaults21
+            defaults41
         );
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             z: Z
         } = channels;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        const xi = X3 ? (i) => X3[i] : constant2(cx);
-        const yi = Y3 ? (i) => Y3[i] : constant2(cy);
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant4(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant4(cy);
         const mark = this;
 
-        function mesh(index4) {
-            const delaunay = Delaunay.from(index4, xi, yi);
-            select_default2(this).append("path").datum(index4[0]).call(applyDirectStyles, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);
-        }
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        function mesh(index6) {
+            const delaunay = Delaunay2.from(index6, xi, yi);
+            select_default5(this).append("path").datum(index6[0]).call(applyDirectStyles2, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles2, mark, channels);
+        }
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append("g").each(mesh) : (g) => g.datum(index3).each(mesh)
+            Z ? (g) => g.selectAll().data(group3(index5, (i) => Z[i]).values()).enter().append("g").each(mesh) : (g) => g.datum(index5).each(mesh)
         ).node();
     }
 };
-var DelaunayMesh = class extends AbstractDelaunayMark {
+var DelaunayMesh2 = class extends AbstractDelaunayMark2 {
     constructor(data, options = {}) {
-        super(data, options, delaunayMeshDefaults);
+        super(data, options, delaunayMeshDefaults2);
         this.fill = "none";
     }
     _render(delaunay) {
         return delaunay.render();
     }
 };
-var Hull = class extends AbstractDelaunayMark {
+var Hull2 = class extends AbstractDelaunayMark2 {
     constructor(data, options = {}) {
-        super(data, options, hullDefaults, maybeZ);
+        super(data, options, hullDefaults2, maybeZ2);
     }
     _render(delaunay) {
         return delaunay.renderHull();
     }
 };
-var Voronoi2 = class extends Mark {
+var Voronoi4 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             z
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 z: {
                     value: z,
                     optional: true
                 }
             },
             options,
-            voronoiDefaults
+            voronoiDefaults2
         );
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             z: Z
         } = channels;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        const xi = X3 ? (i) => X3[i] : constant2(cx);
-        const yi = Y3 ? (i) => Y3[i] : constant2(cy);
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        const xi = X4 ? (i) => X4[i] : constant4(cx);
+        const yi = Y4 ? (i) => Y4[i] : constant4(cy);
         const mark = this;
 
-        function cells(index4) {
-            const delaunay = Delaunay.from(index4, xi, yi);
-            const voronoi2 = voronoiof(delaunay, dimensions);
-            select_default2(this).selectAll().data(index4).enter().append("path").call(applyDirectStyles, mark).attr("d", (_, i) => voronoi2.renderCell(i)).call(applyChannelStyles, mark, channels);
-        }
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        function cells(index6) {
+            const delaunay = Delaunay2.from(index6, xi, yi);
+            const voronoi3 = voronoiof2(delaunay, dimensions);
+            select_default5(this).selectAll().data(index6).enter().append("path").call(applyDirectStyles2, mark).attr("d", (_, i) => voronoi3.renderCell(i)).call(applyChannelStyles2, mark, channels);
+        }
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append("g").each(cells) : (g) => g.datum(index3).each(cells)
+            Z ? (g) => g.selectAll().data(group3(index5, (i) => Z[i]).values()).enter().append("g").each(cells) : (g) => g.datum(index5).each(cells)
         ).node();
     }
 };
-var VoronoiMesh = class extends AbstractDelaunayMark {
+var VoronoiMesh2 = class extends AbstractDelaunayMark2 {
     constructor(data, options) {
-        super(data, options, voronoiMeshDefaults);
+        super(data, options, voronoiMeshDefaults2);
         this.fill = "none";
     }
     _render(delaunay, dimensions) {
-        return voronoiof(delaunay, dimensions).render();
+        return voronoiof2(delaunay, dimensions).render();
     }
 };
 
-function voronoiof(delaunay, dimensions) {
+function voronoiof2(delaunay, dimensions) {
     const {
         width,
         height,
         marginTop,
         marginRight,
         marginBottom,
         marginLeft
     } = dimensions;
     return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);
 }
 
-function delaunayMark(DelaunayMark, data, {
-    x: x4,
-    y: y4,
+function delaunayMark2(DelaunayMark, data, {
+    x: x7,
+    y: y7,
     ...options
 } = {}) {
-    [x4, y4] = maybeTuple(x4, y4);
+    [x7, y7] = maybeTuple2(x7, y7);
     return new DelaunayMark(data, {
         ...options,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-function delaunayLink(data, options) {
-    return delaunayMark(DelaunayLink, data, options);
+function delaunayLink2(data, options) {
+    return delaunayMark2(DelaunayLink2, data, options);
 }
 
-function delaunayMesh(data, options) {
-    return delaunayMark(DelaunayMesh, data, options);
+function delaunayMesh2(data, options) {
+    return delaunayMark2(DelaunayMesh2, data, options);
 }
 
-function hull(data, options) {
-    return delaunayMark(Hull, data, options);
+function hull2(data, options) {
+    return delaunayMark2(Hull2, data, options);
 }
 
-function voronoi(data, options) {
-    return delaunayMark(Voronoi2, data, options);
+function voronoi2(data, options) {
+    return delaunayMark2(Voronoi4, data, options);
 }
 
-function voronoiMesh(data, options) {
-    return delaunayMark(VoronoiMesh, data, options);
+function voronoiMesh2(data, options) {
+    return delaunayMark2(VoronoiMesh2, data, options);
 }
 
-// node_modules/@observablehq/plot/src/marks/density.js
-var defaults16 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/density.js
+var defaults36 = {
     ariaLabel: "density",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-var Density = class extends Mark {
+var Density2 = class extends Mark2 {
     constructor(data, {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         z,
         weight,
         fill,
         stroke,
         ...options
     } = {}) {
-        const fillDensity = isDensity(fill) && (fill = "currentColor", true);
-        const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
+        const fillDensity = isDensity2(fill) && (fill = "currentColor", true);
+        const strokeDensity = isDensity2(stroke) && (stroke = "currentColor", true);
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 z: {
-                    value: maybeZ({
+                    value: maybeZ2({
                         z,
                         fill,
                         stroke
                     }),
                     optional: true
                 },
                 weight: {
                     value: weight,
                     optional: true
                 }
             },
-            densityInitializer({
+            densityInitializer2({
                 ...options,
                 fill,
                 stroke
             }, fillDensity, strokeDensity),
-            defaults16
+            defaults36
         );
         if (fillDensity)
             this.fill = void 0;
         if (strokeDensity)
             this.stroke = void 0;
         this.z = z;
     }
-    filter(index3) {
-        return index3;
+    filter(index5) {
+        return index5;
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             contours
         } = channels;
-        const path2 = path_default();
-        return create_default("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(
-            (g) => g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i) => path2(contours[i]))
+        const path3 = path_default3();
+        return create_default2("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {}).call(
+            (g) => g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).call(applyChannelStyles2, this, channels).attr("d", (i) => path3(contours[i]))
         ).node();
     }
 };
 
-function density(data, options = {}) {
+function density2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
-    [x4, y4] = maybeTuple(x4, y4);
-    return new Density(data, {
+    [x7, y7] = maybeTuple2(x7, y7);
+    return new Density2(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
-var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
+var dropChannels2 = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
 
-function densityInitializer(options, fillDensity, strokeDensity) {
-    const k2 = 100;
+function densityInitializer2(options, fillDensity, strokeDensity) {
+    const k3 = 100;
     let {
         bandwidth,
         thresholds
     } = options;
     bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
-    thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers(thresholds) : +thresholds;
-    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
-        const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
+    thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers2(thresholds) : +thresholds;
+    return initializer2(options, function(data, facets, channels, scales, dimensions, context) {
+        const W = channels.weight ? coerceNumbers2(channels.weight.value) : null;
         const Z = channels.z?.value;
         const {
             z
         } = this;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
         const {
             width,
             height
         } = dimensions;
         const {
-            x: X3,
-            y: Y3
-        } = applyPosition(channels, scales, context);
+            x: X4,
+            y: Y4
+        } = applyPosition2(channels, scales, context);
         const newChannels = Object.fromEntries(
-            Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, {
+            Object.entries(channels).filter(([key]) => !dropChannels2.has(key)).map(([key, channel]) => [key, {
                 ...channel,
                 value: []
             }])
         );
         const FD = fillDensity && [];
         const SD = strokeDensity && [];
-        const density2 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);
+        const density3 = density_default2().x(X4 ? (i) => X4[i] : cx).y(Y4 ? (i) => Y4[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);
         const facetsContours = [];
         for (const facet of facets) {
             const facetContours = [];
             facetsContours.push(facetContours);
-            for (const index3 of Z ? groupZ2(facet, Z, z) : [facet]) {
-                const contour2 = density2.contours(index3);
-                facetContours.push([index3, contour2]);
+            for (const index5 of Z ? groupZ4(facet, Z, z) : [facet]) {
+                const contour3 = density3.contours(index5);
+                facetContours.push([index5, contour3]);
             }
         }
         let T = thresholds;
-        if (!(T instanceof TypedArray)) {
+        if (!(T instanceof TypedArray2)) {
             let maxValue = 0;
             for (const facetContours of facetsContours) {
-                for (const [, contour2] of facetContours) {
-                    const max5 = contour2.max;
-                    if (max5 > maxValue)
-                        maxValue = max5;
+                for (const [, contour3] of facetContours) {
+                    const max9 = contour3.max;
+                    if (max9 > maxValue)
+                        maxValue = max9;
                 }
             }
             T = Float64Array.from({
                 length: thresholds - 1
-            }, (_, i) => maxValue * k2 * (i + 1) / thresholds);
+            }, (_, i) => maxValue * k3 * (i + 1) / thresholds);
         }
         const newFacets = [];
         const contours = [];
         for (const facetContours of facetsContours) {
             const newFacet = [];
             newFacets.push(newFacet);
-            for (const [index3, contour2] of facetContours) {
+            for (const [index5, contour3] of facetContours) {
                 for (const t of T) {
                     newFacet.push(contours.length);
-                    contours.push(contour2(t / k2));
+                    contours.push(contour3(t / k3));
                     if (FD)
                         FD.push(t);
                     if (SD)
                         SD.push(t);
                     for (const key in newChannels) {
-                        newChannels[key].value.push(channels[key].value[index3[0]]);
+                        newChannels[key].value.push(channels[key].value[index5[0]]);
                     }
                 }
             }
         }
         if (FD)
             FD.push(0);
         if (SD)
@@ -32774,84 +67480,84 @@
                     value: contours
                 }
             }
         };
     });
 }
 
-function isDensity(value) {
+function isDensity2(value) {
     return /^density$/i.test(value);
 }
 
-// node_modules/@observablehq/plot/src/marks/geo.js
-var defaults17 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/geo.js
+var defaults37 = {
     ariaLabel: "geo",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-var Geo = class extends Mark {
+var Geo2 = class extends Mark2 {
     constructor(data, options = {}) {
-        const [vr, cr] = maybeNumberChannel(options.r, 3);
+        const [vr, cr] = maybeNumberChannel2(options.r, 3);
         super(
             data, {
                 geometry: {
                     value: options.geometry
                 },
                 r: {
                     value: vr,
                     scale: "r",
-                    filter: positive,
+                    filter: positive2,
                     optional: true
                 }
             },
-            withDefaultSort(options),
-            defaults17
+            withDefaultSort2(options),
+            defaults37
         );
         this.r = cr;
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             geometry: G,
             r: R
         } = channels;
-        const path2 = path_default(context.projection ?? scaleProjection2(scales));
+        const path3 = path_default3(context.projection ?? scaleProjection4(scales));
         const {
             r
         } = this;
-        if (negative(r))
-            index3 = [];
+        if (negative2(r))
+            index5 = [];
         else if (r !== void 0)
-            path2.pointRadius(r);
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
-            g.selectAll().data(index3).enter().append("path").call(applyDirectStyles, this).attr("d", R ? (i) => path2.pointRadius(R[i])(G[i]) : (i) => path2(G[i])).call(applyChannelStyles, this, channels);
+            path3.pointRadius(r);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call((g) => {
+            g.selectAll().data(index5).enter().append("path").call(applyDirectStyles2, this).attr("d", R ? (i) => path3.pointRadius(R[i])(G[i]) : (i) => path3(G[i])).call(applyChannelStyles2, this, channels);
         }).node();
     }
 };
 
-function scaleProjection2({
-    x: X3,
-    y: Y3
+function scaleProjection4({
+    x: X4,
+    y: Y4
 }) {
-    if (X3 || Y3) {
-        X3 ??= (x4) => x4;
-        Y3 ??= (y4) => y4;
-        return transform_default({
-            point(x4, y4) {
-                this.stream.point(X3(x4), Y3(y4));
+    if (X4 || Y4) {
+        X4 ??= (x7) => x7;
+        Y4 ??= (y7) => y7;
+        return transform_default2({
+            point(x7, y7) {
+                this.stream.point(X4(x7), Y4(y7));
             }
         });
     }
 }
 
-function geo(data, {
-    geometry = identity6,
+function geo2(data, {
+    geometry = identity13,
     ...options
 } = {}) {
     switch (data?.type) {
         case "FeatureCollection":
             data = data.features;
             break;
         case "GeometryCollection":
@@ -32864,87 +67570,87 @@
         case "MultiPolygon":
         case "Point":
         case "Polygon":
         case "Sphere":
             data = [data];
             break;
     }
-    return new Geo(data, {
+    return new Geo2(data, {
         geometry,
         ...options
     });
 }
 
-function sphere({
+function sphere2({
     strokeWidth = 1.5,
     ...options
 } = {}) {
-    return geo({
+    return geo2({
         type: "Sphere"
     }, {
         strokeWidth,
         ...options
     });
 }
 
-function graticule2({
+function graticule4({
     strokeOpacity = 0.1,
     ...options
 } = {}) {
-    return geo(graticule10(), {
+    return geo2(graticule102(), {
         strokeOpacity,
         ...options
     });
 }
 
-// node_modules/@observablehq/plot/src/transforms/hexbin.js
-var ox = 0.5;
-var oy = 0;
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/hexbin.js
+var ox2 = 0.5;
+var oy2 = 0;
 
-function hexbin(outputs = {
+function hexbin2(outputs = {
     fill: "count"
 }, {
     binWidth,
     ...options
 } = {}) {
-    binWidth = binWidth === void 0 ? 20 : number5(binWidth);
-    outputs = maybeOutputs(outputs, options);
+    binWidth = binWidth === void 0 ? 20 : number11(binWidth);
+    outputs = maybeOutputs2(outputs, options);
     const {
         z,
         fill,
         stroke
     } = options;
-    if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, "fill"))
+    if (stroke === void 0 && isNoneish2(fill) && hasOutput2(outputs, "fill"))
         options.stroke = "none";
     if (options.symbol === void 0)
         options.symbol = "hexagon";
-    if (options.r === void 0 && !hasOutput(outputs, "r"))
+    if (options.r === void 0 && !hasOutput2(outputs, "r"))
         options.r = binWidth / 2;
-    return initializer(options, (data, facets, channels, scales, _, context) => {
+    return initializer2(options, (data, facets, channels, scales, _, context) => {
         let {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             z: Z,
             fill: F,
             stroke: S,
             symbol: Q
         } = channels;
-        if (X3 === void 0)
+        if (X4 === void 0)
             throw new Error("missing channel: x");
-        if (Y3 === void 0)
+        if (Y4 === void 0)
             throw new Error("missing channel: y");
         ({
-            x: X3,
-            y: Y3
-        } = applyPosition(channels, scales, context));
-        Z = Z ? Z.value : valueof(data, z);
+            x: X4,
+            y: Y4
+        } = applyPosition2(channels, scales, context));
+        Z = Z ? Z.value : valueof2(data, z);
         F = F?.value;
         S = S?.value;
         Q = Q?.value;
-        const G = maybeSubgroup(outputs, {
+        const G = maybeSubgroup2(outputs, {
             z: Z,
             fill: F,
             stroke: S,
             symbol: Q
         });
         const GZ = Z && [];
         const GF = F && [];
@@ -32956,29 +67662,29 @@
         let i = -1;
         for (const o of outputs)
             o.initialize(data);
         for (const facet of facets) {
             const binFacet = [];
             for (const o of outputs)
                 o.scope("facet", facet);
-            for (const [f, I] of maybeGroup(facet, G)) {
-                for (const bin3 of hbin(I, X3, Y3, binWidth)) {
+            for (const [f, I] of maybeGroup2(facet, G)) {
+                for (const bin5 of hbin2(I, X4, Y4, binWidth)) {
                     binFacet.push(++i);
-                    BX.push(bin3.x);
-                    BY.push(bin3.y);
+                    BX.push(bin5.x);
+                    BY.push(bin5.y);
                     if (Z)
-                        GZ.push(G === Z ? f : Z[bin3[0]]);
+                        GZ.push(G === Z ? f : Z[bin5[0]]);
                     if (F)
-                        GF.push(G === F ? f : F[bin3[0]]);
+                        GF.push(G === F ? f : F[bin5[0]]);
                     if (S)
-                        GS.push(G === S ? f : S[bin3[0]]);
+                        GS.push(G === S ? f : S[bin5[0]]);
                     if (Q)
-                        GQ.push(G === Q ? f : Q[bin3[0]]);
+                        GQ.push(G === Q ? f : Q[bin5[0]]);
                     for (const o of outputs)
-                        o.reduce(bin3);
+                        o.reduce(bin5);
                 }
             }
             binFacets.push(binFacet);
         }
         const binChannels = {
             x: {
                 value: BX
@@ -33026,1725 +67732,1725 @@
             data,
             facets: binFacets,
             channels: binChannels
         };
     });
 }
 
-function hbin(I, X3, Y3, dx) {
-    const dy = dx * (1.5 / sqrt35);
+function hbin2(I, X4, Y4, dx) {
+    const dy = dx * (1.5 / sqrt39);
     const bins = /* @__PURE__ */ new Map();
     for (const i of I) {
-        let px = X3[i],
-            py = Y3[i];
+        let px = X4[i],
+            py = Y4[i];
         if (isNaN(px) || isNaN(py))
             continue;
-        let pj = Math.round(py = (py - oy) / dy),
-            pi7 = Math.round(px = (px - ox) / dx - (pj & 1) / 2),
+        let pj = Math.round(py = (py - oy2) / dy),
+            pi13 = Math.round(px = (px - ox2) / dx - (pj & 1) / 2),
             py1 = py - pj;
         if (Math.abs(py1) * 3 > 1) {
-            let px1 = px - pi7,
-                pi22 = pi7 + (px < pi7 ? -1 : 1) / 2,
+            let px1 = px - pi13,
+                pi22 = pi13 + (px < pi13 ? -1 : 1) / 2,
                 pj2 = pj + (py < pj ? -1 : 1),
                 px2 = px - pi22,
                 py2 = py - pj2;
             if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
-                pi7 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
+                pi13 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
         }
-        const key = `${pi7},${pj}`;
-        let bin3 = bins.get(key);
-        if (bin3 === void 0) {
-            bins.set(key, bin3 = []);
-            bin3.x = (pi7 + (pj & 1) / 2) * dx + ox;
-            bin3.y = pj * dy + oy;
+        const key = `${pi13},${pj}`;
+        let bin5 = bins.get(key);
+        if (bin5 === void 0) {
+            bins.set(key, bin5 = []);
+            bin5.x = (pi13 + (pj & 1) / 2) * dx + ox2;
+            bin5.y = pj * dy + oy2;
         }
-        bin3.push(i);
+        bin5.push(i);
     }
     return bins.values();
 }
 
-// node_modules/@observablehq/plot/src/marks/hexgrid.js
-var defaults18 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/hexgrid.js
+var defaults38 = {
     ariaLabel: "hexgrid",
     fill: "none",
     stroke: "currentColor",
     strokeOpacity: 0.1
 };
 
-function hexgrid(options) {
-    return new Hexgrid(options);
+function hexgrid2(options) {
+    return new Hexgrid2(options);
 }
-var Hexgrid = class extends Mark {
+var Hexgrid2 = class extends Mark2 {
     constructor({
         binWidth = 20,
         clip = true,
         ...options
     } = {}) {
         super(void 0, void 0, {
             clip,
             ...options
-        }, defaults18);
-        this.binWidth = number5(binWidth);
+        }, defaults38);
+        this.binWidth = number11(binWidth);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
             binWidth
         } = this;
         const {
             marginTop,
             marginRight,
             marginBottom,
             marginLeft,
             width,
             height
         } = dimensions;
-        const x06 = marginLeft - ox,
-            x12 = width - marginRight - ox,
-            y06 = marginTop - oy,
-            y12 = height - marginBottom - oy,
+        const x011 = marginLeft - ox2,
+            x13 = width - marginRight - ox2,
+            y011 = marginTop - oy2,
+            y13 = height - marginBottom - oy2,
             rx = binWidth / 2,
-            ry = rx * sqrt4_3,
+            ry = rx * sqrt4_32,
             hy = ry / 2,
             wx = rx * 2,
             wy = ry * 1.5,
-            i0 = Math.floor(x06 / wx),
-            i1 = Math.ceil(x12 / wx),
-            j0 = Math.floor((y06 + hy) / wy),
-            j1 = Math.ceil((y12 - hy) / wy) + 1,
-            path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;
-        let d = path2;
+            i0 = Math.floor(x011 / wx),
+            i1 = Math.ceil(x13 / wx),
+            j0 = Math.floor((y011 + hy) / wy),
+            j1 = Math.ceil((y13 - hy) / wy) + 1,
+            path3 = `m0,${round2(-ry)}l${round2(rx)},${round2(hy)}v${round2(ry)}l${round2(-rx)},${round2(hy)}`;
+        let d = path3;
         for (let j = j0; j < j1; ++j) {
             for (let i = i0; i < i1; ++i) {
-                d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path2}`;
+                d += `M${round2(i * wx + (j & 1) * rx)},${round2(j * wy)}${path3}`;
             }
         }
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append("path").call(applyDirectStyles, this).attr("d", d)).node();
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {}, offset2 + ox2, offset2 + oy2).call((g) => g.append("path").call(applyDirectStyles2, this).attr("d", d)).node();
     }
 };
 
-function round(x4) {
-    return Math.round(x4 * 1e3) / 1e3;
+function round2(x7) {
+    return Math.round(x7 * 1e3) / 1e3;
 }
 
-// node_modules/@observablehq/plot/src/marks/image.js
-var defaults19 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/image.js
+var defaults39 = {
     ariaLabel: "image",
     fill: null,
     stroke: null
 };
 
-function isPath(string2) {
-    return /^\.*\//.test(string2);
+function isPath2(string3) {
+    return /^\.*\//.test(string3);
 }
 
-function isUrl(string2) {
-    return /^(blob|data|file|http|https):/i.test(string2);
+function isUrl2(string3) {
+    return /^(blob|data|file|http|https):/i.test(string3);
 }
 
-function maybePathChannel(value) {
-    return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
+function maybePathChannel2(value) {
+    return typeof value === "string" && (isPath2(value) || isUrl2(value)) ? [void 0, value] : [value, void 0];
 }
-var Image2 = class extends Mark {
+var Image3 = class extends Mark2 {
     constructor(data, options = {}) {
         let {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             width,
             height,
             src,
             preserveAspectRatio,
             crossOrigin,
             frameAnchor,
             imageRendering
         } = options;
         if (width === void 0 && height !== void 0)
             width = height;
         else if (height === void 0 && width !== void 0)
             height = width;
-        const [vs, cs] = maybePathChannel(src);
-        const [vw, cw] = maybeNumberChannel(width, 16);
-        const [vh, ch] = maybeNumberChannel(height, 16);
+        const [vs, cs] = maybePathChannel2(src);
+        const [vw, cw] = maybeNumberChannel2(width, 16);
+        const [vh, ch] = maybeNumberChannel2(height, 16);
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x",
                     optional: true
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y",
                     optional: true
                 },
                 width: {
                     value: vw,
-                    filter: positive,
+                    filter: positive2,
                     optional: true
                 },
                 height: {
                     value: vh,
-                    filter: positive,
+                    filter: positive2,
                     optional: true
                 },
                 src: {
                     value: vs,
                     optional: true
                 }
             },
             options,
-            defaults19
+            defaults39
         );
         this.src = cs;
         this.width = cw;
         this.height = ch;
-        this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
-        this.crossOrigin = string(crossOrigin);
-        this.frameAnchor = maybeFrameAnchor(frameAnchor);
-        this.imageRendering = impliedString(imageRendering, "auto");
+        this.preserveAspectRatio = impliedString2(preserveAspectRatio, "xMidYMid");
+        this.crossOrigin = string2(crossOrigin);
+        this.frameAnchor = maybeFrameAnchor2(frameAnchor);
+        this.imageRendering = impliedString2(imageRendering, "auto");
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: x4,
-            y: y4
+            x: x7,
+            y: y7
         } = scales;
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             width: W,
             height: H,
             src: S
         } = channels;
-        const [cx, cy] = applyFrameAnchor(this, dimensions);
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {
-            x: X3 && x4,
-            y: Y3 && y4
+        const [cx, cy] = applyFrameAnchor2(this, dimensions);
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, {
+            x: X4 && x7,
+            y: Y4 && y7
         }).call(
-            (g) => g.selectAll().data(index3).enter().append("image").call(applyDirectStyles, this).attr(
+            (g) => g.selectAll().data(index5).enter().append("image").call(applyDirectStyles2, this).attr(
                 "x",
-                W && X3 ? (i) => X3[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X3 ? (i) => X3[i] - this.width / 2 : cx - this.width / 2
+                W && X4 ? (i) => X4[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X4 ? (i) => X4[i] - this.width / 2 : cx - this.width / 2
             ).attr(
                 "y",
-                H && Y3 ? (i) => Y3[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y3 ? (i) => Y3[i] - this.height / 2 : cy - this.height / 2
-            ).attr("width", W ? (i) => W[i] : this.width).attr("height", H ? (i) => H[i] : this.height).call(applyAttr, "href", S ? (i) => S[i] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyAttr, "image-rendering", this.imageRendering).call(applyChannelStyles, this, channels)
+                H && Y4 ? (i) => Y4[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y4 ? (i) => Y4[i] - this.height / 2 : cy - this.height / 2
+            ).attr("width", W ? (i) => W[i] : this.width).attr("height", H ? (i) => H[i] : this.height).call(applyAttr2, "href", S ? (i) => S[i] : this.src).call(applyAttr2, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr2, "crossorigin", this.crossOrigin).call(applyAttr2, "image-rendering", this.imageRendering).call(applyChannelStyles2, this, channels)
         ).node();
     }
 };
 
-function image(data, options = {}) {
+function image2(data, options = {}) {
     let {
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         ...remainingOptions
     } = options;
     if (options.frameAnchor === void 0)
-        [x4, y4] = maybeTuple(x4, y4);
-    return new Image2(data, {
+        [x7, y7] = maybeTuple2(x7, y7);
+    return new Image3(data, {
         ...remainingOptions,
-        x: x4,
-        y: y4
+        x: x7,
+        y: y7
     });
 }
 
-// node_modules/@observablehq/plot/src/stats.js
-function ibetainv(p, a4, b) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/stats.js
+function ibetainv2(p, a7, b) {
     var EPS = 1e-8;
-    var a1 = a4 - 1;
-    var b12 = b - 1;
+    var a1 = a7 - 1;
+    var b13 = b - 1;
     var j = 0;
-    var lna, lnb, pp, t, u4, err, x4, al, h, w, afac;
+    var lna, lnb, pp, t, u7, err, x7, al, h, w, afac;
     if (p <= 0)
         return 0;
     if (p >= 1)
         return 1;
-    if (a4 >= 1 && b >= 1) {
+    if (a7 >= 1 && b >= 1) {
         pp = p < 0.5 ? p : 1 - p;
         t = Math.sqrt(-2 * Math.log(pp));
-        x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
+        x7 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
         if (p < 0.5)
-            x4 = -x4;
-        al = (x4 * x4 - 3) / 6;
-        h = 2 / (1 / (2 * a4 - 1) + 1 / (2 * b - 1));
-        w = x4 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a4 - 1)) * (al + 5 / 6 - 2 / (3 * h));
-        x4 = a4 / (a4 + b * Math.exp(2 * w));
-    } else {
-        lna = Math.log(a4 / (a4 + b));
-        lnb = Math.log(b / (a4 + b));
-        t = Math.exp(a4 * lna) / a4;
-        u4 = Math.exp(b * lnb) / b;
-        w = t + u4;
+            x7 = -x7;
+        al = (x7 * x7 - 3) / 6;
+        h = 2 / (1 / (2 * a7 - 1) + 1 / (2 * b - 1));
+        w = x7 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a7 - 1)) * (al + 5 / 6 - 2 / (3 * h));
+        x7 = a7 / (a7 + b * Math.exp(2 * w));
+    } else {
+        lna = Math.log(a7 / (a7 + b));
+        lnb = Math.log(b / (a7 + b));
+        t = Math.exp(a7 * lna) / a7;
+        u7 = Math.exp(b * lnb) / b;
+        w = t + u7;
         if (p < t / w)
-            x4 = Math.pow(a4 * w * p, 1 / a4);
+            x7 = Math.pow(a7 * w * p, 1 / a7);
         else
-            x4 = 1 - Math.pow(b * w * (1 - p), 1 / b);
+            x7 = 1 - Math.pow(b * w * (1 - p), 1 / b);
     }
-    afac = -gammaln(a4) - gammaln(b) + gammaln(a4 + b);
+    afac = -gammaln2(a7) - gammaln2(b) + gammaln2(a7 + b);
     for (; j < 10; j++) {
-        if (x4 === 0 || x4 === 1)
-            return x4;
-        err = ibeta(x4, a4, b) - p;
-        t = Math.exp(a1 * Math.log(x4) + b12 * Math.log(1 - x4) + afac);
-        u4 = err / t;
-        x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b12 / (1 - x4))));
-        if (x4 <= 0)
-            x4 = 0.5 * (x4 + t);
-        if (x4 >= 1)
-            x4 = 0.5 * (x4 + t + 1);
-        if (Math.abs(t) < EPS * x4 && j > 0)
-            break;
-    }
-    return x4;
-}
-
-function ibeta(x4, a4, b) {
-    var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln(a4 + b) - gammaln(a4) - gammaln(b) + a4 * Math.log(x4) + b * Math.log(1 - x4));
-    if (x4 < 0 || x4 > 1)
+        if (x7 === 0 || x7 === 1)
+            return x7;
+        err = ibeta2(x7, a7, b) - p;
+        t = Math.exp(a1 * Math.log(x7) + b13 * Math.log(1 - x7) + afac);
+        u7 = err / t;
+        x7 -= t = u7 / (1 - 0.5 * Math.min(1, u7 * (a1 / x7 - b13 / (1 - x7))));
+        if (x7 <= 0)
+            x7 = 0.5 * (x7 + t);
+        if (x7 >= 1)
+            x7 = 0.5 * (x7 + t + 1);
+        if (Math.abs(t) < EPS * x7 && j > 0)
+            break;
+    }
+    return x7;
+}
+
+function ibeta2(x7, a7, b) {
+    var bt = x7 === 0 || x7 === 1 ? 0 : Math.exp(gammaln2(a7 + b) - gammaln2(a7) - gammaln2(b) + a7 * Math.log(x7) + b * Math.log(1 - x7));
+    if (x7 < 0 || x7 > 1)
         return false;
-    if (x4 < (a4 + 1) / (a4 + b + 2))
-        return bt * betacf(x4, a4, b) / a4;
-    return 1 - bt * betacf(1 - x4, b, a4) / b;
+    if (x7 < (a7 + 1) / (a7 + b + 2))
+        return bt * betacf2(x7, a7, b) / a7;
+    return 1 - bt * betacf2(1 - x7, b, a7) / b;
 }
 
-function betacf(x4, a4, b) {
+function betacf2(x7, a7, b) {
     var fpmin = 1e-30;
-    var m3 = 1;
-    var qab = a4 + b;
-    var qap = a4 + 1;
-    var qam = a4 - 1;
-    var c6 = 1;
-    var d = 1 - qab * x4 / qap;
-    var m22, aa2, del, h;
+    var m5 = 1;
+    var qab = a7 + b;
+    var qap = a7 + 1;
+    var qam = a7 - 1;
+    var c11 = 1;
+    var d = 1 - qab * x7 / qap;
+    var m22, aa3, del, h;
     if (Math.abs(d) < fpmin)
         d = fpmin;
     d = 1 / d;
     h = d;
-    for (; m3 <= 100; m3++) {
-        m22 = 2 * m3;
-        aa2 = m3 * (b - m3) * x4 / ((qam + m22) * (a4 + m22));
-        d = 1 + aa2 * d;
+    for (; m5 <= 100; m5++) {
+        m22 = 2 * m5;
+        aa3 = m5 * (b - m5) * x7 / ((qam + m22) * (a7 + m22));
+        d = 1 + aa3 * d;
         if (Math.abs(d) < fpmin)
             d = fpmin;
-        c6 = 1 + aa2 / c6;
-        if (Math.abs(c6) < fpmin)
-            c6 = fpmin;
+        c11 = 1 + aa3 / c11;
+        if (Math.abs(c11) < fpmin)
+            c11 = fpmin;
         d = 1 / d;
-        h *= d * c6;
-        aa2 = -(a4 + m3) * (qab + m3) * x4 / ((a4 + m22) * (qap + m22));
-        d = 1 + aa2 * d;
+        h *= d * c11;
+        aa3 = -(a7 + m5) * (qab + m5) * x7 / ((a7 + m22) * (qap + m22));
+        d = 1 + aa3 * d;
         if (Math.abs(d) < fpmin)
             d = fpmin;
-        c6 = 1 + aa2 / c6;
-        if (Math.abs(c6) < fpmin)
-            c6 = fpmin;
+        c11 = 1 + aa3 / c11;
+        if (Math.abs(c11) < fpmin)
+            c11 = fpmin;
         d = 1 / d;
-        del = d * c6;
+        del = d * c11;
         h *= del;
         if (Math.abs(del - 1) < 3e-7)
             break;
     }
     return h;
 }
 
-function gammaln(x4) {
+function gammaln2(x7) {
     var j = 0;
     var cof = [
         76.18009172947146,
         -86.5053203294167,
         24.01409824083091,
         -1.231739572450155,
         0.001208650973866179,
         -5395239384953e-18
     ];
     var ser = 1.000000000190015;
-    var xx, y4, tmp2;
-    tmp2 = (y4 = xx = x4) + 5.5;
+    var xx, y7, tmp2;
+    tmp2 = (y7 = xx = x7) + 5.5;
     tmp2 -= (xx + 0.5) * Math.log(tmp2);
     for (; j < 6; j++)
-        ser += cof[j] / ++y4;
+        ser += cof[j] / ++y7;
     return Math.log(2.506628274631 * ser / xx) - tmp2;
 }
 
-function qt(p, dof) {
-    var x4 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
-    x4 = Math.sqrt(dof * (1 - x4) / x4);
-    return p > 0.5 ? x4 : -x4;
+function qt2(p, dof) {
+    var x7 = ibetainv2(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
+    x7 = Math.sqrt(dof * (1 - x7) / x7);
+    return p > 0.5 ? x7 : -x7;
 }
 
-// node_modules/@observablehq/plot/src/marks/linearRegression.js
-var defaults20 = {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/linearRegression.js
+var defaults40 = {
     ariaLabel: "linear-regression",
     fill: "currentColor",
     fillOpacity: 0.1,
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-var LinearRegression = class extends Mark {
+var LinearRegression2 = class extends Mark2 {
     constructor(data, options = {}) {
         const {
-            x: x4,
-            y: y4,
+            x: x7,
+            y: y7,
             z,
             ci = 0.95,
             precision = 4
         } = options;
         super(
             data, {
                 x: {
-                    value: x4,
+                    value: x7,
                     scale: "x"
                 },
                 y: {
-                    value: y4,
+                    value: y7,
                     scale: "y"
                 },
                 z: {
-                    value: maybeZ(options),
+                    value: maybeZ2(options),
                     optional: true
                 }
             },
             options,
-            defaults20
+            defaults40
         );
         this.z = z;
         this.ci = +ci;
         this.precision = +precision;
         if (!(0 <= this.ci && this.ci < 1))
             throw new Error(`invalid ci; not in [0, 1): ${ci}`);
         if (!(this.precision > 0))
             throw new Error(`invalid precision: ${precision}`);
     }
-    render(index3, scales, channels, dimensions, context) {
+    render(index5, scales, channels, dimensions, context) {
         const {
-            x: X3,
-            y: Y3,
+            x: X4,
+            y: Y4,
             z: Z
         } = channels;
         const {
             ci
         } = this;
-        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
-            (g) => g.selectAll().data(Z ? groupZ2(index3, Z, this.z) : [index3]).enter().call(
-                (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
+        return create4("svg:g", context).call(applyIndirectStyles2, this, dimensions, context).call(applyTransform2, this, scales).call(
+            (g) => g.selectAll().data(Z ? groupZ4(index5, Z, this.z) : [index5]).enter().call(
+                (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles2, this).call(applyGroupedChannelStyles2, this, {
                     ...channels,
                     fill: null,
                     fillOpacity: null
-                }).attr("d", (I) => this._renderLine(I, X3, Y3)).call(
-                    ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
+                }).attr("d", (I) => this._renderLine(I, X4, Y4)).call(
+                    ci && !isNone2(this.fill) ? (path3) => path3.select(pathBefore2).attr("stroke", "none").call(applyDirectStyles2, this).call(applyGroupedChannelStyles2, this, {
                         ...channels,
                         stroke: null,
                         strokeOpacity: null,
                         strokeWidth: null
-                    }).attr("d", (I) => this._renderBand(I, X3, Y3)) : () => {}
+                    }).attr("d", (I) => this._renderBand(I, X4, Y4)) : () => {}
                 )
             )
         ).node();
     }
 };
 
-function pathBefore() {
-    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
+function pathBefore2() {
+    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default2.svg, "path"), this);
 }
-var LinearRegressionX = class extends LinearRegression {
+var LinearRegressionX2 = class extends LinearRegression2 {
     constructor(data, options) {
         super(data, options);
     }
-    _renderBand(I, X3, Y3) {
+    _renderBand(I, X4, Y4) {
         const {
             ci,
             precision
         } = this;
-        const [y12, y22] = extent(I, (i) => Y3[i]);
-        const f = linearRegressionF(I, Y3, X3);
-        const g = confidenceIntervalF(I, Y3, X3, (1 - ci) / 2, f);
-        return area_default5().y((y4) => y4).x0((y4) => g(y4, -1)).x1((y4) => g(y4, 1))(range(y12, y22 - precision / 2, precision).concat(y22));
-    }
-    _renderLine(I, X3, Y3) {
-        const [y12, y22] = extent(I, (i) => Y3[i]);
-        const f = linearRegressionF(I, Y3, X3);
-        return `M${f(y12)},${y12}L${f(y22)},${y22}`;
+        const [y13, y22] = extent3(I, (i) => Y4[i]);
+        const f = linearRegressionF2(I, Y4, X4);
+        const g = confidenceIntervalF2(I, Y4, X4, (1 - ci) / 2, f);
+        return area_default10().y((y7) => y7).x0((y7) => g(y7, -1)).x1((y7) => g(y7, 1))(range5(y13, y22 - precision / 2, precision).concat(y22));
+    }
+    _renderLine(I, X4, Y4) {
+        const [y13, y22] = extent3(I, (i) => Y4[i]);
+        const f = linearRegressionF2(I, Y4, X4);
+        return `M${f(y13)},${y13}L${f(y22)},${y22}`;
     }
 };
-var LinearRegressionY = class extends LinearRegression {
+var LinearRegressionY2 = class extends LinearRegression2 {
     constructor(data, options) {
         super(data, options);
     }
-    _renderBand(I, X3, Y3) {
+    _renderBand(I, X4, Y4) {
         const {
             ci,
             precision
         } = this;
-        const [x12, x22] = extent(I, (i) => X3[i]);
-        const f = linearRegressionF(I, X3, Y3);
-        const g = confidenceIntervalF(I, X3, Y3, (1 - ci) / 2, f);
-        return area_default5().x((x4) => x4).y0((x4) => g(x4, -1)).y1((x4) => g(x4, 1))(range(x12, x22 - precision / 2, precision).concat(x22));
-    }
-    _renderLine(I, X3, Y3) {
-        const [x12, x22] = extent(I, (i) => X3[i]);
-        const f = linearRegressionF(I, X3, Y3);
-        return `M${x12},${f(x12)}L${x22},${f(x22)}`;
+        const [x13, x22] = extent3(I, (i) => X4[i]);
+        const f = linearRegressionF2(I, X4, Y4);
+        const g = confidenceIntervalF2(I, X4, Y4, (1 - ci) / 2, f);
+        return area_default10().x((x7) => x7).y0((x7) => g(x7, -1)).y1((x7) => g(x7, 1))(range5(x13, x22 - precision / 2, precision).concat(x22));
+    }
+    _renderLine(I, X4, Y4) {
+        const [x13, x22] = extent3(I, (i) => X4[i]);
+        const f = linearRegressionF2(I, X4, Y4);
+        return `M${x13},${f(x13)}L${x22},${f(x22)}`;
     }
 };
 
-function linearRegressionX(data, options = {}) {
+function linearRegressionX2(data, options = {}) {
     const {
-        y: y4 = indexOf,
-        x: x4 = identity6,
+        y: y7 = indexOf2,
+        x: x7 = identity13,
         stroke,
-        fill = isNoneish(stroke) ? "currentColor" : stroke,
+        fill = isNoneish2(stroke) ? "currentColor" : stroke,
         ...remainingOptions
     } = options;
-    return new LinearRegressionX(data, maybeDenseIntervalY({
+    return new LinearRegressionX2(data, maybeDenseIntervalY2({
         ...remainingOptions,
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         fill,
         stroke
     }));
 }
 
-function linearRegressionY(data, options = {}) {
+function linearRegressionY2(data, options = {}) {
     const {
-        x: x4 = indexOf,
-        y: y4 = identity6,
+        x: x7 = indexOf2,
+        y: y7 = identity13,
         stroke,
-        fill = isNoneish(stroke) ? "currentColor" : stroke,
+        fill = isNoneish2(stroke) ? "currentColor" : stroke,
         ...remainingOptions
     } = options;
-    return new LinearRegressionY(data, maybeDenseIntervalX({
+    return new LinearRegressionY2(data, maybeDenseIntervalX2({
         ...remainingOptions,
-        x: x4,
-        y: y4,
+        x: x7,
+        y: y7,
         fill,
         stroke
     }));
 }
 
-function linearRegressionF(I, X3, Y3) {
+function linearRegressionF2(I, X4, Y4) {
     let sumX = 0,
         sumY = 0,
         sumXY = 0,
         sumX2 = 0;
     for (const i of I) {
-        const xi = X3[i];
-        const yi = Y3[i];
+        const xi = X4[i];
+        const yi = Y4[i];
         sumX += xi;
         sumY += yi;
         sumXY += xi * yi;
         sumX2 += xi * xi;
     }
     const n = I.length;
     const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
     const intercept = (sumY - slope * sumX) / n;
-    return (x4) => slope * x4 + intercept;
+    return (x7) => slope * x7 + intercept;
 }
 
-function confidenceIntervalF(I, X3, Y3, p, f) {
-    const mean2 = sum(I, (i) => X3[i]) / I.length;
-    let a4 = 0,
+function confidenceIntervalF2(I, X4, Y4, p, f) {
+    const mean3 = sum4(I, (i) => X4[i]) / I.length;
+    let a7 = 0,
         b = 0;
     for (const i of I) {
-        a4 += (X3[i] - mean2) ** 2;
-        b += (Y3[i] - f(X3[i])) ** 2;
+        a7 += (X4[i] - mean3) ** 2;
+        b += (Y4[i] - f(X4[i])) ** 2;
     }
     const sy = Math.sqrt(b / (I.length - 2));
-    const t = qt(p, I.length - 2);
-    return (x4, k2) => {
-        const Y4 = f(x4);
-        const se = sy * Math.sqrt(1 / I.length + (x4 - mean2) ** 2 / a4);
-        return Y4 + k2 * t * se;
+    const t = qt2(p, I.length - 2);
+    return (x7, k3) => {
+        const Y5 = f(x7);
+        const se = sy * Math.sqrt(1 / I.length + (x7 - mean3) ** 2 / a7);
+        return Y5 + k3 * t * se;
     };
 }
 
-// node_modules/@observablehq/plot/src/transforms/tree.js
-function treeNode(options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/tree.js
+function treeNode2(options = {}) {
     let {
-        path: path2 = identity6,
+        path: path3 = identity13,
         // the delimited path
         delimiter,
         // how the path is separated
         frameAnchor,
-        treeLayout = tree_default,
+        treeLayout = tree_default2,
         treeSort,
         treeSeparation,
         treeAnchor,
         ...remainingOptions
     } = options;
-    treeAnchor = maybeTreeAnchor(treeAnchor);
-    treeSort = maybeTreeSort(treeSort);
+    treeAnchor = maybeTreeAnchor2(treeAnchor);
+    treeSort = maybeTreeSort2(treeSort);
     if (frameAnchor === void 0)
         frameAnchor = treeAnchor.frameAnchor;
-    const normalize4 = normalizer(delimiter);
-    const outputs = treeOutputs(remainingOptions, maybeNodeValue);
-    const [X3, setX] = column();
-    const [Y3, setY] = column();
+    const normalize7 = normalizer2(delimiter);
+    const outputs = treeOutputs2(remainingOptions, maybeNodeValue2);
+    const [X4, setX] = column2();
+    const [Y4, setY] = column2();
     return {
-        x: X3,
-        y: Y3,
+        x: X4,
+        y: Y4,
         frameAnchor,
-        ...basic(remainingOptions, (data, facets) => {
-            const P = normalize4(valueof(data, path2));
-            const X4 = setX([]);
-            const Y4 = setY([]);
+        ...basic2(remainingOptions, (data, facets) => {
+            const P = normalize7(valueof2(data, path3));
+            const X5 = setX([]);
+            const Y5 = setY([]);
             let treeIndex = -1;
             const treeData = [];
             const treeFacets = [];
-            const rootof = stratify_default().path((i) => P[i]);
+            const rootof = stratify_default2().path((i) => P[i]);
             const layout = treeLayout();
             if (layout.nodeSize)
                 layout.nodeSize([1, 1]);
             if (layout.separation && treeSeparation !== void 0)
-                layout.separation(treeSeparation ?? one2);
+                layout.separation(treeSeparation ?? one4);
             for (const o of outputs)
-                o[output_values] = o[output_setValues]([]);
+                o[output_values2] = o[output_setValues2]([]);
             for (const facet of facets) {
                 const treeFacet = [];
-                const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
+                const root5 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
                 if (treeSort != null)
-                    root3.sort(treeSort);
-                layout(root3);
-                for (const node of root3.descendants()) {
+                    root5.sort(treeSort);
+                layout(root5);
+                for (const node of root5.descendants()) {
                     treeFacet.push(++treeIndex);
                     treeData[treeIndex] = node.data;
-                    treeAnchor.position(node, treeIndex, X4, Y4);
+                    treeAnchor.position(node, treeIndex, X5, Y5);
                     for (const o of outputs)
-                        o[output_values][treeIndex] = o[output_evaluate](node);
+                        o[output_values2][treeIndex] = o[output_evaluate2](node);
                 }
                 treeFacets.push(treeFacet);
             }
             return {
                 data: treeData,
                 facets: treeFacets
             };
         }),
         ...Object.fromEntries(outputs)
     };
 }
 
-function treeLink(options = {}) {
+function treeLink2(options = {}) {
     let {
-        path: path2 = identity6,
+        path: path3 = identity13,
         // the delimited path
         delimiter,
         // how the path is separated
         curve = "bump-x",
         stroke = "#555",
         strokeWidth = 1.5,
         strokeOpacity = 0.5,
-        treeLayout = tree_default,
+        treeLayout = tree_default2,
         treeSort,
         treeSeparation,
         treeAnchor,
         ...remainingOptions
     } = options;
-    treeAnchor = maybeTreeAnchor(treeAnchor);
-    treeSort = maybeTreeSort(treeSort);
+    treeAnchor = maybeTreeAnchor2(treeAnchor);
+    treeSort = maybeTreeSort2(treeSort);
     remainingOptions = {
         curve,
         stroke,
         strokeWidth,
         strokeOpacity,
         ...remainingOptions
     };
-    const normalize4 = normalizer(delimiter);
-    const outputs = treeOutputs(remainingOptions, maybeLinkValue);
-    const [X13, setX1] = column();
-    const [X23, setX2] = column();
-    const [Y13, setY1] = column();
-    const [Y23, setY2] = column();
-    return {
-        x1: X13,
-        x2: X23,
-        y1: Y13,
-        y2: Y23,
-        ...basic(remainingOptions, (data, facets) => {
-            const P = normalize4(valueof(data, path2));
-            const X14 = setX1([]);
-            const X24 = setX2([]);
-            const Y14 = setY1([]);
-            const Y24 = setY2([]);
+    const normalize7 = normalizer2(delimiter);
+    const outputs = treeOutputs2(remainingOptions, maybeLinkValue2);
+    const [X15, setX1] = column2();
+    const [X25, setX2] = column2();
+    const [Y15, setY1] = column2();
+    const [Y25, setY2] = column2();
+    return {
+        x1: X15,
+        x2: X25,
+        y1: Y15,
+        y2: Y25,
+        ...basic2(remainingOptions, (data, facets) => {
+            const P = normalize7(valueof2(data, path3));
+            const X16 = setX1([]);
+            const X26 = setX2([]);
+            const Y16 = setY1([]);
+            const Y26 = setY2([]);
             let treeIndex = -1;
             const treeData = [];
             const treeFacets = [];
-            const rootof = stratify_default().path((i) => P[i]);
+            const rootof = stratify_default2().path((i) => P[i]);
             const layout = treeLayout();
             if (layout.nodeSize)
                 layout.nodeSize([1, 1]);
             if (layout.separation && treeSeparation !== void 0)
-                layout.separation(treeSeparation ?? one2);
+                layout.separation(treeSeparation ?? one4);
             for (const o of outputs)
-                o[output_values] = o[output_setValues]([]);
+                o[output_values2] = o[output_setValues2]([]);
             for (const facet of facets) {
                 const treeFacet = [];
-                const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
+                const root5 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
                 if (treeSort != null)
-                    root3.sort(treeSort);
-                layout(root3);
+                    root5.sort(treeSort);
+                layout(root5);
                 for (const {
                         source,
                         target
                     }
-                    of root3.links()) {
+                    of root5.links()) {
                     treeFacet.push(++treeIndex);
                     treeData[treeIndex] = target.data;
-                    treeAnchor.position(source, treeIndex, X14, Y14);
-                    treeAnchor.position(target, treeIndex, X24, Y24);
+                    treeAnchor.position(source, treeIndex, X16, Y16);
+                    treeAnchor.position(target, treeIndex, X26, Y26);
                     for (const o of outputs)
-                        o[output_values][treeIndex] = o[output_evaluate](target, source);
+                        o[output_values2][treeIndex] = o[output_evaluate2](target, source);
                 }
                 treeFacets.push(treeFacet);
             }
             return {
                 data: treeData,
                 facets: treeFacets
             };
         }),
         ...Object.fromEntries(outputs)
     };
 }
 
-function maybeTreeAnchor(anchor = "left") {
+function maybeTreeAnchor2(anchor = "left") {
     switch (`${anchor}`.trim().toLowerCase()) {
         case "left":
-            return treeAnchorLeft;
+            return treeAnchorLeft2;
         case "right":
-            return treeAnchorRight;
+            return treeAnchorRight2;
     }
     throw new Error(`invalid tree anchor: ${anchor}`);
 }
-var treeAnchorLeft = {
+var treeAnchorLeft2 = {
     frameAnchor: "left",
     dx: 6,
     position({
-        x: x4,
-        y: y4
-    }, i, X3, Y3) {
-        X3[i] = y4;
-        Y3[i] = -x4;
+        x: x7,
+        y: y7
+    }, i, X4, Y4) {
+        X4[i] = y7;
+        Y4[i] = -x7;
     }
 };
-var treeAnchorRight = {
+var treeAnchorRight2 = {
     frameAnchor: "right",
     dx: -6,
     position({
-        x: x4,
-        y: y4
-    }, i, X3, Y3) {
-        X3[i] = -y4;
-        Y3[i] = -x4;
+        x: x7,
+        y: y7
+    }, i, X4, Y4) {
+        X4[i] = -y7;
+        Y4[i] = -x7;
     }
 };
 
-function maybeTreeSort(sort3) {
-    return sort3 == null || typeof sort3 === "function" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));
+function maybeTreeSort2(sort5) {
+    return sort5 == null || typeof sort5 === "function" ? sort5 : `${sort5}`.trim().toLowerCase().startsWith("node:") ? nodeSort2(maybeNodeValue2(sort5)) : nodeSort2(nodeData2(sort5));
 }
 
-function nodeSort(value) {
-    return (a4, b) => ascendingDefined2(value(a4), value(b));
+function nodeSort2(value) {
+    return (a7, b) => ascendingDefined4(value(a7), value(b));
 }
 
-function nodeData(field2) {
-    return (node) => node.data?.[field2];
+function nodeData2(field3) {
+    return (node) => node.data?.[field3];
 }
 
-function normalizer(delimiter = "/") {
-    return `${delimiter}` === "/" ? (P) => P : (P) => P.map(replaceAll(delimiter, "/"));
+function normalizer2(delimiter = "/") {
+    return `${delimiter}` === "/" ? (P) => P : (P) => P.map(replaceAll2(delimiter, "/"));
 }
 
-function replaceAll(search, replace) {
-    search = new RegExp(regexEscape(search), "g");
+function replaceAll2(search, replace) {
+    search = new RegExp(regexEscape2(search), "g");
     return (value) => value == null ? null : `${value}`.replace(search, replace);
 }
 
-function regexEscape(string2) {
-    return `${string2}`.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
+function regexEscape2(string3) {
+    return `${string3}`.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
 }
 
-function isNodeValue(option) {
-    return isObject(option) && typeof option.node === "function";
+function isNodeValue2(option) {
+    return isObject2(option) && typeof option.node === "function";
 }
 
-function isLinkValue(option) {
-    return isObject(option) && typeof option.link === "function";
+function isLinkValue2(option) {
+    return isObject2(option) && typeof option.link === "function";
 }
 
-function maybeNodeValue(value) {
-    if (isNodeValue(value))
+function maybeNodeValue2(value) {
+    if (isNodeValue2(value))
         return value.node;
     value = `${value}`.trim().toLowerCase();
     if (!value.startsWith("node:"))
         return;
     switch (value) {
         case "node:name":
-            return nodeName;
+            return nodeName2;
         case "node:path":
-            return nodePath;
+            return nodePath2;
         case "node:internal":
-            return nodeInternal;
+            return nodeInternal2;
         case "node:depth":
-            return nodeDepth;
+            return nodeDepth2;
         case "node:height":
-            return nodeHeight;
+            return nodeHeight2;
     }
     throw new Error(`invalid node value: ${value}`);
 }
 
-function maybeLinkValue(value) {
-    if (isNodeValue(value))
+function maybeLinkValue2(value) {
+    if (isNodeValue2(value))
         return value.node;
-    if (isLinkValue(value))
+    if (isLinkValue2(value))
         return value.link;
     value = `${value}`.trim().toLowerCase();
     if (!value.startsWith("node:") && !value.startsWith("parent:"))
         return;
     switch (value) {
         case "parent:name":
-            return parentValue(nodeName);
+            return parentValue2(nodeName2);
         case "parent:path":
-            return parentValue(nodePath);
+            return parentValue2(nodePath2);
         case "parent:depth":
-            return parentValue(nodeDepth);
+            return parentValue2(nodeDepth2);
         case "parent:height":
-            return parentValue(nodeHeight);
+            return parentValue2(nodeHeight2);
         case "node:name":
-            return nodeName;
+            return nodeName2;
         case "node:path":
-            return nodePath;
+            return nodePath2;
         case "node:internal":
-            return nodeInternal;
+            return nodeInternal2;
         case "node:depth":
-            return nodeDepth;
+            return nodeDepth2;
         case "node:height":
-            return nodeHeight;
+            return nodeHeight2;
     }
     throw new Error(`invalid link value: ${value}`);
 }
 
-function nodePath(node) {
+function nodePath2(node) {
     return node.id;
 }
 
-function nodeName(node) {
-    return nameof(node.id);
+function nodeName2(node) {
+    return nameof2(node.id);
 }
 
-function nodeDepth(node) {
+function nodeDepth2(node) {
     return node.depth;
 }
 
-function nodeHeight(node) {
+function nodeHeight2(node) {
     return node.height;
 }
 
-function nodeInternal(node) {
+function nodeInternal2(node) {
     return !!node.children;
 }
 
-function parentValue(evaluate) {
+function parentValue2(evaluate) {
     return (child, parent) => parent == null ? void 0 : evaluate(parent);
 }
 
-function nameof(path2) {
-    let i = path2.length;
+function nameof2(path3) {
+    let i = path3.length;
     while (--i > 0)
-        if (slash2(path2, i))
+        if (slash4(path3, i))
             break;
-    return path2.slice(i + 1);
+    return path3.slice(i + 1);
 }
 
-function slash2(path2, i) {
-    if (path2[i] === "/") {
-        let k2 = 0;
-        while (i > 0 && path2[--i] === "\\")
-            ++k2;
-        if ((k2 & 1) === 0)
+function slash4(path3, i) {
+    if (path3[i] === "/") {
+        let k3 = 0;
+        while (i > 0 && path3[--i] === "\\")
+            ++k3;
+        if ((k3 & 1) === 0)
             return true;
     }
     return false;
 }
-var output_setValues = 2;
-var output_evaluate = 3;
-var output_values = 4;
+var output_setValues2 = 2;
+var output_evaluate2 = 3;
+var output_values2 = 4;
 
-function treeOutputs(options, maybeTreeValue) {
+function treeOutputs2(options, maybeTreeValue) {
     const outputs = [];
     for (const name in options) {
         const value = options[name];
         const treeValue = maybeTreeValue(value);
         if (treeValue !== void 0) {
-            outputs.push([name, ...column(value), treeValue]);
+            outputs.push([name, ...column2(value), treeValue]);
         }
     }
     return outputs;
 }
 
-// node_modules/@observablehq/plot/src/marks/tree.js
-function tree(data, options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/marks/tree.js
+function tree2(data, options = {}) {
     let {
         fill,
         stroke,
         strokeWidth,
         strokeOpacity,
         strokeLinejoin,
         strokeLinecap,
         strokeMiterlimit,
         strokeDasharray,
         strokeDashoffset,
         marker,
         markerStart = marker,
         markerEnd = marker,
-        dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd),
+        dot: dotDot = isNoneish2(markerStart) && isNoneish2(markerEnd),
         text: textText = "node:name",
         textStroke = "white",
         title = "node:path",
         dx,
         dy,
         ...remainingOptions
     } = options;
     if (dx === void 0)
-        dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;
-    return marks(
-        link3(
+        dx = maybeTreeAnchor2(remainingOptions.treeAnchor).dx;
+    return marks2(
+        link6(
             data,
-            treeLink({
+            treeLink2({
                 markerStart,
                 markerEnd,
                 stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
                 strokeWidth,
                 strokeOpacity,
                 strokeLinejoin,
                 strokeLinecap,
                 strokeMiterlimit,
                 strokeDasharray,
                 strokeDashoffset,
                 ...remainingOptions
             })
         ),
-        dotDot ? dot(data, treeNode({
+        dotDot ? dot2(data, treeNode2({
             fill: fill === void 0 ? "node:internal" : fill,
             title,
             ...remainingOptions
         })) : null,
-        textText != null ? text(
+        textText != null ? text2(
             data,
-            treeNode({
+            treeNode2({
                 text: textText,
                 fill: fill === void 0 ? "currentColor" : fill,
                 stroke: textStroke,
                 dx,
                 dy,
                 title,
                 ...remainingOptions
             })
         ) : null
     );
 }
 
-function cluster(data, options) {
-    return tree(data, {
+function cluster2(data, options) {
+    return tree2(data, {
         ...options,
-        treeLayout: cluster_default
+        treeLayout: cluster_default2
     });
 }
 
-// node_modules/@observablehq/plot/src/transforms/centroid.js
-function centroid({
-    geometry = identity6,
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/centroid.js
+function centroid2({
+    geometry = identity13,
     ...options
 } = {}) {
-    return initializer({
+    return initializer2({
         ...options,
         x: null,
         y: null
     }, (data, facets, channels, scales, dimensions, {
-        projection: projection2
+        projection: projection3
     }) => {
-        const G = valueof(data, geometry);
+        const G = valueof2(data, geometry);
         const n = G.length;
-        const X3 = new Float64Array(n);
-        const Y3 = new Float64Array(n);
-        const path2 = path_default(projection2);
+        const X4 = new Float64Array(n);
+        const Y4 = new Float64Array(n);
+        const path3 = path_default3(projection3);
         for (let i = 0; i < n; ++i)
-            [X3[i], Y3[i]] = path2.centroid(G[i]);
+            [X4[i], Y4[i]] = path3.centroid(G[i]);
         return {
             data,
             facets,
             channels: {
                 x: {
-                    value: X3
+                    value: X4
                 },
                 y: {
-                    value: Y3
+                    value: Y4
                 }
             }
         };
     });
 }
 
-function geoCentroid({
-    geometry = identity6,
+function geoCentroid2({
+    geometry = identity13,
     ...options
 } = {}) {
-    let C3;
+    let C4;
     return {
         ...options,
         x: {
-            transform: (data) => Float64Array.from(C3 = valueof(valueof(data, geometry), centroid_default), ([x4]) => x4)
+            transform: (data) => Float64Array.from(C4 = valueof2(valueof2(data, geometry), centroid_default4), ([x7]) => x7)
         },
         y: {
-            transform: () => Float64Array.from(C3, ([, y4]) => y4)
+            transform: () => Float64Array.from(C4, ([, y7]) => y7)
         }
     };
 }
 
-// node_modules/@observablehq/plot/src/transforms/dodge.js
-var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
-var anchorXLeft = ({
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/dodge.js
+var import_interval_tree_1d2 = __toESM(require_interval_tree2(), 1);
+var anchorXLeft2 = ({
     marginLeft
 }) => [1, marginLeft];
-var anchorXRight = ({
+var anchorXRight2 = ({
     width,
     marginRight
 }) => [-1, width - marginRight];
-var anchorXMiddle = ({
+var anchorXMiddle2 = ({
     width,
     marginLeft,
     marginRight
 }) => [0, (marginLeft + width - marginRight) / 2];
-var anchorYTop = ({
+var anchorYTop2 = ({
     marginTop
 }) => [1, marginTop];
-var anchorYBottom = ({
+var anchorYBottom2 = ({
     height,
     marginBottom
 }) => [-1, height - marginBottom];
-var anchorYMiddle = ({
+var anchorYMiddle2 = ({
     height,
     marginTop,
     marginBottom
 }) => [0, (marginTop + height - marginBottom) / 2];
 
-function maybeAnchor2(anchor) {
+function maybeAnchor5(anchor) {
     return typeof anchor === "string" ? {
         anchor
     } : anchor;
 }
 
-function dodgeX(dodgeOptions = {}, options = {}) {
+function dodgeX2(dodgeOptions = {}, options = {}) {
     if (arguments.length === 1)
-        [dodgeOptions, options] = mergeOptions3(dodgeOptions);
+        [dodgeOptions, options] = mergeOptions6(dodgeOptions);
     let {
         anchor = "left", padding = 1
-    } = maybeAnchor2(dodgeOptions);
+    } = maybeAnchor5(dodgeOptions);
     switch (`${anchor}`.toLowerCase()) {
         case "left":
-            anchor = anchorXLeft;
+            anchor = anchorXLeft2;
             break;
         case "right":
-            anchor = anchorXRight;
+            anchor = anchorXRight2;
             break;
         case "middle":
-            anchor = anchorXMiddle;
+            anchor = anchorXMiddle2;
             break;
         default:
             throw new Error(`unknown dodge anchor: ${anchor}`);
     }
-    return dodge("x", "y", anchor, number5(padding), options);
+    return dodge2("x", "y", anchor, number11(padding), options);
 }
 
-function dodgeY(dodgeOptions = {}, options = {}) {
+function dodgeY2(dodgeOptions = {}, options = {}) {
     if (arguments.length === 1)
-        [dodgeOptions, options] = mergeOptions3(dodgeOptions);
+        [dodgeOptions, options] = mergeOptions6(dodgeOptions);
     let {
         anchor = "bottom", padding = 1
-    } = maybeAnchor2(dodgeOptions);
+    } = maybeAnchor5(dodgeOptions);
     switch (`${anchor}`.toLowerCase()) {
         case "top":
-            anchor = anchorYTop;
+            anchor = anchorYTop2;
             break;
         case "bottom":
-            anchor = anchorYBottom;
+            anchor = anchorYBottom2;
             break;
         case "middle":
-            anchor = anchorYMiddle;
+            anchor = anchorYMiddle2;
             break;
         default:
             throw new Error(`unknown dodge anchor: ${anchor}`);
     }
-    return dodge("y", "x", anchor, number5(padding), options);
+    return dodge2("y", "x", anchor, number11(padding), options);
 }
 
-function mergeOptions3(options) {
+function mergeOptions6(options) {
     const {
         anchor,
         padding,
         ...rest
     } = options;
     return [{
         anchor,
         padding
     }, rest];
 }
 
-function dodge(y4, x4, anchor, padding, options) {
+function dodge2(y7, x7, anchor, padding, options) {
     const {
         r
     } = options;
     if (r != null && typeof r !== "number") {
         const {
             channels,
-            sort: sort3,
-            reverse: reverse3
+            sort: sort5,
+            reverse: reverse5
         } = options;
         options = {
             ...options,
             channels: {
                 r: {
                     value: r,
                     scale: "r"
                 },
-                ...maybeNamed(channels)
+                ...maybeNamed2(channels)
             }
         };
-        if (sort3 === void 0 && reverse3 === void 0)
+        if (sort5 === void 0 && reverse5 === void 0)
             options.sort = {
                 channel: "r",
                 order: "descending"
             };
     }
-    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
+    return initializer2(options, function(data, facets, channels, scales, dimensions, context) {
         let {
-            [x4]: X3, r: R
+            [x7]: X4, r: R
         } = channels;
-        if (!channels[x4])
-            throw new Error(`missing channel: ${x4}`);
+        if (!channels[x7])
+            throw new Error(`missing channel: ${x7}`);
         ({
-            [x4]: X3
-        } = applyPosition(channels, scales, context));
-        const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number5(options.r) : 3;
+            [x7]: X4
+        } = applyPosition2(channels, scales, context));
+        const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number11(options.r) : 3;
         if (R)
-            R = valueof(R.value, scales[R.scale] || identity6, Float64Array);
-        let [ky2, ty] = anchor(dimensions);
-        const compare = ky2 ? compareAscending : compareSymmetric;
-        const Y3 = new Float64Array(X3.length);
-        const radius2 = R ? (i) => R[i] : () => r2;
+            R = valueof2(R.value, scales[R.scale] || identity13, Float64Array);
+        let [ky3, ty] = anchor(dimensions);
+        const compare = ky3 ? compareAscending2 : compareSymmetric2;
+        const Y4 = new Float64Array(X4.length);
+        const radius3 = R ? (i) => R[i] : () => r2;
         for (let I of facets) {
-            const tree2 = (0, import_interval_tree_1d.default)();
-            I = I.filter(R ? (i) => finite2(X3[i]) && positive(R[i]) : (i) => finite2(X3[i]));
+            const tree3 = (0, import_interval_tree_1d2.default)();
+            I = I.filter(R ? (i) => finite5(X4[i]) && positive2(R[i]) : (i) => finite5(X4[i]));
             const intervals = new Float64Array(2 * I.length + 2);
             for (const i of I) {
-                const ri = radius2(i);
-                const y06 = ky2 ? ri + padding : 0;
-                const l = X3[i] - ri;
-                const h = X3[i] + ri;
-                let k2 = 2;
-                tree2.queryInterval(l - padding, h + padding, ([, , j]) => {
-                    const yj = Y3[j] - y06;
-                    const dx = X3[i] - X3[j];
+                const ri = radius3(i);
+                const y011 = ky3 ? ri + padding : 0;
+                const l = X4[i] - ri;
+                const h = X4[i] + ri;
+                let k3 = 2;
+                tree3.queryInterval(l - padding, h + padding, ([, , j]) => {
+                    const yj = Y4[j] - y011;
+                    const dx = X4[i] - X4[j];
                     const dr = padding + (R ? R[i] + R[j] : 2 * r2);
                     const dy = Math.sqrt(dr * dr - dx * dx);
-                    intervals[k2++] = yj - dy;
-                    intervals[k2++] = yj + dy;
+                    intervals[k3++] = yj - dy;
+                    intervals[k3++] = yj + dy;
                 });
-                let candidates = intervals.slice(0, k2);
-                if (ky2)
-                    candidates = candidates.filter((y5) => y5 >= 0);
+                let candidates = intervals.slice(0, k3);
+                if (ky3)
+                    candidates = candidates.filter((y8) => y8 >= 0);
                 out:
-                    for (const y5 of candidates.sort(compare)) {
-                        for (let j = 0; j < k2; j += 2) {
-                            if (intervals[j] + 1e-6 < y5 && y5 < intervals[j + 1] - 1e-6) {
+                    for (const y8 of candidates.sort(compare)) {
+                        for (let j = 0; j < k3; j += 2) {
+                            if (intervals[j] + 1e-6 < y8 && y8 < intervals[j + 1] - 1e-6) {
                                 continue out;
                             }
                         }
-                        Y3[i] = y5 + y06;
+                        Y4[i] = y8 + y011;
                         break;
                     }
-                tree2.insert([l, h, i]);
+                tree3.insert([l, h, i]);
             }
         }
-        if (!ky2)
-            ky2 = 1;
+        if (!ky3)
+            ky3 = 1;
         for (const I of facets) {
             for (const i of I) {
-                Y3[i] = Y3[i] * ky2 + ty;
+                Y4[i] = Y4[i] * ky3 + ty;
             }
         }
         return {
             data,
             facets,
             channels: {
-                [x4]: {
-                    value: X3
+                [x7]: {
+                    value: X4
                 },
-                [y4]: {
-                    value: Y3
+                [y7]: {
+                    value: Y4
                 },
                 ...R && {
                     r: {
                         value: R
                     }
                 }
             }
         };
     });
 }
 
-function compareSymmetric(a4, b) {
-    return Math.abs(a4) - Math.abs(b);
+function compareSymmetric2(a7, b) {
+    return Math.abs(a7) - Math.abs(b);
 }
 
-function compareAscending(a4, b) {
-    return a4 - b;
+function compareAscending2(a7, b) {
+    return a7 - b;
 }
 
-// node_modules/@observablehq/plot/src/transforms/normalize.js
-function normalizeX(basis2, options) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/normalize.js
+function normalizeX2(basis3, options) {
     if (arguments.length === 1)
         ({
-            basis: basis2,
+            basis: basis3,
             ...options
-        } = basis2);
-    return mapX(normalize3(basis2), options);
+        } = basis3);
+    return mapX2(normalize6(basis3), options);
 }
 
-function normalizeY(basis2, options) {
+function normalizeY2(basis3, options) {
     if (arguments.length === 1)
         ({
-            basis: basis2,
+            basis: basis3,
             ...options
-        } = basis2);
-    return mapY(normalize3(basis2), options);
+        } = basis3);
+    return mapY2(normalize6(basis3), options);
 }
 
-function normalize3(basis2) {
-    if (basis2 === void 0)
-        return normalizeFirst;
-    if (typeof basis2 === "function")
-        return normalizeBasis((I, S) => basis2(take(S, I)));
-    if (/^p\d{2}$/i.test(basis2))
-        return normalizeAccessor(percentile(basis2));
-    switch (`${basis2}`.toLowerCase()) {
+function normalize6(basis3) {
+    if (basis3 === void 0)
+        return normalizeFirst2;
+    if (typeof basis3 === "function")
+        return normalizeBasis2((I, S) => basis3(take2(S, I)));
+    if (/^p\d{2}$/i.test(basis3))
+        return normalizeAccessor2(percentile2(basis3));
+    switch (`${basis3}`.toLowerCase()) {
         case "deviation":
-            return normalizeDeviation;
+            return normalizeDeviation2;
         case "first":
-            return normalizeFirst;
+            return normalizeFirst2;
         case "last":
-            return normalizeLast;
+            return normalizeLast2;
         case "max":
-            return normalizeMax;
+            return normalizeMax2;
         case "mean":
-            return normalizeMean;
+            return normalizeMean2;
         case "median":
-            return normalizeMedian;
+            return normalizeMedian2;
         case "min":
-            return normalizeMin;
+            return normalizeMin2;
         case "sum":
-            return normalizeSum;
+            return normalizeSum2;
         case "extent":
-            return normalizeExtent;
+            return normalizeExtent2;
     }
-    throw new Error(`invalid basis: ${basis2}`);
+    throw new Error(`invalid basis: ${basis3}`);
 }
 
-function normalizeBasis(basis2) {
+function normalizeBasis2(basis3) {
     return {
         mapIndex(I, S, T) {
-            const b = +basis2(I, S);
+            const b = +basis3(I, S);
             for (const i of I) {
                 T[i] = S[i] === null ? NaN : S[i] / b;
             }
         }
     };
 }
 
-function normalizeAccessor(f) {
-    return normalizeBasis((I, S) => f(I, (i) => S[i]));
+function normalizeAccessor2(f) {
+    return normalizeBasis2((I, S) => f(I, (i) => S[i]));
 }
-var normalizeExtent = {
+var normalizeExtent2 = {
     mapIndex(I, S, T) {
-        const [s1, s2] = extent(I, (i) => S[i]);
-        const d = s2 - s1;
+        const [s1, s22] = extent3(I, (i) => S[i]);
+        const d = s22 - s1;
         for (const i of I) {
             T[i] = S[i] === null ? NaN : (S[i] - s1) / d;
         }
     }
 };
-var normalizeFirst = normalizeBasis((I, S) => {
+var normalizeFirst2 = normalizeBasis2((I, S) => {
     for (let i = 0; i < I.length; ++i) {
-        const s2 = S[I[i]];
-        if (defined(s2))
-            return s2;
+        const s3 = S[I[i]];
+        if (defined2(s3))
+            return s3;
     }
 });
-var normalizeLast = normalizeBasis((I, S) => {
+var normalizeLast2 = normalizeBasis2((I, S) => {
     for (let i = I.length - 1; i >= 0; --i) {
-        const s2 = S[I[i]];
-        if (defined(s2))
-            return s2;
+        const s3 = S[I[i]];
+        if (defined2(s3))
+            return s3;
     }
 });
-var normalizeDeviation = {
+var normalizeDeviation2 = {
     mapIndex(I, S, T) {
-        const m3 = mean(I, (i) => S[i]);
-        const d = deviation(I, (i) => S[i]);
+        const m5 = mean2(I, (i) => S[i]);
+        const d = deviation2(I, (i) => S[i]);
         for (const i of I) {
-            T[i] = S[i] === null ? NaN : d ? (S[i] - m3) / d : 0;
+            T[i] = S[i] === null ? NaN : d ? (S[i] - m5) / d : 0;
         }
     }
 };
-var normalizeMax = normalizeAccessor(max);
-var normalizeMean = normalizeAccessor(mean);
-var normalizeMedian = normalizeAccessor(median);
-var normalizeMin = normalizeAccessor(min);
-var normalizeSum = normalizeAccessor(sum);
+var normalizeMax2 = normalizeAccessor2(max5);
+var normalizeMean2 = normalizeAccessor2(mean2);
+var normalizeMedian2 = normalizeAccessor2(median2);
+var normalizeMin2 = normalizeAccessor2(min4);
+var normalizeSum2 = normalizeAccessor2(sum4);
 
-// node_modules/@observablehq/plot/src/transforms/window.js
-function windowX(windowOptions = {}, options) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/window.js
+function windowX2(windowOptions = {}, options) {
     if (arguments.length === 1)
         options = windowOptions;
-    return mapX(window2(windowOptions), options);
+    return mapX2(window3(windowOptions), options);
 }
 
-function windowY(windowOptions = {}, options) {
+function windowY2(windowOptions = {}, options) {
     if (arguments.length === 1)
         options = windowOptions;
-    return mapY(window2(windowOptions), options);
+    return mapY2(window3(windowOptions), options);
 }
 
-function window2(options = {}) {
+function window3(options = {}) {
     if (typeof options === "number")
         options = {
             k: options
         };
     let {
-        k: k2,
-        reduce: reduce2,
+        k: k3,
+        reduce: reduce3,
         shift,
         anchor,
         strict
     } = options;
     if (anchor === void 0 && shift !== void 0) {
-        anchor = maybeShift(shift);
-        warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
+        anchor = maybeShift2(shift);
+        warn2(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
     }
-    if (!((k2 = Math.floor(k2)) > 0))
-        throw new Error(`invalid k: ${k2}`);
-    return maybeReduce2(reduce2)(k2, maybeAnchor3(anchor, k2), strict);
+    if (!((k3 = Math.floor(k3)) > 0))
+        throw new Error(`invalid k: ${k3}`);
+    return maybeReduce4(reduce3)(k3, maybeAnchor6(anchor, k3), strict);
 }
 
-function maybeAnchor3(anchor = "middle", k2) {
+function maybeAnchor6(anchor = "middle", k3) {
     switch (`${anchor}`.toLowerCase()) {
         case "middle":
-            return k2 - 1 >> 1;
+            return k3 - 1 >> 1;
         case "start":
             return 0;
         case "end":
-            return k2 - 1;
+            return k3 - 1;
     }
     throw new Error(`invalid anchor: ${anchor}`);
 }
 
-function maybeShift(shift) {
+function maybeShift2(shift) {
     switch (`${shift}`.toLowerCase()) {
         case "centered":
             return "middle";
         case "leading":
             return "start";
         case "trailing":
             return "end";
     }
     throw new Error(`invalid shift: ${shift}`);
 }
 
-function maybeReduce2(reduce2 = "mean") {
-    if (typeof reduce2 === "string") {
-        if (/^p\d{2}$/i.test(reduce2))
-            return reduceNumbers(percentile(reduce2));
-        switch (reduce2.toLowerCase()) {
+function maybeReduce4(reduce3 = "mean") {
+    if (typeof reduce3 === "string") {
+        if (/^p\d{2}$/i.test(reduce3))
+            return reduceNumbers2(percentile2(reduce3));
+        switch (reduce3.toLowerCase()) {
             case "deviation":
-                return reduceNumbers(deviation);
+                return reduceNumbers2(deviation2);
             case "max":
-                return reduceArray(max);
+                return reduceArray2(max5);
             case "mean":
-                return reduceMean;
+                return reduceMean2;
             case "median":
-                return reduceNumbers(median);
+                return reduceNumbers2(median2);
             case "min":
-                return reduceArray(min);
+                return reduceArray2(min4);
             case "mode":
-                return reduceArray(mode);
+                return reduceArray2(mode2);
             case "sum":
-                return reduceSum2;
+                return reduceSum4;
             case "variance":
-                return reduceNumbers(variance);
+                return reduceNumbers2(variance2);
             case "difference":
-                return reduceDifference;
+                return reduceDifference2;
             case "ratio":
-                return reduceRatio;
+                return reduceRatio2;
             case "first":
-                return reduceFirst2;
+                return reduceFirst4;
             case "last":
-                return reduceLast2;
+                return reduceLast4;
         }
     }
-    if (typeof reduce2 !== "function")
-        throw new Error(`invalid reduce: ${reduce2}`);
-    return reduceArray(reduce2);
+    if (typeof reduce3 !== "function")
+        throw new Error(`invalid reduce: ${reduce3}`);
+    return reduceArray2(reduce3);
 }
 
-function slice6(I, i, j) {
+function slice12(I, i, j) {
     return I.subarray ? I.subarray(i, j) : I.slice(i, j);
 }
 
-function reduceNumbers(f) {
-    return (k2, s2, strict) => strict ? {
+function reduceNumbers2(f) {
+    return (k3, s3, strict) => strict ? {
         mapIndex(I, S, T) {
-            const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
+            const C4 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
             let nans = 0;
-            for (let i = 0; i < k2 - 1; ++i)
-                if (isNaN(C3[i]))
+            for (let i = 0; i < k3 - 1; ++i)
+                if (isNaN(C4[i]))
                     ++nans;
-            for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {
-                if (isNaN(C3[i + k2 - 1]))
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                if (isNaN(C4[i + k3 - 1]))
                     ++nans;
-                T[I[i + s2]] = nans === 0 ? f(C3.subarray(i, i + k2)) : NaN;
-                if (isNaN(C3[i]))
+                T[I[i + s3]] = nans === 0 ? f(C4.subarray(i, i + k3)) : NaN;
+                if (isNaN(C4[i]))
                     --nans;
             }
         }
     } : {
         mapIndex(I, S, T) {
-            const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
-            for (let i = -s2; i < 0; ++i) {
-                T[I[i + s2]] = f(C3.subarray(0, i + k2));
+            const C4 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
+            for (let i = -s3; i < 0; ++i) {
+                T[I[i + s3]] = f(C4.subarray(0, i + k3));
             }
-            for (let i = 0, n = I.length - s2; i < n; ++i) {
-                T[I[i + s2]] = f(C3.subarray(i, i + k2));
+            for (let i = 0, n = I.length - s3; i < n; ++i) {
+                T[I[i + s3]] = f(C4.subarray(i, i + k3));
             }
         }
     };
 }
 
-function reduceArray(f) {
-    return (k2, s2, strict) => strict ? {
+function reduceArray2(f) {
+    return (k3, s3, strict) => strict ? {
         mapIndex(I, S, T) {
-            let count3 = 0;
-            for (let i = 0; i < k2 - 1; ++i)
-                count3 += defined(S[I[i]]);
-            for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {
-                count3 += defined(S[I[i + k2 - 1]]);
-                if (count3 === k2)
-                    T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));
-                count3 -= defined(S[I[i]]);
+            let count5 = 0;
+            for (let i = 0; i < k3 - 1; ++i)
+                count5 += defined2(S[I[i]]);
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                count5 += defined2(S[I[i + k3 - 1]]);
+                if (count5 === k3)
+                    T[I[i + s3]] = f(take2(S, slice12(I, i, i + k3)));
+                count5 -= defined2(S[I[i]]);
             }
         }
     } : {
         mapIndex(I, S, T) {
-            for (let i = -s2; i < 0; ++i) {
-                T[I[i + s2]] = f(take(S, slice6(I, 0, i + k2)));
+            for (let i = -s3; i < 0; ++i) {
+                T[I[i + s3]] = f(take2(S, slice12(I, 0, i + k3)));
             }
-            for (let i = 0, n = I.length - s2; i < n; ++i) {
-                T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));
+            for (let i = 0, n = I.length - s3; i < n; ++i) {
+                T[I[i + s3]] = f(take2(S, slice12(I, i, i + k3)));
             }
         }
     };
 }
 
-function reduceSum2(k2, s2, strict) {
+function reduceSum4(k3, s3, strict) {
     return strict ? {
         mapIndex(I, S, T) {
             let nans = 0;
-            let sum5 = 0;
-            for (let i = 0; i < k2 - 1; ++i) {
-                const v2 = S[I[i]];
-                if (v2 === null || isNaN(v2))
+            let sum8 = 0;
+            for (let i = 0; i < k3 - 1; ++i) {
+                const v3 = S[I[i]];
+                if (v3 === null || isNaN(v3))
                     ++nans;
                 else
-                    sum5 += +v2;
+                    sum8 += +v3;
             }
-            for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {
-                const a4 = S[I[i]];
-                const b = S[I[i + k2 - 1]];
+            for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
                 if (b === null || isNaN(b))
                     ++nans;
                 else
-                    sum5 += +b;
-                T[I[i + s2]] = nans === 0 ? sum5 : NaN;
-                if (a4 === null || isNaN(a4))
+                    sum8 += +b;
+                T[I[i + s3]] = nans === 0 ? sum8 : NaN;
+                if (a7 === null || isNaN(a7))
                     --nans;
                 else
-                    sum5 -= +a4;
+                    sum8 -= +a7;
             }
         }
     } : {
         mapIndex(I, S, T) {
-            let sum5 = 0;
+            let sum8 = 0;
             const n = I.length;
-            for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {
-                sum5 += +S[I[i]] || 0;
+            for (let i = 0, j = Math.min(n, k3 - s3 - 1); i < j; ++i) {
+                sum8 += +S[I[i]] || 0;
             }
-            for (let i = -s2, j = n - s2; i < j; ++i) {
-                sum5 += +S[I[i + k2 - 1]] || 0;
-                T[I[i + s2]] = sum5;
-                sum5 -= +S[I[i]] || 0;
+            for (let i = -s3, j = n - s3; i < j; ++i) {
+                sum8 += +S[I[i + k3 - 1]] || 0;
+                T[I[i + s3]] = sum8;
+                sum8 -= +S[I[i]] || 0;
             }
         }
     };
 }
 
-function reduceMean(k2, s2, strict) {
+function reduceMean2(k3, s3, strict) {
     if (strict) {
-        const sum5 = reduceSum2(k2, s2, strict);
+        const sum8 = reduceSum4(k3, s3, strict);
         return {
             mapIndex(I, S, T) {
-                sum5.mapIndex(I, S, T);
-                for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {
-                    T[I[i + s2]] /= k2;
+                sum8.mapIndex(I, S, T);
+                for (let i = 0, n = I.length - k3 + 1; i < n; ++i) {
+                    T[I[i + s3]] /= k3;
                 }
             }
         };
     } else {
         return {
             mapIndex(I, S, T) {
-                let sum5 = 0;
-                let count3 = 0;
+                let sum8 = 0;
+                let count5 = 0;
                 const n = I.length;
-                for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {
-                    let v2 = S[I[i]];
-                    if (v2 !== null && !isNaN(v2 = +v2))
-                        sum5 += v2, ++count3;
+                for (let i = 0, j = Math.min(n, k3 - s3 - 1); i < j; ++i) {
+                    let v3 = S[I[i]];
+                    if (v3 !== null && !isNaN(v3 = +v3))
+                        sum8 += v3, ++count5;
                 }
-                for (let i = -s2, j = n - s2; i < j; ++i) {
-                    let a4 = S[I[i + k2 - 1]];
+                for (let i = -s3, j = n - s3; i < j; ++i) {
+                    let a7 = S[I[i + k3 - 1]];
                     let b = S[I[i]];
-                    if (a4 !== null && !isNaN(a4 = +a4))
-                        sum5 += a4, ++count3;
-                    T[I[i + s2]] = sum5 / count3;
+                    if (a7 !== null && !isNaN(a7 = +a7))
+                        sum8 += a7, ++count5;
+                    T[I[i + s3]] = sum8 / count5;
                     if (b !== null && !isNaN(b = +b))
-                        sum5 -= b, --count3;
+                        sum8 -= b, --count5;
                 }
             }
         };
     }
 }
 
-function firstDefined(S, I, i, k2) {
-    for (let j = i + k2; i < j; ++i) {
-        const v2 = S[I[i]];
-        if (defined(v2))
-            return v2;
+function firstDefined2(S, I, i, k3) {
+    for (let j = i + k3; i < j; ++i) {
+        const v3 = S[I[i]];
+        if (defined2(v3))
+            return v3;
     }
 }
 
-function lastDefined(S, I, i, k2) {
-    for (let j = i + k2 - 1; j >= i; --j) {
-        const v2 = S[I[j]];
-        if (defined(v2))
-            return v2;
+function lastDefined2(S, I, i, k3) {
+    for (let j = i + k3 - 1; j >= i; --j) {
+        const v3 = S[I[j]];
+        if (defined2(v3))
+            return v3;
     }
 }
 
-function firstNumber(S, I, i, k2) {
-    for (let j = i + k2; i < j; ++i) {
-        let v2 = S[I[i]];
-        if (v2 !== null && !isNaN(v2 = +v2))
-            return v2;
+function firstNumber2(S, I, i, k3) {
+    for (let j = i + k3; i < j; ++i) {
+        let v3 = S[I[i]];
+        if (v3 !== null && !isNaN(v3 = +v3))
+            return v3;
     }
 }
 
-function lastNumber(S, I, i, k2) {
-    for (let j = i + k2 - 1; j >= i; --j) {
-        let v2 = S[I[j]];
-        if (v2 !== null && !isNaN(v2 = +v2))
-            return v2;
+function lastNumber2(S, I, i, k3) {
+    for (let j = i + k3 - 1; j >= i; --j) {
+        let v3 = S[I[j]];
+        if (v3 !== null && !isNaN(v3 = +v3))
+            return v3;
     }
 }
 
-function reduceDifference(k2, s2, strict) {
+function reduceDifference2(k3, s3, strict) {
     return strict ? {
         mapIndex(I, S, T) {
-            for (let i = 0, n = I.length - k2; i < n; ++i) {
-                const a4 = S[I[i]];
-                const b = S[I[i + k2 - 1]];
-                T[I[i + s2]] = a4 === null || b === null ? NaN : b - a4;
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
+                T[I[i + s3]] = a7 === null || b === null ? NaN : b - a7;
             }
         }
     } : {
         mapIndex(I, S, T) {
-            for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {
-                T[I[i + s2]] = lastNumber(S, I, i, k2) - firstNumber(S, I, i, k2);
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastNumber2(S, I, i, k3) - firstNumber2(S, I, i, k3);
             }
         }
     };
 }
 
-function reduceRatio(k2, s2, strict) {
+function reduceRatio2(k3, s3, strict) {
     return strict ? {
         mapIndex(I, S, T) {
-            for (let i = 0, n = I.length - k2; i < n; ++i) {
-                const a4 = S[I[i]];
-                const b = S[I[i + k2 - 1]];
-                T[I[i + s2]] = a4 === null || b === null ? NaN : b / a4;
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                const a7 = S[I[i]];
+                const b = S[I[i + k3 - 1]];
+                T[I[i + s3]] = a7 === null || b === null ? NaN : b / a7;
             }
         }
     } : {
         mapIndex(I, S, T) {
-            for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {
-                T[I[i + s2]] = lastNumber(S, I, i, k2) / firstNumber(S, I, i, k2);
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastNumber2(S, I, i, k3) / firstNumber2(S, I, i, k3);
             }
         }
     };
 }
 
-function reduceFirst2(k2, s2, strict) {
+function reduceFirst4(k3, s3, strict) {
     return strict ? {
         mapIndex(I, S, T) {
-            for (let i = 0, n = I.length - k2; i < n; ++i) {
-                T[I[i + s2]] = S[I[i]];
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                T[I[i + s3]] = S[I[i]];
             }
         }
     } : {
         mapIndex(I, S, T) {
-            for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {
-                T[I[i + s2]] = firstDefined(S, I, i, k2);
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = firstDefined2(S, I, i, k3);
             }
         }
     };
 }
 
-function reduceLast2(k2, s2, strict) {
+function reduceLast4(k3, s3, strict) {
     return strict ? {
         mapIndex(I, S, T) {
-            for (let i = 0, n = I.length - k2; i < n; ++i) {
-                T[I[i + s2]] = S[I[i + k2 - 1]];
+            for (let i = 0, n = I.length - k3; i < n; ++i) {
+                T[I[i + s3]] = S[I[i + k3 - 1]];
             }
         }
     } : {
         mapIndex(I, S, T) {
-            for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {
-                T[I[i + s2]] = lastDefined(S, I, i, k2);
+            for (let i = -s3, n = I.length - k3 + s3 + 1; i < n; ++i) {
+                T[I[i + s3]] = lastDefined2(S, I, i, k3);
             }
         }
     };
 }
 
-// node_modules/@observablehq/plot/src/transforms/select.js
-function select(selector, options = {}) {
+// js/pyobsplot-js/node_modules/@observablehq/plot/src/transforms/select.js
+function select2(selector, options = {}) {
     if (typeof selector === "string") {
         switch (selector.toLowerCase()) {
             case "first":
-                return selectFirst(options);
+                return selectFirst2(options);
             case "last":
-                return selectLast(options);
+                return selectLast2(options);
         }
     }
     if (typeof selector === "function") {
-        return selectChannel(null, selector, options);
+        return selectChannel2(null, selector, options);
     }
     let key, value;
     for (key in selector) {
         if (value !== void 0)
             throw new Error("ambiguous selector; multiple inputs");
-        value = maybeSelector(selector[key]);
+        value = maybeSelector2(selector[key]);
     }
     if (value === void 0)
         throw new Error(`invalid selector: ${selector}`);
-    return selectChannel(key, value, options);
+    return selectChannel2(key, value, options);
 }
 
-function maybeSelector(selector) {
+function maybeSelector2(selector) {
     if (typeof selector === "function")
         return selector;
     switch (`${selector}`.toLowerCase()) {
         case "min":
-            return selectorMin;
+            return selectorMin2;
         case "max":
-            return selectorMax;
+            return selectorMax2;
     }
     throw new Error(`unknown selector: ${selector}`);
 }
 
-function selectFirst(options) {
-    return selectChannel(null, selectorFirst, options);
+function selectFirst2(options) {
+    return selectChannel2(null, selectorFirst2, options);
 }
 
-function selectLast(options) {
-    return selectChannel(null, selectorLast, options);
+function selectLast2(options) {
+    return selectChannel2(null, selectorLast2, options);
 }
 
-function selectMinX(options) {
-    return selectChannel("x", selectorMin, options);
+function selectMinX2(options) {
+    return selectChannel2("x", selectorMin2, options);
 }
 
-function selectMinY(options) {
-    return selectChannel("y", selectorMin, options);
+function selectMinY2(options) {
+    return selectChannel2("y", selectorMin2, options);
 }
 
-function selectMaxX(options) {
-    return selectChannel("x", selectorMax, options);
+function selectMaxX2(options) {
+    return selectChannel2("x", selectorMax2, options);
 }
 
-function selectMaxY(options) {
-    return selectChannel("y", selectorMax, options);
+function selectMaxY2(options) {
+    return selectChannel2("y", selectorMax2, options);
 }
 
-function* selectorFirst(I) {
+function* selectorFirst2(I) {
     yield I[0];
 }
 
-function* selectorLast(I) {
+function* selectorLast2(I) {
     yield I[I.length - 1];
 }
 
-function* selectorMin(I, X3) {
-    yield least(I, (i) => X3[i]);
+function* selectorMin2(I, X4) {
+    yield least2(I, (i) => X4[i]);
 }
 
-function* selectorMax(I, X3) {
-    yield greatest(I, (i) => X3[i]);
+function* selectorMax2(I, X4) {
+    yield greatest2(I, (i) => X4[i]);
 }
 
-function selectChannel(v2, selector, options) {
-    if (v2 != null) {
-        if (options[v2] == null)
-            throw new Error(`missing channel: ${v2}`);
-        v2 = options[v2];
+function selectChannel2(v3, selector, options) {
+    if (v3 != null) {
+        if (options[v3] == null)
+            throw new Error(`missing channel: ${v3}`);
+        v3 = options[v3];
     }
-    const z = maybeZ(options);
-    return basic(options, (data, facets) => {
-        const Z = valueof(data, z);
-        const V = valueof(data, v2);
+    const z = maybeZ2(options);
+    return basic2(options, (data, facets) => {
+        const Z = valueof2(data, z);
+        const V = valueof2(data, v3);
         const selectFacets = [];
         for (const facet of facets) {
             const selectFacet = [];
-            for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
+            for (const I of Z ? group3(facet, (i) => Z[i]).values() : [facet]) {
                 for (const i of selector(I, V)) {
                     selectFacet.push(i);
                 }
             }
             selectFacets.push(selectFacet);
         }
         return {
             data,
             facets: selectFacets
         };
     });
 }
 
-// node_modules/tslib/tslib.es6.js
-function __rest(s2, e) {
+// js/pyobsplot-js/node_modules/tslib/tslib.es6.js
+function __rest(s3, e) {
     var t = {};
-    for (var p in s2)
-        if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
-            t[p] = s2[p];
-    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
-            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
-                t[p[i]] = s2[p[i]];
+    for (var p in s3)
+        if (Object.prototype.hasOwnProperty.call(s3, p) && e.indexOf(p) < 0)
+            t[p] = s3[p];
+    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
+        for (var i = 0, p = Object.getOwnPropertySymbols(s3); i < p.length; i++) {
+            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i]))
+                t[p[i]] = s3[p[i]];
         }
     return t;
 }
 
 function __awaiter(thisArg, _arguments, P, generator) {
     function adopt(value) {
         return value instanceof P ? value : new P(function(resolve) {
@@ -34772,58 +69478,58 @@
             result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
         }
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 }
 
 function __values(o) {
-    var s2 = typeof Symbol === "function" && Symbol.iterator,
-        m3 = s2 && o[s2],
+    var s3 = typeof Symbol === "function" && Symbol.iterator,
+        m5 = s3 && o[s3],
         i = 0;
-    if (m3)
-        return m3.call(o);
+    if (m5)
+        return m5.call(o);
     if (o && typeof o.length === "number")
         return {
             next: function() {
                 if (o && i >= o.length)
                     o = void 0;
                 return {
                     value: o && o[i++],
                     done: !o
                 };
             }
         };
-    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
+    throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
 }
 
-function __await(v2) {
-    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
+function __await(v3) {
+    return this instanceof __await ? (this.v = v3, this) : new __await(v3);
 }
 
 function __asyncGenerator(thisArg, _arguments, generator) {
     if (!Symbol.asyncIterator)
         throw new TypeError("Symbol.asyncIterator is not defined.");
     var g = generator.apply(thisArg, _arguments || []),
         i, q = [];
     return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
         return this;
     }, i;
 
     function verb(n) {
         if (g[n])
-            i[n] = function(v2) {
-                return new Promise(function(a4, b) {
-                    q.push([n, v2, a4, b]) > 1 || resume(n, v2);
+            i[n] = function(v3) {
+                return new Promise(function(a7, b) {
+                    q.push([n, v3, a7, b]) > 1 || resume(n, v3);
                 });
             };
     }
 
-    function resume(n, v2) {
+    function resume(n, v3) {
         try {
-            step(g[n](v2));
+            step(g[n](v3));
         } catch (e) {
             settle(q[0][3], e);
         }
     }
 
     function step(r) {
         r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
@@ -34833,66 +69539,66 @@
         resume("next", value);
     }
 
     function reject(value) {
         resume("throw", value);
     }
 
-    function settle(f, v2) {
-        if (f(v2), q.shift(), q.length)
+    function settle(f, v3) {
+        if (f(v3), q.shift(), q.length)
             resume(q[0][0], q[0][1]);
     }
 }
 
 function __asyncDelegator(o) {
     var i, p;
     return i = {}, verb("next"), verb("throw", function(e) {
         throw e;
     }), verb("return"), i[Symbol.iterator] = function() {
         return this;
     }, i;
 
     function verb(n, f) {
-        i[n] = o[n] ? function(v2) {
+        i[n] = o[n] ? function(v3) {
             return (p = !p) ? {
-                value: __await(o[n](v2)),
+                value: __await(o[n](v3)),
                 done: false
-            } : f ? f(v2) : v2;
+            } : f ? f(v3) : v3;
         } : f;
     }
 }
 
 function __asyncValues(o) {
     if (!Symbol.asyncIterator)
         throw new TypeError("Symbol.asyncIterator is not defined.");
-    var m3 = o[Symbol.asyncIterator],
+    var m5 = o[Symbol.asyncIterator],
         i;
-    return m3 ? m3.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
+    return m5 ? m5.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
         return this;
     }, i);
 
     function verb(n) {
-        i[n] = o[n] && function(v2) {
+        i[n] = o[n] && function(v3) {
             return new Promise(function(resolve, reject) {
-                v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
+                v3 = o[n](v3), settle(resolve, reject, v3.done, v3.value);
             });
         };
     }
 
-    function settle(resolve, reject, d, v2) {
-        Promise.resolve(v2).then(function(v3) {
+    function settle(resolve, reject, d, v3) {
+        Promise.resolve(v3).then(function(v4) {
             resolve({
-                value: v3,
+                value: v4,
                 done: d
             });
         }, reject);
     }
 }
 
-// node_modules/apache-arrow/util/buffer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/buffer.mjs
 var buffer_exports = {};
 __export(buffer_exports, {
     compareArrayLike: () => compareArrayLike,
     joinUint8Arrays: () => joinUint8Arrays,
     memcpy: () => memcpy,
     rebaseValueOffsets: () => rebaseValueOffsets,
     toArrayBufferView: () => toArrayBufferView,
@@ -34925,21 +69631,21 @@
     toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
     toUint8ArrayIterator: () => toUint8ArrayIterator,
     toUint8ClampedArray: () => toUint8ClampedArray,
     toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
     toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
 });
 
-// node_modules/apache-arrow/util/utf8.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/utf8.mjs
 var decoder = new TextDecoder("utf-8");
 var decodeUtf8 = (buffer) => decoder.decode(buffer);
 var encoder = new TextEncoder();
 var encodeUtf8 = (value) => encoder.encode(value);
 
-// node_modules/apache-arrow/util/compat.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/compat.mjs
 var [BigIntCtor, BigIntAvailable] = (() => {
     const BigIntUnavailableError = () => {
         throw new Error("BigInt is not available in this environment");
     };
 
     function BigIntUnavailable() {
         throw BigIntUnavailableError();
@@ -34988,117 +69694,117 @@
         }
         constructor() {
             throw BigUint64ArrayUnavailableError();
         }
     }
     return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
 })();
-var isNumber = (x4) => typeof x4 === "number";
-var isBoolean = (x4) => typeof x4 === "boolean";
-var isFunction = (x4) => typeof x4 === "function";
-var isObject2 = (x4) => x4 != null && Object(x4) === x4;
-var isPromise = (x4) => {
-    return isObject2(x4) && isFunction(x4.then);
+var isNumber = (x7) => typeof x7 === "number";
+var isBoolean = (x7) => typeof x7 === "boolean";
+var isFunction = (x7) => typeof x7 === "function";
+var isObject3 = (x7) => x7 != null && Object(x7) === x7;
+var isPromise = (x7) => {
+    return isObject3(x7) && isFunction(x7.then);
 };
-var isIterable2 = (x4) => {
-    return isObject2(x4) && isFunction(x4[Symbol.iterator]);
+var isIterable3 = (x7) => {
+    return isObject3(x7) && isFunction(x7[Symbol.iterator]);
 };
-var isAsyncIterable = (x4) => {
-    return isObject2(x4) && isFunction(x4[Symbol.asyncIterator]);
+var isAsyncIterable = (x7) => {
+    return isObject3(x7) && isFunction(x7[Symbol.asyncIterator]);
 };
-var isArrowJSON = (x4) => {
-    return isObject2(x4) && isObject2(x4["schema"]);
+var isArrowJSON = (x7) => {
+    return isObject3(x7) && isObject3(x7["schema"]);
 };
-var isIteratorResult = (x4) => {
-    return isObject2(x4) && "done" in x4 && "value" in x4;
+var isIteratorResult = (x7) => {
+    return isObject3(x7) && "done" in x7 && "value" in x7;
 };
-var isFileHandle = (x4) => {
-    return isObject2(x4) && isFunction(x4["stat"]) && isNumber(x4["fd"]);
+var isFileHandle = (x7) => {
+    return isObject3(x7) && isFunction(x7["stat"]) && isNumber(x7["fd"]);
 };
-var isFetchResponse = (x4) => {
-    return isObject2(x4) && isReadableDOMStream(x4["body"]);
+var isFetchResponse = (x7) => {
+    return isObject3(x7) && isReadableDOMStream(x7["body"]);
 };
-var isReadableInterop = (x4) => "_getDOMStream" in x4 && "_getNodeStream" in x4;
-var isWritableDOMStream = (x4) => {
-    return isObject2(x4) && isFunction(x4["abort"]) && isFunction(x4["getWriter"]) && !isReadableInterop(x4);
+var isReadableInterop = (x7) => "_getDOMStream" in x7 && "_getNodeStream" in x7;
+var isWritableDOMStream = (x7) => {
+    return isObject3(x7) && isFunction(x7["abort"]) && isFunction(x7["getWriter"]) && !isReadableInterop(x7);
 };
-var isReadableDOMStream = (x4) => {
-    return isObject2(x4) && isFunction(x4["cancel"]) && isFunction(x4["getReader"]) && !isReadableInterop(x4);
+var isReadableDOMStream = (x7) => {
+    return isObject3(x7) && isFunction(x7["cancel"]) && isFunction(x7["getReader"]) && !isReadableInterop(x7);
 };
-var isWritableNodeStream = (x4) => {
-    return isObject2(x4) && isFunction(x4["end"]) && isFunction(x4["write"]) && isBoolean(x4["writable"]) && !isReadableInterop(x4);
+var isWritableNodeStream = (x7) => {
+    return isObject3(x7) && isFunction(x7["end"]) && isFunction(x7["write"]) && isBoolean(x7["writable"]) && !isReadableInterop(x7);
 };
-var isReadableNodeStream = (x4) => {
-    return isObject2(x4) && isFunction(x4["read"]) && isFunction(x4["pipe"]) && isBoolean(x4["readable"]) && !isReadableInterop(x4);
+var isReadableNodeStream = (x7) => {
+    return isObject3(x7) && isFunction(x7["read"]) && isFunction(x7["pipe"]) && isBoolean(x7["readable"]) && !isReadableInterop(x7);
 };
-var isFlatbuffersByteBuffer = (x4) => {
-    return isObject2(x4) && isFunction(x4["clear"]) && isFunction(x4["bytes"]) && isFunction(x4["position"]) && isFunction(x4["setPosition"]) && isFunction(x4["capacity"]) && isFunction(x4["getBufferIdentifier"]) && isFunction(x4["createLong"]);
+var isFlatbuffersByteBuffer = (x7) => {
+    return isObject3(x7) && isFunction(x7["clear"]) && isFunction(x7["bytes"]) && isFunction(x7["position"]) && isFunction(x7["setPosition"]) && isFunction(x7["capacity"]) && isFunction(x7["getBufferIdentifier"]) && isFunction(x7["createLong"]);
 };
 
-// node_modules/apache-arrow/util/buffer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/buffer.mjs
 var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
 
 function collapseContiguousByteRanges(chunks) {
     const result = chunks[0] ? [chunks[0]] : [];
     let xOffset, yOffset, xLen, yLen;
-    for (let x4, y4, i = 0, j = 0, n = chunks.length; ++i < n;) {
-        x4 = result[j];
-        y4 = chunks[i];
-        if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {
-            y4 && (result[++j] = y4);
+    for (let x7, y7, i = 0, j = 0, n = chunks.length; ++i < n;) {
+        x7 = result[j];
+        y7 = chunks[i];
+        if (!x7 || !y7 || x7.buffer !== y7.buffer || y7.byteOffset < x7.byteOffset) {
+            y7 && (result[++j] = y7);
             continue;
         }
         ({
             byteOffset: xOffset,
             byteLength: xLen
-        } = x4);
+        } = x7);
         ({
             byteOffset: yOffset,
             byteLength: yLen
-        } = y4);
+        } = y7);
         if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
-            y4 && (result[++j] = y4);
+            y7 && (result[++j] = y7);
             continue;
         }
-        result[j] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);
+        result[j] = new Uint8Array(x7.buffer, xOffset, yOffset - xOffset + yLen);
     }
     return result;
 }
 
 function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
     const targetByteLength = target.byteLength;
     const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
     const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
     dst.set(src, targetByteOffset);
     return target;
 }
 
 function joinUint8Arrays(chunks, size) {
     const result = collapseContiguousByteRanges(chunks);
-    const byteLength = result.reduce((x4, b) => x4 + b.byteLength, 0);
+    const byteLength = result.reduce((x7, b) => x7 + b.byteLength, 0);
     let source, sliced, buffer;
-    let offset2 = 0,
-        index3 = -1;
-    const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
-    for (const n = result.length; ++index3 < n;) {
-        source = result[index3];
-        sliced = source.subarray(0, Math.min(source.length, length4 - offset2));
-        if (length4 <= offset2 + sliced.length) {
+    let offset3 = 0,
+        index5 = -1;
+    const length7 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
+    for (const n = result.length; ++index5 < n;) {
+        source = result[index5];
+        sliced = source.subarray(0, Math.min(source.length, length7 - offset3));
+        if (length7 <= offset3 + sliced.length) {
             if (sliced.length < source.length) {
-                result[index3] = source.subarray(sliced.length);
+                result[index5] = source.subarray(sliced.length);
             } else if (sliced.length === source.length) {
-                index3++;
+                index5++;
             }
-            buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;
+            buffer ? memcpy(buffer, sliced, offset3) : buffer = sliced;
             break;
         }
-        memcpy(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);
-        offset2 += sliced.length;
+        memcpy(buffer || (buffer = new Uint8Array(length7)), sliced, offset3);
+        offset3 += sliced.length;
     }
-    return [buffer || new Uint8Array(0), result.slice(index3), byteLength - (buffer ? buffer.byteLength : 0)];
+    return [buffer || new Uint8Array(0), result.slice(index5), byteLength - (buffer ? buffer.byteLength : 0)];
 }
 
 function toArrayBufferView(ArrayBufferViewCtor, input) {
     let value = isIteratorResult(input) ? input.value : input;
     if (value instanceof ArrayBufferViewCtor) {
         if (ArrayBufferViewCtor === Uint8Array) {
             return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
@@ -35135,18 +69841,18 @@
 var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
 var pump = (iterator) => {
     iterator.next();
     return iterator;
 };
 
 function* toArrayBufferViewIterator(ArrayCtor, source) {
-    const wrap = function*(x4) {
-        yield x4;
+    const wrap = function*(x7) {
+        yield x7;
     };
-    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;
+    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable3(source) ? wrap(source) : source;
     yield* pump(function*(it) {
         let r = null;
         do {
             r = it.next(yield toArrayBufferView(ArrayCtor, r));
         } while (!r.done);
     }(buffers[Symbol.iterator]()));
     return new ArrayCtor();
@@ -35162,30 +69868,30 @@
 var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
 
 function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
     return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
         if (isPromise(source)) {
             return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
         }
-        const wrap = function(x4) {
+        const wrap = function(x7) {
             return __asyncGenerator(this, arguments, function*() {
-                yield yield __await(yield __await(x4));
+                yield yield __await(yield __await(x7));
             });
         };
         const emit = function(source2) {
             return __asyncGenerator(this, arguments, function*() {
                 yield __await(yield* __asyncDelegator(__asyncValues(pump(function*(it) {
                     let r = null;
                     do {
                         r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
                     } while (!r.done);
                 }(source2[Symbol.iterator]())))));
             });
         };
-        const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
+        const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable3(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
         yield __await(
             // otherwise if AsyncIterable, use it
             yield* __asyncDelegator(__asyncValues(pump(function(it) {
                 return __asyncGenerator(this, arguments, function*() {
                     let r = null;
                     do {
                         r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
@@ -35202,41 +69908,41 @@
 var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
 var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
 var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
 var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
 var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
 var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
 
-function rebaseValueOffsets(offset2, length4, valueOffsets) {
-    if (offset2 !== 0) {
-        valueOffsets = valueOffsets.slice(0, length4 + 1);
-        for (let i = -1; ++i <= length4;) {
-            valueOffsets[i] += offset2;
+function rebaseValueOffsets(offset3, length7, valueOffsets) {
+    if (offset3 !== 0) {
+        valueOffsets = valueOffsets.slice(0, length7 + 1);
+        for (let i = -1; ++i <= length7;) {
+            valueOffsets[i] += offset3;
         }
     }
     return valueOffsets;
 }
 
-function compareArrayLike(a4, b) {
+function compareArrayLike(a7, b) {
     let i = 0;
-    const n = a4.length;
+    const n = a7.length;
     if (n !== b.length) {
         return false;
     }
     if (n > 0) {
         do {
-            if (a4[i] !== b[i]) {
+            if (a7[i] !== b[i]) {
                 return false;
             }
         } while (++i < n);
     }
     return true;
 }
 
-// node_modules/apache-arrow/io/adapters.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/adapters.mjs
 var adapters_default = {
     fromIterable(source) {
         return pump2(fromIterable(source));
     },
     fromAsyncIterable(source) {
         return pump2(fromAsyncIterable(source));
     },
@@ -35471,15 +70177,15 @@
             return yield __await(null);
         }
         try {
             events[0] = onEvent(stream, "end");
             events[1] = onEvent(stream, "error");
             do {
                 events[2] = onEvent(stream, "readable");
-                [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));
+                [event, err] = yield __await(Promise.race(events.map((x7) => x7[2])));
                 if (event === "error") {
                     break;
                 }
                 if (!(done = event === "end")) {
                     if (!Number.isFinite(size - bufferLength)) {
                         buffer = toUint8Array(stream["read"]());
                     } else {
@@ -35523,15 +70229,15 @@
                     err2 != null ? reject(err2) : resolve();
                 }
             });
         }
     });
 }
 
-// node_modules/apache-arrow/enum.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/enum.mjs
 var MetadataVersion;
 (function(MetadataVersion3) {
     MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
     MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
     MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
     MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
     MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
@@ -35625,67 +70331,67 @@
 (function(BufferType2) {
     BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
     BufferType2[BufferType2["DATA"] = 1] = "DATA";
     BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
     BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
 })(BufferType || (BufferType = {}));
 
-// node_modules/apache-arrow/util/vector.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/vector.mjs
 var vector_exports = {};
 __export(vector_exports, {
     clampIndex: () => clampIndex,
     clampRange: () => clampRange,
     createElementComparator: () => createElementComparator
 });
 
-// node_modules/apache-arrow/util/pretty.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/pretty.mjs
 var undf = void 0;
 
-function valueToString(x4) {
-    if (x4 === null) {
+function valueToString(x7) {
+    if (x7 === null) {
         return "null";
     }
-    if (x4 === undf) {
+    if (x7 === undf) {
         return "undefined";
     }
-    switch (typeof x4) {
+    switch (typeof x7) {
         case "number":
-            return `${x4}`;
+            return `${x7}`;
         case "bigint":
-            return `${x4}`;
+            return `${x7}`;
         case "string":
-            return `"${x4}"`;
+            return `"${x7}"`;
     }
-    if (typeof x4[Symbol.toPrimitive] === "function") {
-        return x4[Symbol.toPrimitive]("string");
+    if (typeof x7[Symbol.toPrimitive] === "function") {
+        return x7[Symbol.toPrimitive]("string");
     }
-    if (ArrayBuffer.isView(x4)) {
-        if (x4 instanceof BigInt64ArrayCtor || x4 instanceof BigUint64ArrayCtor) {
-            return `[${[...x4].map((x5) => valueToString(x5))}]`;
+    if (ArrayBuffer.isView(x7)) {
+        if (x7 instanceof BigInt64ArrayCtor || x7 instanceof BigUint64ArrayCtor) {
+            return `[${[...x7].map((x8) => valueToString(x8))}]`;
         }
-        return `[${x4}]`;
+        return `[${x7}]`;
     }
-    return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_, y4) => typeof y4 === "bigint" ? `${y4}` : y4);
+    return ArrayBuffer.isView(x7) ? `[${x7}]` : JSON.stringify(x7, (_, y7) => typeof y7 === "bigint" ? `${y7}` : y7);
 }
 
-// node_modules/apache-arrow/util/bn.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/bn.mjs
 var bn_exports = {};
 __export(bn_exports, {
     BN: () => BN,
     bignumToBigInt: () => bignumToBigInt,
     bignumToString: () => bignumToString,
     isArrowBigNumSymbol: () => isArrowBigNumSymbol
 });
 var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
 
-function BigNum(x4, ...xs) {
+function BigNum(x7, ...xs) {
     if (xs.length === 0) {
-        return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x4), this.constructor.prototype);
+        return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x7), this.constructor.prototype);
     }
-    return Object.setPrototypeOf(new this["TypedArray"](x4, ...xs), this.constructor.prototype);
+    return Object.setPrototypeOf(new this["TypedArray"](x7, ...xs), this.constructor.prototype);
 }
 BigNum.prototype[isArrowBigNumSymbol] = true;
 BigNum.prototype.toJSON = function() {
     return `"${bignumToString(this)}"`;
 };
 BigNum.prototype.valueOf = function() {
     return bignumToNumber(this);
@@ -35738,47 +70444,47 @@
     "BigIntArray": BigUint64ArrayCtor
 });
 
 function bignumToNumber(bn) {
     const {
         buffer,
         byteOffset,
-        length: length4,
+        length: length7,
         "signed": signed
     } = bn;
-    const words = new BigUint64ArrayCtor(buffer, byteOffset, length4);
-    const negative2 = signed && words[words.length - 1] & BigInt(1) << BigInt(63);
-    let number7 = negative2 ? BigInt(1) : BigInt(0);
+    const words = new BigUint64ArrayCtor(buffer, byteOffset, length7);
+    const negative3 = signed && words[words.length - 1] & BigInt(1) << BigInt(63);
+    let number14 = negative3 ? BigInt(1) : BigInt(0);
     let i = BigInt(0);
-    if (!negative2) {
+    if (!negative3) {
         for (const word of words) {
-            number7 += word * (BigInt(1) << BigInt(32) * i++);
+            number14 += word * (BigInt(1) << BigInt(32) * i++);
         }
     } else {
         for (const word of words) {
-            number7 += ~word * (BigInt(1) << BigInt(32) * i++);
+            number14 += ~word * (BigInt(1) << BigInt(32) * i++);
         }
-        number7 *= BigInt(-1);
+        number14 *= BigInt(-1);
     }
-    return number7;
+    return number14;
 }
 var bignumToString;
 var bignumToBigInt;
 if (!BigIntAvailable) {
     bignumToString = decimalToString;
     bignumToBigInt = bignumToString;
 } else {
-    bignumToBigInt = (a4) => a4.byteLength === 8 ? new a4["BigIntArray"](a4.buffer, a4.byteOffset, 1)[0] : decimalToString(a4);
-    bignumToString = (a4) => a4.byteLength === 8 ? `${new a4["BigIntArray"](a4.buffer, a4.byteOffset, 1)[0]}` : decimalToString(a4);
+    bignumToBigInt = (a7) => a7.byteLength === 8 ? new a7["BigIntArray"](a7.buffer, a7.byteOffset, 1)[0] : decimalToString(a7);
+    bignumToString = (a7) => a7.byteLength === 8 ? `${new a7["BigIntArray"](a7.buffer, a7.byteOffset, 1)[0]}` : decimalToString(a7);
 }
 
-function decimalToString(a4) {
+function decimalToString(a7) {
     let digits = "";
     const base64 = new Uint32Array(2);
-    let base32 = new Uint16Array(a4.buffer, a4.byteOffset, a4.byteLength / 2);
+    let base32 = new Uint16Array(a7.buffer, a7.byteOffset, a7.byteLength / 2);
     const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
     let i = -1;
     const n = base32.length - 1;
     do {
         for (base64[0] = base32[i = 0]; i < n;) {
             base32[i++] = base64[1] = base64[0] / 10;
             base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
@@ -35823,15 +70529,15 @@
         return new DecimalBigNum(num);
     }
     constructor(num, isSigned) {
         return BN.new(num, isSigned);
     }
 };
 
-// node_modules/apache-arrow/type.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/type.mjs
 var _a;
 var _b;
 var _c;
 var _d;
 var _e;
 var _f;
 var _g;
@@ -35845,92 +70551,92 @@
 var _q;
 var _r;
 var _s;
 var _t;
 var _u;
 var DataType = class {
     /** @nocollapse */
-    static isNull(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Null;
+    static isNull(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Null;
     }
     /** @nocollapse */
-    static isInt(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Int;
+    static isInt(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Int;
     }
     /** @nocollapse */
-    static isFloat(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Float;
+    static isFloat(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Float;
     }
     /** @nocollapse */
-    static isBinary(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Binary;
+    static isBinary(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Binary;
     }
     /** @nocollapse */
-    static isUtf8(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Utf8;
+    static isUtf8(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Utf8;
     }
     /** @nocollapse */
-    static isBool(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Bool;
+    static isBool(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Bool;
     }
     /** @nocollapse */
-    static isDecimal(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Decimal;
+    static isDecimal(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Decimal;
     }
     /** @nocollapse */
-    static isDate(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Date;
+    static isDate(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Date;
     }
     /** @nocollapse */
-    static isTime(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Time;
+    static isTime(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Time;
     }
     /** @nocollapse */
-    static isTimestamp(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Timestamp;
+    static isTimestamp(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Timestamp;
     }
     /** @nocollapse */
-    static isInterval(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Interval;
+    static isInterval(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Interval;
     }
     /** @nocollapse */
-    static isList(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.List;
+    static isList(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.List;
     }
     /** @nocollapse */
-    static isStruct(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Struct;
+    static isStruct(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Struct;
     }
     /** @nocollapse */
-    static isUnion(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Union;
+    static isUnion(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Union;
     }
     /** @nocollapse */
-    static isFixedSizeBinary(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeBinary;
+    static isFixedSizeBinary(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.FixedSizeBinary;
     }
     /** @nocollapse */
-    static isFixedSizeList(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeList;
+    static isFixedSizeList(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.FixedSizeList;
     }
     /** @nocollapse */
-    static isMap(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Map;
+    static isMap(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Map;
     }
     /** @nocollapse */
-    static isDictionary(x4) {
-        return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Dictionary;
+    static isDictionary(x7) {
+        return (x7 === null || x7 === void 0 ? void 0 : x7.typeId) === Type.Dictionary;
     }
     /** @nocollapse */
-    static isDenseUnion(x4) {
-        return DataType.isUnion(x4) && x4.mode === UnionMode.Dense;
+    static isDenseUnion(x7) {
+        return DataType.isUnion(x7) && x7.mode === UnionMode.Dense;
     }
     /** @nocollapse */
-    static isSparseUnion(x4) {
-        return DataType.isUnion(x4) && x4.mode === UnionMode.Sparse;
+    static isSparseUnion(x7) {
+        return DataType.isUnion(x7) && x7.mode === UnionMode.Sparse;
     }
     get typeId() {
         return Type.NONE;
     }
 };
 _a = Symbol.toStringTag;
 DataType[_a] = ((proto) => {
@@ -36165,17 +70871,17 @@
 };
 _g = Symbol.toStringTag;
 Bool[_g] = ((proto) => {
     proto.ArrayType = Uint8Array;
     return proto[Symbol.toStringTag] = "Bool";
 })(Bool.prototype);
 var Decimal = class extends DataType {
-    constructor(scale3, precision, bitWidth = 128) {
+    constructor(scale5, precision, bitWidth = 128) {
         super();
-        this.scale = scale3;
+        this.scale = scale5;
         this.precision = precision;
         this.bitWidth = bitWidth;
     }
     get typeId() {
         return Type.Decimal;
     }
     toString() {
@@ -36186,17 +70892,17 @@
 Decimal[_h] = ((proto) => {
     proto.scale = null;
     proto.precision = null;
     proto.ArrayType = Uint32Array;
     return proto[Symbol.toStringTag] = "Decimal";
 })(Decimal.prototype);
 var Date_ = class extends DataType {
-    constructor(unit3) {
+    constructor(unit5) {
         super();
-        this.unit = unit3;
+        this.unit = unit5;
     }
     get typeId() {
         return Type.Date;
     }
     toString() {
         return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
     }
@@ -36204,17 +70910,17 @@
 _j = Symbol.toStringTag;
 Date_[_j] = ((proto) => {
     proto.unit = null;
     proto.ArrayType = Int32Array;
     return proto[Symbol.toStringTag] = "Date";
 })(Date_.prototype);
 var Time_ = class extends DataType {
-    constructor(unit3, bitWidth) {
+    constructor(unit5, bitWidth) {
         super();
-        this.unit = unit3;
+        this.unit = unit5;
         this.bitWidth = bitWidth;
     }
     get typeId() {
         return Type.Time;
     }
     toString() {
         return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
@@ -36232,17 +70938,17 @@
 _k = Symbol.toStringTag;
 Time_[_k] = ((proto) => {
     proto.unit = null;
     proto.bitWidth = null;
     return proto[Symbol.toStringTag] = "Time";
 })(Time_.prototype);
 var Timestamp_ = class extends DataType {
-    constructor(unit3, timezone) {
+    constructor(unit5, timezone) {
         super();
-        this.unit = unit3;
+        this.unit = unit5;
         this.timezone = timezone;
     }
     get typeId() {
         return Type.Timestamp;
     }
     toString() {
         return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
@@ -36252,17 +70958,17 @@
 Timestamp_[_l] = ((proto) => {
     proto.unit = null;
     proto.timezone = null;
     proto.ArrayType = Int32Array;
     return proto[Symbol.toStringTag] = "Timestamp";
 })(Timestamp_.prototype);
 var Interval_ = class extends DataType {
-    constructor(unit3) {
+    constructor(unit5) {
         super();
-        this.unit = unit3;
+        this.unit = unit5;
     }
     get typeId() {
         return Type.Interval;
     }
     toString() {
         return `Interval<${IntervalUnit[this.unit]}>`;
     }
@@ -36296,43 +71002,43 @@
 };
 _o = Symbol.toStringTag;
 List[_o] = ((proto) => {
     proto.children = null;
     return proto[Symbol.toStringTag] = "List";
 })(List.prototype);
 var Struct = class extends DataType {
-    constructor(children2) {
+    constructor(children3) {
         super();
-        this.children = children2;
+        this.children = children3;
     }
     get typeId() {
         return Type.Struct;
     }
     toString() {
         return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
     }
 };
 _p = Symbol.toStringTag;
 Struct[_p] = ((proto) => {
     proto.children = null;
     return proto[Symbol.toStringTag] = "Struct";
 })(Struct.prototype);
 var Union_ = class extends DataType {
-    constructor(mode2, typeIds, children2) {
+    constructor(mode3, typeIds, children3) {
         super();
-        this.mode = mode2;
-        this.children = children2;
+        this.mode = mode3;
+        this.children = children3;
         this.typeIds = typeIds = Int32Array.from(typeIds);
         this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
     }
     get typeId() {
         return Type.Union;
     }
     toString() {
-        return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;
+        return `${this[Symbol.toStringTag]}<${this.children.map((x7) => `${x7.type}`).join(` | `)}>`;
     }
 };
 _q = Symbol.toStringTag;
 Union_[_q] = ((proto) => {
     proto.mode = null;
     proto.typeIds = null;
     proto.children = null;
@@ -36412,20 +71118,20 @@
 Map_[_t] = ((proto) => {
     proto.children = null;
     proto.keysSorted = null;
     return proto[Symbol.toStringTag] = "Map_";
 })(Map_.prototype);
 var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
 var Dictionary = class extends DataType {
-    constructor(dictionary, indices, id2, isOrdered2) {
+    constructor(dictionary, indices, id3, isOrdered3) {
         super();
         this.indices = indices;
         this.dictionary = dictionary;
-        this.isOrdered = isOrdered2 || false;
-        this.id = id2 == null ? getId() : typeof id2 === "number" ? id2 : id2.low;
+        this.isOrdered = isOrdered3 || false;
+        this.id = id3 == null ? getId() : typeof id3 === "number" ? id3 : id3.low;
     }
     get typeId() {
         return Type.Dictionary;
     }
     get children() {
         return this.dictionary.children;
     }
@@ -36444,19 +71150,19 @@
     proto.id = null;
     proto.indices = null;
     proto.isOrdered = null;
     proto.dictionary = null;
     return proto[Symbol.toStringTag] = "Dictionary";
 })(Dictionary.prototype);
 
-function strideForType(type2) {
-    const t = type2;
-    switch (type2.typeId) {
+function strideForType(type3) {
+    const t = type3;
+    switch (type3.typeId) {
         case Type.Decimal:
-            return type2.bitWidth / 32;
+            return type3.bitWidth / 32;
         case Type.Timestamp:
             return 2;
         case Type.Date:
             return 1 + t.unit;
         case Type.Interval:
             return 1 + t.unit;
         case Type.FixedSizeList:
@@ -36464,18 +71170,18 @@
         case Type.FixedSizeBinary:
             return t.byteWidth;
         default:
             return 1;
     }
 }
 
-// node_modules/apache-arrow/visitor.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor.mjs
 var Visitor = class {
     visitMany(nodes, ...args) {
-        return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));
+        return nodes.map((node, i) => this.visit(node, ...args.map((x7) => x7[i])));
     }
     visit(...args) {
         return this.getVisitFn(args[0], false).apply(this, args);
     }
     getVisitFn(node, throwIfNotFound = true) {
         return getVisitFn(this, node, throwIfNotFound);
     }
@@ -36690,37 +71396,37 @@
     if (typeof fn === "function")
         return fn;
     if (!throwIfNotFound)
         return () => null;
     throw new Error(`Unrecognized type '${Type[dtype]}'`);
 }
 
-function inferDType(type2) {
-    switch (type2.typeId) {
+function inferDType(type3) {
+    switch (type3.typeId) {
         case Type.Null:
             return Type.Null;
         case Type.Int: {
             const {
                 bitWidth,
                 isSigned
-            } = type2;
+            } = type3;
             switch (bitWidth) {
                 case 8:
                     return isSigned ? Type.Int8 : Type.Uint8;
                 case 16:
                     return isSigned ? Type.Int16 : Type.Uint16;
                 case 32:
                     return isSigned ? Type.Int32 : Type.Uint32;
                 case 64:
                     return isSigned ? Type.Int64 : Type.Uint64;
             }
             return Type.Int;
         }
         case Type.Float:
-            switch (type2.precision) {
+            switch (type3.precision) {
                 case Precision.HALF:
                     return Type.Float16;
                 case Precision.SINGLE:
                     return Type.Float32;
                 case Precision.DOUBLE:
                     return Type.Float64;
             }
@@ -36730,75 +71436,75 @@
         case Type.Utf8:
             return Type.Utf8;
         case Type.Bool:
             return Type.Bool;
         case Type.Decimal:
             return Type.Decimal;
         case Type.Time:
-            switch (type2.unit) {
+            switch (type3.unit) {
                 case TimeUnit.SECOND:
                     return Type.TimeSecond;
                 case TimeUnit.MILLISECOND:
                     return Type.TimeMillisecond;
                 case TimeUnit.MICROSECOND:
                     return Type.TimeMicrosecond;
                 case TimeUnit.NANOSECOND:
                     return Type.TimeNanosecond;
             }
             return Type.Time;
         case Type.Timestamp:
-            switch (type2.unit) {
+            switch (type3.unit) {
                 case TimeUnit.SECOND:
                     return Type.TimestampSecond;
                 case TimeUnit.MILLISECOND:
                     return Type.TimestampMillisecond;
                 case TimeUnit.MICROSECOND:
                     return Type.TimestampMicrosecond;
                 case TimeUnit.NANOSECOND:
                     return Type.TimestampNanosecond;
             }
             return Type.Timestamp;
         case Type.Date:
-            switch (type2.unit) {
+            switch (type3.unit) {
                 case DateUnit.DAY:
                     return Type.DateDay;
                 case DateUnit.MILLISECOND:
                     return Type.DateMillisecond;
             }
             return Type.Date;
         case Type.Interval:
-            switch (type2.unit) {
+            switch (type3.unit) {
                 case IntervalUnit.DAY_TIME:
                     return Type.IntervalDayTime;
                 case IntervalUnit.YEAR_MONTH:
                     return Type.IntervalYearMonth;
             }
             return Type.Interval;
         case Type.Map:
             return Type.Map;
         case Type.List:
             return Type.List;
         case Type.Struct:
             return Type.Struct;
         case Type.Union:
-            switch (type2.mode) {
+            switch (type3.mode) {
                 case UnionMode.Dense:
                     return Type.DenseUnion;
                 case UnionMode.Sparse:
                     return Type.SparseUnion;
             }
             return Type.Union;
         case Type.FixedSizeBinary:
             return Type.FixedSizeBinary;
         case Type.FixedSizeList:
             return Type.FixedSizeList;
         case Type.Dictionary:
             return Type.Dictionary;
     }
-    throw new Error(`Unrecognized type '${Type[type2.typeId]}'`);
+    throw new Error(`Unrecognized type '${Type[type3.typeId]}'`);
 }
 Visitor.prototype.visitInt8 = null;
 Visitor.prototype.visitInt16 = null;
 Visitor.prototype.visitInt32 = null;
 Visitor.prototype.visitInt64 = null;
 Visitor.prototype.visitUint8 = null;
 Visitor.prototype.visitUint16 = null;
@@ -36818,42 +71524,42 @@
 Visitor.prototype.visitTimeMicrosecond = null;
 Visitor.prototype.visitTimeNanosecond = null;
 Visitor.prototype.visitDenseUnion = null;
 Visitor.prototype.visitSparseUnion = null;
 Visitor.prototype.visitIntervalDayTime = null;
 Visitor.prototype.visitIntervalYearMonth = null;
 
-// node_modules/apache-arrow/util/math.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/math.mjs
 var math_exports = {};
 __export(math_exports, {
     float64ToUint16: () => float64ToUint16,
     uint16ToFloat64: () => uint16ToFloat64
 });
 var f64 = new Float64Array(1);
 var u32 = new Uint32Array(f64.buffer);
 
 function uint16ToFloat64(h) {
     const expo = (h & 31744) >> 10;
     const sigf = (h & 1023) / 1024;
-    const sign3 = Math.pow(-1, (h & 32768) >> 15);
+    const sign5 = Math.pow(-1, (h & 32768) >> 15);
     switch (expo) {
         case 31:
-            return sign3 * (sigf ? Number.NaN : 1 / 0);
+            return sign5 * (sigf ? Number.NaN : 1 / 0);
         case 0:
-            return sign3 * (sigf ? 6103515625e-14 * sigf : 0);
+            return sign5 * (sigf ? 6103515625e-14 * sigf : 0);
     }
-    return sign3 * Math.pow(2, expo - 15) * (1 + sigf);
+    return sign5 * Math.pow(2, expo - 15) * (1 + sigf);
 }
 
 function float64ToUint16(d) {
     if (d !== d) {
         return 32256;
     }
     f64[0] = d;
-    const sign3 = (u32[1] & 2147483648) >> 16 & 65535;
+    const sign5 = (u32[1] & 2147483648) >> 16 & 65535;
     let expo = u32[1] & 2146435072,
         sigf = 0;
     if (expo >= 1089470464) {
         if (u32[0] > 0) {
             expo = 31744;
         } else {
             expo = (expo & 2080374784) >> 16;
@@ -36863,254 +71569,254 @@
         sigf = 1048576 + (u32[1] & 1048575);
         sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
         expo = 0;
     } else {
         expo = expo - 1056964608 >> 10;
         sigf = (u32[1] & 1048575) + 512 >> 10;
     }
-    return sign3 | expo | sigf & 65535;
+    return sign5 | expo | sigf & 65535;
 }
 
-// node_modules/apache-arrow/visitor/set.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/set.mjs
 var SetVisitor = class extends Visitor {};
 
 function wrapSet(fn) {
     return (data, _1, _2) => {
         if (data.setValid(_1, _2 != null)) {
             return fn(data, _1, _2);
         }
     };
 }
-var setEpochMsToDays = (data, index3, epochMs) => {
-    data[index3] = Math.trunc(epochMs / 864e5);
+var setEpochMsToDays = (data, index5, epochMs) => {
+    data[index5] = Math.trunc(epochMs / 864e5);
 };
-var setEpochMsToMillisecondsLong = (data, index3, epochMs) => {
-    data[index3] = Math.trunc(epochMs % 4294967296);
-    data[index3 + 1] = Math.trunc(epochMs / 4294967296);
+var setEpochMsToMillisecondsLong = (data, index5, epochMs) => {
+    data[index5] = Math.trunc(epochMs % 4294967296);
+    data[index5 + 1] = Math.trunc(epochMs / 4294967296);
 };
-var setEpochMsToMicrosecondsLong = (data, index3, epochMs) => {
-    data[index3] = Math.trunc(epochMs * 1e3 % 4294967296);
-    data[index3 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
+var setEpochMsToMicrosecondsLong = (data, index5, epochMs) => {
+    data[index5] = Math.trunc(epochMs * 1e3 % 4294967296);
+    data[index5 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
 };
-var setEpochMsToNanosecondsLong = (data, index3, epochMs) => {
-    data[index3] = Math.trunc(epochMs * 1e6 % 4294967296);
-    data[index3 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
+var setEpochMsToNanosecondsLong = (data, index5, epochMs) => {
+    data[index5] = Math.trunc(epochMs * 1e6 % 4294967296);
+    data[index5 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
 };
-var setVariableWidthBytes = (values2, valueOffsets, index3, value) => {
-    if (index3 + 1 < valueOffsets.length) {
+var setVariableWidthBytes = (values3, valueOffsets, index5, value) => {
+    if (index5 + 1 < valueOffsets.length) {
         const {
-            [index3]: x4, [index3 + 1]: y4
+            [index5]: x7, [index5 + 1]: y7
         } = valueOffsets;
-        values2.set(value.subarray(0, y4 - x4), x4);
+        values3.set(value.subarray(0, y7 - x7), x7);
     }
 };
 var setBool = ({
-    offset: offset2,
-    values: values2
-}, index3, val) => {
-    const idx = offset2 + index3;
-    val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);
+    offset: offset3,
+    values: values3
+}, index5, val) => {
+    const idx = offset3 + index5;
+    val ? values3[idx >> 3] |= 1 << idx % 8 : values3[idx >> 3] &= ~(1 << idx % 8);
 };
 var setInt = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
 var setFloat = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
 var setFloat16 = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = float64ToUint16(value);
+    values: values3
+}, index5, value) => {
+    values3[index5] = float64ToUint16(value);
 };
-var setAnyFloat = (data, index3, value) => {
+var setAnyFloat = (data, index5, value) => {
     switch (data.type.precision) {
         case Precision.HALF:
-            return setFloat16(data, index3, value);
+            return setFloat16(data, index5, value);
         case Precision.SINGLE:
         case Precision.DOUBLE:
-            return setFloat(data, index3, value);
+            return setFloat(data, index5, value);
     }
 };
 var setDateDay = ({
-    values: values2
-}, index3, value) => {
-    setEpochMsToDays(values2, index3, value.valueOf());
+    values: values3
+}, index5, value) => {
+    setEpochMsToDays(values3, index5, value.valueOf());
 };
 var setDateMillisecond = ({
-    values: values2
-}, index3, value) => {
-    setEpochMsToMillisecondsLong(values2, index3 * 2, value.valueOf());
+    values: values3
+}, index5, value) => {
+    setEpochMsToMillisecondsLong(values3, index5 * 2, value.valueOf());
 };
 var setFixedSizeBinary = ({
     stride,
-    values: values2
-}, index3, value) => {
-    values2.set(value.subarray(0, stride), stride * index3);
+    values: values3
+}, index5, value) => {
+    values3.set(value.subarray(0, stride), stride * index5);
 };
 var setBinary = ({
-    values: values2,
+    values: values3,
     valueOffsets
-}, index3, value) => setVariableWidthBytes(values2, valueOffsets, index3, value);
+}, index5, value) => setVariableWidthBytes(values3, valueOffsets, index5, value);
 var setUtf8 = ({
-    values: values2,
+    values: values3,
     valueOffsets
-}, index3, value) => {
-    setVariableWidthBytes(values2, valueOffsets, index3, encodeUtf8(value));
+}, index5, value) => {
+    setVariableWidthBytes(values3, valueOffsets, index5, encodeUtf8(value));
 };
-var setDate = (data, index3, value) => {
-    data.type.unit === DateUnit.DAY ? setDateDay(data, index3, value) : setDateMillisecond(data, index3, value);
+var setDate = (data, index5, value) => {
+    data.type.unit === DateUnit.DAY ? setDateDay(data, index5, value) : setDateMillisecond(data, index5, value);
 };
 var setTimestampSecond = ({
-    values: values2
-}, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value / 1e3);
+    values: values3
+}, index5, value) => setEpochMsToMillisecondsLong(values3, index5 * 2, value / 1e3);
 var setTimestampMillisecond = ({
-    values: values2
-}, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value);
+    values: values3
+}, index5, value) => setEpochMsToMillisecondsLong(values3, index5 * 2, value);
 var setTimestampMicrosecond = ({
-    values: values2
-}, index3, value) => setEpochMsToMicrosecondsLong(values2, index3 * 2, value);
+    values: values3
+}, index5, value) => setEpochMsToMicrosecondsLong(values3, index5 * 2, value);
 var setTimestampNanosecond = ({
-    values: values2
-}, index3, value) => setEpochMsToNanosecondsLong(values2, index3 * 2, value);
-var setTimestamp = (data, index3, value) => {
+    values: values3
+}, index5, value) => setEpochMsToNanosecondsLong(values3, index5 * 2, value);
+var setTimestamp = (data, index5, value) => {
     switch (data.type.unit) {
         case TimeUnit.SECOND:
-            return setTimestampSecond(data, index3, value);
+            return setTimestampSecond(data, index5, value);
         case TimeUnit.MILLISECOND:
-            return setTimestampMillisecond(data, index3, value);
+            return setTimestampMillisecond(data, index5, value);
         case TimeUnit.MICROSECOND:
-            return setTimestampMicrosecond(data, index3, value);
+            return setTimestampMicrosecond(data, index5, value);
         case TimeUnit.NANOSECOND:
-            return setTimestampNanosecond(data, index3, value);
+            return setTimestampNanosecond(data, index5, value);
     }
 };
 var setTimeSecond = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
 var setTimeMillisecond = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
 var setTimeMicrosecond = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
 var setTimeNanosecond = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value;
 };
-var setTime = (data, index3, value) => {
+var setTime = (data, index5, value) => {
     switch (data.type.unit) {
         case TimeUnit.SECOND:
-            return setTimeSecond(data, index3, value);
+            return setTimeSecond(data, index5, value);
         case TimeUnit.MILLISECOND:
-            return setTimeMillisecond(data, index3, value);
+            return setTimeMillisecond(data, index5, value);
         case TimeUnit.MICROSECOND:
-            return setTimeMicrosecond(data, index3, value);
+            return setTimeMicrosecond(data, index5, value);
         case TimeUnit.NANOSECOND:
-            return setTimeNanosecond(data, index3, value);
+            return setTimeNanosecond(data, index5, value);
     }
 };
 var setDecimal = ({
-    values: values2,
+    values: values3,
     stride
-}, index3, value) => {
-    values2.set(value.subarray(0, stride), stride * index3);
+}, index5, value) => {
+    values3.set(value.subarray(0, stride), stride * index5);
 };
-var setList = (data, index3, value) => {
-    const values2 = data.children[0];
+var setList = (data, index5, value) => {
+    const values3 = data.children[0];
     const valueOffsets = data.valueOffsets;
-    const set4 = instance.getVisitFn(values2);
+    const set7 = instance.getVisitFn(values3);
     if (Array.isArray(value)) {
-        for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end;) {
-            set4(values2, itr++, value[++idx]);
+        for (let idx = -1, itr = valueOffsets[index5], end = valueOffsets[index5 + 1]; itr < end;) {
+            set7(values3, itr++, value[++idx]);
         }
     } else {
-        for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end;) {
-            set4(values2, itr++, value.get(++idx));
+        for (let idx = -1, itr = valueOffsets[index5], end = valueOffsets[index5 + 1]; itr < end;) {
+            set7(values3, itr++, value.get(++idx));
         }
     }
 };
-var setMap = (data, index3, value) => {
-    const values2 = data.children[0];
+var setMap = (data, index5, value) => {
+    const values3 = data.children[0];
     const {
         valueOffsets
     } = data;
-    const set4 = instance.getVisitFn(values2);
+    const set7 = instance.getVisitFn(values3);
     let {
-        [index3]: idx, [index3 + 1]: end
+        [index5]: idx, [index5 + 1]: end
     } = valueOffsets;
     const entries = value instanceof Map ? value.entries() : Object.entries(value);
     for (const val of entries) {
-        set4(values2, idx, val);
+        set7(values3, idx, val);
         if (++idx >= end)
             break;
     }
 };
-var _setStructArrayValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2[i]);
-var _setStructVectorValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2.get(i));
-var _setStructMapValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2.get(f.name));
-var _setStructObjectValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2[f.name]);
-var setStruct = (data, index3, value) => {
+var _setStructArrayValue = (o, v3) => (set7, c11, _, i) => c11 && set7(c11, o, v3[i]);
+var _setStructVectorValue = (o, v3) => (set7, c11, _, i) => c11 && set7(c11, o, v3.get(i));
+var _setStructMapValue = (o, v3) => (set7, c11, f, _) => c11 && set7(c11, o, v3.get(f.name));
+var _setStructObjectValue = (o, v3) => (set7, c11, f, _) => c11 && set7(c11, o, v3[f.name]);
+var setStruct = (data, index5, value) => {
     const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
-    const set4 = value instanceof Map ? _setStructMapValue(index3, value) : value instanceof Vector2 ? _setStructVectorValue(index3, value) : Array.isArray(value) ? _setStructArrayValue(index3, value) : _setStructObjectValue(index3, value);
-    data.type.children.forEach((f, i) => set4(childSetters[i], data.children[i], f, i));
+    const set7 = value instanceof Map ? _setStructMapValue(index5, value) : value instanceof Vector3 ? _setStructVectorValue(index5, value) : Array.isArray(value) ? _setStructArrayValue(index5, value) : _setStructObjectValue(index5, value);
+    data.type.children.forEach((f, i) => set7(childSetters[i], data.children[i], f, i));
 };
-var setUnion = (data, index3, value) => {
-    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index3, value) : setSparseUnion(data, index3, value);
+var setUnion = (data, index5, value) => {
+    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index5, value) : setSparseUnion(data, index5, value);
 };
-var setDenseUnion = (data, index3, value) => {
-    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];
+var setDenseUnion = (data, index5, value) => {
+    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index5]];
     const child = data.children[childIndex];
-    instance.visit(child, data.valueOffsets[index3], value);
+    instance.visit(child, data.valueOffsets[index5], value);
 };
-var setSparseUnion = (data, index3, value) => {
-    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];
+var setSparseUnion = (data, index5, value) => {
+    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index5]];
     const child = data.children[childIndex];
-    instance.visit(child, index3, value);
+    instance.visit(child, index5, value);
 };
-var setDictionary = (data, index3, value) => {
+var setDictionary = (data, index5, value) => {
     var _a5;
-    (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index3], value);
+    (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index5], value);
 };
-var setIntervalValue = (data, index3, value) => {
-    data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index3, value) : setIntervalYearMonth(data, index3, value);
+var setIntervalValue = (data, index5, value) => {
+    data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index5, value) : setIntervalYearMonth(data, index5, value);
 };
 var setIntervalDayTime = ({
-    values: values2
-}, index3, value) => {
-    values2.set(value.subarray(0, 2), 2 * index3);
+    values: values3
+}, index5, value) => {
+    values3.set(value.subarray(0, 2), 2 * index5);
 };
 var setIntervalYearMonth = ({
-    values: values2
-}, index3, value) => {
-    values2[index3] = value[0] * 12 + value[1] % 12;
+    values: values3
+}, index5, value) => {
+    values3[index5] = value[0] * 12 + value[1] % 12;
 };
-var setFixedSizeList = (data, index3, value) => {
+var setFixedSizeList = (data, index5, value) => {
     const {
         stride
     } = data;
     const child = data.children[0];
-    const set4 = instance.getVisitFn(child);
+    const set7 = instance.getVisitFn(child);
     if (Array.isArray(value)) {
-        for (let idx = -1, offset2 = index3 * stride; ++idx < stride;) {
-            set4(child, offset2 + idx, value[idx]);
+        for (let idx = -1, offset3 = index5 * stride; ++idx < stride;) {
+            set7(child, offset3 + idx, value[idx]);
         }
     } else {
-        for (let idx = -1, offset2 = index3 * stride; ++idx < stride;) {
-            set4(child, offset2 + idx, value.get(idx));
+        for (let idx = -1, offset3 = index5 * stride; ++idx < stride;) {
+            set7(child, offset3 + idx, value.get(idx));
         }
     }
 };
 SetVisitor.prototype.visitBool = wrapSet(setBool);
 SetVisitor.prototype.visitInt = wrapSet(setInt);
 SetVisitor.prototype.visitInt8 = wrapSet(setInt);
 SetVisitor.prototype.visitInt16 = wrapSet(setInt);
@@ -37150,15 +71856,15 @@
 SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
 SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
 SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
 SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
 SetVisitor.prototype.visitMap = wrapSet(setMap);
 var instance = new SetVisitor();
 
-// node_modules/apache-arrow/row/struct.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/row/struct.mjs
 var kParent = Symbol.for("parent");
 var kRowIndex = Symbol.for("rowIndex");
 var StructRow = class {
     constructor(parent, rowIndex) {
         this[kParent] = parent;
         this[kRowIndex] = rowIndex;
         return new Proxy(this, new StructRowProxyHandler());
@@ -37279,201 +71985,201 @@
         } else if (Reflect.has(row, key) || typeof key === "symbol") {
             return Reflect.set(row, key, val);
         }
         return false;
     }
 };
 
-// node_modules/apache-arrow/visitor/get.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/get.mjs
 var GetVisitor = class extends Visitor {};
 
 function wrapGet(fn) {
     return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
 }
-var epochDaysToMs = (data, index3) => 864e5 * data[index3];
-var epochMillisecondsLongToMs = (data, index3) => 4294967296 * data[index3 + 1] + (data[index3] >>> 0);
-var epochMicrosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e3) + (data[index3] >>> 0) / 1e3;
-var epochNanosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e6) + (data[index3] >>> 0) / 1e6;
+var epochDaysToMs = (data, index5) => 864e5 * data[index5];
+var epochMillisecondsLongToMs = (data, index5) => 4294967296 * data[index5 + 1] + (data[index5] >>> 0);
+var epochMicrosecondsLongToMs = (data, index5) => 4294967296 * (data[index5 + 1] / 1e3) + (data[index5] >>> 0) / 1e3;
+var epochNanosecondsLongToMs = (data, index5) => 4294967296 * (data[index5 + 1] / 1e6) + (data[index5] >>> 0) / 1e6;
 var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
-var epochDaysToDate = (data, index3) => epochMillisecondsToDate(epochDaysToMs(data, index3));
-var epochMillisecondsLongToDate = (data, index3) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index3));
+var epochDaysToDate = (data, index5) => epochMillisecondsToDate(epochDaysToMs(data, index5));
+var epochMillisecondsLongToDate = (data, index5) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index5));
 var getNull = (_data, _index) => null;
-var getVariableWidthBytes = (values2, valueOffsets, index3) => {
-    if (index3 + 1 >= valueOffsets.length) {
+var getVariableWidthBytes = (values3, valueOffsets, index5) => {
+    if (index5 + 1 >= valueOffsets.length) {
         return null;
     }
-    const x4 = valueOffsets[index3];
-    const y4 = valueOffsets[index3 + 1];
-    return values2.subarray(x4, y4);
+    const x7 = valueOffsets[index5];
+    const y7 = valueOffsets[index5 + 1];
+    return values3.subarray(x7, y7);
 };
 var getBool = ({
-    offset: offset2,
-    values: values2
-}, index3) => {
-    const idx = offset2 + index3;
-    const byte = values2[idx >> 3];
+    offset: offset3,
+    values: values3
+}, index5) => {
+    const idx = offset3 + index5;
+    const byte = values3[idx >> 3];
     return (byte & 1 << idx % 8) !== 0;
 };
 var getDateDay = ({
-    values: values2
-}, index3) => epochDaysToDate(values2, index3);
+    values: values3
+}, index5) => epochDaysToDate(values3, index5);
 var getDateMillisecond = ({
-    values: values2
-}, index3) => epochMillisecondsLongToDate(values2, index3 * 2);
+    values: values3
+}, index5) => epochMillisecondsLongToDate(values3, index5 * 2);
 var getNumeric = ({
     stride,
-    values: values2
-}, index3) => values2[stride * index3];
+    values: values3
+}, index5) => values3[stride * index5];
 var getFloat16 = ({
     stride,
-    values: values2
-}, index3) => uint16ToFloat64(values2[stride * index3]);
+    values: values3
+}, index5) => uint16ToFloat64(values3[stride * index5]);
 var getBigInts = ({
-    values: values2
-}, index3) => values2[index3];
+    values: values3
+}, index5) => values3[index5];
 var getFixedSizeBinary = ({
     stride,
-    values: values2
-}, index3) => values2.subarray(stride * index3, stride * (index3 + 1));
+    values: values3
+}, index5) => values3.subarray(stride * index5, stride * (index5 + 1));
 var getBinary = ({
-    values: values2,
+    values: values3,
     valueOffsets
-}, index3) => getVariableWidthBytes(values2, valueOffsets, index3);
+}, index5) => getVariableWidthBytes(values3, valueOffsets, index5);
 var getUtf8 = ({
-    values: values2,
+    values: values3,
     valueOffsets
-}, index3) => {
-    const bytes = getVariableWidthBytes(values2, valueOffsets, index3);
+}, index5) => {
+    const bytes = getVariableWidthBytes(values3, valueOffsets, index5);
     return bytes !== null ? decodeUtf8(bytes) : null;
 };
 var getInt = ({
-    values: values2
-}, index3) => values2[index3];
+    values: values3
+}, index5) => values3[index5];
 var getFloat = ({
-    type: type2,
-    values: values2
-}, index3) => type2.precision !== Precision.HALF ? values2[index3] : uint16ToFloat64(values2[index3]);
-var getDate = (data, index3) => data.type.unit === DateUnit.DAY ? getDateDay(data, index3) : getDateMillisecond(data, index3);
+    type: type3,
+    values: values3
+}, index5) => type3.precision !== Precision.HALF ? values3[index5] : uint16ToFloat64(values3[index5]);
+var getDate = (data, index5) => data.type.unit === DateUnit.DAY ? getDateDay(data, index5) : getDateMillisecond(data, index5);
 var getTimestampSecond = ({
-    values: values2
-}, index3) => 1e3 * epochMillisecondsLongToMs(values2, index3 * 2);
+    values: values3
+}, index5) => 1e3 * epochMillisecondsLongToMs(values3, index5 * 2);
 var getTimestampMillisecond = ({
-    values: values2
-}, index3) => epochMillisecondsLongToMs(values2, index3 * 2);
+    values: values3
+}, index5) => epochMillisecondsLongToMs(values3, index5 * 2);
 var getTimestampMicrosecond = ({
-    values: values2
-}, index3) => epochMicrosecondsLongToMs(values2, index3 * 2);
+    values: values3
+}, index5) => epochMicrosecondsLongToMs(values3, index5 * 2);
 var getTimestampNanosecond = ({
-    values: values2
-}, index3) => epochNanosecondsLongToMs(values2, index3 * 2);
-var getTimestamp = (data, index3) => {
+    values: values3
+}, index5) => epochNanosecondsLongToMs(values3, index5 * 2);
+var getTimestamp = (data, index5) => {
     switch (data.type.unit) {
         case TimeUnit.SECOND:
-            return getTimestampSecond(data, index3);
+            return getTimestampSecond(data, index5);
         case TimeUnit.MILLISECOND:
-            return getTimestampMillisecond(data, index3);
+            return getTimestampMillisecond(data, index5);
         case TimeUnit.MICROSECOND:
-            return getTimestampMicrosecond(data, index3);
+            return getTimestampMicrosecond(data, index5);
         case TimeUnit.NANOSECOND:
-            return getTimestampNanosecond(data, index3);
+            return getTimestampNanosecond(data, index5);
     }
 };
 var getTimeSecond = ({
-    values: values2
-}, index3) => values2[index3];
+    values: values3
+}, index5) => values3[index5];
 var getTimeMillisecond = ({
-    values: values2
-}, index3) => values2[index3];
+    values: values3
+}, index5) => values3[index5];
 var getTimeMicrosecond = ({
-    values: values2
-}, index3) => values2[index3];
+    values: values3
+}, index5) => values3[index5];
 var getTimeNanosecond = ({
-    values: values2
-}, index3) => values2[index3];
-var getTime = (data, index3) => {
+    values: values3
+}, index5) => values3[index5];
+var getTime = (data, index5) => {
     switch (data.type.unit) {
         case TimeUnit.SECOND:
-            return getTimeSecond(data, index3);
+            return getTimeSecond(data, index5);
         case TimeUnit.MILLISECOND:
-            return getTimeMillisecond(data, index3);
+            return getTimeMillisecond(data, index5);
         case TimeUnit.MICROSECOND:
-            return getTimeMicrosecond(data, index3);
+            return getTimeMicrosecond(data, index5);
         case TimeUnit.NANOSECOND:
-            return getTimeNanosecond(data, index3);
+            return getTimeNanosecond(data, index5);
     }
 };
 var getDecimal = ({
-    values: values2,
+    values: values3,
     stride
-}, index3) => BN.decimal(values2.subarray(stride * index3, stride * (index3 + 1)));
-var getList = (data, index3) => {
+}, index5) => BN.decimal(values3.subarray(stride * index5, stride * (index5 + 1)));
+var getList = (data, index5) => {
     const {
         valueOffsets,
         stride,
-        children: children2
+        children: children3
     } = data;
     const {
-        [index3 * stride]: begin, [index3 * stride + 1]: end
+        [index5 * stride]: begin, [index5 * stride + 1]: end
     } = valueOffsets;
-    const child = children2[0];
-    const slice7 = child.slice(begin, end - begin);
-    return new Vector2([slice7]);
+    const child = children3[0];
+    const slice13 = child.slice(begin, end - begin);
+    return new Vector3([slice13]);
 };
-var getMap = (data, index3) => {
+var getMap = (data, index5) => {
     const {
         valueOffsets,
-        children: children2
+        children: children3
     } = data;
     const {
-        [index3]: begin, [index3 + 1]: end
+        [index5]: begin, [index5 + 1]: end
     } = valueOffsets;
-    const child = children2[0];
+    const child = children3[0];
     return new MapRow(child.slice(begin, end - begin));
 };
-var getStruct = (data, index3) => {
-    return new StructRow(data, index3);
+var getStruct = (data, index5) => {
+    return new StructRow(data, index5);
 };
-var getUnion = (data, index3) => {
-    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index3) : getSparseUnion(data, index3);
+var getUnion = (data, index5) => {
+    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index5) : getSparseUnion(data, index5);
 };
-var getDenseUnion = (data, index3) => {
-    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];
+var getDenseUnion = (data, index5) => {
+    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index5]];
     const child = data.children[childIndex];
-    return instance2.visit(child, data.valueOffsets[index3]);
+    return instance2.visit(child, data.valueOffsets[index5]);
 };
-var getSparseUnion = (data, index3) => {
-    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];
+var getSparseUnion = (data, index5) => {
+    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index5]];
     const child = data.children[childIndex];
-    return instance2.visit(child, index3);
+    return instance2.visit(child, index5);
 };
-var getDictionary = (data, index3) => {
+var getDictionary = (data, index5) => {
     var _a5;
-    return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index3]);
+    return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index5]);
 };
-var getInterval = (data, index3) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index3) : getIntervalYearMonth(data, index3);
+var getInterval = (data, index5) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index5) : getIntervalYearMonth(data, index5);
 var getIntervalDayTime = ({
-    values: values2
-}, index3) => values2.subarray(2 * index3, 2 * (index3 + 1));
+    values: values3
+}, index5) => values3.subarray(2 * index5, 2 * (index5 + 1));
 var getIntervalYearMonth = ({
-    values: values2
-}, index3) => {
-    const interval2 = values2[index3];
+    values: values3
+}, index5) => {
+    const interval3 = values3[index5];
     const int32s = new Int32Array(2);
-    int32s[0] = Math.trunc(interval2 / 12);
-    int32s[1] = Math.trunc(interval2 % 12);
+    int32s[0] = Math.trunc(interval3 / 12);
+    int32s[1] = Math.trunc(interval3 % 12);
     return int32s;
 };
-var getFixedSizeList = (data, index3) => {
+var getFixedSizeList = (data, index5) => {
     const {
         stride,
-        children: children2
+        children: children3
     } = data;
-    const child = children2[0];
-    const slice7 = child.slice(index3 * stride, stride);
-    return new Vector2([slice7]);
+    const child = children3[0];
+    const slice13 = child.slice(index5 * stride, stride);
+    return new Vector3([slice13]);
 };
 GetVisitor.prototype.visitNull = wrapGet(getNull);
 GetVisitor.prototype.visitBool = wrapGet(getBool);
 GetVisitor.prototype.visitInt = wrapGet(getInt);
 GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
 GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
 GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
@@ -37512,21 +72218,21 @@
 GetVisitor.prototype.visitInterval = wrapGet(getInterval);
 GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
 GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
 GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
 GetVisitor.prototype.visitMap = wrapGet(getMap);
 var instance2 = new GetVisitor();
 
-// node_modules/apache-arrow/row/map.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/row/map.mjs
 var kKeys = Symbol.for("keys");
 var kVals = Symbol.for("vals");
 var MapRow = class {
-    constructor(slice7) {
-            this[kKeys] = new Vector2([slice7.children[0]]).memoize();
-            this[kVals] = slice7.children[1];
+    constructor(slice13) {
+            this[kKeys] = new Vector3([slice13.children[0]]).memoize();
+            this[kVals] = slice13.children[1];
             return new Proxy(this, new MapRowProxyHandler());
         }
         [Symbol.iterator]() {
             return new MapRowIterator(this[kKeys], this[kVals]);
         }
     get size() {
         return this[kKeys].length;
@@ -37643,18 +72349,18 @@
         writable: true,
         enumerable: false,
         configurable: false,
         value: null
     }
 });
 
-// node_modules/apache-arrow/util/vector.mjs
-function clampIndex(source, index3, then) {
-    const length4 = source.length;
-    const adjust = index3 > -1 ? index3 : length4 + index3 % length4;
+// js/pyobsplot-js/node_modules/apache-arrow/util/vector.mjs
+function clampIndex(source, index5, then) {
+    const length7 = source.length;
+    const adjust = index5 > -1 ? index5 : length7 + index5 % length7;
     return then ? then(source, adjust) : adjust;
 }
 var tmp;
 
 function clampRange(source, begin, end, then) {
     const {
         length: len = 0
@@ -37686,15 +72392,15 @@
     }
     if (search instanceof Map) {
         return createMapComparator(search);
     }
     if (Array.isArray(search)) {
         return createArrayLikeComparator(search);
     }
-    if (search instanceof Vector2) {
+    if (search instanceof Vector3) {
         return createVectorComparator(search);
     }
     return createObjectComparator(search, true);
 }
 
 function createArrayLikeComparator(lhs) {
     const comparators = [];
@@ -37703,16 +72409,16 @@
     }
     return createSubElementsComparator(comparators);
 }
 
 function createMapComparator(lhs) {
     let i = -1;
     const comparators = [];
-    for (const v2 of lhs.values())
-        comparators[++i] = createElementComparator(v2);
+    for (const v3 of lhs.values())
+        comparators[++i] = createElementComparator(v3);
     return createSubElementsComparator(comparators);
 }
 
 function createVectorComparator(lhs) {
     const comparators = [];
     for (let i = -1, n = lhs.length; ++i < n;) {
         comparators[i] = createElementComparator(lhs.get(i));
@@ -37744,15 +72450,15 @@
                 return compareObject(comparators, rhs, rhs.keys());
             case MapRow:
             case StructRow:
             case Object:
             case void 0:
                 return compareObject(comparators, rhs, keys || Object.keys(rhs));
         }
-        return rhs instanceof Vector2 ? compareVector(comparators, rhs) : false;
+        return rhs instanceof Vector3 ? compareVector(comparators, rhs) : false;
     };
 }
 
 function compareArray(comparators, arr) {
     const n = comparators.length;
     if (arr.length !== n) {
         return false;
@@ -37761,21 +72467,21 @@
         if (!comparators[i](arr[i])) {
             return false;
         }
     }
     return true;
 }
 
-function compareVector(comparators, vec2) {
+function compareVector(comparators, vec3) {
     const n = comparators.length;
-    if (vec2.length !== n) {
+    if (vec3.length !== n) {
         return false;
     }
     for (let i = -1; ++i < n;) {
-        if (!comparators[i](vec2.get(i))) {
+        if (!comparators[i](vec3.get(i))) {
             return false;
         }
     }
     return true;
 }
 
 function compareObject(comparators, obj, keys) {
@@ -37797,15 +72503,15 @@
     }
     lKeyItr.return && lKeyItr.return();
     rKeyItr.return && rKeyItr.return();
     rValItr.return && rValItr.return();
     return false;
 }
 
-// node_modules/apache-arrow/util/bit.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/bit.mjs
 var bit_exports = {};
 __export(bit_exports, {
     BitIterator: () => BitIterator,
     getBit: () => getBit,
     getBool: () => getBool2,
     packBools: () => packBools,
     popcnt_array: () => popcnt_array,
@@ -37819,56 +72525,56 @@
     return (byte & 1 << bit) !== 0;
 }
 
 function getBit(_data, _index, byte, bit) {
     return (byte & 1 << bit) >> bit;
 }
 
-function setBool2(bytes, index3, value) {
-    return value ? !!(bytes[index3 >> 3] |= 1 << index3 % 8) || true : !(bytes[index3 >> 3] &= ~(1 << index3 % 8)) && false;
+function setBool2(bytes, index5, value) {
+    return value ? !!(bytes[index5 >> 3] |= 1 << index5 % 8) || true : !(bytes[index5 >> 3] &= ~(1 << index5 % 8)) && false;
 }
 
-function truncateBitmap(offset2, length4, bitmap) {
+function truncateBitmap(offset3, length7, bitmap) {
     const alignedSize = bitmap.byteLength + 7 & ~7;
-    if (offset2 > 0 || bitmap.byteLength < alignedSize) {
+    if (offset3 > 0 || bitmap.byteLength < alignedSize) {
         const bytes = new Uint8Array(alignedSize);
-        bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (
+        bytes.set(offset3 % 8 === 0 ? bitmap.subarray(offset3 >> 3) : (
             // Otherwise iterate each bit from the offset and return a new one
-            packBools(new BitIterator(bitmap, offset2, length4, null, getBool2)).subarray(0, alignedSize)
+            packBools(new BitIterator(bitmap, offset3, length7, null, getBool2)).subarray(0, alignedSize)
         ));
         return bytes;
     }
     return bitmap;
 }
 
-function packBools(values2) {
+function packBools(values3) {
     const xs = [];
     let i = 0,
         bit = 0,
         byte = 0;
-    for (const value of values2) {
+    for (const value of values3) {
         value && (byte |= 1 << bit);
         if (++bit === 8) {
             xs[i++] = byte;
             byte = bit = 0;
         }
     }
     if (i === 0 || bit > 0) {
         xs[i++] = byte;
     }
     const b = new Uint8Array(xs.length + 7 & ~7);
     b.set(xs);
     return b;
 }
 var BitIterator = class {
-    constructor(bytes, begin, length4, context, get3) {
+    constructor(bytes, begin, length7, context, get5) {
         this.bytes = bytes;
-        this.length = length4;
+        this.length = length7;
         this.context = context;
-        this.get = get3;
+        this.get = get5;
         this.bit = begin % 8;
         this.byteIndex = begin >> 3;
         this.byte = bytes[this.byteIndex++];
         this.index = 0;
     }
     next() {
             if (this.index < this.length) {
@@ -37891,19 +72597,19 @@
 };
 
 function popcnt_bit_range(data, lhs, rhs) {
     if (rhs - lhs <= 0) {
         return 0;
     }
     if (rhs - lhs < 8) {
-        let sum5 = 0;
+        let sum8 = 0;
         for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
-            sum5 += bit;
+            sum8 += bit;
         }
-        return sum5;
+        return sum8;
     }
     const rhsInside = rhs >> 3 << 3;
     const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
     return (
         // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
         popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
         popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
@@ -37934,33 +72640,33 @@
 function popcnt_uint32(uint32) {
     let i = Math.trunc(uint32);
     i = i - (i >>> 1 & 1431655765);
     i = (i & 858993459) + (i >>> 2 & 858993459);
     return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
 }
 
-// node_modules/apache-arrow/data.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/data.mjs
 var kUnknownNullCount = -1;
 var Data = class {
-    constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {
-        this.type = type2;
-        this.children = children2;
+    constructor(type3, offset3, length7, nullCount, buffers, children3 = [], dictionary) {
+        this.type = type3;
+        this.children = children3;
         this.dictionary = dictionary;
-        this.offset = Math.floor(Math.max(offset2 || 0, 0));
-        this.length = Math.floor(Math.max(length4 || 0, 0));
+        this.offset = Math.floor(Math.max(offset3 || 0, 0));
+        this.length = Math.floor(Math.max(length7 || 0, 0));
         this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
         let buffer;
         if (buffers instanceof Data) {
             this.stride = buffers.stride;
             this.values = buffers.values;
             this.typeIds = buffers.typeIds;
             this.nullBitmap = buffers.nullBitmap;
             this.valueOffsets = buffers.valueOffsets;
         } else {
-            this.stride = strideForType(type2);
+            this.stride = strideForType(type3);
             if (buffers) {
                 (buffer = buffers[0]) && (this.valueOffsets = buffer);
                 (buffer = buffers[1]) && (this.values = buffer);
                 (buffer = buffers[2]) && (this.nullBitmap = buffer);
                 (buffer = buffers[3]) && (this.typeIds = buffer);
             }
         }
@@ -37975,337 +72681,337 @@
     get buffers() {
         return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
     }
     get byteLength() {
         let byteLength = 0;
         const {
             valueOffsets,
-            values: values2,
+            values: values3,
             nullBitmap,
             typeIds
         } = this;
         valueOffsets && (byteLength += valueOffsets.byteLength);
-        values2 && (byteLength += values2.byteLength);
+        values3 && (byteLength += values3.byteLength);
         nullBitmap && (byteLength += nullBitmap.byteLength);
         typeIds && (byteLength += typeIds.byteLength);
         return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
     }
     get nullCount() {
         let nullCount = this._nullCount;
         let nullBitmap;
         if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
             this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
         }
         return nullCount;
     }
-    getValid(index3) {
+    getValid(index5) {
         if (this.nullable && this.nullCount > 0) {
-            const pos = this.offset + index3;
+            const pos = this.offset + index5;
             const val = this.nullBitmap[pos >> 3];
             return (val & 1 << pos % 8) !== 0;
         }
         return true;
     }
-    setValid(index3, value) {
+    setValid(index5, value) {
         if (!this.nullable) {
             return value;
         }
-        if (!this.nullBitmap || this.nullBitmap.byteLength <= index3 >> 3) {
+        if (!this.nullBitmap || this.nullBitmap.byteLength <= index5 >> 3) {
             const {
                 nullBitmap: nullBitmap2
             } = this._changeLengthAndBackfillNullBitmap(this.length);
             Object.assign(this, {
                 nullBitmap: nullBitmap2,
                 _nullCount: 0
             });
         }
         const {
             nullBitmap,
-            offset: offset2
+            offset: offset3
         } = this;
-        const pos = offset2 + index3 >> 3;
-        const bit = (offset2 + index3) % 8;
+        const pos = offset3 + index5 >> 3;
+        const bit = (offset3 + index5) % 8;
         const val = nullBitmap[pos] >> bit & 1;
         value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);
         return value;
     }
-    clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {
-        return new Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);
+    clone(type3 = this.type, offset3 = this.offset, length7 = this.length, nullCount = this._nullCount, buffers = this, children3 = this.children) {
+        return new Data(type3, offset3, length7, nullCount, buffers, children3, this.dictionary);
     }
-    slice(offset2, length4) {
+    slice(offset3, length7) {
         const {
             stride,
             typeId,
-            children: children2
+            children: children3
         } = this;
         const nullCount = +(this._nullCount === 0) - 1;
         const childStride = typeId === 16 ? stride : 1;
-        const buffers = this._sliceBuffers(offset2, length4, stride, typeId);
+        const buffers = this._sliceBuffers(offset3, length7, stride, typeId);
         return this.clone(
             this.type,
-            this.offset + offset2,
-            length4,
+            this.offset + offset3,
+            length7,
             nullCount,
             buffers,
             // Don't slice children if we have value offsets (the variable-width types)
-            children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)
+            children3.length === 0 || this.valueOffsets ? children3 : this._sliceChildren(children3, childStride * offset3, childStride * length7)
         );
     }
     _changeLengthAndBackfillNullBitmap(newLength) {
         if (this.typeId === Type.Null) {
             return this.clone(this.type, 0, newLength, 0);
         }
         const {
-            length: length4,
+            length: length7,
             nullCount
         } = this;
-        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);
-        bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;
+        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length7 >> 3);
+        bitmap[length7 >> 3] = (1 << length7 - (length7 & ~7)) - 1;
         if (nullCount > 0) {
-            bitmap.set(truncateBitmap(this.offset, length4, this.nullBitmap), 0);
+            bitmap.set(truncateBitmap(this.offset, length7, this.nullBitmap), 0);
         }
         const buffers = this.buffers;
         buffers[BufferType.VALIDITY] = bitmap;
-        return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);
+        return this.clone(this.type, 0, newLength, nullCount + (newLength - length7), buffers);
     }
-    _sliceBuffers(offset2, length4, stride, typeId) {
+    _sliceBuffers(offset3, length7, stride, typeId) {
         let arr;
         const {
             buffers
         } = this;
-        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length4));
-        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
-        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));
+        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset3, offset3 + length7));
+        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset3, offset3 + length7 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
+        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset3, stride * (offset3 + length7)));
         return buffers;
     }
-    _sliceChildren(children2, offset2, length4) {
-        return children2.map((child) => child.slice(offset2, length4));
+    _sliceChildren(children3, offset3, length7) {
+        return children3.map((child) => child.slice(offset3, length7));
     }
 };
 Data.prototype.children = Object.freeze([]);
 var MakeDataVisitor = class extends Visitor {
     visit(props) {
         return this.getVisitFn(props["type"]).call(this, props);
     }
     visitNull(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["length"]: length4 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0, ["length"]: length7 = 0
         } = props;
-        return new Data(type2, offset2, length4, 0);
+        return new Data(type3, offset3, length7, 0);
     }
     visitBool(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitInt(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitFloat(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitUtf8(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const data = toUint8Array(props["data"]);
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const valueOffsets = toInt32Array(props["valueOffsets"]);
         const {
-            ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [valueOffsets, data, nullBitmap]);
     }
     visitBinary(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const data = toUint8Array(props["data"]);
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const valueOffsets = toInt32Array(props["valueOffsets"]);
         const {
-            ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [valueOffsets, data, nullBitmap]);
     }
     visitFixedSizeBinary(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitDate(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitTimestamp(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitTime(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitDecimal(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitList(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child
+            ["type"]: type3, ["offset"]: offset3 = 0, ["child"]: child
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const valueOffsets = toInt32Array(props["valueOffsets"]);
         const {
-            ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
+        return new Data(type3, offset3, length7, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
     }
     visitStruct(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = []
+            ["type"]: type3, ["offset"]: offset3 = 0, ["children"]: children3 = []
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const {
-            length: length4 = children2.reduce((len, {
-                length: length5
-            }) => Math.max(len, length5), 0),
+            length: length7 = children3.reduce((len, {
+                length: length8
+            }) => Math.max(len, length8), 0),
             nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);
+        return new Data(type3, offset3, length7, nullCount, [void 0, void 0, nullBitmap], children3);
     }
     visitUnion(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = []
+            ["type"]: type3, ["offset"]: offset3 = 0, ["children"]: children3 = []
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const typeIds = toArrayBufferView(type2.ArrayType, props["typeIds"]);
+        const typeIds = toArrayBufferView(type3.ArrayType, props["typeIds"]);
         const {
-            ["length"]: length4 = typeIds.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = typeIds.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        if (DataType.isSparseUnion(type2)) {
-            return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap, typeIds], children2);
+        if (DataType.isSparseUnion(type3)) {
+            return new Data(type3, offset3, length7, nullCount, [void 0, void 0, nullBitmap, typeIds], children3);
         }
         const valueOffsets = toInt32Array(props["valueOffsets"]);
-        return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children2);
+        return new Data(type3, offset3, length7, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children3);
     }
     visitDictionary(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.indices.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.indices.ArrayType, props["data"]);
         const {
-            ["dictionary"]: dictionary = new Vector2([new MakeDataVisitor().visit({
-                type: type2.dictionary
+            ["dictionary"]: dictionary = new Vector3([new MakeDataVisitor().visit({
+                type: type3.dictionary
             })])
         } = props;
         const {
-            ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap], [], dictionary);
     }
     visitInterval(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0
+            ["type"]: type3, ["offset"]: offset3 = 0
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
-        const data = toArrayBufferView(type2.ArrayType, props["data"]);
+        const data = toArrayBufferView(type3.ArrayType, props["data"]);
         const {
-            ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = data.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, data, nullBitmap]);
     }
     visitFixedSizeList(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new MakeDataVisitor().visit({
-                type: type2.valueType
+            ["type"]: type3, ["offset"]: offset3 = 0, ["child"]: child = new MakeDataVisitor().visit({
+                type: type3.valueType
             })
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const {
-            ["length"]: length4 = child.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = child.length / strideForType(type3), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);
+        return new Data(type3, offset3, length7, nullCount, [void 0, void 0, nullBitmap], [child]);
     }
     visitMap(props) {
         const {
-            ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new MakeDataVisitor().visit({
-                type: type2.childType
+            ["type"]: type3, ["offset"]: offset3 = 0, ["child"]: child = new MakeDataVisitor().visit({
+                type: type3.childType
             })
         } = props;
         const nullBitmap = toUint8Array(props["nullBitmap"]);
         const valueOffsets = toInt32Array(props["valueOffsets"]);
         const {
-            ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
+            ["length"]: length7 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0
         } = props;
-        return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
+        return new Data(type3, offset3, length7, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
     }
 };
 
 function makeData(props) {
     return new MakeDataVisitor().visit(props);
 }
 
-// node_modules/apache-arrow/util/chunk.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/chunk.mjs
 var ChunkedIterator = class {
     constructor(numChunks = 0, getChunkIterator) {
         this.numChunks = numChunks;
         this.getChunkIterator = getChunkIterator;
         this.chunkIndex = 0;
         this.chunkIterator = this.getChunkIterator(0);
     }
@@ -38330,117 +73036,117 @@
 };
 
 function computeChunkNullCounts(chunks) {
     return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
 }
 
 function computeChunkOffsets(chunks) {
-    return chunks.reduce((offsets, chunk, index3) => {
-        offsets[index3 + 1] = offsets[index3] + chunk.length;
+    return chunks.reduce((offsets, chunk, index5) => {
+        offsets[index5 + 1] = offsets[index5] + chunk.length;
         return offsets;
     }, new Uint32Array(chunks.length + 1));
 }
 
 function sliceChunks(chunks, offsets, begin, end) {
     const slices = [];
     for (let i = -1, n = chunks.length; ++i < n;) {
         const chunk = chunks[i];
-        const offset2 = offsets[i];
+        const offset3 = offsets[i];
         const {
-            length: length4
+            length: length7
         } = chunk;
-        if (offset2 >= end) {
+        if (offset3 >= end) {
             break;
         }
-        if (begin >= offset2 + length4) {
+        if (begin >= offset3 + length7) {
             continue;
         }
-        if (offset2 >= begin && offset2 + length4 <= end) {
+        if (offset3 >= begin && offset3 + length7 <= end) {
             slices.push(chunk);
             continue;
         }
-        const from = Math.max(0, begin - offset2);
-        const to = Math.min(end - offset2, length4);
+        const from = Math.max(0, begin - offset3);
+        const to = Math.min(end - offset3, length7);
         slices.push(chunk.slice(from, to - from));
     }
     if (slices.length === 0) {
         slices.push(chunks[0].slice(0, 0));
     }
     return slices;
 }
 
 function binarySearch(chunks, offsets, idx, fn) {
     let lhs = 0,
-        mid2 = 0,
+        mid3 = 0,
         rhs = offsets.length - 1;
     do {
         if (lhs >= rhs - 1) {
             return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
         }
-        mid2 = lhs + Math.trunc((rhs - lhs) * 0.5);
-        idx < offsets[mid2] ? rhs = mid2 : lhs = mid2;
+        mid3 = lhs + Math.trunc((rhs - lhs) * 0.5);
+        idx < offsets[mid3] ? rhs = mid3 : lhs = mid3;
     } while (lhs < rhs);
 }
 
-function isChunkedValid(data, index3) {
-    return data.getValid(index3);
+function isChunkedValid(data, index5) {
+    return data.getValid(index5);
 }
 
 function wrapChunkedCall1(fn) {
     function chunkedFn(chunks, i, j) {
         return fn(chunks[i], j);
     }
-    return function(index3) {
+    return function(index5) {
         const data = this.data;
-        return binarySearch(data, this._offsets, index3, chunkedFn);
+        return binarySearch(data, this._offsets, index5, chunkedFn);
     };
 }
 
 function wrapChunkedCall2(fn) {
     let _2;
 
     function chunkedFn(chunks, i, j) {
         return fn(chunks[i], j, _2);
     }
-    return function(index3, value) {
+    return function(index5, value) {
         const data = this.data;
         _2 = value;
-        const result = binarySearch(data, this._offsets, index3, chunkedFn);
+        const result = binarySearch(data, this._offsets, index5, chunkedFn);
         _2 = void 0;
         return result;
     };
 }
 
-function wrapChunkedIndexOf(indexOf2) {
+function wrapChunkedIndexOf(indexOf3) {
     let _1;
 
     function chunkedIndexOf(data, chunkIndex, fromIndex) {
         let begin = fromIndex,
-            index3 = 0,
+            index5 = 0,
             total = 0;
         for (let i = chunkIndex - 1, n = data.length; ++i < n;) {
             const chunk = data[i];
-            if (~(index3 = indexOf2(chunk, _1, begin))) {
-                return total + index3;
+            if (~(index5 = indexOf3(chunk, _1, begin))) {
+                return total + index5;
             }
             begin = 0;
             total += chunk.length;
         }
         return -1;
     }
-    return function(element, offset2) {
+    return function(element, offset3) {
         _1 = element;
         const data = this.data;
-        const result = typeof offset2 !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset2, chunkedIndexOf);
+        const result = typeof offset3 !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset3, chunkedIndexOf);
         _1 = void 0;
         return result;
     };
 }
 
-// node_modules/apache-arrow/visitor/indexof.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/indexof.mjs
 var IndexOfVisitor = class extends Visitor {};
 
 function nullIndexOf(data, searchElement) {
     return searchElement === null && data.length > 0 ? 0 : -1;
 }
 
 function indexOfNull(data, fromIndex) {
@@ -38463,29 +73169,29 @@
 function indexOfValue(data, searchElement, fromIndex) {
     if (searchElement === void 0) {
         return -1;
     }
     if (searchElement === null) {
         return indexOfNull(data, fromIndex);
     }
-    const get3 = instance2.getVisitFn(data);
+    const get5 = instance2.getVisitFn(data);
     const compare = createElementComparator(searchElement);
     for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
-        if (compare(get3(data, i))) {
+        if (compare(get5(data, i))) {
             return i;
         }
     }
     return -1;
 }
 
 function indexOfUnion(data, searchElement, fromIndex) {
-    const get3 = instance2.getVisitFn(data);
+    const get5 = instance2.getVisitFn(data);
     const compare = createElementComparator(searchElement);
     for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
-        if (compare(get3(data, i))) {
+        if (compare(get5(data, i))) {
             return i;
         }
     }
     return -1;
 }
 IndexOfVisitor.prototype.visitNull = nullIndexOf;
 IndexOfVisitor.prototype.visitBool = indexOfValue;
@@ -38528,39 +73234,39 @@
 IndexOfVisitor.prototype.visitInterval = indexOfValue;
 IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
 IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
 IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
 IndexOfVisitor.prototype.visitMap = indexOfValue;
 var instance3 = new IndexOfVisitor();
 
-// node_modules/apache-arrow/visitor/iterator.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/iterator.mjs
 var IteratorVisitor = class extends Visitor {};
 
-function vectorIterator(vector2) {
+function vectorIterator(vector3) {
     const {
-        type: type2
-    } = vector2;
-    if (vector2.nullCount === 0 && vector2.stride === 1 && (type2.typeId === Type.Timestamp || type2 instanceof Int_ && type2.bitWidth !== 64 || type2 instanceof Time_ && type2.bitWidth !== 64 || type2 instanceof Float && type2.precision !== Precision.HALF)) {
-        return new ChunkedIterator(vector2.data.length, (chunkIndex) => {
-            const data = vector2.data[chunkIndex];
+        type: type3
+    } = vector3;
+    if (vector3.nullCount === 0 && vector3.stride === 1 && (type3.typeId === Type.Timestamp || type3 instanceof Int_ && type3.bitWidth !== 64 || type3 instanceof Time_ && type3.bitWidth !== 64 || type3 instanceof Float && type3.precision !== Precision.HALF)) {
+        return new ChunkedIterator(vector3.data.length, (chunkIndex) => {
+            const data = vector3.data[chunkIndex];
             return data.values.subarray(0, data.length)[Symbol.iterator]();
         });
     }
-    let offset2 = 0;
-    return new ChunkedIterator(vector2.data.length, (chunkIndex) => {
-        const data = vector2.data[chunkIndex];
-        const length4 = data.length;
-        const inner = vector2.slice(offset2, offset2 + length4);
-        offset2 += length4;
+    let offset3 = 0;
+    return new ChunkedIterator(vector3.data.length, (chunkIndex) => {
+        const data = vector3.data[chunkIndex];
+        const length7 = data.length;
+        const inner = vector3.slice(offset3, offset3 + length7);
+        offset3 += length7;
         return new VectorIterator(inner);
     });
 }
 var VectorIterator = class {
-    constructor(vector2) {
-        this.vector = vector2;
+    constructor(vector3) {
+        this.vector = vector3;
         this.index = 0;
     }
     next() {
             if (this.index < this.vector.length) {
                 return {
                     value: this.vector.get(this.index++)
                 };
@@ -38615,16 +73321,16 @@
 IteratorVisitor.prototype.visitInterval = vectorIterator;
 IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
 IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
 IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
 IteratorVisitor.prototype.visitMap = vectorIterator;
 var instance4 = new IteratorVisitor();
 
-// node_modules/apache-arrow/visitor/bytelength.mjs
-var sum4 = (x4, y4) => x4 + y4;
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/bytelength.mjs
+var sum7 = (x7, y7) => x7 + y7;
 var GetByteLengthVisitor = class extends Visitor {
     visitNull(____, _) {
         return 0;
     }
     visitInt(data, _) {
         return data.type.bitWidth / 8;
     }
@@ -38661,122 +73367,122 @@
     visitDictionary(data, i) {
         var _a5;
         return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);
     }
 };
 var getUtf8ByteLength = ({
     valueOffsets
-}, index3) => {
-    return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);
+}, index5) => {
+    return 8 + (valueOffsets[index5 + 1] - valueOffsets[index5]);
 };
 var getBinaryByteLength = ({
     valueOffsets
-}, index3) => {
-    return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);
+}, index5) => {
+    return 8 + (valueOffsets[index5 + 1] - valueOffsets[index5]);
 };
 var getListByteLength = ({
     valueOffsets,
     stride,
-    children: children2
-}, index3) => {
-    const child = children2[0];
+    children: children3
+}, index5) => {
+    const child = children3[0];
     const {
-        [index3 * stride]: start2
+        [index5 * stride]: start3
     } = valueOffsets;
     const {
-        [index3 * stride + 1]: end
+        [index5 * stride + 1]: end
     } = valueOffsets;
     const visit = instance5.getVisitFn(child.type);
-    const slice7 = child.slice(start2, end - start2);
+    const slice13 = child.slice(start3, end - start3);
     let size = 8;
-    for (let idx = -1, len = end - start2; ++idx < len;) {
-        size += visit(slice7, idx);
+    for (let idx = -1, len = end - start3; ++idx < len;) {
+        size += visit(slice13, idx);
     }
     return size;
 };
 var getFixedSizeListByteLength = ({
     stride,
-    children: children2
-}, index3) => {
-    const child = children2[0];
-    const slice7 = child.slice(index3 * stride, stride);
+    children: children3
+}, index5) => {
+    const child = children3[0];
+    const slice13 = child.slice(index5 * stride, stride);
     const visit = instance5.getVisitFn(child.type);
     let size = 0;
-    for (let idx = -1, len = slice7.length; ++idx < len;) {
-        size += visit(slice7, idx);
+    for (let idx = -1, len = slice13.length; ++idx < len;) {
+        size += visit(slice13, idx);
     }
     return size;
 };
-var getUnionByteLength = (data, index3) => {
-    return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index3) : getSparseUnionByteLength(data, index3);
+var getUnionByteLength = (data, index5) => {
+    return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index5) : getSparseUnionByteLength(data, index5);
 };
 var getDenseUnionByteLength = ({
-    type: type2,
-    children: children2,
+    type: type3,
+    children: children3,
     typeIds,
     valueOffsets
-}, index3) => {
-    const childIndex = type2.typeIdToChildIndex[typeIds[index3]];
-    return 8 + instance5.visit(children2[childIndex], valueOffsets[index3]);
+}, index5) => {
+    const childIndex = type3.typeIdToChildIndex[typeIds[index5]];
+    return 8 + instance5.visit(children3[childIndex], valueOffsets[index5]);
 };
 var getSparseUnionByteLength = ({
-    children: children2
-}, index3) => {
-    return 4 + instance5.visitMany(children2, children2.map(() => index3)).reduce(sum4, 0);
+    children: children3
+}, index5) => {
+    return 4 + instance5.visitMany(children3, children3.map(() => index5)).reduce(sum7, 0);
 };
 GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
 GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
 GetByteLengthVisitor.prototype.visitList = getListByteLength;
 GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
 GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
 GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
 GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
 var instance5 = new GetByteLengthVisitor();
 
-// node_modules/apache-arrow/vector.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/vector.mjs
 var _a2;
 var visitorsByTypeId = {};
 var vectorPrototypesByTypeId = {};
-var Vector2 = class {
+var Vector3 = class {
     constructor(input) {
         var _b2, _c2, _d2;
-        const data = input[0] instanceof Vector2 ? input.flatMap((x4) => x4.data) : input;
-        if (data.length === 0 || data.some((x4) => !(x4 instanceof Data))) {
+        const data = input[0] instanceof Vector3 ? input.flatMap((x7) => x7.data) : input;
+        if (data.length === 0 || data.some((x7) => !(x7 instanceof Data))) {
             throw new TypeError("Vector constructor expects an Array of Data instances.");
         }
-        const type2 = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
+        const type3 = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
         switch (data.length) {
             case 0:
                 this._offsets = [0];
                 break;
             case 1: {
                 const {
-                    get: get3,
-                    set: set4,
-                    indexOf: indexOf2,
+                    get: get5,
+                    set: set7,
+                    indexOf: indexOf3,
                     byteLength
-                } = visitorsByTypeId[type2.typeId];
+                } = visitorsByTypeId[type3.typeId];
                 const unchunkedData = data[0];
-                this.isValid = (index3) => isChunkedValid(unchunkedData, index3);
-                this.get = (index3) => get3(unchunkedData, index3);
-                this.set = (index3, value) => set4(unchunkedData, index3, value);
-                this.indexOf = (index3) => indexOf2(unchunkedData, index3);
-                this.getByteLength = (index3) => byteLength(unchunkedData, index3);
+                this.isValid = (index5) => isChunkedValid(unchunkedData, index5);
+                this.get = (index5) => get5(unchunkedData, index5);
+                this.set = (index5, value) => set7(unchunkedData, index5, value);
+                this.indexOf = (index5) => indexOf3(unchunkedData, index5);
+                this.getByteLength = (index5) => byteLength(unchunkedData, index5);
                 this._offsets = [0, unchunkedData.length];
                 break;
             }
             default:
-                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type2.typeId]);
+                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type3.typeId]);
                 this._offsets = computeChunkOffsets(data);
                 break;
         }
         this.data = data;
-        this.type = type2;
-        this.stride = strideForType(type2);
-        this.numChildren = (_d2 = (_c2 = type2.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
+        this.type = type3;
+        this.stride = strideForType(type3);
+        this.numChildren = (_d2 = (_c2 = type3.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
         this.length = this._offsets[this._offsets.length - 1];
     }
     /**
      * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
      */
     get byteLength() {
         if (this._byteLength === -1) {
@@ -38813,74 +73519,74 @@
         return `${Type[this.type.typeId]}Vector`;
     }
     /**
      * Check whether an element is null.
      * @param index The index at which to read the validity bitmap.
      */
     // @ts-ignore
-    isValid(index3) {
+    isValid(index5) {
         return false;
     }
     /**
      * Get an element value by position.
      * @param index The index of the element to read.
      */
     // @ts-ignore
-    get(index3) {
+    get(index5) {
         return null;
     }
     /**
      * Set an element value by position.
      * @param index The index of the element to write.
      * @param value The value to set.
      */
     // @ts-ignore
-    set(index3, value) {
+    set(index5, value) {
         return;
     }
     /**
      * Retrieve the index of the first occurrence of a value in an Vector.
      * @param element The value to locate in the Vector.
      * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
      */
     // @ts-ignore
-    indexOf(element, offset2) {
+    indexOf(element, offset3) {
         return -1;
     }
-    includes(element, offset2) {
-        return this.indexOf(element, offset2) > 0;
+    includes(element, offset3) {
+        return this.indexOf(element, offset3) > 0;
     }
     /**
      * Get the size in bytes of an element by index.
      * @param index The index at which to get the byteLength.
      */
     // @ts-ignore
-    getByteLength(index3) {
+    getByteLength(index5) {
         return 0;
     }
     /**
      * Iterator for the Vector's elements.
      */
     [Symbol.iterator]() {
         return instance4.visit(this);
     }
     /**
      * Combines two or more Vectors of the same type.
      * @param others Additional Vectors to add to the end of this Vector.
      */
     concat(...others) {
-        return new Vector2(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));
+        return new Vector3(this.data.concat(others.flatMap((x7) => x7.data).flat(Number.POSITIVE_INFINITY)));
     }
     /**
      * Return a zero-copy sub-section of this Vector.
      * @param start The beginning of the specified portion of the Vector.
      * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
      */
     slice(begin, end) {
-        return new Vector2(clampRange(this, begin, end, ({
+        return new Vector3(clampRange(this, begin, end, ({
             data,
             _offsets
         }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));
     }
     toJSON() {
         return [...this];
     }
@@ -38893,41 +73599,41 @@
      *  more than one chunk, the resulting TypedArray will be a copy of the data from each
      *  chunk's underlying TypedArray values.
      *
      * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
      */
     toArray() {
         const {
-            type: type2,
+            type: type3,
             data,
-            length: length4,
+            length: length7,
             stride,
             ArrayType
         } = this;
-        switch (type2.typeId) {
+        switch (type3.typeId) {
             case Type.Int:
             case Type.Float:
             case Type.Decimal:
             case Type.Time:
             case Type.Timestamp:
                 switch (data.length) {
                     case 0:
                         return new ArrayType();
                     case 1:
-                        return data[0].values.subarray(0, length4 * stride);
+                        return data[0].values.subarray(0, length7 * stride);
                     default:
                         return data.reduce((memo, {
-                            values: values2,
+                            values: values3,
                             length: chunk_length
                         }) => {
-                            memo.array.set(values2.subarray(0, chunk_length * stride), memo.offset);
+                            memo.array.set(values3.subarray(0, chunk_length * stride), memo.offset);
                             memo.offset += chunk_length * stride;
                             return memo;
                         }, {
-                            array: new ArrayType(length4 * stride),
+                            array: new ArrayType(length7 * stride),
                             offset: 0
                         }).array;
                 }
         }
         return [...this];
     }
     /**
@@ -38946,19 +73652,19 @@
         var _b2;
         return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
     }
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      * @param index The index of the child to retrieve.
      */
-    getChildAt(index3) {
-        if (index3 > -1 && index3 < this.numChildren) {
-            return new Vector2(this.data.map(({
-                children: children2
-            }) => children2[index3]));
+    getChildAt(index5) {
+        if (index5 > -1 && index5 < this.numChildren) {
+            return new Vector3(this.data.map(({
+                children: children3
+            }) => children3[index5]));
         }
         return null;
     }
     get isMemoized() {
         if (DataType.isDictionary(this.type)) {
             return this.data[0].dictionary.isMemoized;
         }
@@ -38979,15 +73685,15 @@
         if (DataType.isDictionary(this.type)) {
             const dictionary = new MemoizedVector(this.data[0].dictionary);
             const newData = this.data.map((data) => {
                 const cloned = data.clone();
                 cloned.dictionary = dictionary;
                 return cloned;
             });
-            return new Vector2(newData);
+            return new Vector3(newData);
         }
         return new MemoizedVector(this);
     }
     /**
      * Returns a vector without memoization of the {@link get} method. If this
      * vector is not memoized, this method returns this vector.
      *
@@ -38997,40 +73703,40 @@
         if (DataType.isDictionary(this.type) && this.isMemoized) {
             const dictionary = this.data[0].dictionary.unmemoize();
             const newData = this.data.map((data) => {
                 const newData2 = data.clone();
                 newData2.dictionary = dictionary;
                 return newData2;
             });
-            return new Vector2(newData);
+            return new Vector3(newData);
         }
         return this;
     }
 };
 _a2 = Symbol.toStringTag;
-Vector2[_a2] = ((proto) => {
+Vector3[_a2] = ((proto) => {
     proto.type = DataType.prototype;
     proto.data = [];
     proto.length = 0;
     proto.stride = 1;
     proto.numChildren = 0;
     proto._nullCount = -1;
     proto._byteLength = -1;
     proto._offsets = new Uint32Array([0]);
     proto[Symbol.isConcatSpreadable] = true;
     const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
     for (const typeId of typeIds) {
-        const get3 = instance2.getVisitFnByTypeId(typeId);
-        const set4 = instance.getVisitFnByTypeId(typeId);
-        const indexOf2 = instance3.getVisitFnByTypeId(typeId);
+        const get5 = instance2.getVisitFnByTypeId(typeId);
+        const set7 = instance.getVisitFnByTypeId(typeId);
+        const indexOf3 = instance3.getVisitFnByTypeId(typeId);
         const byteLength = instance5.getVisitFnByTypeId(typeId);
         visitorsByTypeId[typeId] = {
-            get: get3,
-            set: set4,
-            indexOf: indexOf2,
+            get: get5,
+            set: set7,
+            indexOf: indexOf3,
             byteLength
         };
         vectorPrototypesByTypeId[typeId] = Object.create(proto, {
             ["isValid"]: {
                 value: wrapChunkedCall1(isChunkedValid)
             },
             ["get"]: {
@@ -39044,88 +73750,88 @@
             },
             ["getByteLength"]: {
                 value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId))
             }
         });
     }
     return "Vector";
-})(Vector2.prototype);
-var MemoizedVector = class extends Vector2 {
-    constructor(vector2) {
-        super(vector2.data);
-        const get3 = this.get;
-        const set4 = this.set;
-        const slice7 = this.slice;
+})(Vector3.prototype);
+var MemoizedVector = class extends Vector3 {
+    constructor(vector3) {
+        super(vector3.data);
+        const get5 = this.get;
+        const set7 = this.set;
+        const slice13 = this.slice;
         const cache = new Array(this.length);
         Object.defineProperty(this, "get", {
-            value(index3) {
-                const cachedValue = cache[index3];
+            value(index5) {
+                const cachedValue = cache[index5];
                 if (cachedValue !== void 0) {
                     return cachedValue;
                 }
-                const value = get3.call(this, index3);
-                cache[index3] = value;
+                const value = get5.call(this, index5);
+                cache[index5] = value;
                 return value;
             }
         });
         Object.defineProperty(this, "set", {
-            value(index3, value) {
-                set4.call(this, index3, value);
-                cache[index3] = value;
+            value(index5, value) {
+                set7.call(this, index5, value);
+                cache[index5] = value;
             }
         });
         Object.defineProperty(this, "slice", {
-            value: (begin, end) => new MemoizedVector(slice7.call(this, begin, end))
+            value: (begin, end) => new MemoizedVector(slice13.call(this, begin, end))
         });
         Object.defineProperty(this, "isMemoized", {
             value: true
         });
         Object.defineProperty(this, "unmemoize", {
-            value: () => new Vector2(this.data)
+            value: () => new Vector3(this.data)
         });
         Object.defineProperty(this, "memoize", {
             value: () => this
         });
     }
 };
 
-// node_modules/apache-arrow/builder/valid.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/valid.mjs
 function createIsValidFunction(nullValues) {
     if (!nullValues || nullValues.length <= 0) {
         return function isValid(value) {
             return true;
         };
     }
     let fnBody = "";
-    const noNaNs = nullValues.filter((x4) => x4 === x4);
+    const noNaNs = nullValues.filter((x7) => x7 === x7);
     if (noNaNs.length > 0) {
         fnBody = `
-    switch (x) {${noNaNs.map((x4) => `
-        case ${valueToCase(x4)}:`).join("")}
+    switch (x) {${noNaNs.map((x7) => `
+        case ${valueToCase(x7)}:`).join("")}
             return false;
     }`;
     }
     if (nullValues.length !== noNaNs.length) {
         fnBody = `if (x !== x) return false;
 ${fnBody}`;
     }
     return new Function(`x`, `${fnBody}
 return true;`);
 }
 
-function valueToCase(x4) {
-    if (typeof x4 !== "bigint") {
-        return valueToString(x4);
+function valueToCase(x7) {
+    if (typeof x7 !== "bigint") {
+        return valueToString(x7);
     } else if (BigIntAvailable) {
-        return `${valueToString(x4)}n`;
+        return `${valueToString(x7)}n`;
     }
-    return `"${valueToString(x4)}"`;
+    return `"${valueToString(x7)}"`;
 }
 
-// node_modules/apache-arrow/builder/buffer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/buffer.mjs
 var roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
 var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
 var BufferBuilder = class {
     constructor(buffer, stride = 1) {
         this.buffer = buffer;
         this.stride = stride;
         this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
@@ -39138,37 +73844,37 @@
     get reservedLength() {
         return this.buffer.length / this.stride;
     }
     get reservedByteLength() {
         return this.buffer.byteLength;
     }
     // @ts-ignore
-    set(index3, value) {
+    set(index5, value) {
         return this;
     }
     append(value) {
         return this.set(this.length, value);
     }
     reserve(extra) {
         if (extra > 0) {
             this.length += extra;
             const stride = this.stride;
-            const length4 = this.length * stride;
+            const length7 = this.length * stride;
             const reserved = this.buffer.length;
-            if (length4 >= reserved) {
-                this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length4 * 2, this.BYTES_PER_ELEMENT));
+            if (length7 >= reserved) {
+                this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length7 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length7 * 2, this.BYTES_PER_ELEMENT));
             }
         }
         return this;
     }
-    flush(length4 = this.length) {
-        length4 = roundLengthUpToNearest64Bytes(length4 * this.stride, this.BYTES_PER_ELEMENT);
-        const array4 = sliceOrExtendArray(this.buffer, length4);
+    flush(length7 = this.length) {
+        length7 = roundLengthUpToNearest64Bytes(length7 * this.stride, this.BYTES_PER_ELEMENT);
+        const array7 = sliceOrExtendArray(this.buffer, length7);
         this.clear();
-        return array4;
+        return array7;
     }
     clear() {
         this.length = 0;
         this._resize(0);
         return this;
     }
     _resize(newLength) {
@@ -39176,20 +73882,20 @@
     }
 };
 BufferBuilder.prototype.offset = 0;
 var DataBufferBuilder = class extends BufferBuilder {
     last() {
         return this.get(this.length - 1);
     }
-    get(index3) {
-        return this.buffer[index3];
+    get(index5) {
+        return this.buffer[index5];
     }
-    set(index3, value) {
-        this.reserve(index3 - this.length + 1);
-        this.buffer[index3 * this.stride] = value;
+    set(index5, value) {
+        this.reserve(index5 - this.length + 1);
+        this.buffer[index5 * this.stride] = value;
         return this;
     }
 };
 var BitmapBufferBuilder = class extends DataBufferBuilder {
     constructor(data = new Uint8Array(0)) {
         super(data, 1 / 8);
         this.numValid = 0;
@@ -39218,48 +73924,48 @@
 var OffsetsBufferBuilder = class extends DataBufferBuilder {
     constructor(data = new Int32Array(1)) {
         super(data, 1);
     }
     append(value) {
         return this.set(this.length - 1, value);
     }
-    set(index3, value) {
-        const offset2 = this.length - 1;
-        const buffer = this.reserve(index3 - offset2 + 1).buffer;
-        if (offset2 < index3++) {
-            buffer.fill(buffer[offset2], offset2, index3);
+    set(index5, value) {
+        const offset3 = this.length - 1;
+        const buffer = this.reserve(index5 - offset3 + 1).buffer;
+        if (offset3 < index5++) {
+            buffer.fill(buffer[offset3], offset3, index5);
         }
-        buffer[index3] = buffer[index3 - 1] + value;
+        buffer[index5] = buffer[index5 - 1] + value;
         return this;
     }
-    flush(length4 = this.length - 1) {
-        if (length4 > this.length) {
-            this.set(length4 - 1, 0);
+    flush(length7 = this.length - 1) {
+        if (length7 > this.length) {
+            this.set(length7 - 1, 0);
         }
-        return super.flush(length4 + 1);
+        return super.flush(length7 + 1);
     }
 };
 
-// node_modules/apache-arrow/builder.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder.mjs
 var Builder = class {
     /**
      * Construct a builder with the given Arrow DataType with optional null values,
      * which will be interpreted as "null" when set or appended to the `Builder`.
      * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
      */
     constructor({
-        "type": type2,
+        "type": type3,
         "nullValues": nulls
     }) {
         this.length = 0;
         this.finished = false;
-        this.type = type2;
+        this.type = type3;
         this.children = [];
         this.nullValues = nulls;
-        this.stride = strideForType(type2);
+        this.stride = strideForType(type3);
         this._nulls = new BitmapBufferBuilder();
         if (nulls && nulls.length > 0) {
             this._isValid = createIsValidFunction(nulls);
         }
     }
     /** @nocollapse */
     // @ts-ignore
@@ -39272,15 +73978,15 @@
         throw new Error(`"throughDOM" not available in this environment`);
     }
     /**
      * Flush the `Builder` and return a `Vector<T>`.
      * @returns {Vector<T>} A `Vector<T>` of the flushed values.
      */
     toVector() {
-        return new Vector2([this.flush()]);
+        return new Vector3([this.flush()]);
     }
     get ArrayType() {
         return this.type.ArrayType;
     }
     get nullCount() {
         return this._nulls.numInvalid;
     }
@@ -39293,21 +73999,21 @@
     get byteLength() {
         let size = 0;
         const {
             _offsets,
             _values,
             _nulls,
             _typeIds,
-            children: children2
+            children: children3
         } = this;
         _offsets && (size += _offsets.byteLength);
         _values && (size += _values.byteLength);
         _nulls && (size += _nulls.byteLength);
         _typeIds && (size += _typeIds.byteLength);
-        return children2.reduce((size2, child) => size2 + child.byteLength, size);
+        return children3.reduce((size2, child) => size2 + child.byteLength, size);
     }
     /**
      * @returns The aggregate number of rows that have been reserved to write new values.
      */
     get reservedLength() {
         return this._nulls.reservedLength;
     }
@@ -39355,84 +74061,84 @@
      * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
      * the null `BitmapBufferBuilder`, and the value is passed to
      * `Builder.prototype.setValue()`.
      * @param {number} index The index of the value to write.
      * @param {T['TValue'] | TNull } value The value to write at the supplied index.
      * @returns {this} The updated `Builder` instance.
      */
-    set(index3, value) {
-        if (this.setValid(index3, this.isValid(value))) {
-            this.setValue(index3, value);
+    set(index5, value) {
+        if (this.setValid(index5, this.isValid(value))) {
+            this.setValue(index5, value);
         }
         return this;
     }
     /**
      * Write a value to the underlying buffers at the supplied index, bypassing
      * the null-value check. This is a low-level method that
      * @param {number} index
      * @param {T['TValue'] | TNull } value
      */
-    setValue(index3, value) {
-        this._setValue(this, index3, value);
+    setValue(index5, value) {
+        this._setValue(this, index5, value);
     }
-    setValid(index3, valid2) {
-        this.length = this._nulls.set(index3, +valid2).length;
-        return valid2;
+    setValid(index5, valid3) {
+        this.length = this._nulls.set(index5, +valid3).length;
+        return valid3;
     }
     // @ts-ignore
     addChild(child, name = `${this.numChildren}`) {
         throw new Error(`Cannot append children to non-nested type "${this.type}"`);
     }
     /**
      * Retrieve the child `Builder` at the supplied `index`, or null if no child
      * exists at that index.
      * @param {number} index The index of the child `Builder` to retrieve.
      * @returns {Builder | null} The child Builder at the supplied index or null.
      */
-    getChildAt(index3) {
-        return this.children[index3] || null;
+    getChildAt(index5) {
+        return this.children[index5] || null;
     }
     /**
      * Commit all the values that have been written to their underlying
      * ArrayBuffers, including any child Builders if applicable, and reset
      * the internal `Builder` state.
      * @returns A `Data<T>` of the buffers and children representing the values written.
      */
     flush() {
         let data;
         let typeIds;
         let nullBitmap;
         let valueOffsets;
         const {
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
             _typeIds,
             _offsets,
             _values,
             _nulls
         } = this;
-        if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {
-            valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);
-        } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {
+        if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length7)) {
+            valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length7);
+        } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length7)) {
             data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
         } else {
-            data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);
+            data = _values === null || _values === void 0 ? void 0 : _values.flush(length7);
         }
         if (nullCount > 0) {
-            nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);
+            nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length7);
         }
-        const children2 = this.children.map((child) => child.flush());
+        const children3 = this.children.map((child) => child.flush());
         this.clear();
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            children: children2,
-            "child": children2[0],
+            children: children3,
+            "child": children3[0],
             data,
             typeIds,
             nullBitmap,
             valueOffsets
         });
     }
     /**
@@ -39468,36 +74174,36 @@
 Builder.prototype.nullValues = null;
 Builder.prototype._isValid = () => true;
 var FixedWidthBuilder = class extends Builder {
     constructor(opts) {
         super(opts);
         this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
     }
-    setValue(index3, value) {
-        const values2 = this._values;
-        values2.reserve(index3 - values2.length + 1);
-        return super.setValue(index3, value);
+    setValue(index5, value) {
+        const values3 = this._values;
+        values3.reserve(index5 - values3.length + 1);
+        return super.setValue(index5, value);
     }
 };
 var VariableWidthBuilder = class extends Builder {
     constructor(opts) {
         super(opts);
         this._pendingLength = 0;
         this._offsets = new OffsetsBufferBuilder();
     }
-    setValue(index3, value) {
+    setValue(index5, value) {
         const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
-        const current = pending.get(index3);
+        const current = pending.get(index5);
         current && (this._pendingLength -= current.length);
         this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
-        pending.set(index3, value);
+        pending.set(index5, value);
     }
-    setValid(index3, isValid) {
-        if (!super.setValid(index3, isValid)) {
-            (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index3, void 0);
+    setValid(index5, isValid) {
+        if (!super.setValid(index5, isValid)) {
+            (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index5, void 0);
             return false;
         }
         return true;
     }
     clear() {
         this._pendingLength = 0;
         this._pending = void 0;
@@ -39519,23 +74225,23 @@
         if (pending && pending.size > 0) {
             this._flushPending(pending, pendingLength);
         }
         return this;
     }
 };
 
-// node_modules/apache-arrow/fb/block.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/block.mjs
 var Block = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
     /**
      * Index to the start of the RecordBlock (note this is past the Message header)
      */
     offset() {
         return this.bb.readInt64(this.bb_pos);
@@ -39552,37 +74258,37 @@
      */
     bodyLength() {
         return this.bb.readInt64(this.bb_pos + 16);
     }
     static sizeOf() {
         return 24;
     }
-    static createBlock(builder, offset2, metaDataLength, bodyLength) {
+    static createBlock(builder, offset3, metaDataLength, bodyLength) {
         builder.prep(8, 24);
         builder.writeInt64(bodyLength);
         builder.pad(4);
         builder.writeInt32(metaDataLength);
-        builder.writeInt64(offset2);
+        builder.writeInt64(offset3);
         return builder.offset();
     }
 };
 
-// node_modules/flatbuffers/mjs/constants.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/constants.js
 var SIZEOF_SHORT = 2;
 var SIZEOF_INT = 4;
 var FILE_IDENTIFIER_LENGTH = 4;
 var SIZE_PREFIX_LENGTH = 4;
 
-// node_modules/flatbuffers/mjs/utils.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/utils.js
 var int32 = new Int32Array(2);
 var float32 = new Float32Array(int32.buffer);
 var float64 = new Float64Array(int32.buffer);
 var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
 
-// node_modules/flatbuffers/mjs/long.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/long.js
 var Long = class {
     constructor(low, high) {
         this.low = low | 0;
         this.high = high | 0;
     }
     static create(low, high) {
         return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
@@ -39592,22 +74298,22 @@
     }
     equals(other) {
         return this.low == other.low && this.high == other.high;
     }
 };
 Long.ZERO = new Long(0, 0);
 
-// node_modules/flatbuffers/mjs/encoding.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/encoding.js
 var Encoding;
 (function(Encoding2) {
     Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
     Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
 })(Encoding || (Encoding = {}));
 
-// node_modules/flatbuffers/mjs/byte-buffer.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/byte-buffer.js
 var ByteBuffer = class {
     /**
      * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
      */
     constructor(bytes_) {
         this.bytes_ = bytes_;
         this.position_ = 0;
@@ -39632,98 +74338,98 @@
      */
     position() {
         return this.position_;
     }
     /**
      * Set the buffer's position.
      */
-    setPosition(position2) {
-        this.position_ = position2;
+    setPosition(position3) {
+        this.position_ = position3;
     }
     /**
      * Get the buffer's capacity.
      */
     capacity() {
         return this.bytes_.length;
     }
-    readInt8(offset2) {
-        return this.readUint8(offset2) << 24 >> 24;
+    readInt8(offset3) {
+        return this.readUint8(offset3) << 24 >> 24;
     }
-    readUint8(offset2) {
-        return this.bytes_[offset2];
+    readUint8(offset3) {
+        return this.bytes_[offset3];
     }
-    readInt16(offset2) {
-        return this.readUint16(offset2) << 16 >> 16;
+    readInt16(offset3) {
+        return this.readUint16(offset3) << 16 >> 16;
     }
-    readUint16(offset2) {
-        return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;
+    readUint16(offset3) {
+        return this.bytes_[offset3] | this.bytes_[offset3 + 1] << 8;
     }
-    readInt32(offset2) {
-        return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;
+    readInt32(offset3) {
+        return this.bytes_[offset3] | this.bytes_[offset3 + 1] << 8 | this.bytes_[offset3 + 2] << 16 | this.bytes_[offset3 + 3] << 24;
     }
-    readUint32(offset2) {
-        return this.readInt32(offset2) >>> 0;
+    readUint32(offset3) {
+        return this.readInt32(offset3) >>> 0;
     }
-    readInt64(offset2) {
-        return new Long(this.readInt32(offset2), this.readInt32(offset2 + 4));
+    readInt64(offset3) {
+        return new Long(this.readInt32(offset3), this.readInt32(offset3 + 4));
     }
-    readUint64(offset2) {
-        return new Long(this.readUint32(offset2), this.readUint32(offset2 + 4));
+    readUint64(offset3) {
+        return new Long(this.readUint32(offset3), this.readUint32(offset3 + 4));
     }
-    readFloat32(offset2) {
-        int32[0] = this.readInt32(offset2);
+    readFloat32(offset3) {
+        int32[0] = this.readInt32(offset3);
         return float32[0];
     }
-    readFloat64(offset2) {
-        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);
-        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);
+    readFloat64(offset3) {
+        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset3);
+        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset3 + 4);
         return float64[0];
     }
-    writeInt8(offset2, value) {
-        this.bytes_[offset2] = value;
+    writeInt8(offset3, value) {
+        this.bytes_[offset3] = value;
     }
-    writeUint8(offset2, value) {
-        this.bytes_[offset2] = value;
+    writeUint8(offset3, value) {
+        this.bytes_[offset3] = value;
     }
-    writeInt16(offset2, value) {
-        this.bytes_[offset2] = value;
-        this.bytes_[offset2 + 1] = value >> 8;
-    }
-    writeUint16(offset2, value) {
-        this.bytes_[offset2] = value;
-        this.bytes_[offset2 + 1] = value >> 8;
-    }
-    writeInt32(offset2, value) {
-        this.bytes_[offset2] = value;
-        this.bytes_[offset2 + 1] = value >> 8;
-        this.bytes_[offset2 + 2] = value >> 16;
-        this.bytes_[offset2 + 3] = value >> 24;
-    }
-    writeUint32(offset2, value) {
-        this.bytes_[offset2] = value;
-        this.bytes_[offset2 + 1] = value >> 8;
-        this.bytes_[offset2 + 2] = value >> 16;
-        this.bytes_[offset2 + 3] = value >> 24;
-    }
-    writeInt64(offset2, value) {
-        this.writeInt32(offset2, value.low);
-        this.writeInt32(offset2 + 4, value.high);
-    }
-    writeUint64(offset2, value) {
-        this.writeUint32(offset2, value.low);
-        this.writeUint32(offset2 + 4, value.high);
+    writeInt16(offset3, value) {
+        this.bytes_[offset3] = value;
+        this.bytes_[offset3 + 1] = value >> 8;
+    }
+    writeUint16(offset3, value) {
+        this.bytes_[offset3] = value;
+        this.bytes_[offset3 + 1] = value >> 8;
+    }
+    writeInt32(offset3, value) {
+        this.bytes_[offset3] = value;
+        this.bytes_[offset3 + 1] = value >> 8;
+        this.bytes_[offset3 + 2] = value >> 16;
+        this.bytes_[offset3 + 3] = value >> 24;
+    }
+    writeUint32(offset3, value) {
+        this.bytes_[offset3] = value;
+        this.bytes_[offset3 + 1] = value >> 8;
+        this.bytes_[offset3 + 2] = value >> 16;
+        this.bytes_[offset3 + 3] = value >> 24;
+    }
+    writeInt64(offset3, value) {
+        this.writeInt32(offset3, value.low);
+        this.writeInt32(offset3 + 4, value.high);
+    }
+    writeUint64(offset3, value) {
+        this.writeUint32(offset3, value.low);
+        this.writeUint32(offset3 + 4, value.high);
     }
-    writeFloat32(offset2, value) {
+    writeFloat32(offset3, value) {
         float32[0] = value;
-        this.writeInt32(offset2, int32[0]);
+        this.writeInt32(offset3, int32[0]);
     }
-    writeFloat64(offset2, value) {
+    writeFloat64(offset3, value) {
         float64[0] = value;
-        this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);
-        this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);
+        this.writeInt32(offset3, int32[isLittleEndian ? 0 : 1]);
+        this.writeInt32(offset3 + 4, int32[isLittleEndian ? 1 : 0]);
     }
     /**
      * Return the file identifier.   Behavior is undefined for FlatBuffers whose
      * schema does not include a file_identifier (likely points at padding or the
      * start of a the root vtable).
      */
     getBufferIdentifier() {
@@ -39743,16 +74449,16 @@
     __offset(bb_pos, vtable_offset) {
         const vtable = bb_pos - this.readInt32(bb_pos);
         return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
     }
     /**
      * Initialize any Table-derived type to point to the union at the given offset.
      */
-    __union(t, offset2) {
-        t.bb_pos = offset2 + this.readInt32(offset2);
+    __union(t, offset3) {
+        t.bb_pos = offset3 + this.readInt32(offset3);
         t.bb = this;
         return t;
     }
     /**
      * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
      * This allocates a new string and converts to wide chars upon each access.
      *
@@ -39760,39 +74466,39 @@
      * the "optionalEncoding" argument. This is useful for avoiding conversion to
      * and from UTF-16 when the data will just be packaged back up in another
      * FlatBuffer later on.
      *
      * @param offset
      * @param opt_encoding Defaults to UTF16_STRING
      */
-    __string(offset2, opt_encoding) {
-        offset2 += this.readInt32(offset2);
-        const length4 = this.readInt32(offset2);
+    __string(offset3, opt_encoding) {
+        offset3 += this.readInt32(offset3);
+        const length7 = this.readInt32(offset3);
         let result = "";
         let i = 0;
-        offset2 += SIZEOF_INT;
+        offset3 += SIZEOF_INT;
         if (opt_encoding === Encoding.UTF8_BYTES) {
-            return this.bytes_.subarray(offset2, offset2 + length4);
+            return this.bytes_.subarray(offset3, offset3 + length7);
         }
-        while (i < length4) {
+        while (i < length7) {
             let codePoint;
-            const a4 = this.readUint8(offset2 + i++);
-            if (a4 < 192) {
-                codePoint = a4;
+            const a7 = this.readUint8(offset3 + i++);
+            if (a7 < 192) {
+                codePoint = a7;
             } else {
-                const b = this.readUint8(offset2 + i++);
-                if (a4 < 224) {
-                    codePoint = (a4 & 31) << 6 | b & 63;
+                const b = this.readUint8(offset3 + i++);
+                if (a7 < 224) {
+                    codePoint = (a7 & 31) << 6 | b & 63;
                 } else {
-                    const c6 = this.readUint8(offset2 + i++);
-                    if (a4 < 240) {
-                        codePoint = (a4 & 15) << 12 | (b & 63) << 6 | c6 & 63;
+                    const c11 = this.readUint8(offset3 + i++);
+                    if (a7 < 240) {
+                        codePoint = (a7 & 15) << 12 | (b & 63) << 6 | c11 & 63;
                     } else {
-                        const d = this.readUint8(offset2 + i++);
-                        codePoint = (a4 & 7) << 18 | (b & 63) << 12 | (c6 & 63) << 6 | d & 63;
+                        const d = this.readUint8(offset3 + i++);
+                        codePoint = (a7 & 7) << 18 | (b & 63) << 12 | (c11 & 63) << 6 | d & 63;
                     }
                 }
             }
             if (codePoint < 65536) {
                 result += String.fromCharCode(codePoint);
             } else {
                 codePoint -= 65536;
@@ -39804,37 +74510,37 @@
     /**
      * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
      * if a string then return a new one
      *
      * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
      * makes the behaviour of __union_with_string different compared to __union
      */
-    __union_with_string(o, offset2) {
+    __union_with_string(o, offset3) {
         if (typeof o === "string") {
-            return this.__string(offset2);
+            return this.__string(offset3);
         }
-        return this.__union(o, offset2);
+        return this.__union(o, offset3);
     }
     /**
      * Retrieve the relative offset stored at "offset"
      */
-    __indirect(offset2) {
-        return offset2 + this.readInt32(offset2);
+    __indirect(offset3) {
+        return offset3 + this.readInt32(offset3);
     }
     /**
      * Get the start of data of a vector whose offset is stored at "offset" in this object.
      */
-    __vector(offset2) {
-        return offset2 + this.readInt32(offset2) + SIZEOF_INT;
+    __vector(offset3) {
+        return offset3 + this.readInt32(offset3) + SIZEOF_INT;
     }
     /**
      * Get the length of a vector whose offset is stored at "offset" in this object.
      */
-    __vector_len(offset2) {
-        return this.readInt32(offset2 + this.readInt32(offset2));
+    __vector_len(offset3) {
+        return this.readInt32(offset3 + this.readInt32(offset3));
     }
     __has_identifier(ident) {
         if (ident.length != FILE_IDENTIFIER_LENGTH) {
             throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
         }
         for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
             if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
@@ -39875,15 +74581,15 @@
                 ret.push(val.unpack());
             }
         }
         return ret;
     }
 };
 
-// node_modules/flatbuffers/mjs/builder.js
+// js/pyobsplot-js/node_modules/flatbuffers/mjs/builder.js
 var Builder2 = class {
     /**
      * Create a FlatBufferBuilder.
      */
     constructor(opt_initial_size) {
         this.minalign = 1;
         this.vtable = null;
@@ -40124,33 +74830,33 @@
      * @returns A new byte buffer with the old data copied
      * to it. The data is located at the end of the buffer.
      *
      * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
      * it a uint8Array we need to suppress the type check:
      * @suppress {checkTypes}
      */
-    static growByteBuffer(bb2) {
-        const old_buf_size = bb2.capacity();
+    static growByteBuffer(bb3) {
+        const old_buf_size = bb3.capacity();
         if (old_buf_size & 3221225472) {
             throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
         }
         const new_buf_size = old_buf_size << 1;
         const nbb = ByteBuffer.allocate(new_buf_size);
         nbb.setPosition(new_buf_size - old_buf_size);
-        nbb.bytes().set(bb2.bytes(), new_buf_size - old_buf_size);
+        nbb.bytes().set(bb3.bytes(), new_buf_size - old_buf_size);
         return nbb;
     }
     /**
      * Adds on offset, relative to where it will be written.
      *
      * @param offset The offset to add.
      */
-    addOffset(offset2) {
+    addOffset(offset3) {
         this.prep(SIZEOF_INT, 0);
-        this.writeInt32(this.offset() - offset2 + SIZEOF_INT);
+        this.writeInt32(this.offset() - offset3 + SIZEOF_INT);
     }
     /**
      * Start encoding a new object in the buffer.  Users will not usually need to
      * call this directly. The FlatBuffers compiler will generate helper methods
      * that call this method internally.
      */
     startObject(numfields) {
@@ -40239,20 +74945,20 @@
     finishSizePrefixed(root_table, opt_file_identifier) {
         this.finish(root_table, opt_file_identifier, true);
     }
     /**
      * This checks a required field has been set in a given table that has
      * just been constructed.
      */
-    requiredField(table, field2) {
+    requiredField(table, field3) {
         const table_start = this.bb.capacity() - table;
         const vtable_start = table_start - this.bb.readInt32(table_start);
-        const ok = this.bb.readInt16(vtable_start + field2) != 0;
+        const ok = this.bb.readInt16(vtable_start + field3) != 0;
         if (!ok) {
-            throw new Error("FlatBuffers: field " + field2 + " must be set");
+            throw new Error("FlatBuffers: field " + field3 + " must be set");
         }
     }
     /**
      * Start a new array/vector of objects.  Users usually will not call
      * this directly. The FlatBuffers compiler will create a start/end
      * method for vector types in generated code.
      *
@@ -40280,53 +74986,53 @@
     /**
      * Encode the string `s` in the buffer using UTF-8. If the string passed has
      * already been seen, we return the offset of the already written string
      *
      * @param s The string to encode
      * @return The offset in the buffer where the encoded string starts
      */
-    createSharedString(s2) {
-        if (!s2) {
+    createSharedString(s3) {
+        if (!s3) {
             return 0;
         }
         if (!this.string_maps) {
             this.string_maps = /* @__PURE__ */ new Map();
         }
-        if (this.string_maps.has(s2)) {
-            return this.string_maps.get(s2);
+        if (this.string_maps.has(s3)) {
+            return this.string_maps.get(s3);
         }
-        const offset2 = this.createString(s2);
-        this.string_maps.set(s2, offset2);
-        return offset2;
+        const offset3 = this.createString(s3);
+        this.string_maps.set(s3, offset3);
+        return offset3;
     }
     /**
      * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
      * instead of a string, it is assumed to contain valid UTF-8 encoded data.
      *
      * @param s The string to encode
      * @return The offset in the buffer where the encoded string starts
      */
-    createString(s2) {
-        if (!s2) {
+    createString(s3) {
+        if (!s3) {
             return 0;
         }
         let utf8;
-        if (s2 instanceof Uint8Array) {
-            utf8 = s2;
+        if (s3 instanceof Uint8Array) {
+            utf8 = s3;
         } else {
             utf8 = [];
             let i = 0;
-            while (i < s2.length) {
+            while (i < s3.length) {
                 let codePoint;
-                const a4 = s2.charCodeAt(i++);
-                if (a4 < 55296 || a4 >= 56320) {
-                    codePoint = a4;
+                const a7 = s3.charCodeAt(i++);
+                if (a7 < 55296 || a7 >= 56320) {
+                    codePoint = a7;
                 } else {
-                    const b = s2.charCodeAt(i++);
-                    codePoint = (a4 << 10) + b + (65536 - (55296 << 10) - 56320);
+                    const b = s3.charCodeAt(i++);
+                    codePoint = (a7 << 10) + b + (65536 - (55296 << 10) - 56320);
                 }
                 if (codePoint < 128) {
                     utf8.push(codePoint);
                 } else {
                     if (codePoint < 2048) {
                         utf8.push(codePoint >> 6 & 31 | 192);
                     } else {
@@ -40340,16 +75046,16 @@
                     utf8.push(codePoint & 63 | 128);
                 }
             }
         }
         this.addInt8(0);
         this.startVector(1, utf8.length, 1);
         this.bb.setPosition(this.space -= utf8.length);
-        for (let i = 0, offset2 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
-            bytes[offset2++] = utf8[i];
+        for (let i = 0, offset3 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
+            bytes[offset3++] = utf8[i];
         }
         return this.endVector();
     }
     /**
      * A helper function to avoid generated code depending on this file directly.
      */
     createLong(low, high) {
@@ -40390,839 +75096,839 @@
     createStructOffsetList(list, startFunc) {
         startFunc(this, list.length);
         this.createObjectOffsetList(list);
         return this.endVector();
     }
 };
 
-// node_modules/apache-arrow/fb/key-value.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/key-value.mjs
 var KeyValue = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsKeyValue(bb2, obj) {
-        return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsKeyValue(bb3, obj) {
+        return (obj || new KeyValue()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsKeyValue(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsKeyValue(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new KeyValue()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     key(optionalEncoding) {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.__string(this.bb_pos + offset3, optionalEncoding) : null;
     }
     value(optionalEncoding) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.__string(this.bb_pos + offset3, optionalEncoding) : null;
     }
     static startKeyValue(builder) {
         builder.startObject(2);
     }
     static addKey(builder, keyOffset) {
         builder.addFieldOffset(0, keyOffset, 0);
     }
     static addValue(builder, valueOffset) {
         builder.addFieldOffset(1, valueOffset, 0);
     }
     static endKeyValue(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createKeyValue(builder, keyOffset, valueOffset) {
         KeyValue.startKeyValue(builder);
         KeyValue.addKey(builder, keyOffset);
         KeyValue.addValue(builder, valueOffset);
         return KeyValue.endKeyValue(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/metadata-version.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/metadata-version.mjs
 var MetadataVersion2;
 (function(MetadataVersion3) {
     MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
     MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
     MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
     MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
     MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
 })(MetadataVersion2 || (MetadataVersion2 = {}));
 
-// node_modules/apache-arrow/fb/endianness.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/endianness.mjs
 var Endianness;
 (function(Endianness2) {
     Endianness2[Endianness2["Little"] = 0] = "Little";
     Endianness2[Endianness2["Big"] = 1] = "Big";
 })(Endianness || (Endianness = {}));
 
-// node_modules/apache-arrow/fb/dictionary-kind.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/dictionary-kind.mjs
 var DictionaryKind;
 (function(DictionaryKind2) {
     DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
 })(DictionaryKind || (DictionaryKind = {}));
 
-// node_modules/apache-arrow/fb/int.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/int.mjs
 var Int = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsInt(bb2, obj) {
-        return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsInt(bb3, obj) {
+        return (obj || new Int()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsInt(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsInt(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Int()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     bitWidth() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 0;
     }
     isSigned() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? !!this.bb.readInt8(this.bb_pos + offset3) : false;
     }
     static startInt(builder) {
         builder.startObject(2);
     }
     static addBitWidth(builder, bitWidth) {
         builder.addFieldInt32(0, bitWidth, 0);
     }
     static addIsSigned(builder, isSigned) {
         builder.addFieldInt8(1, +isSigned, 0);
     }
     static endInt(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createInt(builder, bitWidth, isSigned) {
         Int.startInt(builder);
         Int.addBitWidth(builder, bitWidth);
         Int.addIsSigned(builder, isSigned);
         return Int.endInt(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/dictionary-encoding.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/dictionary-encoding.mjs
 var DictionaryEncoding = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsDictionaryEncoding(bb2, obj) {
-        return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsDictionaryEncoding(bb3, obj) {
+        return (obj || new DictionaryEncoding()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsDictionaryEncoding(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new DictionaryEncoding()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * The known dictionary id in the application where this data is used. In
      * the file or streaming formats, the dictionary ids are found in the
      * DictionaryBatch messages
      */
     id() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt64(this.bb_pos + offset3) : this.bb.createLong(0, 0);
     }
     /**
      * The dictionary indices are constrained to be non-negative integers. If
      * this field is null, the indices must be signed int32. To maximize
      * cross-language compatibility and performance, implementations are
      * recommended to prefer signed integer types over unsigned integer types
      * and to avoid uint64 indices unless they are required by an application.
      */
     indexType(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset3), this.bb) : null;
     }
     /**
      * By default, dictionaries are not ordered, or the order does not have
      * semantic meaning. In some statistical, applications, dictionary-encoding
      * is used to represent ordered categorical data, and we provide a way to
      * preserve that metadata here
      */
     isOrdered() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? !!this.bb.readInt8(this.bb_pos + offset3) : false;
     }
     dictionaryKind() {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : DictionaryKind.DenseArray;
     }
     static startDictionaryEncoding(builder) {
         builder.startObject(4);
     }
-    static addId(builder, id2) {
-        builder.addFieldInt64(0, id2, builder.createLong(0, 0));
+    static addId(builder, id3) {
+        builder.addFieldInt64(0, id3, builder.createLong(0, 0));
     }
     static addIndexType(builder, indexTypeOffset) {
         builder.addFieldOffset(1, indexTypeOffset, 0);
     }
-    static addIsOrdered(builder, isOrdered2) {
-        builder.addFieldInt8(2, +isOrdered2, 0);
+    static addIsOrdered(builder, isOrdered3) {
+        builder.addFieldInt8(2, +isOrdered3, 0);
     }
     static addDictionaryKind(builder, dictionaryKind) {
         builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
     }
     static endDictionaryEncoding(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
 };
 
-// node_modules/apache-arrow/fb/binary.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/binary.mjs
 var Binary2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsBinary(bb2, obj) {
-        return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsBinary(bb3, obj) {
+        return (obj || new Binary2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsBinary(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsBinary(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Binary2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startBinary(builder) {
         builder.startObject(0);
     }
     static endBinary(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createBinary(builder) {
         Binary2.startBinary(builder);
         return Binary2.endBinary(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/bool.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/bool.mjs
 var Bool2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsBool(bb2, obj) {
-        return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsBool(bb3, obj) {
+        return (obj || new Bool2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsBool(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsBool(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Bool2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startBool(builder) {
         builder.startObject(0);
     }
     static endBool(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createBool(builder) {
         Bool2.startBool(builder);
         return Bool2.endBool(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/date-unit.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/date-unit.mjs
 var DateUnit2;
 (function(DateUnit3) {
     DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
     DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
 })(DateUnit2 || (DateUnit2 = {}));
 
-// node_modules/apache-arrow/fb/date.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/date.mjs
 var Date2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsDate(bb2, obj) {
-        return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsDate(bb3, obj) {
+        return (obj || new Date2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsDate(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsDate(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Date2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     unit() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit2.MILLISECOND;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : DateUnit2.MILLISECOND;
     }
     static startDate(builder) {
         builder.startObject(1);
     }
-    static addUnit(builder, unit3) {
-        builder.addFieldInt16(0, unit3, DateUnit2.MILLISECOND);
+    static addUnit(builder, unit5) {
+        builder.addFieldInt16(0, unit5, DateUnit2.MILLISECOND);
     }
     static endDate(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createDate(builder, unit3) {
+    static createDate(builder, unit5) {
         Date2.startDate(builder);
-        Date2.addUnit(builder, unit3);
+        Date2.addUnit(builder, unit5);
         return Date2.endDate(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/decimal.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/decimal.mjs
 var Decimal2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsDecimal(bb2, obj) {
-        return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsDecimal(bb3, obj) {
+        return (obj || new Decimal2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsDecimal(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsDecimal(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Decimal2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * Total number of decimal digits
      */
     precision() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 0;
     }
     /**
      * Number of digits after the decimal point "."
      */
     scale() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 0;
     }
     /**
      * Number of bits per value. The only accepted widths are 128 and 256.
      * We use bitWidth for consistency with Int::bitWidth.
      */
     bitWidth() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 128;
     }
     static startDecimal(builder) {
         builder.startObject(3);
     }
     static addPrecision(builder, precision) {
         builder.addFieldInt32(0, precision, 0);
     }
-    static addScale(builder, scale3) {
-        builder.addFieldInt32(1, scale3, 0);
+    static addScale(builder, scale5) {
+        builder.addFieldInt32(1, scale5, 0);
     }
     static addBitWidth(builder, bitWidth) {
         builder.addFieldInt32(2, bitWidth, 128);
     }
     static endDecimal(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createDecimal(builder, precision, scale3, bitWidth) {
+    static createDecimal(builder, precision, scale5, bitWidth) {
         Decimal2.startDecimal(builder);
         Decimal2.addPrecision(builder, precision);
-        Decimal2.addScale(builder, scale3);
+        Decimal2.addScale(builder, scale5);
         Decimal2.addBitWidth(builder, bitWidth);
         return Decimal2.endDecimal(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/time-unit.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/time-unit.mjs
 var TimeUnit2;
 (function(TimeUnit3) {
     TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
     TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
     TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
     TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
 })(TimeUnit2 || (TimeUnit2 = {}));
 
-// node_modules/apache-arrow/fb/fixed-size-binary.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/fixed-size-binary.mjs
 var FixedSizeBinary2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsFixedSizeBinary(bb2, obj) {
-        return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsFixedSizeBinary(bb3, obj) {
+        return (obj || new FixedSizeBinary2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsFixedSizeBinary(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new FixedSizeBinary2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * Number of bytes per value
      */
     byteWidth() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 0;
     }
     static startFixedSizeBinary(builder) {
         builder.startObject(1);
     }
     static addByteWidth(builder, byteWidth) {
         builder.addFieldInt32(0, byteWidth, 0);
     }
     static endFixedSizeBinary(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createFixedSizeBinary(builder, byteWidth) {
         FixedSizeBinary2.startFixedSizeBinary(builder);
         FixedSizeBinary2.addByteWidth(builder, byteWidth);
         return FixedSizeBinary2.endFixedSizeBinary(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/fixed-size-list.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/fixed-size-list.mjs
 var FixedSizeList2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsFixedSizeList(bb2, obj) {
-        return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsFixedSizeList(bb3, obj) {
+        return (obj || new FixedSizeList2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsFixedSizeList(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsFixedSizeList(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new FixedSizeList2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * Number of list items per value
      */
     listSize() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 0;
     }
     static startFixedSizeList(builder) {
         builder.startObject(1);
     }
     static addListSize(builder, listSize) {
         builder.addFieldInt32(0, listSize, 0);
     }
     static endFixedSizeList(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createFixedSizeList(builder, listSize) {
         FixedSizeList2.startFixedSizeList(builder);
         FixedSizeList2.addListSize(builder, listSize);
         return FixedSizeList2.endFixedSizeList(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/precision.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/precision.mjs
 var Precision2;
 (function(Precision3) {
     Precision3[Precision3["HALF"] = 0] = "HALF";
     Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
     Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
 })(Precision2 || (Precision2 = {}));
 
-// node_modules/apache-arrow/fb/floating-point.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/floating-point.mjs
 var FloatingPoint = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsFloatingPoint(bb2, obj) {
-        return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsFloatingPoint(bb3, obj) {
+        return (obj || new FloatingPoint()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsFloatingPoint(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsFloatingPoint(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new FloatingPoint()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     precision() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision2.HALF;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : Precision2.HALF;
     }
     static startFloatingPoint(builder) {
         builder.startObject(1);
     }
     static addPrecision(builder, precision) {
         builder.addFieldInt16(0, precision, Precision2.HALF);
     }
     static endFloatingPoint(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createFloatingPoint(builder, precision) {
         FloatingPoint.startFloatingPoint(builder);
         FloatingPoint.addPrecision(builder, precision);
         return FloatingPoint.endFloatingPoint(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/interval-unit.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/interval-unit.mjs
 var IntervalUnit2;
 (function(IntervalUnit3) {
     IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
     IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
     IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
 })(IntervalUnit2 || (IntervalUnit2 = {}));
 
-// node_modules/apache-arrow/fb/interval.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/interval.mjs
 var Interval = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsInterval(bb2, obj) {
-        return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsInterval(bb3, obj) {
+        return (obj || new Interval()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsInterval(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsInterval(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Interval()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     unit() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit2.YEAR_MONTH;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : IntervalUnit2.YEAR_MONTH;
     }
     static startInterval(builder) {
         builder.startObject(1);
     }
-    static addUnit(builder, unit3) {
-        builder.addFieldInt16(0, unit3, IntervalUnit2.YEAR_MONTH);
+    static addUnit(builder, unit5) {
+        builder.addFieldInt16(0, unit5, IntervalUnit2.YEAR_MONTH);
     }
     static endInterval(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createInterval(builder, unit3) {
+    static createInterval(builder, unit5) {
         Interval.startInterval(builder);
-        Interval.addUnit(builder, unit3);
+        Interval.addUnit(builder, unit5);
         return Interval.endInterval(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/list.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/list.mjs
 var List2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsList(bb2, obj) {
-        return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsList(bb3, obj) {
+        return (obj || new List2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsList(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsList(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new List2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startList(builder) {
         builder.startObject(0);
     }
     static endList(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createList(builder) {
         List2.startList(builder);
         return List2.endList(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/map.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/map.mjs
 var Map2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsMap(bb2, obj) {
-        return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsMap(bb3, obj) {
+        return (obj || new Map2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsMap(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsMap(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Map2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * Set to true if the keys within each value are sorted
      */
     keysSorted() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? !!this.bb.readInt8(this.bb_pos + offset3) : false;
     }
     static startMap(builder) {
         builder.startObject(1);
     }
     static addKeysSorted(builder, keysSorted) {
         builder.addFieldInt8(0, +keysSorted, 0);
     }
     static endMap(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createMap(builder, keysSorted) {
         Map2.startMap(builder);
         Map2.addKeysSorted(builder, keysSorted);
         return Map2.endMap(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/null.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/null.mjs
 var Null2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsNull(bb2, obj) {
-        return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsNull(bb3, obj) {
+        return (obj || new Null2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsNull(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsNull(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Null2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startNull(builder) {
         builder.startObject(0);
     }
     static endNull(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createNull(builder) {
         Null2.startNull(builder);
         return Null2.endNull(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/struct_.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/struct_.mjs
 var Struct_ = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsStruct_(bb2, obj) {
-        return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsStruct_(bb3, obj) {
+        return (obj || new Struct_()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsStruct_(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsStruct_(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Struct_()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startStruct_(builder) {
         builder.startObject(0);
     }
     static endStruct_(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createStruct_(builder) {
         Struct_.startStruct_(builder);
         return Struct_.endStruct_(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/time.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/time.mjs
 var Time = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsTime(bb2, obj) {
-        return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsTime(bb3, obj) {
+        return (obj || new Time()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsTime(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsTime(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Time()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     unit() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : TimeUnit2.MILLISECOND;
     }
     bitWidth() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.readInt32(this.bb_pos + offset3) : 32;
     }
     static startTime(builder) {
         builder.startObject(2);
     }
-    static addUnit(builder, unit3) {
-        builder.addFieldInt16(0, unit3, TimeUnit2.MILLISECOND);
+    static addUnit(builder, unit5) {
+        builder.addFieldInt16(0, unit5, TimeUnit2.MILLISECOND);
     }
     static addBitWidth(builder, bitWidth) {
         builder.addFieldInt32(1, bitWidth, 32);
     }
     static endTime(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createTime(builder, unit3, bitWidth) {
+    static createTime(builder, unit5, bitWidth) {
         Time.startTime(builder);
-        Time.addUnit(builder, unit3);
+        Time.addUnit(builder, unit5);
         Time.addBitWidth(builder, bitWidth);
         return Time.endTime(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/timestamp.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/timestamp.mjs
 var Timestamp = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsTimestamp(bb2, obj) {
-        return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsTimestamp(bb3, obj) {
+        return (obj || new Timestamp()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsTimestamp(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsTimestamp(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Timestamp()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     unit() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.SECOND;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : TimeUnit2.SECOND;
     }
     timezone(optionalEncoding) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.__string(this.bb_pos + offset3, optionalEncoding) : null;
     }
     static startTimestamp(builder) {
         builder.startObject(2);
     }
-    static addUnit(builder, unit3) {
-        builder.addFieldInt16(0, unit3, TimeUnit2.SECOND);
+    static addUnit(builder, unit5) {
+        builder.addFieldInt16(0, unit5, TimeUnit2.SECOND);
     }
     static addTimezone(builder, timezoneOffset) {
         builder.addFieldOffset(1, timezoneOffset, 0);
     }
     static endTimestamp(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createTimestamp(builder, unit3, timezoneOffset) {
+    static createTimestamp(builder, unit5, timezoneOffset) {
         Timestamp.startTimestamp(builder);
-        Timestamp.addUnit(builder, unit3);
+        Timestamp.addUnit(builder, unit5);
         Timestamp.addTimezone(builder, timezoneOffset);
         return Timestamp.endTimestamp(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/union-mode.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/union-mode.mjs
 var UnionMode2;
 (function(UnionMode3) {
     UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
     UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
 })(UnionMode2 || (UnionMode2 = {}));
 
-// node_modules/apache-arrow/fb/union.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/union.mjs
 var Union = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsUnion(bb2, obj) {
-        return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsUnion(bb3, obj) {
+        return (obj || new Union()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsUnion(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsUnion(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Union()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     mode() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode2.Sparse;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : UnionMode2.Sparse;
     }
-    typeIds(index3) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index3 * 4) : 0;
+    typeIds(index5) {
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset3) + index5 * 4) : 0;
     }
     typeIdsLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     typeIdsArray() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset3), this.bb.__vector_len(this.bb_pos + offset3)) : null;
     }
     static startUnion(builder) {
         builder.startObject(2);
     }
-    static addMode(builder, mode2) {
-        builder.addFieldInt16(0, mode2, UnionMode2.Sparse);
+    static addMode(builder, mode3) {
+        builder.addFieldInt16(0, mode3, UnionMode2.Sparse);
     }
     static addTypeIds(builder, typeIdsOffset) {
         builder.addFieldOffset(1, typeIdsOffset, 0);
     }
     static createTypeIdsVector(builder, data) {
         builder.startVector(4, data.length, 4);
         for (let i = data.length - 1; i >= 0; i--) {
@@ -41230,57 +75936,57 @@
         }
         return builder.endVector();
     }
     static startTypeIdsVector(builder, numElems) {
         builder.startVector(4, numElems, 4);
     }
     static endUnion(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static createUnion(builder, mode2, typeIdsOffset) {
+    static createUnion(builder, mode3, typeIdsOffset) {
         Union.startUnion(builder);
-        Union.addMode(builder, mode2);
+        Union.addMode(builder, mode3);
         Union.addTypeIds(builder, typeIdsOffset);
         return Union.endUnion(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/utf8.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/utf8.mjs
 var Utf82 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsUtf8(bb2, obj) {
-        return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsUtf8(bb3, obj) {
+        return (obj || new Utf82()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsUtf8(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsUtf8(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Utf82()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     static startUtf8(builder) {
         builder.startObject(0);
     }
     static endUtf8(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createUtf8(builder) {
         Utf82.startUtf8(builder);
         return Utf82.endUtf8(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/type.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/type.mjs
 var Type2;
 (function(Type3) {
     Type3[Type3["NONE"] = 0] = "NONE";
     Type3[Type3["Null"] = 1] = "Null";
     Type3[Type3["Int"] = 2] = "Int";
     Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
     Type3[Type3["Binary"] = 4] = "Binary";
@@ -41299,84 +76005,84 @@
     Type3[Type3["Map"] = 17] = "Map";
     Type3[Type3["Duration"] = 18] = "Duration";
     Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
     Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
     Type3[Type3["LargeList"] = 21] = "LargeList";
 })(Type2 || (Type2 = {}));
 
-// node_modules/apache-arrow/fb/field.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/field.mjs
 var Field = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsField(bb2, obj) {
-        return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsField(bb3, obj) {
+        return (obj || new Field()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsField(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsField(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Field()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     name(optionalEncoding) {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.__string(this.bb_pos + offset3, optionalEncoding) : null;
     }
     /**
      * Whether or not this field can contain nulls. Should be true in general.
      */
     nullable() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? !!this.bb.readInt8(this.bb_pos + offset3) : false;
     }
     typeType() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type2.NONE;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.readUint8(this.bb_pos + offset3) : Type2.NONE;
     }
     /**
      * This is the type of the decoded value if the field is dictionary encoded.
      */
     // @ts-ignore
     type(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.__union(obj, this.bb_pos + offset3) : null;
     }
     /**
      * Present only if the field is dictionary encoded.
      */
     dictionary(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 12);
-        return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 12);
+        return offset3 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset3), this.bb) : null;
     }
     /**
      * children apply only to nested data types like Struct, List and Union. For
      * primitive types children will have length 0.
      */
-    children(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 14);
-        return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    children(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 14);
+        return offset3 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     childrenLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 14);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 14);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     /**
      * User-defined metadata
      */
-    customMetadata(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 16);
-        return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    customMetadata(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 16);
+        return offset3 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     customMetadataLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 16);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 16);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     static startField(builder) {
         builder.startObject(7);
     }
     static addName(builder, nameOffset) {
         builder.addFieldOffset(0, nameOffset, 0);
     }
@@ -41415,72 +76121,72 @@
         }
         return builder.endVector();
     }
     static startCustomMetadataVector(builder, numElems) {
         builder.startVector(4, numElems, 4);
     }
     static endField(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
 };
 
-// node_modules/apache-arrow/fb/schema.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/schema.mjs
 var Schema = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsSchema(bb2, obj) {
-        return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsSchema(bb3, obj) {
+        return (obj || new Schema()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsSchema(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsSchema(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Schema()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * endianness of the buffer
      * it is Little Endian by default
      * if endianness doesn't match the underlying system then the vectors need to be converted
      */
     endianness() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : Endianness.Little;
     }
-    fields(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    fields(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     fieldsLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
-    customMetadata(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    customMetadata(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     customMetadataLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     /**
      * Features used in the stream/file.
      */
-    features(index3) {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index3 * 8) : this.bb.createLong(0, 0);
+    features(index5) {
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset3) + index5 * 8) : this.bb.createLong(0, 0);
     }
     featuresLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     static startSchema(builder) {
         builder.startObject(4);
     }
     static addEndianness(builder, endianness) {
         builder.addFieldInt16(0, endianness, Endianness.Little);
     }
@@ -41520,85 +76226,85 @@
         }
         return builder.endVector();
     }
     static startFeaturesVector(builder, numElems) {
         builder.startVector(8, numElems, 8);
     }
     static endSchema(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static finishSchemaBuffer(builder, offset2) {
-        builder.finish(offset2);
+    static finishSchemaBuffer(builder, offset3) {
+        builder.finish(offset3);
     }
-    static finishSizePrefixedSchemaBuffer(builder, offset2) {
-        builder.finish(offset2, void 0, true);
+    static finishSizePrefixedSchemaBuffer(builder, offset3) {
+        builder.finish(offset3, void 0, true);
     }
     static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
         Schema.startSchema(builder);
         Schema.addEndianness(builder, endianness);
         Schema.addFields(builder, fieldsOffset);
         Schema.addCustomMetadata(builder, customMetadataOffset);
         Schema.addFeatures(builder, featuresOffset);
         return Schema.endSchema(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/footer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/footer.mjs
 var Footer = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsFooter(bb2, obj) {
-        return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsFooter(bb3, obj) {
+        return (obj || new Footer()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsFooter(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsFooter(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Footer()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     version() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : MetadataVersion2.V1;
     }
     schema(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset3), this.bb) : null;
     }
-    dictionaries(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;
+    dictionaries(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset3) + index5 * 24, this.bb) : null;
     }
     dictionariesLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
-    recordBatches(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;
+    recordBatches(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset3) + index5 * 24, this.bb) : null;
     }
     recordBatchesLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     /**
      * User-defined metadata
      */
-    customMetadata(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 12);
-        return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    customMetadata(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 12);
+        return offset3 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     customMetadataLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 12);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 12);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     static startFooter(builder) {
         builder.startObject(5);
     }
     static addVersion(builder, version) {
         builder.addFieldInt16(0, version, MetadataVersion2.V1);
     }
@@ -41627,26 +76333,26 @@
         }
         return builder.endVector();
     }
     static startCustomMetadataVector(builder, numElems) {
         builder.startVector(4, numElems, 4);
     }
     static endFooter(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static finishFooterBuffer(builder, offset2) {
-        builder.finish(offset2);
+    static finishFooterBuffer(builder, offset3) {
+        builder.finish(offset3);
     }
-    static finishSizePrefixedFooterBuffer(builder, offset2) {
-        builder.finish(offset2, void 0, true);
+    static finishSizePrefixedFooterBuffer(builder, offset3) {
+        builder.finish(offset3, void 0, true);
     }
 };
 
-// node_modules/apache-arrow/schema.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/schema.mjs
 var Schema2 = class {
     constructor(fields = [], metadata, dictionaries) {
         this.fields = fields || [];
         this.metadata = metadata || /* @__PURE__ */ new Map();
         if (!dictionaries) {
             dictionaries = generateDictionaryMap(fields);
         }
@@ -41696,81 +76402,81 @@
         return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
     }
 };
 Schema2.prototype.fields = null;
 Schema2.prototype.metadata = null;
 Schema2.prototype.dictionaries = null;
 var Field2 = class {
-    constructor(name, type2, nullable = false, metadata) {
+    constructor(name, type3, nullable = false, metadata) {
         this.name = name;
-        this.type = type2;
+        this.type = type3;
         this.nullable = nullable;
         this.metadata = metadata || /* @__PURE__ */ new Map();
     }
     /** @nocollapse */
     static new(...args) {
-        let [name, type2, nullable, metadata] = args;
+        let [name, type3, nullable, metadata] = args;
         if (args[0] && typeof args[0] === "object") {
             ({
                 name
             } = args[0]);
-            type2 === void 0 && (type2 = args[0].type);
+            type3 === void 0 && (type3 = args[0].type);
             nullable === void 0 && (nullable = args[0].nullable);
             metadata === void 0 && (metadata = args[0].metadata);
         }
-        return new Field2(`${name}`, type2, nullable, metadata);
+        return new Field2(`${name}`, type3, nullable, metadata);
     }
     get typeId() {
         return this.type.typeId;
     }
     get[Symbol.toStringTag]() {
         return "Field";
     }
     toString() {
         return `${this.name}: ${this.type}`;
     }
     clone(...args) {
-        let [name, type2, nullable, metadata] = args;
-        !args[0] || typeof args[0] !== "object" ? [name = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : {
+        let [name, type3, nullable, metadata] = args;
+        !args[0] || typeof args[0] !== "object" ? [name = this.name, type3 = this.type, nullable = this.nullable, metadata = this.metadata] = args : {
             name = this.name,
-            type: type2 = this.type,
+            type: type3 = this.type,
             nullable = this.nullable,
             metadata = this.metadata
         } = args[0];
-        return Field2.new(name, type2, nullable, metadata);
+        return Field2.new(name, type3, nullable, metadata);
     }
 };
 Field2.prototype.type = null;
 Field2.prototype.name = null;
 Field2.prototype.nullable = null;
 Field2.prototype.metadata = null;
 
 function mergeMaps(m1, m22) {
     return new Map([...m1 || /* @__PURE__ */ new Map(), ...m22 || /* @__PURE__ */ new Map()]);
 }
 
 function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
     for (let i = -1, n = fields.length; ++i < n;) {
-        const field2 = fields[i];
-        const type2 = field2.type;
-        if (DataType.isDictionary(type2)) {
-            if (!dictionaries.has(type2.id)) {
-                dictionaries.set(type2.id, type2.dictionary);
-            } else if (dictionaries.get(type2.id) !== type2.dictionary) {
+        const field3 = fields[i];
+        const type3 = field3.type;
+        if (DataType.isDictionary(type3)) {
+            if (!dictionaries.has(type3.id)) {
+                dictionaries.set(type3.id, type3.dictionary);
+            } else if (dictionaries.get(type3.id) !== type3.dictionary) {
                 throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
             }
         }
-        if (type2.children && type2.children.length > 0) {
-            generateDictionaryMap(type2.children, dictionaries);
+        if (type3.children && type3.children.length > 0) {
+            generateDictionaryMap(type3.children, dictionaries);
         }
     }
     return dictionaries;
 }
 
-// node_modules/apache-arrow/ipc/metadata/file.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/metadata/file.mjs
 var Long2 = Long;
 var Builder3 = Builder2;
 var ByteBuffer2 = ByteBuffer;
 var Footer_ = class {
     constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {
         this.schema = schema;
         this.version = version;
@@ -41822,73 +76528,73 @@
         * dictionaryBatches() {
             for (let block, i = -1, n = this.numDictionaries; ++i < n;) {
                 if (block = this.getDictionaryBatch(i)) {
                     yield block;
                 }
             }
         }
-    getRecordBatch(index3) {
-        return index3 >= 0 && index3 < this.numRecordBatches && this._recordBatches[index3] || null;
+    getRecordBatch(index5) {
+        return index5 >= 0 && index5 < this.numRecordBatches && this._recordBatches[index5] || null;
     }
-    getDictionaryBatch(index3) {
-        return index3 >= 0 && index3 < this.numDictionaries && this._dictionaryBatches[index3] || null;
+    getDictionaryBatch(index5) {
+        return index5 >= 0 && index5 < this.numDictionaries && this._dictionaryBatches[index5] || null;
     }
 };
 var OffHeapFooter = class extends Footer_ {
     constructor(schema, _footer) {
         super(schema, _footer.version());
         this._footer = _footer;
     }
     get numRecordBatches() {
         return this._footer.recordBatchesLength();
     }
     get numDictionaries() {
         return this._footer.dictionariesLength();
     }
-    getRecordBatch(index3) {
-        if (index3 >= 0 && index3 < this.numRecordBatches) {
-            const fileBlock = this._footer.recordBatches(index3);
+    getRecordBatch(index5) {
+        if (index5 >= 0 && index5 < this.numRecordBatches) {
+            const fileBlock = this._footer.recordBatches(index5);
             if (fileBlock) {
                 return FileBlock.decode(fileBlock);
             }
         }
         return null;
     }
-    getDictionaryBatch(index3) {
-        if (index3 >= 0 && index3 < this.numDictionaries) {
-            const fileBlock = this._footer.dictionaries(index3);
+    getDictionaryBatch(index5) {
+        if (index5 >= 0 && index5 < this.numDictionaries) {
+            const fileBlock = this._footer.dictionaries(index5);
             if (fileBlock) {
                 return FileBlock.decode(fileBlock);
             }
         }
         return null;
     }
 };
 var FileBlock = class {
-    constructor(metaDataLength, bodyLength, offset2) {
+    constructor(metaDataLength, bodyLength, offset3) {
         this.metaDataLength = metaDataLength;
-        this.offset = typeof offset2 === "number" ? offset2 : offset2.low;
+        this.offset = typeof offset3 === "number" ? offset3 : offset3.low;
         this.bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
     }
     /** @nocollapse */
     static decode(block) {
         return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
     }
     /** @nocollapse */
     static encode(b, fileBlock) {
         const {
             metaDataLength
         } = fileBlock;
-        const offset2 = new Long2(fileBlock.offset, 0);
+        const offset3 = new Long2(fileBlock.offset, 0);
         const bodyLength = new Long2(fileBlock.bodyLength, 0);
-        return Block.createBlock(b, offset2, metaDataLength, bodyLength);
+        return Block.createBlock(b, offset3, metaDataLength, bodyLength);
     }
 };
 
-// node_modules/apache-arrow/io/interfaces.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/interfaces.mjs
 var ITERATOR_DONE = Object.freeze({
     done: true,
     value: void 0
 });
 var ArrowJSON = class {
     constructor(_json) {
         this._json = _json;
@@ -42025,15 +76731,15 @@
         if (this._closedPromiseResolve) {
             return true;
         }
         throw new Error(`AsyncQueue is closed`);
     }
 };
 
-// node_modules/apache-arrow/io/stream.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/stream.mjs
 var AsyncByteQueue = class extends AsyncQueue {
     write(value) {
         if ((value = toUint8Array(value)).byteLength > 0) {
             return super.write(value);
         }
     }
     toString(sync = false) {
@@ -42100,15 +76806,15 @@
                 this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
             } else if (isReadableNodeStream(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
             } else if (isReadableDOMStream(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
             } else if (isFetchResponse(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
-            } else if (isIterable2(source)) {
+            } else if (isIterable3(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
             } else if (isPromise(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
             } else if (isAsyncIterable(source)) {
                 this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
             }
         }
@@ -42208,52 +76914,52 @@
             this._closedPromiseResolve && this._closedPromiseResolve();
             this._closedPromiseResolve = void 0;
             return Object.create(result);
         });
     }
 };
 
-// node_modules/apache-arrow/io/file.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/file.mjs
 var RandomAccessFile = class extends ByteStream {
     constructor(buffer, byteLength) {
         super();
         this.position = 0;
         this.buffer = toUint8Array(buffer);
         this.size = typeof byteLength === "undefined" ? this.buffer.byteLength : byteLength;
     }
-    readInt32(position2) {
+    readInt32(position3) {
         const {
             buffer,
             byteOffset
-        } = this.readAt(position2, 4);
+        } = this.readAt(position3, 4);
         return new DataView(buffer, byteOffset).getInt32(0, true);
     }
-    seek(position2) {
-        this.position = Math.min(position2, this.size);
-        return position2 < this.size;
+    seek(position3) {
+        this.position = Math.min(position3, this.size);
+        return position3 < this.size;
     }
     read(nBytes) {
         const {
             buffer,
             size,
-            position: position2
+            position: position3
         } = this;
-        if (buffer && position2 < size) {
+        if (buffer && position3 < size) {
             if (typeof nBytes !== "number") {
                 nBytes = Number.POSITIVE_INFINITY;
             }
-            this.position = Math.min(size, position2 + Math.min(size - position2, nBytes));
-            return buffer.subarray(position2, this.position);
+            this.position = Math.min(size, position3 + Math.min(size - position3, nBytes));
+            return buffer.subarray(position3, this.position);
         }
         return null;
     }
-    readAt(position2, nBytes) {
+    readAt(position3, nBytes) {
         const buf = this.buffer;
-        const end = Math.min(this.size, position2 + nBytes);
-        return buf ? buf.subarray(position2, end) : new Uint8Array(nBytes);
+        const end = Math.min(this.size, position3 + nBytes);
+        return buf ? buf.subarray(position3, end) : new Uint8Array(nBytes);
     }
     close() {
         this.buffer && (this.buffer = null);
     }
     throw (value) {
         this.close();
         return {
@@ -42279,68 +76985,68 @@
         } else {
             this._pending = (() => __awaiter(this, void 0, void 0, function*() {
                 this.size = (yield file.stat()).size;
                 delete this._pending;
             }))();
         }
     }
-    readInt32(position2) {
+    readInt32(position3) {
         return __awaiter(this, void 0, void 0, function*() {
             const {
                 buffer,
                 byteOffset
-            } = yield this.readAt(position2, 4);
+            } = yield this.readAt(position3, 4);
             return new DataView(buffer, byteOffset).getInt32(0, true);
         });
     }
-    seek(position2) {
+    seek(position3) {
         return __awaiter(this, void 0, void 0, function*() {
             this._pending && (yield this._pending);
-            this.position = Math.min(position2, this.size);
-            return position2 < this.size;
+            this.position = Math.min(position3, this.size);
+            return position3 < this.size;
         });
     }
     read(nBytes) {
         return __awaiter(this, void 0, void 0, function*() {
             this._pending && (yield this._pending);
             const {
                 _handle: file,
                 size,
-                position: position2
+                position: position3
             } = this;
-            if (file && position2 < size) {
+            if (file && position3 < size) {
                 if (typeof nBytes !== "number") {
                     nBytes = Number.POSITIVE_INFINITY;
                 }
-                let pos = position2,
-                    offset2 = 0,
+                let pos = position3,
+                    offset3 = 0,
                     bytesRead = 0;
                 const end = Math.min(size, pos + Math.min(size - pos, nBytes));
                 const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
-                while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {
+                while ((pos += bytesRead) < end && (offset3 += bytesRead) < buffer.byteLength) {
                     ({
                         bytesRead
-                    } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));
+                    } = yield file.read(buffer, offset3, buffer.byteLength - offset3, pos));
                 }
                 return buffer;
             }
             return null;
         });
     }
-    readAt(position2, nBytes) {
+    readAt(position3, nBytes) {
         return __awaiter(this, void 0, void 0, function*() {
             this._pending && (yield this._pending);
             const {
                 _handle: file,
                 size
             } = this;
-            if (file && position2 + nBytes < size) {
-                const end = Math.min(size, position2 + nBytes);
-                const buffer = new Uint8Array(end - position2);
-                return (yield file.read(buffer, 0, nBytes, position2)).buffer;
+            if (file && position3 + nBytes < size) {
+                const end = Math.min(size, position3 + nBytes);
+                const buffer = new Uint8Array(end - position3);
+                return (yield file.read(buffer, 0, nBytes, position3)).buffer;
             }
             return new Uint8Array(nBytes);
         });
     }
     close() {
         return __awaiter(this, void 0, void 0, function*() {
             const f = this._handle;
@@ -42364,15 +77070,15 @@
                 done: true,
                 value
             };
         });
     }
 };
 
-// node_modules/apache-arrow/util/int.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/int.mjs
 var int_exports = {};
 __export(int_exports, {
     BaseInt64: () => BaseInt64,
     Int128: () => Int128,
     Int64: () => Int642,
     Uint64: () => Uint642
 });
@@ -42417,33 +77123,33 @@
             other.buffer[1] >>> 16,
             other.buffer[1] & 65535,
             other.buffer[0] >>> 16,
             other.buffer[0] & 65535
         ]);
         let product = L[3] * R[3];
         this.buffer[0] = product & 65535;
-        let sum5 = product >>> 16;
+        let sum8 = product >>> 16;
         product = L[2] * R[3];
-        sum5 += product;
+        sum8 += product;
         product = L[3] * R[2] >>> 0;
-        sum5 += product;
-        this.buffer[0] += sum5 << 16;
-        this.buffer[1] = sum5 >>> 0 < product ? carryBit16 : 0;
-        this.buffer[1] += sum5 >>> 16;
+        sum8 += product;
+        this.buffer[0] += sum8 << 16;
+        this.buffer[1] = sum8 >>> 0 < product ? carryBit16 : 0;
+        this.buffer[1] += sum8 >>> 16;
         this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
         this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
         return this;
     }
     _plus(other) {
-        const sum5 = this.buffer[0] + other.buffer[0] >>> 0;
+        const sum8 = this.buffer[0] + other.buffer[0] >>> 0;
         this.buffer[1] += other.buffer[1];
-        if (sum5 < this.buffer[0] >>> 0) {
+        if (sum8 < this.buffer[0] >>> 0) {
             ++this.buffer[1];
         }
-        this.buffer[0] = sum5;
+        this.buffer[0] = sum8;
     }
     lessThan(other) {
         return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
     }
     equals(other) {
         return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
     }
@@ -42469,43 +77175,43 @@
     }
     /** @nocollapse */
     static fromNumber(num, out_buffer = new Uint32Array(2)) {
         return Uint642.fromString(num.toString(), out_buffer);
     }
     /** @nocollapse */
     static fromString(str, out_buffer = new Uint32Array(2)) {
-        const length4 = str.length;
+        const length7 = str.length;
         const out = new Uint642(out_buffer);
-        for (let posn = 0; posn < length4;) {
-            const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
-            const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
-            const multiple = new Uint642(new Uint32Array([kPowersOfTen[group3], 0]));
+        for (let posn = 0; posn < length7;) {
+            const group5 = kInt32DecimalDigits < length7 - posn ? kInt32DecimalDigits : length7 - posn;
+            const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group5), 10), 0]));
+            const multiple = new Uint642(new Uint32Array([kPowersOfTen[group5], 0]));
             out.times(multiple);
             out.plus(chunk);
-            posn += group3;
+            posn += group5;
         }
         return out;
     }
     /** @nocollapse */
-    static convertArray(values2) {
-        const data = new Uint32Array(values2.length * 2);
-        for (let i = -1, n = values2.length; ++i < n;) {
-            Uint642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
+    static convertArray(values3) {
+        const data = new Uint32Array(values3.length * 2);
+        for (let i = -1, n = values3.length; ++i < n;) {
+            Uint642.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
         }
         return data;
     }
     /** @nocollapse */
-    static multiply(left2, right2) {
-        const rtrn = new Uint642(new Uint32Array(left2.buffer));
-        return rtrn.times(right2);
+    static multiply(left3, right3) {
+        const rtrn = new Uint642(new Uint32Array(left3.buffer));
+        return rtrn.times(right3);
     }
     /** @nocollapse */
-    static add(left2, right2) {
-        const rtrn = new Uint642(new Uint32Array(left2.buffer));
-        return rtrn.plus(right2);
+    static add(left3, right3) {
+        const rtrn = new Uint642(new Uint32Array(left3.buffer));
+        return rtrn.plus(right3);
     }
 };
 var Int642 = class extends BaseInt64 {
     negate() {
         this.buffer[0] = ~this.buffer[0] + 1;
         this.buffer[1] = ~this.buffer[1];
         if (this.buffer[0] == 0) {
@@ -42532,44 +77238,44 @@
     }
     /** @nocollapse */
     static fromNumber(num, out_buffer = new Uint32Array(2)) {
         return Int642.fromString(num.toString(), out_buffer);
     }
     /** @nocollapse */
     static fromString(str, out_buffer = new Uint32Array(2)) {
-        const negate2 = str.startsWith("-");
-        const length4 = str.length;
+        const negate3 = str.startsWith("-");
+        const length7 = str.length;
         const out = new Int642(out_buffer);
-        for (let posn = negate2 ? 1 : 0; posn < length4;) {
-            const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
-            const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
-            const multiple = new Int642(new Uint32Array([kPowersOfTen[group3], 0]));
+        for (let posn = negate3 ? 1 : 0; posn < length7;) {
+            const group5 = kInt32DecimalDigits < length7 - posn ? kInt32DecimalDigits : length7 - posn;
+            const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group5), 10), 0]));
+            const multiple = new Int642(new Uint32Array([kPowersOfTen[group5], 0]));
             out.times(multiple);
             out.plus(chunk);
-            posn += group3;
+            posn += group5;
         }
-        return negate2 ? out.negate() : out;
+        return negate3 ? out.negate() : out;
     }
     /** @nocollapse */
-    static convertArray(values2) {
-        const data = new Uint32Array(values2.length * 2);
-        for (let i = -1, n = values2.length; ++i < n;) {
-            Int642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
+    static convertArray(values3) {
+        const data = new Uint32Array(values3.length * 2);
+        for (let i = -1, n = values3.length; ++i < n;) {
+            Int642.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
         }
         return data;
     }
     /** @nocollapse */
-    static multiply(left2, right2) {
-        const rtrn = new Int642(new Uint32Array(left2.buffer));
-        return rtrn.times(right2);
+    static multiply(left3, right3) {
+        const rtrn = new Int642(new Uint32Array(left3.buffer));
+        return rtrn.times(right3);
     }
     /** @nocollapse */
-    static add(left2, right2) {
-        const rtrn = new Int642(new Uint32Array(left2.buffer));
-        return rtrn.plus(right2);
+    static add(left3, right3) {
+        const rtrn = new Int642(new Uint32Array(left3.buffer));
+        return rtrn.plus(right3);
     }
 };
 var Int128 = class {
     constructor(buffer) {
         this.buffer = buffer;
     }
     high() {
@@ -42601,22 +77307,22 @@
         const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
         const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
         const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
         const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
         const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
         let product = Uint642.multiply(L3, R3);
         this.buffer[0] = product.low();
-        const sum5 = new Uint642(new Uint32Array([product.high(), 0]));
+        const sum8 = new Uint642(new Uint32Array([product.high(), 0]));
         product = Uint642.multiply(L2, R3);
-        sum5.plus(product);
+        sum8.plus(product);
         product = Uint642.multiply(L3, R2);
-        sum5.plus(product);
-        this.buffer[1] = sum5.low();
-        this.buffer[3] = sum5.lessThan(product) ? 1 : 0;
-        this.buffer[2] = sum5.high();
+        sum8.plus(product);
+        this.buffer[1] = sum8.low();
+        this.buffer[3] = sum8.lessThan(product) ? 1 : 0;
+        this.buffer[2] = sum8.high();
         const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
         high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
         this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
         return this;
     }
     plus(other) {
         const sums = new Uint32Array(4);
@@ -42639,449 +77345,449 @@
         this.buffer[0] = sums[0];
         return this;
     }
     hex() {
         return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
     }
     /** @nocollapse */
-    static multiply(left2, right2) {
-        const rtrn = new Int128(new Uint32Array(left2.buffer));
-        return rtrn.times(right2);
+    static multiply(left3, right3) {
+        const rtrn = new Int128(new Uint32Array(left3.buffer));
+        return rtrn.times(right3);
     }
     /** @nocollapse */
-    static add(left2, right2) {
-        const rtrn = new Int128(new Uint32Array(left2.buffer));
-        return rtrn.plus(right2);
+    static add(left3, right3) {
+        const rtrn = new Int128(new Uint32Array(left3.buffer));
+        return rtrn.plus(right3);
     }
     /** @nocollapse */
     static from(val, out_buffer = new Uint32Array(4)) {
         return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
     }
     /** @nocollapse */
     static fromNumber(num, out_buffer = new Uint32Array(4)) {
         return Int128.fromString(num.toString(), out_buffer);
     }
     /** @nocollapse */
     static fromString(str, out_buffer = new Uint32Array(4)) {
-        const negate2 = str.startsWith("-");
-        const length4 = str.length;
+        const negate3 = str.startsWith("-");
+        const length7 = str.length;
         const out = new Int128(out_buffer);
-        for (let posn = negate2 ? 1 : 0; posn < length4;) {
-            const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
-            const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));
-            const multiple = new Int128(new Uint32Array([kPowersOfTen[group3], 0, 0, 0]));
+        for (let posn = negate3 ? 1 : 0; posn < length7;) {
+            const group5 = kInt32DecimalDigits < length7 - posn ? kInt32DecimalDigits : length7 - posn;
+            const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group5), 10), 0, 0, 0]));
+            const multiple = new Int128(new Uint32Array([kPowersOfTen[group5], 0, 0, 0]));
             out.times(multiple);
             out.plus(chunk);
-            posn += group3;
+            posn += group5;
         }
-        return negate2 ? out.negate() : out;
+        return negate3 ? out.negate() : out;
     }
     /** @nocollapse */
-    static convertArray(values2) {
-        const data = new Uint32Array(values2.length * 4);
-        for (let i = -1, n = values2.length; ++i < n;) {
-            Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
+    static convertArray(values3) {
+        const data = new Uint32Array(values3.length * 4);
+        for (let i = -1, n = values3.length; ++i < n;) {
+            Int128.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
         }
         return data;
     }
 };
 
-// node_modules/apache-arrow/visitor/vectorloader.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/vectorloader.mjs
 var VectorLoader = class extends Visitor {
     constructor(bytes, nodes, buffers, dictionaries) {
         super();
         this.nodesIndex = -1;
         this.buffersIndex = -1;
         this.bytes = bytes;
         this.nodes = nodes;
         this.buffers = buffers;
         this.dictionaries = dictionaries;
     }
     visit(node) {
         return super.visit(node instanceof Field2 ? node.type : node);
     }
-    visitNull(type2, {
-        length: length4
+    visitNull(type3, {
+        length: length7
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4
+            type: type3,
+            length: length7
         });
     }
-    visitBool(type2, {
-        length: length4,
+    visitBool(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitInt(type2, {
-        length: length4,
+    visitInt(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitFloat(type2, {
-        length: length4,
+    visitFloat(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitUtf8(type2, {
-        length: length4,
+    visitUtf8(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            valueOffsets: this.readOffsets(type2),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            valueOffsets: this.readOffsets(type3),
+            data: this.readData(type3)
         });
     }
-    visitBinary(type2, {
-        length: length4,
+    visitBinary(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            valueOffsets: this.readOffsets(type2),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            valueOffsets: this.readOffsets(type3),
+            data: this.readData(type3)
         });
     }
-    visitFixedSizeBinary(type2, {
-        length: length4,
+    visitFixedSizeBinary(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitDate(type2, {
-        length: length4,
+    visitDate(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitTimestamp(type2, {
-        length: length4,
+    visitTimestamp(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitTime(type2, {
-        length: length4,
+    visitTime(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitDecimal(type2, {
-        length: length4,
+    visitDecimal(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitList(type2, {
-        length: length4,
+    visitList(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            valueOffsets: this.readOffsets(type2),
-            "child": this.visit(type2.children[0])
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            valueOffsets: this.readOffsets(type3),
+            "child": this.visit(type3.children[0])
         });
     }
-    visitStruct(type2, {
-        length: length4,
+    visitStruct(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            children: this.visitMany(type2.children)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            children: this.visitMany(type3.children)
         });
     }
-    visitUnion(type2) {
-        return type2.mode === UnionMode.Sparse ? this.visitSparseUnion(type2) : this.visitDenseUnion(type2);
+    visitUnion(type3) {
+        return type3.mode === UnionMode.Sparse ? this.visitSparseUnion(type3) : this.visitDenseUnion(type3);
     }
-    visitDenseUnion(type2, {
-        length: length4,
+    visitDenseUnion(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            typeIds: this.readTypeIds(type2),
-            valueOffsets: this.readOffsets(type2),
-            children: this.visitMany(type2.children)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            typeIds: this.readTypeIds(type3),
+            valueOffsets: this.readOffsets(type3),
+            children: this.visitMany(type3.children)
         });
     }
-    visitSparseUnion(type2, {
-        length: length4,
+    visitSparseUnion(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            typeIds: this.readTypeIds(type2),
-            children: this.visitMany(type2.children)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            typeIds: this.readTypeIds(type3),
+            children: this.visitMany(type3.children)
         });
     }
-    visitDictionary(type2, {
-        length: length4,
+    visitDictionary(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2.indices),
-            dictionary: this.readDictionary(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3.indices),
+            dictionary: this.readDictionary(type3)
         });
     }
-    visitInterval(type2, {
-        length: length4,
+    visitInterval(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            data: this.readData(type2)
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            data: this.readData(type3)
         });
     }
-    visitFixedSizeList(type2, {
-        length: length4,
+    visitFixedSizeList(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            "child": this.visit(type2.children[0])
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            "child": this.visit(type3.children[0])
         });
     }
-    visitMap(type2, {
-        length: length4,
+    visitMap(type3, {
+        length: length7,
         nullCount
     } = this.nextFieldNode()) {
         return makeData({
-            type: type2,
-            length: length4,
+            type: type3,
+            length: length7,
             nullCount,
-            nullBitmap: this.readNullBitmap(type2, nullCount),
-            valueOffsets: this.readOffsets(type2),
-            "child": this.visit(type2.children[0])
+            nullBitmap: this.readNullBitmap(type3, nullCount),
+            valueOffsets: this.readOffsets(type3),
+            "child": this.visit(type3.children[0])
         });
     }
     nextFieldNode() {
         return this.nodes[++this.nodesIndex];
     }
     nextBufferRange() {
         return this.buffers[++this.buffersIndex];
     }
-    readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {
-        return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);
+    readNullBitmap(type3, nullCount, buffer = this.nextBufferRange()) {
+        return nullCount > 0 && this.readData(type3, buffer) || new Uint8Array(0);
     }
-    readOffsets(type2, buffer) {
-        return this.readData(type2, buffer);
+    readOffsets(type3, buffer) {
+        return this.readData(type3, buffer);
     }
-    readTypeIds(type2, buffer) {
-        return this.readData(type2, buffer);
+    readTypeIds(type3, buffer) {
+        return this.readData(type3, buffer);
     }
     readData(_type, {
-        length: length4,
-        offset: offset2
+        length: length7,
+        offset: offset3
     } = this.nextBufferRange()) {
-        return this.bytes.subarray(offset2, offset2 + length4);
+        return this.bytes.subarray(offset3, offset3 + length7);
     }
-    readDictionary(type2) {
-        return this.dictionaries.get(type2.id);
+    readDictionary(type3) {
+        return this.dictionaries.get(type3.id);
     }
 };
 var JSONVectorLoader = class extends VectorLoader {
     constructor(sources, nodes, buffers, dictionaries) {
         super(new Uint8Array(0), nodes, buffers, dictionaries);
         this.sources = sources;
     }
     readNullBitmap(_type, nullCount, {
-        offset: offset2
+        offset: offset3
     } = this.nextBufferRange()) {
-        return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);
+        return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset3]);
     }
     readOffsets(_type, {
-        offset: offset2
+        offset: offset3
     } = this.nextBufferRange()) {
-        return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset2]));
+        return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset3]));
     }
-    readTypeIds(type2, {
-        offset: offset2
+    readTypeIds(type3, {
+        offset: offset3
     } = this.nextBufferRange()) {
-        return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, this.sources[offset2]));
+        return toArrayBufferView(Uint8Array, toArrayBufferView(type3.ArrayType, this.sources[offset3]));
     }
-    readData(type2, {
-        offset: offset2
+    readData(type3, {
+        offset: offset3
     } = this.nextBufferRange()) {
         const {
             sources
         } = this;
-        if (DataType.isTimestamp(type2)) {
-            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
-        } else if ((DataType.isInt(type2) || DataType.isTime(type2)) && type2.bitWidth === 64) {
-            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
-        } else if (DataType.isDate(type2) && type2.unit === DateUnit.MILLISECOND) {
-            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
-        } else if (DataType.isDecimal(type2)) {
-            return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));
-        } else if (DataType.isBinary(type2) || DataType.isFixedSizeBinary(type2)) {
-            return binaryDataFromJSON(sources[offset2]);
-        } else if (DataType.isBool(type2)) {
-            return packBools(sources[offset2]);
-        } else if (DataType.isUtf8(type2)) {
-            return encodeUtf8(sources[offset2].join(""));
+        if (DataType.isTimestamp(type3)) {
+            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset3]));
+        } else if ((DataType.isInt(type3) || DataType.isTime(type3)) && type3.bitWidth === 64) {
+            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset3]));
+        } else if (DataType.isDate(type3) && type3.unit === DateUnit.MILLISECOND) {
+            return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset3]));
+        } else if (DataType.isDecimal(type3)) {
+            return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset3]));
+        } else if (DataType.isBinary(type3) || DataType.isFixedSizeBinary(type3)) {
+            return binaryDataFromJSON(sources[offset3]);
+        } else if (DataType.isBool(type3)) {
+            return packBools(sources[offset3]);
+        } else if (DataType.isUtf8(type3)) {
+            return encodeUtf8(sources[offset3].join(""));
         }
-        return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, sources[offset2].map((x4) => +x4)));
+        return toArrayBufferView(Uint8Array, toArrayBufferView(type3.ArrayType, sources[offset3].map((x7) => +x7)));
     }
 };
 
-function binaryDataFromJSON(values2) {
-    const joined = values2.join("");
+function binaryDataFromJSON(values3) {
+    const joined = values3.join("");
     const data = new Uint8Array(joined.length / 2);
     for (let i = 0; i < joined.length; i += 2) {
         data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
     }
     return data;
 }
 
-// node_modules/apache-arrow/builder/binary.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/binary.mjs
 var BinaryBuilder = class extends VariableWidthBuilder {
     constructor(opts) {
         super(opts);
         this._values = new BufferBuilder(new Uint8Array(0));
     }
     get byteLength() {
         let size = this._pendingLength + this.length * 4;
         this._offsets && (size += this._offsets.byteLength);
         this._values && (size += this._values.byteLength);
         this._nulls && (size += this._nulls.byteLength);
         return size;
     }
-    setValue(index3, value) {
-        return super.setValue(index3, toUint8Array(value));
+    setValue(index5, value) {
+        return super.setValue(index5, toUint8Array(value));
     }
     _flushPending(pending, pendingLength) {
         const offsets = this._offsets;
         const data = this._values.reserve(pendingLength).buffer;
-        let offset2 = 0;
-        for (const [index3, value] of pending) {
+        let offset3 = 0;
+        for (const [index5, value] of pending) {
             if (value === void 0) {
-                offsets.set(index3, 0);
+                offsets.set(index5, 0);
             } else {
-                const length4 = value.length;
-                data.set(value, offset2);
-                offsets.set(index3, length4);
-                offset2 += length4;
+                const length7 = value.length;
+                data.set(value, offset3);
+                offsets.set(index5, length7);
+                offset3 += length7;
             }
         }
     }
 };
 
-// node_modules/apache-arrow/builder/bool.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/bool.mjs
 var BoolBuilder = class extends Builder {
     constructor(options) {
         super(options);
         this._values = new BitmapBufferBuilder();
     }
-    setValue(index3, value) {
-        this._values.set(index3, +value);
+    setValue(index5, value) {
+        this._values.set(index5, +value);
     }
 };
 
-// node_modules/apache-arrow/builder/date.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/date.mjs
 var DateBuilder = class extends FixedWidthBuilder {};
 DateBuilder.prototype._setValue = setDate;
 var DateDayBuilder = class extends DateBuilder {};
 DateDayBuilder.prototype._setValue = setDateDay;
 var DateMillisecondBuilder = class extends DateBuilder {};
 DateMillisecondBuilder.prototype._setValue = setDateMillisecond;
 
-// node_modules/apache-arrow/builder/decimal.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/decimal.mjs
 var DecimalBuilder = class extends FixedWidthBuilder {};
 DecimalBuilder.prototype._setValue = setDecimal;
 
-// node_modules/apache-arrow/builder/dictionary.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/dictionary.mjs
 var DictionaryBuilder = class extends Builder {
     constructor({
-        "type": type2,
+        "type": type3,
         "nullValues": nulls,
         "dictionaryHashFunction": hashFn
     }) {
         super({
-            type: new Dictionary(type2.dictionary, type2.indices, type2.id, type2.isOrdered)
+            type: new Dictionary(type3.dictionary, type3.indices, type3.id, type3.isOrdered)
         });
         this._nulls = null;
         this._dictionaryOffset = 0;
         this._keysToIndices = /* @__PURE__ */ Object.create(null);
         this.indices = makeBuilder({
             "type": this.type.indices,
             "nullValues": nulls
@@ -43111,34 +77817,34 @@
     }
     get reservedByteLength() {
         return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
     }
     isValid(value) {
         return this.indices.isValid(value);
     }
-    setValid(index3, valid2) {
+    setValid(index5, valid3) {
         const indices = this.indices;
-        valid2 = indices.setValid(index3, valid2);
+        valid3 = indices.setValid(index5, valid3);
         this.length = indices.length;
-        return valid2;
+        return valid3;
     }
-    setValue(index3, value) {
+    setValue(index5, value) {
         const keysToIndices = this._keysToIndices;
         const key = this.valueToKey(value);
         let idx = keysToIndices[key];
         if (idx === void 0) {
             keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
         }
-        return this.indices.setValue(index3, idx);
+        return this.indices.setValue(index5, idx);
     }
     flush() {
-        const type2 = this.type;
+        const type3 = this.type;
         const prev = this._dictionary;
         const curr = this.dictionary.toVector();
-        const data = this.indices.flush().clone(type2);
+        const data = this.indices.flush().clone(type3);
         data.dictionary = prev ? prev.concat(curr) : curr;
         this.finished || (this._dictionaryOffset += curr.length);
         this._dictionary = data.dictionary;
         this.clear();
         return data;
     }
     finish() {
@@ -43154,75 +77860,75 @@
         return super.clear();
     }
     valueToKey(val) {
         return typeof val === "string" ? val : `${val}`;
     }
 };
 
-// node_modules/apache-arrow/builder/fixedsizebinary.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/fixedsizebinary.mjs
 var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {};
 FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;
 
-// node_modules/apache-arrow/builder/fixedsizelist.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/fixedsizelist.mjs
 var FixedSizeListBuilder = class extends Builder {
-    setValue(index3, value) {
+    setValue(index5, value) {
         const [child] = this.children;
-        const start2 = index3 * this.stride;
+        const start3 = index5 * this.stride;
         for (let i = -1, n = value.length; ++i < n;) {
-            child.set(start2 + i, value[i]);
+            child.set(start3 + i, value[i]);
         }
     }
     addChild(child, name = "0") {
         if (this.numChildren > 0) {
             throw new Error("FixedSizeListBuilder can only have one child.");
         }
         const childIndex = this.children.push(child);
         this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));
         return childIndex;
     }
 };
 
-// node_modules/apache-arrow/builder/float.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/float.mjs
 var FloatBuilder = class extends FixedWidthBuilder {
-    setValue(index3, value) {
-        this._values.set(index3, value);
+    setValue(index5, value) {
+        this._values.set(index5, value);
     }
 };
 var Float16Builder = class extends FloatBuilder {
-    setValue(index3, value) {
-        super.setValue(index3, float64ToUint16(value));
+    setValue(index5, value) {
+        super.setValue(index5, float64ToUint16(value));
     }
 };
 var Float32Builder = class extends FloatBuilder {};
 var Float64Builder = class extends FloatBuilder {};
 
-// node_modules/apache-arrow/builder/interval.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/interval.mjs
 var IntervalBuilder = class extends FixedWidthBuilder {};
 IntervalBuilder.prototype._setValue = setIntervalValue;
 var IntervalDayTimeBuilder = class extends IntervalBuilder {};
 IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
 var IntervalYearMonthBuilder = class extends IntervalBuilder {};
 IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;
 
-// node_modules/apache-arrow/builder/int.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/int.mjs
 var IntBuilder = class extends FixedWidthBuilder {
-    setValue(index3, value) {
-        this._values.set(index3, value);
+    setValue(index5, value) {
+        this._values.set(index5, value);
     }
 };
 var Int8Builder = class extends IntBuilder {};
 var Int16Builder = class extends IntBuilder {};
 var Int32Builder = class extends IntBuilder {};
 var Int64Builder = class extends IntBuilder {};
 var Uint8Builder = class extends IntBuilder {};
 var Uint16Builder = class extends IntBuilder {};
 var Uint32Builder = class extends IntBuilder {};
 var Uint64Builder = class extends IntBuilder {};
 
-// node_modules/apache-arrow/builder/list.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/list.mjs
 var ListBuilder = class extends VariableWidthBuilder {
     constructor(opts) {
         super(opts);
         this._offsets = new OffsetsBufferBuilder();
     }
     addChild(child, name = "0") {
         if (this.numChildren > 0) {
@@ -43231,219 +77937,219 @@
         this.children[this.numChildren] = child;
         this.type = new List(new Field2(name, child.type, true));
         return this.numChildren - 1;
     }
     _flushPending(pending) {
         const offsets = this._offsets;
         const [child] = this.children;
-        for (const [index3, value] of pending) {
+        for (const [index5, value] of pending) {
             if (typeof value === "undefined") {
-                offsets.set(index3, 0);
+                offsets.set(index5, 0);
             } else {
                 const n = value.length;
-                const start2 = offsets.set(index3, n).buffer[index3];
+                const start3 = offsets.set(index5, n).buffer[index5];
                 for (let i = -1; ++i < n;) {
-                    child.set(start2 + i, value[i]);
+                    child.set(start3 + i, value[i]);
                 }
             }
         }
     }
 };
 
-// node_modules/apache-arrow/builder/map.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/map.mjs
 var MapBuilder = class extends VariableWidthBuilder {
-    set(index3, value) {
-        return super.set(index3, value);
+    set(index5, value) {
+        return super.set(index5, value);
     }
-    setValue(index3, value) {
+    setValue(index5, value) {
         const row = value instanceof Map ? value : new Map(Object.entries(value));
         const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
-        const current = pending.get(index3);
+        const current = pending.get(index5);
         current && (this._pendingLength -= current.size);
         this._pendingLength += row.size;
-        pending.set(index3, row);
+        pending.set(index5, row);
     }
     addChild(child, name = `${this.numChildren}`) {
         if (this.numChildren > 0) {
             throw new Error("ListBuilder can only have one child.");
         }
         this.children[this.numChildren] = child;
         this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
         return this.numChildren - 1;
     }
     _flushPending(pending) {
         const offsets = this._offsets;
         const [child] = this.children;
-        for (const [index3, value] of pending) {
+        for (const [index5, value] of pending) {
             if (value === void 0) {
-                offsets.set(index3, 0);
+                offsets.set(index5, 0);
             } else {
                 let {
-                    [index3]: idx, [index3 + 1]: end
-                } = offsets.set(index3, value.size).buffer;
+                    [index5]: idx, [index5 + 1]: end
+                } = offsets.set(index5, value.size).buffer;
                 for (const val of value.entries()) {
                     child.set(idx, val);
                     if (++idx >= end)
                         break;
                 }
             }
         }
     }
 };
 
-// node_modules/apache-arrow/builder/null.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/null.mjs
 var NullBuilder = class extends Builder {
     // @ts-ignore
-    setValue(index3, value) {}
-    setValid(index3, valid2) {
-        this.length = Math.max(index3 + 1, this.length);
-        return valid2;
+    setValue(index5, value) {}
+    setValid(index5, valid3) {
+        this.length = Math.max(index5 + 1, this.length);
+        return valid3;
     }
 };
 
-// node_modules/apache-arrow/builder/struct.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/struct.mjs
 var StructBuilder = class extends Builder {
-    setValue(index3, value) {
+    setValue(index5, value) {
         const {
-            children: children2,
-            type: type2
+            children: children3,
+            type: type3
         } = this;
         switch (Array.isArray(value) || value.constructor) {
             case true:
-                return type2.children.forEach((_, i) => children2[i].set(index3, value[i]));
+                return type3.children.forEach((_, i) => children3[i].set(index5, value[i]));
             case Map:
-                return type2.children.forEach((f, i) => children2[i].set(index3, value.get(f.name)));
+                return type3.children.forEach((f, i) => children3[i].set(index5, value.get(f.name)));
             default:
-                return type2.children.forEach((f, i) => children2[i].set(index3, value[f.name]));
+                return type3.children.forEach((f, i) => children3[i].set(index5, value[f.name]));
         }
     }
     /** @inheritdoc */
-    setValid(index3, valid2) {
-        if (!super.setValid(index3, valid2)) {
-            this.children.forEach((child) => child.setValid(index3, valid2));
+    setValid(index5, valid3) {
+        if (!super.setValid(index5, valid3)) {
+            this.children.forEach((child) => child.setValid(index5, valid3));
         }
-        return valid2;
+        return valid3;
     }
     addChild(child, name = `${this.numChildren}`) {
         const childIndex = this.children.push(child);
         this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);
         return childIndex;
     }
 };
 
-// node_modules/apache-arrow/builder/timestamp.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/timestamp.mjs
 var TimestampBuilder = class extends FixedWidthBuilder {};
 TimestampBuilder.prototype._setValue = setTimestamp;
 var TimestampSecondBuilder = class extends TimestampBuilder {};
 TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
 var TimestampMillisecondBuilder = class extends TimestampBuilder {};
 TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
 var TimestampMicrosecondBuilder = class extends TimestampBuilder {};
 TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
 var TimestampNanosecondBuilder = class extends TimestampBuilder {};
 TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;
 
-// node_modules/apache-arrow/builder/time.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/time.mjs
 var TimeBuilder = class extends FixedWidthBuilder {};
 TimeBuilder.prototype._setValue = setTime;
 var TimeSecondBuilder = class extends TimeBuilder {};
 TimeSecondBuilder.prototype._setValue = setTimeSecond;
 var TimeMillisecondBuilder = class extends TimeBuilder {};
 TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
 var TimeMicrosecondBuilder = class extends TimeBuilder {};
 TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
 var TimeNanosecondBuilder = class extends TimeBuilder {};
 TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;
 
-// node_modules/apache-arrow/builder/union.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/union.mjs
 var UnionBuilder = class extends Builder {
     constructor(options) {
         super(options);
         this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
         if (typeof options["valueToChildTypeId"] === "function") {
             this._valueToChildTypeId = options["valueToChildTypeId"];
         }
     }
     get typeIdToChildIndex() {
         return this.type.typeIdToChildIndex;
     }
     append(value, childTypeId) {
         return this.set(this.length, value, childTypeId);
     }
-    set(index3, value, childTypeId) {
+    set(index5, value, childTypeId) {
         if (childTypeId === void 0) {
-            childTypeId = this._valueToChildTypeId(this, value, index3);
+            childTypeId = this._valueToChildTypeId(this, value, index5);
         }
-        if (this.setValid(index3, this.isValid(value))) {
-            this.setValue(index3, value, childTypeId);
+        if (this.setValid(index5, this.isValid(value))) {
+            this.setValue(index5, value, childTypeId);
         }
         return this;
     }
-    setValue(index3, value, childTypeId) {
-        this._typeIds.set(index3, childTypeId);
+    setValue(index5, value, childTypeId) {
+        this._typeIds.set(index5, childTypeId);
         const childIndex = this.type.typeIdToChildIndex[childTypeId];
         const child = this.children[childIndex];
-        child === null || child === void 0 ? void 0 : child.set(index3, value);
+        child === null || child === void 0 ? void 0 : child.set(index5, value);
     }
     addChild(child, name = `${this.children.length}`) {
         const childTypeId = this.children.push(child);
         const {
             type: {
-                children: children2,
-                mode: mode2,
+                children: children3,
+                mode: mode3,
                 typeIds
             }
         } = this;
-        const fields = [...children2, new Field2(name, child.type)];
-        this.type = new Union_(mode2, [...typeIds, childTypeId], fields);
+        const fields = [...children3, new Field2(name, child.type)];
+        this.type = new Union_(mode3, [...typeIds, childTypeId], fields);
         return childTypeId;
     }
     /** @ignore */
     // @ts-ignore
-    _valueToChildTypeId(builder, value, offset2) {
+    _valueToChildTypeId(builder, value, offset3) {
         throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
     }
 };
 var SparseUnionBuilder = class extends UnionBuilder {};
 var DenseUnionBuilder = class extends UnionBuilder {
     constructor(options) {
         super(options);
         this._offsets = new DataBufferBuilder(new Int32Array(0));
     }
     /** @ignore */
-    setValue(index3, value, childTypeId) {
-        const id2 = this._typeIds.set(index3, childTypeId).buffer[index3];
-        const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);
-        const denseIndex = this._offsets.set(index3, child.length).buffer[index3];
+    setValue(index5, value, childTypeId) {
+        const id3 = this._typeIds.set(index5, childTypeId).buffer[index5];
+        const child = this.getChildAt(this.type.typeIdToChildIndex[id3]);
+        const denseIndex = this._offsets.set(index5, child.length).buffer[index5];
         child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
     }
 };
 
-// node_modules/apache-arrow/builder/utf8.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/builder/utf8.mjs
 var Utf8Builder = class extends VariableWidthBuilder {
     constructor(opts) {
         super(opts);
         this._values = new BufferBuilder(new Uint8Array(0));
     }
     get byteLength() {
         let size = this._pendingLength + this.length * 4;
         this._offsets && (size += this._offsets.byteLength);
         this._values && (size += this._values.byteLength);
         this._nulls && (size += this._nulls.byteLength);
         return size;
     }
-    setValue(index3, value) {
-        return super.setValue(index3, encodeUtf8(value));
+    setValue(index5, value) {
+        return super.setValue(index5, encodeUtf8(value));
     }
     // @ts-ignore
     _flushPending(pending, pendingLength) {}
 };
 Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;
 
-// node_modules/apache-arrow/visitor/builderctor.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/builderctor.mjs
 var GetBuilderCtor = class extends Visitor {
     visitNull() {
         return NullBuilder;
     }
     visitBool() {
         return BoolBuilder;
     }
@@ -43569,85 +78275,85 @@
     }
     visitMap() {
         return MapBuilder;
     }
 };
 var instance6 = new GetBuilderCtor();
 
-// node_modules/apache-arrow/visitor/typecomparator.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/typecomparator.mjs
 var TypeComparator = class extends Visitor {
     compareSchemas(schema, other) {
         return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
     }
     compareManyFields(fields, others) {
         return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
     }
-    compareFields(field2, other) {
-        return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);
+    compareFields(field3, other) {
+        return field3 === other || other instanceof field3.constructor && field3.name === other.name && field3.nullable === other.nullable && this.visit(field3.type, other.type);
     }
 };
 
-function compareConstructor(type2, other) {
-    return other instanceof type2.constructor;
+function compareConstructor(type3, other) {
+    return other instanceof type3.constructor;
 }
 
-function compareAny(type2, other) {
-    return type2 === other || compareConstructor(type2, other);
+function compareAny(type3, other) {
+    return type3 === other || compareConstructor(type3, other);
 }
 
-function compareInt(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;
+function compareInt(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.bitWidth === other.bitWidth && type3.isSigned === other.isSigned;
 }
 
-function compareFloat(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.precision === other.precision;
+function compareFloat(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.precision === other.precision;
 }
 
-function compareFixedSizeBinary(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.byteWidth === other.byteWidth;
+function compareFixedSizeBinary(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.byteWidth === other.byteWidth;
 }
 
-function compareDate(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;
+function compareDate(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.unit === other.unit;
 }
 
-function compareTimestamp(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;
+function compareTimestamp(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.unit === other.unit && type3.timezone === other.timezone;
 }
 
-function compareTime(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;
+function compareTime(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.unit === other.unit && type3.bitWidth === other.bitWidth;
 }
 
-function compareList(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);
+function compareList(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.children.length === other.children.length && instance7.compareManyFields(type3.children, other.children);
 }
 
-function compareStruct(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);
+function compareStruct(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.children.length === other.children.length && instance7.compareManyFields(type3.children, other.children);
 }
 
-function compareUnion(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance7.compareManyFields(type2.children, other.children);
+function compareUnion(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.mode === other.mode && type3.typeIds.every((x7, i) => x7 === other.typeIds[i]) && instance7.compareManyFields(type3.children, other.children);
 }
 
-function compareDictionary(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance7.visit(type2.indices, other.indices) && instance7.visit(type2.dictionary, other.dictionary);
+function compareDictionary(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.id === other.id && type3.isOrdered === other.isOrdered && instance7.visit(type3.indices, other.indices) && instance7.visit(type3.dictionary, other.dictionary);
 }
 
-function compareInterval(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;
+function compareInterval(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.unit === other.unit;
 }
 
-function compareFixedSizeList(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);
+function compareFixedSizeList(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.listSize === other.listSize && type3.children.length === other.children.length && instance7.compareManyFields(type3.children, other.children);
 }
 
-function compareMap(type2, other) {
-    return type2 === other || compareConstructor(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);
+function compareMap(type3, other) {
+    return type3 === other || compareConstructor(type3, other) && type3.keysSorted === other.keysSorted && type3.children.length === other.children.length && instance7.compareManyFields(type3.children, other.children);
 }
 TypeComparator.prototype.visitNull = compareAny;
 TypeComparator.prototype.visitBool = compareAny;
 TypeComparator.prototype.visitInt = compareInt;
 TypeComparator.prototype.visitInt8 = compareInt;
 TypeComparator.prototype.visitInt16 = compareInt;
 TypeComparator.prototype.visitInt32 = compareInt;
@@ -43690,116 +78396,116 @@
 TypeComparator.prototype.visitMap = compareMap;
 var instance7 = new TypeComparator();
 
 function compareSchemas(schema, other) {
     return instance7.compareSchemas(schema, other);
 }
 
-function compareFields(field2, other) {
-    return instance7.compareFields(field2, other);
+function compareFields(field3, other) {
+    return instance7.compareFields(field3, other);
 }
 
-function compareTypes(type2, other) {
-    return instance7.visit(type2, other);
+function compareTypes(type3, other) {
+    return instance7.visit(type3, other);
 }
 
-// node_modules/apache-arrow/factories.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/factories.mjs
 function makeBuilder(options) {
-    const type2 = options.type;
-    const builder = new(instance6.getVisitFn(type2)())(options);
-    if (type2.children && type2.children.length > 0) {
-        const children2 = options["children"] || [];
+    const type3 = options.type;
+    const builder = new(instance6.getVisitFn(type3)())(options);
+    if (type3.children && type3.children.length > 0) {
+        const children3 = options["children"] || [];
         const defaultOptions = {
             "nullValues": options["nullValues"]
         };
-        const getChildOptions = Array.isArray(children2) ? (_, i) => children2[i] || defaultOptions : ({
+        const getChildOptions = Array.isArray(children3) ? (_, i) => children3[i] || defaultOptions : ({
             name
-        }) => children2[name] || defaultOptions;
-        for (const [index3, field2] of type2.children.entries()) {
+        }) => children3[name] || defaultOptions;
+        for (const [index5, field3] of type3.children.entries()) {
             const {
-                type: type3
-            } = field2;
-            const opts = getChildOptions(field2, index3);
+                type: type4
+            } = field3;
+            const opts = getChildOptions(field3, index5);
             builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), {
-                type: type3
+                type: type4
             })));
         }
     }
     return builder;
 }
 
-// node_modules/apache-arrow/util/recordbatch.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/util/recordbatch.mjs
 function distributeVectorsIntoRecordBatches(schema, vecs) {
-    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v2) => v2.data.concat()));
+    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v3) => v3.data.concat()));
 }
 
 function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
     const fields = [...schema.fields];
     const batches = [];
     const memo = {
-        numBatches: cols.reduce((n, c6) => Math.max(n, c6.length), 0)
+        numBatches: cols.reduce((n, c11) => Math.max(n, c11.length), 0)
     };
     let numBatches = 0,
         batchLength = 0;
     let i = -1;
     const numColumns = cols.length;
-    let child, children2 = [];
+    let child, children3 = [];
     while (memo.numBatches-- > 0) {
         for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns;) {
-            children2[i] = child = cols[i].shift();
+            children3[i] = child = cols[i].shift();
             batchLength = Math.min(batchLength, child ? child.length : batchLength);
         }
         if (Number.isFinite(batchLength)) {
-            children2 = distributeChildren(fields, batchLength, children2, cols, memo);
+            children3 = distributeChildren(fields, batchLength, children3, cols, memo);
             if (batchLength > 0) {
                 batches[numBatches++] = makeData({
                     type: new Struct(fields),
                     length: batchLength,
                     nullCount: 0,
-                    children: children2.slice()
+                    children: children3.slice()
                 });
             }
         }
     }
     return [
         schema = schema.assign(fields),
         batches.map((data) => new RecordBatch(schema, data))
     ];
 }
 
-function distributeChildren(fields, batchLength, children2, columns, memo) {
+function distributeChildren(fields, batchLength, children3, columns, memo) {
     var _a5;
     const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
     for (let i = -1, n = columns.length; ++i < n;) {
-        const child = children2[i];
-        const length4 = child === null || child === void 0 ? void 0 : child.length;
-        if (length4 >= batchLength) {
-            if (length4 === batchLength) {
-                children2[i] = child;
+        const child = children3[i];
+        const length7 = child === null || child === void 0 ? void 0 : child.length;
+        if (length7 >= batchLength) {
+            if (length7 === batchLength) {
+                children3[i] = child;
             } else {
-                children2[i] = child.slice(0, batchLength);
-                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));
+                children3[i] = child.slice(0, batchLength);
+                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length7 - batchLength)));
             }
         } else {
-            const field2 = fields[i];
-            fields[i] = field2.clone({
+            const field3 = fields[i];
+            fields[i] = field3.clone({
                 nullable: true
             });
-            children2[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
-                type: field2.type,
+            children3[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
+                type: field3.type,
                 length: batchLength,
                 nullCount: batchLength,
                 nullBitmap: new Uint8Array(nullBitmapSize)
             });
         }
     }
-    return children2;
+    return children3;
 }
 
-// node_modules/apache-arrow/table.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/table.mjs
 var _a3;
 var Table = class {
     constructor(...args) {
         var _b2, _c2;
         if (args.length === 0) {
             this.batches = [];
             this.schema = new Schema2([]);
@@ -43810,39 +78516,39 @@
         let offsets;
         if (args[0] instanceof Schema2) {
             schema = args.shift();
         }
         if (args[args.length - 1] instanceof Uint32Array) {
             offsets = args.pop();
         }
-        const unwrap = (x4) => {
-            if (x4) {
-                if (x4 instanceof RecordBatch) {
-                    return [x4];
-                } else if (x4 instanceof Table) {
-                    return x4.batches;
-                } else if (x4 instanceof Data) {
-                    if (x4.type instanceof Struct) {
-                        return [new RecordBatch(new Schema2(x4.type.children), x4)];
-                    }
-                } else if (Array.isArray(x4)) {
-                    return x4.flatMap((v2) => unwrap(v2));
-                } else if (typeof x4[Symbol.iterator] === "function") {
-                    return [...x4].flatMap((v2) => unwrap(v2));
-                } else if (typeof x4 === "object") {
-                    const keys = Object.keys(x4);
-                    const vecs = keys.map((k2) => new Vector2([x4[k2]]));
-                    const schema2 = new Schema2(keys.map((k2, i) => new Field2(String(k2), vecs[i].type)));
+        const unwrap = (x7) => {
+            if (x7) {
+                if (x7 instanceof RecordBatch) {
+                    return [x7];
+                } else if (x7 instanceof Table) {
+                    return x7.batches;
+                } else if (x7 instanceof Data) {
+                    if (x7.type instanceof Struct) {
+                        return [new RecordBatch(new Schema2(x7.type.children), x7)];
+                    }
+                } else if (Array.isArray(x7)) {
+                    return x7.flatMap((v3) => unwrap(v3));
+                } else if (typeof x7[Symbol.iterator] === "function") {
+                    return [...x7].flatMap((v3) => unwrap(v3));
+                } else if (typeof x7 === "object") {
+                    const keys = Object.keys(x7);
+                    const vecs = keys.map((k3) => new Vector3([x7[k3]]));
+                    const schema2 = new Schema2(keys.map((k3, i) => new Field2(String(k3), vecs[i].type)));
                     const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
-                    return batches2.length === 0 ? [new RecordBatch(x4)] : batches2;
+                    return batches2.length === 0 ? [new RecordBatch(x7)] : batches2;
                 }
             }
             return [];
         };
-        const batches = args.flatMap((v2) => unwrap(v2));
+        const batches = args.flatMap((v3) => unwrap(v3));
         schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
         if (!(schema instanceof Schema2)) {
             throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
         }
         for (const batch of batches) {
             if (!(batch instanceof RecordBatch)) {
                 throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
@@ -43886,60 +78592,60 @@
     }
     /**
      * Check whether an element is null.
      *
      * @param index The index at which to read the validity bitmap.
      */
     // @ts-ignore
-    isValid(index3) {
+    isValid(index5) {
         return false;
     }
     /**
      * Get an element value by position.
      *
      * @param index The index of the element to read.
      */
     // @ts-ignore
-    get(index3) {
+    get(index5) {
         return null;
     }
     /**
      * Set an element value by position.
      *
      * @param index The index of the element to write.
      * @param value The value to set.
      */
     // @ts-ignore
-    set(index3, value) {
+    set(index5, value) {
         return;
     }
     /**
      * Retrieve the index of the first occurrence of a value in an Vector.
      *
      * @param element The value to locate in the Vector.
      * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
      */
     // @ts-ignore
-    indexOf(element, offset2) {
+    indexOf(element, offset3) {
         return -1;
     }
     /**
      * Get the size in bytes of an element by index.
      * @param index The index at which to get the byteLength.
      */
     // @ts-ignore
-    getByteLength(index3) {
+    getByteLength(index5) {
         return 0;
     }
     /**
      * Iterator for rows in this Table.
      */
     [Symbol.iterator]() {
         if (this.batches.length > 0) {
-            return instance4.visit(new Vector2(this.data));
+            return instance4.visit(new Vector3(this.data));
         }
         return new Array(0)[Symbol.iterator]();
     }
     /**
      * Return a JavaScript Array of the Table rows.
      *
      * @returns An Array of Table rows.
@@ -43992,71 +78698,71 @@
         return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
     }
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      *
      * @param index The index of the child to retrieve.
      */
-    getChildAt(index3) {
-        if (index3 > -1 && index3 < this.schema.fields.length) {
-            const data = this.data.map((data2) => data2.children[index3]);
+    getChildAt(index5) {
+        if (index5 > -1 && index5 < this.schema.fields.length) {
+            const data = this.data.map((data2) => data2.children[index5]);
             if (data.length === 0) {
                 const {
-                    type: type2
-                } = this.schema.fields[index3];
-                const empty4 = makeData({
-                    type: type2,
+                    type: type3
+                } = this.schema.fields[index5];
+                const empty7 = makeData({
+                    type: type3,
                     length: 0,
                     nullCount: 0
                 });
-                data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));
+                data.push(empty7._changeLengthAndBackfillNullBitmap(this.numRows));
             }
-            return new Vector2(data);
+            return new Vector3(data);
         }
         return null;
     }
     /**
      * Sets a child Vector by name.
      *
      * @param name The name of the child to overwrite.
      * @returns A new Table with the supplied child for the specified name.
      */
     setChild(name, child) {
         var _b2;
         return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
     }
-    setChildAt(index3, child) {
+    setChildAt(index5, child) {
         let schema = this.schema;
         let batches = [...this.batches];
-        if (index3 > -1 && index3 < this.numCols) {
+        if (index5 > -1 && index5 < this.numCols) {
             if (!child) {
-                child = new Vector2([makeData({
+                child = new Vector3([makeData({
                     type: new Null(),
                     length: this.numRows
                 })]);
             }
             const fields = schema.fields.slice();
-            const field2 = fields[index3].clone({
+            const field3 = fields[index5].clone({
                 type: child.type
             });
-            const children2 = this.schema.fields.map((_, i) => this.getChildAt(i));
-            [fields[index3], children2[index3]] = [field2, child];
-            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);
+            const children3 = this.schema.fields.map((_, i) => this.getChildAt(i));
+            [fields[index5], children3[index5]] = [field3, child];
+            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children3);
         }
         return new Table(schema, batches);
     }
     /**
      * Construct a new Table containing only specified columns.
      *
      * @param columnNames Names of columns to keep.
      * @returns A new Table of columns matching the specified names.
      */
     select(columnNames) {
-        const nameToIndex = this.schema.fields.reduce((m3, f, i) => m3.set(f.name, i), /* @__PURE__ */ new Map());
-        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));
+        const nameToIndex = this.schema.fields.reduce((m5, f, i) => m5.set(f.name, i), /* @__PURE__ */ new Map());
+        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x7) => x7 > -1));
     }
     /**
      * Construct a new Table containing only columns at the specified indices.
      *
      * @param columnIndices Indices of columns to keep.
      * @returns A new Table of columns at the specified indices.
      */
@@ -44095,15 +78801,15 @@
     proto["get"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));
     proto["set"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));
     proto["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));
     proto["getByteLength"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));
     return "Table";
 })(Table.prototype);
 
-// node_modules/apache-arrow/recordbatch.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/recordbatch.mjs
 var _a4;
 var RecordBatch = class {
     constructor(...args) {
         switch (args.length) {
             case 2: {
                 [this.schema] = args;
                 if (!(this.schema instanceof Schema2)) {
@@ -44125,16 +78831,16 @@
                 [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
                 break;
             }
             case 1: {
                 const [obj] = args;
                 const {
                     fields,
-                    children: children2,
-                    length: length4
+                    children: children3,
+                    length: length7
                 } = Object.keys(obj).reduce((memo, name, i) => {
                     memo.children[i] = obj[name];
                     memo.length = Math.max(memo.length, obj[name].length);
                     memo.fields[i] = Field2.new({
                         name,
                         type: obj[name].type,
                         nullable: true
@@ -44144,19 +78850,19 @@
                     length: 0,
                     fields: new Array(),
                     children: new Array()
                 });
                 const schema = new Schema2(fields);
                 const data = makeData({
                     type: new Struct(fields),
-                    length: length4,
-                    children: children2,
+                    length: length7,
+                    children: children3,
                     nullCount: 0
                 });
-                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length4);
+                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length7);
                 break;
             }
             default:
                 throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
         }
     }
     get dictionaries() {
@@ -44180,52 +78886,52 @@
     get nullCount() {
         return this.data.nullCount;
     }
     /**
      * Check whether an element is null.
      * @param index The index at which to read the validity bitmap.
      */
-    isValid(index3) {
-        return this.data.getValid(index3);
+    isValid(index5) {
+        return this.data.getValid(index5);
     }
     /**
      * Get a row by position.
      * @param index The index of the element to read.
      */
-    get(index3) {
-        return instance2.visit(this.data, index3);
+    get(index5) {
+        return instance2.visit(this.data, index5);
     }
     /**
      * Set a row by position.
      * @param index The index of the element to write.
      * @param value The value to set.
      */
-    set(index3, value) {
-        return instance.visit(this.data, index3, value);
+    set(index5, value) {
+        return instance.visit(this.data, index5, value);
     }
     /**
      * Retrieve the index of the first occurrence of a row in an RecordBatch.
      * @param element The row to locate in the RecordBatch.
      * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
      */
-    indexOf(element, offset2) {
-        return instance3.visit(this.data, element, offset2);
+    indexOf(element, offset3) {
+        return instance3.visit(this.data, element, offset3);
     }
     /**
      * Get the size (in bytes) of a row by index.
      * @param index The row index for which to compute the byteLength.
      */
-    getByteLength(index3) {
-        return instance5.visit(this.data, index3);
+    getByteLength(index5) {
+        return instance5.visit(this.data, index5);
     }
     /**
      * Iterator for rows in this RecordBatch.
      */
     [Symbol.iterator]() {
-        return instance4.visit(new Vector2([this.data]));
+        return instance4.visit(new Vector3([this.data]));
     }
     /**
      * Return a JavaScript Array of the RecordBatch rows.
      * @returns An Array of RecordBatch rows.
      */
     toArray() {
         return [...this];
@@ -44239,253 +78945,253 @@
     }
     /**
      * Return a zero-copy sub-section of this RecordBatch.
      * @param start The beginning of the specified portion of the RecordBatch.
      * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
      */
     slice(begin, end) {
-        const [slice7] = new Vector2([this.data]).slice(begin, end).data;
-        return new RecordBatch(this.schema, slice7);
+        const [slice13] = new Vector3([this.data]).slice(begin, end).data;
+        return new RecordBatch(this.schema, slice13);
     }
     /**
      * Returns a child Vector by name, or null if this Vector has no child with the given name.
      * @param name The name of the child to retrieve.
      */
     getChild(name) {
         var _b2;
         return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
     }
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      * @param index The index of the child to retrieve.
      */
-    getChildAt(index3) {
-        if (index3 > -1 && index3 < this.schema.fields.length) {
-            return new Vector2([this.data.children[index3]]);
+    getChildAt(index5) {
+        if (index5 > -1 && index5 < this.schema.fields.length) {
+            return new Vector3([this.data.children[index5]]);
         }
         return null;
     }
     /**
      * Sets a child Vector by name.
      * @param name The name of the child to overwrite.
      * @returns A new RecordBatch with the new child for the specified name.
      */
     setChild(name, child) {
         var _b2;
         return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
     }
-    setChildAt(index3, child) {
+    setChildAt(index5, child) {
         let schema = this.schema;
         let data = this.data;
-        if (index3 > -1 && index3 < this.numCols) {
+        if (index5 > -1 && index5 < this.numCols) {
             if (!child) {
-                child = new Vector2([makeData({
+                child = new Vector3([makeData({
                     type: new Null(),
                     length: this.numRows
                 })]);
             }
             const fields = schema.fields.slice();
-            const children2 = data.children.slice();
-            const field2 = fields[index3].clone({
+            const children3 = data.children.slice();
+            const field3 = fields[index5].clone({
                 type: child.type
             });
-            [fields[index3], children2[index3]] = [field2, child.data[0]];
+            [fields[index5], children3[index5]] = [field3, child.data[0]];
             schema = new Schema2(fields, new Map(this.schema.metadata));
             data = makeData({
                 type: new Struct(fields),
-                children: children2
+                children: children3
             });
         }
         return new RecordBatch(schema, data);
     }
     /**
      * Construct a new RecordBatch containing only specified columns.
      *
      * @param columnNames Names of columns to keep.
      * @returns A new RecordBatch of columns matching the specified names.
      */
     select(columnNames) {
         const schema = this.schema.select(columnNames);
-        const type2 = new Struct(schema.fields);
-        const children2 = [];
+        const type3 = new Struct(schema.fields);
+        const children3 = [];
         for (const name of columnNames) {
-            const index3 = this.schema.fields.findIndex((f) => f.name === name);
-            if (~index3) {
-                children2[index3] = this.data.children[index3];
+            const index5 = this.schema.fields.findIndex((f) => f.name === name);
+            if (~index5) {
+                children3[index5] = this.data.children[index5];
             }
         }
         return new RecordBatch(schema, makeData({
-            type: type2,
+            type: type3,
             length: this.numRows,
-            children: children2
+            children: children3
         }));
     }
     /**
      * Construct a new RecordBatch containing only columns at the specified indices.
      *
      * @param columnIndices Indices of columns to keep.
      * @returns A new RecordBatch of columns matching at the specified indices.
      */
     selectAt(columnIndices) {
         const schema = this.schema.selectAt(columnIndices);
-        const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
-        const subset2 = makeData({
+        const children3 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
+        const subset3 = makeData({
             type: new Struct(schema.fields),
             length: this.numRows,
-            children: children2
+            children: children3
         });
-        return new RecordBatch(schema, subset2);
+        return new RecordBatch(schema, subset3);
     }
 };
 _a4 = Symbol.toStringTag;
 RecordBatch[_a4] = ((proto) => {
     proto._nullCount = -1;
     proto[Symbol.isConcatSpreadable] = true;
     return "RecordBatch";
 })(RecordBatch.prototype);
 
-function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max5, col) => Math.max(max5, col.length), 0)) {
+function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max9, col) => Math.max(max9, col.length), 0)) {
     var _b2;
     const fields = [...schema.fields];
-    const children2 = [...chunks];
+    const children3 = [...chunks];
     const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
-    for (const [idx, field2] of schema.fields.entries()) {
+    for (const [idx, field3] of schema.fields.entries()) {
         const chunk = chunks[idx];
         if (!chunk || chunk.length !== maxLength) {
-            fields[idx] = field2.clone({
+            fields[idx] = field3.clone({
                 nullable: true
             });
-            children2[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
-                type: field2.type,
+            children3[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
+                type: field3.type,
                 length: maxLength,
                 nullCount: maxLength,
                 nullBitmap: new Uint8Array(nullBitmapSize)
             });
         }
     }
     return [
         schema.assign(fields),
         makeData({
             type: new Struct(fields),
             length: maxLength,
-            children: children2
+            children: children3
         })
     ];
 }
 
-function collectDictionaries(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {
+function collectDictionaries(fields, children3, dictionaries = /* @__PURE__ */ new Map()) {
     for (let i = -1, n = fields.length; ++i < n;) {
-        const field2 = fields[i];
-        const type2 = field2.type;
-        const data = children2[i];
-        if (DataType.isDictionary(type2)) {
-            if (!dictionaries.has(type2.id)) {
+        const field3 = fields[i];
+        const type3 = field3.type;
+        const data = children3[i];
+        if (DataType.isDictionary(type3)) {
+            if (!dictionaries.has(type3.id)) {
                 if (data.dictionary) {
-                    dictionaries.set(type2.id, data.dictionary);
+                    dictionaries.set(type3.id, data.dictionary);
                 }
-            } else if (dictionaries.get(type2.id) !== data.dictionary) {
+            } else if (dictionaries.get(type3.id) !== data.dictionary) {
                 throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
             }
         }
-        if (type2.children && type2.children.length > 0) {
-            collectDictionaries(type2.children, data.children, dictionaries);
+        if (type3.children && type3.children.length > 0) {
+            collectDictionaries(type3.children, data.children, dictionaries);
         }
     }
     return dictionaries;
 }
 var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
     constructor(schema) {
-        const children2 = schema.fields.map((f) => makeData({
+        const children3 = schema.fields.map((f) => makeData({
             type: f.type
         }));
         const data = makeData({
             type: new Struct(schema.fields),
             nullCount: 0,
-            children: children2
+            children: children3
         });
         super(schema, data);
     }
 };
 
-// node_modules/apache-arrow/fb/body-compression-method.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/body-compression-method.mjs
 var BodyCompressionMethod;
 (function(BodyCompressionMethod2) {
     BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
 })(BodyCompressionMethod || (BodyCompressionMethod = {}));
 
-// node_modules/apache-arrow/fb/compression-type.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/compression-type.mjs
 var CompressionType;
 (function(CompressionType2) {
     CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
     CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
 })(CompressionType || (CompressionType = {}));
 
-// node_modules/apache-arrow/fb/body-compression.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/body-compression.mjs
 var BodyCompression = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsBodyCompression(bb2, obj) {
-        return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsBodyCompression(bb3, obj) {
+        return (obj || new BodyCompression()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsBodyCompression(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsBodyCompression(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new BodyCompression()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * Compressor library.
      * For LZ4_FRAME, each compressed buffer must consist of a single frame.
      */
     codec() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt8(this.bb_pos + offset3) : CompressionType.LZ4_FRAME;
     }
     /**
      * Indicates the way the record batch body was compressed
      */
     method() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.readInt8(this.bb_pos + offset3) : BodyCompressionMethod.BUFFER;
     }
     static startBodyCompression(builder) {
         builder.startObject(2);
     }
     static addCodec(builder, codec) {
         builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
     }
     static addMethod(builder, method) {
         builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
     }
     static endBodyCompression(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
     static createBodyCompression(builder, codec, method) {
         BodyCompression.startBodyCompression(builder);
         BodyCompression.addCodec(builder, codec);
         BodyCompression.addMethod(builder, method);
         return BodyCompression.endBodyCompression(builder);
     }
 };
 
-// node_modules/apache-arrow/fb/buffer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/buffer.mjs
 var Buffer2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
     /**
      * The relative offset into the shared memory page where the bytes for this
      * buffer starts
      */
     offset() {
@@ -44500,31 +79206,31 @@
      */
     length() {
         return this.bb.readInt64(this.bb_pos + 8);
     }
     static sizeOf() {
         return 16;
     }
-    static createBuffer(builder, offset2, length4) {
+    static createBuffer(builder, offset3, length7) {
         builder.prep(8, 16);
-        builder.writeInt64(length4);
-        builder.writeInt64(offset2);
+        builder.writeInt64(length7);
+        builder.writeInt64(offset3);
         return builder.offset();
     }
 };
 
-// node_modules/apache-arrow/fb/field-node.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/field-node.mjs
 var FieldNode = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
     /**
      * The number of value slots in the Arrow array at this level of a nested
      * tree
      */
     length() {
@@ -44537,87 +79243,87 @@
      */
     nullCount() {
         return this.bb.readInt64(this.bb_pos + 8);
     }
     static sizeOf() {
         return 16;
     }
-    static createFieldNode(builder, length4, null_count) {
+    static createFieldNode(builder, length7, null_count) {
         builder.prep(8, 16);
         builder.writeInt64(null_count);
-        builder.writeInt64(length4);
+        builder.writeInt64(length7);
         return builder.offset();
     }
 };
 
-// node_modules/apache-arrow/fb/record-batch.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/record-batch.mjs
 var RecordBatch2 = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsRecordBatch(bb2, obj) {
-        return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsRecordBatch(bb3, obj) {
+        return (obj || new RecordBatch2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsRecordBatch(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsRecordBatch(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new RecordBatch2()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     /**
      * number of records / rows. The arrays in the batch should all have this
      * length
      */
     length() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt64(this.bb_pos + offset3) : this.bb.createLong(0, 0);
     }
     /**
      * Nodes correspond to the pre-ordered flattened logical schema
      */
-    nodes(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;
+    nodes(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset3) + index5 * 16, this.bb) : null;
     }
     nodesLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     /**
      * Buffers correspond to the pre-ordered flattened buffer tree
      *
      * The number of buffers appended to this list depends on the schema. For
      * example, most primitive arrays will have 2 buffers, 1 for the validity
      * bitmap and 1 for the values. For struct arrays, there will only be a
      * single buffer for the validity (nulls) bitmap
      */
-    buffers(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;
+    buffers(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset3) + index5 * 16, this.bb) : null;
     }
     buffersLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     /**
      * Optional compression of the message body
      */
     compression(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset3), this.bb) : null;
     }
     static startRecordBatch(builder) {
         builder.startObject(4);
     }
-    static addLength(builder, length4) {
-        builder.addFieldInt64(0, length4, builder.createLong(0, 0));
+    static addLength(builder, length7) {
+        builder.addFieldInt64(0, length7, builder.createLong(0, 0));
     }
     static addNodes(builder, nodesOffset) {
         builder.addFieldOffset(1, nodesOffset, 0);
     }
     static startNodesVector(builder, numElems) {
         builder.startVector(16, numElems, 8);
     }
@@ -44627,125 +79333,125 @@
     static startBuffersVector(builder, numElems) {
         builder.startVector(16, numElems, 8);
     }
     static addCompression(builder, compressionOffset) {
         builder.addFieldOffset(3, compressionOffset, 0);
     }
     static endRecordBatch(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
 };
 
-// node_modules/apache-arrow/fb/dictionary-batch.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/dictionary-batch.mjs
 var DictionaryBatch = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsDictionaryBatch(bb2, obj) {
-        return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsDictionaryBatch(bb3, obj) {
+        return (obj || new DictionaryBatch()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsDictionaryBatch(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new DictionaryBatch()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     id() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt64(this.bb_pos + offset3) : this.bb.createLong(0, 0);
     }
     data(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset3), this.bb) : null;
     }
     /**
      * If isDelta is true the values in the dictionary are to be appended to a
      * dictionary with the indicated id. If isDelta is false this dictionary
      * should replace the existing dictionary.
      */
     isDelta() {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? !!this.bb.readInt8(this.bb_pos + offset3) : false;
     }
     static startDictionaryBatch(builder) {
         builder.startObject(3);
     }
-    static addId(builder, id2) {
-        builder.addFieldInt64(0, id2, builder.createLong(0, 0));
+    static addId(builder, id3) {
+        builder.addFieldInt64(0, id3, builder.createLong(0, 0));
     }
     static addData(builder, dataOffset) {
         builder.addFieldOffset(1, dataOffset, 0);
     }
     static addIsDelta(builder, isDelta) {
         builder.addFieldInt8(2, +isDelta, 0);
     }
     static endDictionaryBatch(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
 };
 
-// node_modules/apache-arrow/fb/message-header.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/message-header.mjs
 var MessageHeader2;
 (function(MessageHeader3) {
     MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
     MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
     MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
     MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
     MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
     MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
 })(MessageHeader2 || (MessageHeader2 = {}));
 
-// node_modules/apache-arrow/fb/message.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/fb/message.mjs
 var Message = class {
     constructor() {
         this.bb = null;
         this.bb_pos = 0;
     }
-    __init(i, bb2) {
+    __init(i, bb3) {
         this.bb_pos = i;
-        this.bb = bb2;
+        this.bb = bb3;
         return this;
     }
-    static getRootAsMessage(bb2, obj) {
-        return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getRootAsMessage(bb3, obj) {
+        return (obj || new Message()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
-    static getSizePrefixedRootAsMessage(bb2, obj) {
-        bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
-        return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
+    static getSizePrefixedRootAsMessage(bb3, obj) {
+        bb3.setPosition(bb3.position() + SIZE_PREFIX_LENGTH);
+        return (obj || new Message()).__init(bb3.readInt32(bb3.position()) + bb3.position(), bb3);
     }
     version() {
-        const offset2 = this.bb.__offset(this.bb_pos, 4);
-        return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;
+        const offset3 = this.bb.__offset(this.bb_pos, 4);
+        return offset3 ? this.bb.readInt16(this.bb_pos + offset3) : MetadataVersion2.V1;
     }
     headerType() {
-        const offset2 = this.bb.__offset(this.bb_pos, 6);
-        return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader2.NONE;
+        const offset3 = this.bb.__offset(this.bb_pos, 6);
+        return offset3 ? this.bb.readUint8(this.bb_pos + offset3) : MessageHeader2.NONE;
     }
     // @ts-ignore
     header(obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 8);
-        return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
+        const offset3 = this.bb.__offset(this.bb_pos, 8);
+        return offset3 ? this.bb.__union(obj, this.bb_pos + offset3) : null;
     }
     bodyLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 10);
-        return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);
+        const offset3 = this.bb.__offset(this.bb_pos, 10);
+        return offset3 ? this.bb.readInt64(this.bb_pos + offset3) : this.bb.createLong(0, 0);
     }
-    customMetadata(index3, obj) {
-        const offset2 = this.bb.__offset(this.bb_pos, 12);
-        return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;
+    customMetadata(index5, obj) {
+        const offset3 = this.bb.__offset(this.bb_pos, 12);
+        return offset3 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset3) + index5 * 4), this.bb) : null;
     }
     customMetadataLength() {
-        const offset2 = this.bb.__offset(this.bb_pos, 12);
-        return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
+        const offset3 = this.bb.__offset(this.bb_pos, 12);
+        return offset3 ? this.bb.__vector_len(this.bb_pos + offset3) : 0;
     }
     static startMessage(builder) {
         builder.startObject(5);
     }
     static addVersion(builder, version) {
         builder.addFieldInt16(0, version, MetadataVersion2.V1);
     }
@@ -44768,35 +79474,35 @@
         }
         return builder.endVector();
     }
     static startCustomMetadataVector(builder, numElems) {
         builder.startVector(4, numElems, 4);
     }
     static endMessage(builder) {
-        const offset2 = builder.endObject();
-        return offset2;
+        const offset3 = builder.endObject();
+        return offset3;
     }
-    static finishMessageBuffer(builder, offset2) {
-        builder.finish(offset2);
+    static finishMessageBuffer(builder, offset3) {
+        builder.finish(offset3);
     }
-    static finishSizePrefixedMessageBuffer(builder, offset2) {
-        builder.finish(offset2, void 0, true);
+    static finishSizePrefixedMessageBuffer(builder, offset3) {
+        builder.finish(offset3, void 0, true);
     }
     static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
         Message.startMessage(builder);
         Message.addVersion(builder, version);
         Message.addHeaderType(builder, headerType);
         Message.addHeader(builder, headerOffset);
         Message.addBodyLength(builder, bodyLength);
         Message.addCustomMetadata(builder, customMetadataOffset);
         return Message.endMessage(builder);
     }
 };
 
-// node_modules/apache-arrow/visitor/typeassembler.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/typeassembler.mjs
 var Long3 = Long;
 var TypeAssembler = class extends Visitor {
     visit(node, builder) {
         return node == null || builder == null ? void 0 : super.visit(node, builder);
     }
     visitNull(_node, b) {
         Null2.startNull(b);
@@ -44897,15 +79603,15 @@
         Map2.startMap(b);
         Map2.addKeysSorted(b, node.keysSorted);
         return Map2.endMap(b);
     }
 };
 var instance8 = new TypeAssembler();
 
-// node_modules/apache-arrow/ipc/metadata/json.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/metadata/json.mjs
 function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
     return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
 }
 
 function recordBatchFromJSON(b) {
     return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
 }
@@ -44919,87 +79625,87 @@
 }
 
 function fieldChildrenFromJSON(_field, dictionaries) {
     return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
 }
 
 function fieldNodesFromJSON(xs) {
-    return (xs || []).reduce((fieldNodes, column2) => [
+    return (xs || []).reduce((fieldNodes, column3) => [
         ...fieldNodes,
-        new FieldNode2(column2["count"], nullCountFromJSON(column2["VALIDITY"])),
-        ...fieldNodesFromJSON(column2["children"])
+        new FieldNode2(column3["count"], nullCountFromJSON(column3["VALIDITY"])),
+        ...fieldNodesFromJSON(column3["children"])
     ], []);
 }
 
 function buffersFromJSON(xs, buffers = []) {
     for (let i = -1, n = (xs || []).length; ++i < n;) {
-        const column2 = xs[i];
-        column2["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column2["VALIDITY"].length));
-        column2["TYPE"] && buffers.push(new BufferRegion(buffers.length, column2["TYPE"].length));
-        column2["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column2["OFFSET"].length));
-        column2["DATA"] && buffers.push(new BufferRegion(buffers.length, column2["DATA"].length));
-        buffers = buffersFromJSON(column2["children"], buffers);
+        const column3 = xs[i];
+        column3["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column3["VALIDITY"].length));
+        column3["TYPE"] && buffers.push(new BufferRegion(buffers.length, column3["TYPE"].length));
+        column3["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column3["OFFSET"].length));
+        column3["DATA"] && buffers.push(new BufferRegion(buffers.length, column3["DATA"].length));
+        buffers = buffersFromJSON(column3["children"], buffers);
     }
     return buffers;
 }
 
 function nullCountFromJSON(validity) {
-    return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);
+    return (validity || []).reduce((sum8, val) => sum8 + +(val === 0), 0);
 }
 
 function fieldFromJSON(_field, dictionaries) {
-    let id2;
+    let id3;
     let keys;
-    let field2;
+    let field3;
     let dictMeta;
-    let type2;
+    let type3;
     let dictType;
     if (!dictionaries || !(dictMeta = _field["dictionary"])) {
-        type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
-        field2 = new Field2(_field["name"], type2, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
-    } else if (!dictionaries.has(id2 = dictMeta["id"])) {
+        type3 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
+        field3 = new Field2(_field["name"], type3, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
+    } else if (!dictionaries.has(id3 = dictMeta["id"])) {
         keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
-        dictionaries.set(id2, type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
-        dictType = new Dictionary(type2, keys, id2, dictMeta["isOrdered"]);
-        field2 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
+        dictionaries.set(id3, type3 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
+        dictType = new Dictionary(type3, keys, id3, dictMeta["isOrdered"]);
+        field3 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
     } else {
         keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
-        dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta["isOrdered"]);
-        field2 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
+        dictType = new Dictionary(dictionaries.get(id3), keys, id3, dictMeta["isOrdered"]);
+        field3 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
     }
-    return field2 || null;
+    return field3 || null;
 }
 
 function customMetadataFromJSON(_metadata) {
     return new Map(Object.entries(_metadata || {}));
 }
 
 function indexTypeFromJSON(_type) {
     return new Int_(_type["isSigned"], _type["bitWidth"]);
 }
 
-function typeFromJSON(f, children2) {
+function typeFromJSON(f, children3) {
     const typeId = f["type"]["name"];
     switch (typeId) {
         case "NONE":
             return new Null();
         case "null":
             return new Null();
         case "binary":
             return new Binary();
         case "utf8":
             return new Utf8();
         case "bool":
             return new Bool();
         case "list":
-            return new List((children2 || [])[0]);
+            return new List((children3 || [])[0]);
         case "struct":
-            return new Struct(children2 || []);
+            return new Struct(children3 || []);
         case "struct_":
-            return new Struct(children2 || []);
+            return new Struct(children3 || []);
     }
     switch (typeId) {
         case "int": {
             const t = f["type"];
             return new Int_(t["isSigned"], t["bitWidth"]);
         }
         case "floatingpoint": {
@@ -45024,33 +79730,33 @@
         }
         case "interval": {
             const t = f["type"];
             return new Interval_(IntervalUnit[t["unit"]]);
         }
         case "union": {
             const t = f["type"];
-            return new Union_(UnionMode[t["mode"]], t["typeIds"] || [], children2 || []);
+            return new Union_(UnionMode[t["mode"]], t["typeIds"] || [], children3 || []);
         }
         case "fixedsizebinary": {
             const t = f["type"];
             return new FixedSizeBinary(t["byteWidth"]);
         }
         case "fixedsizelist": {
             const t = f["type"];
-            return new FixedSizeList(t["listSize"], (children2 || [])[0]);
+            return new FixedSizeList(t["listSize"], (children3 || [])[0]);
         }
         case "map": {
             const t = f["type"];
-            return new Map_((children2 || [])[0], t["keysSorted"]);
+            return new Map_((children3 || [])[0], t["keysSorted"]);
         }
     }
     throw new Error(`Unrecognized type: "${typeId}"`);
 }
 
-// node_modules/apache-arrow/ipc/metadata/message.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/metadata/message.mjs
 var Long4 = Long;
 var Builder4 = Builder2;
 var ByteBuffer3 = ByteBuffer;
 var Message2 = class {
     constructor(bodyLength, version, headerType, header) {
         this._version = version;
         this._headerType = headerType;
@@ -45129,34 +79835,34 @@
         return this.headerType === MessageHeader.RecordBatch;
     }
     isDictionaryBatch() {
         return this.headerType === MessageHeader.DictionaryBatch;
     }
 };
 var RecordBatch3 = class {
-    constructor(length4, nodes, buffers) {
+    constructor(length7, nodes, buffers) {
         this._nodes = nodes;
         this._buffers = buffers;
-        this._length = typeof length4 === "number" ? length4 : length4.low;
+        this._length = typeof length7 === "number" ? length7 : length7.low;
     }
     get nodes() {
         return this._nodes;
     }
     get length() {
         return this._length;
     }
     get buffers() {
         return this._buffers;
     }
 };
 var DictionaryBatch2 = class {
-    constructor(data, id2, isDelta = false) {
+    constructor(data, id3, isDelta = false) {
         this._data = data;
         this._isDelta = isDelta;
-        this._id = typeof id2 === "number" ? id2 : id2.low;
+        this._id = typeof id3 === "number" ? id3 : id3.low;
     }
     get id() {
         return this._id;
     }
     get data() {
         return this._data;
     }
@@ -45170,51 +79876,51 @@
         return this.data.nodes;
     }
     get buffers() {
         return this.data.buffers;
     }
 };
 var BufferRegion = class {
-    constructor(offset2, length4) {
-        this.offset = typeof offset2 === "number" ? offset2 : offset2.low;
-        this.length = typeof length4 === "number" ? length4 : length4.low;
+    constructor(offset3, length7) {
+        this.offset = typeof offset3 === "number" ? offset3 : offset3.low;
+        this.length = typeof length7 === "number" ? length7 : length7.low;
     }
 };
 var FieldNode2 = class {
-    constructor(length4, nullCount) {
-        this.length = typeof length4 === "number" ? length4 : length4.low;
+    constructor(length7, nullCount) {
+        this.length = typeof length7 === "number" ? length7 : length7.low;
         this.nullCount = typeof nullCount === "number" ? nullCount : nullCount.low;
     }
 };
 
-function messageHeaderFromJSON(message, type2) {
+function messageHeaderFromJSON(message, type3) {
     return () => {
-        switch (type2) {
+        switch (type3) {
             case MessageHeader.Schema:
                 return Schema2.fromJSON(message);
             case MessageHeader.RecordBatch:
                 return RecordBatch3.fromJSON(message);
             case MessageHeader.DictionaryBatch:
                 return DictionaryBatch2.fromJSON(message);
         }
-        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);
+        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type3]}, type: ${type3} }`);
     };
 }
 
-function decodeMessageHeader(message, type2) {
+function decodeMessageHeader(message, type3) {
     return () => {
-        switch (type2) {
+        switch (type3) {
             case MessageHeader.Schema:
                 return Schema2.decode(message.header(new Schema()));
             case MessageHeader.RecordBatch:
                 return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
             case MessageHeader.DictionaryBatch:
                 return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
         }
-        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);
+        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type3]}, type: ${type3} }`);
     };
 }
 Field2["encode"] = encodeField;
 Field2["decode"] = decodeField;
 Field2["fromJSON"] = fieldFromJSON;
 Schema2["encode"] = encodeSchema;
 Schema2["decode"] = decodeSchema;
@@ -45283,45 +79989,45 @@
         if (f = schema.fields(i)) {
             fields[++j] = Field2.decode(f, dictionaries);
         }
     }
     return fields;
 }
 
-function decodeFieldChildren(field2, dictionaries) {
-    const children2 = [];
-    for (let f, i = -1, j = -1, n = field2.childrenLength(); ++i < n;) {
-        if (f = field2.children(i)) {
-            children2[++j] = Field2.decode(f, dictionaries);
+function decodeFieldChildren(field3, dictionaries) {
+    const children3 = [];
+    for (let f, i = -1, j = -1, n = field3.childrenLength(); ++i < n;) {
+        if (f = field3.children(i)) {
+            children3[++j] = Field2.decode(f, dictionaries);
         }
     }
-    return children2;
+    return children3;
 }
 
 function decodeField(f, dictionaries) {
-    let id2;
-    let field2;
-    let type2;
+    let id3;
+    let field3;
+    let type3;
     let keys;
     let dictType;
     let dictMeta;
     if (!dictionaries || !(dictMeta = f.dictionary())) {
-        type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
-        field2 = new Field2(f.name(), type2, f.nullable(), decodeCustomMetadata(f));
-    } else if (!dictionaries.has(id2 = dictMeta.id().low)) {
+        type3 = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
+        field3 = new Field2(f.name(), type3, f.nullable(), decodeCustomMetadata(f));
+    } else if (!dictionaries.has(id3 = dictMeta.id().low)) {
         keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
-        dictionaries.set(id2, type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
-        dictType = new Dictionary(type2, keys, id2, dictMeta.isOrdered());
-        field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
+        dictionaries.set(id3, type3 = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
+        dictType = new Dictionary(type3, keys, id3, dictMeta.isOrdered());
+        field3 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
     } else {
         keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
-        dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());
-        field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
+        dictType = new Dictionary(dictionaries.get(id3), keys, id3, dictMeta.isOrdered());
+        field3 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
     }
-    return field2 || null;
+    return field3 || null;
 }
 
 function decodeCustomMetadata(parent) {
     const data = /* @__PURE__ */ new Map();
     if (parent) {
         for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {
             if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
@@ -45332,31 +80038,31 @@
     return data;
 }
 
 function decodeIndexType(_type) {
     return new Int_(_type.isSigned(), _type.bitWidth());
 }
 
-function decodeFieldType(f, children2) {
+function decodeFieldType(f, children3) {
     const typeId = f.typeType();
     switch (typeId) {
         case Type2["NONE"]:
             return new Null();
         case Type2["Null"]:
             return new Null();
         case Type2["Binary"]:
             return new Binary();
         case Type2["Utf8"]:
             return new Utf8();
         case Type2["Bool"]:
             return new Bool();
         case Type2["List"]:
-            return new List((children2 || [])[0]);
+            return new List((children3 || [])[0]);
         case Type2["Struct_"]:
-            return new Struct(children2 || []);
+            return new Struct(children3 || []);
     }
     switch (typeId) {
         case Type2["Int"]: {
             const t = f.type(new Int());
             return new Int_(t.isSigned(), t.bitWidth());
         }
         case Type2["FloatingPoint"]: {
@@ -45381,84 +80087,84 @@
         }
         case Type2["Interval"]: {
             const t = f.type(new Interval());
             return new Interval_(t.unit());
         }
         case Type2["Union"]: {
             const t = f.type(new Union());
-            return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);
+            return new Union_(t.mode(), t.typeIdsArray() || [], children3 || []);
         }
         case Type2["FixedSizeBinary"]: {
             const t = f.type(new FixedSizeBinary2());
             return new FixedSizeBinary(t.byteWidth());
         }
         case Type2["FixedSizeList"]: {
             const t = f.type(new FixedSizeList2());
-            return new FixedSizeList(t.listSize(), (children2 || [])[0]);
+            return new FixedSizeList(t.listSize(), (children3 || [])[0]);
         }
         case Type2["Map"]: {
             const t = f.type(new Map2());
-            return new Map_((children2 || [])[0], t.keysSorted());
+            return new Map_((children3 || [])[0], t.keysSorted());
         }
     }
     throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
 }
 
 function encodeSchema(b, schema) {
     const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
     Schema.startFieldsVector(b, fieldOffsets.length);
     const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
-    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k2, v2]) => {
-        const key = b.createString(`${k2}`);
-        const val = b.createString(`${v2}`);
+    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k3, v3]) => {
+        const key = b.createString(`${k3}`);
+        const val = b.createString(`${v3}`);
         KeyValue.startKeyValue(b);
         KeyValue.addKey(b, key);
         KeyValue.addValue(b, val);
         return KeyValue.endKeyValue(b);
     }));
     Schema.startSchema(b);
     Schema.addFields(b, fieldsVectorOffset);
     Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
     if (metadataOffset !== -1) {
         Schema.addCustomMetadata(b, metadataOffset);
     }
     return Schema.endSchema(b);
 }
 
-function encodeField(b, field2) {
+function encodeField(b, field3) {
     let nameOffset = -1;
     let typeOffset = -1;
     let dictionaryOffset = -1;
-    const type2 = field2.type;
-    let typeId = field2.typeId;
-    if (!DataType.isDictionary(type2)) {
-        typeOffset = instance8.visit(type2, b);
-    } else {
-        typeId = type2.dictionary.typeId;
-        dictionaryOffset = instance8.visit(type2, b);
-        typeOffset = instance8.visit(type2.dictionary, b);
+    const type3 = field3.type;
+    let typeId = field3.typeId;
+    if (!DataType.isDictionary(type3)) {
+        typeOffset = instance8.visit(type3, b);
+    } else {
+        typeId = type3.dictionary.typeId;
+        dictionaryOffset = instance8.visit(type3, b);
+        typeOffset = instance8.visit(type3.dictionary, b);
     }
-    const childOffsets = (type2.children || []).map((f) => Field2.encode(b, f));
+    const childOffsets = (type3.children || []).map((f) => Field2.encode(b, f));
     const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
-    const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field2.metadata].map(([k2, v2]) => {
-        const key = b.createString(`${k2}`);
-        const val = b.createString(`${v2}`);
+    const metadataOffset = !(field3.metadata && field3.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field3.metadata].map(([k3, v3]) => {
+        const key = b.createString(`${k3}`);
+        const val = b.createString(`${v3}`);
         KeyValue.startKeyValue(b);
         KeyValue.addKey(b, key);
         KeyValue.addValue(b, val);
         return KeyValue.endKeyValue(b);
     }));
-    if (field2.name) {
-        nameOffset = b.createString(field2.name);
+    if (field3.name) {
+        nameOffset = b.createString(field3.name);
     }
     Field.startField(b);
     Field.addType(b, typeOffset);
     Field.addTypeType(b, typeId);
     Field.addChildren(b, childrenVectorOffset);
-    Field.addNullable(b, !!field2.nullable);
+    Field.addNullable(b, !!field3.nullable);
     if (nameOffset !== -1) {
         Field.addName(b, nameOffset);
     }
     if (dictionaryOffset !== -1) {
         Field.addDictionary(b, dictionaryOffset);
     }
     if (metadataOffset !== -1) {
@@ -45508,17 +80214,17 @@
         256,
         true
         /* littleEndian */
     );
     return new Int16Array(buffer)[0] === 256;
 })();
 
-// node_modules/apache-arrow/ipc/message.mjs
-var invalidMessageType = (type2) => `Expected ${MessageHeader[type2]} Message in stream, but was null or length 0.`;
-var nullMessage = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader[type2]} Message is null or length 0.`;
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/message.mjs
+var invalidMessageType = (type3) => `Expected ${MessageHeader[type3]} Message in stream, but was null or length 0.`;
+var nullMessage = (type3) => `Header pointer of flatbuffer-encoded ${MessageHeader[type3]} Message is null or length 0.`;
 var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
 var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
 var MessageReader = class {
     constructor(source) {
             this.source = source instanceof ByteStream ? source : new ByteStream(source);
         }
         [Symbol.iterator]() {
@@ -45539,21 +80245,21 @@
     }
     throw (value) {
         return this.source.throw(value);
     }
     return (value) {
         return this.source.return(value);
     }
-    readMessage(type2) {
+    readMessage(type3) {
         let r;
         if ((r = this.next()).done) {
             return null;
         }
-        if (type2 != null && r.value.headerType !== type2) {
-            throw new Error(invalidMessageType(type2));
+        if (type3 != null && r.value.headerType !== type3) {
+            throw new Error(invalidMessageType(type3));
         }
         return r.value;
     }
     readMessageBody(bodyLength) {
         if (bodyLength <= 0) {
             return new Uint8Array(0);
         }
@@ -45564,26 +80270,26 @@
         return (
             /* 1. */
             buf.byteOffset % 8 === 0 && /* 2. */
             buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
         );
     }
     readSchema(throwIfNull = false) {
-        const type2 = MessageHeader.Schema;
-        const message = this.readMessage(type2);
+        const type3 = MessageHeader.Schema;
+        const message = this.readMessage(type3);
         const schema = message === null || message === void 0 ? void 0 : message.header();
         if (throwIfNull && !schema) {
-            throw new Error(nullMessage(type2));
+            throw new Error(nullMessage(type3));
         }
         return schema;
     }
     readMetadataLength() {
         const buf = this.source.read(PADDING);
-        const bb2 = buf && new ByteBuffer(buf);
-        const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
+        const bb3 = buf && new ByteBuffer(buf);
+        const len = (bb3 === null || bb3 === void 0 ? void 0 : bb3.readInt32(0)) || 0;
         return {
             done: len === 0,
             value: len
         };
     }
     readMetadata(metadataLength) {
         const buf = this.source.read(metadataLength);
@@ -45627,22 +80333,22 @@
         });
     }
     return (value) {
         return __awaiter(this, void 0, void 0, function*() {
             return yield this.source.return(value);
         });
     }
-    readMessage(type2) {
+    readMessage(type3) {
         return __awaiter(this, void 0, void 0, function*() {
             let r;
             if ((r = yield this.next()).done) {
                 return null;
             }
-            if (type2 != null && r.value.headerType !== type2) {
-                throw new Error(invalidMessageType(type2));
+            if (type3 != null && r.value.headerType !== type3) {
+                throw new Error(invalidMessageType(type3));
             }
             return r.value;
         });
     }
     readMessageBody(bodyLength) {
         return __awaiter(this, void 0, void 0, function*() {
             if (bodyLength <= 0) {
@@ -45657,28 +80363,28 @@
                 buf.byteOffset % 8 === 0 && /* 2. */
                 buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
             );
         });
     }
     readSchema(throwIfNull = false) {
         return __awaiter(this, void 0, void 0, function*() {
-            const type2 = MessageHeader.Schema;
-            const message = yield this.readMessage(type2);
+            const type3 = MessageHeader.Schema;
+            const message = yield this.readMessage(type3);
             const schema = message === null || message === void 0 ? void 0 : message.header();
             if (throwIfNull && !schema) {
-                throw new Error(nullMessage(type2));
+                throw new Error(nullMessage(type3));
             }
             return schema;
         });
     }
     readMetadataLength() {
         return __awaiter(this, void 0, void 0, function*() {
             const buf = yield this.source.read(PADDING);
-            const bb2 = buf && new ByteBuffer(buf);
-            const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
+            const bb3 = buf && new ByteBuffer(buf);
+            const len = (bb3 === null || bb3 === void 0 ? void 0 : bb3.readInt32(0)) || 0;
             return {
                 done: len === 0,
                 value: len
             };
         });
     }
     readMetadata(metadataLength) {
@@ -45739,64 +80445,64 @@
         this._body = [];
         return ITERATOR_DONE;
     }
     readMessageBody(_bodyLength) {
         return flattenDataSources(this._body);
 
         function flattenDataSources(xs) {
-            return (xs || []).reduce((buffers, column2) => [
+            return (xs || []).reduce((buffers, column3) => [
                 ...buffers,
-                ...column2["VALIDITY"] && [column2["VALIDITY"]] || [],
-                ...column2["TYPE"] && [column2["TYPE"]] || [],
-                ...column2["OFFSET"] && [column2["OFFSET"]] || [],
-                ...column2["DATA"] && [column2["DATA"]] || [],
-                ...flattenDataSources(column2["children"])
+                ...column3["VALIDITY"] && [column3["VALIDITY"]] || [],
+                ...column3["TYPE"] && [column3["TYPE"]] || [],
+                ...column3["OFFSET"] && [column3["OFFSET"]] || [],
+                ...column3["DATA"] && [column3["DATA"]] || [],
+                ...flattenDataSources(column3["children"])
             ], []);
         }
     }
-    readMessage(type2) {
+    readMessage(type3) {
         let r;
         if ((r = this.next()).done) {
             return null;
         }
-        if (type2 != null && r.value.headerType !== type2) {
-            throw new Error(invalidMessageType(type2));
+        if (type3 != null && r.value.headerType !== type3) {
+            throw new Error(invalidMessageType(type3));
         }
         return r.value;
     }
     readSchema() {
-        const type2 = MessageHeader.Schema;
-        const message = this.readMessage(type2);
+        const type3 = MessageHeader.Schema;
+        const message = this.readMessage(type3);
         const schema = message === null || message === void 0 ? void 0 : message.header();
         if (!message || !schema) {
-            throw new Error(nullMessage(type2));
+            throw new Error(nullMessage(type3));
         }
         return schema;
     }
 };
 var PADDING = 4;
 var MAGIC_STR = "ARROW1";
 var MAGIC = new Uint8Array(MAGIC_STR.length);
 for (let i = 0; i < MAGIC_STR.length; i += 1) {
     MAGIC[i] = MAGIC_STR.codePointAt(i);
 }
 
-function checkForMagicArrowString(buffer, index3 = 0) {
+function checkForMagicArrowString(buffer, index5 = 0) {
     for (let i = -1, n = MAGIC.length; ++i < n;) {
-        if (MAGIC[i] !== buffer[index3 + i]) {
+        if (MAGIC[i] !== buffer[index5 + i]) {
             return false;
         }
     }
     return true;
 }
 var magicLength = MAGIC.length;
 var magicAndPadding = magicLength + PADDING;
 var magicX2AndPadding = magicLength * 2 + PADDING;
 
-// node_modules/apache-arrow/ipc/reader.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/reader.mjs
 var RecordBatchReader = class extends ReadableInterop {
     constructor(impl) {
         super();
         this._impl = impl;
     }
     get closed() {
         return this._impl.closed;
@@ -45849,16 +80555,16 @@
         this._nodeStream = void 0;
         return this;
     }
     open(options) {
         const opening = this._impl.open(options);
         return isPromise(opening) ? opening.then(() => this) : this;
     }
-    readRecordBatch(index3) {
-            return this._impl.isFile() ? this._impl.readRecordBatch(index3) : null;
+    readRecordBatch(index5) {
+            return this._impl.isFile() ? this._impl.readRecordBatch(index5) : null;
         }
         [Symbol.iterator]() {
             return this._impl[Symbol.iterator]();
         }
         [Symbol.asyncIterator]() {
             return this._impl[Symbol.asyncIterator]();
         }
@@ -45904,15 +80610,15 @@
         }
         return fromByteStream(new ByteStream(source));
     }
     /** @nocollapse */
     static readAll(source) {
         if (source instanceof RecordBatchReader) {
             return source.isSync() ? readAllSync(source) : readAllAsync(source);
-        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {
+        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable3(source) || isIteratorResult(source)) {
             return readAllSync(source);
         }
         return readAllAsync(source);
     }
 };
 var RecordBatchStreamReader = class extends RecordBatchReader {
     constructor(_impl) {
@@ -46010,36 +80716,36 @@
         this._dictionaryIndex = 0;
         this._recordBatchIndex = 0;
         this.schema = schema;
         this.dictionaries = /* @__PURE__ */ new Map();
         return this;
     }
     _loadRecordBatch(header, body) {
-        const children2 = this._loadVectors(header, body, this.schema.fields);
+        const children3 = this._loadVectors(header, body, this.schema.fields);
         const data = makeData({
             type: new Struct(this.schema.fields),
             length: header.length,
-            children: children2
+            children: children3
         });
         return new RecordBatch(this.schema, data);
     }
     _loadDictionaryBatch(header, body) {
         const {
-            id: id2,
+            id: id3,
             isDelta
         } = header;
         const {
             dictionaries,
             schema
         } = this;
-        const dictionary = dictionaries.get(id2);
+        const dictionary = dictionaries.get(id3);
         if (isDelta || !dictionary) {
-            const type2 = schema.dictionaries.get(id2);
-            const data = this._loadVectors(header.data, body, [type2]);
-            return (dictionary && isDelta ? dictionary.concat(new Vector2(data)) : new Vector2(data)).memoize();
+            const type3 = schema.dictionaries.get(id3);
+            const data = this._loadVectors(header.data, body, [type3]);
+            return (dictionary && isDelta ? dictionary.concat(new Vector3(data)) : new Vector3(data)).memoize();
         }
         return dictionary.memoize();
     }
     _loadVectors(header, body, types) {
         return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
     }
 };
@@ -46105,29 +80811,29 @@
                     done: false,
                     value: recordBatch
                 };
             } else if (message.isDictionaryBatch()) {
                 this._dictionaryIndex++;
                 const header = message.header();
                 const buffer = reader.readMessageBody(message.bodyLength);
-                const vector2 = this._loadDictionaryBatch(header, buffer);
-                this.dictionaries.set(header.id, vector2);
+                const vector3 = this._loadDictionaryBatch(header, buffer);
+                this.dictionaries.set(header.id, vector3);
             }
         }
         if (this.schema && this._recordBatchIndex === 0) {
             this._recordBatchIndex++;
             return {
                 done: false,
                 value: new _InternalEmptyPlaceholderRecordBatch(this.schema)
             };
         }
         return this.return();
     }
-    _readNextMessageAndValidate(type2) {
-        return this._reader.readMessage(type2);
+    _readNextMessageAndValidate(type3) {
+        return this._reader.readMessage(type3);
     }
 };
 var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
     constructor(source, dictionaries) {
         super(dictionaries);
         this._reader = new AsyncMessageReader(this._handle = source);
     }
@@ -46197,31 +80903,31 @@
                         done: false,
                         value: recordBatch
                     };
                 } else if (message.isDictionaryBatch()) {
                     this._dictionaryIndex++;
                     const header = message.header();
                     const buffer = yield reader.readMessageBody(message.bodyLength);
-                    const vector2 = this._loadDictionaryBatch(header, buffer);
-                    this.dictionaries.set(header.id, vector2);
+                    const vector3 = this._loadDictionaryBatch(header, buffer);
+                    this.dictionaries.set(header.id, vector3);
                 }
             }
             if (this.schema && this._recordBatchIndex === 0) {
                 this._recordBatchIndex++;
                 return {
                     done: false,
                     value: new _InternalEmptyPlaceholderRecordBatch(this.schema)
                 };
             }
             return yield this.return();
         });
     }
-    _readNextMessageAndValidate(type2) {
+    _readNextMessageAndValidate(type3) {
         return __awaiter(this, void 0, void 0, function*() {
-            return yield this._reader.readMessage(type2);
+            return yield this._reader.readMessage(type3);
         });
     }
 };
 var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
     constructor(source, dictionaries) {
         super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
     }
@@ -46245,65 +80951,65 @@
             this.schema = (this._footer = this._readFooter()).schema;
             for (const block of this._footer.dictionaryBatches()) {
                 block && this._readDictionaryBatch(this._dictionaryIndex++);
             }
         }
         return super.open(options);
     }
-    readRecordBatch(index3) {
+    readRecordBatch(index5) {
         var _a5;
         if (this.closed) {
             return null;
         }
         if (!this._footer) {
             this.open();
         }
-        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);
+        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index5);
         if (block && this._handle.seek(block.offset)) {
             const message = this._reader.readMessage(MessageHeader.RecordBatch);
             if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                 const header = message.header();
                 const buffer = this._reader.readMessageBody(message.bodyLength);
                 const recordBatch = this._loadRecordBatch(header, buffer);
                 return recordBatch;
             }
         }
         return null;
     }
-    _readDictionaryBatch(index3) {
+    _readDictionaryBatch(index5) {
         var _a5;
-        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);
+        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index5);
         if (block && this._handle.seek(block.offset)) {
             const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
             if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                 const header = message.header();
                 const buffer = this._reader.readMessageBody(message.bodyLength);
-                const vector2 = this._loadDictionaryBatch(header, buffer);
-                this.dictionaries.set(header.id, vector2);
+                const vector3 = this._loadDictionaryBatch(header, buffer);
+                this.dictionaries.set(header.id, vector3);
             }
         }
     }
     _readFooter() {
         const {
             _handle
         } = this;
-        const offset2 = _handle.size - magicAndPadding;
-        const length4 = _handle.readInt32(offset2);
-        const buffer = _handle.readAt(offset2 - length4, length4);
+        const offset3 = _handle.size - magicAndPadding;
+        const length7 = _handle.readInt32(offset3);
+        const buffer = _handle.readAt(offset3 - length7, length7);
         return Footer_.decode(buffer);
     }
-    _readNextMessageAndValidate(type2) {
+    _readNextMessageAndValidate(type3) {
         var _a5;
         if (!this._footer) {
             this.open();
         }
         if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
             const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
             if (block && this._handle.seek(block.offset)) {
-                return this._reader.readMessage(type2);
+                return this._reader.readMessage(type3);
             }
         }
         return null;
     }
 };
 var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
     constructor(source, ...rest) {
@@ -46338,72 +81044,72 @@
                 for (const block of this._footer.dictionaryBatches()) {
                     block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
                 }
             }
             return yield _super.open.call(this, options);
         });
     }
-    readRecordBatch(index3) {
+    readRecordBatch(index5) {
         var _a5;
         return __awaiter(this, void 0, void 0, function*() {
             if (this.closed) {
                 return null;
             }
             if (!this._footer) {
                 yield this.open();
             }
-            const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);
+            const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index5);
             if (block && (yield this._handle.seek(block.offset))) {
                 const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
                 if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                     const header = message.header();
                     const buffer = yield this._reader.readMessageBody(message.bodyLength);
                     const recordBatch = this._loadRecordBatch(header, buffer);
                     return recordBatch;
                 }
             }
             return null;
         });
     }
-    _readDictionaryBatch(index3) {
+    _readDictionaryBatch(index5) {
         var _a5;
         return __awaiter(this, void 0, void 0, function*() {
-            const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);
+            const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index5);
             if (block && (yield this._handle.seek(block.offset))) {
                 const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
                 if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                     const header = message.header();
                     const buffer = yield this._reader.readMessageBody(message.bodyLength);
-                    const vector2 = this._loadDictionaryBatch(header, buffer);
-                    this.dictionaries.set(header.id, vector2);
+                    const vector3 = this._loadDictionaryBatch(header, buffer);
+                    this.dictionaries.set(header.id, vector3);
                 }
             }
         });
     }
     _readFooter() {
         return __awaiter(this, void 0, void 0, function*() {
             const {
                 _handle
             } = this;
             _handle._pending && (yield _handle._pending);
-            const offset2 = _handle.size - magicAndPadding;
-            const length4 = yield _handle.readInt32(offset2);
-            const buffer = yield _handle.readAt(offset2 - length4, length4);
+            const offset3 = _handle.size - magicAndPadding;
+            const length7 = yield _handle.readInt32(offset3);
+            const buffer = yield _handle.readAt(offset3 - length7, length7);
             return Footer_.decode(buffer);
         });
     }
-    _readNextMessageAndValidate(type2) {
+    _readNextMessageAndValidate(type3) {
         return __awaiter(this, void 0, void 0, function*() {
             if (!this._footer) {
                 yield this.open();
             }
             if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
                 const block = this._footer.getRecordBatch(this._recordBatchIndex);
                 if (block && (yield this._handle.seek(block.offset))) {
-                    return yield this._reader.readMessage(type2);
+                    return yield this._reader.readMessage(type3);
                 }
             }
             return null;
         });
     }
 };
 var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
@@ -46478,15 +81184,15 @@
         if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
             return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
         }
         return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
     });
 }
 
-// node_modules/apache-arrow/visitor/vectorassembler.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/visitor/vectorassembler.mjs
 var VectorAssembler = class extends Visitor {
     constructor() {
         super();
         this._byteLength = 0;
         this._nodes = [];
         this._buffers = [];
         this._bufferRegions = [];
@@ -46495,33 +81201,33 @@
     static assemble(...args) {
         const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
         const assembler = new VectorAssembler();
         assembler.visitMany(unwrap(args));
         return assembler;
     }
     visit(data) {
-        if (data instanceof Vector2) {
+        if (data instanceof Vector3) {
             this.visitMany(data.data);
             return this;
         }
         const {
-            type: type2
+            type: type3
         } = data;
-        if (!DataType.isDictionary(type2)) {
+        if (!DataType.isDictionary(type3)) {
             const {
-                length: length4,
+                length: length7,
                 nullCount
             } = data;
-            if (length4 > 2147483647) {
+            if (length7 > 2147483647) {
                 throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
             }
-            if (!DataType.isNull(type2)) {
-                addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length4, data.nullBitmap));
+            if (!DataType.isNull(type3)) {
+                addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length7, data.nullBitmap));
             }
-            this.nodes.push(new FieldNode2(length4, nullCount));
+            this.nodes.push(new FieldNode2(length7, nullCount));
         }
         return super.visit(data);
     }
     visitNull(_null) {
         return this;
     }
     visitDictionary(data) {
@@ -46537,97 +81243,97 @@
         return this._byteLength;
     }
     get bufferRegions() {
         return this._bufferRegions;
     }
 };
 
-function addBuffer(values2) {
-    const byteLength = values2.byteLength + 7 & ~7;
-    this.buffers.push(values2);
+function addBuffer(values3) {
+    const byteLength = values3.byteLength + 7 & ~7;
+    this.buffers.push(values3);
     this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
     this._byteLength += byteLength;
     return this;
 }
 
 function assembleUnion(data) {
     const {
-        type: type2,
-        length: length4,
+        type: type3,
+        length: length7,
         typeIds,
         valueOffsets
     } = data;
     addBuffer.call(this, typeIds);
-    if (type2.mode === UnionMode.Sparse) {
+    if (type3.mode === UnionMode.Sparse) {
         return assembleNestedVector.call(this, data);
-    } else if (type2.mode === UnionMode.Dense) {
+    } else if (type3.mode === UnionMode.Dense) {
         if (data.offset <= 0) {
             addBuffer.call(this, valueOffsets);
             return assembleNestedVector.call(this, data);
         } else {
-            const maxChildTypeId = typeIds.reduce((x4, y4) => Math.max(x4, y4), typeIds[0]);
+            const maxChildTypeId = typeIds.reduce((x7, y7) => Math.max(x7, y7), typeIds[0]);
             const childLengths = new Int32Array(maxChildTypeId + 1);
             const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
-            const shiftedOffsets = new Int32Array(length4);
-            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets);
-            for (let typeId, shift, index3 = -1; ++index3 < length4;) {
-                if ((shift = childOffsets[typeId = typeIds[index3]]) === -1) {
+            const shiftedOffsets = new Int32Array(length7);
+            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length7, valueOffsets);
+            for (let typeId, shift, index5 = -1; ++index5 < length7;) {
+                if ((shift = childOffsets[typeId = typeIds[index5]]) === -1) {
                     shift = childOffsets[typeId] = unshiftedOffsets[typeId];
                 }
-                shiftedOffsets[index3] = unshiftedOffsets[index3] - shift;
+                shiftedOffsets[index5] = unshiftedOffsets[index5] - shift;
                 ++childLengths[typeId];
             }
             addBuffer.call(this, shiftedOffsets);
-            for (let child, childIndex = -1, numChildren = type2.children.length; ++childIndex < numChildren;) {
+            for (let child, childIndex = -1, numChildren = type3.children.length; ++childIndex < numChildren;) {
                 if (child = data.children[childIndex]) {
-                    const typeId = type2.typeIds[childIndex];
-                    const childLength = Math.min(length4, childLengths[typeId]);
+                    const typeId = type3.typeIds[childIndex];
+                    const childLength = Math.min(length7, childLengths[typeId]);
                     this.visit(child.slice(childOffsets[typeId], childLength));
                 }
             }
         }
     }
     return this;
 }
 
 function assembleBoolVector(data) {
-    let values2;
+    let values3;
     if (data.nullCount >= data.length) {
         return addBuffer.call(this, new Uint8Array(0));
-    } else if ((values2 = data.values) instanceof Uint8Array) {
-        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values2));
+    } else if ((values3 = data.values) instanceof Uint8Array) {
+        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values3));
     }
     return addBuffer.call(this, packBools(data.values));
 }
 
 function assembleFlatVector(data) {
     return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
 }
 
 function assembleFlatListVector(data) {
     const {
-        length: length4,
-        values: values2,
+        length: length7,
+        values: values3,
         valueOffsets
     } = data;
     const firstOffset = valueOffsets[0];
-    const lastOffset = valueOffsets[length4];
-    const byteLength = Math.min(lastOffset - firstOffset, values2.byteLength - firstOffset);
-    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets));
-    addBuffer.call(this, values2.subarray(firstOffset, firstOffset + byteLength));
+    const lastOffset = valueOffsets[length7];
+    const byteLength = Math.min(lastOffset - firstOffset, values3.byteLength - firstOffset);
+    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length7, valueOffsets));
+    addBuffer.call(this, values3.subarray(firstOffset, firstOffset + byteLength));
     return this;
 }
 
 function assembleListVector(data) {
     const {
-        length: length4,
+        length: length7,
         valueOffsets
     } = data;
     if (valueOffsets) {
-        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length4, valueOffsets));
+        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length7, valueOffsets));
     }
     return this.visit(data.children[0]);
 }
 
 function assembleNestedVector(data) {
     return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
 }
@@ -46644,26 +81350,26 @@
 VectorAssembler.prototype.visitList = assembleListVector;
 VectorAssembler.prototype.visitStruct = assembleNestedVector;
 VectorAssembler.prototype.visitUnion = assembleUnion;
 VectorAssembler.prototype.visitInterval = assembleFlatVector;
 VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
 VectorAssembler.prototype.visitMap = assembleListVector;
 
-// node_modules/apache-arrow/ipc/writer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/writer.mjs
 var RecordBatchWriter = class extends ReadableInterop {
     constructor(options) {
         super();
         this._position = 0;
         this._started = false;
         this._sink = new AsyncByteQueue();
         this._schema = null;
         this._dictionaryBlocks = [];
         this._recordBatchBlocks = [];
         this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
-        isObject2(options) || (options = {
+        isObject3(options) || (options = {
             autoDestroy: true,
             writeLegacyIpcFormat: false
         });
         this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
         this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
     }
     /** @nocollapse */
@@ -46679,15 +81385,15 @@
         return this._sink.toString(sync);
     }
     toUint8Array(sync = false) {
         return this._sink.toUint8Array(sync);
     }
     writeAll(input) {
         if (isPromise(input)) {
-            return input.then((x4) => this.writeAll(x4));
+            return input.then((x7) => this.writeAll(x7));
         } else if (isAsyncIterable(input)) {
             return writeAllAsync(this, input);
         }
         return writeAll(this, input);
     }
     get closed() {
             return this._sink.closed;
@@ -46764,24 +81470,24 @@
         }
         if (payload instanceof RecordBatch) {
             if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
                 this._writeRecordBatch(payload);
             }
         } else if (payload instanceof Table) {
             this.writeAll(payload.batches);
-        } else if (isIterable2(payload)) {
+        } else if (isIterable3(payload)) {
             this.writeAll(payload);
         }
     }
     _writeMessage(message, alignment = 8) {
-        const a4 = alignment - 1;
+        const a7 = alignment - 1;
         const buffer = Message2.encode(message);
         const flatbufferSize = buffer.byteLength;
         const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
-        const alignedSize = flatbufferSize + prefixSize + a4 & ~a4;
+        const alignedSize = flatbufferSize + prefixSize + a7 & ~a7;
         const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
         if (message.headerType === MessageHeader.RecordBatch) {
             this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
         } else if (message.headerType === MessageHeader.DictionaryBatch) {
             this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
         }
         if (!this._writeLegacyIpcFormat) {
@@ -46823,24 +81529,24 @@
             bufferRegions,
             buffers
         } = VectorAssembler.assemble(batch);
         const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
         const message = Message2.from(recordBatch, byteLength);
         return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
     }
-    _writeDictionaryBatch(dictionary, id2, isDelta = false) {
-        this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));
+    _writeDictionaryBatch(dictionary, id3, isDelta = false) {
+        this._dictionaryDeltaOffsets.set(id3, dictionary.length + (this._dictionaryDeltaOffsets.get(id3) || 0));
         const {
             byteLength,
             nodes,
             bufferRegions,
             buffers
-        } = VectorAssembler.assemble(new Vector2([dictionary]));
+        } = VectorAssembler.assemble(new Vector3([dictionary]));
         const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
-        const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);
+        const dictionaryBatch = new DictionaryBatch2(recordBatch, id3, isDelta);
         const message = Message2.from(dictionaryBatch, byteLength);
         return this._writeMessage(message)._writeBodyBuffers(buffers);
     }
     _writeBodyBuffers(buffers) {
         let buffer;
         let size, padding;
         for (let i = -1, n = buffers.length; ++i < n;) {
@@ -46850,44 +81556,44 @@
                     this._writePadding(padding);
                 }
             }
         }
         return this;
     }
     _writeDictionaries(batch) {
-        for (let [id2, dictionary] of batch.dictionaries) {
-            let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;
-            if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {
+        for (let [id3, dictionary] of batch.dictionaries) {
+            let offset3 = this._dictionaryDeltaOffsets.get(id3) || 0;
+            if (offset3 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset3)).length > 0) {
                 for (const data of dictionary.data) {
-                    this._writeDictionaryBatch(data, id2, offset2 > 0);
-                    offset2 += data.length;
+                    this._writeDictionaryBatch(data, id3, offset3 > 0);
+                    offset3 += data.length;
                 }
             }
         }
         return this;
     }
 };
 var RecordBatchStreamWriter = class extends RecordBatchWriter {
     /** @nocollapse */
     static writeAll(input, options) {
         const writer = new RecordBatchStreamWriter(options);
         if (isPromise(input)) {
-            return input.then((x4) => writer.writeAll(x4));
+            return input.then((x7) => writer.writeAll(x7));
         } else if (isAsyncIterable(input)) {
             return writeAllAsync(writer, input);
         }
         return writeAll(writer, input);
     }
 };
 var RecordBatchFileWriter = class extends RecordBatchWriter {
     /** @nocollapse */
     static writeAll(input) {
         const writer = new RecordBatchFileWriter();
         if (isPromise(input)) {
-            return input.then((x4) => writer.writeAll(x4));
+            return input.then((x7) => writer.writeAll(x7));
         } else if (isAsyncIterable(input)) {
             return writeAllAsync(writer, input);
         }
         return writeAll(writer, input);
     }
     constructor() {
         super();
@@ -46937,20 +81643,20 @@
                     throw e_1.error;
             }
         }
         return writer.finish();
     });
 }
 
-// node_modules/apache-arrow/io/whatwg/iterable.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/whatwg/iterable.mjs
 function toDOMStream(source, options) {
     if (isAsyncIterable(source)) {
         return asyncIterableAsReadableDOMStream(source, options);
     }
-    if (isIterable2(source)) {
+    if (isIterable3(source)) {
         return iterableAsReadableDOMStream(source, options);
     }
     throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
 }
 
 function iterableAsReadableDOMStream(source, options) {
     let it = null;
@@ -47028,15 +81734,15 @@
                 }
             }
             controller.close();
         });
     }
 }
 
-// node_modules/apache-arrow/io/whatwg/builder.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/whatwg/builder.mjs
 function builderThroughDOMStream(options) {
     return new BuilderTransform(options);
 }
 var BuilderTransform = class {
     constructor(options) {
         this._numChunks = 0;
         this._finished = false;
@@ -47053,19 +81759,19 @@
         const {
             ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3
         } = Object.assign({}, writableStrategy);
         this["readable"] = new ReadableStream({
             ["cancel"]: () => {
                 this._builder.clear();
             },
-            ["pull"]: (c6) => {
-                this._maybeFlush(this._builder, this._controller = c6);
+            ["pull"]: (c11) => {
+                this._maybeFlush(this._builder, this._controller = c11);
             },
-            ["start"]: (c6) => {
-                this._maybeFlush(this._builder, this._controller = c6);
+            ["start"]: (c11) => {
+                this._maybeFlush(this._builder, this._controller = c11);
             }
         }, {
             "highWaterMark": readableHighWaterMark,
             "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
         });
         this["writable"] = new WritableStream({
             ["abort"]: () => {
@@ -47114,15 +81820,15 @@
     return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
 };
 var chunkByteLength = (chunk) => {
     var _a5;
     return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
 };
 
-// node_modules/apache-arrow/io/whatwg/reader.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/whatwg/reader.mjs
 function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
     const queue = new AsyncByteQueue();
     let reader = null;
     const readable = new ReadableStream({
         cancel() {
             return __awaiter(this, void 0, void 0, function*() {
                 yield queue.close();
@@ -47163,15 +81869,15 @@
                 }
             }
             controller.close();
         });
     }
 }
 
-// node_modules/apache-arrow/io/whatwg/writer.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/io/whatwg/writer.mjs
 function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
     const writer = new this(writableStrategy);
     const reader = new AsyncByteStream(writer);
     const readable = new ReadableStream({
         // type: 'bytes',
         cancel() {
             return __awaiter(this, void 0, void 0, function*() {
@@ -47207,34 +81913,34 @@
                 }
             }
             controller.close();
         });
     }
 }
 
-// node_modules/apache-arrow/ipc/serialization.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/ipc/serialization.mjs
 function tableFromIPC(input) {
     const reader = RecordBatchReader.from(input);
     if (isPromise(reader)) {
         return reader.then((reader2) => tableFromIPC(reader2));
     }
     if (reader.isAsync()) {
         return reader.readAll().then((xs) => new Table(xs));
     }
     return new Table(reader.readAll());
 }
 
-// node_modules/apache-arrow/Arrow.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/Arrow.mjs
 var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {
     compareSchemas,
     compareFields,
     compareTypes
 });
 
-// node_modules/apache-arrow/Arrow.dom.mjs
+// js/pyobsplot-js/node_modules/apache-arrow/Arrow.dom.mjs
 adapters_default.toDOMStream = toDOMStream;
 Builder["throughDOM"] = builderThroughDOMStream;
 RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
 RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
 RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
 RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
 RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
@@ -47300,18 +82006,18 @@
     return ret;
 }
 
 function get_fun(mod, method) {
     let fun;
     switch (mod) {
         case "Plot":
-            fun = src_exports2[method];
+            fun = src_exports4[method];
             break;
         case "d3":
-            fun = src_exports[method];
+            fun = src_exports3[method];
             break;
         case "Math":
             fun = Math[method];
             break;
         default:
             throw new Error(`Invalid module: ${mod}`);
     }
@@ -47328,15 +82034,20 @@
         spec["data"] = unserialize_data(spec["data"], renderer);
         out = parse_spec(spec["code"], spec["data"]);
         if (spec["code"]["pyobsplot-type"] == "function") {
             if (!(out instanceof Node)) {
                 out = out.plot();
             }
         } else {
-            out = plot(out);
+            if (spec["debug"]) {
+                console.log("--- start pyobsplot debugging output ---");
+                console.log(out);
+                console.log("--- end pyobsplot debugging output ---");
+            }
+            out = plot2(out);
         }
     } catch (error) {
         out = document.createElement("pre");
         out.style.color = "#CC0000";
         out.style.padding = "1em 1.5em";
         out.textContent = "\u26A0 " + error;
     }
@@ -47347,22 +82058,22 @@
 window.d3 = src_exports;
 window.Plot = src_exports2;
 
 function render(view) {
     let spec = () => view.model.get("spec");
     let plot_div = document.createElement("div");
     plot_div.classList.add("pyobsplot-plot");
-    let plot2 = generate_plot(spec(), "widget");
-    plot_div.appendChild(plot2);
+    let plot3 = generate_plot(spec(), "widget");
+    plot_div.appendChild(plot3);
     view.el.appendChild(plot_div);
     view.model.on("change:spec", () => _onValueChanged(view, view.el));
 }
 
 function _onValueChanged(view, el) {
-    let plot2 = el.querySelector(".pyobsplot-plot");
-    plot2.replaceChildren();
+    let plot3 = el.querySelector(".pyobsplot-plot");
+    plot3.replaceChildren();
     let spec = () => view.model.get("spec");
-    plot2.appendChild(generate_plot(spec()));
+    plot3.appendChild(generate_plot(spec()));
 }
 export {
     render
 };
```

### Comparing `pyobsplot-0.3.0/src/pyobsplot/widget.py` & `pyobsplot-0.3.1/src/pyobsplot/widget.py`

 * *Files 6% similar despite different names*

```diff
@@ -22,20 +22,20 @@
     """
 
     _esm = bundler_output_dir / "widget.js"
     _css = bundler_output_dir / "styles.css"
     # spec traitlet : plot specification
     spec = traitlets.Dict().tag(sync=True)
 
-    def __init__(self, spec):
+    def __init__(self, spec, debug: bool = False):
         """Obsplot widget constructor."""
-
+        self._debug = debug
         # Init widget
         super().__init__(spec=spec)
 
     @traitlets.validate("spec")
     def _validate_spec(self, proposal):
         spec = proposal["value"]
         parser = SpecParser("widget")
         code = parser.parse(spec)
-        spec = {"data": parser.serialize_data(), "code": code}
+        spec = {"data": parser.serialize_data(), "code": code, "debug": self._debug}
         return spec
```

### Comparing `pyobsplot-0.3.0/PKG-INFO` & `pyobsplot-0.3.1/PKG-INFO`

 * *Files 9% similar despite different names*

```diff
@@ -1,50 +1,57 @@
 Metadata-Version: 2.1
 Name: pyobsplot
-Version: 0.3.0
-Summary: Observable Plot in Jupyter notebooks
+Version: 0.3.1
+Summary: Observable Plot in Jupyter notebooks and Quarto documents
+Home-page: https://github.com/juba/pyobsplot
 License: MIT
 Author: Julien Barnier
 Author-email: julien@nozav.org
 Requires-Python: >=3.8,<4.0
+Classifier: Development Status :: 3 - Alpha
+Classifier: Framework :: Jupyter :: JupyterLab
 Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: JavaScript
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3
+Classifier: Topic :: Scientific/Engineering :: Visualization
 Requires-Dist: anywidget[dev] (>=0.2.0,<0.3.0)
 Requires-Dist: ipywidgets (>=8.0.0)
 Requires-Dist: jupyterlab (>=3.6.0)
 Requires-Dist: pandas (>=1.2.0)
 Requires-Dist: polars (>=0.16.0)
 Requires-Dist: pyarrow (>=11.0.0,<12.0.0)
+Project-URL: Documentation, https://juba.github.io/pyobsplot
+Project-URL: Repository, https://github.com/juba/pyobsplot
+Project-URL: changelog, https://github.com/juba/pyobsplot/blob/main/NEWS.md
 Description-Content-Type: text/markdown
 
 # pyobsplot
 
 [![PyPI](https://img.shields.io/pypi/v/pyobsplot.svg?color=green)](https://pypi.org/project/pyobsplot)
 [![Tests](https://github.com/juba/pyobsplot/actions/workflows/tests.yml/badge.svg)](https://github.com/juba/pyobsplot/actions/workflows/tests.yml)
 [![Documentation](https://github.com/juba/pyobsplot/actions/workflows/publish.yml/badge.svg)](https://github.com/juba/pyobsplot/actions/workflows/publish.yml)
 [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/juba/pyobsplot/blob/main/examples/introduction.ipynb)
 
 
-`pyobsplot` allows to use [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot) to create charts in Jupyter notebooks. Plots are produced as [widgets](https://ipywidgets.readthedocs.io/en/latest/index.html) from Python code with a syntax as close as possible to the JavaScript one.
+`pyobsplot` allows to use [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot) to create charts in Jupyter notebooks, VSCode notebooks, Google Colab and Quarto documents. Plots are created from Python code with a syntax as close as possible to the JavaScript one.
 
 It allows to do things like :
 
 ```python
 import polars as pl
-from pyobsplot import Obsplot, Plot
-
-penguins = pl.read_csv("data/penguins.csv")
+from pyobsplot import Plot
 
-op = Obsplot()
+penguins = pl.read_csv("https://github.com/juba/pyobsplot/raw/main/doc/data/penguins.csv")
 
-op({
+Plot.plot({
     "grid": True,
     "color": {"legend": True},
     "marks": [
         Plot.dot(
             penguins, 
             {"x": "flipper_length_mm", "y": "body_mass_g", "fill": "species"}
         ),
@@ -57,15 +64,15 @@
 ```
 
 ![Sample plot screenshot](https://github.com/juba/pyobsplot/raw/main/doc/screenshots/readme_plot.png)
 
 
 ## Installation and usage
 
-> **Warning**: this project is at a very early stage. There will be bugs, and please take a look at the limitations listed below.
+> **Warning**: this project is at an early stage. There will be bugs, and the API may change.
 
 `pyobsplot` can be installed with `pip`:
 
 ```sh
 pip install pyobsplot
 ```
 
@@ -86,16 +93,16 @@
 - Caching mechanism of data objects if they are used several times in the same plot
 - Custom JavaScript code can be passed as strings with the `js` method
 - Python `date` and `datetime` objects are automatically converted to JavaScript `Date` objects
 - Works with Jupyter notebooks and Quarto HTML documents. Plots without legends are also supported in PDF and docx outputs with the `jsdom` renderer.
 
 **Limitations:**
 
-- Plots with legends don't work in Quarto in formats other than HTML.
-- Some faceting operations produce warnings when used as top-level faceting (but the plots should be fine). This doesn't happen when using mark-level faceting (with the `fx` and `fy` channels).
+- Plots with legends don't work in Quarto in formats other than HTML. (#9)
+- Some faceting operations produce warnings when used as top-level faceting (but the plots should be fine). This doesn't happen when using mark-level faceting (with the `fx` and `fy` channels). (#3)
 
 
 
 ## Credits
 
 - [Observable Plot](https://observablehq.com/@observablehq/plot?collection=@observablehq/plot), developed by [Mike Bostock](https://observablehq.com/@mbostock) and [Philippe Rivi√®re](https://observablehq.com/@fil) among others.
 - The widget is developed thanks to the [anywidget](https://anywidget.dev) framework.
```

