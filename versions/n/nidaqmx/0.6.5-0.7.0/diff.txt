--- tmp/nidaqmx-0.6.5.tar.gz
+++ tmp/nidaqmx-0.7.0.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "nidaqmx-0.6.5.tar", max compression
│ +gzip compressed data, was "nidaqmx-0.7.0.tar", max compression
│   --- nidaqmx-0.6.5.tar
├── +++ nidaqmx-0.7.0.tar
│ ├── file list
│ │ @@ -1,64 +1,63 @@
│ │ --rw-r--r--   0        0        0     1213 2022-05-26 20:15:36.274851 nidaqmx-0.6.5/LICENSE
│ │ --rw-r--r--   0        0        0      467 2022-05-26 20:15:36.279922 nidaqmx-0.6.5/nidaqmx/__init__.py
│ │ --rw-r--r--   0        0        0     7700 2022-05-26 20:15:36.279922 nidaqmx-0.6.5/nidaqmx/_lib.py
│ │ --rw-r--r--   0        0        0        0 2021-12-14 20:31:44.811200 nidaqmx-0.6.5/nidaqmx/_task_modules/__init__.py
│ │ --rw-r--r--   0        0        0   208358 2022-07-19 18:29:05.513234 nidaqmx-0.6.5/nidaqmx/_task_modules/ai_channel_collection.py
│ │ --rw-r--r--   0        0        0     8837 2022-05-26 20:24:36.106623 nidaqmx-0.6.5/nidaqmx/_task_modules/ao_channel_collection.py
│ │ --rw-r--r--   0        0        0     5025 2022-05-26 20:15:36.279922 nidaqmx-0.6.5/nidaqmx/_task_modules/channel_collection.py
│ │ --rw-r--r--   0        0        0      512 2022-05-26 20:15:36.284928 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/__init__.py
│ │ --rw-r--r--   0        0        0   339259 2022-07-19 18:29:05.528905 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ai_channel.py
│ │ --rw-r--r--   0        0        0    81019 2022-05-26 20:25:21.836054 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ao_channel.py
│ │ --rw-r--r--   0        0        0    16214 2022-05-26 20:25:32.071714 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/channel.py
│ │ --rw-r--r--   0        0        0   469254 2022-05-26 20:25:37.789446 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ci_channel.py
│ │ --rw-r--r--   0        0        0    64333 2022-05-26 20:25:41.094399 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/co_channel.py
│ │ --rw-r--r--   0        0        0    29343 2022-05-26 20:25:44.481623 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/di_channel.py
│ │ --rw-r--r--   0        0        0    32356 2022-05-26 20:25:48.096742 nidaqmx-0.6.5/nidaqmx/_task_modules/channels/do_channel.py
│ │ --rw-r--r--   0        0        0    53215 2022-05-26 20:26:47.722591 nidaqmx-0.6.5/nidaqmx/_task_modules/ci_channel_collection.py
│ │ --rw-r--r--   0        0        0     9901 2022-05-26 20:25:59.425239 nidaqmx-0.6.5/nidaqmx/_task_modules/co_channel_collection.py
│ │ --rw-r--r--   0        0        0     4417 2022-05-26 20:26:03.041036 nidaqmx-0.6.5/nidaqmx/_task_modules/di_channel_collection.py
│ │ --rw-r--r--   0        0        0     4415 2022-05-26 20:26:06.547607 nidaqmx-0.6.5/nidaqmx/_task_modules/do_channel_collection.py
│ │ --rw-r--r--   0        0        0    95920 2022-05-26 20:26:11.386596 nidaqmx-0.6.5/nidaqmx/_task_modules/export_signals.py
│ │ --rw-r--r--   0        0        0    91117 2022-08-15 15:15:04.753082 nidaqmx-0.6.5/nidaqmx/_task_modules/in_stream.py
│ │ --rw-r--r--   0        0        0    40861 2022-05-26 20:26:18.609279 nidaqmx-0.6.5/nidaqmx/_task_modules/out_stream.py
│ │ --rw-r--r--   0        0        0    24950 2022-07-19 18:29:05.528905 nidaqmx-0.6.5/nidaqmx/_task_modules/read_functions.py
│ │ --rw-r--r--   0        0        0   116447 2022-05-26 20:26:29.652937 nidaqmx-0.6.5/nidaqmx/_task_modules/timing.py
│ │ --rw-r--r--   0        0        0        0 2021-12-14 20:31:44.818188 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/__init__.py
│ │ --rw-r--r--   0        0        0    21212 2022-05-26 20:27:02.733409 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/arm_start_trigger.py
│ │ --rw-r--r--   0        0        0     5777 2022-05-26 20:27:10.219427 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/handshake_trigger.py
│ │ --rw-r--r--   0        0        0    58743 2022-05-26 20:27:14.119510 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/pause_trigger.py
│ │ --rw-r--r--   0        0        0    97689 2022-05-26 20:27:18.815873 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/reference_trigger.py
│ │ --rw-r--r--   0        0        0    94947 2022-05-26 20:27:25.996086 nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/start_trigger.py
│ │ --rw-r--r--   0        0        0     4460 2022-05-26 20:26:38.629517 nidaqmx-0.6.5/nidaqmx/_task_modules/triggers.py
│ │ --rw-r--r--   0        0        0    15876 2022-05-26 20:15:36.309546 nidaqmx-0.6.5/nidaqmx/_task_modules/write_functions.py
│ │ --rw-r--r--   0        0        0    53042 2022-07-22 21:53:27.158112 nidaqmx-0.6.5/nidaqmx/constants.py
│ │ --rw-r--r--   0        0        0    93524 2022-05-26 20:27:42.156905 nidaqmx-0.6.5/nidaqmx/error_codes.py
│ │ --rw-r--r--   0        0        0     6723 2022-07-19 18:29:05.528905 nidaqmx-0.6.5/nidaqmx/errors.py
│ │ --rw-r--r--   0        0        0    36355 2022-05-26 20:27:50.940216 nidaqmx-0.6.5/nidaqmx/scale.py
│ │ --rw-r--r--   0        0        0   116835 2022-07-19 18:29:05.528905 nidaqmx-0.6.5/nidaqmx/stream_readers.py
│ │ --rw-r--r--   0        0        0    67229 2022-05-26 20:15:36.314552 nidaqmx-0.6.5/nidaqmx/stream_writers.py
│ │ --rw-r--r--   0        0        0      426 2022-05-26 20:15:36.314552 nidaqmx-0.6.5/nidaqmx/system/__init__.py
│ │ --rw-r--r--   0        0        0        0 2021-12-14 20:31:44.595797 nidaqmx-0.6.5/nidaqmx/system/_collections/__init__.py
│ │ --rw-r--r--   0        0        0     4073 2022-05-26 20:15:36.314552 nidaqmx-0.6.5/nidaqmx/system/_collections/device_collection.py
│ │ --rw-r--r--   0        0        0     4325 2022-05-26 20:15:36.314552 nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_channel_collection.py
│ │ --rw-r--r--   0        0        0     4191 2022-05-26 20:15:36.319583 nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_scale_collection.py
│ │ --rw-r--r--   0        0        0     4127 2022-05-26 20:15:36.319583 nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_task_collection.py
│ │ --rw-r--r--   0        0        0    13653 2022-05-26 20:15:36.319583 nidaqmx-0.6.5/nidaqmx/system/_collections/physical_channel_collection.py
│ │ --rw-r--r--   0        0        0        0 2021-12-14 20:31:44.640675 nidaqmx-0.6.5/nidaqmx/system/_watchdog_modules/__init__.py
│ │ --rw-r--r--   0        0        0     8392 2022-05-26 20:28:03.846842 nidaqmx-0.6.5/nidaqmx/system/_watchdog_modules/expiration_state.py
│ │ --rw-r--r--   0        0        0     1412 2022-05-26 20:15:36.319583 nidaqmx-0.6.5/nidaqmx/system/_watchdog_modules/expiration_states_collection.py
│ │ --rw-r--r--   0        0        0    90940 2022-05-26 20:27:59.941082 nidaqmx-0.6.5/nidaqmx/system/device.py
│ │ --rw-r--r--   0        0        0    43426 2022-05-26 20:28:07.424214 nidaqmx-0.6.5/nidaqmx/system/physical_channel.py
│ │ --rw-r--r--   0        0        0      275 2022-05-26 20:15:36.324589 nidaqmx-0.6.5/nidaqmx/system/storage/__init__.py
│ │ --rw-r--r--   0        0        0     1052 2022-05-26 20:15:36.329612 nidaqmx-0.6.5/nidaqmx/system/storage/_alternate_task_constructor.py
│ │ --rw-r--r--   0        0        0     3930 2022-05-26 20:15:36.329612 nidaqmx-0.6.5/nidaqmx/system/storage/persisted_channel.py
│ │ --rw-r--r--   0        0        0     4153 2022-05-26 20:15:36.329612 nidaqmx-0.6.5/nidaqmx/system/storage/persisted_scale.py
│ │ --rw-r--r--   0        0        0     4787 2022-05-26 20:15:36.329612 nidaqmx-0.6.5/nidaqmx/system/storage/persisted_task.py
│ │ --rw-r--r--   0        0        0    35077 2022-05-26 20:28:11.251426 nidaqmx-0.6.5/nidaqmx/system/system.py
│ │ --rw-r--r--   0        0        0    25613 2022-05-26 20:28:17.074341 nidaqmx-0.6.5/nidaqmx/system/watchdog.py
│ │ --rw-r--r--   0        0        0    57355 2022-11-28 16:31:42.226498 nidaqmx-0.6.5/nidaqmx/task.py
│ │ --rw-r--r--   0        0        0     1430 2022-05-26 20:17:06.420330 nidaqmx-0.6.5/nidaqmx/types.py
│ │ --rw-r--r--   0        0        0     6774 2022-05-26 20:15:36.339638 nidaqmx-0.6.5/nidaqmx/utils.py
│ │ --rw-r--r--   0        0        0     2026 2022-11-14 15:07:56.821396 nidaqmx-0.6.5/pyproject.toml
│ │ --rw-r--r--   0        0        0     6756 2022-11-22 21:17:25.599854 nidaqmx-0.6.5/README.rst
│ │ --rw-r--r--   0        0        0     7959 2022-11-28 16:36:45.025303 nidaqmx-0.6.5/setup.py
│ │ --rw-r--r--   0        0        0     8249 2022-11-28 16:36:45.026301 nidaqmx-0.6.5/PKG-INFO
│ │ +-rw-r--r--   0        0        0      467 2023-04-03 18:57:20.408212 nidaqmx-0.7.0/generated/nidaqmx/__init__.py
│ │ +-rw-r--r--   0        0        0     7398 2023-04-05 15:42:42.315923 nidaqmx-0.7.0/generated/nidaqmx/_lib.py
│ │ +-rw-r--r--   0        0        0        0 2023-04-03 18:57:20.409211 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/__init__.py
│ │ +-rw-r--r--   0        0        0   208331 2023-04-05 15:42:42.317919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ai_channel_collection.py
│ │ +-rw-r--r--   0        0        0     8810 2023-04-05 15:42:42.318918 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ao_channel_collection.py
│ │ +-rw-r--r--   0        0        0     4971 2023-04-05 15:42:42.319918 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channel_collection.py
│ │ +-rw-r--r--   0        0        0      512 2023-04-03 18:57:20.410211 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/__init__.py
│ │ +-rw-r--r--   0        0        0   342852 2023-04-05 20:08:29.824486 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ai_channel.py
│ │ +-rw-r--r--   0        0        0    81010 2023-04-05 15:42:42.324919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ao_channel.py
│ │ +-rw-r--r--   0        0        0    16195 2023-04-05 15:42:42.325920 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/channel.py
│ │ +-rw-r--r--   0        0        0   469245 2023-04-05 20:08:29.827485 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ci_channel.py
│ │ +-rw-r--r--   0        0        0    64324 2023-04-05 15:42:42.329920 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/co_channel.py
│ │ +-rw-r--r--   0        0        0    29334 2023-04-05 15:42:42.330919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/di_channel.py
│ │ +-rw-r--r--   0        0        0    32347 2023-04-05 15:42:42.331920 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/do_channel.py
│ │ +-rw-r--r--   0        0        0    53188 2023-04-05 15:42:42.332919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ci_channel_collection.py
│ │ +-rw-r--r--   0        0        0     9874 2023-04-05 15:42:42.333918 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/co_channel_collection.py
│ │ +-rw-r--r--   0        0        0     4390 2023-04-05 15:42:42.334918 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/di_channel_collection.py
│ │ +-rw-r--r--   0        0        0     4388 2023-04-05 15:42:42.335920 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/do_channel_collection.py
│ │ +-rw-r--r--   0        0        0    95912 2023-04-05 15:42:42.336919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/export_signals.py
│ │ +-rw-r--r--   0        0        0    91612 2023-04-05 15:42:42.337919 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/in_stream.py
│ │ +-rw-r--r--   0        0        0    40829 2023-04-05 15:42:42.338920 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/out_stream.py
│ │ +-rw-r--r--   0        0        0    24950 2023-04-03 18:57:20.411212 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/read_functions.py
│ │ +-rw-r--r--   0        0        0   116423 2023-04-05 15:42:42.340977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/timing.py
│ │ +-rw-r--r--   0        0        0        0 2023-04-03 18:57:20.411212 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/__init__.py
│ │ +-rw-r--r--   0        0        0    21204 2023-04-05 15:42:42.341977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/arm_start_trigger.py
│ │ +-rw-r--r--   0        0        0     5769 2023-04-05 15:42:42.342983 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/handshake_trigger.py
│ │ +-rw-r--r--   0        0        0    58735 2023-04-05 15:42:42.343977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/pause_trigger.py
│ │ +-rw-r--r--   0        0        0    97681 2023-04-05 15:42:42.344977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/reference_trigger.py
│ │ +-rw-r--r--   0        0        0    94939 2023-04-05 15:42:42.345977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/start_trigger.py
│ │ +-rw-r--r--   0        0        0     4452 2023-04-05 15:42:42.346977 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggers.py
│ │ +-rw-r--r--   0        0        0    15876 2023-04-03 18:57:20.412212 nidaqmx-0.7.0/generated/nidaqmx/_task_modules/write_functions.py
│ │ +-rw-r--r--   0        0        0    50249 2023-04-03 19:47:30.482012 nidaqmx-0.7.0/generated/nidaqmx/constants.py
│ │ +-rw-r--r--   0        0        0    93605 2023-04-03 19:47:30.466051 nidaqmx-0.7.0/generated/nidaqmx/error_codes.py
│ │ +-rw-r--r--   0        0        0     6261 2023-04-05 15:42:42.347979 nidaqmx-0.7.0/generated/nidaqmx/errors.py
│ │ +-rw-r--r--   0        0        0    36338 2023-04-05 15:42:42.348982 nidaqmx-0.7.0/generated/nidaqmx/scale.py
│ │ +-rw-r--r--   0        0        0   116823 2023-04-05 15:42:42.350979 nidaqmx-0.7.0/generated/nidaqmx/stream_readers.py
│ │ +-rw-r--r--   0        0        0    67211 2023-04-05 15:42:42.350979 nidaqmx-0.7.0/generated/nidaqmx/stream_writers.py
│ │ +-rw-r--r--   0        0        0      426 2023-04-03 18:57:20.415213 nidaqmx-0.7.0/generated/nidaqmx/system/__init__.py
│ │ +-rw-r--r--   0        0        0        0 2023-04-03 18:57:20.415213 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/__init__.py
│ │ +-rw-r--r--   0        0        0     4020 2023-04-05 15:42:42.352980 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/device_collection.py
│ │ +-rw-r--r--   0        0        0     4272 2023-04-05 15:42:42.353980 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_channel_collection.py
│ │ +-rw-r--r--   0        0        0     4138 2023-04-05 15:42:42.354980 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_scale_collection.py
│ │ +-rw-r--r--   0        0        0     4074 2023-04-05 15:42:42.354980 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_task_collection.py
│ │ +-rw-r--r--   0        0        0    13588 2023-04-05 15:42:42.355977 nidaqmx-0.7.0/generated/nidaqmx/system/_collections/physical_channel_collection.py
│ │ +-rw-r--r--   0        0        0        0 2023-04-03 18:57:20.419223 nidaqmx-0.7.0/generated/nidaqmx/system/_watchdog_modules/__init__.py
│ │ +-rw-r--r--   0        0        0    10418 2023-04-05 15:42:42.355977 nidaqmx-0.7.0/generated/nidaqmx/system/_watchdog_modules/expiration_state.py
│ │ +-rw-r--r--   0        0        0     1376 2023-04-05 15:42:42.356977 nidaqmx-0.7.0/generated/nidaqmx/system/_watchdog_modules/expiration_states_collection.py
│ │ +-rw-r--r--   0        0        0    91456 2023-04-05 20:08:29.829494 nidaqmx-0.7.0/generated/nidaqmx/system/device.py
│ │ +-rw-r--r--   0        0        0    43419 2023-04-05 20:08:29.830489 nidaqmx-0.7.0/generated/nidaqmx/system/physical_channel.py
│ │ +-rw-r--r--   0        0        0      275 2023-04-03 18:57:20.420224 nidaqmx-0.7.0/generated/nidaqmx/system/storage/__init__.py
│ │ +-rw-r--r--   0        0        0     1052 2023-04-03 18:57:20.421213 nidaqmx-0.7.0/generated/nidaqmx/system/storage/_alternate_task_constructor.py
│ │ +-rw-r--r--   0        0        0     3913 2023-04-05 15:42:42.359977 nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_channel.py
│ │ +-rw-r--r--   0        0        0     4136 2023-04-05 15:42:42.360978 nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_scale.py
│ │ +-rw-r--r--   0        0        0     4770 2023-04-05 15:42:42.361977 nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_task.py
│ │ +-rw-r--r--   0        0        0    35069 2023-04-05 15:42:42.361977 nidaqmx-0.7.0/generated/nidaqmx/system/system.py
│ │ +-rw-r--r--   0        0        0    25625 2023-04-05 20:08:29.831494 nidaqmx-0.7.0/generated/nidaqmx/system/watchdog.py
│ │ +-rw-r--r--   0        0        0    57288 2023-04-05 15:42:42.364981 nidaqmx-0.7.0/generated/nidaqmx/task.py
│ │ +-rw-r--r--   0        0        0     1430 2023-04-03 18:57:20.423214 nidaqmx-0.7.0/generated/nidaqmx/types.py
│ │ +-rw-r--r--   0        0        0     8896 2023-04-05 15:42:42.365980 nidaqmx-0.7.0/generated/nidaqmx/utils.py
│ │ +-rw-r--r--   0        0        0     1213 2022-05-26 20:15:36.274851 nidaqmx-0.7.0/LICENSE
│ │ +-rw-r--r--   0        0        0     2480 2023-04-06 16:16:13.859658 nidaqmx-0.7.0/pyproject.toml
│ │ +-rw-r--r--   0        0        0     7076 2023-04-05 15:42:42.306919 nidaqmx-0.7.0/README.rst
│ │ +-rw-r--r--   0        0        0     8916 1970-01-01 00:00:00.000000 nidaqmx-0.7.0/PKG-INFO
│ │   --- nidaqmx-0.6.5/LICENSE
│ ├── +++ nidaqmx-0.7.0/LICENSE
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/nidaqmx/_lib.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_lib.py
│ │┄ Files 2% similar despite different names
│ │ @@ -1,12 +1,11 @@
│ │  from ctypes.util import find_library
│ │  import ctypes
│ │  from numpy.ctypeslib import ndpointer
│ │  import platform
│ │ -import six
│ │  import sys
│ │  import threading
│ │  
│ │  from nidaqmx.errors import Error
│ │  
│ │  
│ │  class DaqNotFoundError(Error):
│ │ @@ -33,21 +32,21 @@
│ │          ctypes.c_uint.value.__set__(self, int(val))
│ │  
│ │      value = property(_getter, _setter)
│ │  
│ │      del _getter, _setter
│ │  
│ │  
│ │ -class CtypesByteString(object):
│ │ +class CtypesByteString:
│ │      """
│ │      Custom argtype that automatically converts unicode strings to ASCII
│ │      strings in Python 3.
│ │      """
│ │      def from_param(self, param):
│ │ -        if isinstance(param, six.text_type):
│ │ +        if isinstance(param, str):
│ │              param = param.encode('ascii')
│ │          return ctypes.c_char_p(param)
│ │  
│ │  
│ │  ctypes_byte_str = CtypesByteString()
│ │  
│ │  
│ │ @@ -113,15 +112,15 @@
│ │          bitfield_mask = next(
│ │              b for b in bitfield_enum_type if b.name == enum_value.name)
│ │          bitfield_value |= bitfield_mask.value
│ │  
│ │      return bitfield_value
│ │  
│ │  
│ │ -class DaqFunctionImporter(object):
│ │ +class DaqFunctionImporter:
│ │      """
│ │      Wraps the function getter function of a ctypes library.
│ │  
│ │      Allows the NI-DAQmx Python API to fail elegantly if a function is not
│ │      supported in the current version of the API.
│ │      """
│ │  
│ │ @@ -135,20 +134,20 @@
│ │              if not hasattr(cfunc, 'arglock'):
│ │                  with self._lib_lock:
│ │                      if not hasattr(cfunc, 'arglock'):
│ │                          cfunc.arglock = threading.Lock()
│ │              return cfunc
│ │          except AttributeError:
│ │              raise DaqFunctionNotSupportedError(
│ │ -                'The NI-DAQmx function "{0}" is not supported in this '
│ │ +                'The NI-DAQmx function "{}" is not supported in this '
│ │                  'version of NI-DAQmx. Visit ni.com/downloads to upgrade your '
│ │                  'version of NI-DAQmx.'.format(function))
│ │  
│ │  
│ │ -class DaqLibImporter(object):
│ │ +class DaqLibImporter:
│ │      """
│ │      Encapsulates NI-DAQmx library importing and handle type parsing logic.
│ │      """
│ │  
│ │      def __init__(self):
│ │          self._windll = None
│ │          self._cdll = None
│ │ @@ -186,41 +185,34 @@
│ │          self._windll = None
│ │          self._cdll = None
│ │  
│ │          windll = None
│ │          cdll = None
│ │  
│ │          if sys.platform.startswith('win') or sys.platform.startswith('cli'):
│ │ -            lib_name = "nicaiu"
│ │ -
│ │ -            # Converting to ASCII to workaround issue in Python 2.7.13:
│ │ -            # https://bugs.python.org/issue29082
│ │ -            if sys.version_info < (3,):
│ │ -                lib_name = lib_name.encode('ascii')
│ │ -
│ │              if 'iron' in platform.python_implementation().lower():
│ │                  windll = ctypes.windll.nicaiu
│ │                  cdll = ctypes.cdll.nicaiu
│ │              else:
│ │ -                windll = ctypes.windll.LoadLibrary(lib_name)
│ │ -                cdll = ctypes.cdll.LoadLibrary(lib_name)
│ │ +                windll = ctypes.windll.LoadLibrary('nicaiu')
│ │ +                cdll = ctypes.cdll.LoadLibrary('nicaiu')
│ │  
│ │          elif sys.platform.startswith('linux'):
│ │              # On linux you can use the command find_library('nidaqmx')
│ │              if find_library('nidaqmx') is not None:
│ │                  cdll = ctypes.cdll.LoadLibrary(find_library('nidaqmx'))
│ │                  windll = cdll
│ │              else:
│ │                  raise DaqNotFoundError(
│ │                      'Could not find an installation of NI-DAQmx. Please '
│ │                      'ensure that NI-DAQmx is installed on this machine or '
│ │                      'contact National Instruments for support.')
│ │          else:
│ │              raise DaqNotFoundError(
│ │ -                'NI-DAQmx Python is not supported on this platform: {0}. '
│ │ +                'NI-DAQmx Python is not supported on this platform: {}. '
│ │                  'Please direct any questions or feedback to National '
│ │                  'Instruments.'.format(sys.platform))
│ │  
│ │          self._windll = DaqFunctionImporter(windll)
│ │          self._cdll = DaqFunctionImporter(cdll)
│ │  
│ │      @staticmethod
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/ai_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ai_channel_collection.py
│ │┄ Files 0% similar despite different names
│ │ @@ -25,15 +25,15 @@
│ │  
│ │  
│ │  class AIChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of analog input channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(AIChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, physical_channel, name_to_assign_to_channel=''):
│ │          """
│ │          Creates and returns an AIChannel object.
│ │  
│ │          Args:
│ │              physical_channel (str): Specifies the names of the physical
│ │ @@ -45,15 +45,15 @@
│ │              
│ │              Specifies the newly created AIChannel object.
│ │          """
│ │          if name_to_assign_to_channel:
│ │              num_channels = len(unflatten_channel_string(physical_channel))
│ │  
│ │              if num_channels > 1:
│ │ -                name = '{0}0:{1}'.format(
│ │ +                name = '{}0:{}'.format(
│ │                      name_to_assign_to_channel, num_channels-1)
│ │              else:
│ │                  name = name_to_assign_to_channel
│ │          else:
│ │              name = physical_channel
│ │  
│ │          return AIChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/ao_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ao_channel_collection.py
│ │┄ Files 1% similar despite different names
│ │ @@ -12,15 +12,15 @@
│ │  
│ │  
│ │  class AOChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of analog output channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(AOChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, physical_channel, name_to_assign_to_channel=''):
│ │          """
│ │          Creates and returns an AOChannel object.
│ │  
│ │          Args:
│ │              physical_channel (str): Specifies the names of the physical
│ │ @@ -32,15 +32,15 @@
│ │              
│ │              Specifies the newly created AOChannel object.
│ │          """
│ │          if name_to_assign_to_channel:
│ │              num_channels = len(unflatten_channel_string(physical_channel))
│ │  
│ │              if num_channels > 1:
│ │ -                name = '{0}0:{1}'.format(
│ │ +                name = '{}0:{}'.format(
│ │                      name_to_assign_to_channel, num_channels-1)
│ │              else:
│ │                  name = name_to_assign_to_channel
│ │          else:
│ │              name = physical_channel
│ │  
│ │          return AOChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channel_collection.py
│ │┄ Files 4% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx._task_modules.channels.channel import Channel
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small,
│ │      DaqError)
│ │ @@ -19,15 +18,15 @@
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      def __contains__(self, item):
│ │          channel_names = self.channel_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │          elif isinstance(item, Channel):
│ │              items = item.channel_names
│ │  
│ │          return all([item in channel_names for item in items])
│ │  
│ │      def __eq__(self, other):
│ │ @@ -52,31 +51,31 @@
│ │                      the collection.
│ │          Returns:
│ │              nidaqmx._task_modules.channels.channel.Channel: 
│ │              
│ │              Indicates a channel object representing the subset of virtual
│ │              channels indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              channel_names = self.channel_names[index]
│ │          elif isinstance(index, slice):
│ │              channel_names = flatten_channel_string(self.channel_names[index])
│ │ -        elif isinstance(index, six.string_types):
│ │ +        elif isinstance(index, str):
│ │              channel_names = index
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access channels.'
│ │ +                'Invalid index type "{}" used to access channels.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │          if channel_names:
│ │              return Channel._factory(self._handle, channel_names)
│ │          else:
│ │              raise DaqError(
│ │                  'You cannot specify an empty index when indexing channels.\n'
│ │ -                'Index used: {0}'.format(index), DAQmxErrors.UNKNOWN)
│ │ +                'Index used: {}'.format(index), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __hash__(self):
│ │          return hash(self._handle.value)
│ │  
│ │      def __iter__(self):
│ │          for channel_name in self.channel_names:
│ │              yield Channel._factory(self._handle, channel_name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/__init__.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/__init__.py
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ai_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ai_channel.py
│ │┄ Files 2% similar despite different names
│ │ @@ -1,11 +1,12 @@
│ │  # Do not edit this file; it was automatically generated.
│ │  
│ │  import ctypes
│ │  import numpy
│ │ +import deprecation
│ │  
│ │  from nidaqmx._lib import (
│ │      lib_importer, wrapped_ndpointer, ctypes_byte_str, c_bool32)
│ │  from nidaqmx.scale import Scale
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx._task_modules.channels.channel import Channel
│ │ @@ -35,15 +36,15 @@
│ │  class AIChannel(Channel):
│ │      """
│ │      Represents one or more analog input virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'AIChannel(name={0})'.format(self._name)
│ │ +        return f'AIChannel(name={self._name})'
│ │  
│ │      @property
│ │      def ai_ac_excit_freq(self):
│ │          """
│ │          float: Specifies the AC excitation frequency in Hertz.
│ │          """
│ │          val = ctypes.c_double()
│ │ @@ -395,14 +396,64 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ +    def ai_accel_db_ref(self):
│ │ +        """
│ │ +        float: Specifies the decibel reference level in the units of the
│ │ +            channel. When you read samples as a waveform, the decibel
│ │ +            reference level is included in the waveform attributes.
│ │ +        """
│ │ +        val = ctypes.c_double()
│ │ +
│ │ +        cfunc = lib_importer.windll.DAQmxGetAIAcceldBRef
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle, ctypes_byte_str,
│ │ +                        ctypes.POINTER(ctypes.c_double)]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle, self._name, ctypes.byref(val))
│ │ +        check_for_error(error_code)
│ │ +
│ │ +        return val.value
│ │ +
│ │ +    @ai_accel_db_ref.setter
│ │ +    def ai_accel_db_ref(self, val):
│ │ +        cfunc = lib_importer.windll.DAQmxSetAIAcceldBRef
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle, ctypes_byte_str,
│ │ +                        ctypes.c_double]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle, self._name, val)
│ │ +        check_for_error(error_code)
│ │ +
│ │ +    @ai_accel_db_ref.deleter
│ │ +    def ai_accel_db_ref(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAIAcceldBRef
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle, ctypes_byte_str]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle, self._name)
│ │ +        check_for_error(error_code)
│ │ +
│ │ +    @property
│ │      def ai_accel_sensitivity(self):
│ │          """
│ │          float: Specifies the sensitivity of the accelerometer. This
│ │              value is in the units you specify with
│ │              **ai_accel_sensitivity_units**. Refer to the sensor
│ │              documentation to determine this value.
│ │          """
│ │ @@ -546,64 +597,14 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_acceld_b_ref(self):
│ │ -        """
│ │ -        float: Specifies the decibel reference level in the units of the
│ │ -            channel. When you read samples as a waveform, the decibel
│ │ -            reference level is included in the waveform attributes.
│ │ -        """
│ │ -        val = ctypes.c_double()
│ │ -
│ │ -        cfunc = lib_importer.windll.DAQmxGetAIAcceldBRef
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_double)]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle, self._name, ctypes.byref(val))
│ │ -        check_for_error(error_code)
│ │ -
│ │ -        return val.value
│ │ -
│ │ -    @ai_acceld_b_ref.setter
│ │ -    def ai_acceld_b_ref(self, val):
│ │ -        cfunc = lib_importer.windll.DAQmxSetAIAcceldBRef
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_double]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle, self._name, val)
│ │ -        check_for_error(error_code)
│ │ -
│ │ -    @ai_acceld_b_ref.deleter
│ │ -    def ai_acceld_b_ref(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAIAcceldBRef
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle, ctypes_byte_str]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle, self._name)
│ │ -        check_for_error(error_code)
│ │ -
│ │ -    @property
│ │      def ai_adc_custom_timing_mode(self):
│ │          """
│ │          int: Specifies the timing mode of the ADC when
│ │              **ai_adc_timing_mode** is **ADCTimingMode.CUSTOM**.
│ │          """
│ │          val = ctypes.c_uint()
│ │  
│ │ @@ -7037,15 +7038,15 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_rtd_r_0(self):
│ │ +    def ai_rtd_r0(self):
│ │          """
│ │          float: Specifies in ohms the sensor resistance at 0 deg C. The
│ │              Callendar-Van Dusen equation requires this value. Refer to
│ │              the sensor documentation to determine this value.
│ │          """
│ │          val = ctypes.c_double()
│ │  
│ │ @@ -7059,30 +7060,30 @@
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │ -    @ai_rtd_r_0.setter
│ │ -    def ai_rtd_r_0(self, val):
│ │ +    @ai_rtd_r0.setter
│ │ +    def ai_rtd_r0(self, val):
│ │          cfunc = lib_importer.windll.DAQmxSetAIRTDR0
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_rtd_r_0.deleter
│ │ -    def ai_rtd_r_0(self):
│ │ +    @ai_rtd_r0.deleter
│ │ +    def ai_rtd_r0(self):
│ │          cfunc = lib_importer.windll.DAQmxResetAIRTDR0
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │ @@ -7489,162 +7490,162 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_sound_pressure_max_sound_pressure_lvl(self):
│ │ +    def ai_sound_pressure_db_ref(self):
│ │          """
│ │ -        float: Specifies the maximum instantaneous sound pressure level
│ │ -            you expect to measure. This value is in decibels, referenced
│ │ -            to 20 micropascals. NI-DAQmx uses the maximum sound pressure
│ │ -            level to calculate values in pascals for **ai_max** and
│ │ -            **ai_min** for the channel.
│ │ +        float: Specifies the decibel reference level in the units of the
│ │ +            channel. When you read samples as a waveform, the decibel
│ │ +            reference level is included in the waveform attributes. NI-
│ │ +            DAQmx also uses the decibel reference level when converting
│ │ +            **ai_sound_pressure_max_sound_pressure_lvl** to a voltage
│ │ +            level.
│ │          """
│ │          val = ctypes.c_double()
│ │  
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxGetAISoundPressureMaxSoundPressureLvl)
│ │ +        cfunc = lib_importer.windll.DAQmxGetAISoundPressuredBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.POINTER(ctypes.c_double)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │ -    @ai_sound_pressure_max_sound_pressure_lvl.setter
│ │ -    def ai_sound_pressure_max_sound_pressure_lvl(self, val):
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxSetAISoundPressureMaxSoundPressureLvl)
│ │ +    @ai_sound_pressure_db_ref.setter
│ │ +    def ai_sound_pressure_db_ref(self, val):
│ │ +        cfunc = lib_importer.windll.DAQmxSetAISoundPressuredBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_sound_pressure_max_sound_pressure_lvl.deleter
│ │ -    def ai_sound_pressure_max_sound_pressure_lvl(self):
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxResetAISoundPressureMaxSoundPressureLvl)
│ │ +    @ai_sound_pressure_db_ref.deleter
│ │ +    def ai_sound_pressure_db_ref(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAISoundPressuredBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_sound_pressure_units(self):
│ │ +    def ai_sound_pressure_max_sound_pressure_lvl(self):
│ │          """
│ │ -        :class:`nidaqmx.constants.SoundPressureUnits`: Specifies the
│ │ -            units to use to return sound pressure measurements from the
│ │ -            channel.
│ │ +        float: Specifies the maximum instantaneous sound pressure level
│ │ +            you expect to measure. This value is in decibels, referenced
│ │ +            to 20 micropascals. NI-DAQmx uses the maximum sound pressure
│ │ +            level to calculate values in pascals for **ai_max** and
│ │ +            **ai_min** for the channel.
│ │          """
│ │ -        val = ctypes.c_int()
│ │ +        val = ctypes.c_double()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAISoundPressureUnits
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxGetAISoundPressureMaxSoundPressureLvl)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_int)]
│ │ +                        ctypes.POINTER(ctypes.c_double)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return SoundPressureUnits(val.value)
│ │ +        return val.value
│ │  
│ │ -    @ai_sound_pressure_units.setter
│ │ -    def ai_sound_pressure_units(self, val):
│ │ -        val = val.value
│ │ -        cfunc = lib_importer.windll.DAQmxSetAISoundPressureUnits
│ │ +    @ai_sound_pressure_max_sound_pressure_lvl.setter
│ │ +    def ai_sound_pressure_max_sound_pressure_lvl(self, val):
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxSetAISoundPressureMaxSoundPressureLvl)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_int]
│ │ +                        ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_sound_pressure_units.deleter
│ │ -    def ai_sound_pressure_units(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAISoundPressureUnits
│ │ +    @ai_sound_pressure_max_sound_pressure_lvl.deleter
│ │ +    def ai_sound_pressure_max_sound_pressure_lvl(self):
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxResetAISoundPressureMaxSoundPressureLvl)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_sound_pressured_b_ref(self):
│ │ +    def ai_sound_pressure_units(self):
│ │          """
│ │ -        float: Specifies the decibel reference level in the units of the
│ │ -            channel. When you read samples as a waveform, the decibel
│ │ -            reference level is included in the waveform attributes. NI-
│ │ -            DAQmx also uses the decibel reference level when converting
│ │ -            **ai_sound_pressure_max_sound_pressure_lvl** to a voltage
│ │ -            level.
│ │ +        :class:`nidaqmx.constants.SoundPressureUnits`: Specifies the
│ │ +            units to use to return sound pressure measurements from the
│ │ +            channel.
│ │          """
│ │ -        val = ctypes.c_double()
│ │ +        val = ctypes.c_int()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAISoundPressuredBRef
│ │ +        cfunc = lib_importer.windll.DAQmxGetAISoundPressureUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_double)]
│ │ +                        ctypes.POINTER(ctypes.c_int)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return val.value
│ │ +        return SoundPressureUnits(val.value)
│ │  
│ │ -    @ai_sound_pressured_b_ref.setter
│ │ -    def ai_sound_pressured_b_ref(self, val):
│ │ -        cfunc = lib_importer.windll.DAQmxSetAISoundPressuredBRef
│ │ +    @ai_sound_pressure_units.setter
│ │ +    def ai_sound_pressure_units(self, val):
│ │ +        val = val.value
│ │ +        cfunc = lib_importer.windll.DAQmxSetAISoundPressureUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_double]
│ │ +                        ctypes.c_int]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_sound_pressured_b_ref.deleter
│ │ -    def ai_sound_pressured_b_ref(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAISoundPressuredBRef
│ │ +    @ai_sound_pressure_units.deleter
│ │ +    def ai_sound_pressure_units(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAISoundPressureUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │ @@ -8464,15 +8465,15 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_thrmstr_r_1(self):
│ │ +    def ai_thrmstr_r1(self):
│ │          """
│ │          float: Specifies in ohms the value of the reference resistor for
│ │              the thermistor if you use voltage excitation. NI-DAQmx
│ │              ignores this value for current excitation.
│ │          """
│ │          val = ctypes.c_double()
│ │  
│ │ @@ -8486,30 +8487,30 @@
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │ -    @ai_thrmstr_r_1.setter
│ │ -    def ai_thrmstr_r_1(self, val):
│ │ +    @ai_thrmstr_r1.setter
│ │ +    def ai_thrmstr_r1(self, val):
│ │          cfunc = lib_importer.windll.DAQmxSetAIThrmstrR1
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_thrmstr_r_1.deleter
│ │ -    def ai_thrmstr_r_1(self):
│ │ +    @ai_thrmstr_r1.deleter
│ │ +    def ai_thrmstr_r1(self):
│ │          cfunc = lib_importer.windll.DAQmxResetAIThrmstrR1
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │ @@ -8664,157 +8665,157 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_velocity_iepe_sensor_sensitivity(self):
│ │ +    def ai_velocity_iepe_sensor_db_ref(self):
│ │          """
│ │ -        float: Specifies the sensitivity of the IEPE velocity sensor
│ │ -            connected to the channel. Specify this value in the unit
│ │ -            indicated by **ai_velocity_iepe_sensor_sensitivity_units**.
│ │ +        float: Specifies the decibel reference level in the units of the
│ │ +            channel. When you read samples as a waveform, the decibel
│ │ +            reference level is included in the waveform attributes.
│ │          """
│ │          val = ctypes.c_double()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAIVelocityIEPESensorSensitivity
│ │ +        cfunc = lib_importer.windll.DAQmxGetAIVelocityIEPESensordBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.POINTER(ctypes.c_double)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │ -    @ai_velocity_iepe_sensor_sensitivity.setter
│ │ -    def ai_velocity_iepe_sensor_sensitivity(self, val):
│ │ -        cfunc = lib_importer.windll.DAQmxSetAIVelocityIEPESensorSensitivity
│ │ +    @ai_velocity_iepe_sensor_db_ref.setter
│ │ +    def ai_velocity_iepe_sensor_db_ref(self, val):
│ │ +        cfunc = lib_importer.windll.DAQmxSetAIVelocityIEPESensordBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │                          ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_velocity_iepe_sensor_sensitivity.deleter
│ │ -    def ai_velocity_iepe_sensor_sensitivity(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensorSensitivity
│ │ +    @ai_velocity_iepe_sensor_db_ref.deleter
│ │ +    def ai_velocity_iepe_sensor_db_ref(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensordBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_velocity_iepe_sensor_sensitivity_units(self):
│ │ +    def ai_velocity_iepe_sensor_sensitivity(self):
│ │          """
│ │ -        :class:`nidaqmx.constants.VelocityIEPESensorSensitivityUnits`:
│ │ -            Specifies the units for
│ │ -            **ai_velocity_iepe_sensor_sensitivity**.
│ │ +        float: Specifies the sensitivity of the IEPE velocity sensor
│ │ +            connected to the channel. Specify this value in the unit
│ │ +            indicated by **ai_velocity_iepe_sensor_sensitivity_units**.
│ │          """
│ │ -        val = ctypes.c_int()
│ │ +        val = ctypes.c_double()
│ │  
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxGetAIVelocityIEPESensorSensitivityUnits)
│ │ +        cfunc = lib_importer.windll.DAQmxGetAIVelocityIEPESensorSensitivity
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_int)]
│ │ +                        ctypes.POINTER(ctypes.c_double)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return VelocityIEPESensorSensitivityUnits(val.value)
│ │ +        return val.value
│ │  
│ │ -    @ai_velocity_iepe_sensor_sensitivity_units.setter
│ │ -    def ai_velocity_iepe_sensor_sensitivity_units(self, val):
│ │ -        val = val.value
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxSetAIVelocityIEPESensorSensitivityUnits)
│ │ +    @ai_velocity_iepe_sensor_sensitivity.setter
│ │ +    def ai_velocity_iepe_sensor_sensitivity(self, val):
│ │ +        cfunc = lib_importer.windll.DAQmxSetAIVelocityIEPESensorSensitivity
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_int]
│ │ +                        ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_velocity_iepe_sensor_sensitivity_units.deleter
│ │ -    def ai_velocity_iepe_sensor_sensitivity_units(self):
│ │ -        cfunc = (lib_importer.windll.
│ │ -                 DAQmxResetAIVelocityIEPESensorSensitivityUnits)
│ │ +    @ai_velocity_iepe_sensor_sensitivity.deleter
│ │ +    def ai_velocity_iepe_sensor_sensitivity(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensorSensitivity
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_velocity_iepe_sensord_b_ref(self):
│ │ +    def ai_velocity_iepe_sensor_sensitivity_units(self):
│ │          """
│ │ -        float: Specifies the decibel reference level in the units of the
│ │ -            channel. When you read samples as a waveform, the decibel
│ │ -            reference level is included in the waveform attributes.
│ │ +        :class:`nidaqmx.constants.VelocityIEPESensorSensitivityUnits`:
│ │ +            Specifies the units for
│ │ +            **ai_velocity_iepe_sensor_sensitivity**.
│ │          """
│ │ -        val = ctypes.c_double()
│ │ +        val = ctypes.c_int()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAIVelocityIEPESensordBRef
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxGetAIVelocityIEPESensorSensitivityUnits)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_double)]
│ │ +                        ctypes.POINTER(ctypes.c_int)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return val.value
│ │ +        return VelocityIEPESensorSensitivityUnits(val.value)
│ │  
│ │ -    @ai_velocity_iepe_sensord_b_ref.setter
│ │ -    def ai_velocity_iepe_sensord_b_ref(self, val):
│ │ -        cfunc = lib_importer.windll.DAQmxSetAIVelocityIEPESensordBRef
│ │ +    @ai_velocity_iepe_sensor_sensitivity_units.setter
│ │ +    def ai_velocity_iepe_sensor_sensitivity_units(self, val):
│ │ +        val = val.value
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxSetAIVelocityIEPESensorSensitivityUnits)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_double]
│ │ +                        ctypes.c_int]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_velocity_iepe_sensord_b_ref.deleter
│ │ -    def ai_velocity_iepe_sensord_b_ref(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensordBRef
│ │ +    @ai_velocity_iepe_sensor_sensitivity_units.deleter
│ │ +    def ai_velocity_iepe_sensor_sensitivity_units(self):
│ │ +        cfunc = (lib_importer.windll.
│ │ +                 DAQmxResetAIVelocityIEPESensorSensitivityUnits)
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │ @@ -8918,103 +8919,103 @@
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_voltage_units(self):
│ │ +    def ai_voltage_db_ref(self):
│ │          """
│ │ -        :class:`nidaqmx.constants.VoltageUnits`: Specifies the units to
│ │ -            use to return voltage measurements from the channel.
│ │ +        float: Specifies the decibel reference level in the units of the
│ │ +            channel. When you read samples as a waveform, the decibel
│ │ +            reference level is included in the waveform attributes.
│ │          """
│ │ -        val = ctypes.c_int()
│ │ +        val = ctypes.c_double()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAIVoltageUnits
│ │ +        cfunc = lib_importer.windll.DAQmxGetAIVoltagedBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_int)]
│ │ +                        ctypes.POINTER(ctypes.c_double)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return VoltageUnits(val.value)
│ │ +        return val.value
│ │  
│ │ -    @ai_voltage_units.setter
│ │ -    def ai_voltage_units(self, val):
│ │ -        val = val.value
│ │ -        cfunc = lib_importer.windll.DAQmxSetAIVoltageUnits
│ │ +    @ai_voltage_db_ref.setter
│ │ +    def ai_voltage_db_ref(self, val):
│ │ +        cfunc = lib_importer.windll.DAQmxSetAIVoltagedBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_int]
│ │ +                        ctypes.c_double]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_voltage_units.deleter
│ │ -    def ai_voltage_units(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAIVoltageUnits
│ │ +    @ai_voltage_db_ref.deleter
│ │ +    def ai_voltage_db_ref(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAIVoltagedBRef
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │      @property
│ │ -    def ai_voltaged_b_ref(self):
│ │ +    def ai_voltage_units(self):
│ │          """
│ │ -        float: Specifies the decibel reference level in the units of the
│ │ -            channel. When you read samples as a waveform, the decibel
│ │ -            reference level is included in the waveform attributes.
│ │ +        :class:`nidaqmx.constants.VoltageUnits`: Specifies the units to
│ │ +            use to return voltage measurements from the channel.
│ │          """
│ │ -        val = ctypes.c_double()
│ │ +        val = ctypes.c_int()
│ │  
│ │ -        cfunc = lib_importer.windll.DAQmxGetAIVoltagedBRef
│ │ +        cfunc = lib_importer.windll.DAQmxGetAIVoltageUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.POINTER(ctypes.c_double)]
│ │ +                        ctypes.POINTER(ctypes.c_int)]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │ -        return val.value
│ │ +        return VoltageUnits(val.value)
│ │  
│ │ -    @ai_voltaged_b_ref.setter
│ │ -    def ai_voltaged_b_ref(self, val):
│ │ -        cfunc = lib_importer.windll.DAQmxSetAIVoltagedBRef
│ │ +    @ai_voltage_units.setter
│ │ +    def ai_voltage_units(self, val):
│ │ +        val = val.value
│ │ +        cfunc = lib_importer.windll.DAQmxSetAIVoltageUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str,
│ │ -                        ctypes.c_double]
│ │ +                        ctypes.c_int]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name, val)
│ │          check_for_error(error_code)
│ │  
│ │ -    @ai_voltaged_b_ref.deleter
│ │ -    def ai_voltaged_b_ref(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetAIVoltagedBRef
│ │ +    @ai_voltage_units.deleter
│ │ +    def ai_voltage_units(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetAIVoltageUnits
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │ @@ -9369,7 +9370,97 @@
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, self._name)
│ │          check_for_error(error_code)
│ │  
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
│ │ +    def ai_rtd_r_0(self):
│ │ +        return self.ai_rtd_r0
│ │ +
│ │ +    @ai_rtd_r_0.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
│ │ +    def ai_rtd_r_0(self, val):
│ │ +        self.ai_rtd_r0 = val
│ │ +
│ │ +    @ai_rtd_r_0.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
│ │ +    def ai_rtd_r_0(self):
│ │ +        del self.ai_rtd_r0
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
│ │ +    def ai_sound_pressured_b_ref(self):
│ │ +        return self.ai_sound_pressure_db_ref
│ │ +
│ │ +    @ai_sound_pressured_b_ref.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
│ │ +    def ai_sound_pressured_b_ref(self, val):
│ │ +        self.ai_sound_pressure_db_ref = val
│ │ +
│ │ +    @ai_sound_pressured_b_ref.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
│ │ +    def ai_sound_pressured_b_ref(self):
│ │ +        del self.ai_sound_pressure_db_ref
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
│ │ +    def ai_thrmstr_r_1(self):
│ │ +        return self.ai_thrmstr_r1
│ │ +
│ │ +    @ai_thrmstr_r_1.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
│ │ +    def ai_thrmstr_r_1(self, val):
│ │ +        self.ai_thrmstr_r1 = val
│ │ +
│ │ +    @ai_thrmstr_r_1.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
│ │ +    def ai_thrmstr_r_1(self):
│ │ +        del self.ai_thrmstr_r1
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
│ │ +    def ai_acceld_b_ref(self):
│ │ +        return self.ai_accel_db_ref
│ │ +
│ │ +    @ai_acceld_b_ref.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
│ │ +    def ai_acceld_b_ref(self, val):
│ │ +        self.ai_accel_db_ref = val
│ │ +
│ │ +    @ai_acceld_b_ref.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
│ │ +    def ai_acceld_b_ref(self):
│ │ +        del self.ai_accel_db_ref
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
│ │ +    def ai_voltaged_b_ref(self):
│ │ +        return self.ai_voltage_db_ref
│ │ +
│ │ +    @ai_voltaged_b_ref.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
│ │ +    def ai_voltaged_b_ref(self, val):
│ │ +        self.ai_voltage_db_ref = val
│ │ +
│ │ +    @ai_voltaged_b_ref.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
│ │ +    def ai_voltaged_b_ref(self):
│ │ +        del self.ai_voltage_db_ref
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
│ │ +    def ai_velocity_iepe_sensord_b_ref(self):
│ │ +        return self.ai_velocity_iepe_sensor_db_ref
│ │ +
│ │ +    @ai_velocity_iepe_sensord_b_ref.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
│ │ +    def ai_velocity_iepe_sensord_b_ref(self, val):
│ │ +        self.ai_velocity_iepe_sensor_db_ref = val
│ │ +
│ │ +    @ai_velocity_iepe_sensord_b_ref.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
│ │ +    def ai_velocity_iepe_sensord_b_ref(self):
│ │ +        del self.ai_velocity_iepe_sensor_db_ref
│ │ +
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ao_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ao_channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -19,15 +19,15 @@
│ │  class AOChannel(Channel):
│ │      """
│ │      Represents one or more analog output virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'AOChannel(name={0})'.format(self._name)
│ │ +        return f'AOChannel(name={self._name})'
│ │  
│ │      @property
│ │      def ao_common_mode_offset(self):
│ │          """
│ │          float: Specifies the common-mode offset of the AO channel. Use
│ │              the property only when Terminal Configuration is set to
│ │              Differential.
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -9,15 +9,15 @@
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.utils import flatten_channel_string, unflatten_channel_string
│ │  from nidaqmx.constants import (
│ │      ChannelType, SyncUnlockBehavior, _Save)
│ │  
│ │  
│ │ -class Channel(object):
│ │ +class Channel:
│ │      """
│ │      Represents virtual channel or a list of virtual channels.
│ │      """
│ │      __slots__ = ['_handle', '_name', '__weakref__']
│ │  
│ │      def __init__(self, task_handle, virtual_or_physical_name):
│ │          """
│ │ @@ -29,15 +29,15 @@
│ │          """
│ │          self._handle = task_handle
│ │          self._name = virtual_or_physical_name
│ │  
│ │      def __add__(self, other):
│ │          if not isinstance(other, self.__class__):
│ │              raise NotImplementedError(
│ │ -                'Cannot concatenate objects of type {0} and {1}'
│ │ +                'Cannot concatenate objects of type {} and {}'
│ │                  .format(self.__class__, other.__class__))
│ │  
│ │          if self._handle != other._handle:
│ │              raise NotImplementedError(
│ │                  'Cannot concatenate Channel objects from different tasks.')
│ │  
│ │          name = flatten_channel_string([self.name, other.name])
│ │ @@ -79,15 +79,15 @@
│ │          channel_names = self.channel_names
│ │          channel_names.reverse()
│ │  
│ │          for channel_name in channel_names:
│ │              yield Channel._factory(self._handle, channel_name)
│ │  
│ │      def __repr__(self):
│ │ -        return 'Channel(name={0})'.format(self.name)
│ │ +        return f'Channel(name={self.name})'
│ │  
│ │      @staticmethod
│ │      def _factory(task_handle, virtual_or_physical_name):
│ │          """
│ │          Implements the factory pattern for nidaqmx channels.
│ │  
│ │          Args:
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/ci_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/ci_channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -20,15 +20,15 @@
│ │  class CIChannel(Channel):
│ │      """
│ │      Represents one or more counter input virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'CIChannel(name={0})'.format(self._name)
│ │ +        return f'CIChannel(name={self._name})'
│ │  
│ │      @property
│ │      def ci_ang_encoder_initial_angle(self):
│ │          """
│ │          float: Specifies the starting angle of the encoder. This value
│ │              is in the units you specify with **ci_ang_encoder_units**.
│ │          """
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/co_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/co_channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -16,15 +16,15 @@
│ │  class COChannel(Channel):
│ │      """
│ │      Represents one or more counter output virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'COChannel(name={0})'.format(self._name)
│ │ +        return f'COChannel(name={self._name})'
│ │  
│ │      @property
│ │      def co_auto_incr_cnt(self):
│ │          """
│ │          int: Specifies a number of timebase ticks by which to increase
│ │              the time spent in the idle state for each successive pulse.
│ │          """
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/di_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/di_channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -15,15 +15,15 @@
│ │  class DIChannel(Channel):
│ │      """
│ │      Represents one or more digital input virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'DIChannel(name={0})'.format(self._name)
│ │ +        return f'DIChannel(name={self._name})'
│ │  
│ │      @property
│ │      def di_acquire_on(self):
│ │          """
│ │          :class:`nidaqmx.constants.ActiveOrInactiveEdgeSelection`:
│ │              Specifies on which edge of the sample clock to acquire
│ │              samples.
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/channels/do_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/channels/do_channel.py
│ │┄ Files 1% similar despite different names
│ │ @@ -15,15 +15,15 @@
│ │  class DOChannel(Channel):
│ │      """
│ │      Represents one or more digital output virtual channels and their properties.
│ │      """
│ │      __slots__ = []
│ │  
│ │      def __repr__(self):
│ │ -        return 'DOChannel(name={0})'.format(self._name)
│ │ +        return f'DOChannel(name={self._name})'
│ │  
│ │      @property
│ │      def do_data_xfer_mech(self):
│ │          """
│ │          :class:`nidaqmx.constants.DataTransferActiveTransferMode`:
│ │              Specifies the data transfer mode for the device.
│ │          """
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/ci_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/ci_channel_collection.py
│ │┄ Files 0% similar despite different names
│ │ @@ -15,15 +15,15 @@
│ │  
│ │  
│ │  class CIChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of counter input channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(CIChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, counter, name_to_assign_to_channel=''):
│ │          """
│ │          Creates and returns a CIChannel object.
│ │  
│ │          Args:
│ │              counter (str): Specifies the names of the counters to use to 
│ │ @@ -35,15 +35,15 @@
│ │              
│ │              Specifies the newly created CIChannel object.
│ │          """
│ │          if name_to_assign_to_channel:
│ │              num_counters = len(unflatten_channel_string(counter))
│ │  
│ │              if num_counters > 1:
│ │ -                name = '{0}0:{1}'.format(
│ │ +                name = '{}0:{}'.format(
│ │                      name_to_assign_to_channel, num_counters-1)
│ │              else:
│ │                  name = name_to_assign_to_channel
│ │          else:
│ │              name = counter
│ │  
│ │          return CIChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/co_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/co_channel_collection.py
│ │┄ Files 1% similar despite different names
│ │ @@ -13,15 +13,15 @@
│ │  
│ │  
│ │  class COChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of counter output channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(COChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, counter, name_to_assign_to_channel=''):
│ │          """
│ │          Creates and returns a COChannel object.
│ │  
│ │          Args:
│ │              counter (str): Specifies the names of the counters to use to 
│ │ @@ -33,15 +33,15 @@
│ │              
│ │              Specifies the newly created COChannel object.
│ │          """
│ │          if name_to_assign_to_channel:
│ │              num_counters = len(unflatten_channel_string(counter))
│ │  
│ │              if num_counters > 1:
│ │ -                name = '{0}0:{1}'.format(
│ │ +                name = '{}0:{}'.format(
│ │                      name_to_assign_to_channel, num_counters-1)
│ │              else:
│ │                  name = name_to_assign_to_channel
│ │          else:
│ │              name = counter
│ │  
│ │          return COChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/di_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/di_channel_collection.py
│ │┄ Files 2% similar despite different names
│ │ @@ -13,15 +13,15 @@
│ │  
│ │  
│ │  class DIChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of digital input channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(DIChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, lines, line_grouping, name_to_assign_to_lines=''):
│ │          """
│ │          Creates and returns a DIChannel object.
│ │  
│ │          Args:
│ │              lines (str): Specifies the names of the lines to use to 
│ │ @@ -43,15 +43,15 @@
│ │              if name_to_assign_to_lines or num_lines == 1:
│ │                  name = lines
│ │              else:
│ │                  name = unflattened_lines[0] + '...'
│ │          else:
│ │              if name_to_assign_to_lines:
│ │                  if num_lines > 1:
│ │ -                    name = '{0}0:{1}'.format(
│ │ +                    name = '{}0:{}'.format(
│ │                          name_to_assign_to_lines, num_lines-1)
│ │                  else:
│ │                      name = name_to_assign_to_lines
│ │              else:
│ │                  name = lines
│ │  
│ │          return DIChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/do_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/do_channel_collection.py
│ │┄ Files 1% similar despite different names
│ │ @@ -13,15 +13,15 @@
│ │  
│ │  
│ │  class DOChannelCollection(ChannelCollection):
│ │      """
│ │      Contains the collection of digital output channels for a DAQmx Task.
│ │      """
│ │      def __init__(self, task_handle):
│ │ -        super(DOChannelCollection, self).__init__(task_handle)
│ │ +        super().__init__(task_handle)
│ │  
│ │      def _create_chan(self, lines, line_grouping, name_to_assign_to_lines=''):
│ │          """
│ │          Creates and returns a DOChannel object.
│ │  
│ │          Args:
│ │              lines (str): Specifies the names of the lines to use to 
│ │ @@ -43,15 +43,15 @@
│ │              if name_to_assign_to_lines or num_lines == 1:
│ │                  name = lines
│ │              else:
│ │                  name = unflattened_lines[0] + '...'
│ │          else:
│ │              if name_to_assign_to_lines:
│ │                  if num_lines > 1:
│ │ -                    name = '{0}0:{1}'.format(
│ │ +                    name = '{}0:{}'.format(
│ │                          name_to_assign_to_lines, num_lines-1)
│ │                  else:
│ │                      name = name_to_assign_to_lines
│ │              else:
│ │                  name = lines
│ │  
│ │          return DOChannel(self._handle, name)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/export_signals.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/export_signals.py
│ │┄ Files 0% similar despite different names
│ │ @@ -7,15 +7,15 @@
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      DeassertCondition, DigitalWidthUnits, ExportAction, Level, Polarity,
│ │      Signal)
│ │  
│ │  
│ │ -class ExportSignals(object):
│ │ +class ExportSignals:
│ │      """
│ │      Represents the exported signal configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/in_stream.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/in_stream.py
│ │┄ Files 1% similar despite different names
│ │ @@ -1,51 +1,52 @@
│ │  # Do not edit this file; it was automatically generated.
│ │  
│ │  import ctypes
│ │  import numpy
│ │ +import deprecation
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
│ │  from nidaqmx._task_modules.read_functions import _read_raw
│ │  from nidaqmx.errors import check_for_error, is_string_buffer_too_small
│ │  from nidaqmx._task_modules.channels.channel import Channel
│ │  from nidaqmx.utils import unflatten_channel_string
│ │  from nidaqmx.constants import (
│ │      AcquisitionType, LoggingMode, LoggingOperation, OverwriteMode,
│ │      READ_ALL_AVAILABLE, ReadRelativeTo, WaitMode)
│ │  
│ │  
│ │ -class InStream(object):
│ │ +class InStream:
│ │      """
│ │      Exposes an input data stream on a DAQmx task.
│ │  
│ │      The input data stream be used to control reading behavior and can be
│ │      used in conjunction with reader classes to read samples from an
│ │      NI-DAQmx task.
│ │      """
│ │      def __init__(self, task):
│ │          self._task = task
│ │          self._handle = task._handle
│ │          self._timeout = 10.0
│ │  
│ │ -        super(InStream, self).__init__()
│ │ +        super().__init__()
│ │  
│ │      def __eq__(self, other):
│ │          if isinstance(other, self.__class__):
│ │              return (self._handle == other._handle and
│ │                      self._timeout == other._timeout)
│ │          return False
│ │  
│ │      def __hash__(self):
│ │          return hash((self._handle.value, self._timeout))
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'InStream(task={0})'.format(self._task.name)
│ │ +        return f'InStream(task={self._task.name})'
│ │  
│ │      @property
│ │      def timeout(self):
│ │          """
│ │          float: Specifies the amount of time in seconds to wait for
│ │              samples to become available. If the time elapses, the read
│ │              method returns an error and any samples read before the
│ │ @@ -1391,62 +1392,14 @@
│ │          error_code = cfunc(
│ │              self._handle, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │      @property
│ │ -    def over_write(self):
│ │ -        """
│ │ -        :class:`nidaqmx.constants.OverwriteMode`: Specifies whether to
│ │ -            overwrite samples in the buffer that you have not yet read.
│ │ -        """
│ │ -        val = ctypes.c_int()
│ │ -
│ │ -        cfunc = lib_importer.windll.DAQmxGetReadOverWrite
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle, ctypes.POINTER(ctypes.c_int)]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle, ctypes.byref(val))
│ │ -        check_for_error(error_code)
│ │ -
│ │ -        return OverwriteMode(val.value)
│ │ -
│ │ -    @over_write.setter
│ │ -    def over_write(self, val):
│ │ -        val = val.value
│ │ -        cfunc = lib_importer.windll.DAQmxSetReadOverWrite
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle, ctypes.c_int]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle, val)
│ │ -        check_for_error(error_code)
│ │ -
│ │ -    @over_write.deleter
│ │ -    def over_write(self):
│ │ -        cfunc = lib_importer.windll.DAQmxResetReadOverWrite
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        lib_importer.task_handle]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._handle)
│ │ -        check_for_error(error_code)
│ │ -
│ │ -    @property
│ │      def overcurrent_chans(self):
│ │          """
│ │          List[str]: Indicates a list of names of any virtual channels in
│ │              the task for which the device(s) detected an overcurrent
│ │              condition. You must read **overcurrent_chans_exist** before
│ │              you read this property. Otherwise, you will receive an
│ │              error. On some devices, you must restart the task for all
│ │ @@ -1622,14 +1575,62 @@
│ │          error_code = cfunc(
│ │              self._handle, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │      @property
│ │ +    def overwrite(self):
│ │ +        """
│ │ +        :class:`nidaqmx.constants.OverwriteMode`: Specifies whether to
│ │ +            overwrite samples in the buffer that you have not yet read.
│ │ +        """
│ │ +        val = ctypes.c_int()
│ │ +
│ │ +        cfunc = lib_importer.windll.DAQmxGetReadOverWrite
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle, ctypes.POINTER(ctypes.c_int)]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle, ctypes.byref(val))
│ │ +        check_for_error(error_code)
│ │ +
│ │ +        return OverwriteMode(val.value)
│ │ +
│ │ +    @overwrite.setter
│ │ +    def overwrite(self, val):
│ │ +        val = val.value
│ │ +        cfunc = lib_importer.windll.DAQmxSetReadOverWrite
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle, ctypes.c_int]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle, val)
│ │ +        check_for_error(error_code)
│ │ +
│ │ +    @overwrite.deleter
│ │ +    def overwrite(self):
│ │ +        cfunc = lib_importer.windll.DAQmxResetReadOverWrite
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        lib_importer.task_handle]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._handle)
│ │ +        check_for_error(error_code)
│ │ +
│ │ +    @property
│ │      def pll_unlocked_chans(self):
│ │          """
│ │          List[str]: Indicates the channels that had their PLLs unlock.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetReadPLLUnlockedChans
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │ @@ -1931,15 +1932,15 @@
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │      @property
│ │      def reverse_voltage_error_chans(self):
│ │          """
│ │ -        List[str]: Indicates a list of names of any virtual channels in
│ │ +        List[str]: Indicates a list of names of all virtual channels in
│ │              the task for which reverse voltage error condition has been
│ │              detected. You must read the Reverse Voltage Error Channels
│ │              Exist property before you read this property. Otherwise, you
│ │              will receive an error.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetReverseVoltageErrorChans
│ │          if cfunc.argtypes is None:
│ │ @@ -1969,20 +1970,20 @@
│ │  
│ │          return unflatten_channel_string(val.value.decode('ascii'))
│ │  
│ │      @property
│ │      def reverse_voltage_error_chans_exist(self):
│ │          """
│ │          bool: Indicates if the device(s) detected reverse voltage error
│ │ -            for any channel in the task. Reverse voltage error will
│ │ -            occured if the local voltage is equal to negative saturated
│ │ -            voltage. Reading this property clears the error condition
│ │ -            status for all channels in the task. You must read this
│ │ -            property before you read the Reverse Voltage Error Channels
│ │ -            property. Otherwise, you will receive an error.
│ │ +            for any of the channels in the task. Reverse voltage error
│ │ +            occurs if the local voltage is equal to the negative
│ │ +            saturated voltage. Reading this property clears the error
│ │ +            condition status for all channels in the task. You must read
│ │ +            this property before you read the Reverse Voltage Error
│ │ +            Channels property. Otherwise, you will receive an error.
│ │          """
│ │          val = c_bool32()
│ │  
│ │          cfunc = lib_importer.windll.DAQmxGetReverseVoltageErrorChansExist
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │ @@ -2442,7 +2443,23 @@
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [
│ │                          lib_importer.task_handle, ctypes_byte_str]
│ │  
│ │          error_code = cfunc(
│ │              self._handle, file_path)
│ │          check_for_error(error_code)
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use overwrite instead.")
│ │ +    def over_write(self):
│ │ +        return self.overwrite
│ │ +
│ │ +    @over_write.setter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use overwrite instead.")
│ │ +    def over_write(self, val):
│ │ +        self.overwrite = val
│ │ +
│ │ +    @over_write.deleter
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use overwrite instead.")
│ │ +    def over_write(self):
│ │ +        del self.overwrite
│ │ +
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/out_stream.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/out_stream.py
│ │┄ Files 1% similar despite different names
│ │ @@ -7,29 +7,29 @@
│ │  from nidaqmx._task_modules.write_functions import _write_raw
│ │  from nidaqmx.errors import check_for_error, is_string_buffer_too_small
│ │  from nidaqmx.utils import unflatten_channel_string
│ │  from nidaqmx.constants import (
│ │      RegenerationMode, ResolutionType, WaitMode, WriteRelativeTo)
│ │  
│ │  
│ │ -class OutStream(object):
│ │ +class OutStream:
│ │      """
│ │      Exposes an output data stream on a DAQmx task.
│ │  
│ │      The output data stream be used to control writing behavior and can be
│ │      used in conjunction with writer classes to write samples to an
│ │      NI-DAQmx task.
│ │      """
│ │      def __init__(self, task):
│ │          self._task = task
│ │          self._handle = task._handle
│ │          self._auto_start = False
│ │          self._timeout = 10.0
│ │  
│ │ -        super(OutStream, self).__init__()
│ │ +        super().__init__()
│ │  
│ │      def __eq__(self, other):
│ │          if isinstance(other, self.__class__):
│ │              return (self._handle == other._handle and
│ │                      self._auto_start == other._auto_start and
│ │                      self._timeout == other._timeout)
│ │          return False
│ │ @@ -37,15 +37,15 @@
│ │      def __hash__(self):
│ │          return hash((self._handle.value, self._auto_start, self._timeout))
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'OutStream(task={0})'.format(self._task.name)
│ │ +        return f'OutStream(task={self._task.name})'
│ │  
│ │      @property
│ │      def auto_start(self):
│ │          """
│ │          bool: Specifies if the "write" method automatically starts the
│ │              stream's owning task if you did not explicitly start it
│ │              with the DAQmx Start Task method.
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/read_functions.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/read_functions.py
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/timing.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/timing.py
│ │┄ Files 0% similar despite different names
│ │ @@ -10,15 +10,15 @@
│ │  from nidaqmx.constants import (
│ │      AcquisitionType, DigitalWidthUnits, Edge, HandshakeStartCondition, Level,
│ │      MIOAIConvertTimebaseSource, OverflowBehavior, Polarity,
│ │      SampleInputDataWhen, SampleTimingType, SyncPulseType, Timescale,
│ │      UnderflowBehavior)
│ │  
│ │  
│ │ -class Timing(object):
│ │ +class Timing:
│ │      """
│ │      Represents the timing configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │ @@ -3105,19 +3105,19 @@
│ │          Sets the source of the Sample Clock, the rate of the Sample
│ │          Clock, and the number of samples to acquire or generate. The
│ │          device acquires or generates samples on each Sample Clock edge,
│ │          but it does not respond to certain triggers until a few Sample
│ │          Clock edges later. Pipelining allows higher data transfer rates
│ │          at the cost of increased trigger response latency. Refer to the
│ │          device documentation for information about which triggers
│ │ -        pipelining affects.<br/><br/>This timing type allows handshaking
│ │ -        using the Pause trigger and either the Ready for Transfer event
│ │ -        or the Data Active event. Refer to the device documentation for
│ │ -        more information.<br/><br/>This timing type is supported only by
│ │ -        the NI 6536 and NI 6537.
│ │ +        pipelining affects.  This timing type allows handshaking using
│ │ +        the Pause trigger and either the Ready for Transfer event or the
│ │ +        Data Active event. Refer to the device documentation for more
│ │ +        information.  This timing type is supported only by the NI 6536
│ │ +        and NI 6537.
│ │  
│ │          Args:
│ │              rate (float): Specifies the sampling rate in samples per
│ │                  channel per second. If you use an external source for
│ │                  the Sample Clock, set this input to the maximum expected
│ │                  rate of that clock.
│ │              source (Optional[str]): Specifies the source terminal of the
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/arm_start_trigger.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/arm_start_trigger.py
│ │┄ Files 0% similar despite different names
│ │ @@ -8,15 +8,15 @@
│ │  from nidaqmx.system.physical_channel import PhysicalChannel
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      Edge, Timescale, TriggerType)
│ │  
│ │  
│ │ -class ArmStartTrigger(object):
│ │ +class ArmStartTrigger:
│ │      """
│ │      Represents the arm start trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/handshake_trigger.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/handshake_trigger.py
│ │┄ Files 0% similar despite different names
│ │ @@ -7,15 +7,15 @@
│ │  from nidaqmx.system.physical_channel import PhysicalChannel
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      Level, TriggerType)
│ │  
│ │  
│ │ -class HandshakeTrigger(object):
│ │ +class HandshakeTrigger:
│ │      """
│ │      Represents the handshake trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/pause_trigger.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/pause_trigger.py
│ │┄ Files 0% similar despite different names
│ │ @@ -9,15 +9,15 @@
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      ActiveLevel, Coupling, DigitalPatternCondition, Level, TriggerType,
│ │      WindowTriggerCondition2)
│ │  
│ │  
│ │ -class PauseTrigger(object):
│ │ +class PauseTrigger:
│ │      """
│ │      Represents the pause trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/reference_trigger.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/reference_trigger.py
│ │┄ Files 0% similar despite different names
│ │ @@ -9,15 +9,15 @@
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      Coupling, DigitalPatternCondition, Edge, Slope, Timescale, TriggerType,
│ │      WindowTriggerCondition1)
│ │  
│ │  
│ │ -class ReferenceTrigger(object):
│ │ +class ReferenceTrigger:
│ │      """
│ │      Represents the reference trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggering/start_trigger.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggering/start_trigger.py
│ │┄ Files 0% similar despite different names
│ │ @@ -9,15 +9,15 @@
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      Coupling, DigitalPatternCondition, DigitalWidthUnits, Edge, Slope,
│ │      Timescale, TriggerType, WindowTriggerCondition1)
│ │  
│ │  
│ │ -class StartTrigger(object):
│ │ +class StartTrigger:
│ │      """
│ │      Represents the start trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │  
│ │      @property
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/triggers.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/triggers.py
│ │┄ Files 0% similar despite different names
│ │ @@ -12,15 +12,15 @@
│ │  from nidaqmx._task_modules.triggering.pause_trigger import PauseTrigger
│ │  from nidaqmx._task_modules.triggering.reference_trigger import ReferenceTrigger
│ │  from nidaqmx._task_modules.triggering.start_trigger import StartTrigger
│ │  from nidaqmx.constants import (
│ │      SyncType)
│ │  
│ │  
│ │ -class Triggers(object):
│ │ +class Triggers:
│ │      """
│ │      Represents the trigger configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │          self._arm_start_trigger = ArmStartTrigger(self._handle)
│ │          self._handshake_trigger = HandshakeTrigger(self._handle)
│ │   --- nidaqmx-0.6.5/nidaqmx/_task_modules/write_functions.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/_task_modules/write_functions.py
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/nidaqmx/constants.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/constants.py
│ │┄ Files 2% similar despite different names
│ │ @@ -58,34 +58,29 @@
│ │  
│ │  class AcquisitionType(Enum):
│ │      FINITE = 10178  #: Acquire or generate a finite number of samples.
│ │      CONTINUOUS = 10123  #: Acquire or generate samples until you stop the task.
│ │      HW_TIMED_SINGLE_POINT = 12522  #: Acquire or generate samples continuously using hardware timing without a buffer. Hardware timed single point sample mode is supported only for the sample clock and change detection timing types.
│ │  
│ │  
│ │ -class Action(Enum):
│ │ -    COMMIT = 0  #: Commit
│ │ -    CANCEL = 1  #: Cancel
│ │ -
│ │ -
│ │  class ActiveLevel(Enum):
│ │      ABOVE = 10093  #: Pause the measurement or generation while the signal is above the threshold.
│ │      BELOW = 10107  #: Pause the measurement or generation while the signal is below the threshold.
│ │  
│ │  
│ │  class ActiveOrInactiveEdgeSelection(Enum):
│ │      ACTIVE = 14617  #: Active edges.
│ │      INACTIVE = 14618  #: Inactive edges.
│ │  
│ │  
│ │  class AngleUnits(Enum):
│ │      DEGREES = 10146  #: Degrees.
│ │      RADIANS = 10273  #: Radians.
│ │ -    TICKS = 10304  #: Ticks.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ +    TICKS = 10304  #: Ticks.
│ │  
│ │  
│ │  class AngularVelocityUnits(Enum):
│ │      RPM = 16080  #: Revolutions per minute.
│ │      RADIANS_PER_SECOND = 16081  #: Radians per second.
│ │      DEGREES_PER_SECOND = 16082  #: Degrees per second.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ @@ -93,40 +88,33 @@
│ │  
│ │  class AutoZeroType(Enum):
│ │      NONE = 10230  #: Do not perform an autozero.
│ │      ONCE = 10244  #: Perform an auto zero at the beginning of the acquisition. This auto zero task might not run if you have used DAQmx Control Task previously in your task.
│ │      EVERY_SAMPLE = 10164  #: Perform an auto zero at every sample of the acquisition.
│ │  
│ │  
│ │ -class BreakMode(Enum):
│ │ -    NO_ACTION = 10227  #: When advancing to the next entry in the scan list, leave all previous connections intact.
│ │ -    BREAK_BEFORE_MAKE = 10110  #: When advancing to the next entry in the scan list, disconnect all previous connections before making any new connections.
│ │ -
│ │ -
│ │  class BridgeConfiguration(Enum):
│ │      FULL_BRIDGE = 10182  #: Sensor is a full bridge. If you set **ai_excit_use_for_scaling** to True, NI-DAQmx divides the measurement by the excitation value. Many sensors scale data to native units using scaling of volts per excitation.
│ │      HALF_BRIDGE = 10187  #: Sensor is a half bridge. If you set **ai_excit_use_for_scaling** to True, NI-DAQmx divides the measurement by the excitation value. Many sensors scale data to native units using scaling of volts per excitation.
│ │      QUARTER_BRIDGE = 10270  #: Sensor is a quarter bridge. If you set **ai_excit_use_for_scaling** to True, NI-DAQmx divides the measurement by the excitation value. Many sensors scale data to native units using scaling of volts per excitation.
│ │ -    QUARTER_BRIDGE_120_OHM_COMPLETION_RESISTOR = 16163
│ │ -    QUARTER_BRIDGE_350_OHM_COMPLETION_RESISTOR = 16164
│ │      NO_BRIDGE = 10228  #: Sensor is not a Wheatstone bridge.
│ │  
│ │  
│ │  class BridgeElectricalUnits(Enum):
│ │      VOLTS_PER_VOLT = 15896  #: Volts per volt.
│ │      MILLIVOLTS_PER_VOLT = 15897  #: Millivolts per volt.
│ │  
│ │  
│ │  class BridgePhysicalUnits(Enum):
│ │      NEWTONS = 15875  #: Newtons.
│ │      POUNDS = 15876  #: Pounds.
│ │      KILOGRAM_FORCE = 15877  #: kilograms-force.
│ │      PASCALS = 10081  #: Pascals.
│ │ -    BAR = 15880  #: Bar.
│ │      POUNDS_PER_SQ_INCH = 15879  #: Pounds per square inch.
│ │ +    BAR = 15880  #: Bar.
│ │      NEWTON_METERS = 15881  #: Newton metres.
│ │      INCH_OUNCES = 15882  #: Ounce-inches.
│ │      INCH_POUNDS = 15883  #: Pound-inches.
│ │      FOOT_POUNDS = 15884  #: Pound-feet.
│ │  
│ │  
│ │  class BridgeShuntCalSource(Enum):
│ │ @@ -146,32 +134,27 @@
│ │      PCIE = 13612  #: PCI Express.
│ │      PXI = 12583  #: PXI.
│ │      PXIE = 14706  #: PXI Express.
│ │      SCXI = 12584  #: SCXI.
│ │      SCC = 14707  #: SCC.
│ │      PC_CARD = 12585  #: PC Card/PCMCIA.
│ │      USB = 12586  #: USB.
│ │ -    UNKNOWN = 12588  #: Unknown bus type.
│ │      COMPACT_DAQ = 14637  #: CompactDAQ.
│ │      COMPACT_RIO = 16143  #: CompactRIO.
│ │      TCPIP = 14828  #: TCP/IP.
│ │ +    UNKNOWN = 12588  #: Unknown bus type.
│ │      SWITCH_BLOCK = 15870  #: SwitchBlock.
│ │  
│ │  
│ │  class CJCSource(Enum):
│ │      BUILT_IN = 10200  #: Use a cold-junction compensation channel built into the terminal block.
│ │      CONSTANT_USER_VALUE = 10116  #: You must specify the cold-junction temperature.
│ │      SCANNABLE_CHANNEL = 10113  #: Use a channel for cold-junction compensation.
│ │  
│ │  
│ │ -class CalibrationTerminalConfig(Enum):
│ │ -    DIFF = 10106  #: Differential
│ │ -    PSEUDO_DIFF = 12529  #: Pseudodifferential
│ │ -
│ │ -
│ │  class ChannelType(Enum):
│ │      ANALOG_INPUT = 10100  #: Analog input channel.
│ │      ANALOG_OUTPUT = 10102  #: Analog output channel.
│ │      DIGITAL_INPUT = 10151  #: Digital input channel.
│ │      DIGITAL_OUTPUT = 10153  #: Digital output channel.
│ │      COUNTER_INPUT = 10131  #: Counter input channel.
│ │      COUNTER_OUTPUT = 10132  #: Counter output channel.
│ │ @@ -206,17 +189,17 @@
│ │  class Coupling(Enum):
│ │      AC = 10045  #: Remove the DC offset from the signal.
│ │      DC = 10050  #: Allow NI-DAQmx to measure all of the signal.
│ │      GND = 10066  #: Remove the signal from the measurement and measure only ground.
│ │  
│ │  
│ │  class CurrentShuntResistorLocation(Enum):
│ │ -    LET_DRIVER_CHOOSE = -1
│ │      INTERNAL = 10200  #: Use the built-in shunt resistor of the device.
│ │      EXTERNAL = 10167  #: Use a shunt resistor external to the device. You must specify the value of the shunt resistor by using **ai_current_shunt_resistance**.
│ │ +    LET_DRIVER_CHOOSE = -1
│ │  
│ │  
│ │  class CurrentUnits(Enum):
│ │      AMPS = 10342  #: Amperes.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │      FROM_TEDS = 12516  #: Units defined by TEDS information associated with the channel.
│ │  
│ │ @@ -225,15 +208,15 @@
│ │      RIGHT = 10279  #: Samples occupy the lower bits of the integer.
│ │      LEFT = 10209  #: Samples occupy the higher bits of the integer.
│ │  
│ │  
│ │  class DataTransferActiveTransferMode(Enum):
│ │      DMA = 10054  #: Direct Memory Access. Data transfers take place independently from the application.
│ │      INTERRUPT = 10204  #: Data transfers take place independently from the application. Using interrupts increases CPU usage because the CPU must service interrupt requests. Typically, you should use interrupts if the device is out of DMA channels.
│ │ -    POLLED = 10264  #: Data transfers take place when you call DAQmx Read or DAQmx Write.
│ │ +    POLLED = 10264  #: Data transfers take place when you call an NI-DAQmx Read function or an NI-DAQmx Write function.
│ │      USB_BULK = 12590  #: Data transfers take place independently from the application using a USB bulk pipe.
│ │  
│ │  
│ │  class DeassertCondition(Enum):
│ │      ON_BOARD_MEMORY_MORE_THAN_HALF_FULL = 10237  #: Deassert the signal when more than half of the onboard memory of the device fills.
│ │      ON_BOARD_MEMORY_FULL = 10236  #: Deassert the signal when the onboard memory fills.
│ │      ONBOARD_MEMORY_CUSTOM_THRESHOLD = 12577  #: Deassert the signal when the amount of space available in the onboard memory is below the value specified with **rdy_for_xfer_event_deassert_cond_custom_threshold**.
│ │ @@ -268,29 +251,24 @@
│ │      FALLING = 10171  #: Falling edge(s).
│ │  
│ │  
│ │  class EncoderType(Enum):
│ │      X_1 = 10090  #: If signal A leads signal B, count the rising edges of signal A. If signal B leads signal A, count the falling edges of signal A.
│ │      X_2 = 10091  #: Count the rising and falling edges of signal A.
│ │      X_4 = 10092  #: Count the rising and falling edges of signal A and signal B.
│ │ -    TWO_PULSE_COUNTING = 10313  #: Two pulse counting.
│ │ +    TWO_PULSE_COUNTING = 10313  #: Increment the count on rising edges of signal A. Decrement the count on rising edges of signal B.
│ │  
│ │  
│ │  class EncoderZIndexPhase(Enum):
│ │      AHIGH_BHIGH = 10040  #: Reset the measurement when signal A and signal B are high.
│ │      AHIGH_BLOW = 10041  #: Reset the measurement when signal A is high and signal B is low.
│ │      ALOW_BHIGH = 10042  #: Reset the measurement when signal A is low and signal B high.
│ │      ALOW_BLOW = 10043  #: Reset the measurement when signal A and signal B are low.
│ │  
│ │  
│ │ -class EndCalAction(Enum):
│ │ -    COMMIT = 0
│ │ -    CANCEL = 1
│ │ -
│ │ -
│ │  class EveryNSamplesEventType(Enum):
│ │      ACQUIRED_INTO_BUFFER = 1  #: Acquired Into Buffer
│ │      TRANSFERRED_FROM_BUFFER = 2  #: Transferred From Buffer
│ │  
│ │  
│ │  class ExcitationDCorAC(Enum):
│ │      USE_DC = 10050  #: DC excitation.
│ │ @@ -322,60 +300,60 @@
│ │  
│ │  class FillMode(Enum):
│ │      GROUP_BY_CHANNEL = 0  #: Group by Channel
│ │      GROUP_BY_SCAN_NUMBER = 1  #: Group by Scan Number
│ │  
│ │  
│ │  class FilterResponse(Enum):
│ │ -    BRICKWALL = 16155  #: Brickwall filter response.
│ │ -    COMB = 16152  #: Comb filter response.
│ │ -    BESSEL = 16153  #: Bessel filter response.
│ │      CONSTANT_GROUP_DELAY = 16075  #: Constant group delay filter response.
│ │      BUTTERWORTH = 16076  #: Butterworth filter response.
│ │      ELLIPTICAL = 16077  #: Elliptical filter response.
│ │      HARDWARE_DEFINED = 10191  #: Use the hardware-defined filter response.
│ │ +    COMB = 16152  #: Comb filter response.
│ │ +    BESSEL = 16153  #: Bessel filter response.
│ │ +    BRICKWALL = 16155  #: Brickwall filter response.
│ │  
│ │  
│ │  class FilterType(Enum):
│ │      LOWPASS = 16071  #: Lowpass filter.
│ │      HIGHPASS = 16072  #: Highpass filter.
│ │      BANDPASS = 16073  #: Bandpass filter.
│ │      NOTCH = 16074  #: Notch filter.
│ │      CUSTOM = 10137  #: Custom filter.
│ │  
│ │  
│ │  class ForceIEPESensorSensitivityUnits(Enum):
│ │ -    MILLIVOLTS_PER_POUND = 15892  #: Millivolts per pound.
│ │      MILLIVOLTS_PER_NEWTON = 15891  #: Millivolts per newton.
│ │ +    MILLIVOLTS_PER_POUND = 15892  #: Millivolts per pound.
│ │  
│ │  
│ │  class ForceUnits(Enum):
│ │      NEWTONS = 15875  #: Newtons.
│ │      POUNDS = 15876  #: Pounds.
│ │      KILOGRAM_FORCE = 15877  #: Kilograms-force.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │  
│ │  
│ │  class FrequencyUnits(Enum):
│ │      HZ = 10373  #: Hertz.
│ │ -    TICKS = 10304  #: Timebase ticks.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ +    TICKS = 10304  #: Timebase ticks.
│ │  
│ │  
│ │  class FuncGenType(Enum):
│ │      SINE = 14751  #: Sine wave.
│ │      TRIANGLE = 14752  #: Triangle wave.
│ │      SQUARE = 14753  #: Square wave.
│ │      SAWTOOTH = 14754  #: Sawtooth wave.
│ │  
│ │  
│ │  class GpsSignalType(Enum):
│ │      IRIGB = 10070  #: Use the IRIG-B synchronization method. The GPS receiver sends one synchronization pulse per second, as well as information about the number of days, hours, minutes, and seconds that elapsed since the beginning of the current year.
│ │      PPS = 10080  #: Use the PPS synchronization method. The GPS receiver sends one synchronization pulse per second, but does not send any timing information. The timestamp measurement returns the number of seconds that elapsed since the device powered up unless you set **ci_timestamp_initial_seconds**.
│ │ -    NONE = 10230  #: Do not synchronize the counter to a GPS receiver. The timestamp measurement returns the number of seconds that elapsed since the device powered up unless you set  **ci_timestamp_initial_seconds**.
│ │ +    NONE = 10230  #: Do not synchronize the counter to a GPS receiver. The timestamp measurement returns the number of seconds that elapsed since the device powered up unless you set **ci_timestamp_initial_seconds**.
│ │  
│ │  
│ │  class HandshakeStartCondition(Enum):
│ │      IMMEDIATE = 10198  #: Device is waiting for space in the FIFO (for acquisition) or waiting for samples (for generation).
│ │      WAIT_FOR_HANDSHAKE_TRIGGER_ASSERT = 12550  #: Device is waiting for the Handshake Trigger to assert.
│ │      WAIT_FOR_HANDSHAKE_TRIGGER_DEASSERT = 12551  #: Device is waiting for the Handshake Trigger to deassert.
│ │  
│ │ @@ -383,20 +361,14 @@
│ │  class Impedance1(Enum):
│ │      FIFTY_OHMS = 50  #: 50 Ohms.
│ │      SEVENTY_FIVE_OHMS = 75  #: 75 Ohms.
│ │      ONE_M_OHM = 1000000  #: 1 M Ohm.
│ │      TEN_G_OHMS = 10000000000  #: 10 G Ohm.
│ │  
│ │  
│ │ -class InputCalSource(Enum):
│ │ -    LOOPBACK_0 = 0  #: Loopback 0 degree shift
│ │ -    LOOPBACK_180 = 1  #: Loopback 180 degree shift
│ │ -    GROUND = 2  #: Ground
│ │ -
│ │ -
│ │  class InputDataTransferCondition(Enum):
│ │      ON_BOARD_MEMORY_MORE_THAN_HALF_FULL = 10237  #: Transfer data from the device when more than half of the onboard memory of the device fills.
│ │      ON_BOARD_MEMORY_NOT_EMPTY = 10241  #: Transfer data from the device when there is data in the onboard memory.
│ │      ONBOARD_MEMORY_CUSTOM_THRESHOLD = 12577  #: Transfer data from the device when the number of samples specified with **ai_data_xfer_custom_threshold** are in the device FIFO.
│ │      WHEN_ACQUISITION_COMPLETE = 12546  #: Transfer data when the acquisition is complete.
│ │  
│ │  
│ │ @@ -409,34 +381,34 @@
│ │      MILLIVOLTS_PER_VOLT_PER_MILLIMETER = 12506  #: mVolts/Volt/mMeter.
│ │      MILLIVOLTS_PER_VOLT_PER_MILLI_INCH = 12505  #: mVolts/Volt/0.001 Inch.
│ │  
│ │  
│ │  class LengthUnits(Enum):
│ │      METERS = 10219  #: Meters.
│ │      INCHES = 10379  #: Inches.
│ │ -    TICKS = 10304  #: Ticks.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ +    TICKS = 10304  #: Ticks.
│ │  
│ │  
│ │  class Level(Enum):
│ │      HIGH = 10192  #: Logic high.
│ │      LOW = 10214  #: Logic low.
│ │ +    TRISTATE = 10310  #: High-impedance state. You can select this state only on devices with bidirectional lines. You cannot select this state for dedicated digital output lines. On some devices, you can select this value only for entire ports.
│ │      NO_CHANGE = 10160  #: Do not change the state of the lines. On some devices, you can select this value only for entire ports.
│ │ -    TRISTATE = 10310  #: High-impedance state. You can select this state only on devices with bidirectional lines.  You cannot select this state for dedicated digital output lines. On some devices, you can select this value only for entire ports.
│ │  
│ │  
│ │  class LineGrouping(Enum):
│ │      CHAN_PER_LINE = 0  #: One Channel For Each Line
│ │      CHAN_FOR_ALL_LINES = 1  #: One Channel For All Lines
│ │  
│ │  
│ │  class LoggingMode(Enum):
│ │      OFF = 10231  #: Disable logging for the task.
│ │ -    LOG = 15844  #: Enable logging for the task. You cannot read data using DAQmx Read when using this mode. If you require access to the data, read from the TDMS file.
│ │ -    LOG_AND_READ = 15842  #: Enable both logging and reading data for the task. You must use DAQmx Read to read samples for NI-DAQmx to stream them to disk.
│ │ +    LOG = 15844  #: Enable logging for the task. You cannot read data using an NI-DAQmx Read function when using this mode. If you require access to the data, read from the TDMS file.
│ │ +    LOG_AND_READ = 15842  #: Enable both logging and reading data for the task. You must use an NI-DAQmx Read function to read samples for NI-DAQmx to stream them to disk.
│ │  
│ │  
│ │  class LoggingOperation(Enum):
│ │      OPEN = 10437  #: Open an existing TDMS file, and append data to that file. If the file does not exist, NI-DAQmx returns an error.
│ │      OPEN_OR_CREATE = 15846  #: Open an existing TDMS file, and append data to that file. If the file does not exist, NI-DAQmx creates a new TDMS file.
│ │      CREATE_OR_REPLACE = 15847  #: Create a new TDMS file, or replace an existing TDMS file.
│ │      CREATE = 15848  #: Create a new TDMS file. If the file already exists, NI-DAQmx returns an error.
│ │ @@ -451,19 +423,19 @@
│ │  class LogicLvlBehavior(Enum):
│ │      PULL_UP = 16064  #: High logic.
│ │      NONE = 10230  #: Supply no excitation to the channel.
│ │  
│ │  
│ │  class MIOAIConvertTimebaseSource(Enum):
│ │      SAME_AS_SAMP_TIMEBASE = 10284  #: Use the same source as Sample Clock timebase.
│ │ -    EIGHT_MHZ_TIMEBASE = 16023  #: Use the onboard 8 MHz timebase.
│ │ -    ONE_HUNDRED_MHZ_TIMEBASE = 15857  #: Use the onboard 100 MHz timebase.
│ │      SAME_AS_MASTER_TIMEBASE = 10282  #: Use the same source as the Master Timebase.
│ │ -    TWENTY_MHZ_TIMEBASE = 12537  #: Use the onboard 20 MHz timebase.
│ │ +    ONE_HUNDRED_MHZ_TIMEBASE = 15857  #: Use the onboard 100 MHz timebase.
│ │      EIGHTY_MHZ_TIMEBASE = 14636  #: Use the onboard 80 MHz timebase.
│ │ +    TWENTY_MHZ_TIMEBASE = 12537  #: Use the onboard 20 MHz timebase.
│ │ +    EIGHT_MHZ_TIMEBASE = 16023  #: Use the onboard 8 MHz timebase.
│ │  
│ │  
│ │  class ModulationType(Enum):
│ │      AM = 14756  #: Amplitude modulation.
│ │      FM = 14757  #: Frequency modulation.
│ │      NONE = 10230  #: No modulation.
│ │  
│ │ @@ -480,34 +452,19 @@
│ │  
│ │  
│ │  class OverwriteMode(Enum):
│ │      OVERWRITE_UNREAD_SAMPLES = 10252  #: When an acquisition encounters unread data in the buffer, the acquisition continues and overwrites the unread samples with new ones. You can read the new samples by setting **relative_to** to **ReadRelativeTo.MOST_RECENT_SAMPLE** and setting **offset** to the appropriate number of samples.
│ │      DO_NOT_OVERWRITE_UNREAD_SAMPLES = 10159  #: The acquisition stops when it encounters a sample in the buffer that you have not read.
│ │  
│ │  
│ │ -class PathCapability(Enum):
│ │ -    PATH_AVAILABLE = 10431
│ │ -    PATH_ALREADY_EXISTS = 10432
│ │ -    PATH_UNSUPPORTED = 10433
│ │ -    CHANNEL_IN_USE = 10434
│ │ -    CHANNEL_SOURCE_CONFLICT = 10435
│ │ -    CHANNEL_RESERVED_FOR_ROUTING = 10436
│ │ -
│ │ -
│ │  class Polarity(Enum):
│ │      ACTIVE_HIGH = 10095  #: High state is the active state.
│ │      ACTIVE_LOW = 10096  #: Low state is the active state.
│ │  
│ │  
│ │ -class PowerCalibrationType(Enum):
│ │ -    REMOTE_VOLTAGE = 15100  #: Calibrate remote voltage for the power module.
│ │ -    LOCAL_VOLTAGE = 15101  #: Calibrate local voltage for the power module.
│ │ -    CURRENT = 15102  #: Calibrate current for the power module.
│ │ -
│ │ -
│ │  class PowerIdleOutputBehavior(Enum):
│ │      OUTPUT_DISABLED = 15503  #: Disable power output.
│ │      MAINTAIN_EXISTING_VALUE = 12528  #: Continue generating the current power.
│ │  
│ │  
│ │  class PowerOutputState(Enum):
│ │      CONSTANT_VOLTAGE = 15500  #: Power output is maintaining a constant voltage by adjusting the current.
│ │ @@ -521,15 +478,15 @@
│ │      CHANNEL_CURRENT = 1  #: Current Channel
│ │      CHANNEL_HIGH_IMPEDANCE = 2  #: High-Impedance Channel
│ │  
│ │  
│ │  class PowerUpStates(Enum):
│ │      HIGH = 10192  #: Logic high.
│ │      LOW = 10214  #: Logic low.
│ │ -    TRISTATE = 10310  #: High-impedance state. You can select this state only on devices with bidirectional lines.  You cannot select this state for dedicated digital output lines. On some devices, you can select this value only for entire ports.
│ │ +    TRISTATE = 10310  #: High-impedance state. You can select this state only on devices with bidirectional lines. You cannot select this state for dedicated digital output lines. On some devices, you can select this value only for entire ports.
│ │  
│ │  
│ │  class PressureUnits(Enum):
│ │      PASCALS = 10081  #: Pascals.
│ │      POUNDS_PER_SQ_INCH = 15879  #: Pounds per square inch.
│ │      BAR = 15880  #: Bar.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ @@ -553,18 +510,18 @@
│ │      C_SERIES_MODULE = 14659  #: C Series I/O module.
│ │      SCXI_MODULE = 14660  #: SCXI module.
│ │      SCC_CONNECTOR_BLOCK = 14704  #: SCC Connector Block.
│ │      SCC_MODULE = 14705  #: SCC Module.
│ │      NIELVIS = 14755  #: NI ELVIS.
│ │      NETWORK_DAQ = 14829  #: Network DAQ.
│ │      SC_EXPRESS = 15886  #: SC Express.
│ │ -    UNKNOWN = 12588  #: Unknown category.
│ │      FIELD_DAQ = 16151  #: FieldDAQ.
│ │      TEST_SCALE_CHASSIS = 16180  #: TestScale chassis.
│ │      TEST_SCALE_MODULE = 16181  #: TestScale I/O module.
│ │ +    UNKNOWN = 12588  #: Unknown category.
│ │  
│ │  
│ │  class RTDType(Enum):
│ │      PT_3750 = 12481  #: Pt3750.
│ │      PT_3851 = 10071  #: Pt3851.
│ │      PT_3911 = 12482  #: Pt3911.
│ │      PT_3916 = 10069  #: Pt3916.
│ │ @@ -593,50 +550,35 @@
│ │  
│ │  
│ │  class RegenerationMode(Enum):
│ │      ALLOW_REGENERATION = 10097  #: Allow NI-DAQmx to regenerate samples that the device previously generated. When you choose this value, the write marker returns to the beginning of the buffer after the device generates all samples currently in the buffer.
│ │      DONT_ALLOW_REGENERATION = 10158  #: Do not allow NI-DAQmx to regenerate samples the device previously generated. When you choose this value, NI-DAQmx waits for you to write more samples to the buffer or until the timeout expires.
│ │  
│ │  
│ │ -class RelayPosition(Enum):
│ │ -    OPEN = 10437
│ │ -    CLOSED = 10438
│ │ -
│ │ -
│ │  class ResistanceConfiguration(Enum):
│ │      TWO_WIRE = 2  #: 2-wire mode.
│ │      THREE_WIRE = 3  #: 3-wire mode.
│ │      FOUR_WIRE = 4  #: 4-wire mode.
│ │  
│ │  
│ │  class ResistanceUnits(Enum):
│ │      OHMS = 10384  #: Ohms.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │      FROM_TEDS = 12516  #: Units defined by TEDS information associated with the channel.
│ │  
│ │  
│ │  class ResistorState(Enum):
│ │ -    PULL_UP = 15950  #: pull up state for pull up/pull down resistors
│ │ -    PULL_DOWN = 15951  #: pull down state for pull up pull down resistors
│ │ +    PULL_UP = 15950  #: Pull up.
│ │ +    PULL_DOWN = 15951  #: Pull down.
│ │  
│ │  
│ │  class ResolutionType(Enum):
│ │      BITS = 10109  #: Bits.
│ │  
│ │  
│ │ -class SCXI1124Range(Enum):
│ │ -    ZERO_TO_ONE_V = 14629
│ │ -    ZERO_TO_FIVE_V = 14630
│ │ -    ZERO_TO_TEN_V = 14631
│ │ -    NEG_1_TO_1_V = 14632
│ │ -    NEG_5_TO_5_V = 14633
│ │ -    NEG_10_TO_10_V = 14634
│ │ -    ZERO_TO_TWENTY_M_A = 14635
│ │ -
│ │ -
│ │  class SampClkOverrunBehavior(Enum):
│ │      REPEAT_LAST_SAMPLE = 16062  #: Repeat the last sample.
│ │      RETURN_SENTINEL_VALUE = 16063  #: Return the sentinel value.
│ │  
│ │  
│ │  class SampleInputDataWhen(Enum):
│ │      HANDSHAKE_TRIGGER_ASSERTS = 12552  #: Latch data when the Handshake Trigger asserts.
│ │ @@ -646,31 +588,26 @@
│ │  class SampleTimingType(Enum):
│ │      SAMPLE_CLOCK = 10388  #: Acquire or generate samples on the specified edge of the sample clock.
│ │      BURST_HANDSHAKE = 12548  #: Determine sample timing using burst handshaking between the device and a peripheral device.
│ │      HANDSHAKE = 10389  #: Determine sample timing by using digital handshaking between the device and a peripheral device.
│ │      IMPLICIT = 10451  #: Configure only the duration of the task.
│ │      ON_DEMAND = 10390  #: Acquire or generate a sample on each read or write operation. This timing type is also referred to as static or software-timed.
│ │      CHANGE_DETECTION = 12504  #: Acquire samples when a change occurs in the state of one or more digital input lines. The lines must be contained within a digital input channel.
│ │ -    PIPELINED_SAMPLE_CLOCK = 14668  #: Device acquires or generates samples on each sample clock edge, but does not respond to certain triggers until a few sample clock edges later. Pipelining allows higher data transfer rates at the cost of increased trigger response latency.  Refer to the device documentation for information about which triggers pipelining affects. This timing type allows handshaking with some devices using the Pause trigger, the Ready for Transfer event, or the Data Active event. Refer to the device documentation for more information.
│ │ +    PIPELINED_SAMPLE_CLOCK = 14668  #: Device acquires or generates samples on each sample clock edge, but does not respond to certain triggers until a few sample clock edges later. Pipelining allows higher data transfer rates at the cost of increased trigger response latency. Refer to the device documentation for information about which triggers pipelining affects. This timing type allows handshaking with some devices using the Pause trigger, the Ready for Transfer event, or the Data Active event. Refer to the device documentation for more information.
│ │  
│ │  
│ │  class ScaleType(Enum):
│ │      LINEAR = 10447  #: Scale values by using the equation y=mx+b, where x is a prescaled value and y is a scaled value.
│ │      MAP_RANGES = 10448  #: Scale values proportionally from a range of pre-scaled values to a range of scaled values.
│ │      POLYNOMIAL = 10449  #: Scale values by using an Nth order polynomial equation.
│ │      TABLE = 10450  #: Map a list of pre-scaled values to a list of corresponding scaled values, with all other values scaled proportionally.
│ │      NONE = 10230  #: Do not scale electrical values to physical units.
│ │      TWO_POINT_LINEAR = 15898  #: You provide two pairs of electrical values and their corresponding physical values. NI-DAQmx uses those values to calculate the slope and y-intercept of a linear equation and uses that equation to scale electrical values to physical values.
│ │  
│ │  
│ │ -class ScanRepeatMode(Enum):
│ │ -    FINITE = 10172  #: The task advances through the scan list one time only. NI-DAQmx ignores any Advance Triggers after completing the scan list.
│ │ -    CONTINUOUS = 10117  #: The task returns to the beginning of the scan list when it reaches the end of the scan list.
│ │ -
│ │ -
│ │  class Sense(Enum):
│ │      LOCAL = 16095  #: Local.
│ │      REMOTE = 16096  #: Remote.
│ │  
│ │  
│ │  class SensorPowerCfg(Enum):
│ │      NO_CHANGE = 10160  #: Sensor power supply configuration is not changed.
│ │ @@ -686,27 +623,14 @@
│ │  
│ │  class ShuntCalSelect(Enum):
│ │      A = 12513  #: Switch A.
│ │      B = 12514  #: Switch B.
│ │      AAND_B = 12515  #: Switches A and B.
│ │  
│ │  
│ │ -class ShuntElementLocation(Enum):
│ │ -    R_1 = 12465
│ │ -    R_2 = 12466
│ │ -    R_3 = 12467
│ │ -    R_4 = 14813
│ │ -    NONE = 10230
│ │ -
│ │ -
│ │ -class ShuntResistorSelect(Enum):
│ │ -    A = 12513  #: A
│ │ -    B = 12514  #: B
│ │ -
│ │ -
│ │  class Signal(Enum):
│ │      AI_CONVERT_CLOCK = 12484
│ │      TEN_MHZ_REF_CLOCK = 12536
│ │      TWENTY_MHZ_TIMEBASE_CLOCK = 12486
│ │      SAMPLE_CLOCK = 12487  #: Timed Loop executes on each active edge of the Sample Clock.
│ │      ADVANCE_TRIGGER = 12488
│ │      REFERENCE_TRIGGER = 12490
│ │ @@ -725,18 +649,14 @@
│ │  
│ │  
│ │  class Slope(Enum):
│ │      RISING = 10280  #: Trigger on the rising slope of the signal.
│ │      FALLING = 10171  #: Trigger on the falling slope of the signal.
│ │  
│ │  
│ │ -class SoftwareTrigger(Enum):
│ │ -    ADVANCE_TRIGGER = 12488  #: Place holder enum to make editting internal enum easier.
│ │ -
│ │ -
│ │  class SoundPressureUnits(Enum):
│ │      PA = 10081  #: Pascals.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │  
│ │  
│ │  class SourceSelection(Enum):
│ │      INTERNAL = 10200  #: Internal to the device.
│ │ @@ -771,20 +691,14 @@
│ │  
│ │  
│ │  class StrainUnits(Enum):
│ │      STRAIN = 10299  #: Strain.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │  
│ │  
│ │ -class SwitchChannelUsage(Enum):
│ │ -    SOURCE_CHANNEL = 10439  #: You can use the channel only as an input for a signal.
│ │ -    LOAD_CHANNEL = 10440  #: You can use the channel only as the output for a signal passing through the switch.
│ │ -    RESERVED_FOR_ROUTING_CHANNEL = 10441  #: You can use the channel only to complete routes within a switch.
│ │ -
│ │ -
│ │  class SyncPulseType(Enum):
│ │      ONBOARD = 16128  #: Use the synchronization pulse type specified by the device.
│ │      DIGITAL_EDGE = 10150  #: Digital Edge synchronization.
│ │      TIME = 15996  #: Time synchronization.
│ │  
│ │  
│ │  class SyncType(Enum):
│ │ @@ -809,36 +723,28 @@
│ │      TASK_VERIFY = 2  #: Verify
│ │      TASK_COMMIT = 3  #: Commit
│ │      TASK_RESERVE = 4  #: Reserve
│ │      TASK_UNRESERVE = 5  #: Unreserve
│ │      TASK_ABORT = 6  #: Abort
│ │  
│ │  
│ │ -class TaskState(Enum):
│ │ -    VERIFY = 2
│ │ -    RESERVE = 4
│ │ -    COMMIT = 3
│ │ -    UNRESERVE = 5
│ │ -    ABORT = 6
│ │ -
│ │ -
│ │  class TemperatureUnits(Enum):
│ │      DEG_C = 10143  #: Degrees Celsius.
│ │      DEG_F = 10144  #: Degrees Fahrenheit.
│ │      K = 10325  #: Kelvins.
│ │      DEG_R = 10145  #: Degrees Rankine.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │  
│ │  
│ │  class TerminalConfiguration(Enum):
│ │ -    DEFAULT = -1  #: Default.
│ │      RSE = 10083  #: Referenced Single-Ended.
│ │      NRSE = 10078  #: Non-Referenced Single-Ended.
│ │      DIFF = 10106  #: Differential.
│ │      PSEUDO_DIFF = 12529  #: Pseudodifferential.
│ │ +    DEFAULT = -1  #: Default.
│ │  
│ │  
│ │  class ThermocoupleType(Enum):
│ │      J = 10072  #: J-type thermocouple.
│ │      K = 10073  #: K-type thermocouple.
│ │      N = 10077  #: N-type thermocouple.
│ │      R = 10082  #: R-type thermocouple.
│ │ @@ -846,16 +752,16 @@
│ │      T = 10086  #: T-type thermocouple.
│ │      B = 10047  #: B-type thermocouple.
│ │      E = 10055  #: E-type thermocouple.
│ │  
│ │  
│ │  class TimeUnits(Enum):
│ │      SECONDS = 10364  #: Seconds.
│ │ -    TICKS = 10304  #: Timebase ticks.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │ +    TICKS = 10304  #: Timebase ticks.
│ │  
│ │  
│ │  class Timescale(Enum):
│ │      USE_HOST = 16126  #: Use the host device.
│ │      USE_IO_DEVICE = 16127  #: Use the I/O device.
│ │  
│ │  
│ │ @@ -864,31 +770,32 @@
│ │      REFERENCE_TRIGGER = 12490  #: Reference Trigger timestamp.
│ │      ARM_START_TRIGGER = 14641  #: Arm Start Trigger timestamp.
│ │      FIRST_SAMPLE = 16130  #: First Sample timestamp.
│ │  
│ │  
│ │  class TorqueUnits(Enum):
│ │      NEWTON_METERS = 15881  #: Newton meters.
│ │ -    FOOT_POUNDS = 15884  #: Pound-feet.
│ │ -    INCH_POUNDS = 15883  #: Pound-inches.
│ │      INCH_OUNCES = 15882  #: Ounce-inches.
│ │ +    INCH_POUNDS = 15883  #: Pound-inches.
│ │ +    FOOT_POUNDS = 15884  #: Pound-feet.
│ │      FROM_CUSTOM_SCALE = 10065  #: Units a custom scale specifies. If you select this value, you must specify a custom scale name.
│ │  
│ │  
│ │  class TriggerType(Enum):
│ │ -    NONE = 10230  #: Disable reference triggering for the task.
│ │ +    ANALOG_EDGE = 10099  #: Trigger when an analog signal signal crosses a threshold.
│ │ +    ANALOG_MULTI_EDGE = 16108  #: Trigger when any of the configured analog signals cross their respective thresholds.
│ │ +    DIGITAL_EDGE = 10150  #: Trigger on the rising or falling edge of a digital signal.
│ │ +    DIGITAL_PATTERN = 10398  #: Trigger when digital physical channels match a digital pattern.
│ │ +    ANALOG_WINDOW = 10103  #: Trigger when an analog signal enters or leaves a range of values. The range is in the units of the measurement.
│ │ +    TIME = 15996  #: Trigger when a specified time is reached.
│ │ +    NONE = 10230  #: Disable triggering for the task.
│ │ +    SOFTWARE = 10292  #: Advance to the next entry in a scan list when you call DAQmxSendSoftwareTrigger().
│ │      ANALOG_LEVEL = 10101  #: Pause the measurement or generation while an analog signal is above or below a level.
│ │ -    ANALOG_WINDOW = 10103  #: Trigger when an analog signal enters or leaves a range of values.
│ │ -    DIGITAL_EDGE = 10150  #: Trigger on a rising or falling edge of a digital pulse.
│ │      DIGITAL_LEVEL = 10152  #: Pause the measurement or generation while a digital signal is at either a high or low state.
│ │ -    DIGITAL_PATTERN = 10398  #: Pause the measurement or generation while digital physical channels either match or do not match a digital pattern.
│ │ -    ANALOG_EDGE = 10099  #: Trigger when an analog signal crosses a threshold.
│ │ -    ANALOG_MULTI_EDGE = 16108  #: Trigger when any of the configured analog signals cross their respective thresholds.
│ │      INTERLOCKED = 12549  #: Use the Handshake Trigger as a control signal for asynchronous handshaking, such as 8255 handshaking.
│ │ -    TIME = 15996  #: Trigger when a specified time is reached.
│ │  
│ │  
│ │  class TriggerUsage(Enum):
│ │      ADVANCE = 12488  #: Advance trigger.
│ │      PAUSE = 12489  #: Pause trigger.
│ │      REFERENCE = 12490  #: Reference trigger.
│ │      START = 12491  #: Start trigger.
│ │ @@ -925,81 +832,81 @@
│ │      INCHES_PER_SECOND_SQUARED = 12471  #: Inches per second per second.
│ │      METERS_PER_SECOND = 15959  #: Meters per second.
│ │      INCHES_PER_SECOND = 15960  #: Inches per second.
│ │      PA = 10081  #: Pascals.
│ │      NEWTONS = 15875  #: Newtons.
│ │      POUNDS = 15876  #: Pounds.
│ │      KILOGRAM_FORCE = 15877  #: Kilograms-force.
│ │ -    BAR = 15880  #: Bar.
│ │      POUNDS_PER_SQ_INCH = 15879  #: Pounds per square inch.
│ │ +    BAR = 15880  #: Bar.
│ │      NEWTON_METERS = 15881  #: Newton meters.
│ │      INCH_OUNCES = 15882  #: Ounce-inches.
│ │      INCH_POUNDS = 15883  #: Pound-inches.
│ │      FOOT_POUNDS = 15884  #: Pound-feet.
│ │      VOLTS_PER_VOLT = 15896  #: Volts per volt.
│ │      MILLIVOLTS_PER_VOLT = 15897  #: Millivolts per volt.
│ │      COULOMBS = 16102  #: Coulombs.
│ │      PICO_COULOMBS = 16103  #: PicoCoulombs.
│ │      FROM_TEDS = 12516  #: Units defined by TEDS information associated with the channel.
│ │  
│ │  
│ │  class UsageTypeAI(Enum):
│ │      VOLTAGE = 10322  #: Voltage measurement.
│ │      VOLTAGE_ACRMS = 10350  #: Voltage RMS measurement.
│ │ -    VOLTAGE_CUSTOM_WITH_EXCITATION = 10323  #: Voltage measurement with an excitation source. You can use this measurement type for custom sensors that require excitation, but you must use a custom scale to scale the measured voltage.
│ │      CURRENT = 10134  #: Current measurement.
│ │      CURRENT_ACRMS = 10351  #: Current RMS measurement.
│ │ +    VOLTAGE_CUSTOM_WITH_EXCITATION = 10323  #: Voltage measurement with an excitation source. You can use this measurement type for custom sensors that require excitation, but you must use a custom scale to scale the measured voltage.
│ │ +    BRIDGE = 15908  #: Measure voltage ratios from a Wheatstone bridge.
│ │      FREQUENCY_VOLTAGE = 10181  #: Frequency measurement using a frequency to voltage converter.
│ │      RESISTANCE = 10278  #: Resistance measurement.
│ │      TEMPERATURE_THERMOCOUPLE = 10303  #: Temperature measurement using a thermocouple.
│ │      TEMPERATURE_THERMISTOR = 10302  #: Temperature measurement using a thermistor.
│ │ -    TEMPERATURE_BUILT_IN_SENSOR = 10311  #: Temperature measurement using a built-in sensor on a terminal block or device. On SCXI modules, for example, this could be the CJC sensor.
│ │      TEMPERATURE_RTD = 10301  #: Temperature measurement using an RTD.
│ │ +    TEMPERATURE_BUILT_IN_SENSOR = 10311  #: Temperature measurement using a built-in sensor on a terminal block or device. On SCXI modules, for example, this could be the CJC sensor.
│ │ +    STRAIN_STRAIN_GAGE = 10300  #: Strain measurement.
│ │ +    ROSETTE_STRAIN_GAGE = 15980  #: Strain measurement using a rosette strain gage.
│ │      POSITION_LINEAR_LVDT = 10352  #: Position measurement using an LVDT.
│ │      POSITION_ANGULAR_RVDT = 10353  #: Position measurement using an RVDT.
│ │      POSITION_EDDY_CURRENT_PROX_PROBE = 14835  #: Position measurement using an eddy current proximity probe.
│ │ -    SOUND_PRESSURE_MICROPHONE = 10354  #: Sound pressure measurement using a microphone.
│ │ -    STRAIN_STRAIN_GAGE = 10300  #: Strain measurement.
│ │ -    ROSETTE_STRAIN_GAGE = 15980  #: Strain measurement using a rosette strain gage.
│ │      ACCELERATION_ACCELEROMETER_CURRENT_INPUT = 10356  #: Acceleration measurement using an accelerometer.
│ │      ACCELERATION_CHARGE = 16104  #: Acceleration measurement using a charge-based sensor.
│ │      ACCELERATION_4_WIRE_DC_VOLTAGE = 16106  #: Acceleration measurement using a 4 wire DC voltage based sensor.
│ │      VELOCITY_IEPE_SENSOR = 15966  #: Velocity measurement using an IEPE Sensor.
│ │ -    FORCE_IEPE_SENSOR = 15895  #: Force measurement using an IEPE Sensor.
│ │      FORCE_BRIDGE = 15899  #: Force measurement using a bridge-based sensor.
│ │ -    BRIDGE = 15908  #: Measure voltage ratios from a Wheatstone bridge.
│ │ -    TORQUE_BRIDGE = 15905  #: Torque measurement using a bridge-based sensor.
│ │ +    FORCE_IEPE_SENSOR = 15895  #: Force measurement using an IEPE Sensor.
│ │      PRESSURE_BRIDGE = 15902  #: Pressure measurement using a bridge-based sensor.
│ │ +    SOUND_PRESSURE_MICROPHONE = 10354  #: Sound pressure measurement using a microphone.
│ │ +    TORQUE_BRIDGE = 15905  #: Torque measurement using a bridge-based sensor.
│ │      TEDS = 12531  #: Measurement type defined by TEDS.
│ │      CHARGE = 16105  #: Charge measurement.
│ │      POWER = 16201  #: Power source and measurement.
│ │  
│ │  
│ │  class UsageTypeAO(Enum):
│ │      VOLTAGE = 10322  #: Voltage generation.
│ │      CURRENT = 10134  #: Current generation.
│ │      FUNCTION_GENERATION = 14750  #: Function generation.
│ │  
│ │  
│ │  class UsageTypeCI(Enum):
│ │ +    COUNT_EDGES = 10125  #: Count edges of a digital signal.
│ │      FREQUENCY = 10179  #: Measure the frequency of a digital signal.
│ │      PERIOD = 10256  #: Measure the period of a digital signal.
│ │      PULSE_WIDTH_DIGITAL = 10359  #: Measure the width of a pulse of a digital signal.
│ │ -    PULSE_WIDTH_DIGITAL_TWO_EDGE_SEPARATION = 10267  #: Measure time between edges of two digital signals.
│ │      PULSE_WIDTH_DIGITAL_SEMI_PERIOD = 10289  #: Measure the time between state transitions of a digital signal.
│ │      PULSE_FREQ = 15864  #: Pulse measurement, returning the result as frequency and duty cycle.
│ │      PULSE_TIME = 15865  #: Pulse measurement, returning the result as high time and low time.
│ │      PULSE_TICKS = 15866  #: Pulse measurement, returning the result as high ticks and low ticks.
│ │ -    COUNT_EDGES = 10125  #: Count edges of a digital signal.
│ │ +    DUTY_CYCLE = 16070  #: Measure the duty cycle of a digital signal.
│ │      POSITION_ANGULAR_ENCODER = 10360  #: Angular position measurement using an angular encoder.
│ │      POSITION_LINEAR_ENCODER = 10361  #: Linear position measurement using a linear encoder.
│ │ -    TIME_GPS = 10362  #: Timestamp measurement, synchronizing the counter to a GPS receiver.
│ │ -    DUTY_CYCLE = 16070  #: Measure the duty cycle of a digital signal.
│ │      VELOCITY_ANGULAR_ENCODER = 16078  #: Angular velocity measurement using an angular encoder.
│ │      VELOCITY_LINEAR_ENCODER = 16079  #: Linear velocity measurement using a linear encoder.
│ │ +    PULSE_WIDTH_DIGITAL_TWO_EDGE_SEPARATION = 10267  #: Measure time between edges of two digital signals.
│ │ +    TIME_GPS = 10362  #: Timestamp measurement, synchronizing the counter to a GPS receiver.
│ │  
│ │  
│ │  class UsageTypeCO(Enum):
│ │      PULSE_TIME = 10269  #: Generate pulses defined by the time the pulse is at a low state and the time the pulse is at a high state.
│ │      PULSE_FREQUENCY = 10119  #: Generate digital pulses defined by frequency and duty cycle.
│ │      PULSE_TICKS = 10268  #: Generate digital pulses defined by the number of timebase ticks that the pulse is at a low state and the number of timebase ticks that the pulse is at a high state.
│ │  
│ │ @@ -1041,50 +948,35 @@
│ │  
│ │  class WatchdogCOExpirState(Enum):
│ │      LOW = 10214  #: Low logic.
│ │      HIGH = 10192  #: High logic.
│ │      NO_CHANGE = 10160  #: Expiration does not affect the state of the counter output. The channels retain their states at the time of the watchdog timer expiration, and no further counter generation runs.
│ │  
│ │  
│ │ -class WatchdogTaskAction(Enum):
│ │ -    RESET_TIMER = 0
│ │ -    CLEAR_EXPIRATION = 1
│ │ -
│ │ -
│ │ -class WaveformAttributes(Enum):
│ │ -    SAMPLES_ONLY = 10287  #: Return only samples.
│ │ -    SAMPLES_AND_TIMING = 10140  #: Return the samples and timing information.
│ │ -    SAMPLES_TIMING_AND_ATTRIBUTES = 10141  #: Return the samples, timing information, and other attributes, such as the name of the channel.
│ │ -
│ │ -
│ │  class WindowTriggerCondition1(Enum):
│ │      ENTERING_WINDOW = 10163  #: Trigger when the signal enters the window.
│ │      LEAVING_WINDOW = 10208  #: Trigger when the signal leaves the window.
│ │  
│ │  
│ │  class WindowTriggerCondition2(Enum):
│ │      INSIDE_WINDOW = 10199  #: Pause the measurement or generation while the trigger is inside the window.
│ │      OUTSIDE_WINDOW = 10251  #: Pause the measurement or generation while the signal is outside the window.
│ │  
│ │  
│ │  class WriteBasicTEDSOptions(Enum):
│ │ -    WRITE_TO_EEPROM = 12538  #: blah
│ │ -    WRITE_TO_PROM = 12539  #: blah
│ │ -    DO_NOT_WRITE = 12540  #: blah
│ │ +    WRITE_TO_EEPROM = 12538  #: Write basic TEDS data to the EEPROM, even if the sensor includes a PROM. You cannot write basic TEDS data if the PROM contains data.
│ │ +    WRITE_TO_PROM = 12539  #: Write basic TEDS data to the PROM. Any subsequent attempts to write basic TEDS data result in an error.
│ │ +    DO_NOT_WRITE = 12540  #: Ignore basic TEDS data.
│ │  
│ │  
│ │  class WriteRelativeTo(Enum):
│ │      FIRST_SAMPLE = 10424  #: Write samples relative to the first sample.
│ │      CURRENT_WRITE_POSITION = 10430  #: Write samples relative to the current position in the buffer.
│ │  
│ │  
│ │ -class _Callback(Enum):
│ │ -    SYNCHRONOUS_EVENT_CALLBACKS = 1  #: Synchronous callbacks
│ │ -
│ │ -
│ │  class _CouplingTypes(Enum):
│ │      AC = 1  #: Device supports AC coupling
│ │      DC = 2  #: Device supports DC coupling
│ │      GND = 4  #: Device supports ground coupling
│ │      HF_REJECT = 8  #: Device supports High Frequency Reject coupling
│ │      LF_REJECT = 16  #: Device supports Low Frequency Reject coupling
│ │      NOISE_REJECT = 32  #: Device supports Noise Reject coupling
│ │ @@ -1106,7 +998,9 @@
│ │  class _TriggerUsageTypes(Enum):
│ │      ADVANCE = 1  #: Device supports advance triggers
│ │      PAUSE = 2  #: Device supports pause triggers
│ │      REFERENCE = 4  #: Device supports reference triggers
│ │      START = 8  #: Device supports start triggers
│ │      HANDSHAKE = 16  #: Device supports handshake triggers
│ │      ARM_START = 32  #: Device supports arm start triggers
│ │ +
│ │ +
│ │   --- nidaqmx-0.6.5/nidaqmx/error_codes.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/error_codes.py
│ │┄ Files 0% similar despite different names
│ │ @@ -2,14 +2,16 @@
│ │  
│ │  from enum import IntEnum
│ │  
│ │  __all__ = ['DAQmxErrors', 'DAQmxWarnings']
│ │  
│ │  
│ │  class DAQmxErrors(IntEnum):
│ │ +    REMOTE_SENSE = -209888
│ │ +    OVER_TEMPERATURE_PROTECTION_ACTIVATED = -209887
│ │      MULTI_TASK_CFG_SAMP_RATE_NOT_SUPPORTED_WITH_PROP_SET = -209886
│ │      MULTI_TASK_CFG_SAMP_RATE_CONFLICTING_PROP = -209885
│ │      NO_COMMON_SAMP_RATE_FOUND_NO_REPEAT_SAMPS = -209884
│ │      NO_COMMON_SAMP_RATE_FOUND = -209883
│ │      MULTI_TASK_CFG_DOES_NOT_SUPPORT_MULTI_DEV_TASK = -209882
│ │      MULTI_TASK_SAMP_RATE_CFG_NOT_SUPPORTED = -209881
│ │      DEBUG_SESSION_NOT_ALLOWED_TIMING_SOURCE_REGISTERED = -209880
│ │   --- nidaqmx-0.6.5/nidaqmx/errors.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/errors.py
│ │┄ Files 9% similar despite different names
│ │ @@ -20,17 +20,17 @@
│ │      def __init__(self, message, error_code, task_name=''):
│ │          """
│ │          Args:
│ │              message (string): Specifies the error message.
│ │              error_code (int): Specifies the NI-DAQmx error code.
│ │          """
│ │          if task_name:
│ │ -            message = '{0}\n\nTask Name: {1}'.format(message, task_name)
│ │ +            message = f'{message}\n\nTask Name: {task_name}'
│ │  
│ │ -        super(DaqError, self).__init__(message)
│ │ +        super().__init__(message)
│ │  
│ │          self._error_code = int(error_code)
│ │  
│ │          try:
│ │              self._error_type = DAQmxErrors(self._error_code)
│ │          except ValueError:
│ │              self._error_type = DAQmxErrors.UNKNOWN
│ │ @@ -59,17 +59,17 @@
│ │      def __init__(self, message, error_code, samps_per_chan_read, task_name=''):
│ │          """
│ │          Args:
│ │              message (string): Specifies the error message.
│ │              error_code (int): Specifies the NI-DAQmx error code.
│ │          """
│ │          if task_name:
│ │ -            message = '{0}\n\nTask Name: {1}'.format(message, task_name)
│ │ +            message = f'{message}\n\nTask Name: {task_name}'
│ │  
│ │ -        super(DaqReadError, self).__init__(message, error_code, task_name)
│ │ +        super().__init__(message, error_code, task_name)
│ │  
│ │          self._error_code = int(error_code)
│ │          self._samps_per_chan_read = samps_per_chan_read
│ │  
│ │          try:
│ │              self._error_type = DAQmxErrors(self._error_code)
│ │          except ValueError:
│ │ @@ -92,17 +92,17 @@
│ │          """
│ │          Args:
│ │              message (string): Specifies the error message.
│ │              error_code (int): Specifies the NI-DAQmx error code.
│ │              samps_per_chan_written (int): Specifies the number of samples written.
│ │          """
│ │          if task_name:
│ │ -            message = '{0}\n\nTask Name: {1}'.format(message, task_name)
│ │ +            message = f'{message}\n\nTask Name: {task_name}'
│ │  
│ │ -        super(DaqWriteError, self).__init__(message, error_code, task_name)
│ │ +        super().__init__(message, error_code, task_name)
│ │  
│ │          self._error_code = int(error_code)
│ │          self._samps_per_chan_written = samps_per_chan_written
│ │  
│ │          try:
│ │              self._error_type = DAQmxErrors(self._error_code)
│ │          except ValueError:
│ │ @@ -123,16 +123,16 @@
│ │      """
│ │      def __init__(self, message, error_code):
│ │          """
│ │          Args:
│ │              message (string): Specifies the warning message.
│ │              error_code (int): Specifies the NI-DAQmx error code.
│ │          """
│ │ -        super(DaqWarning, self).__init__(
│ │ -            '\nWarning {0} occurred.\n\n{1}'.format(error_code, message))
│ │ +        super().__init__(
│ │ +            f'\nWarning {error_code} occurred.\n\n{message}')
│ │  
│ │          self._error_code = int(error_code)
│ │  
│ │          try:
│ │              self._error_type = DAQmxWarnings(self._error_code)
│ │          except ValueError:
│ │              self._error_type = DAQmxWarnings.UNKNOWN
│ │ @@ -149,28 +149,15 @@
│ │          """
│ │          :class:`nidaqmx.error_codes.DAQmxWarnings`: Specifies the NI-DAQmx 
│ │              error type.
│ │          """
│ │          return self._error_type
│ │  
│ │  
│ │ -class _ResourceWarning(Warning):
│ │ -    """
│ │ -    Resource warning raised by any NI-DAQmx method.
│ │ -
│ │ -    Used in place of built-in ResourceWarning to allow Python 2.7 support.
│ │ -    """
│ │ -    pass
│ │ -
│ │ -
│ │ -# If ResourceWarning is in exceptions, it is also in the built-in namespace.
│ │ -try:
│ │ -    DaqResourceWarning = ResourceWarning
│ │ -except NameError:
│ │ -    DaqResourceWarning = _ResourceWarning
│ │ +DaqResourceWarning = ResourceWarning
│ │  
│ │  warnings.filterwarnings("always", category=DaqWarning)
│ │  warnings.filterwarnings("always", category=DaqResourceWarning)
│ │  
│ │  
│ │  def check_for_error(error_code, samps_per_chan_written=None, samps_per_chan_read=None):
│ │      if not error_code:
│ │   --- nidaqmx-0.6.5/nidaqmx/scale.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/scale.py
│ │┄ Files 0% similar despite different names
│ │ @@ -8,15 +8,15 @@
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.constants import (
│ │      ScaleType, UnitsPreScaled, _Save)
│ │  
│ │  __all__ = ['Scale']
│ │  
│ │  
│ │ -class Scale(object):
│ │ +class Scale:
│ │      """
│ │      Represents a DAQmx scale.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │  
│ │      def __init__(self, name):
│ │          """
│ │ @@ -33,15 +33,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'Scale(name={0})'.format(self._name)
│ │ +        return f'Scale(name={self._name})'
│ │  
│ │      @property
│ │      def name(self):
│ │          """
│ │          str: Specifies the name of this scale.
│ │          """
│ │          return self._name
│ │   --- nidaqmx-0.6.5/nidaqmx/stream_readers.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/stream_readers.py
│ │┄ Files 0% similar despite different names
│ │ @@ -17,15 +17,15 @@
│ │  
│ │  __all__ = ['AnalogSingleChannelReader', 'AnalogMultiChannelReader',
│ │             'AnalogUnscaledReader', 'CounterReader',
│ │             'DigitalSingleChannelReader', 'DigitalMultiChannelReader',
│ │             'PowerSingleChannelReader', 'PowerMultiChannelReader', 'PowerBinaryReader']
│ │  
│ │  
│ │ -class ChannelReaderBase(object):
│ │ +class ChannelReaderBase:
│ │      """
│ │      Defines base class for all NI-DAQmx stream readers.
│ │      """
│ │  
│ │      def __init__(self, task_in_stream):
│ │          """
│ │          Args:
│ │ @@ -91,16 +91,16 @@
│ │          if array_shape is not None and data.shape != array_shape:
│ │              raise DaqError(
│ │                  'Read cannot be performed because the NumPy array passed into '
│ │                  'this function is not shaped correctly. You must pass in a '
│ │                  'NumPy array of the correct shape based on the number of '
│ │                  'channels in task and the number of samples per channel '
│ │                  'requested.\n\n'
│ │ -                'Shape of NumPy Array provided: {0}\n'
│ │ -                'Shape of NumPy Array required: {1}'
│ │ +                'Shape of NumPy Array provided: {}\n'
│ │ +                'Shape of NumPy Array required: {}'
│ │                  .format(data.shape, array_shape),
│ │                  DAQmxErrors.UNKNOWN, task_name=self._task.name)
│ │  
│ │      def _verify_array_digital_lines(
│ │              self, data, is_many_chan, is_many_line):
│ │          """
│ │          Verifies that the shape of the specified NumPy array can be used
│ │ @@ -135,16 +135,16 @@
│ │          if array_shape is not None and data.shape != array_shape:
│ │              raise DaqError(
│ │                  'Read cannot be performed because the NumPy array passed into '
│ │                  'this function is not shaped correctly. You must pass in a '
│ │                  'NumPy array of the correct shape based on the number of '
│ │                  'channels in task and the number of digital lines per '
│ │                  'channel.\n\n'
│ │ -                'Shape of NumPy Array provided: {0}\n'
│ │ -                'Shape of NumPy Array required: {1}'
│ │ +                'Shape of NumPy Array provided: {}\n'
│ │ +                'Shape of NumPy Array required: {}'
│ │                  .format(data.shape, array_shape),
│ │                  DAQmxErrors.UNKNOWN, task_name=self._task.name)
│ │  
│ │  
│ │  class AnalogSingleChannelReader(ChannelReaderBase):
│ │      """
│ │      Reads samples from an analog input channel in an NI-DAQmx task.
│ │   --- nidaqmx-0.6.5/nidaqmx/stream_writers.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/stream_writers.py
│ │┄ Files 1% similar despite different names
│ │ @@ -10,24 +10,24 @@
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  
│ │  __all__ = ['AnalogSingleChannelWriter', 'AnalogMultiChannelWriter',
│ │             'AnalogUnscaledWriter', 'CounterWriter',
│ │             'DigitalSingleChannelWriter', 'DigitalMultiChannelWriter']
│ │  
│ │  
│ │ -class UnsetAutoStartSentinel(object):
│ │ +class UnsetAutoStartSentinel:
│ │      pass
│ │  
│ │  
│ │  AUTO_START_UNSET = UnsetAutoStartSentinel()
│ │  
│ │  del UnsetAutoStartSentinel
│ │  
│ │  
│ │ -class ChannelWriterBase(object):
│ │ +class ChannelWriterBase:
│ │      """
│ │      Defines base class for all NI-DAQmx stream writers.
│ │      """
│ │  
│ │      def __init__(self, task_out_stream, auto_start=AUTO_START_UNSET):
│ │          """
│ │          Args:
│ │ @@ -176,16 +176,16 @@
│ │              self, num_dimensions_expected, num_dimensions_in_data):
│ │          if num_dimensions_expected != num_dimensions_in_data:
│ │              raise DaqError(
│ │                  'Write cannot be performed because the NumPy array passed '
│ │                  'into this function is not shaped correctly. '
│ │                  'You must pass in a NumPy array of the correct number of '
│ │                  'dimensions based on the write method you use.\n\n'
│ │ -                'No. of dimensions of NumPy Array provided: {0}\n'
│ │ -                'No. of dimensions of NumPy Array required: {1}'
│ │ +                'No. of dimensions of NumPy Array provided: {}\n'
│ │ +                'No. of dimensions of NumPy Array required: {}'
│ │                  .format(num_dimensions_in_data, num_dimensions_expected),
│ │                  DAQmxErrors.UNKNOWN, task_name=self._task.name)
│ │  
│ │  
│ │  class AnalogSingleChannelWriter(ChannelWriterBase):
│ │      """
│ │      Writes samples to an analog output channel in an NI-DAQmx task.
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_collections/device_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_collections/device_collection.py
│ │┄ Files 2% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, DaqError)
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  from nidaqmx.system.device import Device
│ │ @@ -15,15 +14,15 @@
│ │      Contains the collection of devices for a DAQmx system.
│ │      
│ │      This class defines methods that implements a container object.
│ │      """
│ │      def __contains__(self, item):
│ │          device_names = self.device_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │              return all([i in device_names for i in items])
│ │          elif isinstance(item, Device):
│ │              return item.name in device_names
│ │          return False
│ │  
│ │      def __eq__(self, other):
│ │ @@ -47,26 +46,26 @@
│ │                  - slice: Range of the indexes/positions of devices in the
│ │                      collection.
│ │          Returns:
│ │              List[nidaqmx.system.device.Device]: 
│ │              
│ │              Indicates the subset of devices indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              return Device(self.device_names[index])
│ │          elif isinstance(index, slice):
│ │              return [Device(name) for name in self.device_names[index]]
│ │ -        elif isinstance(index, six.string_types):
│ │ +        elif isinstance(index, str):
│ │              device_names = unflatten_channel_string(index)
│ │              if len(device_names) == 1:
│ │                  return Device(device_names[0])
│ │              return [Device(name) for name in device_names]
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access collection.'
│ │ +                'Invalid index type "{}" used to access collection.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __iter__(self):
│ │          for device_name in self.device_names:
│ │              yield Device(device_name)
│ │  
│ │      def __len__(self):
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_channel_collection.py
│ │┄ Files 3% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, DaqError)
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  from nidaqmx.system.storage.persisted_channel import PersistedChannel
│ │ @@ -15,15 +14,15 @@
│ │      Contains the collection of global channels for a DAQmx system.
│ │      
│ │      This class defines methods that implements a container object.
│ │      """
│ │      def __contains__(self, item):
│ │          channel_names = self.global_channel_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │              return all([i in channel_names for i in items])
│ │          elif isinstance(item, PersistedChannel):
│ │              return item._name in channel_names
│ │  
│ │      def __eq__(self, other):
│ │          if isinstance(other, self.__class__):
│ │ @@ -48,27 +47,27 @@
│ │                  - slice: Range of the indexes/positions of global
│ │                      channels in the collection.
│ │          Returns:
│ │              List[nidaqmx.system.storage.persisted_channel.PersistedChannel]:
│ │              
│ │              Indicates the of global channels indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              return PersistedChannel(self.global_channel_names[index])
│ │          elif isinstance(index, slice):
│ │              return [PersistedChannel(name) for name in
│ │                      self.global_channel_names[index]]
│ │ -        elif isinstance(index, six.string_types):
│ │ +        elif isinstance(index, str):
│ │              names = unflatten_channel_string(index)
│ │              if len(names) == 1:
│ │                  return PersistedChannel(names[0])
│ │              return [PersistedChannel(name) for name in names]
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access collection.'
│ │ +                'Invalid index type "{}" used to access collection.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __iter__(self):
│ │          for channel_name in self.global_channel_names:
│ │              yield PersistedChannel(channel_name)
│ │  
│ │      def __len__(self):
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_scale_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_scale_collection.py
│ │┄ Files 6% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, DaqError)
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  from nidaqmx.system.storage.persisted_scale import PersistedScale
│ │ @@ -15,15 +14,15 @@
│ │      Contains the collection of custom scales on a DAQmx system.
│ │      
│ │      This class defines methods that implements a container object.
│ │      """
│ │      def __contains__(self, item):
│ │          scale_names = self.scale_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │              return all([i in scale_names for i in items])
│ │          elif isinstance(item, PersistedScale):
│ │              return item._name in scale_names
│ │  
│ │      def __eq__(self, other):
│ │          if isinstance(other, self.__class__):
│ │ @@ -47,27 +46,27 @@
│ │                  - slice: Range of the indexes/positions of custom scales
│ │                      in the collection.
│ │          Returns:
│ │              List[nidaqmx.system.storage.persisted_scale.PersistedScale]:
│ │              
│ │              Indicates the subset of custom scales indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              return PersistedScale(self.scale_names[index])
│ │          elif isinstance(index, slice):
│ │              return [PersistedScale(name) for name in
│ │                      self.scale_names[index]]
│ │ -        elif isinstance(index, six.string_types):
│ │ +        elif isinstance(index, str):
│ │              names = unflatten_channel_string(index)
│ │              if len(names) == 1:
│ │                  return PersistedScale(names[0])
│ │              return [PersistedScale(name) for name in names]
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access collection.'
│ │ +                'Invalid index type "{}" used to access collection.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __iter__(self):
│ │          for scale_name in self.scale_names:
│ │              yield PersistedScale(scale_name)
│ │  
│ │      def __len__(self):
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_collections/persisted_task_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_collections/persisted_task_collection.py
│ │┄ Files 6% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, DaqError)
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  from nidaqmx.system.storage.persisted_task import PersistedTask
│ │ @@ -15,15 +14,15 @@
│ │      Contains the collection of task saved on a DAQmx system.
│ │      
│ │      This class defines methods that implements a container object.
│ │      """
│ │      def __contains__(self, item):
│ │          task_names = self.task_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │              return all([i in task_names for i in items])
│ │          elif isinstance(item, PersistedTask):
│ │              return item._name in task_names
│ │  
│ │      def __eq__(self, other):
│ │          if isinstance(other, self.__class__):
│ │ @@ -47,27 +46,27 @@
│ │                  - slice: Range of the indexes/positions of saved tasks
│ │                      in the collection.
│ │          Returns:
│ │              List[nidaqmx.system.storage.persisted_task.PersistedTask]:
│ │              
│ │              Indicates the subset of saved tasks indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              return PersistedTask(self.task_names[index])
│ │          elif isinstance(index, slice):
│ │              return [PersistedTask(name) for name in
│ │                      self.task_names[index]]
│ │ -        elif isinstance(index, six.string_types):
│ │ +        elif isinstance(index, str):
│ │              names = unflatten_channel_string(index)
│ │              if len(names) == 1:
│ │                  return PersistedTask(names[0])
│ │              return [PersistedTask(name) for name in names]
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access collection.'
│ │ +                'Invalid index type "{}" used to access collection.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __iter__(self):
│ │          for task_name in self.task_names:
│ │              yield PersistedTask(task_name)
│ │  
│ │      def __len__(self):
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_collections/physical_channel_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_collections/physical_channel_collection.py
│ │┄ Files 2% similar despite different names
│ │ @@ -1,9 +1,8 @@
│ │  import ctypes
│ │ -import six
│ │  from collections.abc import Sequence
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, DaqError)
│ │  from nidaqmx.error_codes import DAQmxErrors
│ │  from nidaqmx.system.physical_channel import PhysicalChannel
│ │ @@ -18,15 +17,15 @@
│ │      """
│ │      def __init__(self, device_name):
│ │          self._name = device_name
│ │  
│ │      def __contains__(self, item):
│ │          channel_names = self.channel_names
│ │  
│ │ -        if isinstance(item, six.string_types):
│ │ +        if isinstance(item, str):
│ │              items = unflatten_channel_string(item)
│ │              return all([i in channel_names for i in items])
│ │          elif isinstance(item, PhysicalChannel):
│ │              return item._name in channel_names
│ │          return False
│ │  
│ │      def __eq__(self, other):
│ │ @@ -53,23 +52,23 @@
│ │                  - slice: Range of the indexes/positions of physical
│ │                      channels in the collection.
│ │          Returns:
│ │              nidaqmx.system.physical_channel.PhysicalChannel: 
│ │              
│ │              Indicates the subset of physical channels indexed.
│ │          """
│ │ -        if isinstance(index, six.integer_types):
│ │ +        if isinstance(index, int):
│ │              return PhysicalChannel(self.channel_names[index])
│ │          elif isinstance(index, slice):
│ │              return PhysicalChannel(self.channel_names[index])
│ │ -        elif isinstance(index, six.string_types):
│ │ -            return PhysicalChannel('{0}/{1}'.format(self._name, index))
│ │ +        elif isinstance(index, str):
│ │ +            return PhysicalChannel(f'{self._name}/{index}')
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access collection.'
│ │ +                'Invalid index type "{}" used to access collection.'
│ │                  .format(type(index)), DAQmxErrors.UNKNOWN)
│ │  
│ │      def __iter__(self):
│ │          for channel_name in self.channel_names:
│ │              yield PhysicalChannel(channel_name)
│ │  
│ │      def __len__(self):
│ │   --- nidaqmx-0.6.5/nidaqmx/system/_watchdog_modules/expiration_states_collection.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/_watchdog_modules/expiration_states_collection.py
│ │┄ Files 15% similar despite different names
│ │ @@ -1,14 +1,12 @@
│ │ -import six
│ │ -
│ │  from nidaqmx.errors import DaqError
│ │  from nidaqmx.system._watchdog_modules.expiration_state import ExpirationState
│ │  
│ │  
│ │ -class ExpirationStatesCollection(object):
│ │ +class ExpirationStatesCollection:
│ │      """
│ │      Contains the collection of expiration states for a DAQmx Watchdog Task.
│ │      
│ │      This class defines methods that implements a container object.
│ │      """
│ │      def __init__(self, task_handle):
│ │          self._handle = task_handle
│ │ @@ -32,13 +30,13 @@
│ │              index (str): Name of the physical channel of which the
│ │                  expiration state to retrieve.
│ │          Returns:
│ │              nidaqmx.system._watchdog_modules.expiration_state.ExpirationState:
│ │              
│ │              The object representing the indexed expiration state.
│ │          """
│ │ -        if isinstance(index, six.string_types):
│ │ +        if isinstance(index, str):
│ │              return ExpirationState(self._handle, index)
│ │          else:
│ │              raise DaqError(
│ │ -                'Invalid index type "{0}" used to access expiration states.'
│ │ +                'Invalid index type "{}" used to access expiration states.'
│ │                  .format(type(index)), -1)
│ │   --- nidaqmx-0.6.5/nidaqmx/system/device.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/device.py
│ │┄ Files 2% similar despite different names
│ │ @@ -1,11 +1,12 @@
│ │  # Do not edit this file; it was automatically generated.
│ │  
│ │  import ctypes
│ │  import numpy
│ │ +import deprecation
│ │  
│ │  from nidaqmx._lib import (
│ │      lib_importer, wrapped_ndpointer, enum_bitfield_to_list, ctypes_byte_str,
│ │      c_bool32)
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  from nidaqmx.utils import unflatten_channel_string
│ │ @@ -17,15 +18,15 @@
│ │      AcquisitionType, BusType, Coupling, FilterType, ProductCategory,
│ │      TriggerUsage, UsageTypeAI, UsageTypeAO, UsageTypeCI, UsageTypeCO,
│ │      _CouplingTypes, _TriggerUsageTypes)
│ │  
│ │  __all__ = ['Device']
│ │  
│ │  
│ │ -class Device(object):
│ │ +class Device:
│ │      """
│ │      Represents a DAQmx device.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │  
│ │      def __init__(self, name):
│ │          """
│ │ @@ -42,15 +43,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'Device(name={0})'.format(self._name)
│ │ +        return f'Device(name={self._name})'
│ │  
│ │      @property
│ │      def name(self):
│ │          """
│ │          str: Specifies the name of this device.
│ │          """
│ │          return self._name
│ │ @@ -1856,55 +1857,14 @@
│ │          error_code = cfunc(
│ │              self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │      @property
│ │ -    def dev_is_simulated(self):
│ │ -        """
│ │ -        bool: Indicates if the device is a simulated device.
│ │ -        """
│ │ -        val = c_bool32()
│ │ -
│ │ -        cfunc = lib_importer.windll.DAQmxGetDevIsSimulated
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        ctypes_byte_str, ctypes.POINTER(c_bool32)]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._name, ctypes.byref(val))
│ │ -        check_for_error(error_code)
│ │ -
│ │ -        return val.value
│ │ -
│ │ -    @property
│ │ -    def dev_serial_num(self):
│ │ -        """
│ │ -        int: Indicates the serial number of the device. This value is
│ │ -            zero if the device does not have a serial number.
│ │ -        """
│ │ -        val = ctypes.c_uint()
│ │ -
│ │ -        cfunc = lib_importer.windll.DAQmxGetDevSerialNum
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        ctypes_byte_str, ctypes.POINTER(ctypes.c_uint)]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._name, ctypes.byref(val))
│ │ -        check_for_error(error_code)
│ │ -
│ │ -        return val.value
│ │ -
│ │ -    @property
│ │      def di_max_rate(self):
│ │          """
│ │          float: Indicates the maximum digital input rate of the device.
│ │          """
│ │          val = ctypes.c_double()
│ │  
│ │          cfunc = lib_importer.windll.DAQmxGetDevDIMaxRate
│ │ @@ -2110,14 +2070,54 @@
│ │                  break
│ │  
│ │          check_for_error(size_or_code)
│ │  
│ │          return Device(val.value.decode('ascii'))
│ │  
│ │      @property
│ │ +    def hwteds_supported(self):
│ │ +        """
│ │ +        bool: Indicates whether the device supports hardware TEDS.
│ │ +        """
│ │ +        val = c_bool32()
│ │ +
│ │ +        cfunc = lib_importer.windll.DAQmxGetDevTEDSHWTEDSSupported
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        ctypes_byte_str, ctypes.POINTER(c_bool32)]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._name, ctypes.byref(val))
│ │ +        check_for_error(error_code)
│ │ +
│ │ +        return val.value
│ │ +
│ │ +    @property
│ │ +    def is_simulated(self):
│ │ +        """
│ │ +        bool: Indicates if the device is a simulated device.
│ │ +        """
│ │ +        val = c_bool32()
│ │ +
│ │ +        cfunc = lib_importer.windll.DAQmxGetDevIsSimulated
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        ctypes_byte_str, ctypes.POINTER(c_bool32)]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._name, ctypes.byref(val))
│ │ +        check_for_error(error_code)
│ │ +
│ │ +        return val.value
│ │ +
│ │ +    @property
│ │      def num_dma_chans(self):
│ │          """
│ │          int: Indicates the number of DMA channels on the device.
│ │          """
│ │          val = ctypes.c_uint()
│ │  
│ │          cfunc = lib_importer.windll.DAQmxGetDevNumDMAChans
│ │ @@ -2329,14 +2329,35 @@
│ │          error_code = cfunc(
│ │              self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │      @property
│ │ +    def serial_num(self):
│ │ +        """
│ │ +        int: Indicates the serial number of the device. This value is
│ │ +            zero if the device does not have a serial number.
│ │ +        """
│ │ +        val = ctypes.c_uint()
│ │ +
│ │ +        cfunc = lib_importer.windll.DAQmxGetDevSerialNum
│ │ +        if cfunc.argtypes is None:
│ │ +            with cfunc.arglock:
│ │ +                if cfunc.argtypes is None:
│ │ +                    cfunc.argtypes = [
│ │ +                        ctypes_byte_str, ctypes.POINTER(ctypes.c_uint)]
│ │ +
│ │ +        error_code = cfunc(
│ │ +            self._name, ctypes.byref(val))
│ │ +        check_for_error(error_code)
│ │ +
│ │ +        return val.value
│ │ +
│ │ +    @property
│ │      def tcpip_ethernet_ip(self):
│ │          """
│ │          str: Indicates the IPv4 address of the Ethernet interface in
│ │              dotted decimal format. This property returns 0.0.0.0 if the
│ │              Ethernet interface cannot acquire an address.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetDevTCPIPEthernetIP
│ │ @@ -2429,34 +2450,14 @@
│ │                  break
│ │  
│ │          check_for_error(size_or_code)
│ │  
│ │          return val.value.decode('ascii')
│ │  
│ │      @property
│ │ -    def tedshwteds_supported(self):
│ │ -        """
│ │ -        bool: Indicates whether the device supports hardware TEDS.
│ │ -        """
│ │ -        val = c_bool32()
│ │ -
│ │ -        cfunc = lib_importer.windll.DAQmxGetDevTEDSHWTEDSSupported
│ │ -        if cfunc.argtypes is None:
│ │ -            with cfunc.arglock:
│ │ -                if cfunc.argtypes is None:
│ │ -                    cfunc.argtypes = [
│ │ -                        ctypes_byte_str, ctypes.POINTER(c_bool32)]
│ │ -
│ │ -        error_code = cfunc(
│ │ -            self._name, ctypes.byref(val))
│ │ -        check_for_error(error_code)
│ │ -
│ │ -        return val.value
│ │ -
│ │ -    @property
│ │      def terminals(self):
│ │          """
│ │          List[str]: Indicates a list of all terminals on the device.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetDevTerminals
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │ @@ -2500,14 +2501,29 @@
│ │  
│ │          error_code = cfunc(
│ │              self._name, ctypes.byref(val))
│ │          check_for_error(error_code)
│ │  
│ │          return val.value
│ │  
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use is_simulated instead.")
│ │ +    def dev_is_simulated(self):
│ │ +        return self.is_simulated
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use serial_num instead.")
│ │ +    def dev_serial_num(self):
│ │ +        return self.serial_num
│ │ +
│ │ +    @property
│ │ +    @deprecation.deprecated(deprecated_in="0.7.0", details="Use hwteds_supported instead.")
│ │ +    def tedshwteds_supported(self):
│ │ +        return self.hwteds_supported
│ │ +
│ │      def reset_device(self):
│ │          """
│ │          Immediately aborts all active tasks associated with a device,
│ │          disconnects any routes, and returns the device to an initialized
│ │          state. Aborting a task immediately terminates the currently
│ │          active operation, such as a read or a write. Aborting a task
│ │          puts the task into an unstable but recoverable state. To recover
│ │   --- nidaqmx-0.6.5/nidaqmx/system/physical_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/physical_channel.py
│ │┄ Files 0% similar despite different names
│ │ @@ -13,15 +13,15 @@
│ │      AOPowerUpOutputBehavior, AcquisitionType, SensorPowerType,
│ │      TerminalConfiguration, UsageTypeAI, UsageTypeAO, UsageTypeCI, UsageTypeCO,
│ │      WriteBasicTEDSOptions, _TermCfg)
│ │  
│ │  __all__ = ['PhysicalChannel']
│ │  
│ │  
│ │ -class PhysicalChannel(object):
│ │ +class PhysicalChannel:
│ │      """
│ │      Represents a DAQmx physical channel.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │  
│ │      def __init__(self, name):
│ │          """
│ │ @@ -38,15 +38,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'PhysicalChannel(name={0})'.format(self._name)
│ │ +        return f'PhysicalChannel(name={self._name})'
│ │  
│ │      @property
│ │      def name(self):
│ │          """
│ │          str: Specifies the name of this physical channel.
│ │          """
│ │          return self._name
│ │ @@ -695,15 +695,15 @@
│ │                  break
│ │  
│ │          check_for_error(size_or_code)
│ │  
│ │          return val.tolist()
│ │  
│ │      @property
│ │ -    def ao_power_up_output_types(self):
│ │ +    def ao_supported_power_up_output_types(self):
│ │          """
│ │          List[:class:`nidaqmx.constants.AOPowerUpOutputBehavior`]:
│ │              Indicates the power up output types supported by the
│ │              channel.
│ │          """
│ │          cfunc = (lib_importer.windll.
│ │                   DAQmxGetPhysicalChanAOSupportedPowerUpOutputTypes)
│ │   --- nidaqmx-0.6.5/nidaqmx/system/storage/_alternate_task_constructor.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/storage/_alternate_task_constructor.py
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/nidaqmx/system/storage/persisted_channel.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_channel.py
│ │┄ Files 2% similar despite different names
│ │ @@ -3,15 +3,15 @@
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  
│ │  __all__ = ['PersistedChannel']
│ │  
│ │  
│ │ -class PersistedChannel(object):
│ │ +class PersistedChannel:
│ │      """
│ │      Represents a saved DAQmx global channel.
│ │  
│ │      Use the DAQmx Persisted Channel properties to query information about
│ │      programmatically saved global channels.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │ @@ -31,15 +31,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'PersistedChannel(name={0})'.format(self._name)
│ │ +        return f'PersistedChannel(name={self._name})'
│ │  
│ │      @property
│ │      def author(self):
│ │          """
│ │          str: Indicates the author of the global channel.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetPersistedChanAuthor
│ │   --- nidaqmx-0.6.5/nidaqmx/system/storage/persisted_scale.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_scale.py
│ │┄ Files 2% similar despite different names
│ │ @@ -4,15 +4,15 @@
│ │  from nidaqmx.scale import Scale
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
│ │  
│ │  __all__ = ['PersistedScale']
│ │  
│ │  
│ │ -class PersistedScale(object):
│ │ +class PersistedScale:
│ │      """
│ │      Represents a saved DAQmx custom scale.
│ │  
│ │      Use the DAQmx Persisted Scale properties to query information about
│ │      programmatically saved custom scales.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │ @@ -32,15 +32,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'PersistedScale(name={0})'.format(self._name)
│ │ +        return f'PersistedScale(name={self._name})'
│ │  
│ │      @property
│ │      def author(self):
│ │          """
│ │          str: Indicates the author of the custom scale.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetPersistedScaleAuthor
│ │   --- nidaqmx-0.6.5/nidaqmx/system/storage/persisted_task.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/storage/persisted_task.py
│ │┄ Files 2% similar despite different names
│ │ @@ -3,15 +3,15 @@
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small)
│ │  
│ │  __all__ = ['PersistedTask']
│ │  
│ │  
│ │ -class PersistedTask(object):
│ │ +class PersistedTask:
│ │      """
│ │      Represents a saved DAQmx task.
│ │  
│ │      Use the DAQmx Persisted Task properties to query information about
│ │      programmatically saved tasks.
│ │      """
│ │      __slots__ = ['_name', '__weakref__']
│ │ @@ -31,15 +31,15 @@
│ │      def __hash__(self):
│ │          return hash(self._name)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'PersistedTask(name={0})'.format(self._name)
│ │ +        return f'PersistedTask(name={self._name})'
│ │  
│ │      @property
│ │      def author(self):
│ │          """
│ │          str: Indicates the author of the task.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetPersistedTaskAuthor
│ │   --- nidaqmx-0.6.5/nidaqmx/system/system.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/system.py
│ │┄ Files 1% similar despite different names
│ │ @@ -21,15 +21,15 @@
│ │      SignalModifiers, WAIT_INFINITELY)
│ │  from nidaqmx.types import (
│ │      AOPowerUpState, CDAQSyncConnection, DOPowerUpState, DOResistorPowerUpState)
│ │  
│ │  __all__ = ['System']
│ │  
│ │  
│ │ -class System(object):
│ │ +class System:
│ │      """
│ │      Represents a DAQmx system.
│ │  
│ │      Contains static properties that access tasks, scales, and global channels
│ │      stored in Measurement Automation Explorer (MAX), performs immediate
│ │      operations on DAQ hardware, and creates classes from which you can get
│ │      information about the hardware.
│ │   --- nidaqmx-0.6.5/nidaqmx/system/watchdog.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/system/watchdog.py
│ │┄ Files 1% similar despite different names
│ │ @@ -1,11 +1,12 @@
│ │  # Do not edit this file; it was automatically generated.
│ │  
│ │  import collections
│ │  import ctypes
│ │ +import deprecation
│ │  import numpy
│ │  import warnings
│ │  
│ │  from nidaqmx._lib import (
│ │      lib_importer, wrapped_ndpointer, ctypes_byte_str, c_bool32)
│ │  from nidaqmx.errors import (
│ │      check_for_error, is_string_buffer_too_small, is_array_buffer_too_small,
│ │ @@ -18,15 +19,15 @@
│ │      Edge, TriggerType, WDTTaskAction)
│ │  from nidaqmx.types import (
│ │      AOExpirationState, COExpirationState, DOExpirationState)
│ │  
│ │  __all__ = ['WatchdogTask']
│ │  
│ │  
│ │ -class WatchdogTask(object):
│ │ +class WatchdogTask:
│ │      """
│ │      Represents the watchdog configurations for a DAQmx task.
│ │      """
│ │      def __init__(self, device_name, task_name='', timeout=10):
│ │          """
│ │          Creates and configures a task that controls the watchdog timer of a
│ │          device. The timer activates when you start the task.
│ │ @@ -70,15 +71,15 @@
│ │          # double closes.
│ │          self._saved_name = self.name
│ │          self._expiration_states = ExpirationStatesCollection(self._handle)
│ │  
│ │      def __del__(self):
│ │          if self._handle is not None:
│ │              warnings.warn(
│ │ -                'Task of name "{0}" was not explicitly closed before it was '
│ │ +                'Task of name "{}" was not explicitly closed before it was '
│ │                  'destructed. Resources on the task device may still be '
│ │                  'reserved.'.format(self.name), DaqResourceWarning)
│ │  
│ │      def __enter__(self):
│ │          return self
│ │  
│ │      def __exit__(self, type, value, traceback):
│ │ @@ -585,15 +586,15 @@
│ │  
│ │          If you create a DAQmx Task object within a loop, use this method
│ │          within the loop after you are finished with the task to avoid
│ │          allocating unnecessary memory.
│ │          """
│ │          if self._handle is None:
│ │              warnings.warn(
│ │ -                'Attempted to close NI-DAQmx task of name "{0}" but task was '
│ │ +                'Attempted to close NI-DAQmx task of name "{}" but task was '
│ │                  'already closed.'.format(self._saved_name), DaqResourceWarning)
│ │              return
│ │  
│ │          cfunc = lib_importer.windll.DAQmxClearTask
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │ @@ -659,7 +660,8 @@
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │                      cfunc.argtypes = [lib_importer.task_handle]
│ │  
│ │          error_code = cfunc(self._handle)
│ │          check_for_error(error_code)
│ │ +
│ │   --- nidaqmx-0.6.5/nidaqmx/task.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/task.py
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,9 @@
│ │  import ctypes
│ │  import numpy
│ │ -import six
│ │  import warnings
│ │  
│ │  from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
│ │  from nidaqmx._task_modules.channels.channel import Channel
│ │  from nidaqmx._task_modules.export_signals import ExportSignals
│ │  from nidaqmx._task_modules.in_stream import InStream
│ │  from nidaqmx._task_modules.read_functions import (
│ │ @@ -39,30 +38,30 @@
│ │  from nidaqmx.system.device import Device
│ │  from nidaqmx.types import CtrFreq, CtrTick, CtrTime, PowerMeasurement
│ │  from nidaqmx.utils import unflatten_channel_string, flatten_channel_string
│ │  
│ │  __all__ = ['Task']
│ │  
│ │  
│ │ -class UnsetNumSamplesSentinel(object):
│ │ +class UnsetNumSamplesSentinel:
│ │      pass
│ │  
│ │  
│ │ -class UnsetAutoStartSentinel(object):
│ │ +class UnsetAutoStartSentinel:
│ │      pass
│ │  
│ │  
│ │  NUM_SAMPLES_UNSET = UnsetNumSamplesSentinel()
│ │  AUTO_START_UNSET = UnsetAutoStartSentinel()
│ │  
│ │  del UnsetNumSamplesSentinel
│ │  del UnsetAutoStartSentinel
│ │  
│ │  
│ │ -class Task(object):
│ │ +class Task:
│ │      """
│ │      Represents a DAQmx Task.
│ │      """
│ │  
│ │      def __init__(self, new_task_name=''):
│ │          """
│ │          Creates a DAQmx task.
│ │ @@ -92,15 +91,15 @@
│ │          check_for_error(error_code)
│ │  
│ │          self._initialize(self._handle)
│ │  
│ │      def __del__(self):
│ │          if self._handle:
│ │              warnings.warn(
│ │ -                'Task of name "{0}" was not explicitly closed before it was '
│ │ +                'Task of name "{}" was not explicitly closed before it was '
│ │                  'destructed. Resources on the task device may still be '
│ │                  'reserved.'.format(self._saved_name), DaqResourceWarning)
│ │  
│ │      def __enter__(self):
│ │          return self
│ │  
│ │      def __eq__(self, other):
│ │ @@ -114,15 +113,15 @@
│ │      def __hash__(self):
│ │          return hash(self._handle)
│ │  
│ │      def __ne__(self, other):
│ │          return not self.__eq__(other)
│ │  
│ │      def __repr__(self):
│ │ -        return 'Task(name={0})'.format(self.name)
│ │ +        return f'Task(name={self.name})'
│ │  
│ │      @property
│ │      def name(self):
│ │          """
│ │          str: Indicates the name of the task.
│ │          """
│ │          cfunc = lib_importer.windll.DAQmxGetTaskName
│ │ @@ -451,15 +450,15 @@
│ │  
│ │          If you create a DAQmx Task object within a loop, use this method
│ │          within the loop after you are finished with the task to avoid
│ │          allocating unnecessary memory.
│ │          """
│ │          if self._handle is None:
│ │              warnings.warn(
│ │ -                'Attempted to close NI-DAQmx task of name "{0}" but task was '
│ │ +                'Attempted to close NI-DAQmx task of name "{}" but task was '
│ │                  'already closed.'.format(self._saved_name), DaqResourceWarning)
│ │              return
│ │  
│ │          cfunc = lib_importer.windll.DAQmxClearTask
│ │          if cfunc.argtypes is None:
│ │              with cfunc.arglock:
│ │                  if cfunc.argtypes is None:
│ │ @@ -1118,31 +1117,31 @@
│ │          raise DaqError(
│ │              'Specified read or write operation failed, because the number '
│ │              'of lines in the data for a channel does not match the number '
│ │              'of lines in the channel.\n\n'
│ │              'If you are using boolean data, make sure the array dimension '
│ │              'for lines in the data matches the number of lines in the '
│ │              'channel.\n\n'
│ │ -            'Number of Lines Per Channel in Task: {0}\n'
│ │ -            'Number of Lines Per Channel in Data: {1}'
│ │ +            'Number of Lines Per Channel in Task: {}\n'
│ │ +            'Number of Lines Per Channel in Data: {}'
│ │              .format(num_lines_expected, num_lines_in_data),
│ │              DAQmxErrors.NUM_LINES_MISMATCH_IN_READ_OR_WRITE,
│ │              task_name=self.name)
│ │  
│ │      def _raise_invalid_write_num_chans_error(
│ │              self, number_of_channels, number_of_channels_in_data):
│ │  
│ │          raise DaqError(
│ │              'Write cannot be performed, because the number of channels in the '
│ │              'data does not match the number of channels in the task.\n\n'
│ │              'When writing, supply data for all channels in the task. '
│ │              'Alternatively, modify the task to contain the same number of '
│ │              'channels as the data written.\n\n'
│ │ -            'Number of Channels in Task: {0}\n'
│ │ -            'Number of Channels in Data: {1}'
│ │ +            'Number of Channels in Task: {}\n'
│ │ +            'Number of Channels in Data: {}'
│ │              .format(number_of_channels, number_of_channels_in_data),
│ │              DAQmxErrors.WRITE_NUM_CHANS_MISMATCH, task_name=self.name)
│ │  
│ │      def write(self, data, auto_start=AUTO_START_UNSET, timeout=10.0):
│ │          """
│ │          Writes samples to the task or virtual channels you specify.
│ │  
│ │ @@ -1281,29 +1280,29 @@
│ │              if self.out_stream.do_num_booleans_per_chan == 1:
│ │                  if (not isinstance(element, bool) and
│ │                          not isinstance(element, numpy.bool_)):
│ │                      raise DaqError(
│ │                          'Write failed, because this write method only accepts '
│ │                          'boolean samples when there is one digital line per '
│ │                          'channel in a task.\n\n'
│ │ -                        'Requested sample type: {0}'.format(type(element)),
│ │ +                        'Requested sample type: {}'.format(type(element)),
│ │                          DAQmxErrors.UNKNOWN, task_name=self.name)
│ │  
│ │                  data = numpy.asarray(data, dtype=bool)
│ │                  return _write_digital_lines(
│ │                      self._handle, data, number_of_samples_per_channel,
│ │                      auto_start, timeout)
│ │              else:
│ │ -                if (not isinstance(element, six.integer_types) and
│ │ +                if (not isinstance(element, int) and
│ │                          not isinstance(element, numpy.uint32)):
│ │                      raise DaqError(
│ │                          'Write failed, because this write method only accepts '
│ │                          'unsigned 32-bit integer samples when there are '
│ │                          'multiple digital lines per channel in a task.\n\n'
│ │ -                        'Requested sample type: {0}'.format(type(element)),
│ │ +                        'Requested sample type: {}'.format(type(element)),
│ │                          DAQmxErrors.UNKNOWN, task_name=self.name)
│ │  
│ │                  data = numpy.asarray(data, dtype=numpy.uint32)
│ │                  return _write_digital_u_32(
│ │                      self._handle, data, number_of_samples_per_channel,
│ │                      auto_start, timeout)
│ │   --- nidaqmx-0.6.5/nidaqmx/types.py
│ ├── +++ nidaqmx-0.7.0/generated/nidaqmx/types.py
│ │┄ Files identical despite different names
│ │   --- nidaqmx-0.6.5/pyproject.toml
│ ├── +++ nidaqmx-0.7.0/pyproject.toml
│ │┄ Files 21% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  [tool.poetry]
│ │  name = "nidaqmx"
│ │ -version = "0.6.5"
│ │ +version = "0.7.0"
│ │  license = "MIT"
│ │  description = "NI-DAQmx Python API"
│ │  authors = ["NI <opensource@ni.com>"]
│ │  maintainers = ["Zach Hindes <zach.hindes@ni.com>", "Maxx Boehme <maxx.boehme@ni.com>"]
│ │  readme = "README.rst"
│ │  repository = "https://github.com/ni/nidaqmx-python"
│ │  documentation = "https://nidaqmx-python.readthedocs.io"
│ │ @@ -18,41 +18,55 @@
│ │      "Operating System :: Microsoft :: Windows",
│ │      "Operating System :: POSIX",
│ │      "Programming Language :: Python :: 3",
│ │      "Programming Language :: Python :: 3.7",
│ │      "Programming Language :: Python :: 3.8",
│ │      "Programming Language :: Python :: 3.9",
│ │      "Programming Language :: Python :: 3.10",
│ │ +    "Programming Language :: Python :: 3.11",
│ │      "Programming Language :: Python :: Implementation :: CPython",
│ │      "Programming Language :: Python :: Implementation :: PyPy",
│ │      "Topic :: System :: Hardware :: Hardware Drivers"
│ │  ]
│ │  exclude = ["nidaqmx/tests"]
│ │ +packages = [{ include = "nidaqmx", from = "generated" }]
│ │  
│ │  [tool.poetry.dependencies]
│ │  python = "^3.7"
│ │  numpy = [
│ │ -    {version="^1.20", python = "<3.10"},
│ │ -    # precompiled wheels only available in the 1.22+
│ │ -    {version="^1.22", python = "^3.10"}
│ │ +  # numpy 1.22 dropped support for Python 3.7.
│ │ +  {version=">=1.20,<1.22", python="<3.8"},
│ │ +  {version=">=1.22", python="^3.8"},
│ │  ]
│ │ -six = "^1.16"
│ │ +deprecation = ">=2.1"
│ │  # This functionality was merged into python stdlib beginning in 3.8
│ │ -importlib_metadata = {version="^4.10", python="~3.7"}
│ │ +importlib_metadata = {version="^4.2", python="~3.7"}
│ │  # Documentation, must be in main dependencies (but optional) list for
│ │  # readthedocs integration.
│ │  # See https://github.com/readthedocs/readthedocs.org/issues/4912.
│ │ -Sphinx = {version="^4.4", optional=true}
│ │ +Sphinx = {version="^4.3", optional=true}
│ │  sphinx_rtd_theme = {version="^1.0", optional=true}
│ │  
│ │  [tool.poetry.extras]
│ │  docs = ["sphinx", "sphinx_rtd_theme"]
│ │  
│ │  [tool.poetry.dev-dependencies]
│ │  # Test
│ │ -pytest = "^6.2"
│ │ +pytest = ">=7.2"
│ │ +pytest-cov = ">=4.0"
│ │  pykka = "^3.0"
│ │  tox = "^3.24"
│ │ +click = "^8.1"
│ │ +Mako = "^1.2"
│ │ +ni-python-styleguide = "^0.4"
│ │ +sphinx_rtd_theme = "1.0"
│ │ +
│ │ +[tool.black]
│ │ +line-length = 100
│ │ +extend_exclude = "docs,generated,src/codegen/metadata,src/codegen/templates"
│ │ +
│ │ +[tool.ni-python-styleguide]
│ │ +extend_exclude = "docs,generated,src/codegen/metadata,src/codegen/templates,src/handwritten"
│ │  
│ │  [build-system]
│ │  requires = ["poetry>=1.1.12"]
│ │  build-backend = "poetry.masonry.api"
│ │   --- nidaqmx-0.6.5/README.rst
│ ├── +++ nidaqmx-0.7.0/README.rst
│ │┄ Files 4% similar despite different names
│ │ @@ -28,17 +28,21 @@
│ │  system.
│ │  
│ │  **nidaqmx** supports CPython 3.7+ and PyPy3.
│ │  
│ │  Installation
│ │  ============
│ │  
│ │ -Running **nidaqmx** requires NI-DAQmx or NI-DAQmx Runtime. Visit the
│ │ +Running **nidaqmx** requires NI-DAQmx to be installed. Visit
│ │  `ni.com/downloads <http://www.ni.com/downloads/>`_ to download the latest
│ │ -version of NI-DAQmx.
│ │ +version of NI-DAQmx. None of the recommended **Additional items** are required
│ │ +for **nidaqmx** to function, and they can be removed to minimize installation
│ │ +size. It is recommended you continue to install the **NI Certificates** package
│ │ +to allow your Operating System to trust NI built binaries, improving your
│ │ +software and hardware installation experience.
│ │  
│ │  **nidaqmx** can be installed with `pip <http://pypi.python.org/pypi/pip>`_::
│ │  
│ │    $ python -m pip install nidaqmx
│ │  
│ │  Similar Packages
│ │  ================
│ │ @@ -151,15 +155,15 @@
│ │  
│ │  - Detailed steps on how to reproduce the problem and full traceback, if 
│ │    applicable.
│ │  - The python version used::
│ │  
│ │    $ python -c "import sys; print(sys.version)"
│ │  
│ │ -- The versions of the **nidaqmx**, numpy, six and enum34 packages used::
│ │ +- The versions of the **nidaqmx** and numpy packages used::
│ │  
│ │    $ python -m pip list
│ │  
│ │  - The version of the NI-DAQmx driver used. Follow 
│ │    `this KB article <http://digital.ni.com/express.nsf/bycode/ex8amn>`_ 
│ │    to determine the version of NI-DAQmx you have installed.
│ │  - The operating system and version, for example Windows 7, CentOS 7.2, ...
│ │   --- nidaqmx-0.6.5/setup.py
│ ├── +++ nidaqmx-0.7.0/PKG-INFO
│ │┄ Files 22% similar despite different names
│ │ @@ -1,44 +1,236 @@
│ │ -# -*- coding: utf-8 -*-
│ │ -from setuptools import setup
│ │ +Metadata-Version: 2.1
│ │ +Name: nidaqmx
│ │ +Version: 0.7.0
│ │ +Summary: NI-DAQmx Python API
│ │ +Home-page: https://github.com/ni/nidaqmx-python
│ │ +License: MIT
│ │ +Keywords: nidaqmx,nidaq,daqmx,daq
│ │ +Author: NI
│ │ +Author-email: opensource@ni.com
│ │ +Maintainer: Zach Hindes
│ │ +Maintainer-email: zach.hindes@ni.com
│ │ +Requires-Python: >=3.7,<4.0
│ │ +Classifier: Development Status :: 5 - Production/Stable
│ │ +Classifier: Intended Audience :: Developers
│ │ +Classifier: Intended Audience :: Manufacturing
│ │ +Classifier: Intended Audience :: Science/Research
│ │ +Classifier: License :: OSI Approved :: MIT License
│ │ +Classifier: Operating System :: Microsoft :: Windows
│ │ +Classifier: Operating System :: POSIX
│ │ +Classifier: Programming Language :: Python :: 3
│ │ +Classifier: Programming Language :: Python :: 3.7
│ │ +Classifier: Programming Language :: Python :: 3.8
│ │ +Classifier: Programming Language :: Python :: 3.9
│ │ +Classifier: Programming Language :: Python :: 3.10
│ │ +Classifier: Programming Language :: Python :: 3.11
│ │ +Classifier: Programming Language :: Python :: 3
│ │ +Classifier: Programming Language :: Python :: 3.10
│ │ +Classifier: Programming Language :: Python :: 3.11
│ │ +Classifier: Programming Language :: Python :: 3.7
│ │ +Classifier: Programming Language :: Python :: 3.8
│ │ +Classifier: Programming Language :: Python :: 3.9
│ │ +Classifier: Programming Language :: Python :: Implementation :: CPython
│ │ +Classifier: Programming Language :: Python :: Implementation :: PyPy
│ │ +Classifier: Topic :: System :: Hardware :: Hardware Drivers
│ │ +Provides-Extra: docs
│ │ +Requires-Dist: Sphinx (>=4.3,<5.0) ; extra == "docs"
│ │ +Requires-Dist: deprecation (>=2.1)
│ │ +Requires-Dist: importlib_metadata (>=4.2,<5.0) ; python_version >= "3.7" and python_version < "3.8"
│ │ +Requires-Dist: numpy (>=1.20,<1.22) ; python_version < "3.8"
│ │ +Requires-Dist: numpy (>=1.22) ; python_version >= "3.8" and python_version < "4.0"
│ │ +Requires-Dist: sphinx_rtd_theme (>=1.0,<2.0) ; extra == "docs"
│ │ +Project-URL: Documentation, https://nidaqmx-python.readthedocs.io
│ │ +Project-URL: Repository, https://github.com/ni/nidaqmx-python
│ │ +Description-Content-Type: text/x-rst
│ │ +
│ │ +===========  =================================================================================================================================
│ │ +Info         Contains a Python API for interacting with NI-DAQmx. See `GitHub <https://github.com/ni/nidaqmx-python/>`_ for the latest source.
│ │ +Author       National Instruments
│ │ +===========  =================================================================================================================================
│ │ +
│ │ +About
│ │ +=====
│ │ +
│ │ +The **nidaqmx** package contains an API (Application Programming Interface)
│ │ +for interacting with the NI-DAQmx driver. The package is implemented in Python.
│ │ +The package is implemented as a complex, 
│ │ +highly object-oriented wrapper around the NI-DAQmx C API using the 
│ │ +`ctypes <https://docs.python.org/2/library/ctypes.html>`_ Python library.
│ │ +
│ │ +**nidaqmx** supports all versions of the NI-DAQmx driver that ships with the C
│ │ +API. The C API is included in any version of the driver that supports it. The
│ │ +**nidaqmx** package does not require installation of the C header files.
│ │ +
│ │ +Some functions in the **nidaqmx** package may be unavailable with earlier 
│ │ +versions of the NI-DAQmx driver. Visit the 
│ │ +`ni.com/downloads <http://www.ni.com/downloads/>`_ to upgrade your version of 
│ │ +NI-DAQmx.
│ │ +
│ │ +**nidaqmx** supports Windows and Linux operating systems where the NI-DAQmx
│ │ +driver is supported. Refer to
│ │ +`NI Hardware and Operating System Compatibility <https://www.ni.com/r/hw-support>`_
│ │ +for which versions of the driver support your hardware on a given operating
│ │ +system.
│ │ +
│ │ +**nidaqmx** supports CPython 3.7+ and PyPy3.
│ │ +
│ │ +Installation
│ │ +============
│ │ +
│ │ +Running **nidaqmx** requires NI-DAQmx to be installed. Visit
│ │ +`ni.com/downloads <http://www.ni.com/downloads/>`_ to download the latest
│ │ +version of NI-DAQmx. None of the recommended **Additional items** are required
│ │ +for **nidaqmx** to function, and they can be removed to minimize installation
│ │ +size. It is recommended you continue to install the **NI Certificates** package
│ │ +to allow your Operating System to trust NI built binaries, improving your
│ │ +software and hardware installation experience.
│ │ +
│ │ +**nidaqmx** can be installed with `pip <http://pypi.python.org/pypi/pip>`_::
│ │ +
│ │ +  $ python -m pip install nidaqmx
│ │ +
│ │ +Similar Packages
│ │ +================
│ │ +
│ │ +There are similar packages available that also provide NI-DAQmx functionality in
│ │ +Python:
│ │ +
│ │ +- `daqmx <https://pypi.org/project/daqmx/>`_
│ │ +  (`slightlynybbled/daqmx on GitHub <https://github.com/slightlynybbled/daqmx>`_)
│ │ +  provides an abstraction of NI-DAQmx in the ``ni`` module.
│ │ +
│ │ +- PyLibNIDAQmx (`pearu/pylibnidaqmx on GitHub <https://github.com/pearu/pylibnidaqmx>`_)
│ │ +  provides an abstraction of NI-DAQmx in the ``nidaqmx`` module, which collides
│ │ +  with this package's module name.
│ │ +
│ │ +.. _usage-section:
│ │ +
│ │ +Usage
│ │ +=====
│ │ +The following is a basic example of using an **nidaqmx.task.Task** object. 
│ │ +This example illustrates how the single, dynamic **nidaqmx.task.Task.read** 
│ │ +method returns the appropriate data type.
│ │ +
│ │ +.. code-block:: python
│ │ +
│ │ +  >>> import nidaqmx
│ │ +  >>> with nidaqmx.Task() as task:
│ │ +  ...     task.ai_channels.add_ai_voltage_chan("Dev1/ai0")
│ │ +  ...     task.read()
│ │ +  ...
│ │ +  -0.07476920729381246
│ │ +  >>> with nidaqmx.Task() as task:
│ │ +  ...     task.ai_channels.add_ai_voltage_chan("Dev1/ai0")
│ │ +  ...     task.read(number_of_samples_per_channel=2)
│ │ +  ...
│ │ +  [0.26001373311970705, 0.37796597238117036]
│ │ +  >>> from nidaqmx.constants import LineGrouping
│ │ +  >>> with nidaqmx.Task() as task:
│ │ +  ...     task.di_channels.add_di_chan(
│ │ +  ...         "cDAQ2Mod4/port0/line0:1", line_grouping=LineGrouping.CHAN_PER_LINE)
│ │ +  ...     task.read(number_of_samples_per_channel=2)
│ │ +  ...
│ │ +  [[False, True], [True, True]]
│ │ +
│ │ +A single, dynamic **nidaqmx.task.Task.write** method also exists.
│ │ +
│ │ +.. code-block:: python
│ │ +
│ │ +  >>> import nidaqmx
│ │ +  >>> from nidaqmx.types import CtrTime
│ │ +  >>> with nidaqmx.Task() as task:
│ │ +  ...     task.co_channels.add_co_pulse_chan_time("Dev1/ctr0")
│ │ +  ...     sample = CtrTime(high_time=0.001, low_time=0.001)
│ │ +  ...     task.write(sample)
│ │ +  ...
│ │ +  1
│ │ +  >>> with nidaqmx.Task() as task:
│ │ +  ...     task.ao_channels.add_ao_voltage_chan("Dev1/ao0")
│ │ +  ...     task.write([1.1, 2.2, 3.3, 4.4, 5.5], auto_start=True)
│ │ +  ...
│ │ +  5
│ │ +
│ │ +Consider using the **nidaqmx.stream_readers** and **nidaqmx.stream_writers**
│ │ +classes to increase the performance of your application, which accept pre-allocated
│ │ +NumPy arrays.
│ │ +
│ │ +Following is an example of using an **nidaqmx.system.System** object.
│ │ +
│ │ +.. code-block:: python
│ │ +
│ │ +  >>> import nidaqmx.system
│ │ +  >>> system = nidaqmx.system.System.local()
│ │ +  >>> system.driver_version
│ │ +  DriverVersion(major_version=16L, minor_version=0L, update_version=0L)
│ │ +  >>> for device in system.devices:
│ │ +  ...     print(device)
│ │ +  ...
│ │ +  Device(name=Dev1)
│ │ +  Device(name=Dev2)
│ │ +  Device(name=cDAQ1)
│ │ +  >>> import collections
│ │ +  >>> isinstance(system.devices, collections.Sequence)
│ │ +  True
│ │ +  >>> device = system.devices['Dev1']
│ │ +  >>> device == nidaqmx.system.Device('Dev1')
│ │ +  True
│ │ +  >>> isinstance(device.ai_physical_chans, collections.Sequence)
│ │ +  True
│ │ +  >>> phys_chan = device.ai_physical_chans['ai0']
│ │ +  >>> phys_chan
│ │ +  PhysicalChannel(name=Dev1/ai0)
│ │ +  >>> phys_chan == nidaqmx.system.PhysicalChannel('Dev1/ai0')
│ │ +  True
│ │ +  >>> phys_chan.ai_term_cfgs
│ │ +  [<TerminalConfiguration.RSE: 10083>, <TerminalConfiguration.NRSE: 10078>, <TerminalConfiguration.DIFFERENTIAL: 10106>]
│ │ +  >>> from enum import Enum
│ │ +  >>> isinstance(phys_chan.ai_term_cfgs[0], Enum)
│ │ +  True
│ │ +
│ │ +Bugs / Feature Requests
│ │ +=======================
│ │ +
│ │ +To report a bug or submit a feature request, please use the 
│ │ +`GitHub issues page <https://github.com/ni/nidaqmx-python/issues>`_.
│ │ +
│ │ +Information to Include When Asking for Help
│ │ +-------------------------------------------
│ │ +
│ │ +Please include **all** of the following information when opening an issue:
│ │ +
│ │ +- Detailed steps on how to reproduce the problem and full traceback, if 
│ │ +  applicable.
│ │ +- The python version used::
│ │ +
│ │ +  $ python -c "import sys; print(sys.version)"
│ │ +
│ │ +- The versions of the **nidaqmx** and numpy packages used::
│ │ +
│ │ +  $ python -m pip list
│ │ +
│ │ +- The version of the NI-DAQmx driver used. Follow 
│ │ +  `this KB article <http://digital.ni.com/express.nsf/bycode/ex8amn>`_ 
│ │ +  to determine the version of NI-DAQmx you have installed.
│ │ +- The operating system and version, for example Windows 7, CentOS 7.2, ...
│ │ +
│ │ +Documentation
│ │ +=============
│ │ +
│ │ +Documentation is available `here <http://nidaqmx-python.readthedocs.io>`_.
│ │ +
│ │ +Additional Documentation
│ │ +========================
│ │ +
│ │ +Refer to the `NI-DAQmx Help <http://digital.ni.com/express.nsf/bycode/exagg4>`_ 
│ │ +for API-agnostic information about NI-DAQmx or measurement concepts.
│ │ +
│ │ +NI-DAQmx Help installs only with the full version of NI-DAQmx.
│ │ +
│ │ +License
│ │ +=======
│ │ +
│ │ +**nidaqmx** is licensed under an MIT-style license (see
│ │ +`LICENSE <https://github.com/ni/nidaqmx-python/blob/master/LICENSE>`_).
│ │ +Other incorporated projects may be licensed under different licenses. All
│ │ +licenses allow for non-commercial and commercial use.
│ │  
│ │ -packages = \
│ │ -['nidaqmx',
│ │ - 'nidaqmx._task_modules',
│ │ - 'nidaqmx._task_modules.channels',
│ │ - 'nidaqmx._task_modules.triggering',
│ │ - 'nidaqmx.system',
│ │ - 'nidaqmx.system._collections',
│ │ - 'nidaqmx.system._watchdog_modules',
│ │ - 'nidaqmx.system.storage']
│ │ -
│ │ -package_data = \
│ │ -{'': ['*']}
│ │ -
│ │ -install_requires = \
│ │ -['six>=1.16,<2.0']
│ │ -
│ │ -extras_require = \
│ │ -{':python_version < "3.10"': ['numpy>=1.20,<2.0'],
│ │ - ':python_version >= "3.10" and python_version < "4.0"': ['numpy>=1.22,<2.0'],
│ │ - ':python_version >= "3.7" and python_version < "3.8"': ['importlib_metadata>=4.10,<5.0'],
│ │ - 'docs': ['Sphinx>=4.4,<5.0', 'sphinx_rtd_theme>=1.0,<2.0']}
│ │ -
│ │ -setup_kwargs = {
│ │ -    'name': 'nidaqmx',
│ │ -    'version': '0.6.5',
│ │ -    'description': 'NI-DAQmx Python API',
│ │ -    'long_description': '===========  =================================================================================================================================\nInfo         Contains a Python API for interacting with NI-DAQmx. See `GitHub <https://github.com/ni/nidaqmx-python/>`_ for the latest source.\nAuthor       National Instruments\n===========  =================================================================================================================================\n\nAbout\n=====\n\nThe **nidaqmx** package contains an API (Application Programming Interface)\nfor interacting with the NI-DAQmx driver. The package is implemented in Python.\nThe package is implemented as a complex, \nhighly object-oriented wrapper around the NI-DAQmx C API using the \n`ctypes <https://docs.python.org/2/library/ctypes.html>`_ Python library.\n\n**nidaqmx** supports all versions of the NI-DAQmx driver that ships with the C\nAPI. The C API is included in any version of the driver that supports it. The\n**nidaqmx** package does not require installation of the C header files.\n\nSome functions in the **nidaqmx** package may be unavailable with earlier \nversions of the NI-DAQmx driver. Visit the \n`ni.com/downloads <http://www.ni.com/downloads/>`_ to upgrade your version of \nNI-DAQmx.\n\n**nidaqmx** supports Windows and Linux operating systems where the NI-DAQmx\ndriver is supported. Refer to\n`NI Hardware and Operating System Compatibility <https://www.ni.com/r/hw-support>`_\nfor which versions of the driver support your hardware on a given operating\nsystem.\n\n**nidaqmx** supports CPython 3.7+ and PyPy3.\n\nInstallation\n============\n\nRunning **nidaqmx** requires NI-DAQmx or NI-DAQmx Runtime. Visit the\n`ni.com/downloads <http://www.ni.com/downloads/>`_ to download the latest\nversion of NI-DAQmx.\n\n**nidaqmx** can be installed with `pip <http://pypi.python.org/pypi/pip>`_::\n\n  $ python -m pip install nidaqmx\n\nSimilar Packages\n================\n\nThere are similar packages available that also provide NI-DAQmx functionality in\nPython:\n\n- `daqmx <https://pypi.org/project/daqmx/>`_\n  (`slightlynybbled/daqmx on GitHub <https://github.com/slightlynybbled/daqmx>`_)\n  provides an abstraction of NI-DAQmx in the ``ni`` module.\n\n- PyLibNIDAQmx (`pearu/pylibnidaqmx on GitHub <https://github.com/pearu/pylibnidaqmx>`_)\n  provides an abstraction of NI-DAQmx in the ``nidaqmx`` module, which collides\n  with this package\'s module name.\n\n.. _usage-section:\n\nUsage\n=====\nThe following is a basic example of using an **nidaqmx.task.Task** object. \nThis example illustrates how the single, dynamic **nidaqmx.task.Task.read** \nmethod returns the appropriate data type.\n\n.. code-block:: python\n\n  >>> import nidaqmx\n  >>> with nidaqmx.Task() as task:\n  ...     task.ai_channels.add_ai_voltage_chan("Dev1/ai0")\n  ...     task.read()\n  ...\n  -0.07476920729381246\n  >>> with nidaqmx.Task() as task:\n  ...     task.ai_channels.add_ai_voltage_chan("Dev1/ai0")\n  ...     task.read(number_of_samples_per_channel=2)\n  ...\n  [0.26001373311970705, 0.37796597238117036]\n  >>> from nidaqmx.constants import LineGrouping\n  >>> with nidaqmx.Task() as task:\n  ...     task.di_channels.add_di_chan(\n  ...         "cDAQ2Mod4/port0/line0:1", line_grouping=LineGrouping.CHAN_PER_LINE)\n  ...     task.read(number_of_samples_per_channel=2)\n  ...\n  [[False, True], [True, True]]\n\nA single, dynamic **nidaqmx.task.Task.write** method also exists.\n\n.. code-block:: python\n\n  >>> import nidaqmx\n  >>> from nidaqmx.types import CtrTime\n  >>> with nidaqmx.Task() as task:\n  ...     task.co_channels.add_co_pulse_chan_time("Dev1/ctr0")\n  ...     sample = CtrTime(high_time=0.001, low_time=0.001)\n  ...     task.write(sample)\n  ...\n  1\n  >>> with nidaqmx.Task() as task:\n  ...     task.ao_channels.add_ao_voltage_chan("Dev1/ao0")\n  ...     task.write([1.1, 2.2, 3.3, 4.4, 5.5], auto_start=True)\n  ...\n  5\n\nConsider using the **nidaqmx.stream_readers** and **nidaqmx.stream_writers**\nclasses to increase the performance of your application, which accept pre-allocated\nNumPy arrays.\n\nFollowing is an example of using an **nidaqmx.system.System** object.\n\n.. code-block:: python\n\n  >>> import nidaqmx.system\n  >>> system = nidaqmx.system.System.local()\n  >>> system.driver_version\n  DriverVersion(major_version=16L, minor_version=0L, update_version=0L)\n  >>> for device in system.devices:\n  ...     print(device)\n  ...\n  Device(name=Dev1)\n  Device(name=Dev2)\n  Device(name=cDAQ1)\n  >>> import collections\n  >>> isinstance(system.devices, collections.Sequence)\n  True\n  >>> device = system.devices[\'Dev1\']\n  >>> device == nidaqmx.system.Device(\'Dev1\')\n  True\n  >>> isinstance(device.ai_physical_chans, collections.Sequence)\n  True\n  >>> phys_chan = device.ai_physical_chans[\'ai0\']\n  >>> phys_chan\n  PhysicalChannel(name=Dev1/ai0)\n  >>> phys_chan == nidaqmx.system.PhysicalChannel(\'Dev1/ai0\')\n  True\n  >>> phys_chan.ai_term_cfgs\n  [<TerminalConfiguration.RSE: 10083>, <TerminalConfiguration.NRSE: 10078>, <TerminalConfiguration.DIFFERENTIAL: 10106>]\n  >>> from enum import Enum\n  >>> isinstance(phys_chan.ai_term_cfgs[0], Enum)\n  True\n\nBugs / Feature Requests\n=======================\n\nTo report a bug or submit a feature request, please use the \n`GitHub issues page <https://github.com/ni/nidaqmx-python/issues>`_.\n\nInformation to Include When Asking for Help\n-------------------------------------------\n\nPlease include **all** of the following information when opening an issue:\n\n- Detailed steps on how to reproduce the problem and full traceback, if \n  applicable.\n- The python version used::\n\n  $ python -c "import sys; print(sys.version)"\n\n- The versions of the **nidaqmx**, numpy, six and enum34 packages used::\n\n  $ python -m pip list\n\n- The version of the NI-DAQmx driver used. Follow \n  `this KB article <http://digital.ni.com/express.nsf/bycode/ex8amn>`_ \n  to determine the version of NI-DAQmx you have installed.\n- The operating system and version, for example Windows 7, CentOS 7.2, ...\n\nDocumentation\n=============\n\nDocumentation is available `here <http://nidaqmx-python.readthedocs.io>`_.\n\nAdditional Documentation\n========================\n\nRefer to the `NI-DAQmx Help <http://digital.ni.com/express.nsf/bycode/exagg4>`_ \nfor API-agnostic information about NI-DAQmx or measurement concepts.\n\nNI-DAQmx Help installs only with the full version of NI-DAQmx.\n\nLicense\n=======\n\n**nidaqmx** is licensed under an MIT-style license (see\n`LICENSE <https://github.com/ni/nidaqmx-python/blob/master/LICENSE>`_).\nOther incorporated projects may be licensed under different licenses. All\nlicenses allow for non-commercial and commercial use.\n',
│ │ -    'author': 'NI',
│ │ -    'author_email': 'opensource@ni.com',
│ │ -    'maintainer': 'Zach Hindes',
│ │ -    'maintainer_email': 'zach.hindes@ni.com',
│ │ -    'url': 'https://github.com/ni/nidaqmx-python',
│ │ -    'packages': packages,
│ │ -    'package_data': package_data,
│ │ -    'install_requires': install_requires,
│ │ -    'extras_require': extras_require,
│ │ -    'python_requires': '>=3.7,<4.0',
│ │ -}
│ │ -
│ │ -
│ │ -setup(**setup_kwargs)
