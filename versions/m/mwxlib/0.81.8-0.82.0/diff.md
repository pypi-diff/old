# Comparing `tmp/mwxlib-0.81.8-py3-none-any.whl.zip` & `tmp/mwxlib-0.82.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 160621 bytes, number of entries: 22
+Zip file size: 161376 bytes, number of entries: 22
 -rw-rw-rw-  2.0 fat     2521 b- defN 23-Mar-25 12:55 mwx/__init__.py
 -rw-rw-rw-  2.0 fat    43241 b- defN 23-Mar-27 04:44 mwx/controls.py
--rw-rw-rw-  2.0 fat    72432 b- defN 23-Mar-27 10:09 mwx/framework.py
--rw-rw-rw-  2.0 fat    69542 b- defN 23-Mar-27 04:44 mwx/graphman.py
+-rw-rw-rw-  2.0 fat    72432 b- defN 23-Apr-07 01:41 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69528 b- defN 23-Apr-07 01:41 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    46248 b- defN 23-Feb-21 08:49 mwx/images.py
 -rw-rw-rw-  2.0 fat    36004 b- defN 23-Mar-25 12:55 mwx/matplot2.py
 -rw-rw-rw-  2.0 fat    67727 b- defN 23-Mar-25 13:34 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    27606 b- defN 23-Mar-25 12:55 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   135270 b- defN 23-Mar-27 04:21 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    36280 b- defN 23-Mar-27 04:21 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11264 b- defN 23-Mar-25 12:55 mwx/wxmon.py
--rw-rw-rw-  2.0 fat    19790 b- defN 23-Mar-25 12:55 mwx/wxpdb.py
+-rw-rw-rw-  2.0 fat   137961 b- defN 23-Apr-07 03:19 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    36740 b- defN 23-Apr-05 02:34 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11187 b- defN 23-Apr-07 01:41 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat    19793 b- defN 23-Apr-05 02:34 mwx/wxpdb.py
 -rw-rw-rw-  2.0 fat     5246 b- defN 23-Mar-25 12:54 mwx/wxwil.py
 -rw-rw-rw-  2.0 fat     7398 b- defN 23-Mar-27 10:09 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
--rw-rw-rw-  2.0 fat    16752 b- defN 23-Mar-27 10:09 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-Mar-27 10:12 mwxlib-0.81.8.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-Mar-27 10:12 mwxlib-0.81.8.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Mar-27 10:12 mwxlib-0.81.8.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-Mar-27 10:12 mwxlib-0.81.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1609 b- defN 23-Mar-27 10:12 mwxlib-0.81.8.dist-info/RECORD
-22 files, 608888 bytes uncompressed, 158119 bytes compressed:  74.0%
+-rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-05 02:34 mwx/py/filling.py
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1609 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/RECORD
+22 files, 611993 bytes uncompressed, 158874 bytes compressed:  74.0%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.81.8.dist-info/LICENSE
+Filename: mwxlib-0.82.0.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.81.8.dist-info/METADATA
+Filename: mwxlib-0.82.0.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.81.8.dist-info/WHEEL
+Filename: mwxlib-0.82.0.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.81.8.dist-info/top_level.txt
+Filename: mwxlib-0.82.0.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.81.8.dist-info/RECORD
+Filename: mwxlib-0.82.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.81.8"
+__version__ = "0.82.0"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
```

## mwx/graphman.py

```diff
@@ -439,15 +439,15 @@
                     'focus_set' : [ None, _F(self.loader.select_view, view=self) ],
                   'frame_shown' : [ None, _F(self.update_infobar) ],
                   'S-a pressed' : [ None, _F(self.toggle_infobar) ],
                    'f5 pressed' : [ None, _F(self.refresh) ],
             },
         })
         ## ドロップターゲットを許可する
-        self.SetDropTarget(MyFileDropLoader(self.loader, target=self))
+        self.SetDropTarget(MyFileDropLoader(self, self.loader))
     
     def refresh(self):
         if self.frame:
             self.frame.update_buffer()
             self.draw()
     
     def toggle_infobar(self):
@@ -496,15 +496,15 @@
 class MyFileDropLoader(wx.FileDropTarget):
     """File Drop interface
     
     Args:
         loader : mainframe
         target : target window to drop in, e.g. frame, graph, pane, etc.
     """
-    def __init__(self, loader, target):
+    def __init__(self, target, loader):
         wx.FileDropTarget.__init__(self)
         
         self.target = target
         self.loader = loader
     
     def OnDropFiles(self, x, y, filenames):
         pos = self.target.ScreenPosition + (x,y)
@@ -784,15 +784,15 @@
         self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
         self.Bind(wx.EVT_CLOSE, self.OnClose)
         
         ## Custom Key Bindings
         self.define_key('C-g', self.Quit)
         
         ## Accepts DnD
-        self.SetDropTarget(MyFileDropLoader(self, target=self))
+        self.SetDropTarget(MyFileDropLoader(self, self))
     
     sync_switch = True
     
     def sync(self, a, b):
         """Synchronize b to a."""
         if (self.sync_switch
             and a.frame and b.frame
```

## mwx/nutshell.py

```diff
@@ -25,15 +25,16 @@
 from wx.py import dispatcher
 from wx.py import introspect
 from wx.py import interpreter
 from wx.py.shell import Shell
 from wx.py.editwindow import EditWindow
 
 from .utilus import funcall as _F
-from .utilus import split_words, split_paren, find_modules
+from .utilus import split_words, split_paren
+from .utilus import find_modules, deprecated
 from .framework import CtrlInterface, AuiNotebook, Menu
 
 
 def skip(v):
     v.Skip()
 
 
@@ -171,29 +172,37 @@
             le = self.LineFromPosition(p + evt.Length)
             self.ShowLines(lc, le)
             evt.Skip()
         
         ## This event occurs when lines that are hidden should be made visible.
         self.Bind(stc.EVT_STC_NEEDSHOWN, eof)
         
+        ## Automatically show lines as needed.
+        ## This avoids sending the `EVT_STC_NEEDSHOWN` notification.
+        self.SetAutomaticFold(stc.STC_AUTOMATICFOLD_SHOW)
+        
         ## Keyword(2) setting
         self.SetLexer(stc.STC_LEX_PYTHON)
         self.SetKeyWords(0, ' '.join(keyword.kwlist))
         self.SetKeyWords(1, ' '.join(builtins.__dict__) + ' self this')
         
         ## AutoComp setting
         self.AutoCompSetAutoHide(False)
         self.AutoCompSetIgnoreCase(True)
         ## self.AutoCompSetSeparator(ord('\t')) => gen_autocomp
         self.AutoCompSetMaxWidth(80)
         self.AutoCompSetMaxHeight(10)
         
         ## To prevent @filling crash (Never access to DropTarget)
         ## [BUG 4.1.1] Don't allow DnD of text, file, whatever.
-        self.SetDropTarget(None)
+        ## self.SetDropTarget(None)
+        
+        self.Bind(stc.EVT_STC_START_DRAG, self.OnDrag)
+        self.Bind(stc.EVT_STC_DRAG_OVER, self.OnDragging)
+        self.Bind(stc.EVT_STC_DO_DROP, self.OnDragged)
         
         ## Global style for all languages
         ## wx.Font style
         ##    family : DEFAULT, DECORATIVE, ROMAN, SCRIPT, SWISS, MODERN, TELETYPE
         ##     slant : NORMAL, SLANT, ITALIC
         ##    weight : NORMAL, LIGHT, BOLD
         ## underline : False
@@ -298,14 +307,38 @@
         self.__mark = -1
     
     ## custom constants embedded in stc
     stc.STC_P_WORD3 = 20
     stc.STC_STYLE_CARETLINE = 40
     stc.STC_STYLE_ANNOTATION = 41
     
+    dnd = None
+    dnd_flag = 0 # 1:copy 2:ctrl-pressed
+    
+    def OnDrag(self, evt): #<wx._core.StyledTextEvent>
+        EditorInterface.dnd = evt.EventObject
+        evt.Skip()
+    
+    def OnDragging(self, evt): #<wx._core.StyledTextEvent>
+        if isinstance(self.dnd, Shell):
+            if self.dnd is not evt.EventObject and self.dnd_flag == 1:
+                vk = wx.UIActionSimulator()
+                vk.KeyDown(wx.WXK_CONTROL) # force [C-Ldrag]
+                EditorInterface.dnd_flag += 1
+                def _release():
+                    vk.KeyUp(wx.WXK_CONTROL)
+                    EditorInterface.dnd_flag -= 1
+                wx.CallLater(1000, _release)
+        evt.Skip()
+    
+    def OnDragged(self, evt): #<wx._core.StyledTextEvent>
+        EditorInterface.dnd = None
+        EditorInterface.dnd_flag = 0
+        evt.Skip()
+    
     ## --------------------------------
     ## Marker attributes of the editor
     ## --------------------------------
     marker_names = {
         0: "mark",
         1: "arrow",
         2: "red-arrow",
@@ -321,14 +354,15 @@
             self.MarkerDeleteAll(n)
             self.add_marker(line, n)
         else:
             self.del_marker(n)
     
     def add_marker(self, line, n):
         if self.MarkerAdd(line, n):
+            self.EnsureVisible(line) # expand if folded
             self.handler('{}_set'.format(self.marker_names[n]), line)
     
     def del_marker(self, n):
         line = self.MarkerNext(0, 1<<n)
         if line != -1:
             self.MarkerDeleteAll(n)
             self.handler('{}_unset'.format(self.marker_names[n]), line)
@@ -387,37 +421,39 @@
         return self.__mark
     
     @mark.setter
     def mark(self, v):
         if v != -1:
             self.__mark = v
             ln = self.LineFromPosition(v)
-            self.set_marker(ln, 0)
+            self.set_marker(ln, 0) # [mark_set]
         else:
             del self.mark
     
     @mark.deleter
     def mark(self):
         v = self.__mark
         if v != -1:
             self.__mark = -1
-            self.del_marker(0)
+            self.del_marker(0) # [mark_unset]
     
     def set_mark(self):
         self.mark = self.cpos
     
     def set_pointer(self):
         if self.pointer == self.cline:
             self.pointer = -1 # toggle marker
         else:
             self.pointer = self.cline
     
+    @deprecated
     def goto_mark(self):
         self.goto_marker(0b001)
     
+    @deprecated
     def goto_pointer(self):
         self.goto_marker(0b11000)
     
     def exchange_point_and_mark(self):
         p = self.cpos
         q = self.mark
         if q != -1:
@@ -680,15 +716,16 @@
             self.SetMarginSensitive(2, False)
             self.SetFoldMarginColour(True, 'black')
             self.SetFoldMarginHiColour(True, 'black')
     
     def OnMarginClick(self, evt): #<wx._stc.StyledTextEvent>
         lc = self.LineFromPosition(evt.Position)
         level = self.GetFoldLevel(lc) ^ stc.STC_FOLDLEVELBASE
-        ## `level` indicates indent-header flag or indent-level number
+        ## `level` indicates indent-level number
+        ##                 & indent-header (stc.STC_FOLDLEVELHEADERFLAG)
         if level and evt.Margin == 2:
             self.toggle_fold(lc)
     
     def OnMarginRClick(self, evt): #<wx._stc.StyledTextEvent>
         """Popup context menu."""
         def _Icon(key):
             return wx.ArtProvider.GetBitmap(key, size=(16,16))
@@ -1031,15 +1068,15 @@
         self.__itextlines = []
         for i in range(2):
             self.SetIndicatorCurrent(i)
             self.IndicatorClearRange(0, self.TextLength)
         if text is None:
             text = self.topic_at_caret
         if not text:
-            self.message("- No words")
+            self.message("No words")
             return
         lw = len(text.encode()) # for multi-byte string
         lines = []
         for p in self.search_text(text):
             lines.append(self.LineFromPosition(p))
             for i in range(2):
                 self.SetIndicatorCurrent(i)
@@ -1407,18 +1444,27 @@
             renamed = False
         self.__filename = f
         if renamed:
             self.parent.handler('buffer_filename_set', self)
     
     @property
     def mtdelta(self):
-        """Timestamp delta (for checking external mod)."""
+        """Timestamp delta (for checking external mod).
+        
+        Returns:
+            None : No file
+            = 0  : a file
+            > 0  : a file edited externally
+            < 0  : a url file
+        """
         f = self.filename
         if f and os.path.isfile(f):
             return os.path.getmtime(f) - self.__mtime
+        elif f and re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", f):
+            return -1
     
     def pre_command_hook(self, evt):
         self.parent.handler(self.handler.event, evt)
         return EditorInterface.pre_command_hook(self, evt)
     pre_command_hook.__name__ = str('pre_command_dispatch') # alias
     
     def post_command_hook(self, evt):
@@ -1481,46 +1527,42 @@
         self.set_style(self.STYLE)
     
     def __contains__(self, code):
         if inspect.iscode(code) and self.code:
             return code is self.code\
                 or code in self.code.co_consts
     
-    ## def __str__(self):
-    ##     return "{}:{}".format(self.filename, self.markline+1)
-    
     def trace_position(self):
         text, lp = self.CurLine
         self.message("{:>6d}:{} ({})".format(self.cline, lp, self.cpos), pane=-1)
     
     def OnUpdate(self, evt): #<wx._stc.StyledTextEvent>
         if evt.Updated & (stc.STC_UPDATE_SELECTION | stc.STC_UPDATE_CONTENT):
             self.trace_position()
             self.handler('stc_updated', evt)
         evt.Skip()
     
-    def _set_caption_prefix(self, prefix):
-        if self.mtdelta is not None:
-            caption = '{}{}'.format(prefix, self.name)
-            self.parent.handler('buffer_caps', self, caption)
-    
     def OnSavePointLeft(self, evt):
-        self._set_caption_prefix('* ')
+        if self.mtdelta is not None:
+            prefix = '* ' if self.mtdelta == 0 else '*! '
+            self.parent.handler('buffer_caps', self, prefix + self.name)
         evt.Skip()
     
     def OnSavePointReached(self, evt):
-        self._set_caption_prefix('')
+        if self.mtdelta is not None:
+            prefix = '' if self.mtdelta == 0 else '! '
+            self.parent.handler('buffer_caps', self, prefix + self.name)
         evt.Skip()
     
     def on_activated(self, buf):
         """Called when the buffer is activated."""
-        if self.mtdelta:
-            self._set_caption_prefix('! ')
-            self.message("File: {!r} has been modified externally. "
-                         ## "Please load the file before editing."
+        if self.mtdelta is not None and self.mtdelta > 0:
+            prefix = '! ' if not buf.IsModified() else '*! '
+            self.parent.handler('buffer_caps', self, prefix + self.name)
+            self.message("{!r} has been modified externally."
                          .format(self.filename))
         title = "{} file: {}".format(self.parent.Name, self.filename)
         self.parent.handler('title_window', title)
         self.trace_position()
     
     def on_inactivated(self, buf):
         """Called when the buffer is inactivated."""
@@ -1539,23 +1581,23 @@
     
     def _load_textfile(self, text, filename, lineno=0):
         with self.off_readonly():
             self.Text = text
             self.EmptyUndoBuffer()
             self.SetSavePoint()
         self.markline = lineno - 1
-        self.goto_mark()
+        self.goto_marker(1)
         self.filename = filename
         self.handler('buffer_loaded', self)
     
     def _load_file(self, filename, lineno=0):
         """Wrapped method of LoadFile."""
         if self.LoadFile(filename):
             self.markline = lineno - 1
-            self.goto_mark()
+            self.goto_marker(1)
             self.filename = filename
             self.handler('buffer_loaded', self)
             return True
         return False
     
     def _save_file(self, filename):
         """Wrapped method of SaveFile."""
@@ -1892,14 +1934,22 @@
     
     def need_buffer_save_p(self, buf):
         """Returns whether the buffer should be saved."""
         return buf.mtdelta is not None and buf.IsModified()
     
     def load_url(self, url, *args, **kwargs):
         import requests
+        if wx.MessageBox(
+                "You are loadint URL contents.\n\n"
+               f"{url!r}\n"
+                "Continue loading?",
+                "Load URL",
+                style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
+            self.post_message("The load has been canceled.")
+            return None
         try:
             res = requests.get(url)
         except Exception as e:
             self.post_message("Failed to load URL: {}".format(e))
             return None
         if res.status_code == 200: # success
             buf = self.find_buffer(url) or self.create_buffer(url)
@@ -1952,15 +2002,15 @@
         finally:
             self.Thaw()
     
     def save_file(self, filename, buf=None):
         """Save the current buffer to a file.
         """
         buf = buf or self.buffer
-        if buf.mtdelta:
+        if buf.mtdelta is not None and buf.mtdelta > 0:
             self.swap_page(buf)
             if wx.MessageBox(
                     "The file has been modified externally.\n\n"
                     "The contents of the file will be overwritten.\n"
                     "Continue saving?",
                     "Save {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
@@ -2293,14 +2343,28 @@
             force = wx.GetKeyState(wx.WXK_CONTROL)\
                   & wx.GetKeyState(wx.WXK_SHIFT)
             Nautilus.modules = find_modules(force)
         
         self.Bind(stc.EVT_STC_UPDATEUI, self.OnUpdate) # skip to brace matching
         self.Bind(stc.EVT_STC_CALLTIP_CLICK, self.OnCallTipClick)
         
+        def on_drag(v): #<wx._core.StyledTextEvent>
+            EditorInterface.dnd_flag = (v.Position < self.bolc) # copy
+            v.Skip()
+        self.Bind(stc.EVT_STC_START_DRAG, on_drag)
+        
+        def on_dragging(v): #<wx._core.StyledTextEvent>
+            if v.Position < self.bolc:
+                v.DragResult = wx.DragNone # Don't drop (as readonly)
+            elif self.dnd_flag:
+                v.DragResult = wx.DragCopy # Don't move
+            v.Skip()
+        self.Bind(stc.EVT_STC_DRAG_OVER, on_dragging)
+        self.Bind(stc.EVT_STC_DO_DROP, on_dragging)
+        
         def destroy(v):
             if v.EventObject is self:
                 self.handler('shell_deleted', self)
             v.Skip()
         self.Bind(wx.EVT_WINDOW_DESTROY, destroy)
         
         def activate(v):
```

## mwx/utilus.py

```diff
@@ -430,14 +430,29 @@
     """
     home = os.path.normpath(os.path.expanduser("~/.mwxlib"))
     if not os.path.exists(home):
         os.mkdir(home)
     return os.path.join(home, f)
 
 
+def deprecated(f=None, version="the future", count=1):
+    if f is None:
+        return lambda f: deprecated(f, version, count)
+    @wraps(f)
+    def _f(*args, **kwargs):
+        nonlocal count
+        if count:
+            warnings.warn(
+                f"{f.__name__!r} is deprecated and will be removed in {version}.",
+                DeprecationWarning, stacklevel=2)
+            count -= 1
+        return f(*args, **kwargs)
+    return _f
+
+
 ## --------------------------------
 ## Finite State Machine
 ## --------------------------------
 
 class SSM(dict):
     """Single State Machine/Context of FSM
     """
```

## mwx/wxmon.py

```diff
@@ -195,15 +195,14 @@
         del self.__items[:]
     
     def update(self, evt):
         event = evt.EventType
         obj = evt.EventObject
         name = self.get_name(event)
         source = ew._makeSourceString(obj) + " id=0x{:X}".format(id(evt))
-        ## timestamp = datetime.datetime.now().strftime("%H:%M:%S.%f")[:-4]
         stamp = 1
         
         with warnings.catch_warnings():
             warnings.simplefilter('ignore', DeprecationWarning)
             attribs = ew._makeAttribString(evt)
         
         if wx.VERSION < (4,1,0): # ignore self insert event
```

## mwx/wxpdb.py

```diff
@@ -339,15 +339,15 @@
             self.stamp_marker(ln, 1) # (>>) bp:white-arrow
         
         def _mark():
             buffer = editor.buffer
             if filename == buffer.filename:
                 if code != self.code:
                     buffer.markline = firstlineno - 1 # (o) entry:marker
-                    buffer.goto_mark()
+                    buffer.goto_marker(1)
                     buffer.recenter(3)
                 buffer.goto_line(lineno - 1)
                 buffer.pointer = lineno - 1 # (->) pointer:marker
                 buffer.EnsureLineMoreOnScreen(lineno - 1)
             self.code = code
         wx.CallAfter(_mark)
         self.__interactive = self.interactive_shell.cpos
```

## mwx/py/filling.py

```diff
@@ -94,15 +94,16 @@
 
     def OnItemActivated(self, event):
         """Launch a DirFrame."""
         item = event.GetItem()
         text = self.getFullName(item)
         obj = self.GetItemData(item)
         frame = FillingFrame(parent=None,
-                             size=(600,400), pos=self.ClientToScreen(0,0),
+                             size=self.GrandParent.Size,
+                             pos=self.ClientToScreen(0,0),
                              rootObject=obj, rootLabel=text,
                              rootIsNamespace=False)
         frame.Show()
 
     def objHasChildren(self, obj):
         """Return true if object has children."""
         return type(obj) not in COMMONTYPES
```

## Comparing `mwxlib-0.81.8.dist-info/LICENSE` & `mwxlib-0.82.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.81.8.dist-info/METADATA` & `mwxlib-0.82.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.81.8
+Version: 0.82.0
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

