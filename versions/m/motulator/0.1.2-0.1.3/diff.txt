--- tmp/motulator-0.1.2.tar.gz
+++ tmp/motulator-0.1.3.tar.gz
â”œâ”€â”€ filetype from file(1)
â”‚ @@ -1 +1 @@
â”‚ -gzip compressed data, was "motulator-0.1.2.tar", last modified: Thu Nov 17 19:23:05 2022, max compression
â”‚ +gzip compressed data, was "motulator-0.1.3.tar", last modified: Thu Apr  6 21:26:08 2023, max compression
â”‚   --- motulator-0.1.2.tar
â”œâ”€â”€ +++ motulator-0.1.3.tar
â”‚ â”œâ”€â”€ file list
â”‚ â”‚ @@ -1,36 +1,36 @@
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-17 19:23:05.682012 motulator-0.1.2/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     1078 2022-11-17 19:22:49.000000 motulator-0.1.2/LICENSE
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     7874 2022-11-17 19:23:05.682012 motulator-0.1.2/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     7339 2022-11-17 19:22:49.000000 motulator-0.1.2/README.md
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-17 19:23:05.682012 motulator-0.1.2/motulator/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     2074 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/__init__.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-17 19:23:05.682012 motulator-0.1.2/motulator/control/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)       99 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     9521 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/common.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     8336 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/im_obs_vhz.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)    16011 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/im_vector.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     5733 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/im_vhz.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)    10678 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/sm_flux_vector.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     8048 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/sm_obs_vhz.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     7080 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/sm_signal_inj.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)    21407 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/sm_torque.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)    14229 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/control/sm_vector.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     6802 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/helpers.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-17 19:23:05.682012 motulator-0.1.2/motulator/model/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)      109 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     4092 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/converter.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     6801 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/im.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     9400 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/im_drive.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     4955 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/mech.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)    10082 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/sm.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     6241 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/sm_drive.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     8088 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/model/sm_flux_maps.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     7546 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/plots.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     8377 2022-11-17 19:22:49.000000 motulator-0.1.2/motulator/simulation.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-17 19:23:05.682012 motulator-0.1.2/motulator.egg-info/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)     7874 2022-11-17 19:23:05.000000 motulator-0.1.2/motulator.egg-info/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)      787 2022-11-17 19:23:05.000000 motulator-0.1.2/motulator.egg-info/SOURCES.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)        1 2022-11-17 19:23:05.000000 motulator-0.1.2/motulator.egg-info/dependency_links.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)       10 2022-11-17 19:23:05.000000 motulator-0.1.2/motulator.egg-info/top_level.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)      379 2022-11-17 19:22:49.000000 motulator-0.1.2/pyproject.toml
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (121)      601 2022-11-17 19:23:05.682012 motulator-0.1.2/setup.cfg
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 21:26:08.271854 motulator-0.1.3/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-04-06 21:25:53.000000 motulator-0.1.3/LICENSE
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8471 2023-04-06 21:26:08.275854 motulator-0.1.3/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7936 2023-04-06 21:25:53.000000 motulator-0.1.3/README.md
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 21:26:08.271854 motulator-0.1.3/motulator/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2074 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/__init__.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 21:26:08.271854 motulator-0.1.3/motulator/control/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       99 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    10014 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/common.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8143 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/im_obs_vhz.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    15938 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/im_vector.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5664 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/im_vhz.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7263 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/sm_flux_vector.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     9447 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/sm_obs_vhz.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7021 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/sm_signal_inj.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    19488 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/sm_torque.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    13687 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/control/sm_vector.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6772 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/helpers.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 21:26:08.271854 motulator-0.1.3/motulator/model/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      109 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4071 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/converter.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6881 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/im.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     9364 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/im_drive.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4992 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/mech.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    10079 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/sm.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6194 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/sm_drive.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8057 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/model/sm_flux_maps.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7514 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/plots.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8255 2023-04-06 21:25:53.000000 motulator-0.1.3/motulator/simulation.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 21:26:08.271854 motulator-0.1.3/motulator.egg-info/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8471 2023-04-06 21:26:08.000000 motulator-0.1.3/motulator.egg-info/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-04-06 21:26:08.000000 motulator-0.1.3/motulator.egg-info/SOURCES.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-06 21:26:08.000000 motulator-0.1.3/motulator.egg-info/dependency_links.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       10 2023-04-06 21:26:08.000000 motulator-0.1.3/motulator.egg-info/top_level.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      377 2023-04-06 21:25:53.000000 motulator-0.1.3/pyproject.toml
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      601 2023-04-06 21:26:08.275854 motulator-0.1.3/setup.cfg
â”‚ â”‚   --- motulator-0.1.2/LICENSE
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/LICENSE
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- motulator-0.1.2/PKG-INFO
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/PKG-INFO
â”‚ â”‚â”„ Files 10% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: motulator
â”‚ â”‚ -Version: 0.1.2
â”‚ â”‚ +Version: 0.1.3
â”‚ â”‚  Summary: Motor Drive Simulator in Python
â”‚ â”‚  Home-page: https://github.com/Aalto-Electric-Drives/motulator
â”‚ â”‚  Author: Marko Hinkkanen
â”‚ â”‚  Author-email: marko.hinkkanen@aalto.fi
â”‚ â”‚  Project-URL: Bug Tracker, https://github.com/Aalto-Electric-Drives/motulator/issues
â”‚ â”‚  Classifier: Programming Language :: Python :: 3
â”‚ â”‚  Classifier: License :: OSI Approved :: MIT License
â”‚ â”‚ @@ -71,26 +71,27 @@
â”‚ â”‚  
â”‚ â”‚  <!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
â”‚ â”‚  <!-- prettier-ignore-start -->
â”‚ â”‚  <!-- markdownlint-disable -->
â”‚ â”‚  <table>
â”‚ â”‚    <tbody>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Jialed0303"><img src="https://avatars.githubusercontent.com/u/118135952?v=4?s=50" width="50px;" alt="Jialed0303"/><br /><sub><b>Jialed0303</b></sub></a><br /><a href="#ideas-Jialed0303" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚    </tbody>
â”‚ â”‚  </table>
â”‚ â”‚  
â”‚ â”‚  <!-- markdownlint-restore -->
â”‚ â”‚  <!-- prettier-ignore-end -->
â”‚ â”‚ â”œâ”€â”€ html2text {}
â”‚ â”‚ â”‚ @@ -1,8 +1,8 @@
â”‚ â”‚ â”‚ -Metadata-Version: 2.1 Name: motulator Version: 0.1.2 Summary: Motor Drive
â”‚ â”‚ â”‚ +Metadata-Version: 2.1 Name: motulator Version: 0.1.3 Summary: Motor Drive
â”‚ â”‚ â”‚  Simulator in Python Home-page: https://github.com/Aalto-Electric-Drives/
â”‚ â”‚ â”‚  motulator Author: Marko Hinkkanen Author-email: marko.hinkkanen@aalto.fi
â”‚ â”‚ â”‚  Project-URL: Bug Tracker, https://github.com/Aalto-Electric-Drives/motulator/
â”‚ â”‚ â”‚  issues Classifier: Programming Language :: Python :: 3 Classifier: License ::
â”‚ â”‚ â”‚  OSI Approved :: MIT License Classifier: Operating System :: OS Independent
â”‚ â”‚ â”‚  Requires-Python: >=3.6 Description-Content-Type: text/markdown License-File:
â”‚ â”‚ â”‚  LICENSE # *motulator:* Motor Drive Simulator in Python [![Build Status](https:/
â”‚ â”‚ â”‚ @@ -40,17 +40,17 @@
â”‚ â”‚ â”‚  have a look at these [guidelines](https://github.com/Aalto-Electric-Drives/
â”‚ â”‚ â”‚  motulator/blob/main/CONTRIBUTING.md) first. Contributors ------------ Thanks go
â”‚ â”‚ â”‚  to these wonderful people:
â”‚ â”‚ â”‚                  [Lauri_Tiitinen]                          [HannuHar]              [Marko_Hinkkanen]         [silundbe]      [JoonaKukkonen]  [jarno-  [angelicaiaderosa]
â”‚ â”‚ â”‚                   Lauri_Tiitinen                            HannuHar                Marko_Hinkkanen           silundbe        JoonaKukkonen      k]     angelicaiaderosa
â”‚ â”‚ â”‚             Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ÂŸÂ’Â¡ Ã°ÂŸÂ§Â‘Ã¢Â€         Ã°ÂŸÂ’Â» Ã°ÂŸÂÂ›        Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½jarno-k      Ã°ÂŸÂ’Â» Ã°ÂŸÂ’Â¡
â”‚ â”‚ â”‚                                                                                                                                                 Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚ -                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]
â”‚ â”‚ â”‚ -                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari
â”‚ â”‚ â”‚ -                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£
â”‚ â”‚ â”‚ +                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]       [Jialed0303]
â”‚ â”‚ â”‚ +                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari         Jialed0303
â”‚ â”‚ â”‚ +                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£             Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚     This project follows the [all-contributors](https://github.com/all-
â”‚ â”‚ â”‚  contributors/all-contributors) specification. Contributions of any kind
â”‚ â”‚ â”‚  welcome! Acknowledgement --------------- This project has been sponsored by ABB
â”‚ â”‚ â”‚  Oy and by the Academy of Finland *Centre of Excellence in High-Speed
â”‚ â”‚ â”‚  Electromechanical Energy Conversion Systems*. The example control methods
â”‚ â”‚ â”‚  included in this repository are based on published algorithms (available in
â”‚ â”‚ â”‚  textbooks and scientific articles). They do not present any proprietary control
â”‚ â”‚   --- motulator-0.1.2/README.md
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/README.md
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -56,26 +56,27 @@
â”‚ â”‚  
â”‚ â”‚  <!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
â”‚ â”‚  <!-- prettier-ignore-start -->
â”‚ â”‚  <!-- markdownlint-disable -->
â”‚ â”‚  <table>
â”‚ â”‚    <tbody>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Jialed0303"><img src="https://avatars.githubusercontent.com/u/118135952?v=4?s=50" width="50px;" alt="Jialed0303"/><br /><sub><b>Jialed0303</b></sub></a><br /><a href="#ideas-Jialed0303" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚    </tbody>
â”‚ â”‚  </table>
â”‚ â”‚  
â”‚ â”‚  <!-- markdownlint-restore -->
â”‚ â”‚  <!-- prettier-ignore-end -->
â”‚ â”‚ â”œâ”€â”€ html2text {}
â”‚ â”‚ â”‚ @@ -33,17 +33,17 @@
â”‚ â”‚ â”‚  have a look at these [guidelines](https://github.com/Aalto-Electric-Drives/
â”‚ â”‚ â”‚  motulator/blob/main/CONTRIBUTING.md) first. Contributors ------------ Thanks go
â”‚ â”‚ â”‚  to these wonderful people:
â”‚ â”‚ â”‚                  [Lauri_Tiitinen]                          [HannuHar]              [Marko_Hinkkanen]         [silundbe]      [JoonaKukkonen]  [jarno-  [angelicaiaderosa]
â”‚ â”‚ â”‚                   Lauri_Tiitinen                            HannuHar                Marko_Hinkkanen           silundbe        JoonaKukkonen      k]     angelicaiaderosa
â”‚ â”‚ â”‚             Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ÂŸÂ’Â¡ Ã°ÂŸÂ§Â‘Ã¢Â€         Ã°ÂŸÂ’Â» Ã°ÂŸÂÂ›        Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½jarno-k      Ã°ÂŸÂ’Â» Ã°ÂŸÂ’Â¡
â”‚ â”‚ â”‚                                                                                                                                                 Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚ -                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]
â”‚ â”‚ â”‚ -                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari
â”‚ â”‚ â”‚ -                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£
â”‚ â”‚ â”‚ +                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]       [Jialed0303]
â”‚ â”‚ â”‚ +                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari         Jialed0303
â”‚ â”‚ â”‚ +                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£             Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚     This project follows the [all-contributors](https://github.com/all-
â”‚ â”‚ â”‚  contributors/all-contributors) specification. Contributions of any kind
â”‚ â”‚ â”‚  welcome! Acknowledgement --------------- This project has been sponsored by ABB
â”‚ â”‚ â”‚  Oy and by the Academy of Finland *Centre of Excellence in High-Speed
â”‚ â”‚ â”‚  Electromechanical Energy Conversion Systems*. The example control methods
â”‚ â”‚ â”‚  included in this repository are based on published algorithms (available in
â”‚ â”‚ â”‚  textbooks and scientific articles). They do not present any proprietary control
â”‚ â”‚   --- motulator-0.1.2/motulator/__init__.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/__init__.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- motulator-0.1.2/motulator/control/common.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/common.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Common control functions and classes."""
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  from motulator.helpers import abc2complex, complex2abc, Bunch
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ @@ -196,21 +195,35 @@
â”‚ â”‚      pars : data object
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚ -        self.alpha_s = pars.alpha_s
â”‚ â”‚ -        self.tau_M_max = pars.tau_M_max
â”‚ â”‚ -        self.J = pars.J
â”‚ â”‚ -        # Gain
â”‚ â”‚ -        self.k = pars.alpha_s*pars.J
â”‚ â”‚ +        try:
â”‚ â”‚ +            self.tau_M_max = pars.tau_M_max
â”‚ â”‚ +        except AttributeError:
â”‚ â”‚ +            # No maximum torque limit
â”‚ â”‚ +            self.tau_M_max = np.inf
â”‚ â”‚ +        try:
â”‚ â”‚ +            # Gains for the 2DOF PI controller
â”‚ â”‚ +            self.alpha = pars.alpha_s
â”‚ â”‚ +            self.k_t = pars.alpha_s*pars.J
â”‚ â”‚ +            self.k_p = 2*pars.alpha_s*pars.J
â”‚ â”‚ +        except AttributeError:
â”‚ â”‚ +            # alpha_s or J not defined, try to use k_t, k_p, k_i
â”‚ â”‚ +            try:
â”‚ â”‚ +                self.k_t = pars.k_t
â”‚ â”‚ +                self.k_p = pars.k_p
â”‚ â”‚ +                self.alpha = pars.k_i/pars.k_t
â”‚ â”‚ +            except AttributeError:
â”‚ â”‚ +                print('No speed controller gains found.')
â”‚ â”‚ +
â”‚ â”‚          # Integral state
â”‚ â”‚ -        self.tau_l = 0
â”‚ â”‚ +        self.tau_i = 0
â”‚ â”‚          # Load torque estimate (stored for the update method)
â”‚ â”‚          self.tau_L = 0
â”‚ â”‚  
â”‚ â”‚      def output(self, w_M_ref, w_M):
â”‚ â”‚          """
â”‚ â”‚          Compute the torque reference and the load torque estimate.
â”‚ â”‚  
â”‚ â”‚ @@ -223,16 +236,16 @@
â”‚ â”‚  
â”‚ â”‚          Returns
â”‚ â”‚          -------
â”‚ â”‚          tau_M_ref : float
â”‚ â”‚              Torque reference.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚ -        self.tau_L = self.tau_l - self.alpha_s*self.J*w_M
â”‚ â”‚ -        tau_M_ref = self.k*(w_M_ref - w_M) + self.tau_L
â”‚ â”‚ +        self.tau_L = self.tau_i - (self.k_p - self.k_t)*w_M
â”‚ â”‚ +        tau_M_ref = self.k_t*(w_M_ref - w_M) + self.tau_L
â”‚ â”‚  
â”‚ â”‚          if np.abs(tau_M_ref) > self.tau_M_max:
â”‚ â”‚              tau_M_ref = np.sign(tau_M_ref)*self.tau_M_max
â”‚ â”‚  
â”‚ â”‚          return tau_M_ref
â”‚ â”‚  
â”‚ â”‚      def update(self, tau_M_ref_lim):
â”‚ â”‚ @@ -241,15 +254,15 @@
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚          tau_M_ref_lim : float
â”‚ â”‚              Realized (limited) torque reference.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚ -        self.tau_l += self.T_s*self.alpha_s*(tau_M_ref_lim - self.tau_L)
â”‚ â”‚ +        self.tau_i += self.T_s*self.alpha*(tau_M_ref_lim - self.tau_L)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class RateLimiter:
â”‚ â”‚      """
â”‚ â”‚      Rate limiter.
â”‚ â”‚   --- motulator-0.1.2/motulator/control/im_obs_vhz.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/im_obs_vhz.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,28 +1,25 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Observer-based V/Hz control for induction motor drives.
â”‚ â”‚  
â”‚ â”‚  This implements the observer-based V/Hz control method described in [1]_. The
â”‚ â”‚  state-feedback control law is in the alternative form which uses an
â”‚ â”‚  intermediate stator current reference.
â”‚ â”‚  
â”‚ â”‚  References
â”‚ â”‚  ----------
â”‚ â”‚  .. [1] Tiitinen, Hinkkanen, Harnefors, "Stable and passive observer-based V/Hz
â”‚ â”‚ -    control for induction motors," in Proc. IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚ +    control for induction motors," Proc. IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚ -from collections.abc import Callable
â”‚ â”‚ +from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.control.common import Ctrl, PWM, RateLimiter
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  @dataclass
â”‚ â”‚  class InductionMotorObsVHzCtrlPars:
â”‚ â”‚ @@ -52,15 +49,15 @@
â”‚ â”‚      zeta_inf: float = .7
â”‚ â”‚  
â”‚ â”‚      # Motor parameter estimates (inverse-Î“ model)
â”‚ â”‚      R_s: float = 3.7
â”‚ â”‚      R_R: float = 2.1
â”‚ â”‚      L_sgm: float = .021
â”‚ â”‚      L_M: float = .224
â”‚ â”‚ -    p: int = 2
â”‚ â”‚ +    n_p: int = 2
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class InductionMotorVHzObsCtrl(Ctrl):
â”‚ â”‚      """
â”‚ â”‚      Observer-based V/Hz control for induction motors.
â”‚ â”‚  
â”‚ â”‚ @@ -82,15 +79,15 @@
â”‚ â”‚          self.w_m_ref = pars.w_m_ref
â”‚ â”‚          self.psi_s_ref = pars.psi_s_nom
â”‚ â”‚          # Control Parameters
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.alpha_f = pars.alpha_f
â”‚ â”‚          self.alpha_r = pars.alpha_r
â”‚ â”‚          self.alpha_psi = pars.alpha_psi
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.k_tau = pars.k_tau
â”‚ â”‚          self.i_s_max = pars.i_s_max
â”‚ â”‚          self.slip_compensation = pars.slip_compensation
â”‚ â”‚          # Motor parameters
â”‚ â”‚          self.R_s = pars.R_s
â”‚ â”‚          self.R_R = pars.R_R
â”‚ â”‚          self.L_sgm = pars.L_sgm
â”‚ â”‚ @@ -128,33 +125,33 @@
â”‚ â”‚          # Get the states
â”‚ â”‚          u_s = self.pwm.realized_voltage
â”‚ â”‚          psi_R = self.observer.psi_R
â”‚ â”‚          tau_M_ref = self.tau_M_ref
â”‚ â”‚          w_r_ref = self.w_r_ref
â”‚ â”‚  
â”‚ â”‚          # Torque estimate (11c)
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_s*np.conj(psi_R))
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_s*np.conj(psi_R))
â”‚ â”‚  
â”‚ â”‚          # Slip frequency compensation (if enabled) for the low-pass filter.
â”‚ â”‚          # Note, could also be based on the low-pass filtered torque.
â”‚ â”‚          psi_R_sqr = np.abs(psi_R)**2
â”‚ â”‚          if self.slip_compensation and psi_R_sqr > 0:
â”‚ â”‚ -            w_r = self.R_R*tau_M/(1.5*self.p*psi_R_sqr)
â”‚ â”‚ +            w_r = self.R_R*tau_M/(1.5*self.n_p*psi_R_sqr)
â”‚ â”‚          else:
â”‚ â”‚              w_r = 0
â”‚ â”‚  
â”‚ â”‚          # Slip compensation (9). Uses the low-pass filtered slip estimate
â”‚ â”‚          # w_r_ref. Note if slip compensation disabled w_r_ref == 0.
â”‚ â”‚          w_s_ref = w_m_ref + w_r_ref
â”‚ â”‚  
â”‚ â”‚          # Dynamic frequency (7a)
â”‚ â”‚          w_s = w_s_ref - self.k_tau*(tau_M - tau_M_ref)
â”‚ â”‚  
â”‚ â”‚          # State feedback
â”‚ â”‚ -        u_s_ref, i_s_ref = self.state_feedback(i_s, psi_R, w_s)
â”‚ â”‚ +        u_s_ref = self.state_feedback(i_s, psi_R, w_s)
â”‚ â”‚  
â”‚ â”‚          # Duty ratios
â”‚ â”‚          d_abc_ref, u_s_ref_lim = self.pwm.output(
â”‚ â”‚              u_s_ref, u_dc, self.theta_s, w_s)
â”‚ â”‚  
â”‚ â”‚          # Data logging
â”‚ â”‚          data = Bunch(
â”‚ â”‚ @@ -190,15 +187,15 @@
â”‚ â”‚          # Limit the reference
â”‚ â”‚          if np.abs(i_s_ref) > self.i_s_max:
â”‚ â”‚              i_s_ref = self.i_s_max*i_s_ref/np.abs(i_s_ref)
â”‚ â”‚          # State feedback (6a)
â”‚ â”‚          u_s_ref = (
â”‚ â”‚              self.R_s*i_s_ref + 1j*w_s*self.psi_s_ref +
â”‚ â”‚              self.L_sgm*self.alpha_psi*(i_s_ref - i_s))
â”‚ â”‚ -        return u_s_ref, i_s_ref
â”‚ â”‚ +        return u_s_ref
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class SensorlessFluxObserver:
â”‚ â”‚      """
â”‚ â”‚      Sensorless reduced-order flux observer.
â”‚ â”‚  
â”‚ â”‚ @@ -217,15 +214,15 @@
â”‚ â”‚      .. [1] Hinkkanen, Harnefors, Luomi, "Reduced-order flux observers with
â”‚ â”‚         stator-resistance adaptation for speed-sensorless induction motor
â”‚ â”‚         drives," IEEE Trans. Power Electron., 2010,
â”‚ â”‚         https://doi.org/10.1109/TPEL.2009.2039650
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-many-instance-attributes, too-few-public-methods
â”‚ â”‚ +    # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.R_s = pars.R_s
â”‚ â”‚          self.R_R = pars.R_R
â”‚ â”‚          self.L_sgm = pars.L_sgm
â”‚ â”‚          self.alpha = pars.R_R/pars.L_M
â”‚ â”‚          self.alpha_o = pars.alpha_o
â”‚ â”‚ @@ -247,27 +244,26 @@
â”‚ â”‚              Angular frequency of the reference frame.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Decay rate
â”‚ â”‚          lambd = self.zeta_inf*np.abs(w_s) + .5*self.alpha
â”‚ â”‚          # Observer gain (without the orthogonal projection which is
â”‚ â”‚          # embedded into the state update)
â”‚ â”‚ -        g_o = 2*lambd*(self.alpha + 1j*self.w_m)/(self.alpha**2 + self.w_m**2)
â”‚ â”‚ +        g_o = 2*lambd/(self.alpha - 1j*self.w_m)
â”‚ â”‚  
â”‚ â”‚          # Time derivative of the stator current
â”‚ â”‚          di_s = (i_s - self.i_s_old)/self.T_s
â”‚ â”‚  
â”‚ â”‚          # Error voltage
â”‚ â”‚          e = (
â”‚ â”‚              self.L_sgm*(di_s + 1j*w_s*i_s) + (self.R_s + self.R_R)*i_s -
â”‚ â”‚              (self.alpha - 1j*self.w_m)*self.psi_R - u_s)
â”‚ â”‚  
â”‚ â”‚          # Error signal
â”‚ â”‚ -        psi_R_sqr = np.abs(self.psi_R)**2
â”‚ â”‚ -        err = e*np.conj(self.psi_R)/psi_R_sqr if psi_R_sqr > 0 else 0
â”‚ â”‚ +        err = e/self.psi_R if np.abs(self.psi_R) > 0 else 0
â”‚ â”‚  
â”‚ â”‚          # Update the states
â”‚ â”‚          self.w_m -= self.T_s*self.alpha_o*err.imag
â”‚ â”‚          self.psi_R += self.T_s*(
â”‚ â”‚              u_s - self.R_s*i_s - self.L_sgm*di_s - 1j*w_s*
â”‚ â”‚              (self.psi_R + self.L_sgm*i_s) + g_o*self.psi_R*err.real)
â”‚ â”‚          self.i_s_old = i_s
â”‚ â”‚   --- motulator-0.1.2/motulator/control/im_vector.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/im_vector.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,16 +1,14 @@
â”‚ â”‚ -# pylint: disable=C0103
â”‚ â”‚  """
â”‚ â”‚  Vector control methods for induction motor drives.
â”‚ â”‚  
â”‚ â”‚  The algorithms are written based on the inverse-Î“ model.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚ -from collections.abc import Callable
â”‚ â”‚ +from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚  from motulator.control.common import Ctrl, SpeedCtrl, PWM
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ @@ -40,15 +38,15 @@
â”‚ â”‚      psi_R_nom: float = .9
â”‚ â”‚      u_dc_nom: float = 540
â”‚ â”‚      # Motor parameter estimates (inverse-Î“ model)
â”‚ â”‚      R_s: float = 3.7
â”‚ â”‚      R_R: float = 2.1
â”‚ â”‚      L_sgm: float = .021
â”‚ â”‚      L_M: float = .224
â”‚ â”‚ -    p: int = 2
â”‚ â”‚ +    n_p: int = 2
â”‚ â”‚      J: float = .015
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class InductionMotorVectorCtrl(Ctrl):
â”‚ â”‚      """
â”‚ â”‚      Vector control for an induction motor drive.
â”‚ â”‚ @@ -65,15 +63,15 @@
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          super().__init__()
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.w_m_ref = pars.w_m_ref
â”‚ â”‚          self.sensorless = pars.sensorless
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.speed_ctrl = SpeedCtrl(pars)
â”‚ â”‚          self.current_ref = CurrentRef(pars)
â”‚ â”‚          self.current_ctrl = CurrentCtrl(pars)
â”‚ â”‚          if self.sensorless:
â”‚ â”‚              self.observer = SensorlessObserver(pars)
â”‚ â”‚          else:
â”‚ â”‚              self.observer = Observer(pars)
â”‚ â”‚ @@ -101,28 +99,28 @@
â”‚ â”‚          w_m_ref = self.w_m_ref(self.t)
â”‚ â”‚  
â”‚ â”‚          # Measure the feedback signals
â”‚ â”‚          i_s_abc = mdl.motor.meas_currents()  # Phase currents
â”‚ â”‚          u_dc = mdl.conv.meas_dc_voltage()  # DC-bus voltage
â”‚ â”‚  
â”‚ â”‚          if not self.sensorless:
â”‚ â”‚ -            w_m = self.p*mdl.mech.meas_speed()  # Rotor speed
â”‚ â”‚ +            w_m = self.n_p*mdl.mech.meas_speed()  # Rotor speed
â”‚ â”‚          else:
â”‚ â”‚              w_m = self.observer.w_m  # Get the estimated speed
â”‚ â”‚  
â”‚ â”‚          # Get the states
â”‚ â”‚          u_s = self.pwm.realized_voltage
â”‚ â”‚          psi_R = self.observer.psi_R
â”‚ â”‚          theta_s = self.observer.theta_s
â”‚ â”‚  
â”‚ â”‚          # Space vector and coordinate transformation
â”‚ â”‚          i_s = np.exp(-1j*theta_s)*abc2complex(i_s_abc)
â”‚ â”‚  
â”‚ â”‚          # Outputs
â”‚ â”‚ -        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.p, w_m/self.p)
â”‚ â”‚ +        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.n_p, w_m/self.n_p)
â”‚ â”‚          i_s_ref, tau_M_ref_lim = self.current_ref.output(tau_M_ref, psi_R)
â”‚ â”‚          w_s = self.observer.output(u_s, i_s, w_m)  # w_m not used if sensorless
â”‚ â”‚          u_s_ref = self.current_ctrl.output(i_s_ref, i_s)
â”‚ â”‚          d_abc_ref, u_s_ref_lim = self.pwm.output(u_s_ref, u_dc, theta_s, w_s)
â”‚ â”‚  
â”‚ â”‚          # Save data
â”‚ â”‚          data = Bunch(
â”‚ â”‚ @@ -177,15 +175,15 @@
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.i_s_max = pars.i_s_max
â”‚ â”‚          self.L_sgm = pars.L_sgm
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          # Local parameters for initializing the constants
â”‚ â”‚          psi_R_nom = pars.psi_R_nom
â”‚ â”‚          L_M = pars.L_M
â”‚ â”‚          R_R = pars.R_R
â”‚ â”‚          u_dc_nom = pars.u_dc_nom
â”‚ â”‚          # Nominal d-axis current
â”‚ â”‚          self.i_sd_nom = psi_R_nom/L_M
â”‚ â”‚ @@ -220,26 +218,26 @@
â”‚ â”‚              # Breakdown torque limit
â”‚ â”‚              i_sq_max2 = psi_R/self.L_sgm + i_sd_ref
â”‚ â”‚              # q-axis current limit
â”‚ â”‚              i_sq_max = np.min([i_sq_max1, i_sq_max2])
â”‚ â”‚              return i_sq_max
â”‚ â”‚  
â”‚ â”‚          # q-axis current reference
â”‚ â”‚ -        i_sq_ref = tau_M_ref/(1.5*self.p*psi_R) if psi_R > 0 else 0
â”‚ â”‚ +        i_sq_ref = tau_M_ref/(1.5*self.n_p*psi_R) if psi_R > 0 else 0
â”‚ â”‚  
â”‚ â”‚          # Limit the current
â”‚ â”‚          i_sq_max = q_axis_current_limit(self.i_sd_ref, psi_R)
â”‚ â”‚          if np.abs(i_sq_ref) > i_sq_max:
â”‚ â”‚              i_sq_ref = np.sign(i_sq_ref)*i_sq_max
â”‚ â”‚  
â”‚ â”‚          # Current reference
â”‚ â”‚          i_s_ref = self.i_sd_ref + 1j*i_sq_ref
â”‚ â”‚  
â”‚ â”‚          # Limited torque (for the speed controller)
â”‚ â”‚ -        tau_M_ref_lim = 1.5*self.p*psi_R*i_sq_ref
â”‚ â”‚ +        tau_M_ref_lim = 1.5*self.n_p*psi_R*i_sq_ref
â”‚ â”‚  
â”‚ â”‚          return i_s_ref, tau_M_ref_lim
â”‚ â”‚  
â”‚ â”‚      def update(self, u_s_ref, u_dc):
â”‚ â”‚          """
â”‚ â”‚          Field-weakening based on the unlimited reference voltage.
â”‚ â”‚  
â”‚ â”‚ @@ -403,15 +401,15 @@
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          alpha = self.R_R/self.L_M
â”‚ â”‚  
â”‚ â”‚          # Observer gain (17) with c = w_s**2 (without the orthogonal projection
â”‚ â”‚          # which is embedded into the state update)
â”‚ â”‚          b = alpha + 2*self.zeta_inf*np.abs(self.w_m)
â”‚ â”‚ -        g = b*(alpha + 1j*self.w_m)/(alpha**2 + self.w_m**2)
â”‚ â”‚ +        g = b/(alpha - 1j*self.w_m)
â”‚ â”‚  
â”‚ â”‚          # Induced voltage from stator quantities, cf. (7)
â”‚ â”‚          e_s = u_s - self.R_s*i_s - self.L_sgm*(i_s - self.i_s_old)/self.T_s
â”‚ â”‚          # Induced voltage (8) from the rotor quantities
â”‚ â”‚          e_r = self.R_R*i_s - (alpha - 1j*self.w_m)*self.psi_R
â”‚ â”‚  
â”‚ â”‚          # Angular frequency of the rotor flux vector
â”‚ â”‚   --- motulator-0.1.2/motulator/control/im_vhz.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/im_vhz.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=C0103
â”‚ â”‚  """
â”‚ â”‚  V/Hz control for induction motor drives.
â”‚ â”‚  
â”‚ â”‚  The method is similar to [1]_. Open-loop V/Hz control can be obtained as a
â”‚ â”‚  special case by choosing::
â”‚ â”‚  
â”‚ â”‚      R_s, R_R = 0, 0
â”‚ â”‚ @@ -18,19 +17,17 @@
â”‚ â”‚  ----------
â”‚ â”‚  .. [1] Hinkkanen, Tiitinen, MÃ¶lsÃ¤, Harnefors, "On the stability of
â”‚ â”‚     volts-per-hertz control for induction motors," IEEE J. Emerg. Sel. Topics
â”‚ â”‚     Power Electron., 2022, https://doi.org/10.1109/JESTPE.2021.3060583
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  # %%
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚ -from collections.abc import Callable
â”‚ â”‚ +from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.control.common import Ctrl, PWM, RateLimiter
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  @dataclass
â”‚ â”‚  class InductionMotorVHzCtrlPars:
â”‚ â”‚   --- motulator-0.1.2/motulator/control/sm_flux_vector.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/sm_obs_vhz.py
â”‚ â”‚â”„ Files 10% similar despite different names
â”‚ â”‚ @@ -1,113 +1,100 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚ -Flux-vector control for synchronous motor drives.
â”‚ â”‚ +Observer-based V/Hz control for synchronous motor drives.
â”‚ â”‚  
â”‚ â”‚ -This implements a simplified version of stator-flux-vector control [1]_. The
â”‚ â”‚ -rotor coordinates are used in this implementation [2]_. One control variable is
â”‚ â”‚ -the stator-flux magnitude and another is the electromagnetic torque. The latter
â”‚ â”‚ -choice differs from [1]_ and [2]_, where the torque-producing current component
â”‚ â”‚ -is used. Furthermore, here proportional control is used for simplicity. The
â”‚ â”‚ -magnetic saturation is not considered in this implementation.
â”‚ â”‚ +This method is based on [1]_.
â”‚ â”‚  
â”‚ â”‚  References
â”‚ â”‚  ----------
â”‚ â”‚ -.. [1] Pellegrino, Armando, Guglielmi, â€œDirect flux field-oriented control of
â”‚ â”‚ -   IPM drives with variable DC link in the field-weakening region,â€ IEEE Trans.
â”‚ â”‚ -   Ind. Appl., 2009, https://doi.org/10.1109/TIA.2009.2027167
â”‚ â”‚ -
â”‚ â”‚ -.. [2] Awan, Hinkkanen, Bojoi, Pellegrino, "Stator-flux-oriented control of
â”‚ â”‚ -   synchronous motors: A systematic design procedure," IEEE Trans. Ind. Appl.,
â”‚ â”‚ -   2019, https://doi.org/10.1109/TIA.2019.2927316
â”‚ â”‚ +.. [1] Tiitinen, Hinkkanen, Kukkola, Routimo, Pellegrino, Harnefors, "Stable
â”‚ â”‚ +    and passive observer-based V/Hz control for synchronous Motors," Proc.
â”‚ â”‚ +    IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚ -from collections.abc import Callable
â”‚ â”‚ +
â”‚ â”‚ +from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚ -from motulator.control.common import Ctrl, SpeedCtrl, PWM
â”‚ â”‚ +from motulator.control.common import Ctrl, PWM, RateLimiter
â”‚ â”‚  from motulator.control.sm_torque import TorqueCharacteristics
â”‚ â”‚ -from motulator.control.sm_vector import SensorlessObserver
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  @dataclass
â”‚ â”‚ -class SynchronousMotorFluxVectorCtrlPars:
â”‚ â”‚ -    """Control parameters: flux-vector control for synchronous motor drives."""
â”‚ â”‚ +class SynchronousMotorVHzObsCtrlPars:
â”‚ â”‚ +    """Control parameters."""
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      # Speed reference (in electrical rad/s)
â”‚ â”‚      w_m_ref: Callable[[float], float] = field(
â”‚ â”‚          repr=False, default=lambda t: (t > .2)*(2*np.pi*75))
â”‚ â”‚ -    # Mode
â”‚ â”‚ -    sensorless: bool = True
â”‚ â”‚ -    # Sampling period
â”‚ â”‚ +
â”‚ â”‚ +    # Control
â”‚ â”‚      T_s: float = 250e-6
â”‚ â”‚ -    # Nominal flux
â”‚ â”‚ -    psi_s_nom: float = np.sqrt(2/3)*370/(2*np.pi*75)
â”‚ â”‚ -    # Maximum flux
â”‚ â”‚ -    psi_s_max: float = np.sqrt(2/3)*370/(2*np.pi*75)
â”‚ â”‚ -    # Minimum flux
â”‚ â”‚ -    psi_s_min: float = .5*np.sqrt(2/3)*370/(2*np.pi*75)
â”‚ â”‚ -    # Voltage marginal
â”‚ â”‚ -    k_u: float = .9
â”‚ â”‚ -    # Bandwidths
â”‚ â”‚ -    alpha_psi: float = 2*np.pi*100
â”‚ â”‚ -    alpha_tau_max: float = 2*np.pi*400
â”‚ â”‚ -    alpha_s: float = 2*np.pi*4
â”‚ â”‚ -    # Maximum values
â”‚ â”‚ -    tau_M_max: float = 1.5*14
â”‚ â”‚ -    i_s_max: float = 1.5*np.sqrt(2)*5.
â”‚ â”‚ +    psi_s_max: float = None
â”‚ â”‚ +    psi_s_min: float = None
â”‚ â”‚ +    rate_limit: float = np.inf
â”‚ â”‚ +    i_s_max: float = 1.5*np.sqrt(2)*5
â”‚ â”‚ +    alpha_psi: float = 2*np.pi*50
â”‚ â”‚ +    alpha_tau: float = 2*np.pi*50
â”‚ â”‚ +    alpha_f: float = 2*np.pi*1
â”‚ â”‚ +    k_u: float = 1
â”‚ â”‚ +
â”‚ â”‚ +    # Observer
â”‚ â”‚ +    alpha_o: float = 2*np.pi*20
â”‚ â”‚ +    zeta_inf: float = .2
â”‚ â”‚ +
â”‚ â”‚      # Motor parameter estimates
â”‚ â”‚      R_s: float = 3.6
â”‚ â”‚      L_d: float = .036
â”‚ â”‚      L_q: float = .051
â”‚ â”‚      psi_f: float = .545
â”‚ â”‚ -    p: int = 3
â”‚ â”‚ -    J: float = .015
â”‚ â”‚ -    # Sensorless observer (used only in the sensorless mode)
â”‚ â”‚ -    w_o: float = 2*np.pi*40
â”‚ â”‚ -    zeta_inf: float = .2
â”‚ â”‚ -    # Sensored observer (used only in the sensored mode)
â”‚ â”‚ -    g: float = 2*np.pi*15
â”‚ â”‚ +    n_p: int = 3
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -class SynchronousMotorFluxVectorCtrl(Ctrl):
â”‚ â”‚ +class SynchronousMotorVHzObsCtrl(Ctrl):
â”‚ â”‚      """
â”‚ â”‚ -    Flux-vector control for synchronous motor drives.
â”‚ â”‚ -
â”‚ â”‚ -    This class interconnects the subsystems of the control system and
â”‚ â”‚ -    provides the interface to the solver.
â”‚ â”‚ +    Observer-based V/Hz control for synchronous motors.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚ +    pars : SynchronousMotorVHzObsCtrlPars
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          super().__init__()
â”‚ â”‚ -        self.T_s = pars.T_s
â”‚ â”‚ -        self.w_m_ref = pars.w_m_ref
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ -        self.L_d, self.L_q, self.psi_f = pars.L_d, pars.L_q, pars.psi_f
â”‚ â”‚ -        self.sensorless = pars.sensorless
â”‚ â”‚ -        self.flux_torque_ctrl = FluxTorqueCtrl(pars)
â”‚ â”‚ -        self.speed_ctrl = SpeedCtrl(pars)
â”‚ â”‚ +        # Instantiate classes
â”‚ â”‚ +        self.observer = SensorlessFluxObserver(pars)
â”‚ â”‚          self.pwm = PWM(pars)
â”‚ â”‚ -        if pars.sensorless:
â”‚ â”‚ -            self.observer = SensorlessObserver(pars)
â”‚ â”‚ -        else:
â”‚ â”‚ -            self.observer = Observer(pars)
â”‚ â”‚ +        self.rate_limiter = RateLimiter(pars)
â”‚ â”‚          self.flux_torque_ref = FluxTorqueRef(pars)
â”‚ â”‚ +        # Reference
â”‚ â”‚ +        self.w_m_ref = pars.w_m_ref
â”‚ â”‚ +        # Motor parameters
â”‚ â”‚ +        self.R_s = pars.R_s
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚ +        # Controller parameters
â”‚ â”‚ +        self.T_s = pars.T_s
â”‚ â”‚ +        self.alpha_f = pars.alpha_f
â”‚ â”‚ +        self.alpha_psi = pars.alpha_psi
â”‚ â”‚ +        # Gain k_tau
â”‚ â”‚ +        G = (pars.L_d - pars.L_q)/(pars.L_d*pars.L_q)
â”‚ â”‚ +        psi_s0 = pars.psi_f if pars.psi_f > 0 else pars.psi_s_min
â”‚ â”‚ +        if pars.psi_f > 0:  # PMSM or PM-SyRM
â”‚ â”‚ +            c_delta0 = 1.5*pars.n_p*(pars.psi_f*psi_s0/pars.L_d - G*psi_s0**2)
â”‚ â”‚ +        else:  # SyRM
â”‚ â”‚ +            c_delta0 = 1.5*pars.n_p*G*psi_s0**2
â”‚ â”‚ +        self.k_tau = pars.alpha_tau/c_delta0
â”‚ â”‚ +        # Initial states
â”‚ â”‚ +        self.theta_s, self.tau_M_ref = 0, 0
â”‚ â”‚  
â”‚ â”‚      def __call__(self, mdl):
â”‚ â”‚          """
â”‚ â”‚          Run the main control loop.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚ @@ -120,151 +107,87 @@
â”‚ â”‚          T_s : float
â”‚ â”‚              Sampling period.
â”‚ â”‚          d_abc_ref : ndarray, shape (3,)
â”‚ â”‚              Duty ratio references.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Get the speed reference
â”‚ â”‚ -        w_m_ref = self.w_m_ref(self.t)
â”‚ â”‚ +        w_m_ref = self.rate_limiter(self.w_m_ref(self.t))
â”‚ â”‚  
â”‚ â”‚ -        # Feedback signals
â”‚ â”‚ +        # Measure the feedback signals
â”‚ â”‚          i_s_abc = mdl.motor.meas_currents()  # Phase currents
â”‚ â”‚          u_dc = mdl.conv.meas_dc_voltage()  # DC-bus voltage
â”‚ â”‚ -        u_s = self.pwm.realized_voltage  # Realized voltage from PWM
â”‚ â”‚  
â”‚ â”‚ -        if self.sensorless:
â”‚ â”‚ -            # Get the rotor speed and position estimates
â”‚ â”‚ -            w_m, theta_m = self.observer.w_m, self.observer.theta_m
â”‚ â”‚ -        else:
â”‚ â”‚ -            # Measure the rotor speed
â”‚ â”‚ -            w_m = self.p*mdl.mech.meas_speed()
â”‚ â”‚ -            # Limit the electrical rotor position into [-pi, pi)
â”‚ â”‚ -            theta_m = np.mod(
â”‚ â”‚ -                self.p*mdl.mech.meas_position() + np.pi, 2*np.pi) - np.pi
â”‚ â”‚ +        # Space vector and coordinate transformation
â”‚ â”‚ +        i_s = np.exp(-1j*self.theta_s)*abc2complex(i_s_abc)
â”‚ â”‚  
â”‚ â”‚ -        # Current vector in estimated rotor coordinates
â”‚ â”‚ -        i_s = np.exp(-1j*theta_m)*abc2complex(i_s_abc)
â”‚ â”‚ -
â”‚ â”‚ -        # Flux and torque estimates
â”‚ â”‚ +        # Get the states
â”‚ â”‚ +        u_s = self.pwm.realized_voltage
â”‚ â”‚          psi_s = self.observer.psi_s
â”‚ â”‚ +        tau_M_ref = self.tau_M_ref
â”‚ â”‚ +
â”‚ â”‚ +        # Limited flux and torque references
â”‚ â”‚ +        psi_s_ref, _ = self.flux_torque_ref(tau_M_ref, w_m_ref, u_dc)
â”‚ â”‚ +
â”‚ â”‚ +        # Electromagnetic torque (7d)
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚ +
â”‚ â”‚ +        # Dynamic frequency (5a)
â”‚ â”‚ +        w_s = w_m_ref - self.k_tau*(tau_M - tau_M_ref)
â”‚ â”‚  
â”‚ â”‚ -        # Outputs
â”‚ â”‚ -        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.p, w_m/self.p)
â”‚ â”‚ -        psi_s_ref, tau_M_ref_lim = self.flux_torque_ref(tau_M_ref, w_m, u_dc)
â”‚ â”‚ -        u_s_ref = self.flux_torque_ctrl(
â”‚ â”‚ -            psi_s_ref, tau_M_ref_lim, psi_s, i_s, w_m, u_dc)
â”‚ â”‚ -        d_abc_ref, u_s_ref_lim = self.pwm.output(u_s_ref, u_dc, theta_m, w_m)
â”‚ â”‚ +        # Voltage reference (4)
â”‚ â”‚ +        err = psi_s_ref - psi_s
â”‚ â”‚ +        u_s_ref = self.R_s*i_s + 1j*w_s*psi_s_ref + self.alpha_psi*err
â”‚ â”‚ +
â”‚ â”‚ +        # Duty ratios
â”‚ â”‚ +        d_abc_ref, u_s_ref_lim = self.pwm.output(
â”‚ â”‚ +            u_s_ref, u_dc, self.theta_s, w_s)
â”‚ â”‚  
â”‚ â”‚          # Data logging
â”‚ â”‚          data = Bunch(
â”‚ â”‚              i_s=i_s,
â”‚ â”‚              psi_s=psi_s,
â”‚ â”‚              psi_s_ref=psi_s_ref,
â”‚ â”‚              t=self.t,
â”‚ â”‚ -            tau_M_ref_lim=tau_M_ref_lim,
â”‚ â”‚ -            theta_m=theta_m,
â”‚ â”‚ +            theta_s=self.theta_s,
â”‚ â”‚              u_dc=u_dc,
â”‚ â”‚              u_s=u_s,
â”‚ â”‚ -            w_m=w_m,
â”‚ â”‚              w_m_ref=w_m_ref,
â”‚ â”‚ +            w_s=w_s,
â”‚ â”‚ +            tau_M=tau_M,
â”‚ â”‚          )
â”‚ â”‚          self.save(data)
â”‚ â”‚  
â”‚ â”‚ -        # Update states
â”‚ â”‚ -        self.observer.update(u_s, i_s, w_m)
â”‚ â”‚ -        self.speed_ctrl.update(tau_M_ref_lim)
â”‚ â”‚ +        # Update the states
â”‚ â”‚          self.pwm.update(u_s_ref_lim)
â”‚ â”‚ +        self.observer.update(u_s, i_s, w_s)
â”‚ â”‚ +        self.tau_M_ref += self.T_s*self.alpha_f*(tau_M - self.tau_M_ref)
â”‚ â”‚ +        self.theta_s += self.T_s*w_s  # Next line: limit into [-pi, pi)
â”‚ â”‚ +        self.theta_s = np.mod(self.theta_s + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          self.update_clock(self.T_s)
â”‚ â”‚  
â”‚ â”‚          return self.T_s, d_abc_ref
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -class FluxTorqueCtrl:
â”‚ â”‚ -    """
â”‚ â”‚ -    Stator flux and torque controller.
â”‚ â”‚ -
â”‚ â”‚ -    Parameters
â”‚ â”‚ -    ----------
â”‚ â”‚ -    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚ -        Control parameters.
â”‚ â”‚ -
â”‚ â”‚ -    """
â”‚ â”‚ -
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚ -    def __init__(self, pars):
â”‚ â”‚ -        self.T_s = pars.T_s
â”‚ â”‚ -        self.R_s = pars.R_s
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ -        self.alpha_psi = pars.alpha_psi
â”‚ â”‚ -        G = (pars.L_d - pars.L_q)/(pars.L_d*pars.L_q)
â”‚ â”‚ -        c_delta_max = 1.5*pars.p*(
â”‚ â”‚ -            pars.psi_f*pars.psi_s_nom/pars.L_d + G*pars.psi_s_nom**2)
â”‚ â”‚ -        self.k_tau = pars.alpha_tau_max/c_delta_max
â”‚ â”‚ -
â”‚ â”‚ -    def __call__(self, psi_s_ref, tau_M_ref, psi_s, i_s, w_m, u_dc):
â”‚ â”‚ -        """
â”‚ â”‚ -        Compute the unlimited voltage reference.
â”‚ â”‚ -
â”‚ â”‚ -        Parameters
â”‚ â”‚ -        ----------
â”‚ â”‚ -        psi_s_ref : float
â”‚ â”‚ -            Stator flux reference (magnitude).
â”‚ â”‚ -        tau_M_ref : float
â”‚ â”‚ -            Torque reference.
â”‚ â”‚ -        psi_s : complex
â”‚ â”‚ -            Stator flux estimate.
â”‚ â”‚ -        i_s : complex
â”‚ â”‚ -            Stator current.
â”‚ â”‚ -        w_m : float
â”‚ â”‚ -            Rotor speed (in electrical rad/s).
â”‚ â”‚ -        u_dc : float
â”‚ â”‚ -            DC-bus voltage.
â”‚ â”‚ -
â”‚ â”‚ -        Returns
â”‚ â”‚ -        -------
â”‚ â”‚ -        u_s_ref : complex
â”‚ â”‚ -            Unlimited voltage reference.
â”‚ â”‚ -
â”‚ â”‚ -        """
â”‚ â”‚ -        # Torque estimate
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚ -
â”‚ â”‚ -        # Stator frequency
â”‚ â”‚ -        w_s = w_m + self.k_tau*(tau_M_ref - tau_M)
â”‚ â”‚ -
â”‚ â”‚ -        # Voltage reference
â”‚ â”‚ -        e_psi = psi_s_ref - np.abs(psi_s)
â”‚ â”‚ -        delta = np.angle(psi_s)
â”‚ â”‚ -        u_s_ref = (
â”‚ â”‚ -            self.R_s*i_s + 1j*w_s*psi_s +
â”‚ â”‚ -            self.alpha_psi*e_psi*np.exp(1j*delta))
â”‚ â”‚ -
â”‚ â”‚ -        return u_s_ref
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚ -# %%
â”‚ â”‚  class FluxTorqueRef:
â”‚ â”‚      """
â”‚ â”‚      Flux and torque references.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚ +    pars : SynchronousMotorVHzObsCtrlPars
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚ -        self.psi_s_min = pars.psi_s_min
â”‚ â”‚ -        try:
â”‚ â”‚ -            self.psi_s_max = pars.psi_s_max
â”‚ â”‚ -        except AttributeError:
â”‚ â”‚ -            self.psi_s_max = np.inf
â”‚ â”‚ +        self.psi_s_min = (
â”‚ â”‚ +            pars.psi_f if pars.psi_s_min is None else pars.psi_s_min)
â”‚ â”‚ +        self.psi_s_max = np.inf if pars.psi_s_max is None else pars.psi_s_max
â”‚ â”‚          self.k_u = pars.k_u
â”‚ â”‚          # Merged MTPV and current limits
â”‚ â”‚          tq = TorqueCharacteristics(pars)
â”‚ â”‚          lims = tq.mtpv_and_current_limits(i_s_max=pars.i_s_max)
â”‚ â”‚          self.tau_M_lim = lims.tau_M_vs_abs_psi_s
â”‚ â”‚          # MTPA locus
â”‚ â”‚          mtpa = tq.mtpa_locus(i_s_max=pars.i_s_max)
â”‚ â”‚ @@ -275,86 +198,116 @@
â”‚ â”‚          Calculate the stator flux reference and limit the torque reference.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚          tau_M_ref : float
â”‚ â”‚              Unlimited torque reference.
â”‚ â”‚          w_m : float
â”‚ â”‚ -            Rotor speed (in electrical rad/s).
â”‚ â”‚ +            Rotor speed or its reference (in electrical rad/s).
â”‚ â”‚          u_dc : float
â”‚ â”‚              DC-bus voltage.
â”‚ â”‚  
â”‚ â”‚          Returns
â”‚ â”‚          -------
â”‚ â”‚          psi_s_ref : float
â”‚ â”‚              Stator flux reference.
â”‚ â”‚          tau_M_ref_lim : float
â”‚ â”‚              Limited torque reference.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Get the MTPA flux
â”‚ â”‚          psi_s_mtpa = self.psi_s_mtpa(np.abs(tau_M_ref))
â”‚ â”‚ -        # Limit the MTPA flux for sensorless drives
â”‚ â”‚ -        psi_s_mtpa = np.max([psi_s_mtpa, self.psi_s_min])
â”‚ â”‚ -        # Limit the MTPA flux to avoid magnetic saturation
â”‚ â”‚ -        psi_s_mtpa = np.min([psi_s_mtpa, self.psi_s_max])
â”‚ â”‚ +        np.clip(psi_s_mtpa, self.psi_s_min, self.psi_s_max, out=psi_s_mtpa)
â”‚ â”‚  
â”‚ â”‚          # Field weakening
â”‚ â”‚ -        if np.abs(w_m) > 0:
â”‚ â”‚ -            psi_s_max = self.k_u*u_dc/np.sqrt(3)/np.abs(w_m)
â”‚ â”‚ -        else:
â”‚ â”‚ -            psi_s_max = np.inf
â”‚ â”‚ +        u_s_max = self.k_u*u_dc/np.sqrt(3)
â”‚ â”‚ +        psi_s_max = u_s_max/np.abs(w_m) if np.abs(w_m) > 0 else np.inf
â”‚ â”‚  
â”‚ â”‚          # Flux reference
â”‚ â”‚          psi_s_ref = np.min([psi_s_max, psi_s_mtpa])
â”‚ â”‚  
â”‚ â”‚          # Limit the torque reference according to the MTPV and current limits
â”‚ â”‚          tau_M_lim = self.tau_M_lim(psi_s_ref)
â”‚ â”‚          tau_M_ref_lim = np.min([tau_M_lim, np.abs(tau_M_ref)
â”‚ â”‚                                  ])*np.sign(tau_M_ref)
â”‚ â”‚  
â”‚ â”‚          return psi_s_ref, tau_M_ref_lim
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -class Observer:
â”‚ â”‚ +class SensorlessFluxObserver:
â”‚ â”‚      """
â”‚ â”‚ -    Sensored observer.
â”‚ â”‚ +    Sensorless stator flux observer.
â”‚ â”‚ +
â”‚ â”‚ +    This observer is a variant of [1]_. The observer gain decouples the
â”‚ â”‚ +    electrical and mechanical dynamics and allows placing the poles of the
â”‚ â”‚ +    corresponding linearized estimation error dynamics. For simplicity, the
â”‚ â”‚ +    current model is here implemented in rotor coordinates, however this is
â”‚ â”‚ +    mathematically equivalent to controller coordinates implementation in [2]_.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚ +    pars : SynchronousMotorObsVHzCtrlPars
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚ +    References
â”‚ â”‚ +    ----------
â”‚ â”‚ +    .. [1] Hinkkanen, Saarakkala, Awan, MÃ¶lsÃ¤, Tuovinen, "Observers for
â”‚ â”‚ +        sensorless synchronous motor drives: Framework for design and
â”‚ â”‚ +        analysis," IEEE Trans. Ind. Appl., 2018,
â”‚ â”‚ +        https://doi.org/10.1109/TIA.2018.2858753
â”‚ â”‚ +    .. [2] Tiitinen, Hinkkanen, Kukkola, Routimo, Pellegrino, Harnefors,
â”‚ â”‚ +        "Stable and passive observer-based V/Hz control for synchronous
â”‚ â”‚ +        Motors," Proc. IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚ +
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.R_s = pars.R_s
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.psi_f = pars.psi_f
â”‚ â”‚ -        self.g = pars.g
â”‚ â”‚ -        # Initial state
â”‚ â”‚ -        self.psi_s = pars.psi_f
â”‚ â”‚ +        self.alpha_o = pars.alpha_o
â”‚ â”‚ +        self.b_p = .5*pars.R_s*(pars.L_d + pars.L_q)/(pars.L_d*pars.L_q)
â”‚ â”‚ +        self.zeta_inf = pars.zeta_inf
â”‚ â”‚ +        # Initial states
â”‚ â”‚ +        self.delta, self.psi_s = 0, pars.psi_f
â”‚ â”‚  
â”‚ â”‚ -    def update(self, u_s, i_s, w_m):
â”‚ â”‚ +    def update(self, u_s, i_s, w_s):
â”‚ â”‚          """
â”‚ â”‚          Update the states for the next sampling period.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚          u_s : complex
â”‚ â”‚ -            Stator voltage in estimated rotor coordinates.
â”‚ â”‚ +            Stator voltage.
â”‚ â”‚          i_s : complex
â”‚ â”‚ -            Stator current in estimated rotor coordinates.
â”‚ â”‚ -        w_m : float
â”‚ â”‚ -            Rotor speed (in electrical rad/s).
â”‚ â”‚ +            Stator current.
â”‚ â”‚ +        w_s : float
â”‚ â”‚ +            Stator angular frequency.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚ -        # Estimation error
â”‚ â”‚ -        e = self.L_d*i_s.real + 1j*self.L_q*i_s.imag + self.psi_f - self.psi_s
â”‚ â”‚ +        # Transformations to rotor coordinates
â”‚ â”‚ +        i_sr = i_s*np.exp(1j*self.delta)
â”‚ â”‚ +        psi_sr = self.psi_s*np.exp(1j*self.delta)
â”‚ â”‚ +
â”‚ â”‚ +        # Auxiliary flux and estimation error in rotor coordinates
â”‚ â”‚ +        psi_ar = self.psi_f + (self.L_d - self.L_q)*np.conj(i_sr)
â”‚ â”‚ +        e_r = self.L_d*i_sr.real + 1j*self.L_q*i_sr.imag + self.psi_f - psi_sr
â”‚ â”‚ +
â”‚ â”‚ +        # Auxiliary flux in controller coordinates
â”‚ â”‚ +        psi_a = np.exp(-1j*self.delta)*psi_ar
â”‚ â”‚ +
â”‚ â”‚ +        g_o = self.b_p + 2*self.zeta_inf*np.abs(w_s)
â”‚ â”‚ +
â”‚ â”‚ +        if np.abs(psi_ar) > 0:
â”‚ â”‚ +            # Correction voltage in controller coordinates
â”‚ â”‚ +            v = g_o*psi_a*np.real(e_r/psi_ar)
â”‚ â”‚ +            # Error signal
â”‚ â”‚ +            w_delta = self.alpha_o*np.imag(e_r/psi_ar)
â”‚ â”‚ +        else:
â”‚ â”‚ +            v, w_delta = 0, 0
â”‚ â”‚  
â”‚ â”‚ -        # Update the state
â”‚ â”‚ -        self.psi_s += self.T_s*(
â”‚ â”‚ -            u_s - self.R_s*i_s - 1j*w_m*self.psi_s + self.g*e)
â”‚ â”‚ +        # Update the states
â”‚ â”‚ +        self.psi_s += self.T_s*(u_s - self.R_s*i_s - 1j*w_s*self.psi_s + v)
â”‚ â”‚ +        self.delta += self.T_s*w_delta
â”‚ â”‚   --- motulator-0.1.2/motulator/control/sm_obs_vhz.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/sm_flux_vector.py
â”‚ â”‚â”„ Files 21% similar despite different names
â”‚ â”‚ @@ -1,113 +1,111 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚ -Observer-based V/Hz control for synchronous motor drives.
â”‚ â”‚ +Flux-vector control for synchronous motor drives.
â”‚ â”‚  
â”‚ â”‚ -This method is based on [1]_.
â”‚ â”‚ +This implements a version of stator-flux-vector control [1]_. Rotor coordinates 
â”‚ â”‚ +as well as decoupling between the stator flux and torque channels are used [2]_. 
â”‚ â”‚ +Here, the stator flux magnitude and the electromagnetic torque are selected as
â”‚ â”‚ +controllable variables. Proportional controllers are used for simplicity. The 
â”‚ â”‚ +magnetic saturation is not considered in this implementation.
â”‚ â”‚  
â”‚ â”‚  References
â”‚ â”‚  ----------
â”‚ â”‚ -.. [1] Tiitinen, Hinkkanen, Kukkola, Routimo, Pellegrino, Harnefors, "Stable
â”‚ â”‚ -    and passive observer-based V/Hz control for synchronous Motors," in Proc.
â”‚ â”‚ -    IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚ +.. [1] Pellegrino, Armando, Guglielmi, â€œDirect flux field-oriented control of
â”‚ â”‚ +   IPM drives with variable DC link in the field-weakening region,â€ IEEE Trans.
â”‚ â”‚ +   Ind. Appl., 2009, https://doi.org/10.1109/TIA.2009.2027167
â”‚ â”‚ +
â”‚ â”‚ +.. [2] Awan, Hinkkanen, Bojoi, Pellegrino, "Stator-flux-oriented control of
â”‚ â”‚ +   synchronous motors: A systematic design procedure," IEEE Trans. Ind. Appl.,
â”‚ â”‚ +   2019, https://doi.org/10.1109/TIA.2019.2927316
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚ -
â”‚ â”‚  from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚ -from motulator.control.common import Ctrl, PWM, RateLimiter
â”‚ â”‚ -from motulator.control.sm_torque import TorqueCharacteristics
â”‚ â”‚ +from motulator.control.common import Ctrl, SpeedCtrl, PWM
â”‚ â”‚ +from motulator.control.sm_vector import SensorlessObserver
â”‚ â”‚ +from motulator.control.sm_obs_vhz import FluxTorqueRef
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  @dataclass
â”‚ â”‚ -class SynchronousMotorVHzObsCtrlPars:
â”‚ â”‚ -    """Control parameters."""
â”‚ â”‚ +class SynchronousMotorFluxVectorCtrlPars:
â”‚ â”‚ +    """Control parameters: flux-vector control for synchronous motor drives."""
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      # Speed reference (in electrical rad/s)
â”‚ â”‚      w_m_ref: Callable[[float], float] = field(
â”‚ â”‚          repr=False, default=lambda t: (t > .2)*(2*np.pi*75))
â”‚ â”‚ -
â”‚ â”‚ -    # Control
â”‚ â”‚ +    # Mode
â”‚ â”‚ +    sensorless: bool = True
â”‚ â”‚ +    # Sampling period
â”‚ â”‚      T_s: float = 250e-6
â”‚ â”‚ -    psi_s_max: float = np.sqrt(2/3)*370/(2*np.pi*75)
â”‚ â”‚ -    psi_s_min: float = .5*np.sqrt(2/3)*370/(2*np.pi*75)
â”‚ â”‚ -    rate_limit: float = np.inf
â”‚ â”‚ -    i_s_max: float = 1.5*np.sqrt(2)*5
â”‚ â”‚ -    alpha_psi: float = 2*np.pi*50
â”‚ â”‚ -    alpha_tau_max: float = 2*np.pi*50
â”‚ â”‚ -    alpha_f: float = 2*np.pi*1
â”‚ â”‚ -
â”‚ â”‚ -    # Observer
â”‚ â”‚ -    alpha_o: float = 2*np.pi*20
â”‚ â”‚ -    zeta_inf: float = .7
â”‚ â”‚ -
â”‚ â”‚ +    # Flux reference limits
â”‚ â”‚ +    psi_s_min: float = None
â”‚ â”‚ +    psi_s_max: float = None
â”‚ â”‚ +    # Voltage marginal
â”‚ â”‚ +    k_u: float = .9
â”‚ â”‚ +    # Bandwidths
â”‚ â”‚ +    alpha_psi: float = 2*np.pi*150
â”‚ â”‚ +    alpha_tau: float = 2*np.pi*50
â”‚ â”‚ +    alpha_s: float = 2*np.pi*4
â”‚ â”‚ +    # Maximum values
â”‚ â”‚ +    tau_M_max: float = 1.5*14
â”‚ â”‚ +    i_s_max: float = 1.5*np.sqrt(2)*5.
â”‚ â”‚      # Motor parameter estimates
â”‚ â”‚      R_s: float = 3.6
â”‚ â”‚      L_d: float = .036
â”‚ â”‚      L_q: float = .051
â”‚ â”‚      psi_f: float = .545
â”‚ â”‚ -    p: int = 3
â”‚ â”‚ +    n_p: int = 3
â”‚ â”‚ +    J: float = .015
â”‚ â”‚ +    # Sensorless observer (used only in the sensorless mode)
â”‚ â”‚ +    w_o: float = 2*np.pi*100
â”‚ â”‚ +    zeta_inf: float = .2
â”‚ â”‚ +    # Sensored observer (used only in the sensored mode)
â”‚ â”‚ +    g: float = 2*np.pi*15
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -class SynchronousMotorVHzObsCtrl(Ctrl):
â”‚ â”‚ +class SynchronousMotorFluxVectorCtrl(Ctrl):
â”‚ â”‚      """
â”‚ â”‚ -    Observer-based V/Hz control for synchronous motors.
â”‚ â”‚ +    Flux-vector control for synchronous motor drives.
â”‚ â”‚ +
â”‚ â”‚ +    This class interconnects the subsystems of the control system and
â”‚ â”‚ +    provides the interface to the solver.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    pars : SynchronousMotorVHzObsCtrlPars
â”‚ â”‚ +    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          super().__init__()
â”‚ â”‚ -        # Instantiate classes
â”‚ â”‚ -        self.observer = SensorlessFluxObserver(pars)
â”‚ â”‚ -        self.pwm = PWM(pars)
â”‚ â”‚ -        self.rate_limiter = RateLimiter(pars)
â”‚ â”‚ -        # Reference
â”‚ â”‚ -        self.w_m_ref = pars.w_m_ref
â”‚ â”‚ -        # Motor parameters
â”‚ â”‚ -        self.R_s = pars.R_s
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ -        # Controller parameters
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚ -        self.alpha_f = pars.alpha_f
â”‚ â”‚ +        self.w_m_ref = pars.w_m_ref
â”‚ â”‚ +        self.sensorless = pars.sensorless
â”‚ â”‚ +        self.speed_ctrl = SpeedCtrl(pars)
â”‚ â”‚ +        self.pwm = PWM(pars)
â”‚ â”‚ +        if pars.sensorless:
â”‚ â”‚ +            self.observer = SensorlessObserver(pars)
â”‚ â”‚ +        else:
â”‚ â”‚ +            self.observer = Observer(pars)
â”‚ â”‚ +        self.flux_torque_ref = FluxTorqueRef(pars)
â”‚ â”‚ +        # Bandwidths
â”‚ â”‚          self.alpha_psi = pars.alpha_psi
â”‚ â”‚ -        # MTPA
â”‚ â”‚ -        tq = TorqueCharacteristics(pars)
â”‚ â”‚ -        mtpa = tq.mtpa_locus(i_s_max=pars.i_s_max)
â”‚ â”‚ -        self.abs_psi_s_mtpa = mtpa.abs_psi_s_vs_tau_M
â”‚ â”‚ -        try:
â”‚ â”‚ -            self.psi_s_min = pars.psi_s_min
â”‚ â”‚ -        except AttributeError:
â”‚ â”‚ -            self.psi_s_min = 0
â”‚ â”‚ -        try:
â”‚ â”‚ -            self.psi_s_max = pars.psi_s_max
â”‚ â”‚ -        except AttributeError:
â”‚ â”‚ -            self.psi_s_max = np.inf
â”‚ â”‚ -        # Gain k_tau
â”‚ â”‚ -        abs_psi_s_mtpa0 = self.abs_psi_s_mtpa(0)
â”‚ â”‚ -        G = (pars.L_d - pars.L_q)/(pars.L_d*pars.L_q)
â”‚ â”‚ -        if pars.psi_f > 0:  # PMSM or PM-SyRM
â”‚ â”‚ -            c_delta_max = 1.5*pars.p*(
â”‚ â”‚ -                pars.psi_f*abs_psi_s_mtpa0/pars.L_d - G*abs_psi_s_mtpa0**2)
â”‚ â”‚ -        else:  # SyRM
â”‚ â”‚ -            c_delta_max = 1.5*pars.p*G*abs_psi_s_mtpa0**2
â”‚ â”‚ -        self.k_tau = pars.alpha_tau_max/c_delta_max
â”‚ â”‚ -        # Initial states
â”‚ â”‚ -        self.theta_s, self.tau_M_ref = 0, 0
â”‚ â”‚ +        self.alpha_tau = pars.alpha_tau
â”‚ â”‚ +        # Motor parameter estimates
â”‚ â”‚ +        self.R_s = pars.R_s
â”‚ â”‚ +        self.L_d = pars.L_d
â”‚ â”‚ +        self.L_q = pars.L_q
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚  
â”‚ â”‚      def __call__(self, mdl):
â”‚ â”‚          """
â”‚ â”‚          Run the main control loop.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚ @@ -120,144 +118,121 @@
â”‚ â”‚          T_s : float
â”‚ â”‚              Sampling period.
â”‚ â”‚          d_abc_ref : ndarray, shape (3,)
â”‚ â”‚              Duty ratio references.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Get the speed reference
â”‚ â”‚ -        w_m_ref = self.rate_limiter(self.w_m_ref(self.t))
â”‚ â”‚ +        w_m_ref = self.w_m_ref(self.t)
â”‚ â”‚  
â”‚ â”‚ -        # Measure the feedback signals
â”‚ â”‚ +        # Feedback signals
â”‚ â”‚          i_s_abc = mdl.motor.meas_currents()  # Phase currents
â”‚ â”‚          u_dc = mdl.conv.meas_dc_voltage()  # DC-bus voltage
â”‚ â”‚ +        u_s = self.pwm.realized_voltage  # Realized voltage from PWM
â”‚ â”‚ +
â”‚ â”‚ +        if self.sensorless:
â”‚ â”‚ +            # Get the rotor speed and position estimates
â”‚ â”‚ +            w_m, theta_m = self.observer.w_m, self.observer.theta_m
â”‚ â”‚ +        else:
â”‚ â”‚ +            # Measure the rotor speed
â”‚ â”‚ +            w_m = self.n_p*mdl.mech.meas_speed()
â”‚ â”‚ +            # Limit the electrical rotor position into [-pi, pi)
â”‚ â”‚ +            theta_m = np.mod(
â”‚ â”‚ +                self.n_p*mdl.mech.meas_position() + np.pi, 2*np.pi) - np.pi
â”‚ â”‚  
â”‚ â”‚ -        # Space vector and coordinate transformation
â”‚ â”‚ -        i_s = np.exp(-1j*self.theta_s)*abc2complex(i_s_abc)
â”‚ â”‚ +        # Current vector in estimated rotor coordinates
â”‚ â”‚ +        i_s = np.exp(-1j*theta_m)*abc2complex(i_s_abc)
â”‚ â”‚  
â”‚ â”‚ -        # Get the states
â”‚ â”‚ -        u_s = self.pwm.realized_voltage
â”‚ â”‚ +        # Flux and torque estimates
â”‚ â”‚          psi_s = self.observer.psi_s
â”‚ â”‚ -        tau_M_ref = self.tau_M_ref
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚  
â”‚ â”‚ -        # Electromagnetic torque (7d)
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚ +        # Outputs
â”‚ â”‚ +        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.n_p, w_m/self.n_p)
â”‚ â”‚ +        psi_s_ref, tau_M_ref_lim = self.flux_torque_ref(tau_M_ref, w_m, u_dc)
â”‚ â”‚ +
â”‚ â”‚ +        # Auxiliary current
â”‚ â”‚ +        i_a = psi_s.real/self.L_q + 1j*psi_s.imag/self.L_d - i_s
â”‚ â”‚ +
â”‚ â”‚ +        # Torque-production factor (c_tau = 0 corresponds to the MTPV condition)
â”‚ â”‚ +        c_tau = np.real(i_a*np.conj(psi_s))
â”‚ â”‚ +
â”‚ â”‚ +        # References for the flux and torque controllers
â”‚ â”‚ +        v_psi = self.alpha_psi*(psi_s_ref - np.abs(psi_s))
â”‚ â”‚ +        v_tau = self.alpha_tau*(tau_M_ref_lim - tau_M)
â”‚ â”‚ +        if c_tau > 0:
â”‚ â”‚ +            v = (np.abs(psi_s)*i_a*v_psi + 1j*psi_s*v_tau)/c_tau
â”‚ â”‚ +        else:
â”‚ â”‚ +            v = v_psi
â”‚ â”‚  
â”‚ â”‚ -        # Dynamic frequency (5a)
â”‚ â”‚ -        w_s = w_m_ref - self.k_tau*(tau_M - tau_M_ref)
â”‚ â”‚ +        # Stator voltage reference
â”‚ â”‚ +        u_s_ref = self.R_s*i_s + 1j*w_m*psi_s + v
â”‚ â”‚  
â”‚ â”‚ -        # Flux reference
â”‚ â”‚ -        psi_s_ref = self.abs_psi_s_mtpa(np.abs(tau_M_ref))
â”‚ â”‚ -        psi_s_ref = np.max([psi_s_ref, self.psi_s_min])
â”‚ â”‚ -        psi_s_ref = np.min([psi_s_ref, self.psi_s_max])
â”‚ â”‚ -
â”‚ â”‚ -        # Voltage reference (4)
â”‚ â”‚ -        err = psi_s_ref - psi_s
â”‚ â”‚ -        u_s_ref = self.R_s*i_s + 1j*w_s*psi_s_ref + self.alpha_psi*err
â”‚ â”‚ -
â”‚ â”‚ -        # Duty ratios
â”‚ â”‚ -        d_abc_ref, u_s_ref_lim = self.pwm.output(
â”‚ â”‚ -            u_s_ref, u_dc, self.theta_s, w_s)
â”‚ â”‚ +        # PWM output
â”‚ â”‚ +        d_abc_ref, u_s_ref_lim = self.pwm.output(u_s_ref, u_dc, theta_m, w_m)
â”‚ â”‚  
â”‚ â”‚          # Data logging
â”‚ â”‚          data = Bunch(
â”‚ â”‚              i_s=i_s,
â”‚ â”‚              psi_s=psi_s,
â”‚ â”‚              psi_s_ref=psi_s_ref,
â”‚ â”‚              t=self.t,
â”‚ â”‚ -            theta_s=self.theta_s,
â”‚ â”‚ +            tau_M_ref_lim=tau_M_ref_lim,
â”‚ â”‚ +            theta_m=theta_m,
â”‚ â”‚              u_dc=u_dc,
â”‚ â”‚              u_s=u_s,
â”‚ â”‚ +            w_m=w_m,
â”‚ â”‚              w_m_ref=w_m_ref,
â”‚ â”‚ -            w_s=w_s,
â”‚ â”‚ -            tau_M=tau_M,
â”‚ â”‚          )
â”‚ â”‚          self.save(data)
â”‚ â”‚  
â”‚ â”‚ -        # Update the states
â”‚ â”‚ +        # Update states
â”‚ â”‚ +        self.observer.update(u_s, i_s, w_m)
â”‚ â”‚ +        self.speed_ctrl.update(tau_M_ref_lim)
â”‚ â”‚          self.pwm.update(u_s_ref_lim)
â”‚ â”‚ -        self.observer.update(u_s, i_s, w_s)
â”‚ â”‚ -        self.tau_M_ref += self.T_s*self.alpha_f*(tau_M - self.tau_M_ref)
â”‚ â”‚ -        self.theta_s += self.T_s*w_s  # Next line: limit into [-pi, pi)
â”‚ â”‚ -        self.theta_s = np.mod(self.theta_s + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          self.update_clock(self.T_s)
â”‚ â”‚  
â”‚ â”‚          return self.T_s, d_abc_ref
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -class SensorlessFluxObserver:
â”‚ â”‚ +class Observer:
â”‚ â”‚      """
â”‚ â”‚ -    Sensorless stator flux observer.
â”‚ â”‚ -
â”‚ â”‚ -    This observer is a variant of [1]_. The observer gain decouples the
â”‚ â”‚ -    electrical and mechanical dynamics and allows placing the poles of the
â”‚ â”‚ -    corresponding linearized estimation error dynamics. For simplicity, the
â”‚ â”‚ -    current model is here implemented in rotor coordinates, however this is
â”‚ â”‚ -    mathematically equivalent to controller coordinates implementation in [2]_.
â”‚ â”‚ +    Sensored observer.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    pars : SynchronousMotorObsVHzCtrlPars
â”‚ â”‚ +    pars : SynchronousMotoroFluxVectorCtrlPars
â”‚ â”‚          Control parameters.
â”‚ â”‚  
â”‚ â”‚ -    References
â”‚ â”‚ -    ----------
â”‚ â”‚ -    .. [1] Hinkkanen, Saarakkala, Awan, MÃ¶lsÃ¤, Tuovinen, "Observers for
â”‚ â”‚ -        sensorless synchronous motor drives: Framework for design and
â”‚ â”‚ -        analysis," IEEE Trans. Ind. Appl., 2018,
â”‚ â”‚ -        https://doi.org/10.1109/TIA.2018.2858753
â”‚ â”‚ -    .. [2] Tiitinen, Hinkkanen, Kukkola, Routimo, Pellegrino, Harnefors,
â”‚ â”‚ -        "Stable and passive observer-based V/Hz control for synchronous
â”‚ â”‚ -        Motors," in Proc. IEEE ECCE, Detroit, MI, Oct. 2022.
â”‚ â”‚ -
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.R_s = pars.R_s
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.psi_f = pars.psi_f
â”‚ â”‚ -        self.alpha_o = pars.alpha_o
â”‚ â”‚ -        self.b_p = .5*pars.R_s*(pars.L_d + pars.L_q)/(pars.L_d*pars.L_q)
â”‚ â”‚ -        self.zeta_inf = pars.zeta_inf
â”‚ â”‚ -        # Initial states
â”‚ â”‚ -        self.delta, self.psi_s = 0, pars.psi_f
â”‚ â”‚ +        self.g = pars.g
â”‚ â”‚ +        # Initial state
â”‚ â”‚ +        self.psi_s = pars.psi_f
â”‚ â”‚  
â”‚ â”‚ -    def update(self, u_s, i_s, w_s):
â”‚ â”‚ +    def update(self, u_s, i_s, w_m):
â”‚ â”‚          """
â”‚ â”‚          Update the states for the next sampling period.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚          ----------
â”‚ â”‚          u_s : complex
â”‚ â”‚ -            Stator voltage.
â”‚ â”‚ +            Stator voltage in estimated rotor coordinates.
â”‚ â”‚          i_s : complex
â”‚ â”‚ -            Stator current.
â”‚ â”‚ -        w_s : float
â”‚ â”‚ -            Stator angular frequency.
â”‚ â”‚ +            Stator current in estimated rotor coordinates.
â”‚ â”‚ +        w_m : float
â”‚ â”‚ +            Rotor speed (in electrical rad/s).
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚ -        # Transformations to rotor coordinates
â”‚ â”‚ -        i_sr = i_s*np.exp(1j*self.delta)
â”‚ â”‚ -        psi_sr = self.psi_s*np.exp(1j*self.delta)
â”‚ â”‚ -
â”‚ â”‚ -        # Auxiliary flux and estimation error in rotor coordinates
â”‚ â”‚ -        psi_ar = self.psi_f + (self.L_d - self.L_q)*np.conj(i_sr)
â”‚ â”‚ -        e_r = self.L_d*i_sr.real + 1j*self.L_q*i_sr.imag + self.psi_f - psi_sr
â”‚ â”‚ -
â”‚ â”‚ -        # Auxiliary flux in controller coordinates
â”‚ â”‚ -        psi_a = np.exp(-1j*self.delta)*psi_ar
â”‚ â”‚ -
â”‚ â”‚ -        g_o = self.b_p + 2*self.zeta_inf*np.abs(w_s)
â”‚ â”‚ -
â”‚ â”‚ -        if np.abs(psi_ar) > 0:
â”‚ â”‚ -            # Correction voltage in controller coordinates
â”‚ â”‚ -            v = g_o*psi_a*np.real(e_r/psi_ar)
â”‚ â”‚ -            # Error signal
â”‚ â”‚ -            w_delta = self.alpha_o*np.imag(e_r/psi_ar)
â”‚ â”‚ -        else:
â”‚ â”‚ -            v, w_delta = 0, 0
â”‚ â”‚ +        # Estimation error
â”‚ â”‚ +        e = self.L_d*i_s.real + 1j*self.L_q*i_s.imag + self.psi_f - self.psi_s
â”‚ â”‚  
â”‚ â”‚ -        # Update the states
â”‚ â”‚ -        self.psi_s += self.T_s*(u_s - self.R_s*i_s - 1j*w_s*self.psi_s + v)
â”‚ â”‚ -        self.delta += self.T_s*w_delta
â”‚ â”‚ +        # Update the state
â”‚ â”‚ +        self.psi_s += self.T_s*(
â”‚ â”‚ +            u_s - self.R_s*i_s - 1j*w_m*self.psi_s + self.g*e)
â”‚ â”‚   --- motulator-0.1.2/motulator/control/sm_signal_inj.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/sm_signal_inj.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,23 +1,20 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Sensorless control with signal injection for synchronous motor drives.
â”‚ â”‚  
â”‚ â”‚  This module contains a simple example of square-wave signal injection for low-
â”‚ â”‚  speed operation. A phase-locked loop is used to track the rotor position. For
â”‚ â”‚  a wider speed range, signal injection could be combined to a model-based
â”‚ â”‚  observer. The effects of magnetic saturation are not compensated for in this
â”‚ â”‚  version.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚  from dataclasses import dataclass
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚  from motulator.control.common import Ctrl, SpeedCtrl, PWM
â”‚ â”‚  from motulator.control.sm_vector import (
â”‚ â”‚      CurrentCtrl, CurrentRef, SynchronousMotorVectorCtrlPars)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ @@ -44,15 +41,15 @@
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          super().__init__()
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.w_m_ref = pars.w_m_ref
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.current_ctrl = CurrentCtrl(pars)
â”‚ â”‚          self.speed_ctrl = SpeedCtrl(pars)
â”‚ â”‚          self.current_ref = CurrentRef(pars)
â”‚ â”‚          self.pwm = PWM(pars)
â”‚ â”‚          self.pll = PhaseLockedLoop(pars)
â”‚ â”‚          self.signal_inj = SignalInjection(pars)
â”‚ â”‚  
â”‚ â”‚ @@ -87,15 +84,15 @@
â”‚ â”‚          # Current vector in estimated rotor coordinates
â”‚ â”‚          i_s = np.exp(-1j*theta_m)*abc2complex(i_s_abc)
â”‚ â”‚  
â”‚ â”‚          # Filter the current measurement for the current controller
â”‚ â”‚          i_s_filt = self.signal_inj.filter_current(i_s)
â”‚ â”‚  
â”‚ â”‚          # Outputs
â”‚ â”‚ -        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.p, w_m/self.p)
â”‚ â”‚ +        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.n_p, w_m/self.n_p)
â”‚ â”‚          i_s_ref, tau_M_ref_lim = self.current_ref.output(tau_M_ref, w_m, u_dc)
â”‚ â”‚          err = self.signal_inj.output(i_s.imag)
â”‚ â”‚          # Superimpose the excitation voltage on the d-axis
â”‚ â”‚          u_s_ref = self.current_ctrl.output(
â”‚ â”‚              i_s_ref, i_s_filt) + self.signal_inj.u_sd_inj
â”‚ â”‚          d_abc_ref, u_s_ref_lim = self.pwm.output(u_s_ref, u_dc, theta_m, w_m)
â”‚ â”‚   --- motulator-0.1.2/motulator/control/sm_torque.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/sm_torque.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -1,23 +1,28 @@
â”‚ â”‚ -# pylint: disable=C0103
â”‚ â”‚  """
â”‚ â”‚  Torque characteristics for synchronous machines.
â”‚ â”‚  
â”‚ â”‚  This contains computation and plotting of torque characteristics for
â”‚ â”‚ -synchronous machines, including the MTPA and MTPV loci. The methods can be used
â”‚ â”‚ -to define look-up tables for control as well as to analyze the characteristics.
â”‚ â”‚ +synchronous machines, including the MTPA and MTPV loci [1]_. The methods can be
â”‚ â”‚ +used to define look-up tables for control and to analyze the characteristics.
â”‚ â”‚  In this version, the magnetic saturation is omitted.
â”‚ â”‚  
â”‚ â”‚ +References
â”‚ â”‚ +----------
â”‚ â”‚ +.. [1] Morimoto, Takeda, Hirasa, Taniguchi, "Expansion of operating limits for
â”‚ â”‚ +   permanent magnet motor by current vector control considering inverter
â”‚ â”‚ +   capacity," IEEE Trans. Ind. Appl., 1990,
â”‚ â”‚ +   https://doi.org/10.1109/28.60058
â”‚ â”‚ +
â”‚ â”‚  """
â”‚ â”‚  from sys import float_info
â”‚ â”‚  import numpy as np
â”‚ â”‚  from scipy.interpolate import interp1d
â”‚ â”‚  import matplotlib.pyplot as plt
â”‚ â”‚  from cycler import cycler
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import Bunch
â”‚ â”‚  
â”‚ â”‚  plt.rcParams['axes.prop_cycle'] = cycler(color='brgcmyk')
â”‚ â”‚  plt.rcParams['lines.linewidth'] = 1.
â”‚ â”‚  plt.rcParams.update({"text.usetex": False})  # Disable LaTeX in plots
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ @@ -32,15 +37,15 @@
â”‚ â”‚      ----------
â”‚ â”‚      pars : data object
â”‚ â”‚          Motor parameters.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.psi_f = pars.psi_f
â”‚ â”‚          try:
â”‚ â”‚              self.psi_s_min = pars.psi_s_min
â”‚ â”‚          except AttributeError:
â”‚ â”‚              self.psi_s_min = None
â”‚ â”‚ @@ -61,15 +66,15 @@
â”‚ â”‚          Returns
â”‚ â”‚          -------
â”‚ â”‚          tau_M : float
â”‚ â”‚              Electromagnetic torque.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_s = self.current(psi_s)
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚  
â”‚ â”‚          return tau_M
â”‚ â”‚  
â”‚ â”‚      def current(self, psi_s):
â”‚ â”‚          """
â”‚ â”‚          Compute the stator current as a function of the stator flux linkage.
â”‚ â”‚  
â”‚ â”‚ @@ -269,16 +274,16 @@
â”‚ â”‚  
â”‚ â”‚          psi_s = self.flux(i_s)
â”‚ â”‚          tau_M = self.torque(psi_s)
â”‚ â”‚  
â”‚ â”‚          # Create an interpolant that can be used as a look-up table. If needed,
â”‚ â”‚          # more interpolants can be easily added.
â”‚ â”‚          abs_psi_s_vs_tau_M = interp1d(
â”‚ â”‚ -            tau_M, np.abs(psi_s), fill_value="extrapolate")
â”‚ â”‚ -        i_sd_vs_tau_M = interp1d(tau_M, i_s.real, fill_value="extrapolate")
â”‚ â”‚ +            tau_M, np.abs(psi_s), fill_value='extrapolate')
â”‚ â”‚ +        i_sd_vs_tau_M = interp1d(tau_M, i_s.real, fill_value='extrapolate')
â”‚ â”‚  
â”‚ â”‚          # Return the result as a bunch object
â”‚ â”‚          return Bunch(
â”‚ â”‚              psi_s=psi_s,
â”‚ â”‚              i_s=i_s,
â”‚ â”‚              tau_M=tau_M,
â”‚ â”‚              abs_psi_s_vs_tau_M=abs_psi_s_vs_tau_M,
â”‚ â”‚ @@ -432,52 +437,20 @@
â”‚ â”‚  
â”‚ â”‚          # Create an interpolant that can be used as a look-up table
â”‚ â”‚          tau_M_vs_abs_psi_s = interp1d(
â”‚ â”‚              np.abs(psi_s),
â”‚ â”‚              tau_M,
â”‚ â”‚              bounds_error=False,
â”‚ â”‚              fill_value=(tau_M[0], tau_M[-1]))
â”‚ â”‚ -        i_sd_vs_tau_M = interp1d(tau_M, i_sd, fill_value="extrapolate")
â”‚ â”‚ +        i_sd_vs_tau_M = interp1d(tau_M, i_sd, fill_value='extrapolate')
â”‚ â”‚  
â”‚ â”‚          # Return the result as a bunch object
â”‚ â”‚          return Bunch(
â”‚ â”‚              tau_M_vs_abs_psi_s=tau_M_vs_abs_psi_s, i_sd_vs_tau_M=i_sd_vs_tau_M)
â”‚ â”‚  
â”‚ â”‚ -    def delta_at_zero_torque(self, abs_psi_s):
â”‚ â”‚ -        """
â”‚ â”‚ -        Compute the load angle value at the zero torque.
â”‚ â”‚ -
â”‚ â”‚ -        This computes the "nontrivial" load angle value corresponding to the
â”‚ â”‚ -        zero electromagnetic torque.
â”‚ â”‚ -
â”‚ â”‚ -        Parameters
â”‚ â”‚ -        ----------
â”‚ â”‚ -        abs_psi_s : float
â”‚ â”‚ -            Stator flux magnitude.
â”‚ â”‚ -
â”‚ â”‚ -        Returns
â”‚ â”‚ -        -------
â”‚ â”‚ -        delta : float
â”‚ â”‚ -            Load angle at the zero torque.
â”‚ â”‚ -
â”‚ â”‚ -        """
â”‚ â”‚ -        if self.psi_f > 0:
â”‚ â”‚ -            c = ((self.L_q - self.L_d)/self.L_q*abs_psi_s/self.psi_f)**2 - 1
â”‚ â”‚ -            if c > 0:
â”‚ â”‚ -                if self.L_q > self.L_d:
â”‚ â”‚ -                    delta = np.arctan((np.sqrt(c)))
â”‚ â”‚ -                else:
â”‚ â”‚ -                    delta = np.pi - np.arctan((np.sqrt(c)))
â”‚ â”‚ -            else:
â”‚ â”‚ -                delta = 0
â”‚ â”‚ -        else:
â”‚ â”‚ -            delta = 0
â”‚ â”‚ -
â”‚ â”‚ -        return delta
â”‚ â”‚ -
â”‚ â”‚      def plot_flux_loci(self, i_s_max, base, N=20):
â”‚ â”‚          """
â”‚ â”‚          Plot the stator flux linkage loci.
â”‚ â”‚  
â”‚ â”‚          Per-unit quantities are used.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚ @@ -656,46 +629,7 @@
â”‚ â”‚          except AttributeError:
â”‚ â”‚              pass
â”‚ â”‚          ax.plot(np.abs(clim.psi_s)/base.psi, clim.tau_M/base.tau)
â”‚ â”‚  
â”‚ â”‚          ax.legend(['MTPA', 'MTPV', 'Const current'])
â”‚ â”‚          ax.set_xlabel(r'$\psi_\mathrm{s}$ (p.u.)')
â”‚ â”‚          ax.set_ylabel(r'$\tau_\mathrm{m}$ (p.u.)')
â”‚ â”‚ -
â”‚ â”‚ -    def plot_angle_torque(self, abs_psi_s, base, N=100):
â”‚ â”‚ -        """
â”‚ â”‚ -        Plot the electromagnetic torque as a function of the load angle.
â”‚ â”‚ -
â”‚ â”‚ -        Per-unit quantities are used.
â”‚ â”‚ -
â”‚ â”‚ -        Parameters
â”‚ â”‚ -        ----------
â”‚ â”‚ -        abs_psi_s : float
â”‚ â”‚ -            Stator flux magnitude.
â”‚ â”‚ -        base : object
â”‚ â”‚ -            Base values.
â”‚ â”‚ -        N : int, optional
â”‚ â”‚ -            Amount of points to be evaluated. The default is 100.
â”‚ â”‚ -
â”‚ â”‚ -        """
â”‚ â”‚ -        delta = np.linspace(-np.pi, np.pi, N)
â”‚ â”‚ -        psi_s = abs_psi_s*np.exp(1j*delta)
â”‚ â”‚ -        tau_M = self.torque(psi_s)
â”‚ â”‚ -
â”‚ â”‚ -        delta_mtpv = self.mtpv(abs_psi_s)
â”‚ â”‚ -        psi_s_mtpv = abs_psi_s*np.exp(1j*delta_mtpv)
â”‚ â”‚ -        tau_M_mtpv = self.torque(psi_s_mtpv)
â”‚ â”‚ -
â”‚ â”‚ -        delta0 = self.delta_at_zero_torque(abs_psi_s)
â”‚ â”‚ -        psi_s0 = abs_psi_s*np.exp(1j*delta0)
â”‚ â”‚ -        tau_M0 = self.torque(psi_s0)
â”‚ â”‚ -
â”‚ â”‚ -        _, ax = plt.subplots()
â”‚ â”‚ -        ax.plot(180*delta/np.pi, tau_M/base.tau)
â”‚ â”‚ -        ax.plot(180*delta_mtpv/np.pi, tau_M_mtpv/base.tau, 'o')
â”‚ â”‚ -        ax.plot(180*delta0/np.pi, tau_M0/base.tau, 'x')
â”‚ â”‚ -
â”‚ â”‚ -        ax.set_xlim([-180, 180])
â”‚ â”‚ -        ax.set_xticks([-180, -135, -90, -45, 0, 45, 90, 135, 180])
â”‚ â”‚ -        ax.set_xlabel(r'$\delta$ (deg)')
â”‚ â”‚ -        ax.set_ylabel(r'$\tau_\mathrm{m}$ (p.u.)')
â”‚ â”‚ -        ax.set_title(r'$\psi_\mathrm{s}=$ %1.2f p.u.' % (abs_psi_s/base.psi))
â”‚ â”‚   --- motulator-0.1.2/motulator/control/sm_vector.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/control/sm_vector.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -1,15 +1,12 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Current vector control for synchronous motor drives."""
â”‚ â”‚  
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚ -from collections.abc import Callable
â”‚ â”‚ +from typing import Callable
â”‚ â”‚  from dataclasses import dataclass, field
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import abc2complex, Bunch
â”‚ â”‚  from motulator.control.common import Ctrl, SpeedCtrl, PWM
â”‚ â”‚  from motulator.control.sm_torque import TorqueCharacteristics
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  @dataclass
â”‚ â”‚ @@ -27,46 +24,30 @@
â”‚ â”‚      # Bandwidths
â”‚ â”‚      alpha_c: float = 2*np.pi*200
â”‚ â”‚      alpha_fw: float = 2*np.pi*20
â”‚ â”‚      alpha_s: float = 2*np.pi*4
â”‚ â”‚      # Maximum values
â”‚ â”‚      tau_M_max: float = 2*14
â”‚ â”‚      i_s_max: float = 1.5*np.sqrt(2)*5
â”‚ â”‚ -    psi_s_min: float = 0
â”‚ â”‚ +    psi_s_min: float = None
â”‚ â”‚      # Voltage margin
â”‚ â”‚      k_u: float = .95
â”‚ â”‚      # Nominal values
â”‚ â”‚      w_nom: float = 2*np.pi*75
â”‚ â”‚      # Motor parameter estimates
â”‚ â”‚      R_s: float = 3.6
â”‚ â”‚      L_d: float = .036
â”‚ â”‚      L_q: float = .051
â”‚ â”‚      psi_f: float = .545
â”‚ â”‚ -    p: int = 3
â”‚ â”‚ +    n_p: int = 3
â”‚ â”‚      J: float = .015
â”‚ â”‚      # Sensorless observer
â”‚ â”‚      w_o: float = 2*np.pi*40  # Used only in the sensorless mode
â”‚ â”‚      zeta_inf: float = .2
â”‚ â”‚  
â”‚ â”‚ -    def plot_luts(self, base):
â”‚ â”‚ -        """
â”‚ â”‚ -        Plot control look-up tables.
â”‚ â”‚ -
â”‚ â”‚ -        Parameters
â”‚ â”‚ -        ----------
â”‚ â”‚ -        base : BaseValues
â”‚ â”‚ -            Base values for scaling the plots.
â”‚ â”‚ -
â”‚ â”‚ -        """
â”‚ â”‚ -        tq = TorqueCharacteristics(self)
â”‚ â”‚ -        tq.plot_current_loci(self.i_s_max, base)
â”‚ â”‚ -        tq.plot_torque_flux(self.i_s_max, base)
â”‚ â”‚ -        tq.plot_torque_current(self.i_s_max, base)
â”‚ â”‚ -        # tq.plot_flux_loci(self.i_s_max, base)
â”‚ â”‚ -
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class SynchronousMotorVectorCtrl(Ctrl):
â”‚ â”‚      """
â”‚ â”‚      Vector control for a synchronous motor drive.
â”‚ â”‚  
â”‚ â”‚      This class interconnects the subsystems of the control system and
â”‚ â”‚ @@ -80,15 +61,15 @@
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚          super().__init__()
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.w_m_ref = pars.w_m_ref
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.sensorless = pars.sensorless
â”‚ â”‚          self.current_ctrl = CurrentCtrl(pars)
â”‚ â”‚          self.speed_ctrl = SpeedCtrl(pars)
â”‚ â”‚          self.current_ref = CurrentRef(pars)
â”‚ â”‚          self.pwm = PWM(pars)
â”‚ â”‚          if pars.sensorless:
â”‚ â”‚              self.observer = SensorlessObserver(pars)
â”‚ â”‚ @@ -118,30 +99,30 @@
â”‚ â”‚  
â”‚ â”‚          # Measure the feedback signals
â”‚ â”‚          i_s_abc = mdl.motor.meas_currents()  # Phase currents
â”‚ â”‚          u_dc = mdl.conv.meas_dc_voltage()  # DC-bus voltage
â”‚ â”‚  
â”‚ â”‚          if not self.sensorless:
â”‚ â”‚              # Measure the rotor speed
â”‚ â”‚ -            w_m = self.p*mdl.mech.meas_speed()
â”‚ â”‚ +            w_m = self.n_p*mdl.mech.meas_speed()
â”‚ â”‚              # Limit the electrical rotor position into [-pi, pi)
â”‚ â”‚              theta_m = np.mod(
â”‚ â”‚ -                self.p*mdl.mech.meas_position() + np.pi, 2*np.pi) - np.pi
â”‚ â”‚ +                self.n_p*mdl.mech.meas_position() + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          else:
â”‚ â”‚              # Get the rotor speed and position estimates
â”‚ â”‚              w_m, theta_m = self.observer.w_m, self.observer.theta_m
â”‚ â”‚  
â”‚ â”‚          # Get the realized voltage from the PWM method
â”‚ â”‚          u_s = self.pwm.realized_voltage
â”‚ â”‚  
â”‚ â”‚          # Current vector in estimated rotor coordinates
â”‚ â”‚          i_s = np.exp(-1j*theta_m)*abc2complex(i_s_abc)
â”‚ â”‚  
â”‚ â”‚          # Outputs
â”‚ â”‚ -        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.p, w_m/self.p)
â”‚ â”‚ +        tau_M_ref = self.speed_ctrl.output(w_m_ref/self.n_p, w_m/self.n_p)
â”‚ â”‚          i_s_ref, tau_M_ref_lim = self.current_ref.output(tau_M_ref, w_m, u_dc)
â”‚ â”‚          u_s_ref = self.current_ctrl.output(i_s_ref, i_s)
â”‚ â”‚          d_abc_ref, u_s_ref_lim = self.pwm.output(u_s_ref, u_dc, theta_m, w_m)
â”‚ â”‚  
â”‚ â”‚          # Data logging
â”‚ â”‚          data = Bunch(
â”‚ â”‚              i_s=i_s,
â”‚ â”‚ @@ -193,15 +174,14 @@
â”‚ â”‚      .. [1] Awan, Saarakkala, Hinkkanen, "Flux-linkage-based current control of
â”‚ â”‚         saturated synchronous motors," IEEE Trans. Ind. Appl. 2019,
â”‚ â”‚         https://doi.org/10.1109/TIA.2019.2919258
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚ -
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.alpha_c = pars.alpha_c
â”‚ â”‚          # Integral state
â”‚ â”‚          self.u_i = 0
â”‚ â”‚          # Memory for the update method
â”‚ â”‚ @@ -283,18 +263,17 @@
â”‚ â”‚         accurate torque regulation," IEEE Trans. Ind. Appl., 2020,
â”‚ â”‚         https://doi.org/10.1109/TIA.2019.2942807
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚ -
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.i_s_max = pars.i_s_max
â”‚ â”‚ -        self.p = pars.p
â”‚ â”‚ +        self.n_p = pars.n_p
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.psi_f = pars.psi_f
â”‚ â”‚          self.k = pars.alpha_fw/(pars.w_nom*self.L_d)
â”‚ â”‚          self.k_u = pars.k_u
â”‚ â”‚          # Generate LUTs
â”‚ â”‚          tq = TorqueCharacteristics(pars)
â”‚ â”‚ @@ -343,30 +322,30 @@
â”‚ â”‚              return tau_M_ref
â”‚ â”‚  
â”‚ â”‚          # Limit the torque reference according to MTPV and current limits
â”‚ â”‚          tau_M_ref = limit_torque(tau_M_ref, w_m, u_dc)
â”‚ â”‚  
â”‚ â”‚          # q-axis current reference
â”‚ â”‚          psi_t = self.psi_f + (self.L_d - self.L_q)*self.i_sd_ref
â”‚ â”‚ -        i_sq_ref = tau_M_ref/(1.5*self.p*psi_t) if psi_t != 0 else 0
â”‚ â”‚ +        i_sq_ref = tau_M_ref/(1.5*self.n_p*psi_t) if psi_t != 0 else 0
â”‚ â”‚  
â”‚ â”‚          # Limit the q-axis current reference
â”‚ â”‚          i_sd_mtpa = self.i_sd_mtpa(np.abs(tau_M_ref))
â”‚ â”‚          i_sq_max = np.min([
â”‚ â”‚              np.sqrt(self.i_s_max**2 - self.i_sd_ref**2),
â”‚ â”‚              np.sqrt(self.i_s_max**2 - i_sd_mtpa**2)
â”‚ â”‚          ])
â”‚ â”‚          if np.abs(i_sq_ref) > i_sq_max:
â”‚ â”‚              i_sq_ref = np.sign(i_sq_ref)*i_sq_max
â”‚ â”‚  
â”‚ â”‚          # Current reference
â”‚ â”‚          i_s_ref = self.i_sd_ref + 1j*i_sq_ref
â”‚ â”‚  
â”‚ â”‚          # Limited torque (for the speed controller)
â”‚ â”‚ -        tau_M_ref_lim = 1.5*self.p*psi_t*i_sq_ref
â”‚ â”‚ +        tau_M_ref_lim = 1.5*self.n_p*psi_t*i_sq_ref
â”‚ â”‚  
â”‚ â”‚          return i_s_ref, tau_M_ref_lim
â”‚ â”‚  
â”‚ â”‚      def update(self, tau_M_ref_lim, u_s_ref, u_dc):
â”‚ â”‚          """
â”‚ â”‚          Field-weakening based on the unlimited reference voltage.
â”‚ â”‚  
â”‚ â”‚ @@ -413,17 +392,15 @@
â”‚ â”‚      .. [3] Hinkkanen, Saarakkala, Awan, MÃ¶lsÃ¤, Tuovinen, "Observers for
â”‚ â”‚         sensorless synchronous motor drives: Framework for design and analysis,"
â”‚ â”‚         IEEE Trans. Ind. Appl., 2018, https://doi.org/10.1109/TIA.2018.2858753
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, pars):
â”‚ â”‚ -
â”‚ â”‚          self.T_s = pars.T_s
â”‚ â”‚          self.R_s = pars.R_s
â”‚ â”‚          self.L_d = pars.L_d
â”‚ â”‚          self.L_q = pars.L_q
â”‚ â”‚          self.psi_f = pars.psi_f
â”‚ â”‚          self.k_p = 2*pars.w_o
â”‚ â”‚          self.k_i = pars.w_o**2
â”‚ â”‚   --- motulator-0.1.2/motulator/helpers.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/helpers.py
â”‚ â”‚â”„ Files 7% similar despite different names
â”‚ â”‚ @@ -1,12 +1,10 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Helper functions and classes."""
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚ -from __future__ import annotations
â”‚ â”‚  from dataclasses import dataclass
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  def abc2complex(u):
â”‚ â”‚      """
â”‚ â”‚ @@ -70,31 +68,32 @@
â”‚ â”‚  
â”‚ â”‚      Base values are computed from the nominal values and the number of pole
â”‚ â”‚      pairs. They can be used, e.g., for scaling the plotted waveforms.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚ -    U_nom: float
â”‚ â”‚ -    I_nom: float
â”‚ â”‚ -    f_nom: float
â”‚ â”‚ -    P_nom: float
â”‚ â”‚ -    tau_nom: float
â”‚ â”‚ -    p: int
â”‚ â”‚ +    # Nominal values
â”‚ â”‚ +    U_nom: float  # Voltage (rms, line-line)
â”‚ â”‚ +    I_nom: float  # Current (rms)
â”‚ â”‚ +    f_nom: float  # Frequency
â”‚ â”‚ +    P_nom: float  # Power
â”‚ â”‚ +    tau_nom: float  # Torque
â”‚ â”‚ +    n_p: int  # Number of pole pairs
â”‚ â”‚  
â”‚ â”‚      def __post_init__(self):
â”‚ â”‚          """Compute the base values."""
â”‚ â”‚          self.u = np.sqrt(2/3)*self.U_nom
â”‚ â”‚          self.i = np.sqrt(2)*self.I_nom
â”‚ â”‚          self.w = 2*np.pi*self.f_nom
â”‚ â”‚          self.psi = self.u/self.w
â”‚ â”‚ -        self.P = 1.5*self.u*self.i
â”‚ â”‚ +        self.p = 1.5*self.u*self.i
â”‚ â”‚          self.Z = self.u/self.i
â”‚ â”‚          self.L = self.Z/self.w
â”‚ â”‚ -        self.tau = self.p*self.P/self.w
â”‚ â”‚ +        self.tau = self.n_p*self.p/self.w
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class Sequence:
â”‚ â”‚      """
â”‚ â”‚      Sequence generator.
â”‚ â”‚  
â”‚ â”‚ @@ -108,15 +107,14 @@
â”‚ â”‚      values : ndarray
â”‚ â”‚          Output values.
â”‚ â”‚      periodic : bool, optional
â”‚ â”‚          Enables periodicity. The default is False.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, times, values, periodic=False):
â”‚ â”‚          self.times = times
â”‚ â”‚          self.values = values
â”‚ â”‚          if periodic is True:
â”‚ â”‚              self._period = times[-1] - times[0]
â”‚ â”‚          else:
â”‚ â”‚              self._period = None
â”‚ â”‚ @@ -139,15 +137,14 @@
â”‚ â”‚          return np.interp(t, self.times, self.values, period=self._period)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class Step:
â”‚ â”‚      """Step function."""
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, step_time, step_value, initial_value=0):
â”‚ â”‚          self.step_time = step_time
â”‚ â”‚          self.step_value = step_value
â”‚ â”‚          self.initial_value = initial_value
â”‚ â”‚  
â”‚ â”‚      def __call__(self, t):
â”‚ â”‚          """
â”‚ â”‚   --- motulator-0.1.2/motulator/model/converter.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/converter.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Power converter models.
â”‚ â”‚  
â”‚ â”‚  An inverter with constant DC-bus voltage and a frequency converter with a diode
â”‚ â”‚  front-end rectifier are modeled. Complex space vectors are used also for duty
â”‚ â”‚  ratios and switching states, wherever applicable. In this module, all space
â”‚ â”‚  vectors are in stationary coordinates. The default values correspond to a
â”‚ â”‚ @@ -162,15 +161,15 @@
â”‚ â”‚          list, length 2
â”‚ â”‚              Time derivative of the state vector, [du_dc, d_iL]
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Grid phase voltages
â”‚ â”‚          u_g_abc = self.grid_voltages(t)
â”‚ â”‚          # Output voltage of the diode bridge
â”‚ â”‚ -        u_di = np.amax(u_g_abc, 0) - np.amin(u_g_abc, 0)
â”‚ â”‚ +        u_di = np.amax(u_g_abc, axis=0) - np.amin(u_g_abc, axis=0)
â”‚ â”‚          # State derivatives
â”‚ â”‚          du_dc = (i_L - i_dc)/self.C
â”‚ â”‚          di_L = (u_di - u_dc)/self.L
â”‚ â”‚          # The inductor current cannot be negative due to the diode bridge
â”‚ â”‚          if i_L < 0 and di_L < 0:
â”‚ â”‚              di_L = 0
â”‚ â”‚          return [du_dc, di_L]
â”‚ â”‚   --- motulator-0.1.2/motulator/model/im.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/im.py
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -1,33 +1,31 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Continuous-time models for induction motors.
â”‚ â”‚  
â”‚ â”‚  Peak-valued complex space vectors are used. The space vector models are
â”‚ â”‚  implemented in stator coordinates. The default values correspond to a 2.2-kW
â”‚ â”‚  induction motor.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import complex2abc
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class InductionMotor:
â”‚ â”‚      """
â”‚ â”‚      Î“-equivalent model of an induction motor.
â”‚ â”‚  
â”‚ â”‚      An induction motor is modeled using the Î“-equivalent model [1]_. The model
â”‚ â”‚      is implemented in stator coordinates. The flux linkages are used as state
â”‚ â”‚      variables.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      R_r : float
â”‚ â”‚          Rotor resistance.
â”‚ â”‚      L_ell : float
â”‚ â”‚          Leakage inductance.
â”‚ â”‚ @@ -44,17 +42,17 @@
â”‚ â”‚      References
â”‚ â”‚      ----------
â”‚ â”‚      .. [1] Slemon, "Modelling of induction machines for electric drives," IEEE
â”‚ â”‚         Trans. Ind. Appl., 1989, https://doi.org/10.1109/28.44251.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    def __init__(self, p=2, R_s=3.7, R_r=2.5, L_ell=.023, L_s=.245):
â”‚ â”‚ +    def __init__(self, n_p=2, R_s=3.7, R_r=2.5, L_ell=.023, L_s=.245):
â”‚ â”‚          # pylint: disable=too-many-arguments
â”‚ â”‚ -        self.p = p
â”‚ â”‚ +        self.n_p = n_p
â”‚ â”‚          self.R_s, self.R_r = R_s, R_r
â”‚ â”‚          self.L_ell, self.L_s = L_ell, L_s
â”‚ â”‚          # Initial values
â”‚ â”‚          self.psi_ss0, self.psi_rs0 = 0j, 0j
â”‚ â”‚  
â”‚ â”‚      def currents(self, psi_ss, psi_rs):
â”‚ â”‚          """
â”‚ â”‚ @@ -98,15 +96,15 @@
â”‚ â”‚          i_rs : complex
â”‚ â”‚              Rotor current.
â”‚ â”‚          tau_M : float
â”‚ â”‚              Electromagnetic torque.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_ss, i_rs = self.currents(psi_ss, psi_rs)
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_ss*np.conj(psi_ss))
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_ss*np.conj(psi_ss))
â”‚ â”‚  
â”‚ â”‚          return i_ss, i_rs, tau_M
â”‚ â”‚  
â”‚ â”‚      def f(self, psi_ss, psi_rs, u_ss, w_M):
â”‚ â”‚          """
â”‚ â”‚          Compute the state derivatives.
â”‚ â”‚  
â”‚ â”‚ @@ -136,15 +134,15 @@
â”‚ â”‚          output signals (stator current `i_ss` and torque `tau_M`) needed for
â”‚ â”‚          interconnection with other subsystems. This avoids overlapping
â”‚ â”‚          computation in simulation.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_ss, i_rs, tau_M = self.magnetic(psi_ss, psi_rs)
â”‚ â”‚          dpsi_ss = u_ss - self.R_s*i_ss
â”‚ â”‚ -        dpsi_rs = -self.R_r*i_rs + 1j*self.p*w_M*psi_rs
â”‚ â”‚ +        dpsi_rs = -self.R_r*i_rs + 1j*self.n_p*w_M*psi_rs
â”‚ â”‚  
â”‚ â”‚          return [dpsi_ss, dpsi_rs], i_ss, tau_M
â”‚ â”‚  
â”‚ â”‚      def meas_currents(self):
â”‚ â”‚          """
â”‚ â”‚          Measure the phase currents at the end of the sampling period.
â”‚ â”‚  
â”‚ â”‚ @@ -169,15 +167,15 @@
â”‚ â”‚      This extends the InductionMotor class with a main-flux magnetic saturation
â”‚ â”‚      model [2]_::
â”‚ â”‚  
â”‚ â”‚          L_s(psi_ss) = L_su/(1 + (beta*abs(psi_ss)**S)
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      R_r : float
â”‚ â”‚          Rotor resistance.
â”‚ â”‚      L_ell : float
â”‚ â”‚          Leakage inductance.
â”‚ â”‚ @@ -193,17 +191,24 @@
â”‚ â”‚      .. [2] Qu, Ranta, Hinkkanen, Luomi, "Loss-minimizing flux level control of
â”‚ â”‚         induction motor drives," IEEE Trans. Ind. Appl., 2012,
â”‚ â”‚         https://doi.org/10.1109/TIA.2012.2190818
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(
â”‚ â”‚ -            self, p=2, R_s=3.7, R_r=2.5, L_ell=.023, L_su=.34, beta=.84, S=7):
â”‚ â”‚ +            self,
â”‚ â”‚ +            n_p=2,
â”‚ â”‚ +            R_s=3.7,
â”‚ â”‚ +            R_r=2.5,
â”‚ â”‚ +            L_ell=.023,
â”‚ â”‚ +            L_su=.34,
â”‚ â”‚ +            beta=.84,
â”‚ â”‚ +            S=7):
â”‚ â”‚          # pylint: disable=too-many-arguments
â”‚ â”‚ -        super().__init__(p=p, R_s=R_s, R_r=R_r, L_ell=L_ell)
â”‚ â”‚ +        super().__init__(n_p=n_p, R_s=R_s, R_r=R_r, L_ell=L_ell)
â”‚ â”‚          # Saturation model
â”‚ â”‚          self.L_s = lambda psi: L_su/(1. + (beta*np.abs(psi))**S)
â”‚ â”‚  
â”‚ â”‚      def currents(self, psi_ss, psi_rs):
â”‚ â”‚          """Override the base class method."""
â”‚ â”‚          # Saturated value of the stator inductance.
â”‚ â”‚          L_s = self.L_s(psi_ss)
â”‚ â”‚ @@ -220,32 +225,32 @@
â”‚ â”‚  
â”‚ â”‚      This extends the InductionMotor class (based on the Î“ model) by providing
â”‚ â”‚      an interface for the inverse-Î“ model parameters. Linear magnetics are
â”‚ â”‚      assumed. If magnetic saturation is to be modeled, the Î“ model is preferred.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      R_R : float
â”‚ â”‚          Rotor resistance.
â”‚ â”‚      L_sgm : float
â”‚ â”‚          Leakage inductance.
â”‚ â”‚      L_M : float
â”‚ â”‚          Magnetizing inductance.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    def __init__(self, p=2, R_s=3.7, R_R=2.1, L_sgm=.021, L_M=.224):
â”‚ â”‚ +    def __init__(self, n_p=2, R_s=3.7, R_R=2.1, L_sgm=.021, L_M=.224):
â”‚ â”‚          # pylint: disable=too-many-arguments, disable=super-init-not-called
â”‚ â”‚          # Convert the inverse-Î“ parameters to the Î“ parameters
â”‚ â”‚          gamma = L_M/(L_M + L_sgm)  # Magnetic coupling factor
â”‚ â”‚ -        self.p = p
â”‚ â”‚ +        self.n_p = n_p
â”‚ â”‚          self.R_s = R_s
â”‚ â”‚          self.L_s = L_M + L_sgm
â”‚ â”‚          self.L_ell = L_sgm/gamma
â”‚ â”‚          self.R_r = R_R/gamma**2
â”‚ â”‚          # Initial values
â”‚ â”‚          self.psi_ss0 = 0j
â”‚ â”‚          self.psi_rs0 = 0j  # self.psi_rs0 = self.psi_Rs0/gamma
â”‚ â”‚   --- motulator-0.1.2/motulator/model/im_drive.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/im_drive.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Continuous-time models for induction motor drives.
â”‚ â”‚  
â”‚ â”‚  Peak-valued complex space vectors are used. The space vector models are
â”‚ â”‚  implemented in stator coordinates. The default values correspond to a 2.2-kW
â”‚ â”‚  induction motor.
â”‚ â”‚  
â”‚ â”‚ @@ -131,16 +130,16 @@
â”‚ â”‚  
â”‚ â”‚          # Some useful variables
â”‚ â”‚          self.data.i_ss, _, self.data.tau_M = self.motor.magnetic(
â”‚ â”‚              self.data.psi_ss, self.data.psi_rs)
â”‚ â”‚          self.data.theta_M = np.mod(  # Limit into [-pi, pi)
â”‚ â”‚              self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          self.data.theta_m = np.mod(  # Limit into [-pi, pi)
â”‚ â”‚ -            self.motor.p*self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚ -        self.data.w_m = self.motor.p*self.data.w_M
â”‚ â”‚ +            self.motor.n_p*self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚ +        self.data.w_m = self.motor.n_p*self.data.w_M
â”‚ â”‚          self.data.tau_L = (
â”‚ â”‚              self.mech.tau_L_t(self.data.t) + self.mech.tau_L_w(self.data.w_M))
â”‚ â”‚          self.data.u_ss = self.conv.ac_voltage(self.data.q, self.conv.u_dc0)
â”‚ â”‚  
â”‚ â”‚          # Compute the inverse-Î“ rotor flux
â”‚ â”‚          try:
â”‚ â”‚              # Saturable stator inductance
â”‚ â”‚ @@ -217,18 +216,18 @@
â”‚ â”‚          self.data.i_L = np.asarray(self.data.i_L)
â”‚ â”‚          # Some useful variables
â”‚ â”‚          self.data.u_ss = self.conv.ac_voltage(self.data.q, self.data.u_dc)
â”‚ â”‚          self.data.i_dc = self.conv.dc_current(self.data.q, self.data.i_ss)
â”‚ â”‚          u_g_abc = self.conv.grid_voltages(self.data.t)
â”‚ â”‚          self.data.u_g = abc2complex(u_g_abc)
â”‚ â”‚          # Voltage at the output of the diode bridge
â”‚ â”‚ -        self.data.u_di = np.amax(u_g_abc, 0) - np.amin(u_g_abc, 0)
â”‚ â”‚ +        self.data.u_di = np.amax(u_g_abc, axis=0) - np.amin(u_g_abc, axis=0)
â”‚ â”‚          # Diode briddge switching states (-1, 0, 1)
â”‚ â”‚ -        q_g_abc = ((np.amax(u_g_abc, 0) == u_g_abc).astype(int) -
â”‚ â”‚ -                   (np.amin(u_g_abc, 0) == u_g_abc).astype(int))
â”‚ â”‚ +        q_g_abc = ((np.amax(u_g_abc, axis=0) == u_g_abc).astype(int) -
â”‚ â”‚ +                   (np.amin(u_g_abc, axis=0) == u_g_abc).astype(int))
â”‚ â”‚          # Grid current space vector
â”‚ â”‚          self.data.i_g = abc2complex(q_g_abc)*self.data.i_L
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class InductionMotorDriveTwoMass(InductionMotorDrive):
â”‚ â”‚      """
â”‚ â”‚ @@ -250,28 +249,29 @@
â”‚ â”‚  
â”‚ â”‚      def __init__(self, motor=None, mech=None, conv=None):
â”‚ â”‚          super().__init__(motor=motor, mech=mech, conv=conv)
â”‚ â”‚          self.data.w_L, self.data.theta_ML = [], []
â”‚ â”‚  
â”‚ â”‚      def get_initial_values(self):
â”‚ â”‚          """Extend the base class."""
â”‚ â”‚ -        x0 = super().get_initial_values() + [self.mech.w_L0,
â”‚ â”‚ -                                             self.mech.theta_ML0]
â”‚ â”‚ +        x0 = super().get_initial_values() + [
â”‚ â”‚ +            self.mech.w_L0, self.mech.theta_ML0
â”‚ â”‚ +        ]
â”‚ â”‚          return x0
â”‚ â”‚  
â”‚ â”‚      def set_initial_values(self, t0, x0):
â”‚ â”‚          """Extend the base class."""
â”‚ â”‚          super().set_initial_values(t0, x0[0:4])
â”‚ â”‚          self.mech.w_L0 = x0[4].real
â”‚ â”‚          self.mech.theta_ML0 = np.mod(x0[5].real + np.pi, 2*np.pi) - np.pi
â”‚ â”‚  
â”‚ â”‚      def f(self, t, x):
â”‚ â”‚          """Override the base class."""
â”‚ â”‚          # Unpack the states
â”‚ â”‚ -        psi_ss, psi_rs, w_M, theta_M, w_L, theta_ML = x
â”‚ â”‚ +        psi_ss, psi_rs, w_M, _, w_L, theta_ML = x
â”‚ â”‚          # Interconnections: outputs for computing the state derivatives
â”‚ â”‚          u_ss = self.conv.ac_voltage(self.conv.q, self.conv.u_dc0)
â”‚ â”‚          # State derivatives plus the outputs for interconnections
â”‚ â”‚          motor_f, _, tau_M = self.motor.f(psi_ss, psi_rs, u_ss, w_M)
â”‚ â”‚          mech_f = self.mech.f(t, w_M, w_L, theta_ML, tau_M)
â”‚ â”‚          # List of state derivatives
â”‚ â”‚          return motor_f + mech_f
â”‚ â”‚   --- motulator-0.1.2/motulator/model/mech.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/mech.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Continuous-time models for mechanical subsystems."""
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class Mechanics:
â”‚ â”‚      """
â”‚ â”‚      Mechanics subsystem.
â”‚ â”‚ @@ -107,16 +106,22 @@
â”‚ â”‚          tau_L_w = b*w_L, where b is the viscous friction coefficient.
â”‚ â”‚      tau_L_t : function
â”‚ â”‚          Load torque as a function of time, `tau_L_t(t)`.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚ -    def __init__(self, J_M=.005, J_L=.005, K_S=700., C_S=.13,
â”‚ â”‚ -                 tau_L_w=lambda w_M: 0, tau_L_t=lambda t: 0):
â”‚ â”‚ +    def __init__(
â”‚ â”‚ +            self,
â”‚ â”‚ +            J_M=.005,
â”‚ â”‚ +            J_L=.005,
â”‚ â”‚ +            K_S=700.,
â”‚ â”‚ +            C_S=.13,
â”‚ â”‚ +            tau_L_w=lambda w_M: 0,
â”‚ â”‚ +            tau_L_t=lambda t: 0):
â”‚ â”‚          # pylint: disable=too-many-arguments
â”‚ â”‚          # pylint: disable=super-init-not-called
â”‚ â”‚          self.J_M = J_M
â”‚ â”‚          self.J_L = J_L
â”‚ â”‚          self.K_S = K_S
â”‚ â”‚          self.C_S = C_S
â”‚ â”‚          self.tau_L_t = tau_L_t
â”‚ â”‚   --- motulator-0.1.2/motulator/model/sm.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/sm.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -1,8 +1,7 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Continuous-time models for synchronous motors.
â”‚ â”‚  
â”‚ â”‚  The motor models can be parametrized to represent permanent-magnet synchronous
â”‚ â”‚  motors and synchronous reluctance motors. Peak-valued complex space vectors are
â”‚ â”‚  used.
â”‚ â”‚  
â”‚ â”‚ @@ -20,15 +19,15 @@
â”‚ â”‚  
â”‚ â”‚      This models a synchronous motor in rotor coordinates. The stator flux
â”‚ â”‚      linkage is the state variable. The default values correspond to a 2.2-kW
â”‚ â”‚      permanent-magnet synchronous motor.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      L_d : float
â”‚ â”‚          d-axis inductance.
â”‚ â”‚      L_q : float
â”‚ â”‚          q-axis inductance.
â”‚ â”‚ @@ -37,17 +36,17 @@
â”‚ â”‚      mech : Mechanics
â”‚ â”‚          Model of the mechanical subsystem, needed only for the coordinate
â”‚ â”‚          transformation in the measure_currents method.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      def __init__(
â”‚ â”‚ -            self, p=3, R_s=3.6, L_d=.036, L_q=.051, psi_f=.545, mech=None):
â”‚ â”‚ +            self, n_p=3, R_s=3.6, L_d=.036, L_q=.051, psi_f=.545, mech=None):
â”‚ â”‚          # pylint: disable=too-many-arguments
â”‚ â”‚ -        self.p, self.R_s = p, R_s
â”‚ â”‚ +        self.n_p, self.R_s = n_p, R_s
â”‚ â”‚          self.L_d, self.L_q, self.psi_f = L_d, L_q, psi_f
â”‚ â”‚          # Initial value
â”‚ â”‚          self.psi_s0 = self.psi_f + 0j
â”‚ â”‚          # For the coordinate transformation
â”‚ â”‚          self._mech = mech
â”‚ â”‚  
â”‚ â”‚      def current(self, psi_s):
â”‚ â”‚ @@ -82,15 +81,15 @@
â”‚ â”‚          i_s : complex
â”‚ â”‚              Stator current.
â”‚ â”‚          tau_M : float
â”‚ â”‚              Electromagnetic torque.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_s = self.current(psi_s)
â”‚ â”‚ -        tau_M = 1.5*self.p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚ +        tau_M = 1.5*self.n_p*np.imag(i_s*np.conj(psi_s))
â”‚ â”‚          return i_s, tau_M
â”‚ â”‚  
â”‚ â”‚      def f(self, psi_s, u_s, w_M):
â”‚ â”‚          """
â”‚ â”‚          Compute the state derivative.
â”‚ â”‚  
â”‚ â”‚          Parameters
â”‚ â”‚ @@ -116,29 +115,29 @@
â”‚ â”‚          In addition to the state derivative, this method also returns the
â”‚ â”‚          output signals (stator current `i_ss` and torque `tau_M`) needed for
â”‚ â”‚          interconnection with other subsystems. This avoids overlapping
â”‚ â”‚          computation in simulation.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_s, tau_M = self.magnetic(psi_s)
â”‚ â”‚ -        dpsi_s = u_s - self.R_s*i_s - 1j*self.p*w_M*psi_s
â”‚ â”‚ +        dpsi_s = u_s - self.R_s*i_s - 1j*self.n_p*w_M*psi_s
â”‚ â”‚          return [dpsi_s], i_s, tau_M
â”‚ â”‚  
â”‚ â”‚      def meas_currents(self):
â”‚ â”‚          """
â”‚ â”‚          Measure the phase currents at the end of the sampling period.
â”‚ â”‚  
â”‚ â”‚          Returns
â”‚ â”‚          -------
â”‚ â”‚          i_s_abc : 3-tuple of floats
â”‚ â”‚              Phase currents.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          i_s0 = self.current(self.psi_s0)
â”‚ â”‚ -        theta_m0 = self.p*self._mech.theta_M0
â”‚ â”‚ +        theta_m0 = self.n_p*self._mech.theta_M0
â”‚ â”‚          i_s_abc = complex2abc(np.exp(1j*theta_m0)*i_s0)
â”‚ â”‚          return i_s_abc
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class SynchronousMotorSaturated(SynchronousMotor):
â”‚ â”‚      """
â”‚ â”‚ @@ -147,15 +146,15 @@
â”‚ â”‚      This extends the SynchronousMotor class with an analytical saturation
â”‚ â”‚      model [1]_, [2]_. The permanent magnets (PMs) are assumed to be along the
â”‚ â”‚      d-axis. The default values correspond to a 6.7-kW synchronous reluctance
â”‚ â”‚      motor.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      i_f : float
â”‚ â”‚          Constant current corresponding to the magnetomotive force (MMF) of PMs.
â”‚ â”‚          In the magnetically linear case, `i_f = psi_f/L_d`.
â”‚ â”‚      a_d0 : float
â”‚ â”‚ @@ -213,42 +212,43 @@
â”‚ â”‚         Appl., 2009, https://doi.org/10.1109/TIA.2008.2009493
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-instance-attributes
â”‚ â”‚      def __init__(
â”‚ â”‚          self,
â”‚ â”‚ -        p=2,
â”‚ â”‚ +        n_p=2,
â”‚ â”‚          R_s=.54,
â”‚ â”‚          i_f=0,
â”‚ â”‚          a_d0=17.4,
â”‚ â”‚          a_q0=52.1,
â”‚ â”‚          a_dd=373.,
â”‚ â”‚          a_qq=658.,
â”‚ â”‚          a_dq=1120.,
â”‚ â”‚          S=5,
â”‚ â”‚          T=1,
â”‚ â”‚          U=1,
â”‚ â”‚          V=0,
â”‚ â”‚          mech=None,
â”‚ â”‚      ):
â”‚ â”‚          # pylint: disable=too-many-arguments, disable=super-init-not-called
â”‚ â”‚ -        self.p, self.R_s = p, R_s
â”‚ â”‚ +        self.n_p, self.R_s = n_p, R_s
â”‚ â”‚          self.i_f, self.a_d0, self.a_q0 = i_f, a_d0, a_q0
â”‚ â”‚          self.a_dd, self.a_qq, self.a_dq = a_dd, a_qq, a_dq
â”‚ â”‚          self.S, self.T, self.U, self.V = S, T, U, V
â”‚ â”‚  
â”‚ â”‚          # Initial value of the stator flux
â”‚ â”‚          if i_f == 0:
â”‚ â”‚              # No magnets
â”‚ â”‚              self.psi_s0 = 0j
â”‚ â”‚          else:
â”‚ â”‚              # Solve the stator flux caused by the magnets @ i_s = 0
â”‚ â”‚              res = minimize_scalar(
â”‚ â”‚ -                lambda psi_d: np.abs((a_d0 + a_dd*np.abs(psi_d)**S)*psi_d - i_f))
â”‚ â”‚ +                lambda psi_d: np.abs(
â”‚ â”‚ +                    (a_d0 + a_dd*np.abs(psi_d)**S)*psi_d - i_f))
â”‚ â”‚              self.psi_s0 = complex(res.x)
â”‚ â”‚              print(self.psi_s0)
â”‚ â”‚  
â”‚ â”‚          # For the coordinate transformation
â”‚ â”‚          self._mech = mech
â”‚ â”‚  
â”‚ â”‚      def current(self, psi_s):
â”‚ â”‚ @@ -276,15 +276,15 @@
â”‚ â”‚      This extends the SynchronousMotor class with a saturation model, where the
â”‚ â”‚      stator current depends on the stator flux linkage. The coordinates assume
â”‚ â”‚      the PMSM convention, i.e., that the PM flux is along the d-axis.
â”‚ â”‚      Unstructured flux map data can be used.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚ -    p : int
â”‚ â”‚ +    n_p : int
â”‚ â”‚          Number of pole pairs.
â”‚ â”‚      R_s : float
â”‚ â”‚          Stator resistance.
â”‚ â”‚      psi_s_data : ndarray of complex
â”‚ â”‚          Stator flux data points for creating the interpolant.
â”‚ â”‚      i_s_data : ndarray of complex
â”‚ â”‚          Stator current data values for creating the interpolant.
â”‚ â”‚ @@ -292,26 +292,27 @@
â”‚ â”‚          Model of the mechanical subsystem, needed only for the coordinate
â”‚ â”‚          transformation in the measure_currents method.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      # pylint: disable=too-many-arguments, disable=super-init-not-called
â”‚ â”‚      def __init__(
â”‚ â”‚ -            self, p=2, R_s=.20, psi_s_data=None, i_s_data=None, mech=None):
â”‚ â”‚ +            self, n_p=2, R_s=.20, psi_s_data=None, i_s_data=None, mech=None):
â”‚ â”‚  
â”‚ â”‚ -        self.p, self.R_s = p, R_s
â”‚ â”‚ +        self.n_p, self.R_s = n_p, R_s
â”‚ â”‚  
â”‚ â”‚          # Create the interpolant
â”‚ â”‚          self.i_s = LinearNDInterpolator(
â”‚ â”‚              list(zip(psi_s_data.real, psi_s_data.imag)), i_s_data)
â”‚ â”‚  
â”‚ â”‚          # Solve the PM flux for the initial value of the stator flux
â”‚ â”‚ -        res = minimize_scalar(lambda psi_d: np.abs(self.i_s(psi_d, 0)),
â”‚ â”‚ -                              bounds=(0, np.max(psi_s_data.real)),
â”‚ â”‚ -                              method='bounded')
â”‚ â”‚ +        res = minimize_scalar(
â”‚ â”‚ +            lambda psi_d: np.abs(self.i_s(psi_d, 0)),
â”‚ â”‚ +            bounds=(0, np.max(psi_s_data.real)),
â”‚ â”‚ +            method='bounded')
â”‚ â”‚          self.psi_s0 = complex(res.x)
â”‚ â”‚  
â”‚ â”‚          # For the coordinate transformation
â”‚ â”‚          self._mech = mech
â”‚ â”‚  
â”‚ â”‚      def current(self, psi_s):
â”‚ â”‚          """Override the base class method."""
â”‚ â”‚   --- motulator-0.1.2/motulator/model/sm_drive.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/sm_drive.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,17 +1,15 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """
â”‚ â”‚  Continuous-time models for synchronous motor drives.
â”‚ â”‚  
â”‚ â”‚  Peak-valued complex space vectors are used. The default values correspond to a
â”‚ â”‚  2.2-kW permanent-magnet synchronous motor.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import Bunch
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class SynchronousMotorDrive:
â”‚ â”‚      """
â”‚ â”‚      Continuous-time model for a synchronous motor drive.
â”‚ â”‚ @@ -47,15 +45,15 @@
â”‚ â”‚  
â”‚ â”‚      def get_initial_values(self):
â”‚ â”‚          """
â”‚ â”‚          Get the initial values.
â”‚ â”‚  
â”‚ â”‚          Returns
â”‚ â”‚          -------
â”‚ â”‚ -        x0 : complex list, length 2
â”‚ â”‚ +        x0 : complex list, length 3
â”‚ â”‚              Initial values of the state variables.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          x0 = [
â”‚ â”‚              self.motor.psi_s0,
â”‚ â”‚              self.mech.w_M0,
â”‚ â”‚              self.mech.theta_M0,
â”‚ â”‚ @@ -94,15 +92,15 @@
â”‚ â”‚          -------
â”‚ â”‚          complex list
â”‚ â”‚              State derivatives.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          # Unpack the states
â”‚ â”‚          psi_s, w_M, theta_M = x
â”‚ â”‚ -        theta_m = self.motor.p*theta_M
â”‚ â”‚ +        theta_m = self.motor.n_p*theta_M
â”‚ â”‚  
â”‚ â”‚          # Interconnections: outputs for computing the state derivatives
â”‚ â”‚          u_ss = self.conv.ac_voltage(self.conv.q, self.conv.u_dc0)
â”‚ â”‚          u_s = np.exp(-1j*theta_m)*u_ss  # Stator voltage in rotor coordinates
â”‚ â”‚  
â”‚ â”‚          # State derivatives
â”‚ â”‚          motor_f, _, tau_M = self.motor.f(psi_s, u_s, w_M)
â”‚ â”‚ @@ -131,22 +129,22 @@
â”‚ â”‚          """Transform the lists to the ndarray format and post-process them."""
â”‚ â”‚          # From lists to the ndarray
â”‚ â”‚          for key in self.data:
â”‚ â”‚              self.data[key] = np.asarray(self.data[key])
â”‚ â”‚  
â”‚ â”‚          # Compute some useful quantities
â”‚ â”‚          self.data.i_s, self.data.tau_M = self.motor.magnetic(self.data.psi_s)
â”‚ â”‚ -        self.data.w_m = self.motor.p*self.data.w_M
â”‚ â”‚ +        self.data.w_m = self.motor.n_p*self.data.w_M
â”‚ â”‚          self.data.tau_L = (
â”‚ â”‚              self.mech.tau_L_t(self.data.t) + self.mech.tau_L_w(self.data.w_M))
â”‚ â”‚          self.data.u_ss = self.conv.ac_voltage(self.data.q, self.conv.u_dc0)
â”‚ â”‚          self.data.theta_M = np.mod(  # Limit into [-pi, pi)
â”‚ â”‚              self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          self.data.theta_m = np.mod(  # Limit into [-pi, pi)
â”‚ â”‚ -            self.motor.p*self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚ +            self.motor.n_p*self.data.theta_M + np.pi, 2*np.pi) - np.pi
â”‚ â”‚          self.data.i_ss = self.data.i_s*np.exp(1j*self.data.theta_m)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class SynchronousMotorDriveTwoMass(SynchronousMotorDrive):
â”‚ â”‚      """
â”‚ â”‚      Synchronous motor drive with two-mass mechanics.
â”‚ â”‚ @@ -167,29 +165,30 @@
â”‚ â”‚  
â”‚ â”‚      def __init__(self, motor=None, mech=None, conv=None):
â”‚ â”‚          super().__init__(motor=motor, mech=mech, conv=conv)
â”‚ â”‚          self.data.w_L, self.data.theta_ML = [], []
â”‚ â”‚  
â”‚ â”‚      def get_initial_values(self):
â”‚ â”‚          """Extend the base class."""
â”‚ â”‚ -        x0 = super().get_initial_values() + [self.mech.w_L0,
â”‚ â”‚ -                                             self.mech.theta_ML0]
â”‚ â”‚ +        x0 = super().get_initial_values() + [
â”‚ â”‚ +            self.mech.w_L0, self.mech.theta_ML0
â”‚ â”‚ +        ]
â”‚ â”‚          return x0
â”‚ â”‚  
â”‚ â”‚      def set_initial_values(self, t0, x0):
â”‚ â”‚          """Extend the base class."""
â”‚ â”‚          super().set_initial_values(t0, x0[0:3])
â”‚ â”‚          self.mech.w_L0 = x0[3].real
â”‚ â”‚          self.mech.theta_ML0 = np.mod(x0[4].real + np.pi, 2*np.pi) - np.pi
â”‚ â”‚  
â”‚ â”‚      def f(self, t, x):
â”‚ â”‚          """Override the base class."""
â”‚ â”‚          # Unpack the states
â”‚ â”‚          psi_s, w_M, theta_M, w_L, theta_ML = x
â”‚ â”‚ -        theta_m = self.motor.p*theta_M
â”‚ â”‚ +        theta_m = self.motor.n_p*theta_M
â”‚ â”‚          # Interconnections: outputs for computing the state derivatives
â”‚ â”‚          u_ss = self.conv.ac_voltage(self.conv.q, self.conv.u_dc0)
â”‚ â”‚          u_s = np.exp(-1j*theta_m)*u_ss  # Stator voltage in rotor coordinates
â”‚ â”‚          # State derivatives plus the outputs for interconnections
â”‚ â”‚          motor_f, _, tau_M = self.motor.f(psi_s, u_s, w_M)
â”‚ â”‚          mech_f = self.mech.f(t, w_M, w_L, theta_ML, tau_M)
â”‚ â”‚          # List of state derivatives
â”‚ â”‚   --- motulator-0.1.2/motulator/model/sm_flux_maps.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/model/sm_flux_maps.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,23 +1,22 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Import and plot flux maps from the SyR-e project."""
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  import numpy as np
â”‚ â”‚  import matplotlib.pyplot as plt
â”‚ â”‚  from cycler import cycler
â”‚ â”‚  from scipy.io import loadmat
â”‚ â”‚  from scipy.interpolate import griddata
â”‚ â”‚  from motulator.helpers import Bunch
â”‚ â”‚  
â”‚ â”‚  # Plotting parameters
â”‚ â”‚  plt.rcParams['axes.prop_cycle'] = cycler(color='brgcmyk')
â”‚ â”‚  plt.rcParams['lines.linewidth'] = 1.
â”‚ â”‚  plt.rcParams['axes.grid'] = True
â”‚ â”‚ -plt.rcParams.update({"text.usetex": False})
â”‚ â”‚ +plt.rcParams.update({'text.usetex': False})
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  def import_syre_data(fname='THOR.mat', add_negative_q_axis=True):
â”‚ â”‚      """
â”‚ â”‚      Import a flux map from the MATLAB data file in the SyR-e format.
â”‚ â”‚   --- motulator-0.1.2/motulator/plots.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/plots.py
â”‚ â”‚â”„ Files 0% similar despite different names
â”‚ â”‚ @@ -1,15 +1,13 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Example plotting scripts."""
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  import numpy as np
â”‚ â”‚  import matplotlib.pyplot as plt
â”‚ â”‚  from cycler import cycler
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import Bunch, complex2abc
â”‚ â”‚  
â”‚ â”‚  # Plotting parameters
â”‚ â”‚  plt.rcParams['axes.prop_cycle'] = cycler(color='brgcmyk')
â”‚ â”‚  plt.rcParams['lines.linewidth'] = 1.
â”‚ â”‚  plt.rcParams['axes.grid'] = True
â”‚ â”‚  plt.rcParams.update({"text.usetex": False})
â”‚ â”‚   --- motulator-0.1.2/motulator/simulation.py
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator/simulation.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,14 +1,12 @@
â”‚ â”‚ -# pylint: disable=invalid-name
â”‚ â”‚  """Simulation environment."""
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚  from scipy.integrate import solve_ivp
â”‚ â”‚  from scipy.io import savemat
â”‚ â”‚ -
â”‚ â”‚  from motulator.helpers import abc2complex
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # %%
â”‚ â”‚  class Delay:
â”‚ â”‚      """
â”‚ â”‚      Computational delay.
â”‚ â”‚ @@ -18,15 +16,14 @@
â”‚ â”‚      Parameters
â”‚ â”‚      ----------
â”‚ â”‚      length : int, optional
â”‚ â”‚          Length of the buffer in samples. The default is 1.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, length=1, elem=3):
â”‚ â”‚          self.data = length*[elem*[0]]  # Creates a zero list
â”‚ â”‚  
â”‚ â”‚      def __call__(self, u):
â”‚ â”‚          """
â”‚ â”‚          Delay the input.
â”‚ â”‚  
â”‚ â”‚ @@ -100,15 +97,14 @@
â”‚ â”‚      array([[0, 0, 0],
â”‚ â”‚             [0, 0, 0],
â”‚ â”‚             [0, 0, 0],
â”‚ â”‚             [1, 1, 1]])
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # pylint: disable=too-few-public-methods
â”‚ â”‚      def __init__(self, N=2**12, return_complex=True):
â”‚ â”‚          self.N = N
â”‚ â”‚          self.return_complex = return_complex
â”‚ â”‚          self.rising_edge = True  # Stores the carrier direction
â”‚ â”‚  
â”‚ â”‚      def __call__(self, T_s, d_abc):
â”‚ â”‚          """
â”‚ â”‚ @@ -229,15 +225,15 @@
â”‚ â”‚          Other options of solve_ivp could be easily changed if needed, but, for
â”‚ â”‚          simplicity, only max_step is included as an option of this method.
â”‚ â”‚  
â”‚ â”‚          """
â”‚ â”‚          try:
â”‚ â”‚              self.simulation_loop(t_stop, max_step)
â”‚ â”‚          except FloatingPointError:
â”‚ â”‚ -            print('Invalid value encountered at %.2f seconds.' % self.mdl.t0)
â”‚ â”‚ +            print(f'Invalid value encountered at {self.mdl.t0:.2f} seconds.')
â”‚ â”‚          # Call the post-processing functions
â”‚ â”‚          self.mdl.post_process()
â”‚ â”‚          self.ctrl.post_process()
â”‚ â”‚  
â”‚ â”‚      @np.errstate(invalid='raise')
â”‚ â”‚      def simulation_loop(self, t_stop, max_step):
â”‚ â”‚          """Run the main simulation loop."""
â”‚ â”‚   --- motulator-0.1.2/motulator.egg-info/PKG-INFO
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator.egg-info/PKG-INFO
â”‚ â”‚â”„ Files 10% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: motulator
â”‚ â”‚ -Version: 0.1.2
â”‚ â”‚ +Version: 0.1.3
â”‚ â”‚  Summary: Motor Drive Simulator in Python
â”‚ â”‚  Home-page: https://github.com/Aalto-Electric-Drives/motulator
â”‚ â”‚  Author: Marko Hinkkanen
â”‚ â”‚  Author-email: marko.hinkkanen@aalto.fi
â”‚ â”‚  Project-URL: Bug Tracker, https://github.com/Aalto-Electric-Drives/motulator/issues
â”‚ â”‚  Classifier: Programming Language :: Python :: 3
â”‚ â”‚  Classifier: License :: OSI Approved :: MIT License
â”‚ â”‚ @@ -71,26 +71,27 @@
â”‚ â”‚  
â”‚ â”‚  <!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
â”‚ â”‚  <!-- prettier-ignore-start -->
â”‚ â”‚  <!-- markdownlint-disable -->
â”‚ â”‚  <table>
â”‚ â”‚    <tbody>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/lauritapio"><img src="https://avatars.githubusercontent.com/u/85596019?v=4?s=50" width="50px;" alt="Lauri Tiitinen"/><br /><sub><b>Lauri Tiitinen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=lauritapio" title="Code">ğŸ’»</a> <a href="#ideas-lauritapio" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-lauritapio" title="Examples">ğŸ’¡</a> <a href="#mentoring-lauritapio" title="Mentoring">ğŸ§‘â€ğŸ«</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/HannuHar"><img src="https://avatars.githubusercontent.com/u/96597650?v=4?s=50" width="50px;" alt="HannuHar"/><br /><sub><b>HannuHar</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=HannuHar" title="Code">ğŸ’»</a> <a href="https://github.com/Aalto-Electric-Drives/motulator/issues?q=author%3AHannuHar" title="Bug reports">ğŸ›</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://research.aalto.fi/en/persons/marko-hinkkanen"><img src="https://avatars.githubusercontent.com/u/76600872?v=4?s=50" width="50px;" alt="Marko Hinkkanen"/><br /><sub><b>Marko Hinkkanen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=mhinkkan" title="Code">ğŸ’»</a> <a href="#ideas-mhinkkan" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#example-mhinkkan" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/silundbe"><img src="https://avatars.githubusercontent.com/u/81169347?v=4?s=50" width="50px;" alt="silundbe"/><br /><sub><b>silundbe</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=silundbe" title="Code">ğŸ’»</a> <a href="#example-silundbe" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/JoonaKukkonen"><img src="https://avatars.githubusercontent.com/u/85099403?v=4?s=50" width="50px;" alt="JoonaKukkonen"/><br /><sub><b>JoonaKukkonen</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=JoonaKukkonen" title="Code">ğŸ’»</a> <a href="#infra-JoonaKukkonen" title="Infrastructure (Hosting, Build-Tools, etc)">ğŸš‡</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jarno-k"><img src="https://avatars.githubusercontent.com/u/84438313?v=4?s=50" width="50px;" alt="jarno-k"/><br /><sub><b>jarno-k</b></sub></a><br /><a href="#ideas-jarno-k" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/angelicaiaderosa"><img src="https://avatars.githubusercontent.com/u/112799415?v=4?s=50" width="50px;" alt="angelicaiaderosa"/><br /><sub><b>angelicaiaderosa</b></sub></a><br /><a href="https://github.com/Aalto-Electric-Drives/motulator/commits?author=angelicaiaderosa" title="Code">ğŸ’»</a> <a href="#example-angelicaiaderosa" title="Examples">ğŸ’¡</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚      <tr>
â”‚ â”‚ -      <td align="center"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ -      <td align="center"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://www.kth.se/profile/lucap"><img src="https://avatars.githubusercontent.com/u/64190518?v=4?s=50" width="50px;" alt="Luca Peretti"/><br /><sub><b>Luca Peretti</b></sub></a><br /><a href="#ideas-lucaperetti" title="Ideas, Planning, & Feedback">ğŸ¤”</a> <a href="#promotion-lucaperetti" title="Promotion">ğŸ“£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/GianmarioPellegrinoPolito"><img src="https://avatars.githubusercontent.com/u/70333484?v=4?s=50" width="50px;" alt="GianmarioPellegrinoPolito"/><br /><sub><b>GianmarioPellegrinoPolito</b></sub></a><br /><a href="#data-GianmarioPellegrinoPolito" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/SimFerr"><img src="https://avatars.githubusercontent.com/u/67151973?v=4?s=50" width="50px;" alt="Simone Ferrari"/><br /><sub><b>Simone Ferrari</b></sub></a><br /><a href="#data-SimFerr" title="Data">ğŸ”£</a></td>
â”‚ â”‚ +      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Jialed0303"><img src="https://avatars.githubusercontent.com/u/118135952?v=4?s=50" width="50px;" alt="Jialed0303"/><br /><sub><b>Jialed0303</b></sub></a><br /><a href="#ideas-Jialed0303" title="Ideas, Planning, & Feedback">ğŸ¤”</a></td>
â”‚ â”‚      </tr>
â”‚ â”‚    </tbody>
â”‚ â”‚  </table>
â”‚ â”‚  
â”‚ â”‚  <!-- markdownlint-restore -->
â”‚ â”‚  <!-- prettier-ignore-end -->
â”‚ â”‚ â”œâ”€â”€ html2text {}
â”‚ â”‚ â”‚ @@ -1,8 +1,8 @@
â”‚ â”‚ â”‚ -Metadata-Version: 2.1 Name: motulator Version: 0.1.2 Summary: Motor Drive
â”‚ â”‚ â”‚ +Metadata-Version: 2.1 Name: motulator Version: 0.1.3 Summary: Motor Drive
â”‚ â”‚ â”‚  Simulator in Python Home-page: https://github.com/Aalto-Electric-Drives/
â”‚ â”‚ â”‚  motulator Author: Marko Hinkkanen Author-email: marko.hinkkanen@aalto.fi
â”‚ â”‚ â”‚  Project-URL: Bug Tracker, https://github.com/Aalto-Electric-Drives/motulator/
â”‚ â”‚ â”‚  issues Classifier: Programming Language :: Python :: 3 Classifier: License ::
â”‚ â”‚ â”‚  OSI Approved :: MIT License Classifier: Operating System :: OS Independent
â”‚ â”‚ â”‚  Requires-Python: >=3.6 Description-Content-Type: text/markdown License-File:
â”‚ â”‚ â”‚  LICENSE # *motulator:* Motor Drive Simulator in Python [![Build Status](https:/
â”‚ â”‚ â”‚ @@ -40,17 +40,17 @@
â”‚ â”‚ â”‚  have a look at these [guidelines](https://github.com/Aalto-Electric-Drives/
â”‚ â”‚ â”‚  motulator/blob/main/CONTRIBUTING.md) first. Contributors ------------ Thanks go
â”‚ â”‚ â”‚  to these wonderful people:
â”‚ â”‚ â”‚                  [Lauri_Tiitinen]                          [HannuHar]              [Marko_Hinkkanen]         [silundbe]      [JoonaKukkonen]  [jarno-  [angelicaiaderosa]
â”‚ â”‚ â”‚                   Lauri_Tiitinen                            HannuHar                Marko_Hinkkanen           silundbe        JoonaKukkonen      k]     angelicaiaderosa
â”‚ â”‚ â”‚             Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ÂŸÂ’Â¡ Ã°ÂŸÂ§Â‘Ã¢Â€         Ã°ÂŸÂ’Â» Ã°ÂŸÂÂ›        Ã°ÂŸÂ’Â» Ã°ÂŸÂ¤Â” Ã°ï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½    Ã°ÂŸÂ’Â» Ã°ÂŸï¿½jarno-k      Ã°ÂŸÂ’Â» Ã°ÂŸÂ’Â¡
â”‚ â”‚ â”‚                                                                                                                                                 Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚ -                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]
â”‚ â”‚ â”‚ -                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari
â”‚ â”‚ â”‚ -                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£
â”‚ â”‚ â”‚ +                       [Luca_Peretti]             [GianmarioPellegrinoPolito]        [Simone_Ferrari]       [Jialed0303]
â”‚ â”‚ â”‚ +                        Luca_Peretti               GianmarioPellegrinoPolito          Simone_Ferrari         Jialed0303
â”‚ â”‚ â”‚ +                          Ã°ÂŸÂ¤Â” Ã°ÂŸÂ“Â£                  Ã°ÂŸÂ”Â£                      Ã°ÂŸÂ”Â£             Ã°ÂŸÂ¤Â”
â”‚ â”‚ â”‚     This project follows the [all-contributors](https://github.com/all-
â”‚ â”‚ â”‚  contributors/all-contributors) specification. Contributions of any kind
â”‚ â”‚ â”‚  welcome! Acknowledgement --------------- This project has been sponsored by ABB
â”‚ â”‚ â”‚  Oy and by the Academy of Finland *Centre of Excellence in High-Speed
â”‚ â”‚ â”‚  Electromechanical Energy Conversion Systems*. The example control methods
â”‚ â”‚ â”‚  included in this repository are based on published algorithms (available in
â”‚ â”‚ â”‚  textbooks and scientific articles). They do not present any proprietary control
â”‚ â”‚   --- motulator-0.1.2/motulator.egg-info/SOURCES.txt
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/motulator.egg-info/SOURCES.txt
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- motulator-0.1.2/setup.cfg
â”‚ â”œâ”€â”€ +++ motulator-0.1.3/setup.cfg
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  [metadata]
â”‚ â”‚  name = motulator
â”‚ â”‚ -version = 0.1.2
â”‚ â”‚ +version = 0.1.3
â”‚ â”‚  author = Marko Hinkkanen
â”‚ â”‚  author_email = marko.hinkkanen@aalto.fi
â”‚ â”‚  description = Motor Drive Simulator in Python
â”‚ â”‚  long_description = file: README.md
â”‚ â”‚  long_description_content_type = text/markdown
â”‚ â”‚  url = https://github.com/Aalto-Electric-Drives/motulator
â”‚ â”‚  project_urls =
