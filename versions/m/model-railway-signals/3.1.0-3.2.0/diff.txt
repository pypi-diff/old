--- tmp/model-railway-signals-3.1.0.tar.gz
+++ tmp/model-railway-signals-3.2.0.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "dist/model-railway-signals-3.1.0.tar", last modified: Sun Dec 11 12:14:54 2022, max compression
│ +gzip compressed data, was "dist/model-railway-signals-3.2.0.tar", last modified: Thu Apr  6 13:26:44 2023, max compression
│   --- model-railway-signals-3.1.0.tar
├── +++ model-railway-signals-3.2.0.tar
│ ├── file list
│ │ @@ -1,71 +1,73 @@
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      127 2022-11-19 15:48:54.000000 model-railway-signals-3.1.0/MANIFEST.in
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     5439 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/PKG-INFO
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     4199 2022-12-10 15:36:39.000000 model-railway-signals-3.1.0/README.md
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     6397 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/__init__.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      325 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/__main__.py
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals/editor/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)        0 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/__init__.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    40358 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/common.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    22645 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_point.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    21329 2022-11-19 17:53:12.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_section.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    56493 2022-11-26 12:42:40.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    53228 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab1.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    21531 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab2.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    32936 2022-11-27 16:17:33.000000 model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab3.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     1534 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/editor.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    31275 2022-12-10 15:41:10.000000 model-railway-signals-3.1.0/model_railway_signals/editor/menubar.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    18123 2022-11-27 16:22:46.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     7825 2022-11-25 12:57:05.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_common.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    10895 2022-11-19 17:05:10.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_instruments.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     7711 2022-11-19 17:02:38.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_lines.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    17330 2022-11-19 17:01:38.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_points.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    15872 2022-11-25 13:59:43.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_sections.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    45247 2022-11-26 12:46:17.000000 model-railway-signals-3.1.0/model_railway_signals/editor/objects_signals.py
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)        0 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/__init__.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      644 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/block_instrument.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      284 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/colour_light.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      295 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/ground_disc.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      277 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/ground_position.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      247 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/left_hand_point.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      170 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/line.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      246 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/right_hand_point.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      208 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/semaphore.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      670 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/editor/resources/track_section.png
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    48338 2022-12-11 12:07:34.000000 model-railway-signals-3.1.0/model_railway_signals/editor/run_layout.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    38317 2022-11-25 12:54:33.000000 model-railway-signals-3.1.0/model_railway_signals/editor/schematic.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     6955 2022-11-25 13:03:13.000000 model-railway-signals-3.1.0/model_railway_signals/editor/settings.py
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals/library/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)        0 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/__init__.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    46118 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/block_instruments.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     6553 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/common.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    43663 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/dcc_control.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    22754 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/file_interface.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    18681 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/mqtt_interface.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    31806 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/pi_sprog_interface.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    26338 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/points.py
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)        0 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/__init__.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    80808 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-01.wav
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    80808 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-02.wav
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    80808 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-03.wav
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    80808 2022-11-19 15:48:58.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-04.wav
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    30722 2022-11-19 15:48:58.000000 model-railway-signals-3.1.0/model_railway_signals/library/resources/telegraph-key-01.wav
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    49100 2022-12-10 14:25:40.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    46285 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals_colour_lights.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    35973 2022-12-10 14:23:22.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals_common.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     7444 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals_ground_disc.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     9827 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals_ground_position.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    55433 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/signals_semaphores.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    25913 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/track_sections.py
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)    13806 2022-11-19 15:48:56.000000 model-railway-signals-3.1.0/model_railway_signals/library/track_sensors.py
│ │ -drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     5439 2022-12-11 12:14:51.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/PKG-INFO
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)     2911 2022-12-11 12:14:51.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)        1 2022-12-11 12:14:51.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)       19 2022-12-11 12:14:51.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/requires.txt
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)       22 2022-12-11 12:14:51.000000 model-railway-signals-3.1.0/model_railway_signals.egg-info/top_level.txt
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)       38 2022-12-11 12:14:54.000000 model-railway-signals-3.1.0/setup.cfg
│ │ --rw-r--r--   0 pi        (1000) pi        (1000)      979 2022-11-19 15:48:54.000000 model-railway-signals-3.1.0/setup.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      127 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/MANIFEST.in
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     5616 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/PKG-INFO
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     4344 2023-04-06 12:56:39.000000 model-railway-signals-3.2.0/README.md
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     6599 2023-03-25 17:29:52.000000 model-railway-signals-3.2.0/model_railway_signals/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      325 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/__main__.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/editor/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)        0 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    40363 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/common.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    23000 2023-03-25 17:51:24.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_point.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    21648 2023-03-25 17:52:50.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_section.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    58458 2023-03-26 20:06:50.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    53245 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab1.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    21531 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab2.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    34010 2023-03-25 17:35:26.000000 model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab3.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     2115 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/editor.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    32973 2023-04-06 13:22:53.000000 model-railway-signals-3.2.0/model_railway_signals/editor/menubar.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     5501 2023-04-06 08:55:04.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    29404 2023-04-06 12:06:19.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     9563 2023-04-06 08:49:36.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_common.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    12181 2023-04-06 08:00:14.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_instruments.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     7428 2023-04-06 08:28:36.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_lines.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    20303 2023-04-06 11:36:45.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_points.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    19032 2023-04-06 08:27:53.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_sections.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    50533 2023-04-06 08:29:57.000000 model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_signals.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)        0 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      644 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/block_instrument.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      284 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/colour_light.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      295 2023-03-25 09:50:18.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/ground_disc.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      277 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/ground_position.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      247 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/left_hand_point.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      170 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/line.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      246 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/right_hand_point.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      208 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/semaphore.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      670 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/editor/resources/track_section.png
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    52821 2023-04-06 12:01:06.000000 model-railway-signals-3.2.0/model_railway_signals/editor/run_layout.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    39689 2023-03-28 08:52:12.000000 model-railway-signals-3.2.0/model_railway_signals/editor/schematic.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     6955 2023-04-06 13:00:47.000000 model-railway-signals-3.2.0/model_railway_signals/editor/settings.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/library/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)        0 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    46118 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/block_instruments.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     6542 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/common.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    43683 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/dcc_control.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    22911 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/file_interface.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    18681 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/mqtt_interface.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    31806 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/pi_sprog_interface.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    26338 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/points.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)        0 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/__init__.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    80808 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-01.wav
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    80808 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-02.wav
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    80808 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-03.wav
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    80808 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-04.wav
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    30722 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/resources/telegraph-key-01.wav
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    52946 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    46680 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals_colour_lights.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    37156 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals_common.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     7444 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals_ground_disc.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     9827 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals_ground_position.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    55637 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/signals_semaphores.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    25913 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/track_sections.py
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)    13806 2023-03-25 09:50:20.000000 model-railway-signals-3.2.0/model_railway_signals/library/track_sensors.py
│ │ +drwxr-xr-x   0 pi        (1000) pi        (1000)        0 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     5616 2023-04-06 13:26:41.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)     3016 2023-04-06 13:26:41.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)        1 2023-04-06 13:26:41.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)       19 2023-04-06 13:26:41.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/requires.txt
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)       22 2023-04-06 13:26:41.000000 model-railway-signals-3.2.0/model_railway_signals.egg-info/top_level.txt
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)       38 2023-04-06 13:26:44.000000 model-railway-signals-3.2.0/setup.cfg
│ │ +-rw-r--r--   0 pi        (1000) pi        (1000)      979 2023-04-06 12:53:37.000000 model-railway-signals-3.2.0/setup.py
│ │   --- model-railway-signals-3.1.0/PKG-INFO
│ ├── +++ model-railway-signals-3.2.0/PKG-INFO
│ │┄ Files 2% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: model-railway-signals
│ │ -Version: 3.1.0
│ │ +Version: 3.2.0
│ │  Summary: Create your own DCC model railway signalling scheme
│ │  Home-page: https://github.com/johnrm174/model-railway-signalling
│ │  Author: johnrm174
│ │  Author-email: johnrm17418@gmail.com
│ │  License: GNU GENERAL PUBLIC LICENSE Version 2, June 1991
│ │  Description: # model-railway-signalling
│ │          
│ │ @@ -16,23 +16,23 @@
│ │          
│ │          ## Layout editor
│ │          
│ │          From Release 3.0.0, the schematic editor application enables automated and interlocked layout signalling 
│ │          schemes to be designed and configured without the need to write any code. Note that the editor is in
│ │          active development so any comments and suggestions for future features are welcome.
│ │          
│ │ -        What's supported in Release 3.1.0:
│ │ +        What's supported in Release 3.2.0:
│ │          * Draw your layout schematic with lines, points, signals and track occupancy sections
│ │ -        * Define the DCC acommand sequences to drive the signals and points out on the layout
│ │ +        * Define the DCC command sequences to drive the signals and points out on the layout
│ │          * Configure the signals and points to implement protototypical interlocking schemes
│ │          * Configure GPIO sensors and track sections to provide a 'mimic' display of the layout
│ │ +        * Automation of signals as trains traverse the routes that have been configured
│ │          * Save and load your layout schematic and state between running sessions
│ │          
│ │          What's coming soon:
│ │ -        * Undo/redo for layout editing functions
│ │          * Support for block section instruments
│ │          * MQTT networking (for linking layouts)
│ │          * Application documentation
│ │          
│ │          Any bug reports and feedback you may have would be gratefully appreciated - specifically:
│ │          * What aspects are intuitive? What aspects aren't?
│ │          * What aspects do you particularly like?
│ │ @@ -78,15 +78,19 @@
│ │          
│ │          ## Using the layout editor
│ │          
│ │          To run the editor application:
│ │          
│ │          The python package should be run as a module (note underscores):
│ │          <pre>
│ │ -        $ python3 -m model_railway_signals 
│ │ +        $ python3 -m model_railway_signals
│ │ +        </pre>
│ │ +        or to load a layout schematic at startup
│ │ +        <pre>
│ │ +        $ python3 -m model_railway_signals -f layout_file.sig
│ │          </pre>
│ │          
│ │          ## Using the library functions
│ │          
│ │          To use the public API functions for developing your own layout signalling system:
│ │          <pre>
│ │          from model_railway_signals import *
│ │   --- model-railway-signals-3.1.0/README.md
│ ├── +++ model-railway-signals-3.2.0/README.md
│ │┄ Files 2% similar despite different names
│ │ @@ -8,23 +8,23 @@
│ │  
│ │  ## Layout editor
│ │  
│ │  From Release 3.0.0, the schematic editor application enables automated and interlocked layout signalling 
│ │  schemes to be designed and configured without the need to write any code. Note that the editor is in
│ │  active development so any comments and suggestions for future features are welcome.
│ │  
│ │ -What's supported in Release 3.1.0:
│ │ +What's supported in Release 3.2.0:
│ │  * Draw your layout schematic with lines, points, signals and track occupancy sections
│ │ -* Define the DCC acommand sequences to drive the signals and points out on the layout
│ │ +* Define the DCC command sequences to drive the signals and points out on the layout
│ │  * Configure the signals and points to implement protototypical interlocking schemes
│ │  * Configure GPIO sensors and track sections to provide a 'mimic' display of the layout
│ │ +* Automation of signals as trains traverse the routes that have been configured
│ │  * Save and load your layout schematic and state between running sessions
│ │  
│ │  What's coming soon:
│ │ -* Undo/redo for layout editing functions
│ │  * Support for block section instruments
│ │  * MQTT networking (for linking layouts)
│ │  * Application documentation
│ │  
│ │  Any bug reports and feedback you may have would be gratefully appreciated - specifically:
│ │  * What aspects are intuitive? What aspects aren't?
│ │  * What aspects do you particularly like?
│ │ @@ -70,15 +70,19 @@
│ │  
│ │  ## Using the layout editor
│ │  
│ │  To run the editor application:
│ │  
│ │  The python package should be run as a module (note underscores):
│ │  <pre>
│ │ -$ python3 -m model_railway_signals 
│ │ +$ python3 -m model_railway_signals
│ │ +</pre>
│ │ +or to load a layout schematic at startup
│ │ +<pre>
│ │ +$ python3 -m model_railway_signals -f layout_file.sig
│ │  </pre>
│ │  
│ │  ## Using the library functions
│ │  
│ │  To use the public API functions for developing your own layout signalling system:
│ │  <pre>
│ │  from model_railway_signals import *
│ │   --- model-railway-signals-3.1.0/model_railway_signals/__init__.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/__init__.py
│ │┄ Files 8% similar despite different names
│ │ @@ -34,14 +34,16 @@
│ │  from .library.signals import unlock_subsidary
│ │  from .library.signals import toggle_subsidary
│ │  from .library.signals import signal_clear
│ │  from .library.signals import subsidary_clear
│ │  from .library.signals import signal_state
│ │  from .library.signals import set_signal_override
│ │  from .library.signals import clear_signal_override
│ │ +from .library.signals import set_signal_override_caution
│ │ +from .library.signals import clear_signal_override_caution
│ │  from .library.signals import set_approach_control
│ │  from .library.signals import clear_approach_control
│ │  from .library.signals import trigger_timed_signal
│ │  from .library.signals import subscribe_to_signal_updates
│ │  from .library.signals import subscribe_to_signal_passed_events
│ │  from .library.signals import set_signals_to_publish_state
│ │  from .library.signals import set_signals_to_publish_passed_events
│ │ @@ -63,15 +65,14 @@
│ │  from .library.pi_sprog_interface import service_mode_write_cv
│ │  from .library.pi_sprog_interface import request_dcc_power_on
│ │  from .library.pi_sprog_interface import request_dcc_power_off
│ │  
│ │  from .library.dcc_control import map_dcc_signal
│ │  from .library.dcc_control import map_semaphore_signal
│ │  from .library.dcc_control import map_traintech_signal
│ │ -from .library.dcc_control import map_semaphore_signal
│ │  from .library.dcc_control import map_dcc_point
│ │  from .library.dcc_control import subscribe_to_dcc_command_feed
│ │  from .library.dcc_control import set_node_to_publish_dcc_commands
│ │  
│ │  from .library.mqtt_interface import configure_networking
│ │  
│ │  from .library.file_interface import load_layout_state
│ │ @@ -116,14 +117,16 @@
│ │          'unlock_subsidary',
│ │          'toggle_subsidary',
│ │          'signal_clear',
│ │          'subsidary_clear',
│ │          'signal_state',
│ │          'set_signal_override',
│ │          'clear_signal_override',
│ │ +        'set_signal_override_caution',
│ │ +        'clear_signal_override_caution',
│ │          'set_approach_control',
│ │          'clear_approach_control',
│ │          'trigger_timed_signal',
│ │          'subscribe_to_signal_updates',
│ │          'subscribe_to_signal_passed_events',
│ │          'set_signals_to_publish_state',
│ │          'set_signals_to_publish_passed_events',
│ │ @@ -157,10 +160,12 @@
│ │          'configure_networking',
│ │        # Public File load/save functions
│ │          'load_layout_state',
│ │        # public block instrument types
│ │          'block_callback_type',
│ │        # Public block instrument functions
│ │          'create_block_instrument',
│ │ -        'block_section_ahead_clear'
│ │ +        'block_section_ahead_clear',
│ │ +      # Public function to run editor
│ │ +        'run_editor'
│ │             ]
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/common.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/common.py
│ │┄ Files 0% similar despite different names
│ │ @@ -728,15 +728,15 @@
│ │          if not self.read_only:
│ │              if self.EB.entry.get() == "":
│ │                  super().disable()
│ │              else:
│ │                  super().enable()
│ │      
│ │      def validate(self):
│ │ -        return(EB.validate())
│ │ +        return(self.EB.validate())
│ │      
│ │      def enable(self):
│ │          self.EB.enable()
│ │          self.eb_updated()
│ │          
│ │      def disable(self):
│ │          self.EB.disable()
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_point.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_point.py
│ │┄ Files 2% similar despite different names
│ │ @@ -50,34 +50,39 @@
│ │  #------------------------------------------------------------------------------------
│ │  # Function to load the initial UI state when the Edit window is created
│ │  # Also called to re-load the UI state on an "Apply" (i.e. after the save)
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def load_state(point):
│ │      object_id = point.object_id
│ │ -    # Label the edit window with the Point ID
│ │ -    point.window.title("Point "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ -    # Set the Initial UI state from the current object settings
│ │ -    point.config.pointid.set_value(objects.schematic_objects[object_id]["itemid"])
│ │ -    point.config.alsoswitch.set_value(objects.schematic_objects[object_id]["alsoswitch"])
│ │ -    point.config.alsoswitch.set_switched_with(switched_with_point(object_id))
│ │ -    point.config.pointtype.set_value(objects.schematic_objects[object_id]["itemtype"])
│ │ -    # These are the general settings for the point
│ │ -    auto = objects.schematic_objects[object_id]["automatic"]
│ │ -    rev = objects.schematic_objects[object_id]["reverse"]
│ │ -    fpl = objects.schematic_objects[object_id]["hasfpl"]
│ │ -    if objects.schematic_objects[object_id]["orientation"] == 180: rot = True
│ │ -    else:rot = False
│ │ -    point.config.settings.set_values(rot, rev, auto, fpl)
│ │ -    # Set the initial DCC address values
│ │ -    add = objects.schematic_objects[object_id]["dccaddress"]
│ │ -    rev = objects.schematic_objects[object_id]["dccreversed"]
│ │ -    point.config.dccsettings.set_values (add, rev)
│ │ -    # Set the read only list of Interlocked signals
│ │ -    point.locking.signals.set_values(objects.schematic_objects[object_id]["siginterlock"])
│ │ +    # Check the point we are editing still exists (hasn't been deleted from the schematic)
│ │ +    # If it no longer exists then we just destroy the window and exit without saving
│ │ +    if object_id not in objects.schematic_objects.keys():
│ │ +        point.window.destroy()
│ │ +    else:
│ │ +        # Label the edit window with the Point ID
│ │ +        point.window.title("Point "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ +        # Set the Initial UI state from the current object settings
│ │ +        point.config.pointid.set_value(objects.schematic_objects[object_id]["itemid"])
│ │ +        point.config.alsoswitch.set_value(objects.schematic_objects[object_id]["alsoswitch"])
│ │ +        point.config.alsoswitch.set_switched_with(switched_with_point(object_id))
│ │ +        point.config.pointtype.set_value(objects.schematic_objects[object_id]["itemtype"])
│ │ +        # These are the general settings for the point
│ │ +        auto = objects.schematic_objects[object_id]["automatic"]
│ │ +        rev = objects.schematic_objects[object_id]["reverse"]
│ │ +        fpl = objects.schematic_objects[object_id]["hasfpl"]
│ │ +        if objects.schematic_objects[object_id]["orientation"] == 180: rot = True
│ │ +        else:rot = False
│ │ +        point.config.settings.set_values(rot, rev, auto, fpl)
│ │ +        # Set the initial DCC address values
│ │ +        add = objects.schematic_objects[object_id]["dccaddress"]
│ │ +        rev = objects.schematic_objects[object_id]["dccreversed"]
│ │ +        point.config.dccsettings.set_values (add, rev)
│ │ +        # Set the read only list of Interlocked signals
│ │ +        point.locking.signals.set_values(objects.schematic_objects[object_id]["siginterlock"])
│ │      return()
│ │      
│ │  #------------------------------------------------------------------------------------
│ │  # Function to commit all configuration changes (Apply/OK Button)
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def save_state(point, close_window:bool):
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_section.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_section.py
│ │┄ Files 0% similar despite different names
│ │ @@ -98,24 +98,29 @@
│ │  #------------------------------------------------------------------------------------
│ │  # Function to load the initial UI state when the Edit window is created
│ │  # Also called to re-load the UI state on an "Apply" (i.e. after the save)
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def load_state(section):
│ │      object_id = section.object_id
│ │ -    # Label the edit window with the Section ID
│ │ -    section.window.title("Track Section "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ -    # Set the Initial UI state from the current object settings
│ │ -    section.config.sectionid.set_value(objects.schematic_objects[object_id]["itemid"])
│ │ -    section.config.readonly.set_value(not objects.schematic_objects[object_id]["editable"])
│ │ -    section.config.mirror.set_value(objects.schematic_objects[object_id]["mirror"])
│ │ -    section.config.mirror.set_mirrored_by(mirrored_by_section(object_id))
│ │ -    section.config.label.set_value(objects.schematic_objects[object_id]["defaultlabel"])
│ │ -    section.automation.ahead.set_values(signals_ahead(object_id))
│ │ -    section.automation.behind.set_values(signals_behind(object_id))
│ │ +    # Check the section we are editing still exists (hasn't been deleted from the schematic)
│ │ +    # If it no longer exists then we just destroy the window and exit without saving
│ │ +    if object_id not in objects.schematic_objects.keys():
│ │ +        section.window.destroy()
│ │ +    else:
│ │ +        # Label the edit window with the Section ID
│ │ +        section.window.title("Track Section "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ +        # Set the Initial UI state from the current object settings
│ │ +        section.config.sectionid.set_value(objects.schematic_objects[object_id]["itemid"])
│ │ +        section.config.readonly.set_value(not objects.schematic_objects[object_id]["editable"])
│ │ +        section.config.mirror.set_value(objects.schematic_objects[object_id]["mirror"])
│ │ +        section.config.mirror.set_mirrored_by(mirrored_by_section(object_id))
│ │ +        section.config.label.set_value(objects.schematic_objects[object_id]["defaultlabel"])
│ │ +        section.automation.ahead.set_values(signals_ahead(object_id))
│ │ +        section.automation.behind.set_values(signals_behind(object_id))
│ │      return()
│ │      
│ │  #------------------------------------------------------------------------------------
│ │  # Function to commit all configuration changes (Apply/OK Button)
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def save_state(section, close_window:bool):
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal.py
│ │┄ Files 1% similar despite different names
│ │ @@ -33,36 +33,51 @@
│ │  from . import configure_signal_tab3
│ │  
│ │  from ..library import signals_common
│ │  from ..library import signals_colour_lights
│ │  from ..library import signals_semaphores
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Helper functions to find out if the signal has a subsidary or a distant
│ │ +# Helper function to find out if the signal has a subsidary (colour light or semaphore)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def has_subsidary(signal):
│ │      return ( ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │                 ( signal.config.semaphores.main.sub.get_element()[0] or
│ │                   signal.config.semaphores.lh1.sub.get_element()[0] or
│ │                   signal.config.semaphores.lh2.sub.get_element()[0] or
│ │                   signal.config.semaphores.rh1.sub.get_element()[0] or
│ │                   signal.config.semaphores.rh2.sub.get_element()[0] ) ) or
│ │               (signal.config.sigtype.get_value() == signals_common.sig_type.colour_light.value and
│ │                  signal.config.aspects.get_subsidary()[0] ) )
│ │  
│ │ -def has_distant(signal):
│ │ +#------------------------------------------------------------------------------------
│ │ +# Helper functions to find out if the signal has distant arms (semaphore
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def has_distant_arms(signal):
│ │      return ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │               ( signal.config.semaphores.main.dist.get_element()[0] or
│ │                 signal.config.semaphores.lh1.dist.get_element()[0] or
│ │                 signal.config.semaphores.lh2.dist.get_element()[0] or
│ │                 signal.config.semaphores.rh1.dist.get_element()[0] or
│ │                 signal.config.semaphores.rh2.dist.get_element()[0] ) )
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Helper functions to find out if the signal has route arms (semaphore)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def has_route_arms(signal):
│ │ +    return ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │ +             (signal.config.semaphores.lh1.sig.get_element()[0] or
│ │ +               signal.config.semaphores.lh2.sig.get_element()[0] or
│ │ +               signal.config.semaphores.rh1.sig.get_element()[0] or
│ │ +               signal.config.semaphores.rh2.sig.get_element()[0] ) )
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Helper functions to return a list of the selected signal, distant and subsidary
│ │  # routes epending on the route indication type that has been selected
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def get_sig_routes(signal):
│ │      # Get the route selections from the appropriate UI element
│ │      if signal.config.routetype.get_value() == 1:
│ │ @@ -153,76 +168,84 @@
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to load the initial UI state when the Edit window is created
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def load_state(signal):
│ │      object_id = signal.object_id
│ │ -    # Label the edit window with the Signal ID
│ │ -    signal.window.title("Signal "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ -    # Set the Initial UI state from the current object settings
│ │ -    signal.config.sigid.set_value(str(objects.schematic_objects[object_id]["itemid"]))
│ │ -    signal.config.sigtype.set_value(objects.schematic_objects[object_id]["itemtype"])
│ │ -    signal.config.subtype.set_value(objects.schematic_objects[object_id]["itemsubtype"])
│ │ -    signal.config.aspects.set_subsidary(objects.schematic_objects[object_id]["subsidary"])
│ │ -    signal.config.feathers.set_feathers(objects.schematic_objects[object_id]["feathers"])
│ │ -    signal.config.aspects.set_addresses(objects.schematic_objects[object_id]["dccaspects"])
│ │ -    signal.config.feathers.set_addresses(objects.schematic_objects[object_id]["dccfeathers"])
│ │ -    signal.config.theatre.set_theatre(objects.schematic_objects[object_id]["dcctheatre"])
│ │ -    signal.config.feathers.set_auto_inhibit(objects.schematic_objects[object_id]["dccautoinhibit"])
│ │ -    signal.config.theatre.set_auto_inhibit(objects.schematic_objects[object_id]["dccautoinhibit"])
│ │ -    signal.config.semaphores.set_arms(objects.schematic_objects[object_id]["sigarms"])
│ │ -    signal.config.sig_routes.set_values(objects.schematic_objects[object_id]["sigroutes"])
│ │ -    signal.config.sub_routes.set_values(objects.schematic_objects[object_id]["subroutes"])
│ │ -    # These are the general settings for the signal
│ │ -    if objects.schematic_objects[object_id]["orientation"] == 180: rot = True
│ │ -    else:rot = False
│ │ -    signal.config.settings.set_value(rot)
│ │ -    # These elements are for the signal intelocking tab
│ │ -    signal.locking.interlocking.set_routes(objects.schematic_objects[object_id]["pointinterlock"])
│ │ -    signal.locking.conflicting_sigs.set_values(objects.schematic_objects[object_id]["siginterlock"])
│ │ -    signal.locking.interlock_ahead.set_value(objects.schematic_objects[object_id]["interlockahead"])
│ │ -    # These elements are for the Automation tab
│ │ -    signal.automation.track_sensors.approach.set_value(objects.schematic_objects[object_id]["approachsensor"][1])
│ │ -    signal.automation.track_sensors.passed.set_value(objects.schematic_objects[object_id]["passedsensor"][1])
│ │ -    signal.automation.track_occupancy.set_values(objects.schematic_objects[object_id]["tracksections"])
│ │ -    override = objects.schematic_objects[object_id]["overridesignal"]
│ │ -    fully_automatic = objects.schematic_objects[object_id]["fullyautomatic"]
│ │ -    override_ahead = objects.schematic_objects[object_id]["overrideahead"]
│ │ -    signal.automation.general_settings.set_values(override, fully_automatic, override_ahead)
│ │ -    signal.automation.timed_signal.set_values(objects.schematic_objects[object_id]["timedsequences"])
│ │ -    signal.automation.approach_control.set_values(objects.schematic_objects[object_id]["approachcontrol"])
│ │ -    # Configure the initial Route indication selection
│ │ -    feathers = objects.schematic_objects[object_id]["feathers"]
│ │ -    if objects.schematic_objects[object_id]["itemtype"] == signals_common.sig_type.colour_light.value:
│ │ -        if objects.schematic_objects[object_id]["theatreroute"]:
│ │ -            signal.config.routetype.set_value(3)
│ │ -        elif feathers[0] or feathers[1] or feathers[2] or feathers[3] or feathers[4]:
│ │ -            signal.config.routetype.set_value(2)
│ │ +    # Check the object we are editing still exists (hasn't been deleted from the schematic)
│ │ +    # If it no longer exists then we just destroy the window and exit without saving
│ │ +    if object_id not in objects.schematic_objects.keys():
│ │ +        signal.window.destroy()
│ │ +    else:
│ │ +        # Label the edit window with the Signal ID
│ │ +        signal.window.title("Signal "+str(objects.schematic_objects[object_id]["itemid"]))
│ │ +        # Set the Initial UI state from the current object settings
│ │ +        signal.config.sigid.set_value(str(objects.schematic_objects[object_id]["itemid"]))
│ │ +        signal.config.sigtype.set_value(objects.schematic_objects[object_id]["itemtype"])
│ │ +        signal.config.subtype.set_value(objects.schematic_objects[object_id]["itemsubtype"])
│ │ +        signal.config.aspects.set_subsidary(objects.schematic_objects[object_id]["subsidary"])
│ │ +        signal.config.feathers.set_feathers(objects.schematic_objects[object_id]["feathers"])
│ │ +        signal.config.aspects.set_addresses(objects.schematic_objects[object_id]["dccaspects"])
│ │ +        signal.config.feathers.set_addresses(objects.schematic_objects[object_id]["dccfeathers"])
│ │ +        signal.config.theatre.set_theatre(objects.schematic_objects[object_id]["dcctheatre"])
│ │ +        signal.config.feathers.set_auto_inhibit(objects.schematic_objects[object_id]["dccautoinhibit"])
│ │ +        signal.config.theatre.set_auto_inhibit(objects.schematic_objects[object_id]["dccautoinhibit"])
│ │ +        signal.config.semaphores.set_arms(objects.schematic_objects[object_id]["sigarms"])
│ │ +        signal.config.sig_routes.set_values(objects.schematic_objects[object_id]["sigroutes"])
│ │ +        signal.config.sub_routes.set_values(objects.schematic_objects[object_id]["subroutes"])
│ │ +        # These are the general settings for the signal
│ │ +        if objects.schematic_objects[object_id]["orientation"] == 180: rot = True
│ │ +        else:rot = False
│ │ +        signal.config.settings.set_value(rot)
│ │ +        # These elements are for the signal intelocking tab
│ │ +        signal.locking.interlocking.set_routes(objects.schematic_objects[object_id]["pointinterlock"])
│ │ +        signal.locking.conflicting_sigs.set_values(objects.schematic_objects[object_id]["siginterlock"])
│ │ +        signal.locking.interlock_ahead.set_value(objects.schematic_objects[object_id]["interlockahead"])
│ │ +        # These elements are for the Automation tab
│ │ +        signal.automation.track_sensors.approach.set_value(objects.schematic_objects[object_id]["approachsensor"][1])
│ │ +        signal.automation.track_sensors.passed.set_value(objects.schematic_objects[object_id]["passedsensor"][1])
│ │ +        signal.automation.track_occupancy.set_values(objects.schematic_objects[object_id]["tracksections"])
│ │ +        override = objects.schematic_objects[object_id]["overridesignal"]
│ │ +        main_auto = objects.schematic_objects[object_id]["fullyautomatic"]
│ │ +        dist_auto = objects.schematic_objects[object_id]["distautomatic"]
│ │ +        override_ahead = objects.schematic_objects[object_id]["overrideahead"]
│ │ +        signal.automation.general_settings.set_values(override, main_auto, override_ahead, dist_auto)
│ │ +        signal.automation.timed_signal.set_values(objects.schematic_objects[object_id]["timedsequences"])
│ │ +        signal.automation.approach_control.set_values(objects.schematic_objects[object_id]["approachcontrol"])
│ │ +        # Configure the initial Route indication selection
│ │ +        feathers = objects.schematic_objects[object_id]["feathers"]
│ │ +        if objects.schematic_objects[object_id]["itemtype"] == signals_common.sig_type.colour_light.value:
│ │ +            if objects.schematic_objects[object_id]["theatreroute"]:
│ │ +                signal.config.routetype.set_value(3)
│ │ +            elif feathers[0] or feathers[1] or feathers[2] or feathers[3] or feathers[4]:
│ │ +                signal.config.routetype.set_value(2)
│ │ +            else:
│ │ +                signal.config.routetype.set_value(1)      
│ │ +        elif objects.schematic_objects[object_id]["itemtype"] == signals_common.sig_type.semaphore.value:
│ │ +            if objects.schematic_objects[object_id]["theatreroute"]:
│ │ +                signal.config.routetype.set_value(3)
│ │ +            elif has_route_arms(signal):
│ │ +                signal.config.routetype.set_value(4)
│ │ +            else:
│ │ +                signal.config.routetype.set_value(1)      
│ │          else:
│ │              signal.config.routetype.set_value(1)      
│ │ -    elif objects.schematic_objects[object_id]["itemtype"] == signals_common.sig_type.semaphore.value:
│ │ -        if objects.schematic_objects[object_id]["theatreroute"]:
│ │ -            signal.config.routetype.set_value(3)
│ │ -        else: 
│ │ -            signal.config.routetype.set_value(4)      
│ │ -    else:
│ │ -        signal.config.routetype.set_value(1)      
│ │ -    # Set the initial UI selections
│ │ -    update_tab1_signal_subtype_selections(signal)
│ │ -    update_tab1_signal_aspect_selections(signal)
│ │ -    update_tab1_route_selection_elements(signal)
│ │ -    update_tab1_signal_ui_elements(signal)
│ │ -    update_tab2_available_signal_routes(signal)
│ │ -    update_tab2_interlock_ahead_selection(signal)
│ │ -    update_tab3_track_section_ahead_routes(signal)
│ │ -    update_tab3_general_settings_selections(signal)
│ │ -    update_tab3_timed_signal_selections(signal)
│ │ -    update_tab3_approach_control_selections(signal)
│ │ -    update_tab3_signal_ui_elements(signal)
│ │ +        # Set the initial UI selections
│ │ +        update_tab1_signal_subtype_selections(signal)
│ │ +        update_tab1_signal_aspect_selections(signal)
│ │ +        update_tab1_route_selection_elements(signal)
│ │ +        update_tab1_signal_ui_elements(signal)
│ │ +        update_tab2_available_signal_routes(signal)
│ │ +        update_tab2_interlock_ahead_selection(signal)
│ │ +        update_tab3_track_section_ahead_routes(signal)
│ │ +        update_tab3_general_settings_selections(signal)
│ │ +        update_tab3_timed_signal_selections(signal)
│ │ +        update_tab3_approach_control_selections(signal)
│ │ +        update_tab3_signal_ui_elements(signal)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to commit all configuration changes (Apply/OK Button)
│ │  #------------------------------------------------------------------------------------
│ │   
│ │  def save_state(signal, close_window):
│ │ @@ -269,17 +292,17 @@
│ │          new_object_configuration["interlockahead"] = signal.locking.interlock_ahead.get_value()
│ │          # These elements are for the Automation tab
│ │          new_object_configuration["passedsensor"][0] = True
│ │          new_object_configuration["passedsensor"][1] = signal.automation.track_sensors.passed.get_value()
│ │          new_object_configuration["approachsensor"][0] = signal.automation.approach_control.is_selected()
│ │          new_object_configuration["approachsensor"][1] = signal.automation.track_sensors.approach.get_value()
│ │          new_object_configuration["tracksections"] = signal.automation.track_occupancy.get_values()
│ │ -        override, fully_automatic, override_ahead = signal.automation.general_settings.get_values()
│ │ -        new_object_configuration["fullyautomatic"] = fully_automatic
│ │ -        new_object_configuration["distautomatic"] = False
│ │ +        override, main_auto, override_ahead, dist_auto = signal.automation.general_settings.get_values()
│ │ +        new_object_configuration["fullyautomatic"] = main_auto
│ │ +        new_object_configuration["distautomatic"] = dist_auto
│ │          new_object_configuration["overridesignal"] = override
│ │          new_object_configuration["overrideahead"] = override_ahead
│ │          new_object_configuration["timedsequences"] = signal.automation.timed_signal.get_values()
│ │          new_object_configuration["approachcontrol"] = signal.automation.approach_control.get_values()
│ │          # Save the updated configuration (and re-draw the object)
│ │          objects.update_object(object_id, new_object_configuration)
│ │          # Close window on "OK" or re-load UI for "apply"
│ │ @@ -641,15 +664,15 @@
│ │  def update_tab2_interlock_ahead_selection(signal):
│ │      if ( ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │             signal.config.subtype.get_value() == signals_semaphores.semaphore_sub_type.distant.value) or
│ │           ( signal.config.sigtype.get_value() == signals_common.sig_type.colour_light.value and
│ │             signal.config.subtype.get_value() == signals_colour_lights.signal_sub_type.distant.value) or
│ │           ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │             signal.config.subtype.get_value() == signals_semaphores.semaphore_sub_type.home.value and
│ │ -           has_distant(signal) ) ):
│ │ +           has_distant_arms(signal) ) ):
│ │          signal.locking.interlock_ahead.frame.pack(padx=2, pady=2, fill='x')
│ │          signal.locking.interlock_ahead.enable()
│ │      else:
│ │          signal.locking.interlock_ahead.frame.pack_forget()
│ │          signal.locking.interlock_ahead.disable()
│ │      return()
│ │  
│ │ @@ -686,22 +709,28 @@
│ │      if ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value  or
│ │           signal.config.sigtype.get_value() == signals_common.sig_type.colour_light.value):
│ │          signal.automation.general_settings.automatic.enable()
│ │          signal.automation.general_settings.override.enable()
│ │      else:
│ │          signal.automation.general_settings.automatic.disable()
│ │          signal.automation.general_settings.override.disable()
│ │ -    # Enable/disable the "Override Ahead"(no signal button) and "Override" selections
│ │ +    # Enable/disable the "Dustant Automatic"(no distant button) selection
│ │ +    if ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │ +         has_distant_arms(signal) ):
│ │ +        signal.automation.general_settings.distant_automatic.enable()
│ │ +    else:
│ │ +        signal.automation.general_settings.distant_automatic.disable()
│ │ +    # Enable/disable the "Override Ahead" selection (can be selected for all main signal types
│ │ +    # apart from colour light Home signals and Semnaphore Home signals without secondary distant arms
│ │      if ( ( signal.config.sigtype.get_value() == signals_common.sig_type.colour_light.value and
│ │ -           signal.config.subtype.get_value() == signals_colour_lights.signal_sub_type.distant.value) or
│ │ +           signal.config.subtype.get_value() != signals_colour_lights.signal_sub_type.home.value) or
│ │           ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │ -           signal.config.subtype.get_value() == signals_semaphores.semaphore_sub_type.distant.value ) or
│ │ +           signal.config.subtype.get_value() != signals_semaphores.semaphore_sub_type.home.value ) or
│ │           ( signal.config.sigtype.get_value() == signals_common.sig_type.semaphore.value and
│ │ -           signal.config.subtype.get_value() == signals_semaphores.semaphore_sub_type.home.value and
│ │ -           has_distant(signal) ) ):
│ │ +           has_distant_arms(signal) ) ):
│ │          signal.automation.general_settings.override_ahead.enable()
│ │      else:
│ │          signal.automation.general_settings.override_ahead.disable()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Enable/disable the Tab3 track occupancy route selection elements
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab1.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab1.py
│ │┄ Files 0% similar despite different names
│ │ @@ -116,21 +116,21 @@
│ │          self.dist_arms_callback = dist_arms_updated_callback
│ │          # Create a frame for the UI element (always packed into the parent frame)
│ │          self.frame = Frame(parent_frame)
│ │          self.frame.pack()
│ │          # Create the lable and route elements (these are packed by the class instances)
│ │          self.label = Label(self.frame, anchor='w', width=5, text=label)
│ │          self.label.pack(side=LEFT)
│ │ -        self.sig = semaphore_route_element(self.frame, label="Main signal",
│ │ -                      tool_tip= "Select to add a main signal arm for this route",
│ │ +        self.sig = semaphore_route_element(self.frame, label="Main (home) arm ",
│ │ +                      tool_tip= "Select to add a home signal arm for this route",
│ │                        callback=self.sig_arms_updated)
│ │ -        self.sub = semaphore_route_element(self.frame, label="Subsidary arm",
│ │ +        self.sub = semaphore_route_element(self.frame, label="Subsidary arm ",
│ │                      tool_tip="Select to add a subsidary signal arm for this route",
│ │                      callback=self.sub_arms_updated)
│ │ -        self.dist = semaphore_route_element(self.frame, label="Distant arm",
│ │ +        self.dist = semaphore_route_element(self.frame, label="Distant arm ",
│ │                          tool_tip="Select to add a distant signal arm for this route",
│ │                          callback=self.dist_arms_updated)
│ │          
│ │      def sig_arms_updated(self):
│ │          self.enable_disable_distant_arms()
│ │          if self.sig_arms_callback is not None: self.sig_arms_callback()
│ │          
│ │ @@ -437,15 +437,15 @@
│ │          self.dylw = colour_light_aspect(self.frame, label="Prelim Caution")
│ │          self.fylw = colour_light_aspect(self.frame, label="Flash Caution")
│ │          self.fdylw = colour_light_aspect(self.frame, label="Flash Prelim")
│ │          # Create a subframe to hold the subsidary signal entry box (always packed)
│ │          self.subframe = Frame(self.frame)
│ │          self.subframe.pack()
│ │          self.CB = common.check_box(self.subframe, label="Subsidary signal",   
│ │ -                    tool_tip="Select to include a seperate subsidary signal",callback=self.sub_updated)
│ │ +                    tool_tip="Select to add a seperate calling on aspect",callback=self.sub_updated)
│ │          self.CB.pack(side=LEFT, padx=2, pady=2)
│ │          self.EB = common.dcc_entry_box(self.subframe)
│ │          self.EB.pack(side=LEFT, padx=2, pady=2)
│ │  
│ │      def sub_updated(self):
│ │          self.update_eb_state()
│ │          if self.callback is not None: self.callback()
│ │ @@ -763,15 +763,15 @@
│ │          # state of the EBs (enabled or disabled) remains unchanged. This is to support the MAIN
│ │          # route which will always need a DCC address sequence even if there is no feather
│ │          self.enable_addresses_on_selection = enable_addresses_on_selection
│ │          # Create the label and checkbox for the feather route selection
│ │          self.label = Label(self.frame, width=width, text=label, anchor='w')
│ │          self.label.pack(side=LEFT)
│ │          self.CB = common.check_box(self.frame, callback=self.selection_updated, label="",
│ │ -                        tool_tip="Select to create a feather indication for this route")
│ │ +                        tool_tip="Select to add a feather indication for this route")
│ │          self.CB.pack(side=LEFT)
│ │          # Call the init function of the class we are inheriting from
│ │          # The DCC entry boxes get packed into the frame by the parent class
│ │          super().__init__(self.frame)
│ │          
│ │      def selection_updated(self):
│ │          self.update_addresses()
│ │ @@ -1041,15 +1041,15 @@
│ │          self.aspects = colour_light_aspects(parent_tab, sub_routes_updated)
│ │          self.theatre = theatre_route_indications(parent_tab, route_selections_updated)
│ │          self.feathers = feather_route_indications(parent_tab, route_selections_updated)
│ │          self.semaphores = semaphore_signal_arms(parent_tab, sig_routes_updated,
│ │                                          sub_routes_updated, dist_routes_updated)
│ │          self.sig_routes = route_selections(parent_tab, 
│ │                          "Routes to be controlled by the Main Signal",
│ │ -                        "Select the routes to be controlled by the main signal",
│ │ +                        "Select one or more routes to be controlled by the main signal",
│ │                          callback=route_selections_updated, main_signal=True)
│ │          self.sub_routes = route_selections(parent_tab,
│ │                          "Routes to be controlled by the Subsidary Signal",
│ │ -                        "Select the routes to be controlled by the subsidary signal",
│ │ +                        "Select one or more routes to be controlled by the subsidary signal",
│ │                          callback=route_selections_updated, main_signal=False)
│ │          
│ │  #############################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab2.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab2.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/configure_signal_tab3.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/configure_signal_tab3.py
│ │┄ Files 4% similar despite different names
│ │ @@ -33,15 +33,14 @@
│ │          if valid and self.entry.get() != "":
│ │              new_channel = int(self.entry.get())
│ │              if new_channel == 14 or new_channel == 15:
│ │                  self.TT.text = ("GPIO Ports 14 and 15 are reserved and canot be used")
│ │                  valid = False
│ │              else:
│ │                  # Test to see if the gpio channel is alreay assigned to another signal
│ │ -                current_channel = self.initial_value
│ │                  for signal_id in objects.signal_index:
│ │                      signal_object = objects.schematic_objects[objects.signal(signal_id)]
│ │                      if ( signal_object["itemid"] != self.parent_object.config.sigid.get_initial_value() and
│ │                           ( signal_object["passedsensor"][1] == new_channel or
│ │                                signal_object["approachsensor"][1] == new_channel ) ):
│ │                          self.TT.text = ("GPIO Channel "+str(new_channel)+" is already assigned to signal "
│ │                                          +str(signal_object["itemid"]))
│ │ @@ -103,27 +102,27 @@
│ │  
│ │  class section_behind_element(common.int_item_id_entry_box):
│ │      def __init__(self, parent_frame):
│ │          self.frame = Frame(parent_frame)
│ │          self.frame.pack()
│ │          self.label1 = Label(self.frame, width=1)
│ │          self.label1.pack(side=LEFT)
│ │ -        tool_tip = "Sepecify the track section before the signal (to be cleared when the signal is passed)"
│ │ +        tool_tip = "Sepecify the track section 'behind' this signal (to be cleared when the signal is passed)"
│ │          super().__init__(self.frame, tool_tip=tool_tip, exists_function=objects.section_exists)
│ │          self.pack(side=LEFT)
│ │          self.label = Label(self.frame, text=" ==>")
│ │          self.label.pack(side=LEFT)
│ │  
│ │  class section_ahead_element(common.int_item_id_entry_box):
│ │      def __init__(self, parent_frame, label):
│ │          self.frame = Frame(parent_frame)
│ │          self.frame.pack()
│ │          self.label1 = Label(self.frame, text=label, width=10)
│ │          self.label1.pack(side=LEFT)
│ │ -        tool_tip = ("Specify the track section on the route after the signal "+
│ │ +        tool_tip = ("Specify the track section on the route 'ahead of' the signal "+
│ │                               "(to be occupied when the signal is passed)")
│ │          super().__init__(self.frame, tool_tip=tool_tip, exists_function=objects.section_exists)
│ │          self.pack(side=LEFT)
│ │          self.label2 = Label(self.frame, width=1)
│ │          self.label2.pack(side=LEFT)
│ │                  
│ │  class section_ahead_frame():
│ │ @@ -186,51 +185,62 @@
│ │                   self.section_ahead.validate() )
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Class for the General automation settings subframe
│ │  # Public Class instance methods provided by this class:
│ │  #     "override.enable" - enable the override checkbox
│ │  #     "override.disable"- disable the override checkbox
│ │ -#     "automatic.enable" - enable the automatic checkbox
│ │ -#     "automatic.disable"- disable the automatic checkbox
│ │ +#     "automatic.enable" - enable the main auto checkbox
│ │ +#     "automatic.disable"- disable the main auto checkbox
│ │ +#     "distant_automatic.enable" - enable the distant auto checkbox
│ │ +#     "distant_automatic.disable"- disable the distant auto checkbox
│ │  #     "override_ahead.enable" - enable the override ahead checkbox
│ │  #     "override_ahead.disable"- disable the override ahead checkbox
│ │  #     "set_values" - will set the current values (override, auto)
│ │  #     "get_values" - will return the "valid" values (override, auto)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  class general_settings_frame():
│ │      def __init__(self, parent_frame):
│ │          # Create the Label Frame for the UI element (packed by the creating function/class)
│ │          self.frame = LabelFrame(parent_frame, text="General settings")
│ │          self.automatic = common.check_box(self.frame, width=40,
│ │ -                    label="  Fully automatic signal (no signal button)",
│ │ +                    label="  Fully automatic signal (no control button)",
│ │                      tool_tip="Select to create without a main signal button "+
│ │ -                    "(signal will have a default signal state of OFF)")
│ │ +                    "(signal will have a default signal state of OFF, but can be "+
│ │ +                        "overridden to ON via the selections below)")
│ │          self.automatic.pack(padx=2, pady=2)
│ │ +        self.distant_automatic = common.check_box(self.frame, width=40,
│ │ +                    label="  Fully automatic distant arms (no control button)",
│ │ +                    tool_tip="Select to create without a distant signal control "+
│ │ +                    "(signal will have a default signal state of OFF, but can be "+
│ │ +                        "overridden to ON via the selections below)")
│ │ +        self.distant_automatic.pack(padx=2, pady=2)
│ │          self.override = common.check_box(self.frame, width=40,
│ │ -                    label="  Override signal to ON if section ahead occupied",
│ │ +                    label="  Override signal to ON if section ahead is occupied",
│ │                      tool_tip="Select to override the signal to ON if "+
│ │                      "the track section ahead of the signal is occupied")
│ │          self.override.pack(padx=2, pady=2)
│ │          self.override_ahead = common.check_box(self.frame, width=40,
│ │ -                    label="  Override if home signals ahead are at DANGER",
│ │ +                    label="  Override to CAUTION to reflect home signals ahead",
│ │                      tool_tip="Select to override distant signal to ON if "+
│ │                      "any home signals on the route ahead are at DANGER")
│ │          self.override_ahead.pack(padx=2, pady=2)
│ │                          
│ │ -    def set_values(self, override_sig:bool, fully_automatic:bool, override_ahead:bool):
│ │ -        self.override.set_value(override_sig)
│ │ -        self.automatic.set_value(fully_automatic)
│ │ +    def set_values(self, override:bool, main_auto:bool, override_ahead:bool, dist_auto:bool):
│ │ +        self.override.set_value(override)
│ │ +        self.automatic.set_value(main_auto)
│ │          self.override_ahead.set_value(override_ahead)
│ │ -        
│ │ +        self.distant_automatic.set_value(dist_auto)
│ │ +
│ │      def get_values(self):
│ │          return ( self.override.get_value(),
│ │                   self.automatic.get_value(),
│ │ -                 self.override_ahead.get_value() )
│ │ +                 self.override_ahead.get_value(),
│ │ +                 self.distant_automatic.get_value() )
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Class for a Timed signal route element comprising a route selection checkbox, a
│ │  # signal ID entry box and two integer entry boxes for specifying the timed sequence
│ │  # Public class instance methods provided by this class are 
│ │  #    "disable" - disables/blanks all checkboxes and selection boxes 
│ │  #    "enable"  enables/loads all checkboxes and selection boxes
│ │ @@ -265,15 +275,16 @@
│ │                     "trigger. This can be the current signal or another semaphore / colour light "+
│ │                              "signal (on the route ahead of the current signal)")
│ │          self.sig.pack(side=LEFT)
│ │          self.label3 = Label(self.frame, text="  Start delay:")
│ │          self.label3.pack(side=LEFT)
│ │          self.start = common.integer_entry_box(self.frame, width=3, min_value=0, max_value=60,
│ │                              allow_empty=False, tool_tip="Specify the time delay (in seconds) "+
│ │ -                            "before triggering the signal (set to zero for triggering the current signal)")
│ │ +                            "before triggering the timed sequence (if triggering the current signal " +
│ │ +                            " then this should be set to zero to trigger when the signal is passed)")
│ │          self.start.pack(side=LEFT)
│ │          self.label4 = Label(self.frame, text="  Time delay:")
│ │          self.label4.pack(side=LEFT)
│ │          self.delay = common.integer_entry_box(self.frame, width=3, min_value=0, max_value=60,
│ │                              allow_empty=False, tool_tip="Specify the time period (in seconds) "+
│ │                                                          "between signal aspect changes")
│ │          self.delay.pack(side=LEFT)
│ │ @@ -283,14 +294,17 @@
│ │              self.sig.enable1()
│ │              self.start.enable1()
│ │              self.delay.enable1()
│ │              # If no siganl ID is configured then set the ID to the current Signal ID
│ │              # So we start off with a valid configuration for the user to edit
│ │              if self.sig.get_value() == 0:
│ │                  self.sig.set_value(self.parent_object.config.sigid.get_initial_value())
│ │ +            # Start delays of zero are OK but timed delays of zero just aren't sensible
│ │ +            # We therefore always set a default of 5 seconds to provide a starting point
│ │ +            if self.delay.get_value() == 0: self.delay.set_value(5)
│ │          else:
│ │              self.sig.disable1()
│ │              self.start.disable1()
│ │              self.delay.disable1()
│ │      
│ │      def enable(self):
│ │          self.route.enable()
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/editor.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/editor.py
│ │┄ Files 21% similar despite different names
│ │ @@ -2,33 +2,41 @@
│ │  # This python module will launch the schematic editor (creating the top level window)
│ │  # The run_editor() function is called from '__main__.py' if the package is run as
│ │  # a module (-m) - or can be called externally (useful for running in a pyhon IDE)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  import tkinter
│ │  import logging
│ │ +from argparse import ArgumentParser
│ │  
│ │  from . import schematic
│ │  from . import menubar
│ │ -
│ │ +from . import settings
│ │  from ..library import common as library_common
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # This is where the code begins  
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def run_editor():
│ │      global logging
│ │ +    # Get the initial defaults for creating the canvas
│ │ +    width, height, grid = settings.get_canvas()
│ │      # Create the Main Root Window
│ │      root = tkinter.Tk()
│ │      # Create the menubar and editor canvas (canvas size will be set on creation)
│ │      main_window_menubar = menubar.main_menubar(root)
│ │ -    schematic.create_canvas(root, main_window_menubar.handle_canvas_event)
│ │ +    schematic.initialise(root, main_window_menubar.handle_canvas_event, width, height, grid)
│ │      # Initialise the editor (using the default config)
│ │      main_window_menubar.initialise_editor()
│ │ +    # Parse the command line arguments to get the filename (and load it)
│ │ +    parser = ArgumentParser(description =  "Model railway signalling "+settings.get_version())
│ │ +    parser.add_argument("-f","--file",dest="filename",help="schematic file to load on startup",metavar="FILE")
│ │ +    args = parser.parse_args()
│ │ +    if args.filename is not None: main_window_menubar.load_schematic(args.filename)
│ │      # Enter the TKinter main loop (with exception handling for keyboardinterrupt)
│ │      try: root.mainloop()
│ │      except KeyboardInterrupt:
│ │          logging.info("Keyboard Interrupt - Shutting down")
│ │          library_common.on_closing(ask_to_save_state=False)
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/menubar.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/menubar.py
│ │┄ Files 3% similar despite different names
│ │ @@ -2,22 +2,23 @@
│ │  # This module contains all the functions to process menubar selections
│ │  # 
│ │  # External API functions intended for use by other editor modules:
│ │  #    main_menubar(root) - the main menubar class - call once on initialisation
│ │  #    main_menubar.initialise_editor() - call once on initialisation
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ +#    objects.save_schematic_state() - Save the state following save or load
│ │  #    objects.set_all(new_objects) - Set the dict of objects following a load
│ │  #    objects.get_all() - Retrieve the dict of objects for saving to file
│ │ +#    objects.reset_objects() - Reset the schematic back to its default state
│ │  #    schematic.select_all_objects() - For selecting all objects prior to deletion
│ │  #    schematic.delete_selected_objects() - For deleting all objects (on new/load)
│ │  #    schematic.resize_canvas() - For updating the canvas following reload/resizing
│ │  #    schematic.enable_editing() - On mode toggle or load (if file is in edit mode)
│ │  #    schematic.disable_editing() - On mode toggle or load (if file is in run mode)
│ │ -#    run_layout.initialise_layout() - Initialise everything following a load
│ │  #    settings.get_canvas() - Get the current canvas settings (for editing)
│ │  #    settings.set_canvas(width,height,grid)) - Call following update/resizing/load
│ │  #    settings.get_all() - Get all settings (for save)
│ │  #    settings.set_all() - Set all settings (following load)
│ │  #    settings.get_version() - Get the Application version (for the 'About" window)
│ │  #    settings.get_general() - Get general settings - prior to a save
│ │  #    settings.set_general(filename,editmode) - following a reload
│ │ @@ -45,52 +46,51 @@
│ │  import logging
│ │  import webbrowser
│ │  
│ │  from . import common
│ │  from . import objects
│ │  from . import settings
│ │  from . import schematic
│ │ -from . import run_layout
│ │  
│ │  from ..library import file_interface
│ │  from ..library import pi_sprog_interface
│ │  from ..library import common as library_common
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Class for the "Help" window
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  help_text = """
│ │  Application documentation is still on the 'ToDo' list, but in the meantime here is some
│ │  basic guidance and top tips for creating your layout signalling system:
│ │  
│ │  1) Save your progress - The editor is still in active development so may still contain
│ │ -   latent bugs (any you find please do report back to me so I can fix them). Its also
│ │ -   worth mentioning that there is no 'undo' function as yet - that's coming soon.
│ │ +   latent bugs (any you find please do report back to me so I can fix them).
│ │  2) Draw the track layout (points and lines) before adding any signals or the schematic may
│ │     get cluttered (making it difficult to select the thing you want to move or edit).
│ │  3) Complete the signal configuration (signal type, routes indications, DCC addresses etc)
│ │     before interlocking (available interlocking selections are driven by this).
│ │  4) Tooltips (hover-over) have been added to most of the UI elements which will hopefully
│ │     provide an insight as to what information needs to be entered (if they don't then please
│ │     let me know and I will try and make them clearer in a future release)
│ │  
│ │ -Schematic functions:
│ │ +Schematic functions (in edit mode):
│ │   
│ │  1) Use the photoimage buttons on the left to add objects to the schematic.
│ │  2) Left-click to select objects (shift-left-click will 'add' to the selection).
│ │  3) Left-click / release to drag / drop selected objects around the schematic.
│ │  4) Double-left-click on a point or signal to open the object configuraton window
│ │  5) Left-click on the 'end' of a selected line to move/edit the position
│ │  6) Left-click / release (when not over an object) can also be used for an 'area' selection
│ │  7) Right-click on an object or the canvas to bring up additional options
│ │  8) <r> will rotate all selected point and signal objects by 180 degrees
│ │  9) <backspace> will permanently delete all selected object from the schematic
│ │  10) <cntl-c> will copy all currently selected objects to a copy/paste buffer
│ │  11) <cntl-v> will paste the selected objects at a slightly offset position
│ │ +11) <cntl-z> / <cntl-y>  undo and redo for schematic and object configuration changes
│ │  12) <m> will toggle the schematic editor between Edit Mode and Run Mode
│ │  
│ │  Menubar Options
│ │  
│ │  1) File - All the functions you would expect
│ │  2) Mode - Selects the schematic editor mode (Edit Mode or Run Mode)
│ │  3) SPROG - Opens the serial port and connects to the SPROG
│ │ @@ -385,15 +385,16 @@
│ │      def save_state(self, parent_object, close_window:bool):
│ │          # Parent object is passed by the callback - not used here
│ │          # Only allow the changes to be applied / window closed if both values are valid
│ │          if self.width.validate() and self.height.validate():
│ │              width = self.width.get_value()
│ │              height = self.height.get_value()
│ │              settings.set_canvas(width=width, height=height)
│ │ -            schematic.resize_canvas()
│ │ +            grid = settings.get_canvas()[2]
│ │ +            schematic.update_canvas(width, height, grid)
│ │              # close the window (on OK or cancel)
│ │              if close_window: self.window.destroy()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Top level classfor the toolbar window
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ @@ -413,14 +414,15 @@
│ │          self.file_menu.add_command(label=" Quit",command=lambda:self.quit_schematic())
│ │          self.mainmenubar.add_cascade(label="File  ", menu=self.file_menu)
│ │          # Create the various menubar items for the Mode Dropdown
│ │          self.mode_label = "Mode:Edit  "
│ │          self.mode_menu = Menu(self.mainmenubar,tearoff=False)
│ │          self.mode_menu.add_command(label=" Edit ", command=self.edit_mode)
│ │          self.mode_menu.add_command(label=" Run  ", command=self.run_mode)
│ │ +        self.mode_menu.add_command(label=" Reset", command=self.reset_layout)
│ │          self.mainmenubar.add_cascade(label=self.mode_label, menu=self.mode_menu)
│ │          # Create the various menubar items for the SPROG Connection Dropdown
│ │          self.sprog_label = "SPROG:DISCONNECTED "
│ │          self.sprog_menu = Menu(self.mainmenubar,tearoff=False)
│ │          self.sprog_menu.add_command(label=" Connect ", command=self.sprog_connect)
│ │          self.mainmenubar.add_cascade(label=self.sprog_label, menu=self.sprog_menu)
│ │          # Create the various menubar items for the DCC Power Dropdown
│ │ @@ -445,15 +447,15 @@
│ │          # And then re-bind the close window event to the editor quit function
│ │          library_common.find_root_window(self.mainmenubar)
│ │          self.root.protocol("WM_DELETE_WINDOW", self.quit_schematic)
│ │          # Flag to track whether the new configuration has been saved or not
│ │          # Used to enforce a "save as" dialog on the initial save of a new layout
│ │          self.file_has_been_saved = False
│ │          
│ │ -    # Common initialisation function (called on editor start or layout load)
│ │ +    # Common initialisation function (called on editor start or layout load or new layout)
│ │      def initialise_editor(self):
│ │          # Set the root window label to the name of the current file (split from the dir path)
│ │          # The fully qualified filename is the first parameter provided by 'get_general'
│ │          path, name = os.path.split(settings.get_general()[0])
│ │          self.root.title(name)
│ │          # Set the edit mode (2nd param in the returned tuple)
│ │          if settings.get_general()[1]: self.edit_mode()
│ │ @@ -466,14 +468,17 @@
│ │          elif initial_log_level == 3: logging.getLogger().setLevel(logging.INFO)
│ │          elif initial_log_level == 4: logging.getLogger().setLevel(logging.DEBUG)
│ │          # Initialise the SPROG (if configured). Note that we use the menubar functions
│ │          # for connection and the DCC power so these are correctly reflected in the UI
│ │          port, baud, debug, startup, power = settings.get_sprog()
│ │          if startup: self.sprog_connect()
│ │          if power: self.dcc_power_on()
│ │ +        # Re-size the canvas to reflect the new schematic size
│ │ +        width, height, grid = settings.get_canvas()
│ │ +        schematic.update_canvas(width, height, grid)
│ │          
│ │      def handle_canvas_event(self, event=None):
│ │          # Handle the Toggle Mode Event ('m' key)
│ │          if event.keysym == 'm':
│ │              # the Edit mode flag is the second parameter returned
│ │              if settings.get_general()[1]: self.run_mode()
│ │              else: self.edit_mode()
│ │ @@ -488,14 +493,22 @@
│ │      def run_mode(self):
│ │          new_label = "Mode:Run   "
│ │          self.mainmenubar.entryconfigure(self.mode_label, label=new_label)
│ │          self.mode_label = new_label
│ │          settings.set_general(editmode=False)
│ │          schematic.disable_editing()
│ │  
│ │ +    def reset_layout(self, ask_for_confirm:bool=True):
│ │ +        if ask_for_confirm:
│ │ +            if messagebox.askokcancel("Reset Schematic", "Are you sure you want to reset all "+
│ │ +                    "signals, points and track occupancy sections back to their default state"):
│ │ +                objects.reset_objects()
│ │ +        else:
│ │ +            objects.reset_objects()
│ │ +
│ │      def sprog_connect(self):
│ │          port, baud, debug, startup, power = settings.get_sprog()
│ │          connected = pi_sprog_interface.initialise_pi_sprog(port, baud, debug)
│ │          if connected:
│ │              new_label = "SPROG:CONNECTED "
│ │              self.mainmenubar.entryconfigure(self.sprog_label, label=new_label)
│ │              self.sprog_label = new_label
│ │ @@ -515,31 +528,38 @@
│ │      def dcc_power_on(self):
│ │          # The power on request returns True if successful 
│ │          if pi_sprog_interface.request_dcc_power_on():
│ │              new_label = "DCC Power:ON  "
│ │              self.mainmenubar.entryconfigure(self.power_label, label=new_label)
│ │              self.power_label = new_label
│ │  
│ │ -    def quit_schematic(self):
│ │ -        if messagebox.askokcancel("Quit Schematic", "Are you sure you want to "+
│ │ -                             "discard all changes and quit the application"):
│ │ +    def quit_schematic(self, ask_for_confirm:bool=True):
│ │ +        # Note that 'confirmation' is defaulted to 'True' for normal use (i.e. when this function
│ │ +        # is called as a result of a menubar selection) to enforce the confirmation dialog. If
│ │ +        # 'confirmation' is False (system_test_harness use case) then the dialogue is surpressed
│ │ +        if not ask_for_confirm or messagebox.askokcancel("Quit Schematic",
│ │ +                "Are you sure you want to discard all changes and quit the application"):
│ │              library_common.on_closing(ask_to_save_state=False)
│ │          return()
│ │                  
│ │ -    def new_schematic(self):
│ │ -        if messagebox.askokcancel("New Schematic", "Are you sure you want to "+
│ │ -                         "discard all changes and create a new blank schematic"):
│ │ +    def new_schematic(self, ask_for_confirm:bool=True):
│ │ +        # Note that 'confirmation' is defaulted to 'True' for normal use (i.e. when this function
│ │ +        # is called as a result of a menubar selection) to enforce the confirmation dialog. If
│ │ +        if not ask_for_confirm or messagebox.askokcancel("New Schematic", "Are you sure you "+
│ │ +                         "want to discard all changes and create a new blank schematic"):
│ │              # We use the schematic functions to delete all existing objects to
│ │              # ensure they are also deselected and removed from the clibboard 
│ │              schematic.select_all_objects()
│ │              schematic.delete_selected_objects()
│ │              # Restore the default settings and update the editor config
│ │              settings.restore_defaults()
│ │ -            schematic.resize_canvas()
│ │ +            # Re-initialise the editor for the new settings to take effect
│ │              self.initialise_editor()
│ │ +            # save the current state (for undo/redo) - deleting all previous history
│ │ +            objects.save_schematic_state(reset_pointer=True)
│ │          return()
│ │  
│ │      def save_schematic(self, save_as:bool=False):
│ │          settings_to_save = settings.get_all()
│ │          objects_to_save = objects.get_all()
│ │          filename_to_save = settings.get_general()[0]
│ │          # If the filename is the default "new_schematic.sig" then we force a 'save as'
│ │ @@ -553,32 +573,33 @@
│ │          if saved_filename is not None:
│ │              settings.set_general(filename=saved_filename)
│ │              path, name = os.path.split(saved_filename)
│ │              self.root.title(name)
│ │              self.file_has_been_saved = True
│ │          return()
│ │  
│ │ -    def load_schematic(self):
│ │ +    def load_schematic(self, filename=None):
│ │ +        # Note that 'filename' is defaulted to 'None' for normal use (i.e. when this function
│ │ +        # is called as a result of a menubar selection) to enforce the file selection dialog. If
│ │ +        # a filename is specified (system_test_harness use case) then the dialogue is surpressed
│ │          global logging
│ │          # Call the library function to load the base configuration file
│ │          # the 'file_loaded' will be the name of the file loaded or None (if not loaded)
│ │ -        file_loaded, layout_state = file_interface.load_schematic()
│ │ +        file_loaded, layout_state = file_interface.load_schematic(filename)
│ │          if file_loaded is not None:
│ │              # Do some basic validation that the file has the elements we need
│ │              if "settings" in layout_state.keys() and "objects" in layout_state.keys():
│ │                  # We use the schematic functions to delete all existing objects to
│ │                  # ensure they are also deselected and removed from the clibboard 
│ │                  schematic.select_all_objects()
│ │                  schematic.delete_selected_objects()
│ │                  # Store the newly loaded settings
│ │                  settings.set_all(layout_state["settings"])
│ │                  # Set the filename to reflect that actual name of the loaded file
│ │                  settings.set_general(filename=file_loaded)
│ │ -                # Re-size the canvas to reflect the new schematic size
│ │ -                schematic.resize_canvas()
│ │                  # Re-initailise the editor with the new configuration
│ │                  self.initialise_editor()
│ │                  # Create the loaded layout objects then purge the loaded state information
│ │                  objects.set_all(layout_state["objects"])
│ │                  # Purge the loaded state (to stope it being erroneously inherited
│ │                  # when items are deleted and then new items created with the same IDs)
│ │                  file_interface.purge_loaded_state_information()
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects.py
│ │┄ Files 24% similar despite different names
│ │ @@ -1,152 +1,319 @@
│ │  #------------------------------------------------------------------------------------
│ │ -# This module contains all the functions for managing layout objects
│ │ +# This module contains all the functions for managing layout objects. This is
│ │ +# effectively the "top-level" objects module (with all public API functions)
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions / objects intended for use by other editor modules:
│ │ -#
│ │ -#    set_canvas(canvas) called on start up to set a local canvas object reference
│ │ -#    enable_editing() - Call when 'Edit' Mode is selected (from Schematic Module)
│ │ -#    disable_editing() - Call when 'Run' Mode is selected (from Schematic Module)
│ │ +#    save_schematic_state(reset_pointer=False) - save the current snapshot ('load' or 'new')
│ │ +#    undo() / redo() - Undo and re-do functions as you would expect
│ │  #    set_all(new_objects) - Creates a new dictionary of objects (following a load)
│ │  #    get_all() - returns the current dictionary of objects (for saving to file)
│ │  #    create_object(obj_type, item_type, item_subtype) - create a new object on the canvas
│ │  #    delete_objects(list of obj IDs) - Delete the selected objects from the canvas
│ │  #    rotate_objects(list of obj IDs) - Rotate the selected objects on the canvas
│ │  #    move_objects(list of obj IDs) - Finalises the move of selected objects
│ │  #    copy_objects(list of obj IDs) - Copy the selected objects to the clipboard
│ │  #    paste_objects() - Paste Clipboard objects onto the canvas (returnslist of new IDs)
│ │  #    update_object(object ID, new_object) - update the config of an existing object
│ │ +#    reset_objects() - resets all points, signals, instruments and sections to default state
│ │  #
│ │ -# Objects intended to be accessed directly by other editor modules:
│ │ -#
│ │ -#    object_type - Enumeration type for the supported objects
│ │ -#    schematic_objects - For accessing/editing the configuration of an object
│ │ -#
│ │ -#    signal_index - for iterating through all the signal objects
│ │ -#    point_index - for iterating through all the point objects
│ │ -#    instrument_index - for iterating through all the instrument objects
│ │ -#    section_index - for iterating through all the section objects
│ │ -#
│ │ -#    signal(item_id) - helper function to find the object Id by Item ID
│ │ -#    point(item_id) - helper function to find the object Id by Item ID
│ │ -#    section(Id:int) - helper function to find the object Id by Item ID
│ │ -#    instrument(item_id) - helper function to find the object Id by Item ID
│ │ -#
│ │ -#    signal_exists (item_id) - Common function to see if a given item exists
│ │ -#    point_exists (item_id) - Common function to see if a given item exists
│ │ -#    section_exists (item_id) - Common function to see if a given item exists
│ │ -#    instrument_exists (item_id) - Common function to see if a given item exists
│ │ +# Makes the following external API calls to other editor modules:
│ │ +#    run_layout.initialise_layout() - Re-initiallise the state of schematic objects following a change
│ │ +#    run_layout.enable_editing() - To set "edit mode" for processing schematic object callbacks
│ │ +#    run_layout.disable_editing() - To set "edit mode" for processing schematic object callbacks
│ │ +#    objects_instruments.create_instrument(type) - Create a default object on the schematic
│ │ +#    objects_instruments.delete_instrument(object_id) - Hard Delete an object when deleted from the schematic
│ │ +#    objects_instruments.update_instrument(obj_id,new_obj) - Update the configuration of an existing instrument object
│ │ +#    objects_instruments.paste_instrument(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ +#    objects_instruments.delete_instrument_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    objects_instruments.redraw_instrument_object(object_id) - Redraw the object on the canvas following an update
│ │ +#    objects_instruments.default_instrument_object - The dictionary of default values for the object
│ │ +#    objects_lines.create_line() - Create a default object on the schematic
│ │ +#    objects_lines.delete_line(object_id) - Hard Delete an object when deleted from the schematic
│ │ +#    objects_lines.paste_line(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ +#    objects_lines.delete_line_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    objects_lines.redraw_line_object(object_id) - Redraw the object on the canvas following an update
│ │ +#    objects_lines.default_line_object - The dictionary of default values for the object
│ │ +#    objects_points.create_point(type) - Create a default object on the schematic
│ │ +#    objects_points.delete_point(obj_id) - Hard Delete an object when deleted from the schematic
│ │ +#    objects_points.update_point(obj_id,new_obj) - Update the configuration of an existing point object
│ │ +#    objects_points.paste_point(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ +#    objects_points.delete_point_object(object_id) - Soft delete the drawing object (prior to recreating)
│ │ +#    objects_points.redraw_point_object(object_id) - Redraw the object on the canvas following an update
│ │ +#    objects_points.default_point_object - The dictionary of default values for the object
│ │ +#    objects_points.reset_point_interlocking_tables() - recalculates interlocking tables from scratch
│ │ +#    objects_sections.create_section(type) - Create a default object on the schematic
│ │ +#    objects_sections.delete_section(object_id) - Hard Delete an object when deleted from the schematic
│ │ +#    objects_sections.update_section(obj_id,new_obj) - Update the configuration of an existing section object
│ │ +#    objects_sections.paste_section(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ +#    objects_sections.delete_section_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    objects_sections.redraw_section_object(object_id) - Redraw the object on the canvas following an update
│ │ +#    objects_sections.default_section_object - The dictionary of default values for the object
│ │ +#    objects_sections.enable_editing() - Called when 'Edit' Mode is selected (from Schematic Module)
│ │ +#    objects_sections.disable_editing() - Called when 'Run' Mode is selected (from Schematic Module)
│ │ +#    objects_signals.create_signal(type,subtype) - Create a default object on the schematic
│ │ +#    objects_signals.delete_signal(object_id) - Hard Delete an object when deleted from the schematic
│ │ +#    objects_signals.update_signal(obj_id,new_obj) - Update the configuration of an existing signal object
│ │ +#    objects_signals.paste_signal(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ +#    objects_signals.delete_signal_object(object_id) - soft delete the drawing object (prior to recreating)
│ │ +#    objects_signals.redraw_signal_object(object_id) - Redraw the object on the canvas following an update
│ │ +#    objects_signals.default_signal_object - The dictionary of default values for the object
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  import copy 
│ │  import logging
│ │  
│ │  from . import objects_common
│ │  from . import objects_signals
│ │  from . import objects_points
│ │  from . import objects_lines
│ │  from . import objects_sections
│ │  from . import objects_instruments
│ │ -from . import run_layout
│ │  
│ │ -from .objects_common import set_canvas as set_canvas
│ │ -from .objects_common import object_type as object_type
│ │ -from .objects_common import schematic_objects as schematic_objects
│ │ -
│ │ -from .objects_common import signal_index as signal_index
│ │ -from .objects_common import point_index as point_index
│ │ -from .objects_common import section_index as section_index
│ │ -from .objects_common import instrument_index as instrument_index
│ │ -
│ │ -from .objects_common import signal as signal
│ │ -from .objects_common import point as point
│ │ -from .objects_common import section as section
│ │ -from .objects_common import instrument as instrument
│ │ -
│ │ -from .objects_common import signal_exists as signal_exists
│ │ -from .objects_common import point_exists as point_exists
│ │ -from .objects_common import section_exists as section_exists
│ │ -from .objects_common import instrument_exists as instrument_exists
│ │ +from .. import run_layout
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Internal function to bring all track sections to the front of the canvas
│ │ +# This insures they are not obscured by any lines drawn on the canvas
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def bring_track_sections_to_the_front():
│ │ +    for object_id in objects_common.schematic_objects:
│ │ +        if objects_common.schematic_objects[object_id]["item"] == objects_common.object_type.section:
│ │ +            objects_common.canvas.tag_raise(objects_common.schematic_objects[object_id]["tags"])
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Internal Function to set (re-create) all schematic objects
│ │ +# Called following a file load or re-drawing for undo/redo
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def redraw_all_objects(create_new_bbox:bool):
│ │ +    for object_id in objects_common.schematic_objects:
│ │ +        # Set the bbox reference to none so it will be created on redraw
│ │ +        if create_new_bbox: objects_common.schematic_objects[object_id]["bbox"] = None
│ │ +        this_object_type = objects_common.schematic_objects[object_id]["item"]
│ │ +        if this_object_type == objects_common.object_type.line:
│ │ +            objects_lines.redraw_line_object(object_id)
│ │ +        elif this_object_type == objects_common.object_type.signal:                
│ │ +            objects_signals.redraw_signal_object(object_id)
│ │ +        elif this_object_type == objects_common.object_type.point:
│ │ +            objects_points.redraw_point_object(object_id)
│ │ +        elif this_object_type == objects_common.object_type.section:
│ │ +            objects_sections.redraw_section_object(object_id)
│ │ +        elif this_object_type == objects_common.object_type.instrument:
│ │ +            objects_instruments.redraw_instrument_object(object_id)
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Internal function to reset all item-specific indexes from the main schematic_objects
│ │ +# dictionary - called following item load and as part of undo/redo. Note that for
│ │ +# both of these cases, all existing entries will have been deleted when all schematic
│ │ +# objects were selected then deleted as part of the undo/redo or load layout
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def reset_all_schematic_indexes():
│ │ +    for object_id in objects_common.schematic_objects:
│ │ +        this_object_type = objects_common.schematic_objects[object_id]["item"]
│ │ +        this_object_id = objects_common.schematic_objects[object_id]["itemid"]
│ │ +        if this_object_type == objects_common.object_type.signal:                
│ │ +            objects_common.signal_index[str(this_object_id)] = object_id
│ │ +        elif this_object_type == objects_common.object_type.point:
│ │ +            objects_common.point_index[str(this_object_id)] = object_id
│ │ +        elif this_object_type == objects_common.object_type.section:
│ │ +            objects_common.section_index[str(this_object_id)] = object_id
│ │ +        elif this_object_type == objects_common.object_type.instrument:
│ │ +            objects_common.instrument_index[str(this_object_id)] = object_id
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Undo and redo functions - the 'save_schematic_state' function should be called after
│ │ +# every change the schematic or a change to any object on the schematic to take a snapshot
│ │ +# and add this to the undo buffer. 'undo' and 'redo' then work as you'd expect
│ │ +# 'restore_schematic_state' is the internal function used by 'undo' and 'redo'
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +undo_buffer = [{}]
│ │ +undo_pointer = 0
│ │ +
│ │ +def save_schematic_state(reset_pointer:bool=False):
│ │ +    global undo_buffer
│ │ +    global undo_pointer
│ │ +    # The undo buffer is reset following 'layout load' or 'new layout'
│ │ +    if reset_pointer: undo_pointer = 0
│ │ +    else:undo_pointer = undo_pointer + 1
│ │ +    # If the undo pointer isn't at the end of the undo buffer when a change is made
│ │ +    # then we need to clear everything from the undo buffer forward of this point
│ │ +    if len(undo_buffer) > undo_pointer:
│ │ +        undo_buffer = undo_buffer[:undo_pointer]
│ │ +    undo_buffer.append({})
│ │ +    # Save a snapshot of all schematic objects - I had a few issues with copy and
│ │ +    # deepcopy not working as I was expecting but copying one object at a time works
│ │ +    snapshot_objects = objects_common.schematic_objects
│ │ +    for object_id in snapshot_objects:
│ │ +        undo_buffer[undo_pointer][object_id] = copy.deepcopy(snapshot_objects[object_id])
│ │ +    return()
│ │ +
│ │ +def undo():
│ │ +    global undo_pointer
│ │ +    if undo_pointer > 0:
│ │ +        undo_pointer = undo_pointer - 1
│ │ +        restore_schematic_state()
│ │ +    return() 
│ │ +        
│ │ +def redo():
│ │ +    global undo_pointer
│ │ +    if undo_pointer < len(undo_buffer)-1:
│ │ +        undo_pointer = undo_pointer + 1
│ │ +        restore_schematic_state()
│ │ +    return()
│ │ +
│ │ +def restore_schematic_state():
│ │ +    global undo_pointer
│ │ +    # Delete all current objects gracefully. We create a list of objects to delete rather than
│ │ +    # just iterating through the main dictionary otherwise the dict would disappear from underneath
│ │ +    objects_to_delete = []
│ │ +    for object_id in objects_common.schematic_objects:
│ │ +        objects_to_delete.append(object_id)
│ │ +    for object_id in objects_to_delete:
│ │ +        delete_object(object_id)
│ │ +    # Restore the main schematic object dictionary from the snapshot - I had a few issues with
│ │ +    # copy and deepcopy not working as I was expecting but copying one object at a time works
│ │ +    snapshot_objects = undo_buffer[undo_pointer]
│ │ +    for object_id in snapshot_objects:
│ │ +        objects_common.schematic_objects[object_id] = copy.deepcopy(snapshot_objects[object_id])
│ │ +    # Set the seperate schematic dictionary indexes from the restored schematic objects dict
│ │ +    reset_all_schematic_indexes()
│ │ +    # Re-draw all objects, ensuring a new bbox is created for each object
│ │ +    redraw_all_objects(create_new_bbox=True)
│ │ +    # Ensure all track sections are brought forward on the schematic (in front of any lines)
│ │ +    bring_track_sections_to_the_front()
│ │ +    # Recalculate instrument interlocking tables as a 'belt and braces' measure (on the 
│ │ +    # basis they would have successfully been restored with the rest of the snapshot)
│ │ +    objects_points.reset_point_interlocking_tables()
│ │ +    return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Functions to make any necessary object configuration changes when changing mode
│ │ -# Called from the Schematic Module when the mode is changed (edit or Run)
│ │ +# Functions to Enable and disable editing 
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def enable_editing():
│ │      objects_sections.enable_editing()
│ │      run_layout.enable_editing()
│ │      return()
│ │  
│ │  def disable_editing():
│ │      objects_sections.disable_editing()
│ │      run_layout.disable_editing()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Function to reset the schematic back to its default state with all signals 'on',
│ │ +# all points 'unswitched', all track sections 'unoccupied' and all block instruments
│ │ +# showing 'line blocked' (by soft deleting all objects and redrawing them)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def reset_objects():
│ │ +    # Soft delete all point, section, instrument and signal objects (keeping the bbox)
│ │ +    for object_id in objects_common.schematic_objects:
│ │ +        type_of_object = objects_common.schematic_objects[object_id]["item"]
│ │ +        if type_of_object == objects_common.object_type.signal:
│ │ +            objects_signals.delete_signal_object(object_id)
│ │ +        elif type_of_object == objects_common.object_type.point:
│ │ +             objects_points.delete_point_object(object_id)
│ │ +        elif type_of_object == objects_common.object_type.section:
│ │ +            objects_sections.delete_section_object(object_id)
│ │ +        elif type_of_object == objects_common.object_type.instrument:
│ │ +            objects_instruments.delete_instrument_object(object_id)
│ │ +    # Redraw all point, section, instrument and signal objects in their default state
│ │ +    # We don't need to create a new bbox as soft_delete keeps the tkinter object
│ │ +    redraw_all_objects(create_new_bbox=False)
│ │ +    # Ensure all track sections are brought forward on the schematic (in front of any lines)
│ │ +    bring_track_sections_to_the_front()
│ │ +    # Process any layout changes (interlocking, signal ahead etc)
│ │ +    # that might be dependent on the object configuration change
│ │ +    run_layout.initialise_layout()
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Function to Create a new schematic object and draw it on the canvas
│ │  # Called from the Schematic Module when an "add object" button is clicked
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def create_object(new_object_type, item_type=None, item_subtype=None):
│ │ -    if new_object_type == object_type.line:
│ │ +    if new_object_type == objects_common.object_type.line:
│ │          objects_lines.create_line() 
│ │ -    elif new_object_type == object_type.signal:
│ │ +    elif new_object_type == objects_common.object_type.signal:
│ │          objects_signals.create_signal(item_type, item_subtype)
│ │ -    elif new_object_type == object_type.point:
│ │ +    elif new_object_type == objects_common.object_type.point:
│ │           objects_points.create_point(item_type)
│ │ -    elif new_object_type == object_type.section:
│ │ +    elif new_object_type == objects_common.object_type.section:
│ │          objects_sections.create_section()
│ │ -    elif new_object_type == object_type.instrument:
│ │ -        objects_instruments.create_instrument()    
│ │ +    elif new_object_type == objects_common.object_type.instrument:
│ │ +        objects_instruments.create_instrument()
│ │ +    # save the current state (for undo/redo)
│ │ +    save_schematic_state()
│ │      # As we are creating 'new' objects we don't need to process layout changes
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to update the configuration of an existing schematic object and re-draw it
│ │  # in its new configuration (delete the drawing objects then re-draw in the new configuration)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def update_object(object_id, new_object):
│ │ -    type_of_object = schematic_objects[object_id]["item"]
│ │ -    if type_of_object == object_type.line:
│ │ +    type_of_object = objects_common.schematic_objects[object_id]["item"]
│ │ +    if type_of_object == objects_common.object_type.line:
│ │          pass
│ │ -    elif type_of_object == object_type.signal:
│ │ +    elif type_of_object == objects_common.object_type.signal:
│ │          objects_signals.update_signal(object_id, new_object)
│ │ -    elif type_of_object == object_type.point:
│ │ +    elif type_of_object == objects_common.object_type.point:
│ │          objects_points.update_point(object_id, new_object)
│ │ -    elif type_of_object == object_type.section:
│ │ +    elif type_of_object == objects_common.object_type.section:
│ │          objects_sections.update_section(object_id, new_object)
│ │ -    elif type_of_object == object_type.instrument:
│ │ +    elif type_of_object == objects_common.object_type.instrument:
│ │          objects_instruments.update_instrument(object_id, new_object)
│ │ +    # save the current state (for undo/redo)
│ │ +    save_schematic_state()
│ │      # Process any layout changes (interlocking, signal ahead etc)
│ │      # that might be dependent on the object configuration change
│ │      run_layout.initialise_layout()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Common Function to permanently Delete an objects from the schematic
│ │ +# Called from the delete_objects and also the undo/redo functions
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def delete_object(object_id):
│ │ +    type_of_object = objects_common.schematic_objects[object_id]["item"]
│ │ +    if type_of_object == objects_common.object_type.line:
│ │ +        objects_lines.delete_line(object_id) 
│ │ +    elif type_of_object == objects_common.object_type.signal:
│ │ +        objects_signals.delete_signal(object_id)
│ │ +    elif type_of_object == objects_common.object_type.point:
│ │ +         objects_points.delete_point(object_id)
│ │ +    elif type_of_object == objects_common.object_type.section:
│ │ +        objects_sections.delete_section(object_id)
│ │ +    elif type_of_object == objects_common.object_type.instrument:
│ │ +        objects_instruments.delete_instrument(object_id)
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Function to permanently Delete one or more objects from the schematic
│ │  # Called from the Schematic Module when selected objects are deleted
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_objects(list_of_object_ids):
│ │      for object_id in list_of_object_ids:
│ │ -        type_of_object = schematic_objects[object_id]["item"]
│ │ -        if type_of_object == object_type.line:
│ │ -            objects_lines.delete_line(object_id) 
│ │ -        elif type_of_object == object_type.signal:
│ │ -            objects_signals.delete_signal(object_id)
│ │ -        elif type_of_object == object_type.point:
│ │ -             objects_points.delete_point(object_id)
│ │ -        elif type_of_object == object_type.section:
│ │ -            objects_sections.delete_section(object_id)
│ │ -        elif type_of_object == object_type.instrument:
│ │ -            objects_instruments.delete_instrument(object_id)
│ │ +        delete_object(object_id)
│ │ +    # save the current state (for undo/redo)
│ │ +    save_schematic_state()
│ │      # Process any layout changes (interlocking, signal ahead etc)
│ │      # that might need to change following objet deletion
│ │      run_layout.initialise_layout()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Rotate one or more objects on the schematic
│ │ @@ -154,61 +321,66 @@
│ │  # Only Points and Signals can be rotated - all other objects are unchanged
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def rotate_objects(list_of_object_ids):
│ │      # Note that we do all deletions prior to re-drawing as tkinter doesn't seem to like
│ │      # processing a load of intermixed deletes/creates when it returns to the main loop
│ │      for object_id in list_of_object_ids:
│ │ -        type_of_object = schematic_objects[object_id]["item"]            
│ │ +        type_of_object = objects_common.schematic_objects[object_id]["item"]            
│ │          # Delete the drawing objects from the canvas
│ │ -        if type_of_object == object_type.signal: objects_signals.delete_signal_object(object_id)
│ │ -        elif type_of_object == object_type.point: objects_points.delete_point_object(object_id)
│ │ +        if type_of_object == objects_common.object_type.signal: objects_signals.delete_signal_object(object_id)
│ │ +        elif type_of_object == objects_common.object_type.point: objects_points.delete_point_object(object_id)
│ │      # Re-draw the drawing objects on the canvas in their new position
│ │      for object_id in list_of_object_ids:
│ │ -        type_of_object = schematic_objects[object_id]["item"]            
│ │ -        if type_of_object in (object_type.signal,object_type.point):
│ │ +        type_of_object = objects_common.schematic_objects[object_id]["item"]            
│ │ +        if type_of_object in (objects_common.object_type.signal,objects_common.object_type.point):
│ │              # Work out the orientation change based on the current orientation
│ │ -            orientation = schematic_objects[object_id]["orientation"]
│ │ -            if orientation == 0: schematic_objects[object_id]["orientation"] = 180
│ │ -            else: schematic_objects[object_id]["orientation"] = 0
│ │ -            if type_of_object == object_type.signal: objects_signals.redraw_signal_object(object_id)
│ │ -            elif type_of_object == object_type.point: objects_points.redraw_point_object(object_id)    
│ │ +            orientation = objects_common.schematic_objects[object_id]["orientation"]
│ │ +            if orientation == 0: objects_common.schematic_objects[object_id]["orientation"] = 180
│ │ +            else: objects_common.schematic_objects[object_id]["orientation"] = 0
│ │ +            if type_of_object == objects_common.object_type.signal: objects_signals.redraw_signal_object(object_id)
│ │ +            elif type_of_object == objects_common.object_type.point: objects_points.redraw_point_object(object_id)    
│ │ +    # save the current state (for undo/redo)
│ │ +    save_schematic_state()
│ │      # As we are just rotating objects we don't need to process layout changes
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to finalise the move of selected objects on the schematic. The objects
│ │  # themselves will have already been moved on the canvas and snapped to the grid
│ │  # so we just need to update the object configuration to reflect the new positions.
│ │  # Note that the function also caters for the editing of lines - in this case we will
│ │  # be given a single object id and either the xdiff1/ydiff1 or xdiff2/ydiff2 will be
│ │  # passed to signify which end of the line needs to be updated
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def move_objects(list_of_object_ids, xdiff1:int=None,
│ │              ydiff1:int=None, xdiff2:int=None, ydiff2:int=None):
│ │ -    for object_id in list_of_object_ids:
│ │ -        type_of_object = schematic_objects[object_id]["item"]            
│ │ -        if type_of_object == object_type.line:
│ │ -            if xdiff1 is not None and ydiff1 is not None:
│ │ -                schematic_objects[object_id]["posx"] += xdiff1 
│ │ -                schematic_objects[object_id]["posy"] += ydiff1 
│ │ -            if xdiff2 is not None and ydiff2 is not None:
│ │ -                schematic_objects[object_id]["endx"] += xdiff2 
│ │ -                schematic_objects[object_id]["endy"] += ydiff2 
│ │ -            # Update the boundary box to reflect the new line position
│ │ -            objects_common.set_bbox(object_id,objects_common.canvas.bbox
│ │ -                            (schematic_objects[object_id]["line"]))
│ │ -        else:
│ │ -            schematic_objects[object_id]["posx"] += xdiff1 
│ │ -            schematic_objects[object_id]["posy"] += ydiff2
│ │ -    # Ensure all track sections are on top
│ │ -    for object_id in schematic_objects:
│ │ -        if schematic_objects[object_id]["item"] == objects_common.object_type.section:
│ │ -            objects_common.canvas.tag_raise(schematic_objects[object_id]["tags"])
│ │ +    # Only bother processing the update if there has been a change
│ │ +    if ( (xdiff1 is not None and xdiff1 !=0) or (ydiff1 is not None and ydiff1 !=0) or
│ │ +         (xdiff2 is not None and xdiff2 !=0) or (ydiff2 is not None and ydiff2 !=0) ): 
│ │ +        for object_id in list_of_object_ids:
│ │ +            type_of_object = objects_common.schematic_objects[object_id]["item"]            
│ │ +            if type_of_object == objects_common.object_type.line:
│ │ +                if xdiff1 is not None and ydiff1 is not None:
│ │ +                    objects_common.schematic_objects[object_id]["posx"] += xdiff1 
│ │ +                    objects_common.schematic_objects[object_id]["posy"] += ydiff1 
│ │ +                if xdiff2 is not None and ydiff2 is not None:
│ │ +                    objects_common.schematic_objects[object_id]["endx"] += xdiff2 
│ │ +                    objects_common.schematic_objects[object_id]["endy"] += ydiff2 
│ │ +                # Update the boundary box to reflect the new line position
│ │ +                objects_common.set_bbox(object_id,objects_common.canvas.bbox
│ │ +                                (objects_common.schematic_objects[object_id]["line"]))
│ │ +            else:
│ │ +                objects_common.schematic_objects[object_id]["posx"] += xdiff1 
│ │ +                objects_common.schematic_objects[object_id]["posy"] += ydiff2
│ │ +        # Ensure all track sections are in front of any lines
│ │ +        bring_track_sections_to_the_front()
│ │ +        # save the current state (for undo/redo)
│ │ +        save_schematic_state()
│ │      # As we are just moving objects we don't need to process layout changes
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Copy one or more objects on the schematic to the clipboard
│ │  # Called from the Schematic Module when selected objects are copied
│ │  #------------------------------------------------------------------------------------
│ │ @@ -216,116 +388,107 @@
│ │  clipboard=[]
│ │  
│ │  def copy_objects(list_of_object_ids):
│ │      global clipboard
│ │      clipboard=[]
│ │      for object_id in list_of_object_ids:
│ │          # Take a deep copy of the object and add to the clipboard
│ │ -        clipboard.append(copy.deepcopy(schematic_objects[object_id]))
│ │ +        clipboard.append(copy.deepcopy(objects_common.schematic_objects[object_id]))
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to paste copies of the current clipboard objects to the canvas
│ │  # Called from the Schematic Modulee on 'paste' - returns a list of new object_ids
│ │  # Note that the object_ids, item_ids and canvas positions are reassigned on 'paste'
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def paste_objects():
│ │      list_of_new_object_ids=[]
│ │ +    # New objects are "pasted" at a slightly offset position on the canvas
│ │ +    deltax, deltay = objects_common.canvas_grid, objects_common.canvas_grid
│ │ +    # Create a copy of each object in the clipboard (depending on type)
│ │      for object_to_paste in clipboard:
│ │ -        # Paste the Copy the object (depending on type)
│ │          type_of_object = object_to_paste["item"]
│ │ -        if type_of_object == object_type.line:
│ │ -            new_object_id = objects_lines.paste_line(object_to_paste)
│ │ -        if type_of_object == object_type.signal:
│ │ -            new_object_id = objects_signals.paste_signal(object_to_paste)
│ │ -        elif type_of_object == object_type.point:
│ │ -            new_object_id = objects_points.paste_point(object_to_paste)
│ │ -        elif type_of_object == object_type.section:
│ │ -            new_object_id = objects_sections.paste_section(object_to_paste)
│ │ -        elif type_of_object == object_type.instrument:
│ │ -            new_object_id = objects_instruments.paste_instrument(object_to_paste)
│ │ +        if type_of_object == objects_common.object_type.line:
│ │ +            new_object_id = objects_lines.paste_line(object_to_paste, deltax, deltay)
│ │ +        if type_of_object == objects_common.object_type.signal:
│ │ +            new_object_id = objects_signals.paste_signal(object_to_paste, deltax, deltay)
│ │ +        elif type_of_object == objects_common.object_type.point:
│ │ +            new_object_id = objects_points.paste_point(object_to_paste, deltax, deltay)
│ │ +        elif type_of_object == objects_common.object_type.section:
│ │ +            new_object_id = objects_sections.paste_section(object_to_paste, deltax, deltay)
│ │ +        elif type_of_object == objects_common.object_type.instrument:
│ │ +            new_object_id = objects_instruments.paste_instrument(object_to_paste, deltax, deltay)
│ │          # Add the new object to the list of clipboard objects
│ │          # in case the user wants to paste the same objects again
│ │          list_of_new_object_ids.append(new_object_id)
│ │ -    # Ensure all track sections are on top
│ │ -    for object_id in schematic_objects:
│ │ -        if schematic_objects[object_id]["item"] == objects_common.object_type.section:
│ │ -            objects_common.canvas.tag_raise(schematic_objects[object_id]["tags"])
│ │ +    # Ensure all track sections are in front of any lines
│ │ +    bring_track_sections_to_the_front()
│ │ +    # save the current state (for undo/redo)
│ │ +    save_schematic_state()
│ │      # As we are just pasting 'new' objects we don't need to process layout changes
│ │      return(list_of_new_object_ids)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to set (re-create) all schematic objects (following a file load)
│ │ +# Note that there is a dependancy that the main schematic objects dict is empty
│ │ +# i.e. any legacy objects existing prior to the load will have been deleted first
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def set_all(new_objects):
│ │      global logging
│ │      # For each loaded object, create a new default object of the same type
│ │      # and then copy across each element in turn. This is defensive programming
│ │      # to populate the objects gracefully whilst handling changes to an object
│ │      # structre (e.g. new element introduced since the file was last saved)
│ │      for object_id in new_objects:
│ │          new_object_type = new_objects[object_id]["item"]
│ │ -        if new_object_type == object_type.line:
│ │ +        if new_object_type == objects_common.object_type.line:
│ │              default_object = objects_lines.default_line_object
│ │ -        elif new_object_type == object_type.signal:
│ │ +        elif new_object_type == objects_common.object_type.signal:
│ │              default_object = objects_signals.default_signal_object
│ │ -        elif new_object_type == object_type.point:
│ │ +        elif new_object_type == objects_common.object_type.point:
│ │              default_object = objects_points.default_point_object
│ │ -        elif new_object_type == object_type.section:
│ │ +        elif new_object_type == objects_common.object_type.section:
│ │              default_object = objects_sections.default_section_object
│ │ -        elif new_object_type == object_type.instrument:
│ │ +        elif new_object_type == objects_common.object_type.instrument:
│ │              default_object = objects_instruments.default_instrument_object
│ │          else:
│ │              default_object = {}
│ │              logging.error("LOAD LAYOUT - Object type '"+new_object_type+" not recognised")
│ │          # Populate each element at a time and report any elements not recognised
│ │          if default_object != {}:
│ │ -            schematic_objects[object_id] = copy.deepcopy(default_object)
│ │ +            objects_common.schematic_objects[object_id] = copy.deepcopy(default_object)
│ │              for element in new_objects[object_id]:
│ │                  if element not in default_object.keys():
│ │                      logging.warning("LOAD LAYOUT - Unexpected "+new_object_type+" element '"+element+"'")
│ │                  else:
│ │ -                    schematic_objects[object_id][element] = new_objects[object_id][element]        
│ │ +                    objects_common.schematic_objects[object_id][element] = new_objects[object_id][element]        
│ │              # Now report any elements missing from the new object - intended to provide a
│ │              # level of backward capability (able to load old config files into an extended config)
│ │              for element in default_object:
│ │                  if element not in new_objects[object_id].keys():
│ │                      logging.warning("LOAD LAYOUT - Missing "+new_object_type+" element '"+element+"'")
│ │ -            # Set the Boundary box for the new object to None so it gets created on re-draw
│ │ -            schematic_objects[object_id]["bbox"] = None
│ │ -            # Update the object indexes and all redraw each object on the schematic
│ │ -            if new_object_type == object_type.line:
│ │ -                objects_lines.redraw_line_object(object_id)
│ │ -            elif new_object_type == object_type.signal:                
│ │ -                signal_index[str(schematic_objects[object_id]["itemid"])] = object_id
│ │ -                objects_signals.redraw_signal_object(object_id)
│ │ -            elif new_object_type == object_type.point:
│ │ -                point_index[str(schematic_objects[object_id]["itemid"])] = object_id
│ │ -                objects_points.redraw_point_object(object_id)
│ │ -            elif new_object_type == object_type.section:
│ │ -                section_index[str(schematic_objects[object_id]["itemid"])] = object_id
│ │ -                objects_sections.redraw_section_object(object_id)
│ │ -            elif new_object_type == object_type.instrument:
│ │ -                instrument_index[str(schematic_objects[object_id]["itemid"])] = object_id
│ │ -                objects_instruments.redraw_instrument_object(object_id)
│ │ -    # Ensure all track sections are on top
│ │ -    for object_id in schematic_objects:
│ │ -        if schematic_objects[object_id]["item"] == objects_common.object_type.section:
│ │ -            objects_common.canvas.tag_raise(schematic_objects[object_id]["tags"])
│ │ -    # Refresh the point interlocking tables to reflect the signal interlocking
│ │ -    # selections - this is a belt and braces thing as the loaded point interlocking
│ │ -    # tables should exactly match the loaded signal interlocking tables
│ │ +    # Reset the signal/point/section/instrument indexes
│ │ +    reset_all_schematic_indexes()
│ │ +    # Redraw (re-create) all items on the schematic with a new bbox
│ │ +    redraw_all_objects(create_new_bbox=True)
│ │ +    # Ensure all track sections are in front of any lines
│ │ +    bring_track_sections_to_the_front()
│ │ +    # Recalculate point interlocking tables as a 'belt and braces' measure (on the 
│ │ +    # basis they would have successfully been loaded with the rest of the configuration)
│ │      objects_points.reset_point_interlocking_tables()
│ │      # Initialise the layout (interlocking changes, signal aspects etc)
│ │      run_layout.initialise_layout()    
│ │ +    # save the current state (for undo/redo) - deleting all previous history
│ │ +    save_schematic_state(reset_pointer=True)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function get the current objects dictionary (for saving to file)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def get_all():
│ │ -    return(schematic_objects)
│ │ +    return(objects_common.schematic_objects)
│ │ +
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects_common.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_common.py
│ │┄ Files 14% similar despite different names
│ │ @@ -1,159 +1,189 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the common internal functions for managing layout objects
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ -#    set_canvas(canvas,callback) called on start up to set a local canvas object reference
│ │ -#    set_bbox - Common function to create boundary box for a schematic object
│ │ -#    find_initial_canvas_position - common function to find the next 'free' position 
│ │ -#    new_item_id - Common function - Find the next 'free' item ID hen creating objects
│ │ -#    signal_exists (item_id) - Common function to see if a given item exists
│ │ -#    point_exists (item_id) - Common function to see if a given item exists
│ │ -#    section_exists (item_id) - Common function to see if a given item exists
│ │ -#    instrument_exists (item_id) - Common function to see if a given item exists
│ │ -#    signal(item_id) - helper function to find the object Id by Item ID
│ │ -#    point(item_id) - helper function to find the object Id by Item ID
│ │ -#    section(Id:int) - helper function to find the object Id by Item ID
│ │ -#    instrument(item_id) - helper function to find the object Id by Item ID
│ │ +#    initialise (canvas,width,height,grid) - Initialise the objects package and set defaults
│ │ +#    update_canvas(width,height,grid) - update the attributes (on layout load or canvas re-size)
│ │ +#    set_bbox - Common function to create/update the boundary box for a schematic object
│ │ +#    find_initial_canvas_position - common function to return the next 'free' position (x,y)
│ │ +#    new_item_id - Common function - common function to return the next 'free' item ID
│ │ +#    signal_exists (item_id:int) - Common function to see if a given item exists
│ │ +#    point_exists (item_id:int) - Common function to see if a given item exists
│ │ +#    section_exists (item_id:int) - Common function to see if a given item exists
│ │ +#    instrument_exists (item_id:int) - Common function to see if a given item exists
│ │ +#    signal(item_id:int) - helper function to find the object Id by Item ID
│ │ +#    point(item_id:int) - helper function to find the object Id by Item ID
│ │ +#    section(item_id:int) - helper function to find the object Id by Item ID
│ │ +#    instrument(item_id:int) - helper function to find the object Id by Item ID
│ │  #
│ │  # Objects intended to be accessed directly by other editor modules:
│ │  #    object_type - Enumeration type for the supported objects
│ │ -#    schematic_objects - For accessing/editing the configuration of an object
│ │ +#    schematic_objects - for accessing/editing the configuration of an object
│ │  #    signal_index - for iterating through all the signal objects
│ │  #    point_index - for iterating through all the point objects
│ │  #    instrument_index - for iterating through all the instrument objects
│ │  #    section_index - for iterating through all the section objects
│ │ +#    canvas_width, canvas_height, canvas_grid - for creating/pasting objects
│ │ +#    canvas - global reference to the Tkinter drawing object
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas() - To get the canvas parameters when creating objects 
│ │ +#    run_layout.initialise(canvas) - Initialise the run_layout module with the canvas reference
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -from typing import Union
│ │ -from . import settings
│ │ +from .. import run_layout
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Global class used for the Object Type - we use normal strings rather than enumeration
│ │ -# types so we can easily serialise/deserialise to/from json forsave and load
│ │ +# Global class used for the object_type - we use normal strings rather than enumeration
│ │ +# types so we can easily serialise/deserialise to/from json for save and load
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  class object_type():
│ │      none:str = "none"
│ │      line:str = "line"
│ │      point:str = "point"
│ │      signal:str = "signal"
│ │      section:str = "section"
│ │      instrument:str = "instrument"
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # All Objects we create (and their configuration) are stored in a global dictionary
│ │ +# and are indexed by their UUID (object_id) - which is assigned at creation time
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  schematic_objects:dict={}
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# We also maintain seperate indexes for each of the complex object types
│ │ +# We also maintain seperate indexes for each of the object types to enable the unique
│ │ +# object_id to be indexed by the item_id (unique only for each object_type)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  signal_index:dict={}
│ │  point_index:dict={}
│ │  instrument_index:dict={}
│ │  section_index:dict={}
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Simple functions to get the main dictionary index
│ │ -# Note that signal and instrument IDs can be local or remote
│ │ +# Helper functions to get the main dictionary index (the object_id) from the item_id
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def signal(ID:Union[int,str]): return (signal_index[str(ID)])
│ │ +def signal(ID:int): return (signal_index[str(ID)])
│ │  def point(ID:int): return (point_index[str(ID)])
│ │ -def instrument(ID:Union[int,str]): return (instrument_index[str(ID)])
│ │ +def instrument(ID:int): return (instrument_index[str(ID)])
│ │  def section(ID:int): return (section_index[str(ID)])
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# simple functions to test if a particular object ID already exists
│ │ -# Note that signal and instrument IDs can be local or remote
│ │ +# Simple functions to test if a particular item_id already exists (for an item_type)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def signal_exists(ID:Union[int,str]): return (str(ID) in signal_index.keys())
│ │ +def signal_exists(ID:int): return (str(ID) in signal_index.keys())
│ │  def point_exists(ID:int): return (str(ID) in point_index.keys())
│ │ -def instrument_exists(ID:Union[int,str]): return (str(ID) in instrument_index.keys())
│ │ +def instrument_exists(ID:int): return (str(ID) in instrument_index.keys())
│ │  def section_exists(ID:int): return (str(ID) in section_index.keys())
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Common parameters for a Default Layout Object (i.e. state at creation)
│ │ -# These elements are common to all schematic layout objects
│ │ +# These elements are common to all schematic layout objects and are primarily
│ │ +# used to support the schematic editor functions (move, select, etc)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_object = {}
│ │ -default_object["item"] = object_type.none  
│ │ +default_object["item"] = object_type.none
│ │  default_object["posx"] = 0
│ │  default_object["posy"] = 0
│ │  default_object["itemid"] = 0
│ │  default_object["bbox"] = None   # Tkinter canvas object for the boundary box
│ │  default_object["tags"] = ""     # Canvas Tags (for moving/deleting objects)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# The Canvas Object is saved as a global variable for subsequent use
│ │ +# Function to set the required defaults for the Objects package at application start
│ │ +# The Tkinter Canvas Object and default canvas attributes (dimentions and grid size)
│ │ +# are saved as global variables for easy referencing. The Canvas width, height and grid
│ │ +# are used for optimising the positioning of objects on creation or 'paste'
│ │ +# Also calls the run_layout.initialise function to set the tkinter canvas object
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  canvas = None
│ │ +canvas_width = 0
│ │ +canvas_height = 0
│ │ +canvas_grid = 0
│ │  
│ │ -def set_canvas (canvas_object):
│ │ +def initialise (canvas_object, width:int, height:int, grid:int):
│ │      global canvas
│ │      canvas = canvas_object
│ │ +    update_canvas(canvas_width, canvas_height, grid)
│ │ +    run_layout.initialise(canvas)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Function to update the Canvas Attributes (following layout load or canvas resize)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def update_canvas(width:int, height:int, grid:int):
│ │ +    global canvas_width, canvas_height, canvas_grid
│ │ +    canvas_width = width
│ │ +    canvas_height = height
│ │ +    canvas_grid = grid
│ │ +    return()
│ │ +    
│ │ +#------------------------------------------------------------------------------------
│ │  # Internal function to create/update the boundary box rectangle for an object.
│ │  # Note that we create the boundary box slightly bigger than the object itself
│ │ -# This is primarily to cater for horizontal and vertical lines.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def set_bbox(object_id:str,bbox:[int,int,int,int]):
│ │      global schematic_objects
│ │      x1, y1 = bbox[0] - 2, bbox[1] - 2
│ │      x2, y2 = bbox[2] + 2, bbox[3] + 2
│ │ -    # If we are moving it we leave it in its current selected/unselected state
│ │ -    # If we are creating it for the first time - we hide it (object unselected)
│ │ +    # If the tkinter object exists we leave it in its current selected/unselected state
│ │ +    # If it doesn't exist then we create it (in the default object unselected state)
│ │      if schematic_objects[object_id]["bbox"]:
│ │          canvas.coords(schematic_objects[object_id]["bbox"],x1,y1,x2,y2)
│ │      else:
│ │ -        schematic_objects[object_id]["bbox"] = canvas.create_rectangle(x1,y1,x2,y2,state='hidden')        
│ │ +        schematic_objects[object_id]["bbox"] = canvas.create_rectangle(x1,y1,x2,y2,state='hidden')
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal function to find an initial canvas position for the created object.
│ │  # This is used by all the object type-specific creation functions (below).
│ │  #------------------------------------------------------------------------------------
│ │ -        
│ │ +
│ │  def find_initial_canvas_position():
│ │      global schematic_objects
│ │ +    # Default position (top left) to try first
│ │      x, y = 50, 50
│ │ +    # Deltas to use for object spacing
│ │ +    deltax, deltay = canvas_grid*2, canvas_grid*2
│ │      # Find an intial position not taken up with an existing object
│ │      while True:
│ │          posfree = True
│ │          for object_id in schematic_objects:
│ │              if (schematic_objects[object_id]["posx"] == x and
│ │                   schematic_objects[object_id]["posx"] == x):
│ │ +                # Another object already exists at this position
│ │ +                # No point trying the other schematic objects
│ │                  posfree = False
│ │ +                break
│ │ +        # If the current x/y position is "free" now have iterated through all other
│ │ +        # schematic objects then we can use this position to create the new object
│ │          if posfree: break
│ │ -        width, height, canvas_grid = settings.get_canvas()
│ │ -        x, y = x + canvas_grid*2, y + canvas_grid*2
│ │ +        # Else, apply the deltas and try again
│ │ +        x, y = x + deltax, y + deltay
│ │      return(x, y)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal function to assign a unique type-specific id for a newly created object
│ │  # This function is called on object creation or object copy/paste and takes in the
│ │  # function to call to see if the Item_ID already exists for a specific item type
│ │ -# This is used by all the object type-specific creation functions (below).
│ │ +# This is used by all the object type-specific creation functions.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def new_item_id(exists_function):
│ │      item_id = 1
│ │      while True:
│ │          if not exists_function(item_id): break
│ │ -        else: item_id += 1
│ │ +        item_id += 1
│ │      return(item_id)
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects_instruments.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_instruments.py
│ │┄ Files 21% similar despite different names
│ │ @@ -1,191 +1,200 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the functions for managing Block Instrument objects
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ -#    create_instrument(type) - Create a default object on the schematic
│ │ +#    create_instrument() - Create a default block instrument object on the schematic
│ │  #    delete_instrument(object_id) - Hard Delete an object when deleted from the schematic
│ │  #    update_instrument(obj_id,new_obj) - Update the configuration of an existing instrument object
│ │  #    paste_instrument(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ -#    delete_instrument_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    delete_instrument_object(object_id) - Soft delete the drawing object (prior to recreating)
│ │  #    redraw_instrument_object(object_id) - Redraw the object on the canvas following an update
│ │  #    default_instrument_object - The dictionary of default values for the object
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas() - To get the canvas parameters when creating objects
│ │ -#    objects_common.set_bbox - Common function to create boundary box
│ │ -#    objects_common.find_initial_canvas_position - common function 
│ │ -#    objects_common.new_item_id - Common function - when creating objects
│ │ +#    objects_common.set_bbox - to create/update the boundary box for the schematic object
│ │ +#    objects_common.find_initial_canvas_position - to find the next 'free' canvas position
│ │ +#    objects_common.new_item_id - to find the next 'free' item ID when creating objects
│ │  #    objects_common.instrument_exists - Common function to see if a given item exists
│ │  #    objects_signals.update_references_to_instrument - when the instrument ID is changed
│ │  #    objects_signals.remove_references_to_instrument - when the instrument is deleted
│ │  #
│ │  # Accesses the following external editor objects directly:
│ │  #    run_layout.schematic_callback - setting the object callbacks when created/recreated
│ │  #    objects_common.schematic_objects - the master dictionary of Schematic Objects
│ │ -#    objects_common.instrument_index - The index of Instrument Objects (for iterating)
│ │ -#    objects_common.signal_index - The index of Signal Objects (for iterating)
│ │ +#    objects_common.objects_common.instrument_index - The index of Instrument Objects (for iterating)
│ │  #    objects_common.default_object - The common dictionary element for all objects
│ │  #    objects_common.object_type - The Enumeration of supported objects
│ │  #    objects_common.canvas - Reference to the Tkinter drawing canvas
│ │  #
│ │  # Makes the following external API calls to library modules:
│ │  #    block_instruments.delete_instrument(id) - delete library drawing object (part of soft delete)
│ │  #    block_instruments.create_block_instrument(id) -  To create the library object (create or redraw)
│ │  #    block_instruments.get_tags(id) - get the canvas 'tags' for the instrument drawing objects
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  import uuid
│ │  import copy
│ │  
│ │ -from ..library import block_instruments
│ │ +from ...library import block_instruments
│ │  
│ │ -from . import settings
│ │  from . import objects_common
│ │  from . import objects_signals
│ │ -from . import run_layout 
│ │ -
│ │ -from .objects_common import schematic_objects as schematic_objects
│ │ -from .objects_common import instrument_index as instrument_index
│ │ +from .. import run_layout 
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Default Block Instrument Objects (i.e. state at creation)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_instrument_object = copy.deepcopy(objects_common.default_object)
│ │  default_instrument_object["item"] = objects_common.object_type.instrument
│ │  default_instrument_object["itemid"] = 0
│ │  default_instrument_object["singleline"] = False
│ │  default_instrument_object["bellsound"] = "bell-ring-01.wav"
│ │  default_instrument_object["keysound"] = "telegraph-key-01.wav"
│ │  default_instrument_object["linkedto"] = None
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Internal function Update references from instruments linked to this one
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def update_references_to_instrument(old_inst_id:int, new_inst_id:int):
│ │ +    ######################################################################
│ │ +    ######################## TODO ########################################
│ │ +    ######################################################################
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Internal function to Remove references from instruments linked to this one
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def remove_references_to_instrument(deleted_inst_id:int):
│ │ +    ######################################################################
│ │ +    ######################## TODO ########################################
│ │ +    ######################################################################
│ │ +    return()
│ │ +    
│ │ +#------------------------------------------------------------------------------------
│ │  # Function to to update (delete and re-draw) an Instrument object on the schematic. Called
│ │  # when the object is first created or after the object attributes have been updated
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def update_instrument(object_id, new_object_configuration):
│ │ -    global schematic_objects
│ │      # We need to track whether the Item ID has changed
│ │ -    old_item_id = schematic_objects[object_id]["itemid"]
│ │ +    old_item_id = objects_common.schematic_objects[object_id]["itemid"]
│ │      new_item_id = new_object_configuration["itemid"]
│ │      # Delete the existing instrument object, copy across the new config and redraw
│ │      delete_instrument_object(object_id)
│ │ -    schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │      redraw_instrument_object(object_id)
│ │      # Check to see if the Type-specific ID has been changed
│ │      if old_item_id != new_item_id:
│ │          # Update the type-specific index
│ │ -        del instrument_index[str(old_item_id)]
│ │ -        instrument_index[str(new_item_id)] = object_id
│ │ -        # Update any signal 'block ahead' references when the instID is changed
│ │ +        del objects_common.instrument_index[str(old_item_id)]
│ │ +        objects_common.instrument_index[str(new_item_id)] = object_id
│ │ +        # Update any signal 'block ahead' references when the ID is changed
│ │          objects_signals.update_references_to_instrument(old_item_id, new_item_id)
│ │ -        ###########################################################################
│ │ -        ## TO DO - update any "linkedto" references for other block insttruments ##
│ │ -        ###########################################################################
│ │ +        # Update any references from linked instruments when the ID is changed
│ │ +        update_references_to_instrument(old_item_id, new_item_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Function to redraw an Instrument object on the schematic. Called when the object is first
│ │ -# created or after the object configuration has been updated.
│ │ +# Function to redraw an Instrument object on the schematic. Called when the object
│ │ +# is first reated or after the object configuration has been updated.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def redraw_instrument_object(object_id):
│ │ -    global schematic_objects
│ │      # Create the new Block Instrument object
│ │      block_instruments.create_block_instrument (
│ │                  canvas = objects_common.canvas,
│ │ -                block_id = schematic_objects[object_id]["itemid"],
│ │ -                x = schematic_objects[object_id]["posx"],
│ │ -                y = schematic_objects[object_id]["posy"],
│ │ +                block_id = objects_common.schematic_objects[object_id]["itemid"],
│ │ +                x = objects_common.schematic_objects[object_id]["posx"],
│ │ +                y = objects_common.schematic_objects[object_id]["posy"],
│ │                  block_callback = run_layout.schematic_callback,
│ │ -                single_line = schematic_objects[object_id]["singleline"],
│ │ -                bell_sound_file = schematic_objects[object_id]["bellsound"],
│ │ -                telegraph_sound_file = schematic_objects[object_id]["keysound"],
│ │ -                linked_to = schematic_objects[object_id]["linkedto"])
│ │ -    # Create/update the canvas "tags" and selection rectangle for the signal
│ │ -    schematic_objects[object_id]["tags"] = block_instruments.get_tags(schematic_objects[object_id]["itemid"])
│ │ -    objects_common.set_bbox (object_id, objects_common.canvas.bbox(schematic_objects[object_id]["tags"]))         
│ │ +                single_line = objects_common.schematic_objects[object_id]["singleline"],
│ │ +                bell_sound_file = objects_common.schematic_objects[object_id]["bellsound"],
│ │ +                telegraph_sound_file = objects_common.schematic_objects[object_id]["keysound"],
│ │ +                linked_to = objects_common.schematic_objects[object_id]["linkedto"])
│ │ +    # Create/update the canvas "tags" and selection rectangle for the instrument
│ │ +    objects_common.schematic_objects[object_id]["tags"] = block_instruments.get_tags(objects_common.schematic_objects[object_id]["itemid"])
│ │ +    objects_common.set_bbox (object_id, objects_common.canvas.bbox(objects_common.schematic_objects[object_id]["tags"]))         
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Create a new default Block Instrument (and draw it on the canvas)
│ │  #------------------------------------------------------------------------------------
│ │          
│ │  def create_instrument():
│ │ -    global schematic_objects
│ │      # Generate a new object from the default configuration with a new UUID 
│ │      object_id = str(uuid.uuid4())
│ │ -    schematic_objects[object_id] = copy.deepcopy(default_instrument_object)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(default_instrument_object)
│ │      # Find the initial canvas position for the new object and assign the item ID
│ │      x, y = objects_common.find_initial_canvas_position()
│ │      item_id = objects_common.new_item_id(exists_function=objects_common.instrument_exists)
│ │ -    # Add the specific elements for this particular instance of the signal
│ │ -    schematic_objects[object_id]["itemid"] = item_id
│ │ -    schematic_objects[object_id]["posx"] = x
│ │ -    schematic_objects[object_id]["posy"] = y
│ │ -    # Add the new object to the index of sections
│ │ -    instrument_index[str(item_id)] = object_id 
│ │ +    # Add the specific elements for this particular instance of the instrument
│ │ +    objects_common.schematic_objects[object_id]["itemid"] = item_id
│ │ +    objects_common.schematic_objects[object_id]["posx"] = x
│ │ +    objects_common.schematic_objects[object_id]["posy"] = y
│ │ +    # Add the new object to the index of instruments
│ │ +    objects_common.instrument_index[str(item_id)] = object_id 
│ │      # Draw the object on the canvas
│ │      redraw_instrument_object(object_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Paste a copy of an existing Block Instrument  - returns the new Object ID
│ │  # Note that only the basic instrument configuration is used. Underlying configuration
│ │  # such as the linked instruments is set back to the defaults as it will need to be
│ │  # configured specific to the new instrument
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def paste_instrument(object_to_paste):
│ │ -    global schematic_objects
│ │ +def paste_instrument(object_to_paste, deltax:int, deltay:int):
│ │      # Create a new UUID for the pasted object
│ │      new_object_id = str(uuid.uuid4())
│ │ -    schematic_objects[new_object_id] = object_to_paste
│ │ +    objects_common.schematic_objects[new_object_id] = copy.deepcopy(object_to_paste)
│ │      # Assign a new type-specific ID for the object and add to the index
│ │      new_id = objects_common.new_item_id(exists_function=objects_common.instrument_exists)
│ │ -    schematic_objects[new_object_id]["itemid"] = new_id
│ │ -    instrument_index[str(new_id)] = new_object_id
│ │ -    # New objects are "pasted" at a slightly offset position on the canvas
│ │ -    width, height, position_offset = settings.get_canvas()
│ │ -    schematic_objects[new_object_id]["posx"] += position_offset
│ │ -    schematic_objects[new_object_id]["posy"] += position_offset
│ │ +    objects_common.schematic_objects[new_object_id]["itemid"] = new_id
│ │ +    objects_common.instrument_index[str(new_id)] = new_object_id
│ │ +    # Set the position for the "pasted" object (offset from the original position)
│ │ +    objects_common.schematic_objects[new_object_id]["posx"] += deltax
│ │ +    objects_common.schematic_objects[new_object_id]["posy"] += deltay
│ │      # Now set the default values for all elements we don't want to copy:
│ │ -    schematic_objects[new_object_id]["linkedto"] = default_instrument_object["linkedto"]
│ │ +    objects_common.schematic_objects[new_object_id]["linkedto"] = default_instrument_object["linkedto"]
│ │      # Set the Boundary box for the new object to None so it gets created on re-draw
│ │ -    schematic_objects[new_object_id]["bbox"] = None
│ │ +    objects_common.schematic_objects[new_object_id]["bbox"] = None
│ │      # Draw the new object
│ │      redraw_instrument_object(new_object_id)
│ │      return(new_object_id)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to "soft delete" the instrument object from the canvas - Primarily used to
│ │  # delete the block instrument in its current configuration prior to re-creating in its
│ │  # new configuration - also called as part of a hard delete (below).
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_instrument_object(object_id):
│ │ -    block_instruments.delete_instrument(schematic_objects[object_id]["itemid"])
│ │ +    block_instruments.delete_instrument(objects_common.schematic_objects[object_id]["itemid"])
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to 'hard delete' a block instrument (drawing objects and the main
│ │  # dictionary entry). Function called when object is deleted from the schematic.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_instrument(object_id):
│ │ -    global schematic_objects
│ │ -    # Delete the associated library objects from the canvas
│ │ +    # Soft delete the associated library objects from the canvas
│ │      delete_instrument_object(object_id)
│ │ +    # Remove any references to the instrument from other (linked) instruments
│ │ +    remove_references_to_instrument(objects_common.schematic_objects[object_id]["itemid"])
│ │      # Remove any references to the block instrument from the signal interlocking tables
│ │ -    objects_signals.remove_references_to_instrument(object_id)
│ │ +    objects_signals.remove_references_to_instrument(objects_common.schematic_objects[object_id]["itemid"])
│ │      # "Hard Delete" the selected object - deleting the boundary box rectangle and deleting
│ │      # the object from the dictionary of schematic objects (and associated dictionary keys)
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["bbox"])
│ │ -    del instrument_index[str(schematic_objects[object_id]["itemid"])]
│ │ -    del schematic_objects[object_id]
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["bbox"])
│ │ +    del objects_common.instrument_index[str(objects_common.schematic_objects[object_id]["itemid"])]
│ │ +    del objects_common.schematic_objects[object_id]
│ │      return()
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects_lines.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_lines.py
│ │┄ Files 10% similar despite different names
│ │ @@ -1,48 +1,36 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the functions for managing Line objects
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules: 
│ │ -#    create_line(type) - Create a default object on the schematic
│ │ +#    create_line() - Create a default line object on the schematic
│ │  #    delete_line(object_id) - Hard Delete an object when deleted from the schematic
│ │  #    paste_line(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ -#    delete_line_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    delete_line_object(object_id) - Soft delete the drawing object (prior to recreating)
│ │  #    redraw_line_object(object_id) - Redraw the object on the canvas following an update
│ │  #    default_line_object - The dictionary of default values for the object
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas() - To get the canvas parameters when creating objects
│ │ -#    objects_common.set_bbox - Common function to create boundary box
│ │ -#    objects_common.find_initial_canvas_position - common function 
│ │ -#    objects_common.new_item_id - Common function - when creating objects
│ │ +#    objects_common.set_bbox - to create/update the boundary box for the schematic object
│ │ +#    objects_common.find_initial_canvas_position - to find the next 'free' canvas position
│ │  #    
│ │  # Accesses the following external editor objects directly:
│ │  #    objects_common.schematic_objects - the master dictionary of Schematic Objects
│ │  #    objects_common.default_object - The common dictionary element for all objects
│ │  #    objects_common.object_type - The Enumeration of supported objects
│ │  #    objects_common.canvas - Reference to the Tkinter drawing canvas
│ │  #
│ │ -# Makes the following external API calls to library modules:
│ │ -#    block_instruments.delete_instrument(id) - delete library drawing object (part of soft delete)
│ │ -#    block_instruments.create_block_instrument(id) -  To create the library object (create or redraw)
│ │ -#    block_instruments.get_boundary_box(id) - get the boundary box for the section (i.e. selection area)
│ │ -#
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -from tkinter import *
│ │ -
│ │  import uuid
│ │ -import copy 
│ │ +import copy
│ │  
│ │ -from . import settings
│ │  from . import objects_common
│ │  
│ │ -from .objects_common import schematic_objects as schematic_objects
│ │ -
│ │  #------------------------------------------------------------------------------------
│ │  # Default Line Objects (i.e. state at creation)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_line_object = copy.deepcopy(objects_common.default_object)
│ │  default_line_object["item"] = objects_common.object_type.line
│ │  default_line_object["endx"] = 0
│ │ @@ -53,92 +41,87 @@
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to to update (delete and re-draw) a Line object on the schematic. Called
│ │  # when the object is first created or after the object attributes have been updated.
│ │  #------------------------------------------------------------------------------------
│ │          
│ │  def redraw_line_object(object_id):
│ │ -    global schematic_objects
│ │ -    # Create new drawing objects
│ │ -    x1 = schematic_objects[object_id]["posx"]
│ │ -    y1 = schematic_objects[object_id]["posy"]
│ │ -    x2 = schematic_objects[object_id]["endx"]
│ │ -    y2 = schematic_objects[object_id]["endy"]
│ │ -    schematic_objects[object_id]["line"] = objects_common.canvas.create_line(x1,y1,x2,y2,fill="black",width=3,tags=object_id)
│ │ -    schematic_objects[object_id]["end1"] = objects_common.canvas.create_oval(x1-5,y1-5,x1+5,y1+5,state='hidden',tags=object_id)
│ │ -    schematic_objects[object_id]["end2"] = objects_common.canvas.create_oval(x2-5,y2-5,x2+5,y2+5,state='hidden',tags=object_id)
│ │ +    # Create new drawing objects - note that the ovals at each end are for schematic editing
│ │ +    # normally hidden, but displayed when the line is selected so they can be selected/moved
│ │ +    x1 = objects_common.schematic_objects[object_id]["posx"]
│ │ +    y1 = objects_common.schematic_objects[object_id]["posy"]
│ │ +    x2 = objects_common.schematic_objects[object_id]["endx"]
│ │ +    y2 = objects_common.schematic_objects[object_id]["endy"]
│ │ +    objects_common.schematic_objects[object_id]["line"] = objects_common.canvas.create_line(x1,y1,x2,y2,fill="black",width=3,tags=object_id)
│ │ +    objects_common.schematic_objects[object_id]["end1"] = objects_common.canvas.create_oval(x1-5,y1-5,x1+5,y1+5,state='hidden',tags=object_id)
│ │ +    objects_common.schematic_objects[object_id]["end2"] = objects_common.canvas.create_oval(x2-5,y2-5,x2+5,y2+5,state='hidden',tags=object_id)
│ │      # Create/update the canvas "tags" and selection rectangle for the point
│ │ -    schematic_objects[object_id]["tags"] = object_id
│ │ -    objects_common.set_bbox (object_id, objects_common.canvas.bbox(schematic_objects[object_id]["tags"]))         
│ │ +    objects_common.schematic_objects[object_id]["tags"] = object_id
│ │ +    objects_common.set_bbox (object_id, objects_common.canvas.bbox(objects_common.schematic_objects[object_id]["tags"]))         
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Create a new default Line (and draw it on the canvas)
│ │  #------------------------------------------------------------------------------------
│ │          
│ │  def create_line():
│ │ -    global schematic_objects
│ │      # Generate a new object from the default configuration with a new UUID 
│ │      object_id = str(uuid.uuid4())
│ │ -    schematic_objects[object_id] = copy.deepcopy(default_line_object)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(default_line_object)
│ │      # Find the initial canvas position for the new object 
│ │      x, y = objects_common.find_initial_canvas_position()
│ │      # Add the specific elements for this particular instance of the object
│ │ -    schematic_objects[object_id]["posx"] = x
│ │ -    schematic_objects[object_id]["posy"] = y
│ │ -    schematic_objects[object_id]["endx"] = x + 50
│ │ -    schematic_objects[object_id]["endy"] = y
│ │ +    objects_common.schematic_objects[object_id]["posx"] = x
│ │ +    objects_common.schematic_objects[object_id]["posy"] = y
│ │ +    objects_common.schematic_objects[object_id]["endx"] = x + 50
│ │ +    objects_common.schematic_objects[object_id]["endy"] = y
│ │      # Draw the Line on the canvas
│ │      redraw_line_object(object_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to paste a copy of an existing line - returns the new Object ID
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def paste_line(object_to_paste):
│ │ -    global schematic_objects
│ │ +def paste_line(object_to_paste, deltax:int, deltay:int):
│ │      # Create a new UUID for the pasted object
│ │      new_object_id = str(uuid.uuid4())
│ │ -    schematic_objects[new_object_id] = object_to_paste
│ │ -    # New objects are "pasted" at a slightly offset position on the canvas
│ │ -    # The other end of the line also needs to be shifted
│ │ -    width, height, position_offset = settings.get_canvas()
│ │ -    schematic_objects[new_object_id]["posx"] += position_offset
│ │ -    schematic_objects[new_object_id]["posy"] += position_offset
│ │ -    schematic_objects[new_object_id]["endx"] += position_offset
│ │ -    schematic_objects[new_object_id]["endy"] += position_offset
│ │ +    objects_common.schematic_objects[new_object_id] = copy.deepcopy(object_to_paste)
│ │ +    # Set the position for the "pasted" object (offset from the original position)
│ │ +    objects_common.schematic_objects[new_object_id]["posx"] += deltax
│ │ +    objects_common.schematic_objects[new_object_id]["posy"] += deltay
│ │ +    objects_common.schematic_objects[new_object_id]["endx"] += deltax
│ │ +    objects_common.schematic_objects[new_object_id]["endy"] += deltay
│ │      # Set the Boundary box for the new object to None so it gets created on re-draw
│ │ -    schematic_objects[new_object_id]["bbox"] = None
│ │ +    objects_common.schematic_objects[new_object_id]["bbox"] = None
│ │      # Draw the new object
│ │      redraw_line_object(new_object_id)
│ │      return(new_object_id)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to "soft delete" the section object from the canvas - Primarily used to
│ │  # delete the line in its current configuration prior to re-creating in its
│ │  # new configuration - also called as part of a hard delete (below).
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_line_object(object_id):
│ │      # Delete the tkinter drawing objects assoviated with the line object
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["line"])
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["end1"])
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["end2"])
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["line"])
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["end1"])
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["end2"])
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to 'hard delete' a schematic line object (drawing objects and the main
│ │  # dictionary entry). Function called when object is deleted from the schematic.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_line(object_id):
│ │ -    global schematic_objects
│ │ -    # Delete the associated library objects from the canvas
│ │ +    # Soft delete the associated library objects from the canvas
│ │      delete_line_object(object_id)
│ │      # "Hard Delete" the selected object - deleting the boundary box rectangle and deleting
│ │      # the object from the dictionary of schematic objects (and associated dictionary keys)
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["bbox"])
│ │ -    del schematic_objects[object_id]
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["bbox"])
│ │ +    del objects_common.schematic_objects[object_id]
│ │      return()
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects_points.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_points.py
│ │┄ Files 22% similar despite different names
│ │ @@ -1,66 +1,63 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the functions for managing Point objects
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ -#    create_point(type) - Create a default object on the schematic
│ │ +#    create_point(type) - Create a default point object on the schematic
│ │  #    delete_point(obj_id) - Hard Delete an object when deleted from the schematic
│ │  #    update_point(obj_id,new_obj) - Update the configuration of an existing point object
│ │  #    paste_point(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │  #    delete_point_object(object_id) - Soft delete the drawing object (prior to recreating)
│ │  #    redraw_point_object(object_id) - Redraw the object on the canvas following an update
│ │  #    default_point_object - The dictionary of default values for the object
│ │ +#    reset_point_interlocking_tables() - recalculates interlocking tables from scratch
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas() - To get the canvas parameters when creating objects
│ │ +#    objects_common.set_bbox - to create/update the boundary box for the schematic object
│ │ +#    objects_common.find_initial_canvas_position - to find the next 'free' canvas position
│ │ +#    objects_common.new_item_id - to find the next 'free' item ID when creating objects
│ │  #    objects_common.point - To get The Object_ID for a given Item_ID
│ │ -#    objects_common.set_bbox - Common function to create boundary box
│ │ -#    objects_common.find_initial_canvas_position - common function 
│ │ -#    objects_common.new_item_id - Common function - when creating objects
│ │ +#    objects_common.signal - To get The Object_ID for a given Item_ID
│ │  #    objects_common.point_exists - Common function to see if a given item exists
│ │ -#    objects_signals.update_references_to_point - called when point ID changes
│ │ -#    objects_signals.remove_references_to_point - called when Point is deleted
│ │ +#    objects_signals.update_references_to_point - called when the point ID is changed
│ │ +#    objects_signals.remove_references_to_point - called when the point is deleted
│ │  #
│ │  # Accesses the following external editor objects directly:
│ │ -#    run_layout.schematic_callback - setting the object callbacks when created/recreated
│ │ +#    run_layout.schematic_callback - to set the callbacks when creating/recreating
│ │  #    objects_common.schematic_objects - the master dictionary of Schematic Objects
│ │  #    objects_common.point_index - The index of Point Objects (for iterating)
│ │ +#    objects_common.signal_index - The index of Signal Objects (for iterating)
│ │  #    objects_common.default_object - The common dictionary element for all objects
│ │  #    objects_common.object_type - The Enumeration of supported objects
│ │  #    objects_common.canvas - Reference to the Tkinter drawing canvas
│ │  #
│ │  # Accesses the following external library objects directly:
│ │  #    points.point_type - for setting the enum value when creating the object
│ │  #
│ │  # Makes the following external API calls to library modules:
│ │  #    points.delete_point(id) - delete library drawing object (part of soft delete)
│ │  #    points.create_point(id) -  To create the library object (create or redraw)
│ │  #    points.get_tags(id) - get the canvas 'tags' for the point drawing objects
│ │  #    points.point_switched(id) - test if a point is switched (when updating dependent objects)
│ │ -#    points.toggle_point_state(id) - internal function to toggle point (when updating dependent objects)
│ │ -#    dcc_control.delete_point_mapping - delete library object when deleted / prior to recreating
│ │ +#    points.toggle_point_state(id) - to toggle point (when updating dependent objects)
│ │ +#    dcc_control.delete_point_mapping - delete mappings when deleting point / prior to recreating
│ │  #    dcc_control.map_dcc_point - to create the new DCC mapping (creation or updating)
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  import uuid
│ │  import copy
│ │  
│ │ -from ..library import points
│ │ -from ..library import dcc_control
│ │ +from ...library import points
│ │ +from ...library import dcc_control
│ │  
│ │ -from . import settings
│ │  from . import objects_common
│ │  from . import objects_signals
│ │ -from . import run_layout
│ │ -
│ │ -from .objects_common import schematic_objects as schematic_objects
│ │ -from .objects_common import point_index as point_index
│ │ -from .objects_common import point as point
│ │ +from .. import run_layout
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Default Point Objects (i.e. state at creation)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_point_object = copy.deepcopy(objects_common.default_object)
│ │  default_point_object["item"] = objects_common.object_type.point
│ │ @@ -76,229 +73,258 @@
│ │  default_point_object["dccreversed"] = False
│ │  # This is the default signal interlocking table for the point
│ │  # The Table comprises a variable length list of interlocked signals
│ │  # Each signal entry in the list comprises [sig_id, [main, lh1, lh2, rh1, rh2]]
│ │  # Each route element in the list of routes is a boolean value (True or False)
│ │  default_point_object["siginterlock"] = []
│ │  
│ │ -
│ │  #------------------------------------------------------------------------------------
│ │ -# Function to reset the point interlocking tables for all points
│ │ +# Function to recalculate the point interlocking tables for all points
│ │ +# Called following update or delete of a signal object and on layout load
│ │ +# Signal 'pointinterlock' comprises: [main, lh1, lh2, rh1, rh2]
│ │ +# Each route comprises: [[p1, p2, p3, p4, p5, p6, p7], sig_id, block_id]
│ │ +# Each point element (in the list of points) comprises [point_id, point_state]
│ │ +# Point 'siginterlock' comprises a variable length list of interlocked signals
│ │ +# Each list entry comprises [sig_id, [main, lh1, lh2, rh1, rh2]]
│ │ +# Each route element is a boolean value (True or False)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def reset_point_interlocking_tables():
│ │ +    # Iterate through the points to clear the interlocking tables
│ │      for point_id in objects_common.point_index:
│ │ -        schematic_objects[objects_common.point(point_id)]["siginterlock"] = []
│ │ +        objects_common.schematic_objects[objects_common.point(point_id)]["siginterlock"] = []
│ │ +    # Iterate through the points to re-calculate the interlocking tables
│ │      for signal_id in objects_common.signal_index:
│ │ -        add_back_references_to_signal(objects_common.signal(signal_id))
│ │ +        # Get the object ID for the signal
│ │ +        signal_object = objects_common.signal(signal_id)
│ │ +        # Iterate through all the points on the schematic
│ │ +        for point_id in objects_common.point_index:
│ │ +            # Get the Object ID of the point
│ │ +            point_object = objects_common.point(point_id)
│ │ +            # Everything is false by default- UNLESS specifically set
│ │ +            point_interlocked_by_signal = False
│ │ +            interlocked_routes = [False, False, False, False, False]
│ │ +            # Iterate through each route in the SIGNAL interlocking table and then the points on each route
│ │ +            interlocking_table = objects_common.schematic_objects[signal_object]["pointinterlock"]
│ │ +            for route_index, route_to_test in enumerate(interlocking_table):
│ │ +                list_of_points_to_test = route_to_test[0]
│ │ +                for point_to_test in list_of_points_to_test:
│ │ +                    if point_to_test[0] == int(point_id):
│ │ +                        interlocked_routes[route_index] = True
│ │ +                        point_interlocked_by_signal = True
│ │ +            if point_interlocked_by_signal:
│ │ +                interlocked_signal = [objects_common.schematic_objects[signal_object]["itemid"], interlocked_routes]
│ │ +                objects_common.schematic_objects[point_object]["siginterlock"].append(interlocked_signal)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Function to remove all references to a signal from the point interlocking tables
│ │ -# Point 'siginterlock' comprises a variable length list of interlocked signals
│ │ -# Each list entry comprises [sig_id, [main, lh1, lh2, rh1, rh2]]
│ │ +# Internal function to update references from points that "also switch" this point
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def delete_back_references_to_signal(object_id):
│ │ -    for point_id in point_index:
│ │ -        list_of_interlocked_signals = schematic_objects[point(point_id)]["siginterlock"]
│ │ -        for index, interlocked_signal in enumerate(list_of_interlocked_signals):
│ │ -            if interlocked_signal[0] == schematic_objects[object_id]["itemid"]:
│ │ -                schematic_objects[point(point_id)]["siginterlock"].pop(index)
│ │ +def update_references_to_point(old_point_id:int, new_point_id:int):
│ │ +    # Iterate through all the points on the schematic
│ │ +    for point_id in objects_common.point_index:
│ │ +        point_object = objects_common.point(point_id)
│ │ +        if objects_common.schematic_objects[point_object]["alsoswitch"] == old_point_id:
│ │ +            objects_common.schematic_objects[point_object]["alsoswitch"] = new_point_id
│ │ +            # We have to delete and re-create the 'parent' point for changes to take effect
│ │ +            # Note that when we delete and then re-draw the point it is created in its
│ │ +            # default state - so if it was switched before we need to switch it after
│ │ +            # Use the non-public-api call to bypass the validation for "toggle_point"
│ │ +            parent_point_switched = points.point_switched(point_id)
│ │ +            delete_point_object(point_object)
│ │ +            redraw_point_object(point_object)
│ │ +            if parent_point_switched:
│ │ +                points.toggle_point_state(point_id,True)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Function to update all references to a signal that has been deleted
│ │ -# Signal 'pointinterlock' comprises: [main, lh1, lh2, rh1, rh2]
│ │ -# Each route comprises: [[p1, p2, p3, p4, p5, p6, p7], sig_id, block_id]
│ │ -# Each point element (in the list of points) comprises [point_id, point_state]
│ │ -# Point 'siginterlock' comprises a variable length list of interlocked signals
│ │ -# Each list entry comprises [sig_id, [main, lh1, lh2, rh1, rh2]]
│ │ -# Each route element is a boolean value (True or False)
│ │ +# Internal function to Remove references from points that "also switch" this point.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def add_back_references_to_signal(object_id):
│ │ -    for point_id in point_index:
│ │ -        point_interlocked_by_signal = False
│ │ -        interlocked_routes = [False, False, False, False, False]
│ │ -        list_of_routes_to_test = schematic_objects[object_id]["pointinterlock"]
│ │ -        for route_index, route_to_test in enumerate(list_of_routes_to_test):
│ │ -            list_of_points_to_test = route_to_test[0]
│ │ -            for point_to_test in list_of_points_to_test:
│ │ -                if point_to_test[0] == int(point_id):
│ │ -                    interlocked_routes[route_index] = True
│ │ -                    point_interlocked_by_signal = True
│ │ -        if point_interlocked_by_signal:
│ │ -            interlocked_signal = [schematic_objects[object_id]["itemid"], interlocked_routes]
│ │ -            schematic_objects[point(point_id)]["siginterlock"].append(interlocked_signal)
│ │ +def remove_references_to_point(deleted_point_id:int):
│ │ +    for point_id in objects_common.point_index:
│ │ +        point_object = objects_common.point(point_id)
│ │ +        if objects_common.schematic_objects[point_object]["alsoswitch"] == deleted_point_id:
│ │ +            objects_common.schematic_objects[point_object]["alsoswitch"] = 0
│ │ +            # We have to delete and re-create the 'parent' point for changes to take effect
│ │ +            # Note that when we delete and then re-draw the point it is created in its
│ │ +            # default state - so if it was switched before we need to switch it after
│ │ +            # Use the non-public-api call to bypass the validation for "toggle_point"
│ │ +            point_switched = points.point_switched(point_id)
│ │ +            delete_point_object(point_object)
│ │ +            redraw_point_object(point_object)
│ │ +            if point_switched:
│ │ +                points.toggle_point_state(point_id,True)    
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Internal Function to update an autoswitched point chain by recursively working
│ │ +# through the chain to set any downstream points.
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def update_downstream_points(object_id):
│ │ +    # Test to see if the current point is configured to "auto switch" another
│ │ +    # point and, if so, toggle the other (downstream) point to the same setting
│ │ +    point_id = objects_common.schematic_objects[object_id]["itemid"]
│ │ +    also_switch_id = objects_common.schematic_objects[object_id]["alsoswitch"]
│ │ +    if  also_switch_id > 0:
│ │ +        if points.point_switched(also_switch_id) != points.point_switched(point_id):
│ │ +            # Use the non-public-api call to bypass validation (can't toggle "auto" points)
│ │ +            points.toggle_point_state(also_switch_id,True)
│ │ +            # Recursively call back into the function with the object ID for the other point
│ │ +            update_downstream_points(objects_common.point(str(also_switch_id)))
│ │ +    return()
│ │ +
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Function to update (delete and re-draw) a Point object on the schematic. Called
│ │  # when the object is first created or after the object attributes have been updated.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def update_point(object_id, new_object_configuration):
│ │ -    global schematic_objects
│ │      # We need to track whether the Item ID has changed
│ │ -    old_item_id = schematic_objects[object_id]["itemid"]
│ │ +    old_item_id = objects_common.schematic_objects[object_id]["itemid"]
│ │      new_item_id = new_object_configuration["itemid"]
│ │      # Delete the existing point object, copy across the new configuration and redraw
│ │ +    # Note the point will be created in the unswitched state (we change it later if needed)
│ │      delete_point_object(object_id)
│ │ -    schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │      redraw_point_object(object_id)
│ │      # Check to see if the Type-specific ID has been changed
│ │      if old_item_id != new_item_id:
│ │          # Update the type-specific index
│ │ -        del point_index[str(old_item_id)]
│ │ -        point_index[str(new_item_id)] = object_id
│ │ -        # Update any other points that "also switch" this point to use the new ID
│ │ -        for point_id in point_index:
│ │ -            if schematic_objects[point(point_id)]["alsoswitch"] == old_item_id:
│ │ -                schematic_objects[point(point_id)]["alsoswitch"] = new_item_id
│ │ -                delete_point_object(point(point_id))
│ │ -                redraw_point_object(point(point_id))
│ │ +        del objects_common.point_index[str(old_item_id)]
│ │ +        objects_common.point_index[str(new_item_id)] = object_id
│ │ +        # Update any other point that "also switches" this point to use the new ID
│ │ +        update_references_to_point(old_item_id,new_item_id)
│ │          # Update any affected signal interlocking tables to reference the new point ID
│ │          objects_signals.update_references_to_point(old_item_id, new_item_id)
│ │      # We need to ensure that all points in an 'auto switch' chain are set
│ │      # to the same switched/not-switched state so they switch together correctly
│ │      # First, test to see if the current point is configured to "auto switch" with 
│ │      # another point and, if so, toggle the current point to the same setting
│ │ -    current_point_id = schematic_objects[object_id]["itemid"]
│ │ -    also_switch_id = schematic_objects[object_id]["alsoswitch"]
│ │ -    for point_id in point_index:
│ │ -        if schematic_objects[point(point_id)]["alsoswitch"] == current_point_id:
│ │ +    for point_id in objects_common.point_index:
│ │ +        point_object = objects_common.point(point_id)
│ │ +        if objects_common.schematic_objects[point_object]["alsoswitch"] == new_item_id:
│ │              if points.point_switched(point_id):
│ │                  # Use the non-public-api call to bypass the validation for "toggle_point"
│ │ -                points.toggle_point_state(current_point_id,True)
│ │ -    # Next, test to see if the current point is configured to "auto switch" another
│ │ -    # point and, if so, toggle that point to the same setting (this will also toggle
│ │ -    # any other points downstream in the "auto-switch" chain)
│ │ -    if  also_switch_id > 0:
│ │ -        if points.point_switched(also_switch_id) != points.point_switched(current_point_id):
│ │ -            # Use the non-public-api call to bypass validation (can't toggle "auto" points)
│ │ -            points.toggle_point_state(also_switch_id,True)
│ │ +                points.toggle_point_state(new_item_id,True)
│ │ +    # Next, update any downstream points that are configured to autoswitch with this one
│ │ +    update_downstream_points(object_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to redraw a Point object on the schematic. Called when the object is first
│ │  # created or after the object configuration has been updated.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def redraw_point_object(object_id):
│ │ -    global schematic_objects
│ │      # Create the new DCC Mapping for the point
│ │ -    if schematic_objects[object_id]["dccaddress"] > 0:
│ │ -        dcc_control.map_dcc_point (schematic_objects[object_id]["itemid"],
│ │ -                                   schematic_objects[object_id]["dccaddress"],
│ │ -                                   schematic_objects[object_id]["dccreversed"])
│ │ +    if objects_common.schematic_objects[object_id]["dccaddress"] > 0:
│ │ +        dcc_control.map_dcc_point (objects_common.schematic_objects[object_id]["itemid"],
│ │ +                                   objects_common.schematic_objects[object_id]["dccaddress"],
│ │ +                                   objects_common.schematic_objects[object_id]["dccreversed"])
│ │      # Turn the point type value back into the required enumeration type
│ │ -    point_type = points.point_type(schematic_objects[object_id]["itemtype"])
│ │ +    point_type = points.point_type(objects_common.schematic_objects[object_id]["itemtype"])
│ │      # Create the new point object
│ │      points.create_point (
│ │                  canvas = objects_common.canvas,
│ │ -                point_id = schematic_objects[object_id]["itemid"],
│ │ +                point_id = objects_common.schematic_objects[object_id]["itemid"],
│ │                  pointtype = point_type,
│ │ -                x = schematic_objects[object_id]["posx"],
│ │ -                y = schematic_objects[object_id]["posy"],
│ │ -                colour = schematic_objects[object_id]["colour"],
│ │ -                orientation = schematic_objects[object_id]["orientation"],
│ │ +                x = objects_common.schematic_objects[object_id]["posx"],
│ │ +                y = objects_common.schematic_objects[object_id]["posy"],
│ │ +                colour = objects_common.schematic_objects[object_id]["colour"],
│ │ +                orientation = objects_common.schematic_objects[object_id]["orientation"],
│ │                  point_callback = run_layout.schematic_callback,
│ │ -                also_switch = schematic_objects[object_id]["alsoswitch"],
│ │ -                reverse = schematic_objects[object_id]["reverse"],
│ │ -                auto = schematic_objects[object_id]["automatic"],
│ │ -                fpl = schematic_objects[object_id]["hasfpl"])
│ │ +                also_switch = objects_common.schematic_objects[object_id]["alsoswitch"],
│ │ +                reverse = objects_common.schematic_objects[object_id]["reverse"],
│ │ +                auto = objects_common.schematic_objects[object_id]["automatic"],
│ │ +                fpl = objects_common.schematic_objects[object_id]["hasfpl"])
│ │      # Create/update the canvas "tags" and selection rectangle for the point
│ │ -    schematic_objects[object_id]["tags"] = points.get_tags(schematic_objects[object_id]["itemid"])
│ │ -    objects_common.set_bbox (object_id, objects_common.canvas.bbox(schematic_objects[object_id]["tags"]))         
│ │ +    objects_common.schematic_objects[object_id]["tags"] = points.get_tags(objects_common.schematic_objects[object_id]["itemid"])
│ │ +    objects_common.set_bbox (object_id, objects_common.canvas.bbox(objects_common.schematic_objects[object_id]["tags"]))         
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Create a new default Point (and draw it on the canvas)
│ │  #------------------------------------------------------------------------------------
│ │          
│ │  def create_point(item_type):
│ │ -    global schematic_objects
│ │      # Generate a new object from the default configuration with a new UUID 
│ │      object_id = str(uuid.uuid4())
│ │ -    schematic_objects[object_id] = copy.deepcopy(default_point_object)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(default_point_object)
│ │      # Find the initial canvas position for the new object and assign the item ID
│ │      x, y = objects_common.find_initial_canvas_position()
│ │      item_id = objects_common.new_item_id(exists_function=objects_common.point_exists)
│ │      # Add the specific elements for this particular instance of the point
│ │ -    schematic_objects[object_id]["itemid"] = item_id
│ │ -    schematic_objects[object_id]["itemtype"] = item_type
│ │ -    schematic_objects[object_id]["posx"] = x
│ │ -    schematic_objects[object_id]["posy"] = y
│ │ +    objects_common.schematic_objects[object_id]["itemid"] = item_id
│ │ +    objects_common.schematic_objects[object_id]["itemtype"] = item_type
│ │ +    objects_common.schematic_objects[object_id]["posx"] = x
│ │ +    objects_common.schematic_objects[object_id]["posy"] = y
│ │      # Add the new object to the index of points
│ │ -    point_index[str(item_id)] = object_id
│ │ +    objects_common.point_index[str(item_id)] = object_id
│ │      # Draw the object on the canvas
│ │      redraw_point_object(object_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to paste a copy of an existing point - returns the new Object ID
│ │  # Note that only the basic point configuration is used. Underlying configuration
│ │  # such as signal interlocking, dcc addresses  etc is set back to the default
│ │  # values as it will need to be configured specific to the new point
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def paste_point(object_to_paste):
│ │ -    global schematic_objects
│ │ +def paste_point(object_to_paste, deltax:int, deltay:int):
│ │      # Create a new UUID for the pasted object
│ │      new_object_id = str(uuid.uuid4())
│ │ -    schematic_objects[new_object_id] = object_to_paste
│ │ +    objects_common.schematic_objects[new_object_id] = copy.deepcopy(object_to_paste)
│ │      # Assign a new type-specific ID for the object and add to the index
│ │      new_id = objects_common.new_item_id(exists_function=objects_common.point_exists)
│ │ -    schematic_objects[new_object_id]["itemid"] = new_id
│ │ -    point_index[str(new_id)] = new_object_id
│ │ -    # New objects are "pasted" at a slightly offset position on the canvas
│ │ -    width, height, position_offset = settings.get_canvas()
│ │ -    schematic_objects[new_object_id]["posx"] += position_offset
│ │ -    schematic_objects[new_object_id]["posy"] += position_offset
│ │ +    objects_common.schematic_objects[new_object_id]["itemid"] = new_id
│ │ +    objects_common.point_index[str(new_id)] = new_object_id
│ │ +    # Set the position for the "pasted" object (offset from the original position)
│ │ +    objects_common.schematic_objects[new_object_id]["posx"] += deltax
│ │ +    objects_common.schematic_objects[new_object_id]["posy"] += deltay
│ │      # Now set the default values for all elements we don't want to copy:
│ │ -    schematic_objects[new_object_id]["alsoswitch"] = default_point_object["alsoswitch"]
│ │ -    schematic_objects[new_object_id]["dccaddress"] = default_point_object["dccaddress"]
│ │ -    schematic_objects[new_object_id]["dccreversed"] = default_point_object["dccreversed"]
│ │ -    schematic_objects[new_object_id]["siginterlock"] = default_point_object["siginterlock"]
│ │ +    objects_common.schematic_objects[new_object_id]["alsoswitch"] = default_point_object["alsoswitch"]
│ │ +    objects_common.schematic_objects[new_object_id]["dccaddress"] = default_point_object["dccaddress"]
│ │ +    objects_common.schematic_objects[new_object_id]["dccreversed"] = default_point_object["dccreversed"]
│ │ +    objects_common.schematic_objects[new_object_id]["siginterlock"] = default_point_object["siginterlock"]
│ │      # Set the Boundary box for the new object to None so it gets created on re-draw
│ │ -    schematic_objects[new_object_id]["bbox"] = None
│ │ +    objects_common.schematic_objects[new_object_id]["bbox"] = None
│ │      # Create/draw the new object on the canvas
│ │      redraw_point_object(new_object_id)
│ │      return(new_object_id)            
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to "soft delete" the point object from the canvas together with any accociated
│ │  # dcc mapping. Primarily used to delete the point in its current configuration prior to
│ │  # re-creating in its new configuration - also used as part of a hard delete (below)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_point_object(object_id):
│ │ -    global schematic_objects
│ │      # Delete the point drawing objects and associated DCC mapping
│ │ -    points.delete_point(schematic_objects[object_id]["itemid"])
│ │ -    dcc_control.delete_point_mapping(schematic_objects[object_id]["itemid"])
│ │ +    points.delete_point(objects_common.schematic_objects[object_id]["itemid"])
│ │ +    dcc_control.delete_point_mapping(objects_common.schematic_objects[object_id]["itemid"])
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to 'hard delete' a point (drawing objects, DCC mappings, and the main
│ │  # dictionary entry). Function called when object is deleted from the schematic.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_point(object_id):
│ │ -    global schematic_objects
│ │ -    # Delete the associated library objects from the canvas
│ │ +    # Soft delete the associated library objects from the canvas
│ │      delete_point_object(object_id)
│ │      # Remove any references to the point from other points ('also switch' points).
│ │ -    for point_id in point_index:
│ │ -        if schematic_objects[point(point_id)]["alsoswitch"] == schematic_objects[object_id]["itemid"]:
│ │ -            schematic_objects[point(point_id)]["alsoswitch"] = 0
│ │ +    remove_references_to_point(objects_common.schematic_objects[object_id]["itemid"])
│ │      # Remove any references to the point from the signal interlocking tables
│ │ -    objects_signals.remove_references_to_point(object_id)
│ │ +    objects_signals.remove_references_to_point(objects_common.schematic_objects[object_id]["itemid"])
│ │      # "Hard Delete" the selected object - deleting the boundary box rectangle and deleting
│ │      # the object from the dictionary of schematic objects (and associated dictionary keys)
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["bbox"])
│ │ -    del point_index[str(schematic_objects[object_id]["itemid"])]
│ │ -    del schematic_objects[object_id]
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["bbox"])
│ │ +    del objects_common.point_index[str(objects_common.schematic_objects[object_id]["itemid"])]
│ │ +    del objects_common.schematic_objects[object_id]
│ │      return()
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/objects_sections.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/objects/objects_sections.py
│ │┄ Files 16% similar despite different names
│ │ @@ -1,36 +1,35 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the functions for managing Track Section objects
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ -#    create_section(type) - Create a default object on the schematic
│ │ +#    create_section(type) - Create a default track section object on the schematic
│ │  #    delete_section(object_id) - Hard Delete an object when deleted from the schematic
│ │  #    update_section(obj_id,new_obj) - Update the configuration of an existing section object
│ │  #    paste_section(object) - Paste a copy of an object to create a new one (returns new object_id)
│ │ -#    delete_section_object(object_id) - Soft delete the drawing object (prior to recreating))
│ │ +#    delete_section_object(object_id) - Soft delete the drawing object (prior to recreating)
│ │  #    redraw_section_object(object_id) - Redraw the object on the canvas following an update
│ │  #    default_section_object - The dictionary of default values for the object
│ │  #    enable_editing() - Called when 'Edit' Mode is selected (from Schematic Module)
│ │  #    disable_editing() - Called when 'Run' Mode is selected (from Schematic Module)
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas() - To get the canvas parameters when creating objects
│ │ +#    objects_common.set_bbox - to create/update the boundary box for the schematic object
│ │ +#    objects_common.find_initial_canvas_position - to find the next 'free' canvas position
│ │ +#    objects_common.new_item_id - to find the next 'free' item ID when creating objects
│ │  #    objects_common.section - To get The Object_ID for a given Item_ID
│ │ -#    objects_common.set_bbox - Common function to create boundary box
│ │ -#    objects_common.find_initial_canvas_position - common function 
│ │ -#    objects_common.new_item_id - Common function - when creating objects
│ │  #    objects_common.section_exists - Common function to see if a given item exists
│ │ -#    objects_signals.update_references_to_section - called when point ID changes
│ │ -#    objects_signals.remove_references_to_section - called when Point is deleted
│ │ +#    objects_signals.update_references_to_instrument - when the instrument ID is changed
│ │ +#    objects_signals.remove_references_to_instrument - when the instrument is deleted
│ │  #    
│ │  # Accesses the following external editor objects directly:
│ │  #    run_layout.schematic_callback - setting the object callbacks when created/recreated
│ │ -#    objects_common.schematic_objects - the master dictionary of Schematic Objects
│ │ -#    objects_common.section_index - The index of Section Objects (for iterating)
│ │ +#    objects_common.objects_common.schematic_objects - the master dictionary of Schematic Objects
│ │ +#    objects_common.objects_common.section_index - The index of Section Objects (for iterating)
│ │  #    objects_common.default_object - The common dictionary element for all objects
│ │  #    objects_common.object_type - The Enumeration of supported objects
│ │  #    objects_common.canvas - Reference to the Tkinter drawing canvas
│ │  #
│ │  # Makes the following external API calls to library modules:
│ │  #    track_sections.delete_section(id) - delete library drawing object (part of soft delete)
│ │  #    track_sections.create_section(id) -  To create the library object (create or redraw)
│ │ @@ -38,24 +37,19 @@
│ │  #    track_sections.bind_selection_events(id) - Bind schematic events to the section "button"
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  import uuid
│ │  import copy
│ │  
│ │ -from ..library import track_sections
│ │ +from ...library import track_sections
│ │  
│ │ -from . import settings
│ │  from . import objects_common
│ │  from . import objects_signals
│ │ -from . import run_layout 
│ │ -
│ │ -from .objects_common import schematic_objects as schematic_objects
│ │ -from .objects_common import section_index as section_index
│ │ -from .objects_common import section as section
│ │ +from .. import run_layout 
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Default Track Section Objects (i.e. state at creation)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_section_object = copy.deepcopy(objects_common.default_object)
│ │  default_section_object["item"] = objects_common.object_type.section
│ │ @@ -70,212 +64,246 @@
│ │  # The editing_enabled flag is used to control whether the track section object
│ │  # is created as 'editable' or 'non-editable' (i.e. when 'running' the layout)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  editing_enabled = True
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Functions to delete/re-draw the track section objects on schematic mode change.
│ │ +# Internal function to delete/re-draw the track section objects following a mode change.
│ │ +# We delete everything first before re-drawing to keep Tkinter happy (otherwise it breaks)
│ │ +# The 'reset_state' flag is False when the objects are being re-drawn after a mode toggle
│ │ +# between edit and run mode to maintain state (improved the user experience). For all other
│ │ +# cases, the track section will be set to its default state on re-drawing (i.e. exactly
│ │ +# the same behavior as all other library objects (signals, points, instruments)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def redraw_all_section_objects():
│ │ -    for item_id in section_index:
│ │ -        object_id = objects_common.section(item_id)
│ │ +def redraw_all_section_objects(reset_state:bool=False):
│ │ +    for section_id in objects_common.section_index:
│ │ +        object_id = objects_common.section(section_id)
│ │          delete_section_object(object_id)
│ │ -    for item_id in section_index:
│ │ -        object_id = objects_common.section(item_id)
│ │ -        redraw_section_object(object_id)
│ │ +    for section_id in objects_common.section_index:
│ │ +        object_id = objects_common.section(section_id)
│ │ +        redraw_section_object(object_id, reset_state=False)
│ │      return()
│ │  
│ │ +#------------------------------------------------------------------------------------
│ │ +# Functions to set run/edit mode - We care about this for track sections as we can
│ │ +# only use library objects in run mode. In edit mode we have to use a 'fake' track
│ │ +# section object that is selectable/moveable via canvas mouse/keyboard events
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │  def enable_editing():
│ │      global editing_enabled
│ │      editing_enabled = True
│ │      # Save the current state of the track section library objects
│ │ -    for section_id in section_index:
│ │ +    for section_id in objects_common.section_index:
│ │ +        object_id = objects_common.section(section_id)
│ │          current_state = track_sections.section_occupied(int(section_id))
│ │          current_label = track_sections.section_label(int(section_id))
│ │ -        schematic_objects[section(section_id)]["state"] = current_state
│ │ -        schematic_objects[section(section_id)]["label"] = current_label
│ │ +        objects_common.schematic_objects[object_id]["state"] = current_state
│ │ +        objects_common.schematic_objects[object_id]["label"] = current_label
│ │      # Re-draw the section objects - this will delete the library track section
│ │      # objects and draw dummy objects in their place
│ │      redraw_all_section_objects()
│ │      return()
│ │  
│ │  def disable_editing():
│ │      global editing_enabled
│ │      editing_enabled = False
│ │      # Re-draw the section objects - this will delete the dummy placeholder objects
│ │      # and create the 'real' library track section objects in their place
│ │      redraw_all_section_objects()
│ │      # Set the state of the track section objects to match the retained configuration
│ │ -    for section_id in section_index:
│ │ -        section_label = schematic_objects[section(section_id)]["label"]
│ │ -        if schematic_objects[section(section_id)]["state"]:
│ │ +    for section_id in objects_common.section_index:
│ │ +        object_id = objects_common.section(section_id)
│ │ +        section_label = objects_common.schematic_objects[object_id]["label"]
│ │ +        if objects_common.schematic_objects[object_id]["state"]:
│ │              track_sections.set_section_occupied(section_id, section_label)
│ │          else:
│ │              track_sections.clear_section_occupied(section_id, section_label)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Internal function to Update any references from other Track Sections (mirrored section)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def update_references_to_section(old_section_id:int, new_section_id:int):
│ │ +    # Iterate through all the sections on the schematic
│ │ +    for section_id in objects_common.section_index:
│ │ +        object_id = objects_common.section(section_id)
│ │ +        # We use strings as the IDs support local or remote sections
│ │ +        if objects_common.schematic_objects[object_id]["mirror"] == str(old_section_id):
│ │ +            objects_common.schematic_objects[object_id]["mirror"] = str(new_section_id)
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Internal function to Remove any references from other Track Sections (mirrored section)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def remove_references_to_section(deleted_sec_id:int):
│ │ +    # Iterate through all the sections on the schematic
│ │ +    for section_id in objects_common.section_index:
│ │ +        section_object = objects_common.section(section_id)
│ │ +        # We use string comparison as the IDs support local or remote sections
│ │ +        if objects_common.schematic_objects[section_object]["mirror"] == str(deleted_sec_id):
│ │ +            objects_common.schematic_objects[section_object]["mirror"] = ""
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Function to update (delete and re-draw) a Track Section object on the schematic. Called
│ │  # when the object is first created or after the object attributes have been updated.
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def update_section(object_id, new_object_configuration):
│ │ -    global schematic_objects
│ │      # We need to track whether the Item ID has changed
│ │ -    old_item_id = schematic_objects[object_id]["itemid"]
│ │ +    old_item_id = objects_common.schematic_objects[object_id]["itemid"]
│ │      new_item_id = new_object_configuration["itemid"]
│ │      # Delete the existing section object, copy across the new config and redraw
│ │      delete_section_object(object_id)
│ │ -    schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(new_object_configuration)
│ │      redraw_section_object(object_id)
│ │      # Check to see if the Type-specific ID has been changed
│ │      if old_item_id != new_item_id:
│ │          # Update the type-specific index
│ │ -        del section_index[str(old_item_id)]
│ │ -        section_index[str(new_item_id)] = object_id
│ │ +        del objects_common.section_index[str(old_item_id)]
│ │ +        objects_common.section_index[str(new_item_id)] = object_id
│ │          # Update any references to the section from the Signal automation tables
│ │          objects_signals.update_references_to_section(old_item_id, new_item_id)
│ │ -        # Update any references from other Track Sections (mirrored section)
│ │ -        # We use strings as the IDs support local or remote sections
│ │ -        for section_id in section_index:
│ │ -            if schematic_objects[section(section_id)]["mirror"] == str(old_item_id):
│ │ -                schematic_objects[section(section_id)]["mirror"] = str(new_item_id)
│ │ +        # Update any references from other Track Sections (mirrored sections)
│ │ +        update_references_to_section(old_item_id, new_item_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to redraw a Section object on the schematic. Called when the object is first
│ │ -# created or after the object configuration has been updated.
│ │ +# created or after the object configuration has been updated. The 'reset_state' flag
│ │ +# is False when the objects are being re-drawn after a mode toggle between edit and run
│ │ +# so the state is maintained to improve the user experience (when configuring/testing).
│ │ +# For all other cases, the track section will be set to its default state on re-drawing
│ │ +# (i.e. exactly the same behavior as all other library objects (signals, points etc)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def redraw_section_object(object_id):
│ │ -    global schematic_objects, editing_enabled
│ │ +def redraw_section_object(object_id, reset_state:bool=True):
│ │ +    global editing_enabled
│ │ +    if reset_state:
│ │ +        objects_common.schematic_objects[object_id]["state"] = default_section_object["state"]
│ │ +        objects_common.schematic_objects[object_id]["label"] = objects_common.schematic_objects[object_id]["defaultlabel"]
│ │      # If we are in edit mode then we draw a "dummy" Tracck Section using canvas objects
│ │      # so we can use the mouse events for selecting and moving them (normal Track section
│ │      # objects are selectable buttons which makes selection/moving overly complicated)
│ │      if editing_enabled:
│ │          # Set the tkinter 'tags' to use when creating the drawing objects
│ │ -        schematic_objects[object_id]["tags"] = "section"+ str(schematic_objects[object_id]["itemid"])
│ │ +        objects_common.schematic_objects[object_id]["tags"] = "section"+ str(objects_common.schematic_objects[object_id]["itemid"])
│ │          # Create the text item first using the default section label to define the width
│ │          text_item = objects_common.canvas.create_text(
│ │ -                    schematic_objects[object_id]["posx"],
│ │ -                    schematic_objects[object_id]["posy"],
│ │ -                    text = schematic_objects[object_id]["defaultlabel"],
│ │ -                    tags=schematic_objects[object_id]["tags"],
│ │ +                    objects_common.schematic_objects[object_id]["posx"],
│ │ +                    objects_common.schematic_objects[object_id]["posy"],
│ │ +                    text = objects_common.schematic_objects[object_id]["defaultlabel"],
│ │ +                    tags=objects_common.schematic_objects[object_id]["tags"],
│ │                      font=('Ariel',8,"normal"), fill="white")
│ │          # get the boundary box of the text box and use this to create the background rectangle
│ │          bbox = objects_common.canvas.bbox(text_item)
│ │          rect_item = objects_common.canvas.create_rectangle(
│ │                      bbox[0]-6, bbox[1]-6, bbox[2]+6, bbox[3]+6,
│ │ -                    tags=schematic_objects[object_id]["tags"],
│ │ +                    tags=objects_common.schematic_objects[object_id]["tags"],
│ │                      fill="black")
│ │          # raise the text item to be in front of the rectangle item
│ │          objects_common.canvas.tag_raise(text_item,rect_item)
│ │          # Now the width is set, update the section label to show the section ID
│ │ -        section_label = format(schematic_objects[object_id]["itemid"],'02d')
│ │ +        section_label = format(objects_common.schematic_objects[object_id]["itemid"],'02d')
│ │          objects_common.canvas.itemconfigure(text_item, text=section_label)
│ │          # Create/update the selection rectangle for the Track Section
│ │ -        objects_common.set_bbox(object_id, objects_common.canvas.bbox(schematic_objects[object_id]["tags"]))         
│ │ +        objects_common.set_bbox(object_id, objects_common.canvas.bbox(objects_common.schematic_objects[object_id]["tags"]))         
│ │      else:
│ │          track_sections.create_section(
│ │                      canvas = objects_common.canvas,
│ │ -                    section_id = schematic_objects[object_id]["itemid"],
│ │ -                    x = schematic_objects[object_id]["posx"],
│ │ -                    y = schematic_objects[object_id]["posy"],
│ │ +                    section_id = objects_common.schematic_objects[object_id]["itemid"],
│ │ +                    x = objects_common.schematic_objects[object_id]["posx"],
│ │ +                    y = objects_common.schematic_objects[object_id]["posy"],
│ │                      section_callback = run_layout.schematic_callback,
│ │ -                    label = schematic_objects[object_id]["defaultlabel"],
│ │ -                    editable = schematic_objects[object_id]["editable"])
│ │ +                    label = objects_common.schematic_objects[object_id]["defaultlabel"],
│ │ +                    editable = objects_common.schematic_objects[object_id]["editable"])
│ │          # Create/update the canvas "tags" and selection rectangle for the Track Section
│ │ -        schematic_objects[object_id]["tags"] = track_sections.get_tags(schematic_objects[object_id]["itemid"])
│ │ -        objects_common.set_bbox(object_id, objects_common.canvas.bbox(schematic_objects[object_id]["tags"]))         
│ │ +        objects_common.schematic_objects[object_id]["tags"] = track_sections.get_tags(objects_common.schematic_objects[object_id]["itemid"])
│ │ +        objects_common.set_bbox(object_id, objects_common.canvas.bbox(objects_common.schematic_objects[object_id]["tags"]))         
│ │      return()
│ │   
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Create a new default Track Section (and draw it on the canvas)
│ │  #------------------------------------------------------------------------------------
│ │          
│ │  def create_section():
│ │ -    global schematic_objects
│ │      # Generate a new object from the default configuration with a new UUID 
│ │      object_id = str(uuid.uuid4())
│ │ -    schematic_objects[object_id] = copy.deepcopy(default_section_object)
│ │ +    objects_common.schematic_objects[object_id] = copy.deepcopy(default_section_object)
│ │      # Find the initial canvas position for the new object and assign the item ID
│ │      x, y = objects_common.find_initial_canvas_position()
│ │      item_id = objects_common.new_item_id(exists_function=objects_common.section_exists)
│ │ -    # Add the specific elements for this particular instance of the signal
│ │ -    schematic_objects[object_id]["itemid"] = item_id
│ │ -    schematic_objects[object_id]["posx"] = x
│ │ -    schematic_objects[object_id]["posy"] = y
│ │ +    # Add the specific elements for this particular instance of the section
│ │ +    objects_common.schematic_objects[object_id]["itemid"] = item_id
│ │ +    objects_common.schematic_objects[object_id]["posx"] = x
│ │ +    objects_common.schematic_objects[object_id]["posy"] = y
│ │      # Add the new object to the index of sections
│ │ -    section_index[str(item_id)] = object_id 
│ │ +    objects_common.section_index[str(item_id)] = object_id 
│ │      # Draw the object on the canvas
│ │      redraw_section_object(object_id)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Paste a copy of an existing Track Section - returns the new Object ID
│ │  # Note that only the basic section configuration is used. Underlying configuration
│ │  # such as the current label, state and reference to any mirrored sections is set back
│ │  # to the defaults as it will need to be configured specific to the new section
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def paste_section(object_to_paste):
│ │ -    global schematic_objects
│ │ +def paste_section(object_to_paste, deltax:int, deltay:int):
│ │      # Create a new UUID for the pasted object
│ │      new_object_id = str(uuid.uuid4())
│ │ -    schematic_objects[new_object_id] = object_to_paste
│ │ +    objects_common.schematic_objects[new_object_id] = copy.deepcopy(object_to_paste)
│ │      # Assign a new type-specific ID for the object and add to the index
│ │      new_id = objects_common.new_item_id(exists_function=objects_common.section_exists)
│ │ -    schematic_objects[new_object_id]["itemid"] = new_id
│ │ -    section_index[str(new_id)] = new_object_id
│ │ -    # New objects are "pasted" at a slightly offset position on the canvas
│ │ -    width, height, position_offset = settings.get_canvas()
│ │ -    schematic_objects[new_object_id]["posx"] += position_offset
│ │ -    schematic_objects[new_object_id]["posy"] += position_offset
│ │ +    objects_common.schematic_objects[new_object_id]["itemid"] = new_id
│ │ +    objects_common.section_index[str(new_id)] = new_object_id
│ │ +    # Set the position for the "pasted" object (offset from the original position)
│ │ +    objects_common.schematic_objects[new_object_id]["posx"] += deltax
│ │ +    objects_common.schematic_objects[new_object_id]["posy"] += deltay
│ │      # Now set the default values for all elements we don't want to copy:
│ │ -    schematic_objects[new_object_id]["mirror"] = default_section_object["mirror"]
│ │ -    schematic_objects[new_object_id]["state"] = default_section_object["state"]
│ │ +    objects_common.schematic_objects[new_object_id]["mirror"] = default_section_object["mirror"]
│ │ +    objects_common.schematic_objects[new_object_id]["state"] = default_section_object["state"]
│ │      # Copy across the default label and "reset" the actual lable to the copied default label
│ │ -    schematic_objects[new_object_id]["label"] = schematic_objects[new_object_id]["defaultlabel"]
│ │ +    objects_common.schematic_objects[new_object_id]["label"] = objects_common.schematic_objects[new_object_id]["defaultlabel"]
│ │      # Set the Boundary box for the new object to None so it gets created on re-draw
│ │ -    schematic_objects[new_object_id]["bbox"] = None
│ │ +    objects_common.schematic_objects[new_object_id]["bbox"] = None
│ │      # Draw the new object
│ │      redraw_section_object(new_object_id)
│ │      return(new_object_id)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to "soft delete" the section object from the canvas - Primarily used to
│ │  # delete the track section in its current configuration prior to re-creating in its
│ │  # new configuration - also called as part of a hard delete (below).
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def delete_section_object(object_id):
│ │ -    track_sections.delete_section(schematic_objects[object_id]["itemid"])
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["tags"])
│ │ +    track_sections.delete_section(objects_common.schematic_objects[object_id]["itemid"])
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["tags"])
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to 'hard delete' a track occupancy section (drawing objects and the main
│ │  # dictionary entry). Function called when object is deleted from the schematic.
│ │  #------------------------------------------------------------------------------------
│ │      
│ │  def delete_section(object_id):
│ │ -    global schematic_objects
│ │ -    # Delete the associated library objects from the canvas
│ │ +    # Soft delete the associated library objects from the canvas
│ │      delete_section_object(object_id)
│ │      # Remove any references to the section from the signal track occupancy tables
│ │ -    objects_signals.remove_references_to_section(object_id)
│ │ -    # Remove any references from other Track Sections (mirrored section)
│ │ -    # We use string comparison as the IDs support local or remote sections
│ │ -    item_id_str = str(schematic_objects[object_id]["itemid"])
│ │ -    for section_id in section_index:
│ │ -        if schematic_objects[section(section_id)]["mirror"] == item_id_str:
│ │ -            schematic_objects[section(section_id)]["mirror"] = ""
│ │ +    objects_signals.remove_references_to_section(objects_common.schematic_objects[object_id]["itemid"])
│ │ +    # Remove any references from other Track Sections (mirrored sections)
│ │ +    remove_references_to_section(objects_common.schematic_objects[object_id]["itemid"])
│ │      # "Hard Delete" the selected object - deleting the boundary box rectangle and deleting
│ │      # the object from the dictionary of schematic objects (and associated dictionary keys)
│ │ -    objects_common.canvas.delete(schematic_objects[object_id]["bbox"])
│ │ -    del section_index[str(schematic_objects[object_id]["itemid"])]
│ │ -    del schematic_objects[object_id]
│ │ +    objects_common.canvas.delete(objects_common.schematic_objects[object_id]["bbox"])
│ │ +    del objects_common.section_index[str(objects_common.schematic_objects[object_id]["itemid"])]
│ │ +    del objects_common.schematic_objects[object_id]
│ │      return()
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/resources/block_instrument.png
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/resources/block_instrument.png
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/resources/track_section.png
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/resources/track_section.png
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/run_layout.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/run_layout.py
│ │┄ Files 6% similar despite different names
│ │ @@ -1,11 +1,12 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This module contains all the functions to "run" the layout
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ +#    initialise(canvas) - sets a global reference to the tkinter canvas object
│ │  #    initialise_layout() - call after object changes/deletions or load of a new schematic
│ │  #    schematic_callback(item_id,callback_type) - the callback for all schematic objects
│ │  #    enable_editing() - Call when 'Edit' Mode is selected (from Schematic Module)
│ │  #    disable_editing() - Call when 'Run' Mode is selected (from Schematic Module)
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │  #    objects.signal(signal_id) - To get the object_id for a given signal_id
│ │ @@ -33,49 +34,64 @@
│ │  #    <MORE COMING>
│ │  #
│ │  # Makes the following external API calls to library modules:
│ │  #    signals.signal_state(sig_id) - For testing the current displayed aspect
│ │  #    signals.update_signal(sig_id, sig_ahead_id) - To update the signal aspect
│ │  #    signals.signal_clear(sig_id, sig_route) - To test if a signal is clear
│ │  #    signals.subsidary_clear(sig_id) - to test if a subsidary is clear
│ │ +#    signals.lock_signal(sig_id) - To lock a signal
│ │  #    signals.unlock_signal(sig_id) - To unlock a signal
│ │ -#    signals.lock_signal(sig_id) - To interlocklock a signal
│ │ -#    signals.unlock_subsidary(sig_id) - To unlock a subsidary signal
│ │  #    signals.lock_subsidary(sig_id) - To lock a subsidary signal
│ │ +#    signals.unlock_subsidary(sig_id) - To unlock a subsidary signal
│ │ +#    signals.toggle_signal(sig_id) - To toggle a signal state
│ │ +#    signals.toggle_subsidary(sig_id) - To toggle a subsidary signal state
│ │  #    signals.set_route(sig_id, sig_route, theatre) - To set the route for the signal
│ │  #    signals.trigger_timed_signal(sig_id, T1, T2) - Trigger timed signal sequence
│ │  #    points.fpl_active(point_id) - To test if a facing point lock is active
│ │ +#    points.toggle_fpl(point_id) - To toggle the state of the point FPL
│ │  #    points.point_switched(point_id) - To test if a point is switched
│ │ +#    points.toggle_point(point_id) - To toggle the state of the point
│ │  #    points.lock_point(point_id) - To intelock a point
│ │ +#    points.unlock_point(point_id) - To intelock a point
│ │  #    track_sections.set_section_occupied (section_id) - Set "Occupied"
│ │  #    track_sections.clear_section_occupied (section_id) - Clear "Occupied"
│ │  #    track_sections.section_occupied (section_id) - To test if a section is occupied
│ │  #    <MORE COMING>
│ │  #
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -from typing import Union
│ │  import logging
│ │  
│ │  from ..library import signals
│ │  from ..library import points
│ │  from ..library import block_instruments
│ │  from ..library import signals_common
│ │  from ..library import signals_semaphores
│ │  from ..library import signals_colour_lights
│ │  from ..library import track_sections
│ │  
│ │  from . import objects
│ │ -from . import objects_common
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# The Tkinter Canvas Object is saved as a global variable for easy referencing
│ │ +# The set_canvas function is called at application startup (on canvas creation)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +canvas = None
│ │ +
│ │ +def initialise(canvas_object):
│ │ +    global canvas
│ │ +    canvas = canvas_object
│ │ +    return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal helper Function to find if a signal has a subsidary
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def has_subsidary(signal_id):    
│ │ +def has_subsidary(signal_id:int):    
│ │      signal_object = objects.schematic_objects[objects.signal(signal_id)]
│ │      return (signal_object["subsidary"][0] or
│ │              signal_object["sigarms"][0][1][0] or
│ │              signal_object["sigarms"][1][1][0] or
│ │              signal_object["sigarms"][2][1][0] or
│ │              signal_object["sigarms"][3][1][0] or
│ │              signal_object["sigarms"][4][1][0] )
│ │ @@ -174,15 +190,15 @@
│ │  # signal type) and return home_signal_at_danger=False
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def home_signal_ahead_at_danger(signal_object, recursion_level:int=0):
│ │      global logging
│ │      home_signal_at_danger = False
│ │ -    if recursion_level < 50:
│ │ +    if recursion_level < 20:
│ │          signal_ahead_object = find_signal_ahead(signal_object)
│ │          if signal_ahead_object is not None:
│ │              signal_id = signal_ahead_object["itemid"]
│ │              is_home = ( ( signal_ahead_object["itemtype"] == signals_common.sig_type.colour_light.value and
│ │                            signal_ahead_object["itemsubtype"] == signals_colour_lights.signal_sub_type.home.value ) or
│ │                          ( signal_ahead_object["itemtype"] == signals_common.sig_type.semaphore.value and
│ │                            signal_ahead_object["itemsubtype"] == signals_semaphores.semaphore_sub_type.home.value) )
│ │ @@ -192,25 +208,46 @@
│ │                  # Call the function recursively to find the next signal ahead
│ │                  home_signal_at_danger = home_signal_ahead_at_danger(signal_ahead_object, recursion_level+1)
│ │      else:
│ │          logging.error("RUN LAYOUT - Interlock with Signal ahead - Maximum recursion level reached")
│ │      return (home_signal_at_danger)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ +# Internal Function to test if the signal ahead of the specified signal is a
│ │ +# distant signal and if that distant signal is displaying a caution aspect
│ │ +#####################################################################################
│ │ +# TODO - Update function to the modified signal_ahead function and then test to
│ │ +# see if the signal is local or remote (sigID is integer or string). If the signal
│ │ +# is a remote signal then we should stop processing (as we have no idea of the
│ │ +# signal type) and return home_signal_at_danger=False
│ │ +#####################################################################################
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def distant_signal_ahead_at_caution(signal_object):
│ │ +    sig_ahead = find_signal_ahead(signal_object)
│ │ +    sig_ahead_id = sig_ahead["itemid"]
│ │ +    is_distant = ( ( sig_ahead["itemtype"] == signals_common.sig_type.colour_light.value and
│ │ +                     sig_ahead["itemsubtype"] == signals_colour_lights.signal_sub_type.distant.value ) or
│ │ +                   ( sig_ahead["itemtype"] == signals_common.sig_type.semaphore.value and
│ │ +                     sig_ahead["itemsubtype"] == signals_colour_lights.signal_sub_type.distant.value ) )
│ │ +    signal_at_caution = (signals.signal_state(sig_ahead_id) == signals_common.signal_state_type.CAUTION)
│ │ +    return(is_distant and signal_at_caution)
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │  # Internal function to find any colour light signals which are configured to update aspects
│ │  # based on the aspect of the signal that has changed (i.e. signals "behind"). The function
│ │  # is recursive and keeps working back along the route until there are no further changes
│ │  # that need propagating backwards. A maximum recursion depth provides a level of protection.
│ │  #####################################################################################
│ │  # TODO - Update function to use the updated "find signal behind" function (using SigID)
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def update_signal_behind(signal_object, recursion_level:int=0):
│ │ -    if recursion_level < 50:
│ │ +    if recursion_level < 20:
│ │          signal_behind_object = find_signal_behind(signal_object)
│ │          if signal_behind_object is not None:
│ │              if signal_behind_object["itemtype"] == signals_common.sig_type.colour_light.value:
│ │                  signal_id = signal_object["itemid"]
│ │                  signal_behind_id = signal_behind_object["itemid"]
│ │                  # Fnd the displayed aspect of the signal (before any changes)
│ │                  initial_signal_aspect = signals.signal_state(signal_behind_id)
│ │ @@ -376,25 +413,37 @@
│ │  # Function to Update any mirrored track sections on a change to one track section
│ │  # Note that the ID is a string (local or remote)
│ │  #####################################################################################
│ │  # TODO - Update function to use Section ID rather than section_object for consistency
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def update_mirrored_section(section_object):
│ │ -    section_id = str(section_object["itemid"])
│ │ -    for other_section_id in objects.section_index:
│ │ -        mirrored_section = objects.schematic_objects[objects.section(other_section_id)]["mirror"]
│ │ -        if mirrored_section == section_id:
│ │ -            label_to_set = track_sections.section_label(section_id)
│ │ -            state_to_set = track_sections.section_occupied(section_id)
│ │ -            if state_to_set:
│ │ -                track_sections.set_section_occupied(other_section_id, label_to_set, publish=False)
│ │ -            else:
│ │ -                track_sections.clear_section_occupied(other_section_id, label_to_set, publish=False)
│ │ +def update_mirrored_section(section_object, section_id_just_set:str="0", recursion_level:int=0):
│ │ +    if recursion_level < 20:
│ │ +        changed_section_id = str(section_object["itemid"])
│ │ +       # Iterate through the other sections to see if any are set to mirror this section
│ │ +        for section_id_to_test in objects.section_index:
│ │ +            section_object_to_test = objects.schematic_objects[objects.section(section_id_to_test)]
│ │ +            mirrored_section_id_of_object_to_test = section_object_to_test["mirror"]
│ │ +            # Note that the use case of trwo sections set to mirror each other is valid
│ │ +            # For this, we just update the first mirrored section and then exit
│ │ +            if changed_section_id == mirrored_section_id_of_object_to_test:
│ │ +                label_to_set = track_sections.section_label(changed_section_id)
│ │ +                state_to_set = track_sections.section_occupied(changed_section_id)
│ │ +                if state_to_set:
│ │ +                    track_sections.set_section_occupied(section_id_to_test,label_to_set,publish=False)
│ │ +                else:
│ │ +                    track_sections.clear_section_occupied(section_id_to_test,label_to_set,publish=False)
│ │ +                # See if there are any other sections set to mirror this section
│ │ +                if section_id_to_test != section_id_just_set:
│ │ +                    update_mirrored_section(section_object=section_object_to_test,
│ │ +                                section_id_just_set=mirrored_section_id_of_object_to_test,
│ │ +                                recursion_level= recursion_level+1)
│ │ +    else:
│ │ +        logging.error("RUN LAYOUT - Update Mirrored Section - Maximum recursion level reached")
│ │      return()
│ │  
│ │  #-------------------------------------------------------------------------------------
│ │  # Function to update the Signal interlocking (against points & instruments). Called on
│ │  # sig/sub_switched, point_switched fpl_switched or block_section_ahead_updated events
│ │  # Note that this function processes updates for the entire schematic
│ │  #------------------------------------------------------------------------------------
│ │ @@ -524,101 +573,108 @@
│ │              clear_signal_override(signal_object)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to override any distant signals that have been configured to be overridden
│ │  # to CAUTION if any of the home signals on the route ahead are at DANGER. If this
│ │  # results in an aspect change then we also work back to update any dependent signals
│ │ -# The 'track_occupancy_updated' flag is used to determine if the override has already
│ │ -# been set/cleared due to possible changes in track occupancy (where any override that
│ │ -# has been set needs to be maintained. If the flag is False then this function needs
│ │ -# to explicitly set or clear the override based soley on the home signals ahead
│ │  #####################################################################################
│ │  # TODO - Update function in light of the move to using IDs rather than objects
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def update_all_distant_overrides(track_occupancy_updated):
│ │ +def update_all_distant_overrides():
│ │      for signal_id in objects.signal_index:
│ │          signal_object = objects.schematic_objects[objects.signal(signal_id)]
│ │ -        signal_should_be_overridden = False
│ │ -        distant_should_be_overridden = False
│ │          # The "overrideahead" flag will only be True if selected and it can only be selected for
│ │          # a semaphore distant, a colour light distant or a semaphore home with secondary distant arms
│ │          # In the latter case then a call to "has_distant_arms" will be true (false for all other types)
│ │          if signal_object["overrideahead"]:
│ │ -            # In 'run' mode, all Signal Overrides will already have been SET or CLEARED based on the state
│ │ -            # of the track section ahead of the signal so we need to additional SET the override if any home
│ │ -            # signals ahead are at DANGER (we don't want to CLEAR any existing Track Occupancy overrides)
│ │ -            # In 'edit' mode the state will be unknown when this function is called so we need to SET or
│ │ -            # CLEAR the signal override based solely on the state of any home signals ahead
│ │ -            if home_signal_ahead_at_danger(signal_object):
│ │ +            # The Override on signals ahead function is designed for two use cases
│ │ +            # 1) Override signal to CAUTION if ANY home signals in the block section are at danger
│ │ +            # 2) Override signal to CAUTION if a distant signal is ahead and at CAUTION - this is to
│ │ +            #    allow distant signals controlled by one block section to be 'mirrored' on another block
│ │ +            #    section - e.g. A home signal with an secondary distant arm. In this case the distant
│ │ +            #    arm would be under the control of the next block section (on that block section schematic)
│ │ +            #    but you might still want to show the signal (and its state) on your own block schematic
│ │ +            if distant_signal_ahead_at_caution(signal_object) or home_signal_ahead_at_danger(signal_object):
│ │                  if has_distant_arms(signal_object):
│ │ -                    signals.set_signal_override(int(signal_id)+100)
│ │ +                    signals.set_signal_override_caution(int(signal_id)+100)
│ │                  else:
│ │ -                    signals.set_signal_override(int(signal_id))
│ │ -            elif not track_occupancy_updated:
│ │ +                    signals.set_signal_override_caution(int(signal_id))
│ │ +            else:
│ │                  if has_distant_arms(signal_object):
│ │ -                    signals.clear_signal_override(int(signal_id)+100)
│ │ +                    signals.clear_signal_override_caution(int(signal_id)+100)
│ │                  else:
│ │ -                    signals.clear_signal_override(int(signal_id))
│ │ +                    signals.clear_signal_override_caution(int(signal_id))
│ │              # Update the signal aspect and propogate any aspect updates back along the route
│ │              process_aspect_updates(signal_object)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to SET or CLEAR a signal's approach control state and refresh the displayed
│ │  # aspect. The function then recursively calls itself to work backwards along the route
│ │  # updating the approach control state (and displayed aspect)of preceding signals
│ │ +# Note that Approach control won't be set in the period between signal released and
│ │ +# signal passed events unless the 'force_set' flag is set
│ │  #####################################################################################
│ │  # TODO - Update function in light of the move to using IDs rather than objects
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def update_signal_approach_control(signal_object, recursion_level:int=0):
│ │ -    if recursion_level < 50:
│ │ +def update_signal_approach_control(signal_object, force_set:bool, recursion_level:int=0):
│ │ +    if recursion_level < 20:
│ │          if (signal_object["itemtype"] == signals_common.sig_type.colour_light.value or
│ │                   signal_object["itemtype"] == signals_common.sig_type.semaphore.value):
│ │              signal_route = find_signal_route(signal_object)
│ │              if signal_route is not None:
│ │                  # The "approachcontrol" element is a list of routes [Main, Lh1, Lh2, Rh1, Rh2]
│ │                  # Each element represents the approach control mode that has been set
│ │                  # release_on_red=1, release_on_yel=2, released_on_red_home_ahead=3
│ │                  if signal_object["approachcontrol"][signal_route.value-1] == 1:
│ │ -                    signals.set_approach_control(signal_object["itemid"],release_on_yellow=False,force_set=False)
│ │ +                    signals.set_approach_control(signal_object["itemid"],
│ │ +                                  release_on_yellow=False, force_set=force_set)
│ │                  elif signal_object["approachcontrol"][signal_route.value-1] == 2:
│ │ -                    signals.set_approach_control(signal_object["itemid"],release_on_yellow=True,force_set=False)
│ │ +                    signals.set_approach_control(signal_object["itemid"],
│ │ +                                release_on_yellow=True, force_set=force_set)
│ │                  elif (signal_object["approachcontrol"][signal_route.value-1] == 3 and
│ │                                      home_signal_ahead_at_danger(signal_object) ):
│ │ -                    signals.set_approach_control(signal_object["itemid"], release_on_yellow=False, force_set=False)
│ │ +                    signals.set_approach_control(signal_object["itemid"],
│ │ +                                release_on_yellow=False, force_set=force_set)
│ │                  else:
│ │                      signals.clear_approach_control(signal_object["itemid"])
│ │              else:
│ │                  signals.clear_approach_control(signal_object["itemid"])
│ │          # Update the signal aspect and work back along the route to see if any other signals need
│ │          # approach control to be set/cleared depending on the updated aspect of this signal
│ │          process_aspect_updates(signal_object)    
│ │          signal_behind_object = find_signal_behind(signal_object)
│ │          if signal_behind_object is not None:
│ │ -            update_signal_approach_control(signal_behind_object,recursion_level+1)
│ │ +            update_signal_approach_control(signal_behind_object, False, recursion_level+1)
│ │      else:
│ │          logging.error("RUN LAYOUT - Update Approach Control on signals ahead - Maximum recursion level reached")
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to Update the approach control state of all signals
│ │ +# Note that the 'force_set' flag is set for the signal that has been switched
│ │ +# (this is passed in on a signal switched event only) to enforce a "reset" of
│ │ +# the Approach control mode in the period between signal released and signal passed events
│ │  #####################################################################################
│ │  # TODO - Update function in light of the move to using IDs rather than objects
│ │  #####################################################################################
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def update_all_signal_approach_control():
│ │ +def update_all_signal_approach_control(item_id=None, callback_type=None):
│ │      for signal_id in objects.signal_index:
│ │ +        if (callback_type == signals_common.sig_callback_type.sig_switched and
│ │ +            signal_id == str(item_id) ): force_set = True
│ │ +        else: force_set = False
│ │          signal_object = objects.schematic_objects[objects.signal(signal_id)]
│ │ -        update_signal_approach_control(signal_object)
│ │ +        update_signal_approach_control(signal_object, force_set)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to clear all signal overrides
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def clear_all_signal_overrides():
│ │ @@ -658,96 +714,98 @@
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def schematic_callback(item_id,callback_type):
│ │      global logging
│ │      global editing_enabled
│ │      logging.info("RUN LAYOUT - Callback - Item: "+str(item_id)+" - Callback Type: "+str(callback_type))
│ │  
│ │ -    # The following flags are used to control what gets processed during the callback
│ │ -    track_occupancy_updated = False
│ │ -    signal_overrides_updated = False
│ │ -    signal_aspects_updated = False
│ │ +    # Timed signal sequences can be triggered by 'signal_passed' events
│ │ +    if callback_type == signals_common.sig_callback_type.sig_passed:
│ │ +        logging.info("RUN LAYOUT - Triggering any Timed Signal sequences (signal passed event):")
│ │ +        trigger_timed_sequence(objects.schematic_objects[objects.signal(item_id)])
│ │ +            
│ │ +    # 'signal_passed' events can trigger changes in track occupancy but only in RUN mode
│ │ +    # This is because Track section library objects only 'exist' in Run mode
│ │ +    if callback_type == signals_common.sig_callback_type.sig_passed and not editing_enabled:
│ │ +        logging.info("RUN LAYOUT - Updating Track Section occupancy (signal passed event):")
│ │ +        update_track_occupancy(objects.schematic_objects[objects.signal(item_id)])
│ │  
│ │      # Signal routes are updated on 'point_switched' or 'fpl_switched' events
│ │ -    # Signal overrides are also updated as the 'section ahead' may have changed
│ │      if ( callback_type == points.point_callback_type.point_switched or
│ │           callback_type == points.point_callback_type.fpl_switched ):
│ │          logging.info("RUN LAYOUT - Updating Signal Routes based on Point settings:")
│ │          set_all_signal_routes()
│ │ -        logging.info("RUN LAYOUT - Overriding Signals to reflect Track Occupancy:")
│ │ -        update_all_signal_overrides()
│ │ -        # Note that approach control and signal overrides will have been set/cleared
│ │ -        signal_overrides_updated = True
│ │          
│ │ -    # Timed sequences or changes in track occupancy are triggered by 'signal_passed' events
│ │ -    if callback_type == signals_common.sig_callback_type.sig_passed:
│ │ -        logging.info("RUN LAYOUT - Triggering any Timed Signal sequences (signal passed event):")
│ │ -        trigger_timed_sequence(objects.schematic_objects[objects.signal(item_id)])
│ │ -        # Note that Track sections (the library objects) only "exist" in run mode
│ │ -        if not editing_enabled:
│ │ -            logging.info("RUN LAYOUT - Updating Track Section occupancy (signal passed event):")
│ │ -            update_track_occupancy(objects.schematic_objects[objects.signal(item_id)])
│ │ -            # Set the flag to note that all track sections will have been set or cleared
│ │ -            track_occupancy_updated = True
│ │ -
│ │ -    # 'Mirrored' track sections and signal overrides (i.e. overrides based on track
│ │ -    # occupancy) only need to be updated when a track section is manually changed
│ │ -    # (which implies we are in RUN Mode) or if the track section occupancy has been
│ │ -    # updated in RUN Mode (signified by the track_occupancy_updated flag) - this is
│ │ -    # important as Track sections (the library objects) only "exist" in run mode
│ │ -    if ( callback_type == track_sections.section_callback_type.section_updated or
│ │ -                track_occupancy_updated ):
│ │ -        logging.info("RUN LAYOUT - Updating all Mirrored Track Sections:")
│ │ -        update_all_mirrored_sections()
│ │ -        logging.info("RUN LAYOUT - Updating Signal Overrides to reflect Track Occupancy:")
│ │ -        update_all_signal_overrides()
│ │ -        # Set the flag to note that the overrides for all signals will have been explicitly
│ │ -        # set or cleared to reflect the occupancy state of the track section ahead
│ │ -        signal_overrides_updated = True
│ │ -            
│ │ -    # Signal aspects can change as a result of 'sig_switched' or 'sig_updated' event or if
│ │ +    # 'Mirrored' track sections only need to be updated when a track section is manually
│ │ +    # changed (which implies we are in RUN Mode) or if track section occupancy has been
│ │ +    # updated in RUN Mode (i.e. following a signal passed event in RUN Mode) - this
│ │ +    # is important as Track sections (the library objects) only "exist" in run mode
│ │ +    if callback_type == track_sections.section_callback_type.section_updated:
│ │ +        logging.info("RUN LAYOUT - Updating any Mirrored Track Sections:")
│ │ +        update_mirrored_section(objects.schematic_objects[objects.section(item_id)])
│ │ +
│ │ +    # Signal aspects need to be updated on 'sig_switched'(where a signal state has been manually
│ │ +    # changed via the UI), 'sig_updated' (either a timed signal sequence or a remote signal update),
│ │ +    # changes to signal overides (see above for events) or changes to the approach control state
│ │ +    # of a signal ('sig_passed' or 'sig_released' events - or any changes to the signal routes)
│ │      # any signal overrides have been SET or CLEARED (as a result of track sections ahead
│ │      # being occupied/cleared following a signal passed event) or if any signal junction
│ │      # approach control states have been SET or CLEARED - including the case of the signal
│ │      # being RELEASED (as signified by the 'sig_released' event) or the approach control
│ │      # being RESET (following a 'sig_passed' event)
│ │      if ( callback_type == signals_common.sig_callback_type.sig_updated or
│ │           callback_type == signals_common.sig_callback_type.sig_released or
│ │           callback_type == signals_common.sig_callback_type.sig_passed or
│ │           callback_type == signals_common.sig_callback_type.sig_switched or
│ │ -         signal_overrides_updated):
│ │ +         callback_type == points.point_callback_type.point_switched or
│ │ +         callback_type == points.point_callback_type.fpl_switched or
│ │ +         callback_type == track_sections.section_callback_type.section_updated ):
│ │ +        # First we update all signal overrides based on track occupancy
│ │ +        # But only in RUN mode (as track sections only exist in RUN Mode)
│ │ +        logging.info("RUN LAYOUT - Updating Signal Overrides to reflect Track Occupancy:")
│ │ +        if not editing_enabled: update_all_signal_overrides()
│ │          # Approach control is made complex by the need to support the case of setting approach
│ │          # control on the state of home signals ahead (for layout automation). We therefore have
│ │          # to process these changes here (which also updates the aspects of all signals)
│ │          logging.info("RUN LAYOUT - Updating Signal Approach Control and updating signal aspects:")
│ │ -        update_all_signal_approach_control()
│ │ -        # If the 'track_occupancy_updated' flag is set we only need to 'set' any affected sections
│ │ -        logging.info("RUN LAYOUT - Updating Distant Signal Overrides to reflect Home Signals ahead:")
│ │ -        update_all_distant_overrides(track_occupancy_updated)
│ │ -        # Set the flag to note that the signal aspects may have been changed
│ │ -        signal_aspects_updated = True
│ │ +        update_all_signal_approach_control(item_id, callback_type)
│ │ +        # Finally process any distant signal overrides on home signals ahead
│ │ +        # The editing_enabled flag is used by the function to determine whether all signal
│ │ +        # overrides have already been explicitly SET/CLEARED by the update_all_signal_overrides
│ │ +        # function (see above). If so, then the function will only additionally SET an override
│ │ +        # (any existing overrides will remain SET). If  not, then the function will either SET or
│ │ +        # CLEAR the override based solely on the state of the Home signals ahead
│ │ +        logging.info("RUN LAYOUT - Updating Signal CAUTION Overrides to reflect Signals ahead:")
│ │ +        update_all_distant_overrides()
│ │  
│ │      # Signal interlocking is updated on point, signal or block instrument switched events
│ │      # We also need to process signal interlocking on any event which may have changed the
│ │      # displayed aspect of a signal (when interlocking signals against home signals ahead)
│ │      if ( callback_type == block_instruments.block_callback_type.block_section_ahead_updated or
│ │ -              signal_aspects_updated ):
│ │ +         callback_type == signals_common.sig_callback_type.sub_switched or
│ │ +         callback_type == signals_common.sig_callback_type.sig_updated or
│ │ +         callback_type == signals_common.sig_callback_type.sig_released or
│ │ +         callback_type == signals_common.sig_callback_type.sig_passed or
│ │ +         callback_type == signals_common.sig_callback_type.sig_switched or
│ │ +         callback_type == points.point_callback_type.point_switched or
│ │ +         callback_type == points.point_callback_type.fpl_switched or
│ │ +         callback_type == track_sections.section_callback_type.section_updated  ):
│ │          logging.info("RUN LAYOUT - Updating Signal Interlocking:")
│ │          process_all_signal_interlocking()
│ │          
│ │      # Point interlocking is updated on signal changed events
│ │      if ( callback_type == signals_common.sig_callback_type.sig_switched or
│ │           callback_type == signals_common.sig_callback_type.sub_switched):
│ │          logging.info("RUN LAYOUT - Updating Point Interlocking:")
│ │          process_all_point_interlocking()
│ │          
│ │      logging.info("**************************************************************************************")
│ │      
│ │      # Refocus back on the canvas to ensure that any keypress events function
│ │ -    objects_common.canvas.focus_set()
│ │ +    canvas.focus_set()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Function to "initialise" the layout following a reset / re-load or item deletion
│ │  # Also called after the configuration change of any layout object
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ @@ -765,15 +823,15 @@
│ │          logging.info("RUN LAYOUT - Updating all Mirrored Track Sections:")
│ │          update_all_mirrored_sections()
│ │          logging.info("RUN LAYOUT - Overriding Signals to reflect Track Occupancy:")
│ │          update_all_signal_overrides()
│ │      logging.info("RUN LAYOUT - Updating Signal Approach Control and updating signal aspects:")
│ │      update_all_signal_approach_control()
│ │      logging.info("RUN LAYOUT - Updating Distant Signal Overrides based on Home Signals ahead:")
│ │ -    update_all_distant_overrides(editing_enabled)    
│ │ +    update_all_distant_overrides()    
│ │      logging.info("RUN LAYOUT - Updating Signal Interlocking:")
│ │      process_all_signal_interlocking()
│ │      logging.info("RUN LAYOUT - Updating Point Interlocking:")
│ │      process_all_point_interlocking()
│ │      logging.info("**************************************************************************************")
│ │      return()
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/schematic.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/schematic.py
│ │┄ Files 6% similar despite different names
│ │ @@ -1,28 +1,31 @@
│ │  #------------------------------------------------------------------------------------
│ │  # This Module provides all the internal functions for editing the layout schematic
│ │  # in terms of adding/removing objects, drag/drop objects, copy/paste objects etc
│ │  #------------------------------------------------------------------------------------
│ │  #
│ │  # External API functions intended for use by other editor modules:
│ │ -#    create_canvas(root) - Call once on startup - returns canvas object
│ │ +#    initialise(root, callback, width, height, grid) - Call once on startup
│ │ +#    update_canvas() - Call following a size update (or layout load/canvas resize)
│ │  #    select_all_objects() - For selecting all objects prior to a "safe" delete
│ │  #    delete_selected_objects() - To delete all objects (once all are selected)
│ │ -#    resize_canvas() - Call following a size update (or layout load/canvas resize)
│ │  #    enable_editing() - Call when 'Edit' Mode is selected (via toolbar or on load)
│ │  #    disable_editing() - Call when 'Run' Mode is selected (via toolbar or on load)
│ │  #
│ │  # Makes the following external API calls to other editor modules:
│ │ -#    settings.get_canvas(object_id) - Get canvas settings (for resize, snap to grid etc)
│ │ -#    objects.set_canvas(canvas) - Initialise the objects module with the canvas reference
│ │ +#    objects.initialise (canvas,width,height,grid) - Initialise the objects package and set defaults
│ │ +#    objects.update_canvas(width,height,grid) - update the attributes (on layout load or canvas re-size)
│ │  #    objects.create_object(obj, type, subtype) - Create a default object on the schematic
│ │  #    objects.delete_objects(list of obj IDs) - Delete the selected objects from the canvas
│ │  #    objects.rotate_objects(list of obj IDs) - Rotate the selected objects on the canvas
│ │  #    objects.copy_objects(list of obj IDs) - Copy the selected objects to the clipboard
│ │  #    objects.paste_objects() - Paste the selected objects (returns a list of new IDs)
│ │ +#    objects.undo() / objects.redo() - Undo and re-do functions as you would expect
│ │ +#    objects.enable_editing() - Call when 'Edit' Mode is selected 
│ │ +#    objects.disable_editing() - Call when 'Run' Mode is selected
│ │  #    configure_signal.edit_signal(root,object_id) - Open signal edit window (on double click)
│ │  #    configure_point.edit_point(root,object_id) - Open point edit window (on double click)
│ │  #    configure_section.edit_section(root,object_id) - Open section edit window (on double click)
│ │  #    ########################## More to be added ########################################
│ │  #
│ │  # Accesses the following external editor objects directly:
│ │  #    objects.schematic_objects - the dict holding descriptions for all objects
│ │ @@ -44,15 +47,14 @@
│ │  from ..library import signals_common
│ │  from ..library import signals_colour_lights
│ │  from ..library import signals_semaphores
│ │  from ..library import signals_ground_position
│ │  from ..library import signals_ground_disc
│ │  from ..library import points
│ │  
│ │ -from . import settings
│ │  from . import objects
│ │  from . import configure_signal
│ │  from . import configure_point
│ │  from . import configure_section
│ │  
│ │  import importlib.resources
│ │  import logging
│ │ @@ -73,16 +75,21 @@
│ │  schematic_state["editlineend1"] = False
│ │  schematic_state["editlineend2"] = False
│ │  schematic_state["selectarea"] = False
│ │  schematic_state["selectareabox"] = None      # Tkinter drawing object
│ │  schematic_state["selectedobjects"] = []
│ │  # The Root reference is used when calling a "configure object" module (to open a popup window)
│ │  # The Canvas reference is used for configuring and moving canvas widgets for schematic editing
│ │ +# canvas_width / canvas_height / canvas_grid are used for positioning of objects
│ │  canvas = None
│ │  root = None
│ │ +canvas = None
│ │ +canvas_width = 0
│ │ +canvas_height = 0
│ │ +canvas_grid = 0
│ │  # The callback to make (for selected canvas events). Currently only the mode change keypress
│ │  # event makes this callback (to enable the application mode to be toggled between edit and run)
│ │  canvas_event_callback = None
│ │  # The following Tkinter objects are also treated as global variables as they need to remain
│ │  # "in scope" for the schematic editor functions (i.e. so they don't get garbage collected)
│ │  # The two popup menus (for right click on the canvas or a schematic object)
│ │  popup1 = None
│ │ @@ -90,28 +97,27 @@
│ │  # The Frame holding the "add object" buttons (for pack/forget on enable/disable editing)
│ │  # and the Tkinter PhotoImage labels for the buttons
│ │  button_frame = None
│ │  button_images = {}
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal Function to draw (or redraw) the grid on the screen (after re-sizing)
│ │ +# Uses the global canvas_width, canvas_height, canvas_grid variables
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def draw_grid():
│ │ -    width, height, canvas_grid = settings.get_canvas()
│ │      # Note we leave the 'state' of the grid  unchanged when re-drawing
│ │      # As the 'state' is set (normal or hidden) when enabling/disabling editing
│ │      grid_state = canvas.itemcget("grid",'state')
│ │      canvas.delete("grid")
│ │ -    if grid_state =="" : state = "normal"
│ │ -    canvas.create_rectangle(0, 0, width, height, outline='#999', fill="", tags="grid", state=grid_state)
│ │ -    for i in range(0, height, canvas_grid):
│ │ -        canvas.create_line(0,i,width,i,fill='#999',tags="grid",state=grid_state)
│ │ -    for i in range(0, width, canvas_grid):
│ │ -        canvas.create_line(i,0,i,height,fill='#999',tags="grid",state=grid_state)
│ │ +    canvas.create_rectangle(0, 0, canvas_width, canvas_height, outline='#999', fill="", tags="grid", state=grid_state)
│ │ +    for i in range(0, canvas_height, canvas_grid):
│ │ +        canvas.create_line(0,i,canvas_width,i,fill='#999',tags="grid",state=grid_state)
│ │ +    for i in range(0, canvas_width, canvas_grid):
│ │ +        canvas.create_line(i,0,i,canvas_height,fill='#999',tags="grid",state=grid_state)
│ │      # Push the grid to the back (behind any drawing objects)
│ │      canvas.tag_lower("grid")
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal function to select an object (adding to the list of selected objects)
│ │  #------------------------------------------------------------------------------------
│ │ @@ -310,25 +316,25 @@
│ │              elif math.sqrt((xpos - x2) ** 2 + (ypos - y2) ** 2) <= 10:
│ │                  schematic_state["editlineend1"] = False
│ │                  schematic_state["editlineend2"] = True
│ │                  return(object_id)
│ │      return(None)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Internal function to Snap the given coordinates to a grid (by rewturning the deltas)
│ │ +# Internal function to Snap the given coordinates to a grid (by returning the deltas)
│ │ +# Uses the global canvas_grid variable
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def snap_to_grid(xpos:int,ypos:int):
│ │ -    width, height, grid_size = settings.get_canvas()
│ │ -    remainderx = xpos%grid_size
│ │ -    remaindery = ypos%grid_size
│ │ -    if remainderx < grid_size/2: remainderx = 0 - remainderx
│ │ -    else: remainderx = grid_size - remainderx
│ │ -    if remaindery < grid_size/2: remaindery = 0 - remaindery
│ │ -    else: remaindery = grid_size - remaindery
│ │ +    remainderx = xpos%canvas_grid
│ │ +    remaindery = ypos%canvas_grid
│ │ +    if remainderx < canvas_grid/2: remainderx = 0 - remainderx
│ │ +    else: remainderx = canvas_grid - remainderx
│ │ +    if remaindery < canvas_grid/2: remaindery = 0 - remaindery
│ │ +    else: remaindery = canvas_grid - remaindery
│ │      return(remainderx,remaindery)
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Right Button Click - Bring Up Context specific Popup menu
│ │  # The event will only be bound to the canvas in "Edit" Mode
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ @@ -465,42 +471,39 @@
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  def left_button_release(event):
│ │      global schematic_state
│ │      if schematic_state["moveobjects"]:
│ │          # Finish the move by snapping all objects to the grid - we only need to work
│ │          # out the xdiff and xdiff for one of the selected objects to get the diff
│ │ -        obj = schematic_state["selectedobjects"][0]
│ │          xdiff,ydiff = snap_to_grid(schematic_state["lastx"]- schematic_state["startx"],
│ │                                     schematic_state["lasty"]- schematic_state["starty"])
│ │          move_selected_objects(xdiff,ydiff)
│ │          # Calculate the total deltas for the move (from the startposition)
│ │          finalx = schematic_state["lastx"] - schematic_state["startx"] + xdiff
│ │          finaly = schematic_state["lasty"] - schematic_state["starty"] + ydiff
│ │          # Finalise the move by updating the current object position
│ │          objects.move_objects(schematic_state["selectedobjects"],
│ │                  xdiff1=finalx, ydiff1=finaly, xdiff2=finalx, ydiff2=finaly )
│ │          # Clear the "select object mode" - but leave all objects selected
│ │          schematic_state["moveobjects"] = False
│ │      elif schematic_state["editlineend1"]:
│ │          # Finish the move by snapping the line end to the grid
│ │ -        obj = schematic_state["selectedobjects"][0]
│ │          xdiff,ydiff = snap_to_grid(schematic_state["lastx"]- schematic_state["startx"],
│ │                                     schematic_state["lasty"]- schematic_state["starty"])
│ │          move_line_end(xdiff,ydiff)
│ │          # Calculate the total deltas for the move (from the startposition)
│ │          finalx = schematic_state["lastx"] - schematic_state["startx"] + xdiff
│ │          finaly = schematic_state["lasty"] - schematic_state["starty"] + ydiff
│ │          # Finalise the move by updating the current object position
│ │          objects.move_objects(schematic_state["selectedobjects"], xdiff1=finalx, ydiff1=finaly)
│ │          # Clear the "Edit line mode" - but leave the line selected
│ │          schematic_state["editlineend1"] = False
│ │      elif schematic_state["editlineend2"]:
│ │          # Finish the move by snapping the line end to the grid
│ │ -        obj = schematic_state["selectedobjects"][0]
│ │          xdiff,ydiff = snap_to_grid(schematic_state["lastx"]- schematic_state["startx"],
│ │                                     schematic_state["lasty"]- schematic_state["starty"])
│ │          move_line_end(xdiff,ydiff)
│ │          # Calculate the total deltas for the move (from the startposition)
│ │          finalx = schematic_state["lastx"] - schematic_state["startx"] + xdiff
│ │          finaly = schematic_state["lasty"] - schematic_state["starty"] + ydiff
│ │          # Finalise the move by updating the current object position
│ │ @@ -518,22 +521,44 @@
│ │          canvas.itemconfigure(schematic_state["selectareabox"],state="hidden")
│ │          schematic_state["selectarea"] = False
│ │      # Re-bind the canvas keypresses on completion of area selection or Move Objects
│ │      enable_all_keypress_events()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │ -# Externally called Function to resize the canvas (called from menubar module)
│ │ +# Externally called Function to resize the canvas (called from menubar module on load
│ │ +# of new schematic or re-size of canvas via menubar). Updates the global variables
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def resize_canvas():
│ │ -    width, height, canvas_grid = settings.get_canvas()
│ │ -    canvas.config (width=width, height=height, scrollregion=(0,0,width,height))
│ │ +def update_canvas(width:int, height:int, grid:int):
│ │ +    global canvas_width, canvas_height, canvas_grid
│ │ +    # Update the tkinter canvas object
│ │ +    canvas.config (width=width, height=height, scrollregion=(0,0,width, height))
│ │      canvas.pack()
│ │ +    # Set the global variables (used in the 'draw_grid' function)
│ │ +    canvas_width = width
│ │ +    canvas_height = height
│ │ +    canvas_grid = grid
│ │      draw_grid()
│ │ +    # Also update the objects module with the new settings
│ │ +    objects.update_canvas(width, height, grid)
│ │ +    return()
│ │ +
│ │ +#------------------------------------------------------------------------------------
│ │ +# Undo and re-do functions (to deselect all objects first)
│ │ +#------------------------------------------------------------------------------------
│ │ +
│ │ +def schematic_undo(event=None):
│ │ +    deselect_all_objects()
│ │ +    objects.undo()
│ │ +    return()
│ │ +
│ │ +def schematic_redo(event=None):
│ │ +    deselect_all_objects()
│ │ +    objects.redo()
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Internal Functions to enable/disable all canvas keypress events during an object
│ │  # move, line edit or area selection function (to ensure deterministic behavior)
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ @@ -554,23 +579,27 @@
│ │  
│ │  def enable_edit_keypress_events():
│ │      canvas.bind('<BackSpace>', delete_selected_objects)
│ │      canvas.bind('<Delete>', delete_selected_objects)
│ │      canvas.bind('<Escape>', deselect_all_objects)
│ │      canvas.bind('<Control-Key-c>', copy_selected_objects)
│ │      canvas.bind('<Control-Key-v>', paste_clipboard_objects)
│ │ +    canvas.bind('<Control-Key-z>', schematic_undo)
│ │ +    canvas.bind('<Control-Key-y>', schematic_redo)
│ │      canvas.bind('r', rotate_selected_objects)
│ │      return()
│ │  
│ │  def disable_edit_keypress_events():
│ │      canvas.unbind('<BackSpace>')
│ │      canvas.unbind('<Delete>')
│ │      canvas.unbind('<Escape>')
│ │      canvas.unbind('<Control-Key-c>')
│ │      canvas.unbind('<Control-Key-v>')
│ │ +    canvas.unbind('<Control-Key-z>')
│ │ +    canvas.unbind('<Control-Key-y>')
│ │      canvas.unbind('r')
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Externally called Functions to enable/disable schematic editing
│ │  # Either from the Menubar Mode selection or the 'm' key
│ │  #------------------------------------------------------------------------------------
│ │ @@ -621,16 +650,17 @@
│ │      canvas.bind('m', canvas_event_callback)
│ │      return()
│ │  
│ │  #------------------------------------------------------------------------------------
│ │  # Externally Called Initialisation function for the Canvas object
│ │  #------------------------------------------------------------------------------------
│ │  
│ │ -def create_canvas (root_window, event_callback):
│ │ +def initialise (root_window, event_callback, width:int, height:int, grid:int):
│ │      global root, canvas, popup1, popup2
│ │ +    global canvas_width, canvas_height, canvas_grid
│ │      global button_frame
│ │      global button_images
│ │      global canvas_event_callback
│ │      global logging
│ │      root = root_window
│ │      canvas_event_callback = event_callback
│ │      # Create a frame to hold the two subframes ("add" buttons and drawing canvas)
│ │ @@ -638,16 +668,16 @@
│ │      frame.pack (expand=True, fill=BOTH)    
│ │      # Create a subframe to hold the canvas and scrollbars
│ │      canvas_frame = Frame(frame, borderwidth=1)
│ │      canvas_frame.pack(side=RIGHT, expand=True, fill=BOTH)
│ │      # Create a subframe to hold the "add" buttons
│ │      button_frame = Frame(frame, borderwidth=1)
│ │      button_frame.pack(side=RIGHT, expand=True, fill=BOTH)
│ │ -    # Default values for the canvas
│ │ -    canvas_width, canvas_height, canvas_grid = settings.get_canvas()
│ │ +    # Save the Default values for the canvas as global variables
│ │ +    canvas_width, canvas_height, canvas_grid = width, height, grid
│ │      # Create the canvas and scrollbars inside the parentframe
│ │      # We also set focus on the canvas so the keypress events will take effect
│ │      canvas = Canvas(canvas_frame ,bg="grey85", scrollregion=(0, 0, canvas_width, canvas_height))
│ │      canvas.focus_set()
│ │      hbar = Scrollbar(canvas_frame, orient=HORIZONTAL)
│ │      hbar.pack(side=BOTTOM, fill=X)
│ │      hbar.config(command=canvas.xview)
│ │ @@ -712,15 +742,15 @@
│ │      button7 = Button (button_frame, image=button_images['right_hand_point'],
│ │                        command=lambda:objects.create_object(objects.object_type.point,
│ │                              points.point_type.RH.value))
│ │      button7.pack (padx=2, pady=2)
│ │      button8 = Button (button_frame, image=button_images['track_section'],
│ │                        command=lambda:objects.create_object(objects.object_type.section))
│ │      button8.pack (padx=2, pady=2)
│ │ -#     button9 = Button (button_frame, image=button_images['block_instrument'],
│ │ -#                       command=lambda:objects.create_object(objects.object_type.instrument))
│ │ -#     button9.pack (padx=2, pady=2)
│ │ -    # Initialise the Objects Module with the Canvas reference
│ │ -    objects.set_canvas(canvas)
│ │ +    button9 = Button (button_frame, image=button_images['block_instrument'],
│ │ +                      command=lambda:objects.create_object(objects.object_type.instrument))
│ │ +    button9.pack (padx=2, pady=2)
│ │ +    # Initialise the Objects package with the required parameters
│ │ +    objects.initialise(canvas, canvas_width, canvas_height, canvas_grid)
│ │      return()
│ │  
│ │  ####################################################################################
│ │   --- model-railway-signals-3.1.0/model_railway_signals/editor/settings.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/editor/settings.py
│ │┄ Files 0% similar despite different names
│ │ @@ -20,15 +20,15 @@
│ │  # These are the default settings
│ │  #------------------------------------------------------------------------------------
│ │  
│ │  default_settings = {}
│ │  default_settings["general"] = {}
│ │  default_settings["general"]["filename"] = "new_layout.sig"
│ │  default_settings["general"]["editmode"] = True
│ │ -default_settings["general"]["version"] = "Version 3.1.0"
│ │ +default_settings["general"]["version"] = "Version 3.2.0"
│ │  default_settings["canvas"] = {}
│ │  default_settings["canvas"]["width"] = 1000
│ │  default_settings["canvas"]["height"] = 500
│ │  default_settings["canvas"]["grid"] = 25
│ │  default_settings["logging"] = {}
│ │  default_settings["logging"]["level"] = 2   # Warning
│ │  default_settings["sprog"] = {}
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/block_instruments.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/block_instruments.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/common.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/common.py
│ │┄ Files 1% similar despite different names
│ │ @@ -109,15 +109,15 @@
│ │      except event_queue.Empty:
│ │          return()
│ │      callback()
│ │      return()
│ │      
│ │  def execute_function_in_tkinter_thread(callback_function):
│ │      global logging
│ │ -    callback = event_queue.put(callback_function)
│ │ +    event_queue.put(callback_function)
│ │      if root_window is not None:
│ │          root_window.event_generate("<<ExtCallback>>", when="tail")
│ │      else:
│ │          logging.error ("execute_function_in_tkinter_thread - cannot execute callback function as root window is undefined")
│ │      return()
│ │  
│ │  # -------------------------------------------------------------------------
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/dcc_control.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/dcc_control.py
│ │┄ Files 0% similar despite different names
│ │ @@ -245,15 +245,15 @@
│ │              addresses = addresses + theatre_state[1]
│ │          addresses_valid = True
│ │          for entry in addresses:
│ │              if entry[0] < 0 or entry[0] > 2047:
│ │                  logging.error ("Signal "+str(sig_id)+": Invalid DCC Address "+str(entry[0])+" - must be between 1 and 2047")
│ │                  addresses_valid = False
│ │          if (subsidary < 0 or subsidary > 2047):
│ │ -            logging.error ("Signal "+str(sig_id)+": Invalid DCC Address for subsidary"+str(address)+" - must be between 1 and 2047")
│ │ +            logging.error ("Signal "+str(sig_id)+": Invalid DCC Address for subsidary "+str(subsidary)+" - must be between 1 and 2047")
│ │              addresses_valid = False
│ │          if addresses_valid:
│ │              # Create the DCC Mapping entry for the signal
│ │              new_dcc_mapping = {
│ │                  "mapping_type" : mapping_type.COLOUR_LIGHT,                                        # Common to Colour_Light & Semaphore Mappings
│ │                  "auto_route_inhibit" : auto_route_inhibit,                                         # Common to Colour_Light & Semaphore Mappings
│ │                  "main_subsidary" :  subsidary,                                                     # Common to Colour_Light & Semaphore Mappings 
│ │ @@ -289,17 +289,17 @@
│ │      # Do some basic validation on the parameters we have been given
│ │      logging.info ("Signal "+str(sig_id)+": Creating DCC Address mapping for a Train Tech Signal")
│ │      if sig_mapped(sig_id):
│ │          logging.error ("Signal "+str(sig_id)+": Signal already has a DCC Address mapping")
│ │      elif sig_id < 1:
│ │          logging.error ("Signal "+str(sig_id)+": Signal ID for DCC Mapping must be greater than zero")
│ │      elif base_address < 0 or base_address > 2047:
│ │ -        logging.error ("Signal "+str(sig_id)+": Invalid DCC Address for signal"+str(address)+" - must be between 1 and 2047")
│ │ +        logging.error ("Signal "+str(sig_id)+": Invalid DCC Base Address for signal "+str(base_address)+" - must be between 1 and 2047")
│ │      elif route_address < 0 or route_address > 2047:
│ │ -        logging.error ("Signal "+str(sig_id)+": Invalid DCC Address for route indication "+str(address)+" - must be between 1 and 2047")
│ │ +        logging.error ("Signal "+str(sig_id)+": Invalid DCC Address for route indication "+str(route_address)+" - must be between 1 and 2047")
│ │      elif theatre_route != "NONE" and feather_route != signals_common.route_type.NONE:
│ │          logging.error ("Signal "+str(sig_id)+": Signal can only support Feather or Theatre - not both")
│ │      else:
│ │          # We only need to map the address for the feather OR the theatre (can't have both)
│ │          theatre_address = route_address
│ │          if feather_route is signals_common.route_type.NONE: route_address = 0
│ │          else: theatre_address = 0
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/file_interface.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/file_interface.py
│ │┄ Files 2% similar despite different names
│ │ @@ -343,17 +343,20 @@
│ │      dictionary_to_save["settings"] = settings
│ │      dictionary_to_save["objects"] = objects
│ │      filename_used_for_load = filename
│ │      save_as_option_enabled = save_as
│ │      save_state_and_quit(quit_application=False)
│ │      return(filename_used_for_save)
│ │  
│ │ -def load_schematic():
│ │ +def load_schematic(filename=None):
│ │      global layout_state
│ │ -    file_loaded = load_layout_state(file_name=None,load_file_dialog=True,ask_to_load_state=False)
│ │ +    if filename==None:
│ │ +        file_loaded = load_layout_state(file_name=None,load_file_dialog=True,ask_to_load_state=False)
│ │ +    else:
│ │ +        file_loaded = load_layout_state(file_name=filename,load_file_dialog=False,ask_to_load_state=False)
│ │      return(file_loaded, layout_state)    
│ │  
│ │  def purge_loaded_state_information():
│ │      global layout_state
│ │      layout_state ={}
│ │      return()
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/mqtt_interface.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/mqtt_interface.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/pi_sprog_interface.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/pi_sprog_interface.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/points.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/points.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-01.wav
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-01.wav
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-02.wav
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-02.wav
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-03.wav
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-03.wav
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/resources/bell-ring-04.wav
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/resources/bell-ring-04.wav
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/resources/telegraph-key-01.wav
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/resources/telegraph-key-01.wav
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals.py
│ │┄ Files 3% similar despite different names
│ │ @@ -30,24 +30,26 @@
│ │  #     Colour Light signals
│ │  #            - set_route_indication (Route Type and theatre text)
│ │  #            - update_signal (based on a signal Ahead) - not 2 Aspect Home or Red/Yellow
│ │  #            - toggle_signal / toggle_subsidary
│ │  #            - lock_subsidary / unlock_subsidary
│ │  #            - lock_signal / unlock_signal
│ │  #            - set_signal_override / clear_signal_override
│ │ +#            - set_signal_override_caution / clear_signal_override_caution (not Home)
│ │  #            - set_approach_control (Release on Red or Yellow) / clear_approach_control
│ │  #            - trigger_timed_signal
│ │  #            - query signal state (signal_clear, signal_state, subsidary_clear)
│ │  #     Semaphore signals:
│ │  #            - set_route_indication (Route Type and theatre text)
│ │  #            - update_signal (based on a signal Ahead) - (distant signals only)
│ │  #            - toggle_signal / toggle_subsidary
│ │  #            - lock_subsidary / unlock_subsidary
│ │  #            - lock_signal / unlock_signal
│ │  #            - set_signal_override / clear_signal_override
│ │ +#            - set_signal_override_caution / clear_signal_override_caution (not Home)
│ │  #            - set_approach_control (Release on Red only) / clear_approach_control
│ │  #            - trigger_timed_signal
│ │  #            - query signal state (signal_clear, signal_state, subsidary_clear)
│ │  #     Ground Position Colour Light signals:
│ │  #            - toggle_signal
│ │  #            - lock_signal / unlock_signal
│ │  #            - set_signal_override / clear_signal_override
│ │ @@ -241,18 +243,25 @@
│ │  #                       to the SWITCHED state if the signal is OVERRIDDEN or subject to APPROACH
│ │  #                       CONTROL. Use this function when you need to get the actual state (in terms
│ │  #                       of aspect) that the signal is displaying - returns 'signal_state_type'.
│ │  #                       - Note that for this function, the sig_id can be specified either as an 
│ │  #                       integer (representing the ID of a signal on the local schematic), or a 
│ │  #                       string (representing the identifier of an signal on an external MQTT node)
│ │  # 
│ │ -# set_signal_override (sig_id*:int) - Overrides the signal to DANGER (can specify multiple sig_ids)
│ │ +# set_signal_override (sig_id*:int) - Overrides the signal to display the most restrictive aspect
│ │ +#                       (Distant signals will display CAUTION - all other types will display DANGER)
│ │  # 
│ │ -# clear_signal_override (sig_id*:int) - Clears the siganl Override (can specify multiple sig_ids)
│ │ +# clear_signal_override (sig_id*:int) - Clears the signal Override (can specify multiple sig_ids)
│ │ +#
│ │ +# set_signal_override_caution (sig_id*:int) - Overrides the signal to display CAUTION
│ │ +#                       (Applicable to all main signal types apart from home signals)
│ │  # 
│ │ +# clear_signal_override_caution (sig_id*:int) - Clears the signal Override
│ │ +#                       (Applicable to all main signal types apart from home signals)
│ │ +#
│ │  # trigger_timed_signal - Sets the signal to DANGER and cycles through the aspects back to PROCEED.
│ │  #                       If start delay > 0 then a 'sig_passed' callback event is generated when
│ │  #                       the signal is changed to DANGER - For each subsequent aspect change 
│ │  #                       (back to PROCEED) a 'sig_updated' callback event will be generated.
│ │  #   Mandatory Parameters:
│ │  #       sig_id:int - The ID for the signal
│ │  #   Optional Parameters:
│ │ @@ -502,14 +511,66 @@
│ │          else:
│ │              # Clear the override and refresh the signal following the change in state
│ │              signals_common.clear_signal_override(sig_id)
│ │              signals_common.auto_refresh_signal(sig_id)
│ │      return() 
│ │  
│ │  # -------------------------------------------------------------------------
│ │ +# Externally called function to Override a signal to CAUTION. The signal will
│ │ +# display CAUTION irrespective of its current setting. Used to support automation
│ │ +# e.g. set a signal to CAUTION if any Home signals ahead are at DANGER.
│ │ +# Multiple signal IDs can be specified in the call
│ │ +# Function applicable to all signal types apart from HOME signals
│ │ +# Function does not support REMOTE Signals (with a compound Sig-ID)
│ │ +# -------------------------------------------------------------------------
│ │ +
│ │ +def set_signal_override_caution (*sig_ids:int):
│ │ +    global logging
│ │ +    for sig_id in sig_ids:
│ │ +        # Validate the signal exists
│ │ +        if not signals_common.sig_exists(sig_id):
│ │ +            logging.error ("Signal "+str(sig_id)+": set_signal_override_caution - Signal does not exist")
│ │ +        elif ( ( signals_common.signals[str(sig_id)]["sigtype"] == signals_common.sig_type.colour_light and
│ │ +                 signals_common.signals[str(sig_id)]["subtype"] != signals_colour_lights.signal_sub_type.home ) or
│ │ +               ( signals_common.signals[str(sig_id)]["sigtype"] == signals_common.sig_type.semaphore and
│ │ +                 signals_common.signals[str(sig_id)]["subtype"] != signals_semaphores.semaphore_sub_type.home ) ):
│ │ +            # Set the override and refresh the signal following the change in state
│ │ +            signals_common.set_signal_override_caution(sig_id)
│ │ +            signals_common.auto_refresh_signal(sig_id)
│ │ +        else:
│ │ +            logging.error("Signal "+str(sig_id)+": - set_signal_override_caution - Function not supported by signal type")
│ │ +        return()
│ │ +
│ │ +# -------------------------------------------------------------------------
│ │ +# Externally called function to Clear a Signal Override 
│ │ +# Signal will revert to its current manual setting (on/off) and aspect
│ │ +# Multiple signal IDs can be specified in the call
│ │ +# Function applicable to ALL signal types created on the local schematic
│ │ +# Function does not support REMOTE Signals (with a compound Sig-ID)
│ │ +# -------------------------------------------------------------------------
│ │ +
│ │ +def clear_signal_override_caution (*sig_ids:int):
│ │ +    global logging
│ │ +    for sig_id in sig_ids:
│ │ +        # Validate the signal exists
│ │ +        if not signals_common.sig_exists(sig_id):
│ │ +            logging.error ("Signal "+str(sig_id)+": clear_signal_override_caution - Signal does not exist")
│ │ +        elif ( ( signals_common.signals[str(sig_id)]["sigtype"] == signals_common.sig_type.colour_light and
│ │ +                 signals_common.signals[str(sig_id)]["subtype"] != signals_colour_lights.signal_sub_type.home ) or
│ │ +               ( signals_common.signals[str(sig_id)]["sigtype"] == signals_common.sig_type.semaphore and
│ │ +                 signals_common.signals[str(sig_id)]["subtype"] != signals_semaphores.semaphore_sub_type.home ) ):
│ │ +            # Set the override and refresh the signal following the change in state
│ │ +            signals_common.clear_signal_override_caution(sig_id)
│ │ +            signals_common.auto_refresh_signal(sig_id)
│ │ +        else:
│ │ +            logging.error("Signal "+str(sig_id)+": - clear_signal_override_caution - Function not supported by signal type")
│ │ +        return()
│ │ +    return()
│ │ +
│ │ +# -------------------------------------------------------------------------
│ │  # Externally called function to Toggle the state of a main signal
│ │  # to enable automated route setting from the external programme.
│ │  # Use in conjunction with 'signal_clear' to find the state first
│ │  # Function applicable to ALL signal types created on the local schematic
│ │  # Function does not support REMOTE Signals (with a compound Sig-ID)
│ │  # -------------------------------------------------------------------------
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals_colour_lights.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals_colour_lights.py
│ │┄ Files 0% similar despite different names
│ │ @@ -270,14 +270,21 @@
│ │              log_message = " (signal is ON)"
│ │  
│ │      # If signal is Overriden the set the signal to its overriden aspect
│ │      elif signals_common.signals[str(sig_id)]["override"]:
│ │          new_aspect = signals_common.signals[str(sig_id)]["overriddenaspect"]
│ │          log_message = " (signal is OVERRIDEN)"
│ │  
│ │ +    # If signal is Overriden to CAUTION set the signal to display CAUTION
│ │ +    # Note we are relying on the public API function to only allow this to
│ │ +    # be set for signal types apart from 2 aspect home signals
│ │ +    elif signals_common.signals[str(sig_id)]["overcaution"]:
│ │ +        new_aspect = signals_common.signal_state_type.CAUTION
│ │ +        log_message = " (signal is OVERRIDDEN to CAUTION)"
│ │ +
│ │      # If signal is triggered on a timed sequence then set to the sequence aspect
│ │      elif signals_common.signals[str(sig_id)]["timedsequence"][route.value].sequence_in_progress:
│ │          new_aspect = signals_common.signals[str(sig_id)]["timedsequence"][route.value].aspect
│ │          log_message = " (signal is on a timed sequence)"
│ │  
│ │      # Set to DANGER if the signal is subject to "Release on Red" approach control
│ │      # Note that this state should never apply to 2 aspect distant signals
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals_common.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals_common.py
│ │┄ Files 0% similar despite different names
│ │ @@ -262,38 +262,64 @@
│ │  # -------------------------------------------------------------------------
│ │  # Common Function to set a signal override
│ │  # -------------------------------------------------------------------------
│ │  
│ │  def set_signal_override (sig_id:int):
│ │      global logging
│ │      global signals
│ │ -    # Only set the override if signal is not already overridden
│ │ +    # Only set the override if the signal is not already overridden
│ │      if not signals[str(sig_id)]["override"]:
│ │          logging.info ("Signal "+str(sig_id)+": Setting override")
│ │          # Set the override state and change the button text to indicate override
│ │          signals[str(sig_id)]["override"] = True
│ │          signals[str(sig_id)]["sigbutton"].config(fg="red", disabledforeground="red")
│ │      return()
│ │  
│ │  # -------------------------------------------------------------------------
│ │  # Common Function to clear a signal override
│ │  # -------------------------------------------------------------------------
│ │  
│ │  def clear_signal_override (sig_id:int):
│ │      global logging
│ │      global signals
│ │ -    # Only set the override if signal is not already overridden
│ │ +    # Only clear the override if the signal is already overridden
│ │      if signals[str(sig_id)]["override"]:
│ │          logging.info ("Signal "+str(sig_id)+": Clearing override")
│ │          # Clear the override and change the button colour
│ │          signals[str(sig_id)]["override"] = False
│ │          signals[str(sig_id)]["sigbutton"].config(fg="black",disabledforeground="grey50")
│ │      return()
│ │  
│ │  # -------------------------------------------------------------------------
│ │ +# Common Function to set a signal override
│ │ +# -------------------------------------------------------------------------
│ │ +
│ │ +def set_signal_override_caution (sig_id:int):
│ │ +    global logging
│ │ +    global signals
│ │ +    # Only set the override if the signal is not already overridden
│ │ +    if not signals[str(sig_id)]["overcaution"]:
│ │ +        logging.info ("Signal "+str(sig_id)+": Setting override CAUTION")
│ │ +        signals[str(sig_id)]["overcaution"] = True
│ │ +    return()
│ │ +
│ │ +# -------------------------------------------------------------------------
│ │ +# Common Function to clear a signal override
│ │ +# -------------------------------------------------------------------------
│ │ +
│ │ +def clear_signal_override_caution (sig_id:int):
│ │ +    global logging
│ │ +    global signals
│ │ +    # Only clear the override if the signal is already overridden
│ │ +    if signals[str(sig_id)]["overcaution"]:
│ │ +        logging.info ("Signal "+str(sig_id)+": Clearing override CAUTION")
│ │ +        signals[str(sig_id)]["overcaution"] = False
│ │ +    return()
│ │ +
│ │ +# -------------------------------------------------------------------------
│ │  # Common Function to lock a signal (i.e. for point/signal interlocking)
│ │  # -------------------------------------------------------------------------
│ │  
│ │  def lock_signal (sig_id:int):
│ │      global logging
│ │      global signals
│ │      # Only lock if it is currently unlocked
│ │ @@ -427,15 +453,16 @@
│ │      signals[str(sig_id)] = {}
│ │      signals[str(sig_id)]["canvas"]       = canvas               # MANDATORY - canvas object
│ │      signals[str(sig_id)]["sigtype"]      = signal_type          # MANDATORY - Type of the signal
│ │      signals[str(sig_id)]["automatic"]    = automatic            # MANDATORY - True = signal is fully automatic 
│ │      signals[str(sig_id)]["extcallback"]  = ext_callback         # MANDATORY - The External Callback to use for the signal
│ │      signals[str(sig_id)]["routeset"]     = route_type.MAIN      # MANDATORY - Route setting for signal (MAIN at creation)
│ │      signals[str(sig_id)]["sigclear"]     = False                # MANDATORY - State of the main signal control (ON/OFF)
│ │ -    signals[str(sig_id)]["override"]     = False                # MANDATORY - Signal is "Overridden" (overrides main signal control)
│ │ +    signals[str(sig_id)]["override"]     = False                # MANDATORY - Signal is "Overridden" to most restrictive aspect
│ │ +    signals[str(sig_id)]["overcaution"]  = False                # MANDATORY - Signal is "Overridden" to CAUTION
│ │      signals[str(sig_id)]["sigstate"]     = None                 # MANDATORY - Displayed 'aspect' of the signal (None on creation)
│ │      signals[str(sig_id)]["hassubsidary"] = subsidary            # MANDATORY - Whether the signal has a subsidary aspect or arms
│ │      signals[str(sig_id)]["subclear"]     = False                # MANDATORY - State of the subsidary sgnal control (ON/OFF - or None)
│ │      signals[str(sig_id)]["siglocked"]    = False                # MANDATORY - State of signal interlocking 
│ │      signals[str(sig_id)]["sublocked"]    = False                # MANDATORY - State of subsidary interlocking
│ │      signals[str(sig_id)]["sigbutton"]    = sig_button           # MANDATORY - Button Drawing object (main Signal)
│ │      signals[str(sig_id)]["subbutton"]    = sub_button           # MANDATORY - Button Drawing object (main Signal)
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals_ground_disc.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals_ground_disc.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals_ground_position.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals_ground_position.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/signals_semaphores.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/signals_semaphores.py
│ │┄ Files 0% similar despite different names
│ │ @@ -555,14 +555,17 @@
│ │      if signals_common.signals[str(sig_id)]["subtype"] == semaphore_sub_type.distant:
│ │          if not signals_common.signals[str(sig_id)]["sigclear"]:
│ │              new_aspect = signals_common.signal_state_type.CAUTION
│ │              log_message = " (CAUTION) - signal is ON"
│ │          elif signals_common.signals[str(sig_id)]["override"]:
│ │              new_aspect = signals_common.signal_state_type.CAUTION
│ │              log_message = " (CAUTION) - signal is OVERRIDDEN"
│ │ +        elif signals_common.signals[str(sig_id)]["overcaution"]:
│ │ +            new_aspect = signals_common.signal_state_type.CAUTION
│ │ +            log_message = " (CAUTION) - signal is OVERRIDDEN to CAUTION"
│ │          elif signals_common.signals[str(sig_id)]["timedsequence"][route.value].sequence_in_progress:
│ │              new_aspect = signals_common.signal_state_type.CAUTION
│ │              log_message = " (CAUTION) - signal is on a timed sequence"
│ │          elif associated_signal > 0 and signals_common.signals[str(associated_signal)]["sigstate"] == signals_common.signal_state_type.DANGER:
│ │              new_aspect = signals_common.signal_state_type.CAUTION
│ │              log_message = (" (CAUTION) - signal is OFF but slotted with home signal "+str(associated_signal)+" at DANGER")
│ │          elif sig_ahead_id is not None and signals_common.signals[str(sig_ahead_id)]["sigstate"] == signals_common.signal_state_type.DANGER:
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/track_sections.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/track_sections.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals/library/track_sensors.py
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals/library/track_sensors.py
│ │┄ Files identical despite different names
│ │   --- model-railway-signals-3.1.0/model_railway_signals.egg-info/PKG-INFO
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals.egg-info/PKG-INFO
│ │┄ Files 2% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: model-railway-signals
│ │ -Version: 3.1.0
│ │ +Version: 3.2.0
│ │  Summary: Create your own DCC model railway signalling scheme
│ │  Home-page: https://github.com/johnrm174/model-railway-signalling
│ │  Author: johnrm174
│ │  Author-email: johnrm17418@gmail.com
│ │  License: GNU GENERAL PUBLIC LICENSE Version 2, June 1991
│ │  Description: # model-railway-signalling
│ │          
│ │ @@ -16,23 +16,23 @@
│ │          
│ │          ## Layout editor
│ │          
│ │          From Release 3.0.0, the schematic editor application enables automated and interlocked layout signalling 
│ │          schemes to be designed and configured without the need to write any code. Note that the editor is in
│ │          active development so any comments and suggestions for future features are welcome.
│ │          
│ │ -        What's supported in Release 3.1.0:
│ │ +        What's supported in Release 3.2.0:
│ │          * Draw your layout schematic with lines, points, signals and track occupancy sections
│ │ -        * Define the DCC acommand sequences to drive the signals and points out on the layout
│ │ +        * Define the DCC command sequences to drive the signals and points out on the layout
│ │          * Configure the signals and points to implement protototypical interlocking schemes
│ │          * Configure GPIO sensors and track sections to provide a 'mimic' display of the layout
│ │ +        * Automation of signals as trains traverse the routes that have been configured
│ │          * Save and load your layout schematic and state between running sessions
│ │          
│ │          What's coming soon:
│ │ -        * Undo/redo for layout editing functions
│ │          * Support for block section instruments
│ │          * MQTT networking (for linking layouts)
│ │          * Application documentation
│ │          
│ │          Any bug reports and feedback you may have would be gratefully appreciated - specifically:
│ │          * What aspects are intuitive? What aspects aren't?
│ │          * What aspects do you particularly like?
│ │ @@ -78,15 +78,19 @@
│ │          
│ │          ## Using the layout editor
│ │          
│ │          To run the editor application:
│ │          
│ │          The python package should be run as a module (note underscores):
│ │          <pre>
│ │ -        $ python3 -m model_railway_signals 
│ │ +        $ python3 -m model_railway_signals
│ │ +        </pre>
│ │ +        or to load a layout schematic at startup
│ │ +        <pre>
│ │ +        $ python3 -m model_railway_signals -f layout_file.sig
│ │          </pre>
│ │          
│ │          ## Using the library functions
│ │          
│ │          To use the public API functions for developing your own layout signalling system:
│ │          <pre>
│ │          from model_railway_signals import *
│ │   --- model-railway-signals-3.1.0/model_railway_signals.egg-info/SOURCES.txt
│ ├── +++ model-railway-signals-3.2.0/model_railway_signals.egg-info/SOURCES.txt
│ │┄ Files 2% similar despite different names
│ │ @@ -14,24 +14,25 @@
│ │  model_railway_signals/editor/configure_section.py
│ │  model_railway_signals/editor/configure_signal.py
│ │  model_railway_signals/editor/configure_signal_tab1.py
│ │  model_railway_signals/editor/configure_signal_tab2.py
│ │  model_railway_signals/editor/configure_signal_tab3.py
│ │  model_railway_signals/editor/editor.py
│ │  model_railway_signals/editor/menubar.py
│ │ -model_railway_signals/editor/objects.py
│ │ -model_railway_signals/editor/objects_common.py
│ │ -model_railway_signals/editor/objects_instruments.py
│ │ -model_railway_signals/editor/objects_lines.py
│ │ -model_railway_signals/editor/objects_points.py
│ │ -model_railway_signals/editor/objects_sections.py
│ │ -model_railway_signals/editor/objects_signals.py
│ │  model_railway_signals/editor/run_layout.py
│ │  model_railway_signals/editor/schematic.py
│ │  model_railway_signals/editor/settings.py
│ │ +model_railway_signals/editor/objects/__init__.py
│ │ +model_railway_signals/editor/objects/objects.py
│ │ +model_railway_signals/editor/objects/objects_common.py
│ │ +model_railway_signals/editor/objects/objects_instruments.py
│ │ +model_railway_signals/editor/objects/objects_lines.py
│ │ +model_railway_signals/editor/objects/objects_points.py
│ │ +model_railway_signals/editor/objects/objects_sections.py
│ │ +model_railway_signals/editor/objects/objects_signals.py
│ │  model_railway_signals/editor/resources/__init__.py
│ │  model_railway_signals/editor/resources/block_instrument.png
│ │  model_railway_signals/editor/resources/colour_light.png
│ │  model_railway_signals/editor/resources/ground_disc.png
│ │  model_railway_signals/editor/resources/ground_position.png
│ │  model_railway_signals/editor/resources/left_hand_point.png
│ │  model_railway_signals/editor/resources/line.png
│ │   --- model-railway-signals-3.1.0/setup.py
│ ├── +++ model-railway-signals-3.2.0/setup.py
│ │┄ Files 1% similar despite different names
│ │ @@ -7,15 +7,15 @@
│ │  
│ │  # The text of the README file
│ │  README = (HERE / "README.md").read_text()
│ │  
│ │  # This call to setup() does all the work
│ │  setup(
│ │      name="model-railway-signals",
│ │ -    version="3.1.0",
│ │ +    version="3.2.0",
│ │      packages=find_packages(),
│ │      include_package_data=True,
│ │      description="Create your own DCC model railway signalling scheme",
│ │      long_description=README,
│ │      long_description_content_type="text/markdown",
│ │      url="https://github.com/johnrm174/model-railway-signalling",
│ │      author="johnrm174",
