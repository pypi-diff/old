# Comparing `tmp/meraki-1.7.1.tar.gz` & `tmp/meraki-1.7.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "meraki-1.7.1.tar", last modified: Tue Mar 16 20:43:51 2021, max compression
+gzip compressed data, was "meraki-1.7.2.tar", last modified: Sat Apr  3 02:40:45 2021, max compression
```

## Comparing `meraki-1.7.1.tar` & `meraki-1.7.2.tar`

### file list

```diff
@@ -1,225 +1,225 @@
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.568565 meraki-1.7.1/
--rw-rw-rw-   0        0        0    12093 2021-03-16 20:43:51.566570 meraki-1.7.1/PKG-INFO
--rw-rw-rw-   0        0        0    10667 2021-02-22 22:54:32.000000 meraki-1.7.1/README.md
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:50.904342 meraki-1.7.1/meraki/
--rw-rw-rw-   0        0        0     8130 2021-03-16 20:41:54.000000 meraki-1.7.1/meraki/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.031999 meraki-1.7.1/meraki/aio/
--rw-rw-rw-   0        0        0     7411 2021-03-16 20:41:56.000000 meraki-1.7.1/meraki/aio/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.058927 meraki-1.7.1/meraki/aio/api/
--rw-rw-rw-   0        0        0        0 2021-03-16 20:41:57.000000 meraki-1.7.1/meraki/aio/api/__init__.py
--rw-rw-rw-   0        0        0    74232 2021-03-16 20:42:00.000000 meraki-1.7.1/meraki/aio/api/appliance.py
--rw-rw-rw-   0        0        0    20296 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/aio/api/camera.py
--rw-rw-rw-   0        0        0    10970 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/aio/api/cellularGateway.py
--rw-rw-rw-   0        0        0     7640 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/aio/api/devices.py
--rw-rw-rw-   0        0        0     4325 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/aio/api/insight.py
--rw-rw-rw-   0        0        0    75650 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/aio/api/networks.py
--rw-rw-rw-   0        0        0    70917 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/aio/api/organizations.py
--rw-rw-rw-   0        0        0    33794 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/aio/api/sm.py
--rw-rw-rw-   0        0        0    89282 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/aio/api/switch.py
--rw-rw-rw-   0        0        0    85358 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/aio/api/wireless.py
--rw-rw-rw-   0        0        0    20002 2021-03-16 20:41:56.000000 meraki-1.7.1/meraki/aio/rest_session.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.088847 meraki-1.7.1/meraki/api/
--rw-rw-rw-   0        0        0        0 2021-03-16 20:41:56.000000 meraki-1.7.1/meraki/api/__init__.py
--rw-rw-rw-   0        0        0    74250 2021-03-16 20:42:00.000000 meraki-1.7.1/meraki/api/appliance.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.116772 meraki-1.7.1/meraki/api/batch/
--rw-rw-rw-   0        0        0        0 2021-03-16 20:41:57.000000 meraki-1.7.1/meraki/api/batch/__init__.py
--rw-rw-rw-   0        0        0    21822 2021-03-16 20:42:00.000000 meraki-1.7.1/meraki/api/batch/appliance.py
--rw-rw-rw-   0        0        0     4644 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/api/batch/camera.py
--rw-rw-rw-   0        0        0     5788 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/batch/cellularGateway.py
--rw-rw-rw-   0        0        0     2553 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/batch/devices.py
--rw-rw-rw-   0        0        0     3266 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/api/batch/insight.py
--rw-rw-rw-   0        0        0    22699 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/batch/networks.py
--rw-rw-rw-   0        0        0    16412 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/batch/organizations.py
--rw-rw-rw-   0        0        0      728 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/batch/sm.py
--rw-rw-rw-   0        0        0    63644 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/batch/switch.py
--rw-rw-rw-   0        0        0    33286 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/api/batch/wireless.py
--rw-rw-rw-   0        0        0    20311 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/api/camera.py
--rw-rw-rw-   0        0        0    10994 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/cellularGateway.py
--rw-rw-rw-   0        0        0     7656 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/devices.py
--rw-rw-rw-   0        0        0     4341 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/insight.py
--rw-rw-rw-   0        0        0    75667 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/networks.py
--rw-rw-rw-   0        0        0    70939 2021-03-16 20:41:58.000000 meraki-1.7.1/meraki/api/organizations.py
--rw-rw-rw-   0        0        0    33805 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/sm.py
--rw-rw-rw-   0        0        0    89297 2021-03-16 20:42:01.000000 meraki-1.7.1/meraki/api/switch.py
--rw-rw-rw-   0        0        0    85375 2021-03-16 20:41:59.000000 meraki-1.7.1/meraki/api/wireless.py
--rw-rw-rw-   0        0        0     1820 2021-03-16 20:41:55.000000 meraki-1.7.1/meraki/config.py
--rw-rw-rw-   0        0        0     2774 2021-03-16 20:41:55.000000 meraki-1.7.1/meraki/exceptions.py
--rw-rw-rw-   0        0        0    19895 2021-03-16 20:41:55.000000 meraki-1.7.1/meraki/rest_session.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.028010 meraki-1.7.1/meraki.egg-info/
--rw-rw-rw-   0        0        0    12093 2021-03-16 20:43:50.000000 meraki-1.7.1/meraki.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     7017 2021-03-16 20:43:50.000000 meraki-1.7.1/meraki.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-03-16 20:43:50.000000 meraki-1.7.1/meraki.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       17 2021-03-16 20:43:50.000000 meraki-1.7.1/meraki.egg-info/requires.txt
--rw-rw-rw-   0        0        0       17 2021-03-16 20:43:50.000000 meraki-1.7.1/meraki.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.134725 meraki-1.7.1/meraki_v0/
--rw-rw-rw-   0        0        0    14303 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.140708 meraki-1.7.1/meraki_v0/aio/
--rw-rw-rw-   0        0        0    15427 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.338181 meraki-1.7.1/meraki_v0/aio/api/
--rw-rw-rw-   0        0        0        0 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/__init__.py
--rw-rw-rw-   0        0        0     4765 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/action_batches.py
--rw-rw-rw-   0        0        0     4717 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/admins.py
--rw-rw-rw-   0        0        0     1606 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/alert_settings.py
--rw-rw-rw-   0        0        0     4148 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/api_usage.py
--rw-rw-rw-   0        0        0     3517 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/bluetooth_clients.py
--rw-rw-rw-   0        0        0     4452 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/bluetooth_settings.py
--rw-rw-rw-   0        0        0     6902 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/camera_quality_retention_profiles.py
--rw-rw-rw-   0        0        0     7643 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/cameras.py
--rw-rw-rw-   0        0        0     2548 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/change_log.py
--rw-rw-rw-   0        0        0    16573 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/clients.py
--rw-rw-rw-   0        0        0     1335 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/config_templates.py
--rw-rw-rw-   0        0        0     1707 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/connectivity_monitoring_destinations.py
--rw-rw-rw-   0        0        0      745 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/content_filtering_categories.py
--rw-rw-rw-   0        0        0     2105 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/content_filtering_rules.py
--rw-rw-rw-   0        0        0     6963 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/dashboard_branding_policies.py
--rw-rw-rw-   0        0        0    12998 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/devices.py
--rw-rw-rw-   0        0        0     4156 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/events.py
--rw-rw-rw-   0        0        0     2893 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/firewalled_services.py
--rw-rw-rw-   0        0        0     6460 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/floor_plans.py
--rw-rw-rw-   0        0        0     6460 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/floorplans.py
--rw-rw-rw-   0        0        0     6062 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/group_policies.py
--rw-rw-rw-   0        0        0     5283 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/http_servers.py
--rw-rw-rw-   0        0        0     4060 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/intrusion_settings.py
--rw-rw-rw-   0        0        0     8566 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/licenses.py
--rw-rw-rw-   0        0        0     3493 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/link_aggregations.py
--rw-rw-rw-   0        0        0     2260 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/malware_settings.py
--rw-rw-rw-   0        0        0     1786 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/management_interface_settings.py
--rw-rw-rw-   0        0        0     1300 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/meraki_auth_users.py
--rw-rw-rw-   0        0        0     1909 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_connectivity_monitoring_destinations.py
--rw-rw-rw-   0        0        0     1946 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_dhcp_settings.py
--rw-rw-rw-   0        0        0     1593 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_lan_settings.py
--rw-rw-rw-   0        0        0     1666 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_port_forwarding_rules.py
--rw-rw-rw-   0        0        0     1805 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_subnet_pool_settings.py
--rw-rw-rw-   0        0        0     1598 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mg_uplink_settings.py
--rw-rw-rw-   0        0        0     4560 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/monitored_media_servers.py
--rw-rw-rw-   0        0        0     1837 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mr_l3_firewall.py
--rw-rw-rw-   0        0        0     5758 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mv_sense.py
--rw-rw-rw-   0        0        0     1438 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_1_1_nat_rules.py
--rw-rw-rw-   0        0        0     1464 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_1_many_nat_rules.py
--rw-rw-rw-   0        0        0     1543 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_cellular_firewall.py
--rw-rw-rw-   0        0        0     1842 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_inbound_firewall.py
--rw-rw-rw-   0        0        0     1635 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_l3_firewall.py
--rw-rw-rw-   0        0        0      819 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_l7_application_categories.py
--rw-rw-rw-   0        0        0     1445 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_l7_firewall.py
--rw-rw-rw-   0        0        0     1495 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_port_forwarding_rules.py
--rw-rw-rw-   0        0        0     4266 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_static_routes.py
--rw-rw-rw-   0        0        0     2995 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_vlan_ports.py
--rw-rw-rw-   0        0        0     1750 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_vpn_firewall.py
--rw-rw-rw-   0        0        0     2256 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/mx_warm_spare_settings.py
--rw-rw-rw-   0        0        0     4481 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/named_tag_scope.py
--rw-rw-rw-   0        0        0     1743 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/netflow_settings.py
--rw-rw-rw-   0        0        0    14074 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/networks.py
--rw-rw-rw-   0        0        0      706 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/openapi_spec.py
--rw-rw-rw-   0        0        0    10130 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/organizations.py
--rw-rw-rw-   0        0        0     8227 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/pii.py
--rw-rw-rw-   0        0        0     8183 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/radio_settings.py
--rw-rw-rw-   0        0        0     3990 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/saml_roles.py
--rw-rw-rw-   0        0        0     7266 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/security_events.py
--rw-rw-rw-   0        0        0    27144 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/sm.py
--rw-rw-rw-   0        0        0     4460 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/snmp_settings.py
--rw-rw-rw-   0        0        0     1504 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/splash_login_attempts.py
--rw-rw-rw-   0        0        0     2036 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/splash_settings.py
--rw-rw-rw-   0        0        0    11012 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/ssids.py
--rw-rw-rw-   0        0        0      688 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_access_policies.py
--rw-rw-rw-   0        0        0     1584 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_acls.py
--rw-rw-rw-   0        0        0     3558 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_port_schedules.py
--rw-rw-rw-   0        0        0     6831 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_ports.py
--rw-rw-rw-   0        0        0      842 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_profiles.py
--rw-rw-rw-   0        0        0    18967 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_settings.py
--rw-rw-rw-   0        0        0     4191 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/switch_stacks.py
--rw-rw-rw-   0        0        0     1410 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/syslog_servers.py
--rw-rw-rw-   0        0        0     2055 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/traffic_analysis_settings.py
--rw-rw-rw-   0        0        0     5232 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/traffic_shaping.py
--rw-rw-rw-   0        0        0     1526 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/uplink_settings.py
--rw-rw-rw-   0        0        0     7399 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/vlans.py
--rw-rw-rw-   0        0        0     2427 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/webhook_logs.py
--rw-rw-rw-   0        0        0    20528 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/wireless_health.py
--rw-rw-rw-   0        0        0     2442 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/api/wireless_settings.py
--rw-rw-rw-   0        0        0    12595 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/aio/rest_session.py
-drwxrwxrwx   0        0        0        0 2021-03-16 20:43:51.563578 meraki-1.7.1/meraki_v0/api/
--rw-rw-rw-   0        0        0        0 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/__init__.py
--rw-rw-rw-   0        0        0     4727 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/action_batches.py
--rw-rw-rw-   0        0        0     4684 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/admins.py
--rw-rw-rw-   0        0        0     1604 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/alert_settings.py
--rw-rw-rw-   0        0        0     4141 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/api_usage.py
--rw-rw-rw-   0        0        0     3518 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/bluetooth_clients.py
--rw-rw-rw-   0        0        0     4430 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/bluetooth_settings.py
--rw-rw-rw-   0        0        0     6881 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/camera_quality_retention_profiles.py
--rw-rw-rw-   0        0        0     7575 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/cameras.py
--rw-rw-rw-   0        0        0     2554 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/change_log.py
--rw-rw-rw-   0        0        0    16445 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/clients.py
--rw-rw-rw-   0        0        0     1335 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/config_templates.py
--rw-rw-rw-   0        0        0     1726 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/connectivity_monitoring_destinations.py
--rw-rw-rw-   0        0        0      768 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/content_filtering_categories.py
--rw-rw-rw-   0        0        0     2111 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/content_filtering_rules.py
--rw-rw-rw-   0        0        0     6913 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/dashboard_branding_policies.py
--rw-rw-rw-   0        0        0    12858 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/devices.py
--rw-rw-rw-   0        0        0     4147 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/events.py
--rw-rw-rw-   0        0        0     2884 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/firewalled_services.py
--rw-rw-rw-   0        0        0     6419 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/floor_plans.py
--rw-rw-rw-   0        0        0     6419 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/floorplans.py
--rw-rw-rw-   0        0        0     6024 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/group_policies.py
--rw-rw-rw-   0        0        0     5219 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/http_servers.py
--rw-rw-rw-   0        0        0     4038 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/intrusion_settings.py
--rw-rw-rw-   0        0        0     8499 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/licenses.py
--rw-rw-rw-   0        0        0     3470 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/link_aggregations.py
--rw-rw-rw-   0        0        0     2260 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/malware_settings.py
--rw-rw-rw-   0        0        0     1798 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/management_interface_settings.py
--rw-rw-rw-   0        0        0     1300 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/meraki_auth_users.py
--rw-rw-rw-   0        0        0     1930 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_connectivity_monitoring_destinations.py
--rw-rw-rw-   0        0        0     1945 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_dhcp_settings.py
--rw-rw-rw-   0        0        0     1591 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_lan_settings.py
--rw-rw-rw-   0        0        0     1672 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_port_forwarding_rules.py
--rw-rw-rw-   0        0        0     1810 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_subnet_pool_settings.py
--rw-rw-rw-   0        0        0     1599 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mg_uplink_settings.py
--rw-rw-rw-   0        0        0     4530 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/monitored_media_servers.py
--rw-rw-rw-   0        0        0     1834 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mr_l3_firewall.py
--rw-rw-rw-   0        0        0     5714 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mv_sense.py
--rw-rw-rw-   0        0        0     1435 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_1_1_nat_rules.py
--rw-rw-rw-   0        0        0     1464 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_1_many_nat_rules.py
--rw-rw-rw-   0        0        0     1546 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_cellular_firewall.py
--rw-rw-rw-   0        0        0     1844 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_inbound_firewall.py
--rw-rw-rw-   0        0        0     1632 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_l3_firewall.py
--rw-rw-rw-   0        0        0      841 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_l7_application_categories.py
--rw-rw-rw-   0        0        0     1442 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_l7_firewall.py
--rw-rw-rw-   0        0        0     1501 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_port_forwarding_rules.py
--rw-rw-rw-   0        0        0     4229 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_static_routes.py
--rw-rw-rw-   0        0        0     2979 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_vlan_ports.py
--rw-rw-rw-   0        0        0     1748 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_vpn_firewall.py
--rw-rw-rw-   0        0        0     2248 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/mx_warm_spare_settings.py
--rw-rw-rw-   0        0        0     4443 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/named_tag_scope.py
--rw-rw-rw-   0        0        0     1743 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/netflow_settings.py
--rw-rw-rw-   0        0        0    13935 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/networks.py
--rw-rw-rw-   0        0        0      714 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/openapi_spec.py
--rw-rw-rw-   0        0        0     9996 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/organizations.py
--rw-rw-rw-   0        0        0     8155 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/pii.py
--rw-rw-rw-   0        0        0     8121 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/radio_settings.py
--rw-rw-rw-   0        0        0     3948 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/saml_roles.py
--rw-rw-rw-   0        0        0     7253 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/security_events.py
--rw-rw-rw-   0        0        0    26831 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/sm.py
--rw-rw-rw-   0        0        0     4433 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/snmp_settings.py
--rw-rw-rw-   0        0        0     1520 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/splash_login_attempts.py
--rw-rw-rw-   0        0        0     2035 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/splash_settings.py
--rw-rw-rw-   0        0        0    10978 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/ssids.py
--rw-rw-rw-   0        0        0      705 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_access_policies.py
--rw-rw-rw-   0        0        0     1579 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_acls.py
--rw-rw-rw-   0        0        0     3538 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_port_schedules.py
--rw-rw-rw-   0        0        0     6791 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_ports.py
--rw-rw-rw-   0        0        0      853 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_profiles.py
--rw-rw-rw-   0        0        0    18738 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_settings.py
--rw-rw-rw-   0        0        0     4140 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/switch_stacks.py
--rw-rw-rw-   0        0        0     1408 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/syslog_servers.py
--rw-rw-rw-   0        0        0     2063 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/traffic_analysis_settings.py
--rw-rw-rw-   0        0        0     5183 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/traffic_shaping.py
--rw-rw-rw-   0        0        0     1525 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/uplink_settings.py
--rw-rw-rw-   0        0        0     7329 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/vlans.py
--rw-rw-rw-   0        0        0     2435 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/webhook_logs.py
--rw-rw-rw-   0        0        0    20419 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/wireless_health.py
--rw-rw-rw-   0        0        0     2443 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/api/wireless_settings.py
--rw-rw-rw-   0        0        0     1820 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/config.py
--rw-rw-rw-   0        0        0     5273 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/convert_to_aio.py
--rw-rw-rw-   0        0        0     2334 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/exceptions.py
--rw-rw-rw-   0        0        0   144517 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/legacy.py
--rw-rw-rw-   0        0        0    14415 2021-02-07 18:00:35.000000 meraki-1.7.1/meraki_v0/rest_session.py
--rw-rw-rw-   0        0        0       42 2021-03-16 20:43:51.568565 meraki-1.7.1/setup.cfg
--rw-rw-rw-   0        0        0     1495 2021-02-07 18:00:35.000000 meraki-1.7.1/setup.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.754290 meraki-1.7.2/
+-rw-rw-rw-   0        0        0    12093 2021-04-03 02:40:45.753292 meraki-1.7.2/PKG-INFO
+-rw-rw-rw-   0        0        0    10667 2021-02-22 22:54:32.000000 meraki-1.7.2/README.md
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.387268 meraki-1.7.2/meraki/
+-rw-rw-rw-   0        0        0     6793 2021-04-03 02:32:10.000000 meraki-1.7.2/meraki/__init__.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.398239 meraki-1.7.2/meraki/aio/
+-rw-rw-rw-   0        0        0     7442 2021-04-03 02:32:11.000000 meraki-1.7.2/meraki/aio/__init__.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.418187 meraki-1.7.2/meraki/aio/api/
+-rw-rw-rw-   0        0        0        0 2021-04-03 02:32:12.000000 meraki-1.7.2/meraki/aio/api/__init__.py
+-rw-rw-rw-   0        0        0    81169 2021-04-03 02:32:15.000000 meraki-1.7.2/meraki/aio/api/appliance.py
+-rw-rw-rw-   0        0        0    22140 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/aio/api/camera.py
+-rw-rw-rw-   0        0        0    12083 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/aio/api/cellularGateway.py
+-rw-rw-rw-   0        0        0     8460 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/aio/api/devices.py
+-rw-rw-rw-   0        0        0     4753 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/aio/api/insight.py
+-rw-rw-rw-   0        0        0    84191 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/aio/api/networks.py
+-rw-rw-rw-   0        0        0    77187 2021-04-03 02:32:12.000000 meraki-1.7.2/meraki/aio/api/organizations.py
+-rw-rw-rw-   0        0        0    37081 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/aio/api/sm.py
+-rw-rw-rw-   0        0        0    97544 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/aio/api/switch.py
+-rw-rw-rw-   0        0        0    95453 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/aio/api/wireless.py
+-rw-rw-rw-   0        0        0    19736 2021-04-03 02:32:11.000000 meraki-1.7.2/meraki/aio/rest_session.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.439129 meraki-1.7.2/meraki/api/
+-rw-rw-rw-   0        0        0        0 2021-04-03 02:32:11.000000 meraki-1.7.2/meraki/api/__init__.py
+-rw-rw-rw-   0        0        0    81187 2021-04-03 02:32:15.000000 meraki-1.7.2/meraki/api/appliance.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.458079 meraki-1.7.2/meraki/api/batch/
+-rw-rw-rw-   0        0        0     1018 2021-04-03 02:32:12.000000 meraki-1.7.2/meraki/api/batch/__init__.py
+-rw-rw-rw-   0        0        0    24139 2021-04-03 02:32:15.000000 meraki-1.7.2/meraki/api/batch/appliance.py
+-rw-rw-rw-   0        0        0     5102 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/api/batch/camera.py
+-rw-rw-rw-   0        0        0     6503 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/batch/cellularGateway.py
+-rw-rw-rw-   0        0        0     2841 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/batch/devices.py
+-rw-rw-rw-   0        0        0     3633 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/batch/insight.py
+-rw-rw-rw-   0        0        0    26823 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/batch/networks.py
+-rw-rw-rw-   0        0        0    18044 2021-04-03 02:32:12.000000 meraki-1.7.2/meraki/api/batch/organizations.py
+-rw-rw-rw-   0        0        0      844 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/batch/sm.py
+-rw-rw-rw-   0        0        0    69591 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/batch/switch.py
+-rw-rw-rw-   0        0        0    38246 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/api/batch/wireless.py
+-rw-rw-rw-   0        0        0    22155 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/api/camera.py
+-rw-rw-rw-   0        0        0    12107 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/cellularGateway.py
+-rw-rw-rw-   0        0        0     8476 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/devices.py
+-rw-rw-rw-   0        0        0     4769 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/insight.py
+-rw-rw-rw-   0        0        0    84208 2021-04-03 02:32:13.000000 meraki-1.7.2/meraki/api/networks.py
+-rw-rw-rw-   0        0        0    77209 2021-04-03 02:32:12.000000 meraki-1.7.2/meraki/api/organizations.py
+-rw-rw-rw-   0        0        0    37092 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/sm.py
+-rw-rw-rw-   0        0        0    97559 2021-04-03 02:32:16.000000 meraki-1.7.2/meraki/api/switch.py
+-rw-rw-rw-   0        0        0    95470 2021-04-03 02:32:14.000000 meraki-1.7.2/meraki/api/wireless.py
+-rw-rw-rw-   0        0        0     1759 2021-04-03 02:32:10.000000 meraki-1.7.2/meraki/config.py
+-rw-rw-rw-   0        0        0     2698 2021-04-03 02:32:11.000000 meraki-1.7.2/meraki/exceptions.py
+-rw-rw-rw-   0        0        0    19373 2021-04-03 02:32:11.000000 meraki-1.7.2/meraki/rest_session.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.395247 meraki-1.7.2/meraki.egg-info/
+-rw-rw-rw-   0        0        0    12093 2021-04-03 02:40:45.000000 meraki-1.7.2/meraki.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     7017 2021-04-03 02:40:45.000000 meraki-1.7.2/meraki.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2021-04-03 02:40:45.000000 meraki-1.7.2/meraki.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       17 2021-04-03 02:40:45.000000 meraki-1.7.2/meraki.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       17 2021-04-03 02:40:45.000000 meraki-1.7.2/meraki.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.469050 meraki-1.7.2/meraki_v0/
+-rw-rw-rw-   0        0        0    14303 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/__init__.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.472041 meraki-1.7.2/meraki_v0/aio/
+-rw-rw-rw-   0        0        0    15427 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/__init__.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.610672 meraki-1.7.2/meraki_v0/aio/api/
+-rw-rw-rw-   0        0        0        0 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/__init__.py
+-rw-rw-rw-   0        0        0     4765 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/action_batches.py
+-rw-rw-rw-   0        0        0     4717 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/admins.py
+-rw-rw-rw-   0        0        0     1606 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/alert_settings.py
+-rw-rw-rw-   0        0        0     4148 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/api_usage.py
+-rw-rw-rw-   0        0        0     3517 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/bluetooth_clients.py
+-rw-rw-rw-   0        0        0     4452 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/bluetooth_settings.py
+-rw-rw-rw-   0        0        0     6902 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/camera_quality_retention_profiles.py
+-rw-rw-rw-   0        0        0     7643 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/cameras.py
+-rw-rw-rw-   0        0        0     2548 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/change_log.py
+-rw-rw-rw-   0        0        0    16573 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/clients.py
+-rw-rw-rw-   0        0        0     1335 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/config_templates.py
+-rw-rw-rw-   0        0        0     1707 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/connectivity_monitoring_destinations.py
+-rw-rw-rw-   0        0        0      745 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/content_filtering_categories.py
+-rw-rw-rw-   0        0        0     2105 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/content_filtering_rules.py
+-rw-rw-rw-   0        0        0     6963 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/dashboard_branding_policies.py
+-rw-rw-rw-   0        0        0    12998 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/devices.py
+-rw-rw-rw-   0        0        0     4156 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/events.py
+-rw-rw-rw-   0        0        0     2893 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/firewalled_services.py
+-rw-rw-rw-   0        0        0     6460 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/floor_plans.py
+-rw-rw-rw-   0        0        0     6460 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/floorplans.py
+-rw-rw-rw-   0        0        0     6062 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/group_policies.py
+-rw-rw-rw-   0        0        0     5283 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/http_servers.py
+-rw-rw-rw-   0        0        0     4060 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/intrusion_settings.py
+-rw-rw-rw-   0        0        0     8566 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/licenses.py
+-rw-rw-rw-   0        0        0     3493 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/link_aggregations.py
+-rw-rw-rw-   0        0        0     2260 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/malware_settings.py
+-rw-rw-rw-   0        0        0     1786 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/management_interface_settings.py
+-rw-rw-rw-   0        0        0     1300 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/meraki_auth_users.py
+-rw-rw-rw-   0        0        0     1909 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_connectivity_monitoring_destinations.py
+-rw-rw-rw-   0        0        0     1946 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_dhcp_settings.py
+-rw-rw-rw-   0        0        0     1593 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_lan_settings.py
+-rw-rw-rw-   0        0        0     1666 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_port_forwarding_rules.py
+-rw-rw-rw-   0        0        0     1805 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_subnet_pool_settings.py
+-rw-rw-rw-   0        0        0     1598 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mg_uplink_settings.py
+-rw-rw-rw-   0        0        0     4560 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/monitored_media_servers.py
+-rw-rw-rw-   0        0        0     1837 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mr_l3_firewall.py
+-rw-rw-rw-   0        0        0     5758 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mv_sense.py
+-rw-rw-rw-   0        0        0     1438 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_1_1_nat_rules.py
+-rw-rw-rw-   0        0        0     1464 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_1_many_nat_rules.py
+-rw-rw-rw-   0        0        0     1543 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_cellular_firewall.py
+-rw-rw-rw-   0        0        0     1842 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_inbound_firewall.py
+-rw-rw-rw-   0        0        0     1635 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_l3_firewall.py
+-rw-rw-rw-   0        0        0      819 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_l7_application_categories.py
+-rw-rw-rw-   0        0        0     1445 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_l7_firewall.py
+-rw-rw-rw-   0        0        0     1495 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_port_forwarding_rules.py
+-rw-rw-rw-   0        0        0     4266 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_static_routes.py
+-rw-rw-rw-   0        0        0     2995 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_vlan_ports.py
+-rw-rw-rw-   0        0        0     1750 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_vpn_firewall.py
+-rw-rw-rw-   0        0        0     2256 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/mx_warm_spare_settings.py
+-rw-rw-rw-   0        0        0     4481 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/named_tag_scope.py
+-rw-rw-rw-   0        0        0     1743 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/netflow_settings.py
+-rw-rw-rw-   0        0        0    14074 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/networks.py
+-rw-rw-rw-   0        0        0      706 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/openapi_spec.py
+-rw-rw-rw-   0        0        0    10130 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/organizations.py
+-rw-rw-rw-   0        0        0     8227 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/pii.py
+-rw-rw-rw-   0        0        0     8183 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/radio_settings.py
+-rw-rw-rw-   0        0        0     3990 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/saml_roles.py
+-rw-rw-rw-   0        0        0     7266 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/security_events.py
+-rw-rw-rw-   0        0        0    27144 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/sm.py
+-rw-rw-rw-   0        0        0     4460 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/snmp_settings.py
+-rw-rw-rw-   0        0        0     1504 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/splash_login_attempts.py
+-rw-rw-rw-   0        0        0     2036 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/splash_settings.py
+-rw-rw-rw-   0        0        0    11012 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/ssids.py
+-rw-rw-rw-   0        0        0      688 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_access_policies.py
+-rw-rw-rw-   0        0        0     1584 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_acls.py
+-rw-rw-rw-   0        0        0     3558 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_port_schedules.py
+-rw-rw-rw-   0        0        0     6831 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_ports.py
+-rw-rw-rw-   0        0        0      842 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_profiles.py
+-rw-rw-rw-   0        0        0    18967 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_settings.py
+-rw-rw-rw-   0        0        0     4191 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/switch_stacks.py
+-rw-rw-rw-   0        0        0     1410 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/syslog_servers.py
+-rw-rw-rw-   0        0        0     2055 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/traffic_analysis_settings.py
+-rw-rw-rw-   0        0        0     5232 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/traffic_shaping.py
+-rw-rw-rw-   0        0        0     1526 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/uplink_settings.py
+-rw-rw-rw-   0        0        0     7399 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/vlans.py
+-rw-rw-rw-   0        0        0     2427 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/webhook_logs.py
+-rw-rw-rw-   0        0        0    20528 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/wireless_health.py
+-rw-rw-rw-   0        0        0     2442 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/api/wireless_settings.py
+-rw-rw-rw-   0        0        0    12595 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/aio/rest_session.py
+drwxrwxrwx   0        0        0        0 2021-04-03 02:40:45.751297 meraki-1.7.2/meraki_v0/api/
+-rw-rw-rw-   0        0        0        0 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/__init__.py
+-rw-rw-rw-   0        0        0     4727 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/action_batches.py
+-rw-rw-rw-   0        0        0     4684 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/admins.py
+-rw-rw-rw-   0        0        0     1604 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/alert_settings.py
+-rw-rw-rw-   0        0        0     4141 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/api_usage.py
+-rw-rw-rw-   0        0        0     3518 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/bluetooth_clients.py
+-rw-rw-rw-   0        0        0     4430 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/bluetooth_settings.py
+-rw-rw-rw-   0        0        0     6881 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/camera_quality_retention_profiles.py
+-rw-rw-rw-   0        0        0     7575 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/cameras.py
+-rw-rw-rw-   0        0        0     2554 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/change_log.py
+-rw-rw-rw-   0        0        0    16445 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/clients.py
+-rw-rw-rw-   0        0        0     1335 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/config_templates.py
+-rw-rw-rw-   0        0        0     1726 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/connectivity_monitoring_destinations.py
+-rw-rw-rw-   0        0        0      768 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/content_filtering_categories.py
+-rw-rw-rw-   0        0        0     2111 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/content_filtering_rules.py
+-rw-rw-rw-   0        0        0     6913 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/dashboard_branding_policies.py
+-rw-rw-rw-   0        0        0    12858 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/devices.py
+-rw-rw-rw-   0        0        0     4147 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/events.py
+-rw-rw-rw-   0        0        0     2884 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/firewalled_services.py
+-rw-rw-rw-   0        0        0     6419 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/floor_plans.py
+-rw-rw-rw-   0        0        0     6419 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/floorplans.py
+-rw-rw-rw-   0        0        0     6024 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/group_policies.py
+-rw-rw-rw-   0        0        0     5219 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/http_servers.py
+-rw-rw-rw-   0        0        0     4038 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/intrusion_settings.py
+-rw-rw-rw-   0        0        0     8499 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/licenses.py
+-rw-rw-rw-   0        0        0     3470 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/link_aggregations.py
+-rw-rw-rw-   0        0        0     2260 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/malware_settings.py
+-rw-rw-rw-   0        0        0     1798 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/management_interface_settings.py
+-rw-rw-rw-   0        0        0     1300 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/meraki_auth_users.py
+-rw-rw-rw-   0        0        0     1930 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_connectivity_monitoring_destinations.py
+-rw-rw-rw-   0        0        0     1945 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_dhcp_settings.py
+-rw-rw-rw-   0        0        0     1591 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_lan_settings.py
+-rw-rw-rw-   0        0        0     1672 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_port_forwarding_rules.py
+-rw-rw-rw-   0        0        0     1810 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_subnet_pool_settings.py
+-rw-rw-rw-   0        0        0     1599 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mg_uplink_settings.py
+-rw-rw-rw-   0        0        0     4530 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/monitored_media_servers.py
+-rw-rw-rw-   0        0        0     1834 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mr_l3_firewall.py
+-rw-rw-rw-   0        0        0     5714 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mv_sense.py
+-rw-rw-rw-   0        0        0     1435 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_1_1_nat_rules.py
+-rw-rw-rw-   0        0        0     1464 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_1_many_nat_rules.py
+-rw-rw-rw-   0        0        0     1546 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_cellular_firewall.py
+-rw-rw-rw-   0        0        0     1844 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_inbound_firewall.py
+-rw-rw-rw-   0        0        0     1632 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_l3_firewall.py
+-rw-rw-rw-   0        0        0      841 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_l7_application_categories.py
+-rw-rw-rw-   0        0        0     1442 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_l7_firewall.py
+-rw-rw-rw-   0        0        0     1501 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_port_forwarding_rules.py
+-rw-rw-rw-   0        0        0     4229 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_static_routes.py
+-rw-rw-rw-   0        0        0     2979 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_vlan_ports.py
+-rw-rw-rw-   0        0        0     1748 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_vpn_firewall.py
+-rw-rw-rw-   0        0        0     2248 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/mx_warm_spare_settings.py
+-rw-rw-rw-   0        0        0     4443 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/named_tag_scope.py
+-rw-rw-rw-   0        0        0     1743 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/netflow_settings.py
+-rw-rw-rw-   0        0        0    13935 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/networks.py
+-rw-rw-rw-   0        0        0      714 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/openapi_spec.py
+-rw-rw-rw-   0        0        0     9996 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/organizations.py
+-rw-rw-rw-   0        0        0     8155 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/pii.py
+-rw-rw-rw-   0        0        0     8121 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/radio_settings.py
+-rw-rw-rw-   0        0        0     3948 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/saml_roles.py
+-rw-rw-rw-   0        0        0     7253 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/security_events.py
+-rw-rw-rw-   0        0        0    26831 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/sm.py
+-rw-rw-rw-   0        0        0     4433 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/snmp_settings.py
+-rw-rw-rw-   0        0        0     1520 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/splash_login_attempts.py
+-rw-rw-rw-   0        0        0     2035 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/splash_settings.py
+-rw-rw-rw-   0        0        0    10978 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/ssids.py
+-rw-rw-rw-   0        0        0      705 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_access_policies.py
+-rw-rw-rw-   0        0        0     1579 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_acls.py
+-rw-rw-rw-   0        0        0     3538 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_port_schedules.py
+-rw-rw-rw-   0        0        0     6791 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_ports.py
+-rw-rw-rw-   0        0        0      853 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_profiles.py
+-rw-rw-rw-   0        0        0    18738 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_settings.py
+-rw-rw-rw-   0        0        0     4140 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/switch_stacks.py
+-rw-rw-rw-   0        0        0     1408 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/syslog_servers.py
+-rw-rw-rw-   0        0        0     2063 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/traffic_analysis_settings.py
+-rw-rw-rw-   0        0        0     5183 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/traffic_shaping.py
+-rw-rw-rw-   0        0        0     1525 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/uplink_settings.py
+-rw-rw-rw-   0        0        0     7329 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/vlans.py
+-rw-rw-rw-   0        0        0     2435 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/webhook_logs.py
+-rw-rw-rw-   0        0        0    20419 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/wireless_health.py
+-rw-rw-rw-   0        0        0     2443 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/api/wireless_settings.py
+-rw-rw-rw-   0        0        0     1820 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/config.py
+-rw-rw-rw-   0        0        0     5273 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/convert_to_aio.py
+-rw-rw-rw-   0        0        0     2334 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/exceptions.py
+-rw-rw-rw-   0        0        0   144517 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/legacy.py
+-rw-rw-rw-   0        0        0    14415 2021-02-07 18:00:35.000000 meraki-1.7.2/meraki_v0/rest_session.py
+-rw-rw-rw-   0        0        0       42 2021-04-03 02:40:45.754290 meraki-1.7.2/setup.cfg
+-rw-rw-rw-   0        0        0     1495 2021-02-07 18:00:35.000000 meraki-1.7.2/setup.py
```

### Comparing `meraki-1.7.1/PKG-INFO` & `meraki-1.7.2/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: meraki
-Version: 1.7.1
+Version: 1.7.2
 Summary: Cisco Meraki Dashboard API library
 Home-page: https://github.com/meraki/dashboard-api-python
 Author: Cisco Meraki
 Author-email: api-feedback@meraki.net
 License: MIT
 Description: # Meraki Dashboard API Python Library
```

### Comparing `meraki-1.7.1/README.md` & `meraki-1.7.2/README.md`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki/__init__.py` & `meraki-1.7.2/meraki/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,166 +1,140 @@
-from datetime import datetime
-import logging
-import os
-
-from .rest_session import *
-from .api.organizations import Organizations
-from .api.networks import Networks
-from .api.devices import Devices
-from .api.appliance import Appliance
-from .api.camera import Camera
-from .api.cellularGateway import CellularGateway
-from .api.insight import Insight
-from .api.sm import Sm
-from .api.switch import Switch
-from .api.wireless import Wireless
-
-# Batch class imports
-from .api.batch.organizations import ActionBatchOrganizations
-from .api.batch.networks import ActionBatchNetworks
-from .api.batch.devices import ActionBatchDevices
-from .api.batch.appliance import ActionBatchAppliance
-from .api.batch.camera import ActionBatchCamera
-from .api.batch.cellularGateway import ActionBatchCellularGateway
-from .api.batch.insight import ActionBatchInsight
-from .api.batch.sm import ActionBatchSm
-from .api.batch.switch import ActionBatchSwitch
-from .api.batch.wireless import ActionBatchWireless
-
-# Config import
-from .config import (
-    API_KEY_ENVIRONMENT_VARIABLE, DEFAULT_BASE_URL, SINGLE_REQUEST_TIMEOUT, CERTIFICATE_PATH, REQUESTS_PROXY,
-    WAIT_ON_RATE_LIMIT, NGINX_429_RETRY_WAIT_TIME, ACTION_BATCH_RETRY_WAIT_TIME, RETRY_4XX_ERROR,
-    RETRY_4XX_ERROR_WAIT_TIME, MAXIMUM_RETRIES, OUTPUT_LOG, LOG_PATH, LOG_FILE_PREFIX, PRINT_TO_CONSOLE,
-    SUPPRESS_LOGGING, SIMULATE_API_CALLS, BE_GEO_ID, MERAKI_PYTHON_SDK_CALLER
-)
-
-__version__ = '1.7.1'
-
-
-class DashboardAPI(object):
-    """
-    **Creates a persistent Meraki dashboard API session**
-
-    - api_key (string): API key generated in dashboard; can also be set as an environment variable MERAKI_DASHBOARD_API_KEY
-    - base_url (string): preceding all endpoint resources
-    - single_request_timeout (integer): maximum number of seconds for each API call
-    - certificate_path (string): path for TLS/SSL certificate verification if behind local proxy
-    - requests_proxy (string): proxy server and port, if needed, for HTTPS
-    - wait_on_rate_limit (boolean): retry if 429 rate limit error encountered?
-    - nginx_429_retry_wait_time (integer): Nginx 429 retry wait time
-    - action_batch_retry_wait_time (integer): action batch concurrency error retry wait time
-    - retry_4xx_error (boolean): retry if encountering other 4XX error (besides 429)?
-    - retry_4xx_error_wait_time (integer): other 4XX error retry wait time
-    - maximum_retries (integer): retry up to this many times when encountering 429s or other server-side errors
-    - output_log (boolean): create an output log file?
-    - log_path (string): path to output log; by default, working directory of script if not specified
-    - log_file_prefix (string): log file name appended with date and timestamp
-    - print_console (boolean): print logging output to console?
-    - suppress_logging (boolean): disable all logging? you're on your own then!
-    - simulate (boolean): simulate POST/PUT/DELETE calls to prevent changes?
-    - be_geo_id (string): optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
-    - caller (string): optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
-    - use_iterator_for_get_pages (boolean): list* methods will return an iterator with each object instead of a complete list with all items
-    """
-
-    def __init__(self, api_key=None, base_url=DEFAULT_BASE_URL, single_request_timeout=SINGLE_REQUEST_TIMEOUT,
-                 certificate_path=CERTIFICATE_PATH, requests_proxy=REQUESTS_PROXY,
-                 wait_on_rate_limit=WAIT_ON_RATE_LIMIT, nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
-                 action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME, retry_4xx_error=RETRY_4XX_ERROR,
-                 retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME, maximum_retries=MAXIMUM_RETRIES,
-                 output_log=OUTPUT_LOG, log_path=LOG_PATH, log_file_prefix=LOG_FILE_PREFIX,
-                 print_console=PRINT_TO_CONSOLE, suppress_logging=SUPPRESS_LOGGING, simulate=SIMULATE_API_CALLS,
-                 be_geo_id=BE_GEO_ID, caller=MERAKI_PYTHON_SDK_CALLER, use_iterator_for_get_pages=False):
-        # Check API key
-        api_key = api_key or os.environ.get(API_KEY_ENVIRONMENT_VARIABLE)
-        if not api_key:
-            raise APIKeyError()
-
-        # Pull the BE GEO ID from an environment variable if present
-        be_geo_id = be_geo_id or os.environ.get('BE_GEO_ID')
-
-        # Pull the caller from an environment variable if present
-        caller = caller or os.environ.get('MERAKI_PYTHON_SDK_CALLER')
-
-        # Configure logging
-        if not suppress_logging:
-            self._logger = logging.getLogger(__name__)
-            self._logger.setLevel(logging.DEBUG)
-
-            formatter = logging.Formatter(
-                fmt='%(asctime)s %(name)12s: %(levelname)8s > %(message)s',
-                datefmt='%Y-%m-%d %H:%M:%S'
-            )
-            handler_console = logging.StreamHandler()
-            handler_console.setFormatter(formatter)
-
-            if output_log:
-                if log_path and log_path[-1] != '/':
-                    log_path += '/'
-                self._log_file = f'{log_path}{log_file_prefix}_log__{datetime.now():%Y-%m-%d_%H-%M-%S}.log'
-                handler_log = logging.FileHandler(
-                    filename=self._log_file
-                )
-                handler_log.setFormatter(formatter)
-            
-            if output_log and not self._logger.hasHandlers():
-                self._logger.addHandler(handler_log)
-                if print_console:
-                    handler_console.setLevel(logging.INFO)
-                    self._logger.addHandler(handler_console)
-            elif print_console and not self._logger.hasHandlers():
-                self._logger.addHandler(handler_console)
-        else:
-            self._logger = None
-
-        # Creates the API session
-        self._session = RestSession(
-            logger=self._logger,
-            api_key=api_key,
-            base_url=base_url,
-            single_request_timeout=single_request_timeout,
-            certificate_path=certificate_path,
-            requests_proxy=requests_proxy,
-            wait_on_rate_limit=wait_on_rate_limit,
-            nginx_429_retry_wait_time=nginx_429_retry_wait_time,
-            action_batch_retry_wait_time=action_batch_retry_wait_time,
-            retry_4xx_error=retry_4xx_error,
-            retry_4xx_error_wait_time=retry_4xx_error_wait_time,
-            maximum_retries=maximum_retries,
-            simulate=simulate,
-            be_geo_id=be_geo_id,
-            caller=caller,
-            use_iterator_for_get_pages=use_iterator_for_get_pages,
-        )
-
-        # API endpoints by section
-        self.organizations = Organizations(self._session)
-        self.networks = Networks(self._session)
-        self.devices = Devices(self._session)
-        self.appliance = Appliance(self._session)
-        self.camera = Camera(self._session)
-        self.cellularGateway = CellularGateway(self._session)
-        self.insight = Insight(self._session)
-        self.sm = Sm(self._session)
-        self.switch = Switch(self._session)
-        self.wireless = Wireless(self._session)
-
-        # Batch class
-        class Batch:
-            def __init__(self):
-                pass
-
-        # Batch definitions
-        self.batch = Batch()
-
-        # Action Batch API endpoints by section
-        self.batch.organizations = ActionBatchOrganizations()
-        self.batch.networks = ActionBatchNetworks()
-        self.batch.devices = ActionBatchDevices()
-        self.batch.appliance = ActionBatchAppliance()
-        self.batch.camera = ActionBatchCamera()
-        self.batch.cellularGateway = ActionBatchCellularGateway()
-        self.batch.insight = ActionBatchInsight()
-        self.batch.sm = ActionBatchSm()
-        self.batch.switch = ActionBatchSwitch()
-        self.batch.wireless = ActionBatchWireless()
+from datetime import datetime
+import logging
+import os
+
+from .rest_session import *
+from .api.organizations import Organizations
+from .api.networks import Networks
+from .api.devices import Devices
+from .api.appliance import Appliance
+from .api.camera import Camera
+from .api.cellularGateway import CellularGateway
+from .api.insight import Insight
+from .api.sm import Sm
+from .api.switch import Switch
+from .api.wireless import Wireless
+
+# Batch class imports
+from .api.batch import Batch
+
+# Config import
+from .config import (
+    API_KEY_ENVIRONMENT_VARIABLE, DEFAULT_BASE_URL, SINGLE_REQUEST_TIMEOUT, CERTIFICATE_PATH, REQUESTS_PROXY,
+    WAIT_ON_RATE_LIMIT, NGINX_429_RETRY_WAIT_TIME, ACTION_BATCH_RETRY_WAIT_TIME, RETRY_4XX_ERROR,
+    RETRY_4XX_ERROR_WAIT_TIME, MAXIMUM_RETRIES, OUTPUT_LOG, LOG_PATH, LOG_FILE_PREFIX, PRINT_TO_CONSOLE,
+    SUPPRESS_LOGGING, SIMULATE_API_CALLS, BE_GEO_ID, MERAKI_PYTHON_SDK_CALLER
+)
+
+__version__ = '1.7.2'
+
+
+class DashboardAPI(object):
+    """
+    **Creates a persistent Meraki dashboard API session**
+
+    - api_key (string): API key generated in dashboard; can also be set as an environment variable MERAKI_DASHBOARD_API_KEY
+    - base_url (string): preceding all endpoint resources
+    - single_request_timeout (integer): maximum number of seconds for each API call
+    - certificate_path (string): path for TLS/SSL certificate verification if behind local proxy
+    - requests_proxy (string): proxy server and port, if needed, for HTTPS
+    - wait_on_rate_limit (boolean): retry if 429 rate limit error encountered?
+    - nginx_429_retry_wait_time (integer): Nginx 429 retry wait time
+    - action_batch_retry_wait_time (integer): action batch concurrency error retry wait time
+    - retry_4xx_error (boolean): retry if encountering other 4XX error (besides 429)?
+    - retry_4xx_error_wait_time (integer): other 4XX error retry wait time
+    - maximum_retries (integer): retry up to this many times when encountering 429s or other server-side errors
+    - output_log (boolean): create an output log file?
+    - log_path (string): path to output log; by default, working directory of script if not specified
+    - log_file_prefix (string): log file name appended with date and timestamp
+    - print_console (boolean): print logging output to console?
+    - suppress_logging (boolean): disable all logging? you're on your own then!
+    - simulate (boolean): simulate POST/PUT/DELETE calls to prevent changes?
+    - be_geo_id (string): optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
+    - caller (string): optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
+    - use_iterator_for_get_pages (boolean): list* methods will return an iterator with each object instead of a complete list with all items
+    """
+
+    def __init__(self, api_key=None, base_url=DEFAULT_BASE_URL, single_request_timeout=SINGLE_REQUEST_TIMEOUT,
+                 certificate_path=CERTIFICATE_PATH, requests_proxy=REQUESTS_PROXY,
+                 wait_on_rate_limit=WAIT_ON_RATE_LIMIT, nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
+                 action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME, retry_4xx_error=RETRY_4XX_ERROR,
+                 retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME, maximum_retries=MAXIMUM_RETRIES,
+                 output_log=OUTPUT_LOG, log_path=LOG_PATH, log_file_prefix=LOG_FILE_PREFIX,
+                 print_console=PRINT_TO_CONSOLE, suppress_logging=SUPPRESS_LOGGING, simulate=SIMULATE_API_CALLS,
+                 be_geo_id=BE_GEO_ID, caller=MERAKI_PYTHON_SDK_CALLER, use_iterator_for_get_pages=False):
+        # Check API key
+        api_key = api_key or os.environ.get(API_KEY_ENVIRONMENT_VARIABLE)
+        if not api_key:
+            raise APIKeyError()
+
+        # Pull the BE GEO ID from an environment variable if present
+        be_geo_id = be_geo_id or os.environ.get('BE_GEO_ID')
+
+        # Pull the caller from an environment variable if present
+        caller = caller or os.environ.get('MERAKI_PYTHON_SDK_CALLER')
+
+        # Configure logging
+        if not suppress_logging:
+            self._logger = logging.getLogger(__name__)
+            self._logger.setLevel(logging.DEBUG)
+
+            formatter = logging.Formatter(
+                fmt='%(asctime)s %(name)12s: %(levelname)8s > %(message)s',
+                datefmt='%Y-%m-%d %H:%M:%S'
+            )
+            handler_console = logging.StreamHandler()
+            handler_console.setFormatter(formatter)
+
+            if output_log:
+                if log_path and log_path[-1] != '/':
+                    log_path += '/'
+                self._log_file = f'{log_path}{log_file_prefix}_log__{datetime.now():%Y-%m-%d_%H-%M-%S}.log'
+                handler_log = logging.FileHandler(
+                    filename=self._log_file
+                )
+                handler_log.setFormatter(formatter)
+
+            if output_log and not self._logger.hasHandlers():
+                self._logger.addHandler(handler_log)
+                if print_console:
+                    handler_console.setLevel(logging.INFO)
+                    self._logger.addHandler(handler_console)
+            elif print_console and not self._logger.hasHandlers():
+                self._logger.addHandler(handler_console)
+        else:
+            self._logger = None
+
+        # Creates the API session
+        self._session = RestSession(
+            logger=self._logger,
+            api_key=api_key,
+            base_url=base_url,
+            single_request_timeout=single_request_timeout,
+            certificate_path=certificate_path,
+            requests_proxy=requests_proxy,
+            wait_on_rate_limit=wait_on_rate_limit,
+            nginx_429_retry_wait_time=nginx_429_retry_wait_time,
+            action_batch_retry_wait_time=action_batch_retry_wait_time,
+            retry_4xx_error=retry_4xx_error,
+            retry_4xx_error_wait_time=retry_4xx_error_wait_time,
+            maximum_retries=maximum_retries,
+            simulate=simulate,
+            be_geo_id=be_geo_id,
+            caller=caller,
+            use_iterator_for_get_pages=use_iterator_for_get_pages,
+        )
+
+        # API endpoints by section
+        self.organizations = Organizations(self._session)
+        self.networks = Networks(self._session)
+        self.devices = Devices(self._session)
+        self.appliance = Appliance(self._session)
+        self.camera = Camera(self._session)
+        self.cellularGateway = CellularGateway(self._session)
+        self.insight = Insight(self._session)
+        self.sm = Sm(self._session)
+        self.switch = Switch(self._session)
+        self.wireless = Wireless(self._session)
+
+        # Batch definitions
+        self.batch = Batch()
```

### Comparing `meraki-1.7.1/meraki/aio/__init__.py` & `meraki-1.7.2/meraki/aio/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,168 +1,174 @@
-import logging
-import os
-from datetime import datetime
-
-from ..config import (
-    ACTION_BATCH_RETRY_WAIT_TIME,
-    AIO_MAXIMUM_CONCURRENT_REQUESTS,
-    API_KEY_ENVIRONMENT_VARIABLE,
-    BE_GEO_ID,
-    CERTIFICATE_PATH,
-    DEFAULT_BASE_URL,
-    LOG_FILE_PREFIX,
-    LOG_PATH,
-    MAXIMUM_RETRIES,
-    MERAKI_PYTHON_SDK_CALLER,
-    NGINX_429_RETRY_WAIT_TIME,
-    OUTPUT_LOG,
-    PRINT_TO_CONSOLE,
-    REQUESTS_PROXY,
-    RETRY_4XX_ERROR,
-    RETRY_4XX_ERROR_WAIT_TIME,
-    SIMULATE_API_CALLS,
-    SINGLE_REQUEST_TIMEOUT,
-    SUPPRESS_LOGGING,
-    WAIT_ON_RATE_LIMIT,
-)
-from .api.appliance import AsyncAppliance
-from .api.camera import AsyncCamera
-from .api.cellularGateway import AsyncCellularGateway
-from .api.devices import AsyncDevices
-from .api.insight import AsyncInsight
-from .api.networks import AsyncNetworks
-from .api.organizations import AsyncOrganizations
-from .api.sm import AsyncSm
-from .api.switch import AsyncSwitch
-from .api.wireless import AsyncWireless
-from .rest_session import *
-
-
-class AsyncDashboardAPI:
-    """
-    **Creates a persistent Meraki dashboard API session**
-
-    - api_key (string): API key generated in dashboard; can also be set as an environment variable MERAKI_DASHBOARD_API_KEY
-    - base_url (string): preceding all endpoint resources
-    - single_request_timeout (integer): maximum number of seconds for each API call
-    - certificate_path (string): path for TLS/SSL certificate verification if behind local proxy
-    - requests_proxy (string): proxy server and port, if needed, for HTTPS
-    - wait_on_rate_limit (boolean): retry if 429 rate limit error encountered?
-    - nginx_429_retry_wait_time (integer): Nginx 429 retry wait time
-    - action_batch_retry_wait_time (integer): action batch concurrency error retry wait time
-    - retry_4xx_error (boolean): retry if encountering other 4XX error (besides 429)?
-    - retry_4xx_error_wait_time (integer): other 4XX error retry wait time
-    - maximum_retries (integer): retry up to this many times when encountering 429s or other server-side errors
-    - output_log (boolean): create an output log file?
-    - log_path (string): path to output log; by default, working directory of script if not specified
-    - log_file_prefix (string): log file name appended with date and timestamp
-    - print_console (boolean): print logging output to console?
-    - suppress_logging (boolean): disable all logging? you're on your own then!
-    - simulate (boolean): simulate POST/PUT/DELETE calls to prevent changes?
-    - maximum_concurrent_requests (integer): number of concurrent API requests for asynchronous class
-    - be_geo_id (string): optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
-    - caller (string): optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
-    - use_iterator_for_get_pages (boolean): list* methods will return an iterator with each object instead of a complete list with all items
-    """
-
-    def __init__(
-        self,
-        api_key=None,
-        base_url=DEFAULT_BASE_URL,
-        single_request_timeout=SINGLE_REQUEST_TIMEOUT,
-        certificate_path=CERTIFICATE_PATH,
-        requests_proxy=REQUESTS_PROXY,
-        wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
-        nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
-        action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
-        retry_4xx_error=RETRY_4XX_ERROR,
-        retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
-        maximum_retries=MAXIMUM_RETRIES,
-        output_log=OUTPUT_LOG,
-        log_path=LOG_PATH,
-        log_file_prefix=LOG_FILE_PREFIX,
-        print_console=PRINT_TO_CONSOLE,
-        suppress_logging=SUPPRESS_LOGGING,
-        simulate=SIMULATE_API_CALLS,
-        maximum_concurrent_requests=AIO_MAXIMUM_CONCURRENT_REQUESTS,
-        be_geo_id=BE_GEO_ID,
-        caller=MERAKI_PYTHON_SDK_CALLER,
-        use_iterator_for_get_pages=False,
-    ):
-        # Check API key
-        api_key = api_key or os.environ.get(API_KEY_ENVIRONMENT_VARIABLE)
-        if not api_key:
-            raise APIKeyError()
-
-        # Pull the BE GEO ID from an environment variable if present
-        be_geo_id = be_geo_id or os.environ.get("BE_GEO_ID")
-
-        # Pull the caller from an environment variable if present
-        caller = caller or os.environ.get("MERAKI_PYTHON_SDK_CALLER")
-
-        # Configure logging
-        if not suppress_logging:
-            self._logger = logging.getLogger(__name__)
-            self._logger.setLevel(logging.DEBUG)
-
-            formatter = logging.Formatter(
-                fmt="%(asctime)s %(name)12s: %(levelname)8s > %(message)s",
-                datefmt="%Y-%m-%d %H:%M:%S",
-            )
-            handler_console = logging.StreamHandler()
-            handler_console.setFormatter(formatter)
-
-            if output_log:
-                if log_path and log_path[-1] != "/":
-                    log_path += "/"
-                self._log_file = f"{log_path}{log_file_prefix}_log__{datetime.now():%Y-%m-%d_%H-%M-%S}.log"
-                handler_log = logging.FileHandler(filename=self._log_file)
-                handler_log.setFormatter(formatter)
-
-            if output_log and not self._logger.hasHandlers():
-                self._logger.addHandler(handler_log)
-                if print_console:
-                    handler_console.setLevel(logging.INFO)
-                    self._logger.addHandler(handler_console)
-            elif print_console and not self._logger.hasHandlers():
-                self._logger.addHandler(handler_console)
-        else:
-            self._logger = None
-
-        # Creates the API session
-        self._session = AsyncRestSession(
-            logger=self._logger,
-            api_key=api_key,
-            base_url=base_url,
-            single_request_timeout=single_request_timeout,
-            certificate_path=certificate_path,
-            requests_proxy=requests_proxy,
-            wait_on_rate_limit=wait_on_rate_limit,
-            nginx_429_retry_wait_time=nginx_429_retry_wait_time,
-            action_batch_retry_wait_time=action_batch_retry_wait_time,
-            retry_4xx_error=retry_4xx_error,
-            retry_4xx_error_wait_time=retry_4xx_error_wait_time,
-            maximum_retries=maximum_retries,
-            simulate=simulate,
-            maximum_concurrent_requests=maximum_concurrent_requests,
-            be_geo_id=be_geo_id,
-            caller=caller,
-            use_iterator_for_get_pages=use_iterator_for_get_pages,
-        )
-
-        # API endpoints by section
-        self.organizations = AsyncOrganizations(self._session)
-        self.networks = AsyncNetworks(self._session)
-        self.devices = AsyncDevices(self._session)
-        self.appliance = AsyncAppliance(self._session)
-        self.camera = AsyncCamera(self._session)
-        self.cellularGateway = AsyncCellularGateway(self._session)
-        self.insight = AsyncInsight(self._session)
-        self.switch = AsyncSwitch(self._session)
-        self.sm = AsyncSm(self._session)
-        self.wireless = AsyncWireless(self._session)
-
-    async def __aenter__(self):
-        return self
-
-    async def __aexit__(self, exc_type, exc, tb):
-        await self._session.close()
+import logging
+import os
+from datetime import datetime
+
+from ..config import (
+    ACTION_BATCH_RETRY_WAIT_TIME,
+    AIO_MAXIMUM_CONCURRENT_REQUESTS,
+    API_KEY_ENVIRONMENT_VARIABLE,
+    BE_GEO_ID,
+    CERTIFICATE_PATH,
+    DEFAULT_BASE_URL,
+    LOG_FILE_PREFIX,
+    LOG_PATH,
+    MAXIMUM_RETRIES,
+    MERAKI_PYTHON_SDK_CALLER,
+    NGINX_429_RETRY_WAIT_TIME,
+    OUTPUT_LOG,
+    PRINT_TO_CONSOLE,
+    REQUESTS_PROXY,
+    RETRY_4XX_ERROR,
+    RETRY_4XX_ERROR_WAIT_TIME,
+    SIMULATE_API_CALLS,
+    SINGLE_REQUEST_TIMEOUT,
+    SUPPRESS_LOGGING,
+    WAIT_ON_RATE_LIMIT,
+)
+from .api.appliance import AsyncAppliance
+from .api.camera import AsyncCamera
+from .api.cellularGateway import AsyncCellularGateway
+from .api.devices import AsyncDevices
+from .api.insight import AsyncInsight
+from .api.networks import AsyncNetworks
+from .api.organizations import AsyncOrganizations
+from .api.sm import AsyncSm
+from .api.switch import AsyncSwitch
+from .api.wireless import AsyncWireless
+from .rest_session import *
+
+# Batch class imports
+from ..api.batch import Batch
+
+
+class AsyncDashboardAPI:
+    """
+    **Creates a persistent Meraki dashboard API session**
+
+    - api_key (string): API key generated in dashboard; can also be set as an environment variable MERAKI_DASHBOARD_API_KEY
+    - base_url (string): preceding all endpoint resources
+    - single_request_timeout (integer): maximum number of seconds for each API call
+    - certificate_path (string): path for TLS/SSL certificate verification if behind local proxy
+    - requests_proxy (string): proxy server and port, if needed, for HTTPS
+    - wait_on_rate_limit (boolean): retry if 429 rate limit error encountered?
+    - nginx_429_retry_wait_time (integer): Nginx 429 retry wait time
+    - action_batch_retry_wait_time (integer): action batch concurrency error retry wait time
+    - retry_4xx_error (boolean): retry if encountering other 4XX error (besides 429)?
+    - retry_4xx_error_wait_time (integer): other 4XX error retry wait time
+    - maximum_retries (integer): retry up to this many times when encountering 429s or other server-side errors
+    - output_log (boolean): create an output log file?
+    - log_path (string): path to output log; by default, working directory of script if not specified
+    - log_file_prefix (string): log file name appended with date and timestamp
+    - print_console (boolean): print logging output to console?
+    - suppress_logging (boolean): disable all logging? you're on your own then!
+    - simulate (boolean): simulate POST/PUT/DELETE calls to prevent changes?
+    - maximum_concurrent_requests (integer): number of concurrent API requests for asynchronous class
+    - be_geo_id (string): optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
+    - caller (string): optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
+    - use_iterator_for_get_pages (boolean): list* methods will return an iterator with each object instead of a complete list with all items
+    """
+
+    def __init__(
+            self,
+            api_key=None,
+            base_url=DEFAULT_BASE_URL,
+            single_request_timeout=SINGLE_REQUEST_TIMEOUT,
+            certificate_path=CERTIFICATE_PATH,
+            requests_proxy=REQUESTS_PROXY,
+            wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
+            nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
+            action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
+            retry_4xx_error=RETRY_4XX_ERROR,
+            retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
+            maximum_retries=MAXIMUM_RETRIES,
+            output_log=OUTPUT_LOG,
+            log_path=LOG_PATH,
+            log_file_prefix=LOG_FILE_PREFIX,
+            print_console=PRINT_TO_CONSOLE,
+            suppress_logging=SUPPRESS_LOGGING,
+            simulate=SIMULATE_API_CALLS,
+            maximum_concurrent_requests=AIO_MAXIMUM_CONCURRENT_REQUESTS,
+            be_geo_id=BE_GEO_ID,
+            caller=MERAKI_PYTHON_SDK_CALLER,
+            use_iterator_for_get_pages=False,
+    ):
+        # Check API key
+        api_key = api_key or os.environ.get(API_KEY_ENVIRONMENT_VARIABLE)
+        if not api_key:
+            raise APIKeyError()
+
+        # Pull the BE GEO ID from an environment variable if present
+        be_geo_id = be_geo_id or os.environ.get("BE_GEO_ID")
+
+        # Pull the caller from an environment variable if present
+        caller = caller or os.environ.get("MERAKI_PYTHON_SDK_CALLER")
+
+        # Configure logging
+        if not suppress_logging:
+            self._logger = logging.getLogger(__name__)
+            self._logger.setLevel(logging.DEBUG)
+
+            formatter = logging.Formatter(
+                fmt="%(asctime)s %(name)12s: %(levelname)8s > %(message)s",
+                datefmt="%Y-%m-%d %H:%M:%S",
+            )
+            handler_console = logging.StreamHandler()
+            handler_console.setFormatter(formatter)
+
+            if output_log:
+                if log_path and log_path[-1] != "/":
+                    log_path += "/"
+                self._log_file = f"{log_path}{log_file_prefix}_log__{datetime.now():%Y-%m-%d_%H-%M-%S}.log"
+                handler_log = logging.FileHandler(filename=self._log_file)
+                handler_log.setFormatter(formatter)
+
+            if output_log and not self._logger.hasHandlers():
+                self._logger.addHandler(handler_log)
+                if print_console:
+                    handler_console.setLevel(logging.INFO)
+                    self._logger.addHandler(handler_console)
+            elif print_console and not self._logger.hasHandlers():
+                self._logger.addHandler(handler_console)
+        else:
+            self._logger = None
+
+        # Creates the API session
+        self._session = AsyncRestSession(
+            logger=self._logger,
+            api_key=api_key,
+            base_url=base_url,
+            single_request_timeout=single_request_timeout,
+            certificate_path=certificate_path,
+            requests_proxy=requests_proxy,
+            wait_on_rate_limit=wait_on_rate_limit,
+            nginx_429_retry_wait_time=nginx_429_retry_wait_time,
+            action_batch_retry_wait_time=action_batch_retry_wait_time,
+            retry_4xx_error=retry_4xx_error,
+            retry_4xx_error_wait_time=retry_4xx_error_wait_time,
+            maximum_retries=maximum_retries,
+            simulate=simulate,
+            maximum_concurrent_requests=maximum_concurrent_requests,
+            be_geo_id=be_geo_id,
+            caller=caller,
+            use_iterator_for_get_pages=use_iterator_for_get_pages,
+        )
+
+        # API endpoints by section
+        self.organizations = AsyncOrganizations(self._session)
+        self.networks = AsyncNetworks(self._session)
+        self.devices = AsyncDevices(self._session)
+        self.appliance = AsyncAppliance(self._session)
+        self.camera = AsyncCamera(self._session)
+        self.cellularGateway = AsyncCellularGateway(self._session)
+        self.insight = AsyncInsight(self._session)
+        self.switch = AsyncSwitch(self._session)
+        self.sm = AsyncSm(self._session)
+        self.wireless = AsyncWireless(self._session)
+
+        # Batch definitions
+        self.batch = Batch()
+
+    async def __aenter__(self):
+        return self
+
+    async def __aexit__(self, exc_type, exc, tb):
+        await self._session.close()
```

### Comparing `meraki-1.7.1/meraki/aio/api/appliance.py` & `meraki-1.7.2/meraki/aio/api/appliance.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,1677 +1,1836 @@
-class AsyncAppliance:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def getDeviceApplianceDhcpSubnets(self, serial: str):
-		"""
-		**Return the DHCP subnet information for an appliance**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-dhcp-subnets
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'dhcp', 'subnets'],
-			'operation': 'getDeviceApplianceDhcpSubnets'
-		}
-		resource = f'/devices/{serial}/appliance/dhcp/subnets'
-
-		return self._session.get(metadata, resource)
-
-	def getDeviceAppliancePerformance(self, serial: str):
-		"""
-		**Return the performance score for a single MX**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-performance
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'performance'],
-			'operation': 'getDeviceAppliancePerformance'
-		}
-		resource = f'/devices/{serial}/appliance/performance'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceClientSecurityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for a client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-client-security-events
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'clients', 'security', 'events'],
-			'operation': 'getNetworkApplianceClientSecurityEvents'
-		}
-		resource = f'/networks/{networkId}/appliance/clients/{clientId}/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str):
-		"""
-		**Return the connectivity testing destinations for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'getNetworkApplianceConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
-		"""
-		**Update the connectivity testing destinations for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		- destinations (array): The list of connectivity monitoring destinations
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
-
-		body_params = ['destinations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceContentFiltering(self, networkId: str):
-		"""
-		**Return the content filtering settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering'],
-			'operation': 'getNetworkApplianceContentFiltering'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceContentFiltering(self, networkId: str, **kwargs):
-		"""
-		**Update the content filtering settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-content-filtering
-		
-		- networkId (string): (required)
-		- allowedUrlPatterns (array): A list of URL patterns that are allowed
-		- blockedUrlPatterns (array): A list of URL patterns that are blocked
-		- blockedUrlCategories (array): A list of URL categories to block
-		- urlCategoryListSize (string): URL category list size which is either 'topSites' or 'fullList'
-		"""
-
-		kwargs.update(locals())
-
-		if 'urlCategoryListSize' in kwargs:
-			options = ['topSites', 'fullList']
-			assert kwargs['urlCategoryListSize'] in options, f'''"urlCategoryListSize" cannot be "{kwargs['urlCategoryListSize']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering'],
-			'operation': 'updateNetworkApplianceContentFiltering'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering'
-
-		body_params = ['allowedUrlPatterns', 'blockedUrlPatterns', 'blockedUrlCategories', 'urlCategoryListSize', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceContentFilteringCategories(self, networkId: str):
-		"""
-		**List all available content filtering categories for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering', 'categories'],
-			'operation': 'getNetworkApplianceContentFilteringCategories'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering/categories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallCellularFirewallRules(self, networkId: str):
-		"""
-		**Return the cellular firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-cellular-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
-			'operation': 'getNetworkApplianceFirewallCellularFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallCellularFirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the cellular firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-cellular-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallCellularFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallFirewalledServices(self, networkId: str):
-		"""
-		**List the appliance services and their accessibility rules**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-services
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'getNetworkApplianceFirewallFirewalledServices'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str):
-		"""
-		**Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-service
-		
-		- networkId (string): (required)
-		- service (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'getNetworkApplianceFirewallFirewalledService'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str, access: str, **kwargs):
-		"""
-		**Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-firewalled-service
-		
-		- networkId (string): (required)
-		- service (string): (required)
-		- access (string): A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
-		- allowedIps (array): An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored
-		"""
-
-		kwargs.update(locals())
-
-		if 'access' in kwargs:
-			options = ['blocked', 'restricted', 'unrestricted']
-			assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'updateNetworkApplianceFirewallFirewalledService'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
-
-		body_params = ['access', 'allowedIps', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallInboundFirewallRules(self, networkId: str):
-		"""
-		**Return the inbound firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-inbound-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
-			'operation': 'getNetworkApplianceFirewallInboundFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallInboundFirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the inbound firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-inbound-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallInboundFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL3FirewallRules(self, networkId: str):
-		"""
-		**Return the L3 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
-			'operation': 'getNetworkApplianceFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallL3FirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the L3 firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL7FirewallRules(self, networkId: str):
-		"""
-		**List the MX L7 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
-			'operation': 'getNetworkApplianceFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the MX L7 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the MX L7 firewall rules
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL7FirewallRulesApplicationCategories(self, networkId: str):
-		"""
-		**Return the L7 firewall application categories and their associated applications for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules-application-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules', 'applicationCategories'],
-			'operation': 'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallOneToManyNatRules(self, networkId: str):
-		"""
-		**Return the 1:Many NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-many-nat-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
-			'operation': 'getNetworkApplianceFirewallOneToManyNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallOneToManyNatRules(self, networkId: str, rules: list):
-		"""
-		**Set the 1:Many NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-many-nat-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of 1:Many nat rules
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
-			'operation': 'updateNetworkApplianceFirewallOneToManyNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallOneToOneNatRules(self, networkId: str):
-		"""
-		**Return the 1:1 NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-one-nat-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
-			'operation': 'getNetworkApplianceFirewallOneToOneNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallOneToOneNatRules(self, networkId: str, rules: list):
-		"""
-		**Set the 1:1 NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-one-nat-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of 1:1 nat rules
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
-			'operation': 'updateNetworkApplianceFirewallOneToOneNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallPortForwardingRules(self, networkId: str):
-		"""
-		**Return the port forwarding rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-port-forwarding-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
-			'operation': 'getNetworkApplianceFirewallPortForwardingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallPortForwardingRules(self, networkId: str, rules: list):
-		"""
-		**Update the port forwarding rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-port-forwarding-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of port forwarding params
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
-			'operation': 'updateNetworkApplianceFirewallPortForwardingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkAppliancePorts(self, networkId: str):
-		"""
-		**List per-port VLAN settings for all ports of a MX.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-ports
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'getNetworkAppliancePorts'
-		}
-		resource = f'/networks/{networkId}/appliance/ports'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkAppliancePort(self, networkId: str, portId: str):
-		"""
-		**Return per-port VLAN settings for a single MX port.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-port
-		
-		- networkId (string): (required)
-		- portId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'getNetworkAppliancePort'
-		}
-		resource = f'/networks/{networkId}/appliance/ports/{portId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
-		"""
-		**Update the per-port VLAN settings for a single MX port.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
-		
-		- networkId (string): (required)
-		- portId (string): (required)
-		- enabled (boolean): The status of the port
-		- dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
-		- type (string): The type of the port: 'access' or 'trunk'.
-		- vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
-		- allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
-		- accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'updateNetworkAppliancePort'
-		}
-		resource = f'/networks/{networkId}/appliance/ports/{portId}'
-
-		body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSecurityEvents(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-events
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'security', 'events'],
-			'operation': 'getNetworkApplianceSecurityEvents'
-		}
-		resource = f'/networks/{networkId}/appliance/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkApplianceSecurityIntrusion(self, networkId: str):
-		"""
-		**Returns all supported intrusion settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-intrusion
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'getNetworkApplianceSecurityIntrusion'
-		}
-		resource = f'/networks/{networkId}/appliance/security/intrusion'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSecurityIntrusion(self, networkId: str, **kwargs):
-		"""
-		**Set the supported intrusion settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-intrusion
-		
-		- networkId (string): (required)
-		- mode (string): Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
-		- idsRulesets (string): Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
-		- protectedNetworks (object): Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['prevention', 'detection', 'disabled']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-		if 'idsRulesets' in kwargs:
-			options = ['connectivity', 'balanced', 'security']
-			assert kwargs['idsRulesets'] in options, f'''"idsRulesets" cannot be "{kwargs['idsRulesets']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'updateNetworkApplianceSecurityIntrusion'
-		}
-		resource = f'/networks/{networkId}/appliance/security/intrusion'
-
-		body_params = ['mode', 'idsRulesets', 'protectedNetworks', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSecurityMalware(self, networkId: str):
-		"""
-		**Returns all supported malware settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-malware
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'malware'],
-			'operation': 'getNetworkApplianceSecurityMalware'
-		}
-		resource = f'/networks/{networkId}/appliance/security/malware'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSecurityMalware(self, networkId: str, mode: str, **kwargs):
-		"""
-		**Set the supported malware settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-malware
-		
-		- networkId (string): (required)
-		- mode (string): Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
-		- allowedUrls (array): The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
-		- allowedFiles (array): The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['enabled', 'disabled']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'malware'],
-			'operation': 'updateNetworkApplianceSecurityMalware'
-		}
-		resource = f'/networks/{networkId}/appliance/security/malware'
-
-		body_params = ['mode', 'allowedUrls', 'allowedFiles', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSettings(self, networkId: str):
-		"""
-		**Return the appliance settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'settings'],
-			'operation': 'getNetworkApplianceSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/settings'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceSingleLan(self, networkId: str):
-		"""
-		**Return single LAN configuration**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-single-lan
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'singleLan'],
-			'operation': 'getNetworkApplianceSingleLan'
-		}
-		resource = f'/networks/{networkId}/appliance/singleLan'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
-		"""
-		**Update single LAN configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
-		
-		- networkId (string): (required)
-		- subnet (string): The subnet of the single LAN configuration
-		- applianceIp (string): The appliance IP address of the single LAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'singleLan'],
-			'operation': 'updateNetworkApplianceSingleLan'
-		}
-		resource = f'/networks/{networkId}/appliance/singleLan'
-
-		body_params = ['subnet', 'applianceIp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceStaticRoutes(self, networkId: str):
-		"""
-		**List the static routes for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-routes
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'getNetworkApplianceStaticRoutes'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceStaticRoute(self, networkId: str, name: str, subnet: str, gatewayIp: str):
-		"""
-		**Add a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- name (string): The name of the new static route
-		- subnet (string): The subnet of the static route
-		- gatewayIp (string): The gateway IP (next hop) of the static route
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'createNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes'
-
-		body_params = ['name', 'subnet', 'gatewayIp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
-		"""
-		**Return a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'getNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str, **kwargs):
-		"""
-		**Update a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		- name (string): The name of the static route
-		- subnet (string): The subnet of the static route
-		- gatewayIp (string): The gateway IP (next hop) of the static route
-		- enabled (boolean): The enabled state of the static route
-		- fixedIpAssignments (object): The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
-		- reservedIpRanges (array): The DHCP reserved IP ranges on the static route
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'updateNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		body_params = ['name', 'subnet', 'gatewayIp', 'enabled', 'fixedIpAssignments', 'reservedIpRanges', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
-		"""
-		**Delete a static route from an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'deleteNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkApplianceTrafficShaping(self, networkId: str):
-		"""
-		**Display the traffic shaping settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping'],
-			'operation': 'getNetworkApplianceTrafficShaping'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShaping(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic shaping settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping
-		
-		- networkId (string): (required)
-		- globalBandwidthLimits (object): Global per-client bandwidth limit
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping'],
-			'operation': 'updateNetworkApplianceTrafficShaping'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping'
-
-		body_params = ['globalBandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingCustomPerformanceClasses(self, networkId: str):
-		"""
-		**List all custom performance classes for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-classes
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClasses'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
-		"""
-		**Add a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
-		"""
-		**Return a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
-		"""
-		**Update a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
-		"""
-		**Delete a custom performance class from an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		return self._session.delete(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic shaping settings rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
-		- rules (array):     An array of traffic shaping rules. Rules are applied in the order that
-    they are specified in. An empty list (or null) means no rules. Note that
-    you are allowed a maximum of 8 rules.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
-			'operation': 'updateNetworkApplianceTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
-
-		body_params = ['defaultRulesEnabled', 'rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingRules(self, networkId: str):
-		"""
-		**Display the traffic shaping settings rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
-			'operation': 'getNetworkApplianceTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str):
-		"""
-		**Returns the uplink bandwidth settings for your MX network.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-bandwidth
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
-			'operation': 'getNetworkApplianceTrafficShapingUplinkBandwidth'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
-		"""
-		**Updates the uplink bandwidth settings for your MX network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
-		
-		- networkId (string): (required)
-		- bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
-
-		body_params = ['bandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str):
-		"""
-		**Show uplink selection settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-selection
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
-			'operation': 'getNetworkApplianceTrafficShapingUplinkSelection'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
-		"""
-		**Update uplink selection settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
-		
-		- networkId (string): (required)
-		- activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
-		- defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
-		- loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
-		- wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
-		- vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
-		"""
-
-		kwargs.update(locals())
-
-		if 'defaultUplink' in kwargs:
-			options = ['wan1', 'wan2']
-			assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
-
-		body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVlans(self, networkId: str):
-		"""
-		**List the VLANs for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'getNetworkApplianceVlans'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
-		"""
-		**Add a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
-		- name (string): The name of the new VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'createNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans'
-
-		body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceVlansSettings(self, networkId: str):
-		"""
-		**Returns the enabled status of VLANs for the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans', 'settings'],
-			'operation': 'getNetworkApplianceVlansSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
-		"""
-		**Enable/Disable VLANs for the given network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
-		
-		- networkId (string): (required)
-		- vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans', 'settings'],
-			'operation': 'updateNetworkApplianceVlansSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/settings'
-
-		body_params = ['vlansEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVlan(self, networkId: str, vlanId: str):
-		"""
-		**Return a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'getNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
-		"""
-		**Update a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		- name (string): The name of the VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		- vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
-		- dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
-		- dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
-		- dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
-		- dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
-		- dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
-		- dhcpBootFilename (string): DHCP boot option for boot filename
-		- fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
-		- reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
-		- dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
-		- dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
-		"""
-
-		kwargs.update(locals())
-
-		if 'dhcpHandling' in kwargs:
-			options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
-			assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
-		if 'dhcpLeaseTime' in kwargs:
-			options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
-			assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'updateNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
-		"""
-		**Delete a VLAN from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'deleteNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkApplianceVpnBgp(self, networkId: str):
-		"""
-		**Return a Hub BGP Configuration**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-bgp
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'bgp'],
-			'operation': 'getNetworkApplianceVpnBgp'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/bgp'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update a Hub BGP Configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
-		- asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
-		- ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
-		- neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'bgp'],
-			'operation': 'updateNetworkApplianceVpnBgp'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/bgp'
-
-		body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVpnSiteToSiteVpn(self, networkId: str):
-		"""
-		**Return the site-to-site VPN settings of a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-site-to-site-vpn
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
-			'operation': 'getNetworkApplianceVpnSiteToSiteVpn'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
-		"""
-		**Update the site-to-site VPN settings of a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
-		
-		- networkId (string): (required)
-		- mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
-		- hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
-		- subnets (array): The list of subnets and their VPN presence.
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['none', 'spoke', 'hub']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
-			'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
-
-		body_params = ['mode', 'hubs', 'subnets', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceWarmSpare(self, networkId: str):
-		"""
-		**Return MX warm spare settings**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'getNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update MX warm spare settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		- enabled (boolean): Enable warm spare
-		- spareSerial (string): Serial number of the warm spare appliance
-		- uplinkMode (string): Uplink mode, either virtual or public
-		- virtualIp1 (string): The WAN 1 shared IP
-		- virtualIp2 (string): The WAN 2 shared IP
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'updateNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare'
-
-		body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def swapNetworkApplianceWarmSpare(self, networkId: str):
-		"""
-		**Swap MX primary and warm spare appliances**
-		https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'swapNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare/swap'
-
-		return self._session.post(metadata, resource)
-
-	def getOrganizationApplianceSecurityEvents(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-events
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'security', 'events'],
-			'operation': 'getOrganizationApplianceSecurityEvents'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceSecurityIntrusion(self, organizationId: str):
-		"""
-		**Returns all supported intrusion settings for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-intrusion
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'getOrganizationApplianceSecurityIntrusion'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/intrusion'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceSecurityIntrusion(self, organizationId: str, allowedRules: list):
-		"""
-		**Sets supported intrusion settings for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-security-intrusion
-		
-		- organizationId (string): (required)
-		- allowedRules (array): Sets a list of specific SNORT signatures to allow
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'updateOrganizationApplianceSecurityIntrusion'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/intrusion'
-
-		body_params = ['allowedRules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getOrganizationApplianceUplinkStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the uplink status of every Meraki MX and Z series appliances in the organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-uplink-statuses
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of network IDs. The returned devices will be filtered to only include these networks.
-		- serials (array): A list of serial numbers. The returned devices will be filtered to only include these serials.
-		- iccids (array): A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'uplink', 'statuses'],
-			'operation': 'getOrganizationApplianceUplinkStatuses'
-		}
-		resource = f'/organizations/{organizationId}/appliance/uplink/statuses'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 'serials', 'iccids', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', 'serials', 'iccids', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnStats(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Show VPN history stat for networks in an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-stats
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'vpn', 'stats'],
-			'operation': 'getOrganizationApplianceVpnStats'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/stats'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Show VPN status for networks in an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-statuses
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'vpn', 'statuses'],
-			'operation': 'getOrganizationApplianceVpnStatuses'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/statuses'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str):
-		"""
-		**Return the third party VPN peers for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-third-party-v-p-n-peers
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
-			'operation': 'getOrganizationApplianceVpnThirdPartyVPNPeers'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str, peers: list):
-		"""
-		**Update the third party VPN peers for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-third-party-v-p-n-peers
-		
-		- organizationId (string): (required)
-		- peers (array): The list of VPN peers
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
-			'operation': 'updateOrganizationApplianceVpnThirdPartyVPNPeers'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
-
-		body_params = ['peers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str):
-		"""
-		**Return the firewall rules for an organization's site-to-site VPN**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-vpn-firewall-rules
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
-			'operation': 'getOrganizationApplianceVpnVpnFirewallRules'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str, **kwargs):
-		"""
-		**Update the firewall rules of an organization's site-to-site VPN**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-vpn-firewall-rules
-		
-		- organizationId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
-			'operation': 'updateOrganizationApplianceVpnVpnFirewallRules'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
+class AsyncAppliance:
+    def __init__(self, session):
+        super().__init__()
+        self._session = session
+        
+
+
+    def getDeviceApplianceDhcpSubnets(self, serial: str):
+        """
+        **Return the DHCP subnet information for an appliance**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-dhcp-subnets
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'dhcp', 'subnets'],
+            'operation': 'getDeviceApplianceDhcpSubnets'
+        }
+        resource = f'/devices/{serial}/appliance/dhcp/subnets'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getDeviceAppliancePerformance(self, serial: str):
+        """
+        **Return the performance score for a single MX**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-performance
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'performance'],
+            'operation': 'getDeviceAppliancePerformance'
+        }
+        resource = f'/devices/{serial}/appliance/performance'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceClientSecurityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for a client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-client-security-events
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'clients', 'security', 'events'],
+            'operation': 'getNetworkApplianceClientSecurityEvents'
+        }
+        resource = f'/networks/{networkId}/appliance/clients/{clientId}/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str):
+        """
+        **Return the connectivity testing destinations for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'getNetworkApplianceConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
+        """
+        **Update the connectivity testing destinations for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        - destinations (array): The list of connectivity monitoring destinations
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
+
+        body_params = ['destinations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceContentFiltering(self, networkId: str):
+        """
+        **Return the content filtering settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering'],
+            'operation': 'getNetworkApplianceContentFiltering'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceContentFiltering(self, networkId: str, **kwargs):
+        """
+        **Update the content filtering settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-content-filtering
+
+        - networkId (string): (required)
+        - allowedUrlPatterns (array): A list of URL patterns that are allowed
+        - blockedUrlPatterns (array): A list of URL patterns that are blocked
+        - blockedUrlCategories (array): A list of URL categories to block
+        - urlCategoryListSize (string): URL category list size which is either 'topSites' or 'fullList'
+        """
+
+        kwargs.update(locals())
+
+        if 'urlCategoryListSize' in kwargs:
+            options = ['topSites', 'fullList']
+            assert kwargs['urlCategoryListSize'] in options, f'''"urlCategoryListSize" cannot be "{kwargs['urlCategoryListSize']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering'],
+            'operation': 'updateNetworkApplianceContentFiltering'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering'
+
+        body_params = ['allowedUrlPatterns', 'blockedUrlPatterns', 'blockedUrlCategories', 'urlCategoryListSize', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceContentFilteringCategories(self, networkId: str):
+        """
+        **List all available content filtering categories for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering', 'categories'],
+            'operation': 'getNetworkApplianceContentFilteringCategories'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering/categories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallCellularFirewallRules(self, networkId: str):
+        """
+        **Return the cellular firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-cellular-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
+            'operation': 'getNetworkApplianceFirewallCellularFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallCellularFirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the cellular firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-cellular-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallCellularFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallFirewalledServices(self, networkId: str):
+        """
+        **List the appliance services and their accessibility rules**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-services
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'getNetworkApplianceFirewallFirewalledServices'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str):
+        """
+        **Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-service
+
+        - networkId (string): (required)
+        - service (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'getNetworkApplianceFirewallFirewalledService'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str, access: str, **kwargs):
+        """
+        **Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-firewalled-service
+
+        - networkId (string): (required)
+        - service (string): (required)
+        - access (string): A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
+        - allowedIps (array): An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored
+        """
+
+        kwargs.update(locals())
+
+        if 'access' in kwargs:
+            options = ['blocked', 'restricted', 'unrestricted']
+            assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'updateNetworkApplianceFirewallFirewalledService'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
+
+        body_params = ['access', 'allowedIps', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallInboundFirewallRules(self, networkId: str):
+        """
+        **Return the inbound firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-inbound-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
+            'operation': 'getNetworkApplianceFirewallInboundFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallInboundFirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the inbound firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-inbound-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallInboundFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL3FirewallRules(self, networkId: str):
+        """
+        **Return the L3 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
+            'operation': 'getNetworkApplianceFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallL3FirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the L3 firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL7FirewallRules(self, networkId: str):
+        """
+        **List the MX L7 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
+            'operation': 'getNetworkApplianceFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the MX L7 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the MX L7 firewall rules
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL7FirewallRulesApplicationCategories(self, networkId: str):
+        """
+        **Return the L7 firewall application categories and their associated applications for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules-application-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules', 'applicationCategories'],
+            'operation': 'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallOneToManyNatRules(self, networkId: str):
+        """
+        **Return the 1:Many NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-many-nat-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
+            'operation': 'getNetworkApplianceFirewallOneToManyNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallOneToManyNatRules(self, networkId: str, rules: list):
+        """
+        **Set the 1:Many NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-many-nat-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of 1:Many nat rules
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
+            'operation': 'updateNetworkApplianceFirewallOneToManyNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallOneToOneNatRules(self, networkId: str):
+        """
+        **Return the 1:1 NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-one-nat-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
+            'operation': 'getNetworkApplianceFirewallOneToOneNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallOneToOneNatRules(self, networkId: str, rules: list):
+        """
+        **Set the 1:1 NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-one-nat-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of 1:1 nat rules
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
+            'operation': 'updateNetworkApplianceFirewallOneToOneNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallPortForwardingRules(self, networkId: str):
+        """
+        **Return the port forwarding rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-port-forwarding-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
+            'operation': 'getNetworkApplianceFirewallPortForwardingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallPortForwardingRules(self, networkId: str, rules: list):
+        """
+        **Update the port forwarding rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-port-forwarding-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of port forwarding params
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
+            'operation': 'updateNetworkApplianceFirewallPortForwardingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkAppliancePorts(self, networkId: str):
+        """
+        **List per-port VLAN settings for all ports of a MX.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-ports
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'getNetworkAppliancePorts'
+        }
+        resource = f'/networks/{networkId}/appliance/ports'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkAppliancePort(self, networkId: str, portId: str):
+        """
+        **Return per-port VLAN settings for a single MX port.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-port
+
+        - networkId (string): (required)
+        - portId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'getNetworkAppliancePort'
+        }
+        resource = f'/networks/{networkId}/appliance/ports/{portId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
+        """
+        **Update the per-port VLAN settings for a single MX port.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
+
+        - networkId (string): (required)
+        - portId (string): (required)
+        - enabled (boolean): The status of the port
+        - dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
+        - type (string): The type of the port: 'access' or 'trunk'.
+        - vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
+        - allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
+        - accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'updateNetworkAppliancePort'
+        }
+        resource = f'/networks/{networkId}/appliance/ports/{portId}'
+
+        body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSecurityEvents(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-events
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'security', 'events'],
+            'operation': 'getNetworkApplianceSecurityEvents'
+        }
+        resource = f'/networks/{networkId}/appliance/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkApplianceSecurityIntrusion(self, networkId: str):
+        """
+        **Returns all supported intrusion settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-intrusion
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'getNetworkApplianceSecurityIntrusion'
+        }
+        resource = f'/networks/{networkId}/appliance/security/intrusion'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSecurityIntrusion(self, networkId: str, **kwargs):
+        """
+        **Set the supported intrusion settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-intrusion
+
+        - networkId (string): (required)
+        - mode (string): Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
+        - idsRulesets (string): Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
+        - protectedNetworks (object): Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['prevention', 'detection', 'disabled']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+        if 'idsRulesets' in kwargs:
+            options = ['connectivity', 'balanced', 'security']
+            assert kwargs['idsRulesets'] in options, f'''"idsRulesets" cannot be "{kwargs['idsRulesets']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'updateNetworkApplianceSecurityIntrusion'
+        }
+        resource = f'/networks/{networkId}/appliance/security/intrusion'
+
+        body_params = ['mode', 'idsRulesets', 'protectedNetworks', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSecurityMalware(self, networkId: str):
+        """
+        **Returns all supported malware settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-malware
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'malware'],
+            'operation': 'getNetworkApplianceSecurityMalware'
+        }
+        resource = f'/networks/{networkId}/appliance/security/malware'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSecurityMalware(self, networkId: str, mode: str, **kwargs):
+        """
+        **Set the supported malware settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-malware
+
+        - networkId (string): (required)
+        - mode (string): Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
+        - allowedUrls (array): The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
+        - allowedFiles (array): The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['enabled', 'disabled']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'malware'],
+            'operation': 'updateNetworkApplianceSecurityMalware'
+        }
+        resource = f'/networks/{networkId}/appliance/security/malware'
+
+        body_params = ['mode', 'allowedUrls', 'allowedFiles', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSettings(self, networkId: str):
+        """
+        **Return the appliance settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'settings'],
+            'operation': 'getNetworkApplianceSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceSingleLan(self, networkId: str):
+        """
+        **Return single LAN configuration**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-single-lan
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'singleLan'],
+            'operation': 'getNetworkApplianceSingleLan'
+        }
+        resource = f'/networks/{networkId}/appliance/singleLan'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
+        """
+        **Update single LAN configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
+
+        - networkId (string): (required)
+        - subnet (string): The subnet of the single LAN configuration
+        - applianceIp (string): The appliance IP address of the single LAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'singleLan'],
+            'operation': 'updateNetworkApplianceSingleLan'
+        }
+        resource = f'/networks/{networkId}/appliance/singleLan'
+
+        body_params = ['subnet', 'applianceIp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceStaticRoutes(self, networkId: str):
+        """
+        **List the static routes for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-routes
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'getNetworkApplianceStaticRoutes'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceStaticRoute(self, networkId: str, name: str, subnet: str, gatewayIp: str):
+        """
+        **Add a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-static-route
+
+        - networkId (string): (required)
+        - name (string): The name of the new static route
+        - subnet (string): The subnet of the static route
+        - gatewayIp (string): The gateway IP (next hop) of the static route
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'createNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes'
+
+        body_params = ['name', 'subnet', 'gatewayIp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
+        """
+        **Return a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'getNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str, **kwargs):
+        """
+        **Update a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        - name (string): The name of the static route
+        - subnet (string): The subnet of the static route
+        - gatewayIp (string): The gateway IP (next hop) of the static route
+        - enabled (boolean): The enabled state of the static route
+        - fixedIpAssignments (object): The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
+        - reservedIpRanges (array): The DHCP reserved IP ranges on the static route
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'updateNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        body_params = ['name', 'subnet', 'gatewayIp', 'enabled', 'fixedIpAssignments', 'reservedIpRanges', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
+        """
+        **Delete a static route from an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'deleteNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkApplianceTrafficShaping(self, networkId: str):
+        """
+        **Display the traffic shaping settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping'],
+            'operation': 'getNetworkApplianceTrafficShaping'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShaping(self, networkId: str, **kwargs):
+        """
+        **Update the traffic shaping settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping
+
+        - networkId (string): (required)
+        - globalBandwidthLimits (object): Global per-client bandwidth limit
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping'],
+            'operation': 'updateNetworkApplianceTrafficShaping'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping'
+
+        body_params = ['globalBandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingCustomPerformanceClasses(self, networkId: str):
+        """
+        **List all custom performance classes for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-classes
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClasses'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
+        """
+        **Add a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
+        """
+        **Return a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
+        """
+        **Update a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
+        """
+        **Delete a custom performance class from an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
+        """
+        **Update the traffic shaping settings rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
+        - rules (array):     An array of traffic shaping rules. Rules are applied in the order that
+    they are specified in. An empty list (or null) means no rules. Note that
+    you are allowed a maximum of 8 rules.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
+            'operation': 'updateNetworkApplianceTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
+
+        body_params = ['defaultRulesEnabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingRules(self, networkId: str):
+        """
+        **Display the traffic shaping settings rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
+            'operation': 'getNetworkApplianceTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str):
+        """
+        **Returns the uplink bandwidth settings for your MX network.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-bandwidth
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
+            'operation': 'getNetworkApplianceTrafficShapingUplinkBandwidth'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
+        """
+        **Updates the uplink bandwidth settings for your MX network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
+
+        - networkId (string): (required)
+        - bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
+
+        body_params = ['bandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str):
+        """
+        **Show uplink selection settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-selection
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
+            'operation': 'getNetworkApplianceTrafficShapingUplinkSelection'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
+        """
+        **Update uplink selection settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
+
+        - networkId (string): (required)
+        - activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
+        - defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
+        - loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
+        - wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
+        - vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
+        """
+
+        kwargs.update(locals())
+
+        if 'defaultUplink' in kwargs:
+            options = ['wan1', 'wan2']
+            assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
+
+        body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlans(self, networkId: str):
+        """
+        **List the VLANs for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'getNetworkApplianceVlans'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
+        """
+        **Add a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
+
+        - networkId (string): (required)
+        - id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
+        - name (string): The name of the new VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'createNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans'
+
+        body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlansSettings(self, networkId: str):
+        """
+        **Returns the enabled status of VLANs for the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans', 'settings'],
+            'operation': 'getNetworkApplianceVlansSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
+        """
+        **Enable/Disable VLANs for the given network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
+
+        - networkId (string): (required)
+        - vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans', 'settings'],
+            'operation': 'updateNetworkApplianceVlansSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/settings'
+
+        body_params = ['vlansEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlan(self, networkId: str, vlanId: str):
+        """
+        **Return a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'getNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
+        """
+        **Update a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        - name (string): The name of the VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        - vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
+        - dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
+        - dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
+        - dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
+        - dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
+        - dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
+        - dhcpBootFilename (string): DHCP boot option for boot filename
+        - fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
+        - reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
+        - dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
+        - dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
+        """
+
+        kwargs.update(locals())
+
+        if 'dhcpHandling' in kwargs:
+            options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
+            assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
+        if 'dhcpLeaseTime' in kwargs:
+            options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
+            assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'updateNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
+        """
+        **Delete a VLAN from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'deleteNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkApplianceVpnBgp(self, networkId: str):
+        """
+        **Return a Hub BGP Configuration**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-bgp
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'bgp'],
+            'operation': 'getNetworkApplianceVpnBgp'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/bgp'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update a Hub BGP Configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
+        - asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
+        - ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
+        - neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'bgp'],
+            'operation': 'updateNetworkApplianceVpnBgp'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/bgp'
+
+        body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVpnSiteToSiteVpn(self, networkId: str):
+        """
+        **Return the site-to-site VPN settings of a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-site-to-site-vpn
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
+            'operation': 'getNetworkApplianceVpnSiteToSiteVpn'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
+        """
+        **Update the site-to-site VPN settings of a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
+
+        - networkId (string): (required)
+        - mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
+        - hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
+        - subnets (array): The list of subnets and their VPN presence.
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['none', 'spoke', 'hub']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
+            'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
+
+        body_params = ['mode', 'hubs', 'subnets', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceWarmSpare(self, networkId: str):
+        """
+        **Return MX warm spare settings**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'getNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update MX warm spare settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        - enabled (boolean): Enable warm spare
+        - spareSerial (string): Serial number of the warm spare appliance
+        - uplinkMode (string): Uplink mode, either virtual or public
+        - virtualIp1 (string): The WAN 1 shared IP
+        - virtualIp2 (string): The WAN 2 shared IP
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'updateNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare'
+
+        body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def swapNetworkApplianceWarmSpare(self, networkId: str):
+        """
+        **Swap MX primary and warm spare appliances**
+        https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'swapNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare/swap'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getOrganizationApplianceSecurityEvents(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-events
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'security', 'events'],
+            'operation': 'getOrganizationApplianceSecurityEvents'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceSecurityIntrusion(self, organizationId: str):
+        """
+        **Returns all supported intrusion settings for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-intrusion
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'getOrganizationApplianceSecurityIntrusion'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/intrusion'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceSecurityIntrusion(self, organizationId: str, allowedRules: list):
+        """
+        **Sets supported intrusion settings for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-security-intrusion
+
+        - organizationId (string): (required)
+        - allowedRules (array): Sets a list of specific SNORT signatures to allow
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'updateOrganizationApplianceSecurityIntrusion'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/intrusion'
+
+        body_params = ['allowedRules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getOrganizationApplianceUplinkStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the uplink status of every Meraki MX and Z series appliances in the organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-uplink-statuses
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of network IDs. The returned devices will be filtered to only include these networks.
+        - serials (array): A list of serial numbers. The returned devices will be filtered to only include these serials.
+        - iccids (array): A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'uplink', 'statuses'],
+            'operation': 'getOrganizationApplianceUplinkStatuses'
+        }
+        resource = f'/organizations/{organizationId}/appliance/uplink/statuses'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 'serials', 'iccids', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', 'serials', 'iccids', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnStats(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Show VPN history stat for networks in an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-stats
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'vpn', 'stats'],
+            'operation': 'getOrganizationApplianceVpnStats'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/stats'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Show VPN status for networks in an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-statuses
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'vpn', 'statuses'],
+            'operation': 'getOrganizationApplianceVpnStatuses'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/statuses'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str):
+        """
+        **Return the third party VPN peers for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-third-party-v-p-n-peers
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
+            'operation': 'getOrganizationApplianceVpnThirdPartyVPNPeers'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str, peers: list):
+        """
+        **Update the third party VPN peers for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-third-party-v-p-n-peers
+
+        - organizationId (string): (required)
+        - peers (array): The list of VPN peers
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
+            'operation': 'updateOrganizationApplianceVpnThirdPartyVPNPeers'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
+
+        body_params = ['peers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str):
+        """
+        **Return the firewall rules for an organization's site-to-site VPN**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-vpn-firewall-rules
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
+            'operation': 'getOrganizationApplianceVpnVpnFirewallRules'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str, **kwargs):
+        """
+        **Update the firewall rules of an organization's site-to-site VPN**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-vpn-firewall-rules
+
+        - organizationId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
+            'operation': 'updateOrganizationApplianceVpnVpnFirewallRules'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+
```

### Comparing `meraki-1.7.1/meraki/aio/api/camera.py` & `meraki-1.7.2/meraki/aio/api/camera.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,442 +1,483 @@
-class AsyncCamera:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def getDeviceCameraAnalyticsLive(self, serial: str):
-		"""
-		**Returns live state from camera of analytics zones**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-live
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'monitor', 'analytics', 'live'],
-			'operation': 'getDeviceCameraAnalyticsLive'
-		}
-		resource = f'/devices/{serial}/camera/analytics/live'
-
-		return self._session.get(metadata, resource)
-
-	def getDeviceCameraAnalyticsOverview(self, serial: str, **kwargs):
-		"""
-		**Returns an overview of aggregate analytics data for a timespan**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-overview
-		
-		- serial (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.
-		- objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
-		"""
-
-		kwargs.update(locals())
-
-		if 'objectType' in kwargs:
-			options = ['person', 'vehicle']
-			assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['camera', 'monitor', 'analytics', 'overview'],
-			'operation': 'getDeviceCameraAnalyticsOverview'
-		}
-		resource = f'/devices/{serial}/camera/analytics/overview'
-
-		query_params = ['t0', 't1', 'timespan', 'objectType', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getDeviceCameraAnalyticsRecent(self, serial: str, **kwargs):
-		"""
-		**Returns most recent record for analytics zones**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-recent
-		
-		- serial (string): (required)
-		- objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
-		"""
-
-		kwargs.update(locals())
-
-		if 'objectType' in kwargs:
-			options = ['person', 'vehicle']
-			assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['camera', 'monitor', 'analytics', 'recent'],
-			'operation': 'getDeviceCameraAnalyticsRecent'
-		}
-		resource = f'/devices/{serial}/camera/analytics/recent'
-
-		query_params = ['objectType', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getDeviceCameraAnalyticsZones(self, serial: str):
-		"""
-		**Returns all configured analytic zones for this camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-zones
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'monitor', 'analytics', 'zones'],
-			'operation': 'getDeviceCameraAnalyticsZones'
-		}
-		resource = f'/devices/{serial}/camera/analytics/zones'
-
-		return self._session.get(metadata, resource)
-
-	def getDeviceCameraAnalyticsZoneHistory(self, serial: str, zoneId: str, **kwargs):
-		"""
-		**Return historical records for analytic zones**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-zone-history
-		
-		- serial (string): (required)
-		- zoneId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 14 hours after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60.
-		- objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
-		"""
-
-		kwargs.update(locals())
-
-		if 'objectType' in kwargs:
-			options = ['person', 'vehicle']
-			assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['camera', 'monitor', 'analytics', 'zones', 'history'],
-			'operation': 'getDeviceCameraAnalyticsZoneHistory'
-		}
-		resource = f'/devices/{serial}/camera/analytics/zones/{zoneId}/history'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'objectType', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def generateDeviceCameraSnapshot(self, serial: str, **kwargs):
-		"""
-		**Generate a snapshot of what the camera sees at the specified time and return a link to that image.**
-		https://developer.cisco.com/meraki/api-v1/#!generate-device-camera-snapshot
-		
-		- serial (string): (required)
-		- timestamp (string): [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
-		- fullframe (boolean): [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'monitor'],
-			'operation': 'generateDeviceCameraSnapshot'
-		}
-		resource = f'/devices/{serial}/camera/generateSnapshot'
-
-		body_params = ['timestamp', 'fullframe', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getDeviceCameraQualityAndRetention(self, serial: str):
-		"""
-		**Returns quality and retention settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-quality-and-retention
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityAndRetention'],
-			'operation': 'getDeviceCameraQualityAndRetention'
-		}
-		resource = f'/devices/{serial}/camera/qualityAndRetention'
-
-		return self._session.get(metadata, resource)
-
-	def updateDeviceCameraQualityAndRetention(self, serial: str, **kwargs):
-		"""
-		**Update quality and retention settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-quality-and-retention
-		
-		- serial (string): (required)
-		- profileId (string): The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.
-		- motionBasedRetentionEnabled (boolean): Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera.
-		- audioRecordingEnabled (boolean): Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera
-		- restrictedBandwidthModeEnabled (boolean): Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera
-		- quality (string): Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.
-		- resolution (string): Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model.
-		- motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
-		"""
-
-		kwargs.update(locals())
-
-		if 'quality' in kwargs:
-			options = ['Standard', 'High', 'Enhanced']
-			assert kwargs['quality'] in options, f'''"quality" cannot be "{kwargs['quality']}", & must be set to one of: {options}'''
-		if 'resolution' in kwargs:
-			options = ['1280x720', '1920x1080', '1080x1080', '2058x2058']
-			assert kwargs['resolution'] in options, f'''"resolution" cannot be "{kwargs['resolution']}", & must be set to one of: {options}'''
-		if 'motionDetectorVersion' in kwargs:
-			options = [1, 2]
-			assert kwargs['motionDetectorVersion'] in options, f'''"motionDetectorVersion" cannot be "{kwargs['motionDetectorVersion']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityAndRetention'],
-			'operation': 'updateDeviceCameraQualityAndRetention'
-		}
-		resource = f'/devices/{serial}/camera/qualityAndRetention'
-
-		body_params = ['profileId', 'motionBasedRetentionEnabled', 'audioRecordingEnabled', 'restrictedBandwidthModeEnabled', 'quality', 'resolution', 'motionDetectorVersion', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getDeviceCameraSense(self, serial: str):
-		"""
-		**Returns sense settings for a given camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-sense
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'sense'],
-			'operation': 'getDeviceCameraSense'
-		}
-		resource = f'/devices/{serial}/camera/sense'
-
-		return self._session.get(metadata, resource)
-
-	def updateDeviceCameraSense(self, serial: str, **kwargs):
-		"""
-		**Update sense settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-sense
-		
-		- serial (string): (required)
-		- senseEnabled (boolean): Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera
-		- mqttBrokerId (string): The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera
-		- detectionModelId (string): The ID of the object detection model
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'sense'],
-			'operation': 'updateDeviceCameraSense'
-		}
-		resource = f'/devices/{serial}/camera/sense'
-
-		body_params = ['senseEnabled', 'mqttBrokerId', 'detectionModelId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getDeviceCameraSenseObjectDetectionModels(self, serial: str):
-		"""
-		**Returns the MV Sense object detection model list for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-sense-object-detection-models
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'sense', 'objectDetectionModels'],
-			'operation': 'getDeviceCameraSenseObjectDetectionModels'
-		}
-		resource = f'/devices/{serial}/camera/sense/objectDetectionModels'
-
-		return self._session.get(metadata, resource)
-
-	def getDeviceCameraVideoSettings(self, serial: str):
-		"""
-		**Returns video settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-video-settings
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'video', 'settings'],
-			'operation': 'getDeviceCameraVideoSettings'
-		}
-		resource = f'/devices/{serial}/camera/video/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateDeviceCameraVideoSettings(self, serial: str, **kwargs):
-		"""
-		**Update video settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-video-settings
-		
-		- serial (string): (required)
-		- externalRtspEnabled (boolean): Boolean indicating if external rtsp stream is exposed
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'video', 'settings'],
-			'operation': 'updateDeviceCameraVideoSettings'
-		}
-		resource = f'/devices/{serial}/camera/video/settings'
-
-		body_params = ['externalRtspEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getDeviceCameraVideoLink(self, serial: str, **kwargs):
-		"""
-		**Returns video link to the specified camera**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-camera-video-link
-		
-		- serial (string): (required)
-		- timestamp (string): [optional] The video link will start at this time. The timestamp should be a string in ISO8601 format. If no timestamp is specified, we will assume current time.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'videoLink'],
-			'operation': 'getDeviceCameraVideoLink'
-		}
-		resource = f'/devices/{serial}/camera/videoLink'
-
-		query_params = ['timestamp', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkCameraQualityRetentionProfiles(self, networkId: str):
-		"""
-		**List the quality retention profiles for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-camera-quality-retention-profiles
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
-			'operation': 'getNetworkCameraQualityRetentionProfiles'
-		}
-		resource = f'/networks/{networkId}/camera/qualityRetentionProfiles'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkCameraQualityRetentionProfile(self, networkId: str, name: str, **kwargs):
-		"""
-		**Creates new quality retention profile for this network.**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-camera-quality-retention-profile
-		
-		- networkId (string): (required)
-		- name (string): The name of the new profile. Must be unique. This parameter is required.
-		- motionBasedRetentionEnabled (boolean): Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false.
-		- restrictedBandwidthModeEnabled (boolean): Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false.
-		- audioRecordingEnabled (boolean): Whether or not to record audio. Can be either true or false. Defaults to false.
-		- cloudArchiveEnabled (boolean): Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
-		- motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
-		- scheduleId (string): Schedule for which this camera will record video, or 'null' to always record.
-		- maxRetentionDays (integer): The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days
-		- videoSettings (object): Video quality and resolution settings for all the camera models.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
-			'operation': 'createNetworkCameraQualityRetentionProfile'
-		}
-		resource = f'/networks/{networkId}/camera/qualityRetentionProfiles'
-
-		body_params = ['name', 'motionBasedRetentionEnabled', 'restrictedBandwidthModeEnabled', 'audioRecordingEnabled', 'cloudArchiveEnabled', 'motionDetectorVersion', 'scheduleId', 'maxRetentionDays', 'videoSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str):
-		"""
-		**Retrieve a single quality retention profile**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-camera-quality-retention-profile
-		
-		- networkId (string): (required)
-		- qualityRetentionProfileId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
-			'operation': 'getNetworkCameraQualityRetentionProfile'
-		}
-		resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str, **kwargs):
-		"""
-		**Update an existing quality retention profile for this network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-camera-quality-retention-profile
-		
-		- networkId (string): (required)
-		- qualityRetentionProfileId (string): (required)
-		- name (string): The name of the new profile. Must be unique.
-		- motionBasedRetentionEnabled (boolean): Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false.
-		- restrictedBandwidthModeEnabled (boolean): Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false.
-		- audioRecordingEnabled (boolean): Whether or not to record audio. Can be either true or false. Defaults to false.
-		- cloudArchiveEnabled (boolean): Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
-		- motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
-		- scheduleId (string): Schedule for which this camera will record video, or 'null' to always record.
-		- maxRetentionDays (integer): The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days
-		- videoSettings (object): Video quality and resolution settings for all the camera models.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
-			'operation': 'updateNetworkCameraQualityRetentionProfile'
-		}
-		resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
-
-		body_params = ['name', 'motionBasedRetentionEnabled', 'restrictedBandwidthModeEnabled', 'audioRecordingEnabled', 'cloudArchiveEnabled', 'motionDetectorVersion', 'scheduleId', 'maxRetentionDays', 'videoSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str):
-		"""
-		**Delete an existing quality retention profile for this network.**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-camera-quality-retention-profile
-		
-		- networkId (string): (required)
-		- qualityRetentionProfileId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
-			'operation': 'deleteNetworkCameraQualityRetentionProfile'
-		}
-		resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkCameraSchedules(self, networkId: str):
-		"""
-		**Returns a list of all camera recording schedules.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-camera-schedules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['camera', 'configure', 'schedules'],
-			'operation': 'getNetworkCameraSchedules'
-		}
-		resource = f'/networks/{networkId}/camera/schedules'
-
-		return self._session.get(metadata, resource)
+class AsyncCamera:
+    def __init__(self, session):
+        super().__init__()
+        self._session = session
+        
+
+
+    def getDeviceCameraAnalyticsLive(self, serial: str):
+        """
+        **Returns live state from camera of analytics zones**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-live
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'monitor', 'analytics', 'live'],
+            'operation': 'getDeviceCameraAnalyticsLive'
+        }
+        resource = f'/devices/{serial}/camera/analytics/live'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getDeviceCameraAnalyticsOverview(self, serial: str, **kwargs):
+        """
+        **Returns an overview of aggregate analytics data for a timespan**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-overview
+
+        - serial (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.
+        - objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
+        """
+
+        kwargs.update(locals())
+
+        if 'objectType' in kwargs:
+            options = ['person', 'vehicle']
+            assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['camera', 'monitor', 'analytics', 'overview'],
+            'operation': 'getDeviceCameraAnalyticsOverview'
+        }
+        resource = f'/devices/{serial}/camera/analytics/overview'
+
+        query_params = ['t0', 't1', 'timespan', 'objectType', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getDeviceCameraAnalyticsRecent(self, serial: str, **kwargs):
+        """
+        **Returns most recent record for analytics zones**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-recent
+
+        - serial (string): (required)
+        - objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
+        """
+
+        kwargs.update(locals())
+
+        if 'objectType' in kwargs:
+            options = ['person', 'vehicle']
+            assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['camera', 'monitor', 'analytics', 'recent'],
+            'operation': 'getDeviceCameraAnalyticsRecent'
+        }
+        resource = f'/devices/{serial}/camera/analytics/recent'
+
+        query_params = ['objectType', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getDeviceCameraAnalyticsZones(self, serial: str):
+        """
+        **Returns all configured analytic zones for this camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-zones
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'monitor', 'analytics', 'zones'],
+            'operation': 'getDeviceCameraAnalyticsZones'
+        }
+        resource = f'/devices/{serial}/camera/analytics/zones'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getDeviceCameraAnalyticsZoneHistory(self, serial: str, zoneId: str, **kwargs):
+        """
+        **Return historical records for analytic zones**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-analytics-zone-history
+
+        - serial (string): (required)
+        - zoneId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 14 hours after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60.
+        - objectType (string): [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
+        """
+
+        kwargs.update(locals())
+
+        if 'objectType' in kwargs:
+            options = ['person', 'vehicle']
+            assert kwargs['objectType'] in options, f'''"objectType" cannot be "{kwargs['objectType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['camera', 'monitor', 'analytics', 'zones', 'history'],
+            'operation': 'getDeviceCameraAnalyticsZoneHistory'
+        }
+        resource = f'/devices/{serial}/camera/analytics/zones/{zoneId}/history'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'objectType', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def generateDeviceCameraSnapshot(self, serial: str, **kwargs):
+        """
+        **Generate a snapshot of what the camera sees at the specified time and return a link to that image.**
+        https://developer.cisco.com/meraki/api-v1/#!generate-device-camera-snapshot
+
+        - serial (string): (required)
+        - timestamp (string): [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
+        - fullframe (boolean): [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'monitor'],
+            'operation': 'generateDeviceCameraSnapshot'
+        }
+        resource = f'/devices/{serial}/camera/generateSnapshot'
+
+        body_params = ['timestamp', 'fullframe', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getDeviceCameraQualityAndRetention(self, serial: str):
+        """
+        **Returns quality and retention settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-quality-and-retention
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityAndRetention'],
+            'operation': 'getDeviceCameraQualityAndRetention'
+        }
+        resource = f'/devices/{serial}/camera/qualityAndRetention'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateDeviceCameraQualityAndRetention(self, serial: str, **kwargs):
+        """
+        **Update quality and retention settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-quality-and-retention
+
+        - serial (string): (required)
+        - profileId (string): The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.
+        - motionBasedRetentionEnabled (boolean): Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera.
+        - audioRecordingEnabled (boolean): Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera
+        - restrictedBandwidthModeEnabled (boolean): Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera
+        - quality (string): Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.
+        - resolution (string): Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model.
+        - motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
+        """
+
+        kwargs.update(locals())
+
+        if 'quality' in kwargs:
+            options = ['Standard', 'High', 'Enhanced']
+            assert kwargs['quality'] in options, f'''"quality" cannot be "{kwargs['quality']}", & must be set to one of: {options}'''
+        if 'resolution' in kwargs:
+            options = ['1280x720', '1920x1080', '1080x1080', '2058x2058']
+            assert kwargs['resolution'] in options, f'''"resolution" cannot be "{kwargs['resolution']}", & must be set to one of: {options}'''
+        if 'motionDetectorVersion' in kwargs:
+            options = [1, 2]
+            assert kwargs['motionDetectorVersion'] in options, f'''"motionDetectorVersion" cannot be "{kwargs['motionDetectorVersion']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityAndRetention'],
+            'operation': 'updateDeviceCameraQualityAndRetention'
+        }
+        resource = f'/devices/{serial}/camera/qualityAndRetention'
+
+        body_params = ['profileId', 'motionBasedRetentionEnabled', 'audioRecordingEnabled', 'restrictedBandwidthModeEnabled', 'quality', 'resolution', 'motionDetectorVersion', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getDeviceCameraSense(self, serial: str):
+        """
+        **Returns sense settings for a given camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-sense
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'sense'],
+            'operation': 'getDeviceCameraSense'
+        }
+        resource = f'/devices/{serial}/camera/sense'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateDeviceCameraSense(self, serial: str, **kwargs):
+        """
+        **Update sense settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-sense
+
+        - serial (string): (required)
+        - senseEnabled (boolean): Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera
+        - mqttBrokerId (string): The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera
+        - detectionModelId (string): The ID of the object detection model
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'sense'],
+            'operation': 'updateDeviceCameraSense'
+        }
+        resource = f'/devices/{serial}/camera/sense'
+
+        body_params = ['senseEnabled', 'mqttBrokerId', 'detectionModelId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getDeviceCameraSenseObjectDetectionModels(self, serial: str):
+        """
+        **Returns the MV Sense object detection model list for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-sense-object-detection-models
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'sense', 'objectDetectionModels'],
+            'operation': 'getDeviceCameraSenseObjectDetectionModels'
+        }
+        resource = f'/devices/{serial}/camera/sense/objectDetectionModels'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getDeviceCameraVideoSettings(self, serial: str):
+        """
+        **Returns video settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-video-settings
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'video', 'settings'],
+            'operation': 'getDeviceCameraVideoSettings'
+        }
+        resource = f'/devices/{serial}/camera/video/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateDeviceCameraVideoSettings(self, serial: str, **kwargs):
+        """
+        **Update video settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-video-settings
+
+        - serial (string): (required)
+        - externalRtspEnabled (boolean): Boolean indicating if external rtsp stream is exposed
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'video', 'settings'],
+            'operation': 'updateDeviceCameraVideoSettings'
+        }
+        resource = f'/devices/{serial}/camera/video/settings'
+
+        body_params = ['externalRtspEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getDeviceCameraVideoLink(self, serial: str, **kwargs):
+        """
+        **Returns video link to the specified camera**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-camera-video-link
+
+        - serial (string): (required)
+        - timestamp (string): [optional] The video link will start at this time. The timestamp should be a string in ISO8601 format. If no timestamp is specified, we will assume current time.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'videoLink'],
+            'operation': 'getDeviceCameraVideoLink'
+        }
+        resource = f'/devices/{serial}/camera/videoLink'
+
+        query_params = ['timestamp', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkCameraQualityRetentionProfiles(self, networkId: str):
+        """
+        **List the quality retention profiles for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-camera-quality-retention-profiles
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
+            'operation': 'getNetworkCameraQualityRetentionProfiles'
+        }
+        resource = f'/networks/{networkId}/camera/qualityRetentionProfiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkCameraQualityRetentionProfile(self, networkId: str, name: str, **kwargs):
+        """
+        **Creates new quality retention profile for this network.**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-camera-quality-retention-profile
+
+        - networkId (string): (required)
+        - name (string): The name of the new profile. Must be unique. This parameter is required.
+        - motionBasedRetentionEnabled (boolean): Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false.
+        - restrictedBandwidthModeEnabled (boolean): Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false.
+        - audioRecordingEnabled (boolean): Whether or not to record audio. Can be either true or false. Defaults to false.
+        - cloudArchiveEnabled (boolean): Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
+        - motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
+        - scheduleId (string): Schedule for which this camera will record video, or 'null' to always record.
+        - maxRetentionDays (integer): The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days
+        - videoSettings (object): Video quality and resolution settings for all the camera models.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
+            'operation': 'createNetworkCameraQualityRetentionProfile'
+        }
+        resource = f'/networks/{networkId}/camera/qualityRetentionProfiles'
+
+        body_params = ['name', 'motionBasedRetentionEnabled', 'restrictedBandwidthModeEnabled', 'audioRecordingEnabled', 'cloudArchiveEnabled', 'motionDetectorVersion', 'scheduleId', 'maxRetentionDays', 'videoSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str):
+        """
+        **Retrieve a single quality retention profile**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-camera-quality-retention-profile
+
+        - networkId (string): (required)
+        - qualityRetentionProfileId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
+            'operation': 'getNetworkCameraQualityRetentionProfile'
+        }
+        resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str, **kwargs):
+        """
+        **Update an existing quality retention profile for this network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-camera-quality-retention-profile
+
+        - networkId (string): (required)
+        - qualityRetentionProfileId (string): (required)
+        - name (string): The name of the new profile. Must be unique.
+        - motionBasedRetentionEnabled (boolean): Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false.
+        - restrictedBandwidthModeEnabled (boolean): Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false.
+        - audioRecordingEnabled (boolean): Whether or not to record audio. Can be either true or false. Defaults to false.
+        - cloudArchiveEnabled (boolean): Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
+        - motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
+        - scheduleId (string): Schedule for which this camera will record video, or 'null' to always record.
+        - maxRetentionDays (integer): The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days
+        - videoSettings (object): Video quality and resolution settings for all the camera models.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
+            'operation': 'updateNetworkCameraQualityRetentionProfile'
+        }
+        resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
+
+        body_params = ['name', 'motionBasedRetentionEnabled', 'restrictedBandwidthModeEnabled', 'audioRecordingEnabled', 'cloudArchiveEnabled', 'motionDetectorVersion', 'scheduleId', 'maxRetentionDays', 'videoSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkCameraQualityRetentionProfile(self, networkId: str, qualityRetentionProfileId: str):
+        """
+        **Delete an existing quality retention profile for this network.**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-camera-quality-retention-profile
+
+        - networkId (string): (required)
+        - qualityRetentionProfileId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityRetentionProfiles'],
+            'operation': 'deleteNetworkCameraQualityRetentionProfile'
+        }
+        resource = f'/networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkCameraSchedules(self, networkId: str):
+        """
+        **Returns a list of all camera recording schedules.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-camera-schedules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['camera', 'configure', 'schedules'],
+            'operation': 'getNetworkCameraSchedules'
+        }
+        resource = f'/networks/{networkId}/camera/schedules'
+
+        return self._session.get(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/aio/api/insight.py` & `meraki-1.7.2/meraki/aio/api/insight.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,103 +1,114 @@
-class AsyncInsight:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def getOrganizationInsightMonitoredMediaServers(self, organizationId: str):
-		"""
-		**List the monitored media servers for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-servers
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'getOrganizationInsightMonitoredMediaServers'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
-
-		return self._session.get(metadata, resource)
-
-	def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
-		"""
-		**Add a media server to be monitored for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'createOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
-		"""
-		**Return a monitored media server for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'getOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
-		"""
-		**Update a monitored media server for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'updateOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
-		"""
-		**Delete a monitored media server from this organization**
-		https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'deleteOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		return self._session.delete(metadata, resource)
+class AsyncInsight:
+    def __init__(self, session):
+        super().__init__()
+        self._session = session
+        
+
+
+    def getOrganizationInsightMonitoredMediaServers(self, organizationId: str):
+        """
+        **List the monitored media servers for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-servers
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'getOrganizationInsightMonitoredMediaServers'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
+        """
+        **Add a media server to be monitored for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'createOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
+        """
+        **Return a monitored media server for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'getOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
+        """
+        **Update a monitored media server for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'updateOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
+        """
+        **Delete a monitored media server from this organization**
+        https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'deleteOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        return self._session.delete(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/aio/api/networks.py` & `meraki-1.7.2/meraki/aio/api/networks.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,1700 +1,1888 @@
-class AsyncNetworks:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def getNetwork(self, networkId: str):
-		"""
-		**Return a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'getNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetwork(self, networkId: str, **kwargs):
-		"""
-		**Update a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network
-		
-		- networkId (string): (required)
-		- name (string): The name of the network
-		- timeZone (string): The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
-		- tags (array): A list of tags to be applied to the network
-		- enrollmentString (string): A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
-		- notes (string): Add any notes or additional information about this network here.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'updateNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		body_params = ['name', 'timeZone', 'tags', 'enrollmentString', 'notes', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetwork(self, networkId: str):
-		"""
-		**Delete a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'deleteNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkAlertsSettings(self, networkId: str):
-		"""
-		**Return the alert configuration for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-alerts-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'alerts', 'settings'],
-			'operation': 'getNetworkAlertsSettings'
-		}
-		resource = f'/networks/{networkId}/alerts/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkAlertsSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the alert configuration for this network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-alerts-settings
-		
-		- networkId (string): (required)
-		- defaultDestinations (object): The network-wide destinations for all alerts on the network.
-		- alerts (array): Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'alerts', 'settings'],
-			'operation': 'updateNetworkAlertsSettings'
-		}
-		resource = f'/networks/{networkId}/alerts/settings'
-
-		body_params = ['defaultDestinations', 'alerts', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def bindNetwork(self, networkId: str, configTemplateId: str, **kwargs):
-		"""
-		**Bind a network to a template.**
-		https://developer.cisco.com/meraki/api-v1/#!bind-network
-		
-		- networkId (string): (required)
-		- configTemplateId (string): The ID of the template to which the network should be bound.
-		- autoBind (boolean): Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'bindNetwork'
-		}
-		resource = f'/networks/{networkId}/bind'
-
-		body_params = ['configTemplateId', 'autoBind', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkBluetoothClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the Bluetooth clients seen by APs in this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-clients
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- includeConnectivityHistory (boolean): Include the connectivity history for this client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'bluetoothClients'],
-			'operation': 'getNetworkBluetoothClients'
-		}
-		resource = f'/networks/{networkId}/bluetoothClients'
-
-		query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'includeConnectivityHistory', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkBluetoothClient(self, networkId: str, bluetoothClientId: str, **kwargs):
-		"""
-		**Return a Bluetooth client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-client
-		
-		- networkId (string): (required)
-		- bluetoothClientId (string): (required)
-		- includeConnectivityHistory (boolean): Include the connectivity history for this client
-		- connectivityHistoryTimespan (integer): The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'bluetoothClients'],
-			'operation': 'getNetworkBluetoothClient'
-		}
-		resource = f'/networks/{networkId}/bluetoothClients/{bluetoothClientId}'
-
-		query_params = ['includeConnectivityHistory', 'connectivityHistoryTimespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the clients that have used this network in the timespan**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients'],
-			'operation': 'getNetworkClients'
-		}
-		resource = f'/networks/{networkId}/clients'
-
-		query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClientsApplicationUsage(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the application usage data for clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients-application-usage
-		
-		- networkId (string): (required)
-		- clients (string): A list of client keys, MACs or IPs separated by comma.
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- ssidNumber (integer): An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'applicationUsage'],
-			'operation': 'getNetworkClientsApplicationUsage'
-		}
-		resource = f'/networks/{networkId}/clients/applicationUsage'
-
-		query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def provisionNetworkClients(self, networkId: str, clients: list, devicePolicy: str, **kwargs):
-		"""
-		**Provisions a client with a name and policy**
-		https://developer.cisco.com/meraki/api-v1/#!provision-network-clients
-		
-		- networkId (string): (required)
-		- clients (array): The array of clients to provision
-		- devicePolicy (string): The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
-		- groupPolicyId (string): The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
-		- policiesBySecurityAppliance (object): An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
-		- policiesBySsid (object): An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
-		"""
-
-		kwargs.update(locals())
-
-		if 'devicePolicy' in kwargs:
-			options = ['Group policy', 'Allowed', 'Blocked', 'Per connection', 'Normal']
-			assert kwargs['devicePolicy'] in options, f'''"devicePolicy" cannot be "{kwargs['devicePolicy']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients'],
-			'operation': 'provisionNetworkClients'
-		}
-		resource = f'/networks/{networkId}/clients/provision'
-
-		body_params = ['clients', 'devicePolicy', 'groupPolicyId', 'policiesBySecurityAppliance', 'policiesBySsid', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkClientsUsageHistories(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the usage histories for clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients-usage-histories
-		
-		- networkId (string): (required)
-		- clients (string): A list of client keys, MACs or IPs separated by comma.
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'usageHistories'],
-			'operation': 'getNetworkClientsUsageHistories'
-		}
-		resource = f'/networks/{networkId}/clients/usageHistories'
-
-		query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClient(self, networkId: str, clientId: str):
-		"""
-		**Return the client associated with the given identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients'],
-			'operation': 'getNetworkClient'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkClientPolicy(self, networkId: str, clientId: str):
-		"""
-		**Return the policy assigned to a client on the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-policy
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'policy'],
-			'operation': 'getNetworkClientPolicy'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/policy'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkClientPolicy(self, networkId: str, clientId: str, devicePolicy: str, **kwargs):
-		"""
-		**Update the policy assigned to a client on the network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-client-policy
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- devicePolicy (string): The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
-		- groupPolicyId (string): [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'policy'],
-			'operation': 'updateNetworkClientPolicy'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/policy'
-
-		body_params = ['devicePolicy', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str):
-		"""
-		**Return the splash authorization for a client, for each SSID they've associated with through splash**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-splash-authorization-status
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
-			'operation': 'getNetworkClientSplashAuthorizationStatus'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str, ssids: dict):
-		"""
-		**Update a client's splash authorization**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-client-splash-authorization-status
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- ssids (object): The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
-			'operation': 'updateNetworkClientSplashAuthorizationStatus'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
-
-		body_params = ['ssids', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkClientTrafficHistory(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the client's network traffic data over time**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-traffic-history
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'trafficHistory'],
-			'operation': 'getNetworkClientTrafficHistory'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/trafficHistory'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClientUsageHistory(self, networkId: str, clientId: str):
-		"""
-		**Return the client's daily usage history**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-usage-history
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'usageHistory'],
-			'operation': 'getNetworkClientUsageHistory'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/usageHistory'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkDevices(self, networkId: str):
-		"""
-		**List the devices in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-devices
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'getNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices'
-
-		return self._session.get(metadata, resource)
-
-	def claimNetworkDevices(self, networkId: str, serials: list):
-		"""
-		**Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)**
-		https://developer.cisco.com/meraki/api-v1/#!claim-network-devices
-		
-		- networkId (string): (required)
-		- serials (array): A list of serials of devices to claim
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'claimNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices/claim'
-
-		body_params = ['serials', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def removeNetworkDevices(self, networkId: str, serial: str):
-		"""
-		**Remove a single device**
-		https://developer.cisco.com/meraki/api-v1/#!remove-network-devices
-		
-		- networkId (string): (required)
-		- serial (string): The serial of a device
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'removeNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices/remove'
-
-		body_params = ['serial', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkEvents(self, networkId: str, total_pages=1, direction='prev', event_log_end_time=None, **kwargs):
-		"""
-		**List the events for the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-events
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" or "prev" (default) page
-		- event_log_end_time (string): ISO8601 Zulu/UTC time, to use in conjunction with startingAfter, to retrieve events within a time window
-		- productType (string): The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental
-		- includedEventTypes (array): A list of event types. The returned events will be filtered to only include events with these types.
-		- excludedEventTypes (array): A list of event types. The returned events will be filtered to exclude events with these types.
-		- deviceMac (string): The MAC address of the Meraki device which the list of events will be filtered with
-		- deviceSerial (string): The serial of the Meraki device which the list of events will be filtered with
-		- deviceName (string): The name of the Meraki device which the list of events will be filtered with
-		- clientIp (string): The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.
-		- clientMac (string): The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.
-		- clientName (string): The name, or partial name, of the client which the list of events will be filtered with
-		- smDeviceMac (string): The MAC address of the Systems Manager device which the list of events will be filtered with
-		- smDeviceName (string): The name of the Systems Manager device which the list of events will be filtered with
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'events'],
-			'operation': 'getNetworkEvents'
-		}
-		resource = f'/networks/{networkId}/events'
-
-		query_params = ['productType', 'includedEventTypes', 'excludedEventTypes', 'deviceMac', 'deviceSerial', 'deviceName', 'clientIp', 'clientMac', 'clientName', 'smDeviceMac', 'smDeviceName', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['includedEventTypes', 'excludedEventTypes', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction, event_log_end_time)
-
-	def getNetworkEventsEventTypes(self, networkId: str):
-		"""
-		**List the event type to human-readable description**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-events-event-types
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'events', 'eventTypes'],
-			'operation': 'getNetworkEventsEventTypes'
-		}
-		resource = f'/networks/{networkId}/events/eventTypes'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkFirmwareUpgrades(self, networkId: str):
-		"""
-		**Get current maintenance window for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-firmware-upgrades
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'firmwareUpgrades'],
-			'operation': 'getNetworkFirmwareUpgrades'
-		}
-		resource = f'/networks/{networkId}/firmwareUpgrades'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkFirmwareUpgrades(self, networkId: str, **kwargs):
-		"""
-		**Update current maintenance window for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-firmware-upgrades
-		
-		- networkId (string): (required)
-		- upgradeWindow (object): Upgrade window for devices in network
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'firmwareUpgrades'],
-			'operation': 'updateNetworkFirmwareUpgrades'
-		}
-		resource = f'/networks/{networkId}/firmwareUpgrades'
-
-		body_params = ['upgradeWindow', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkFloorPlans(self, networkId: str):
-		"""
-		**List the floor plans that belong to your network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plans
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'getNetworkFloorPlans'
-		}
-		resource = f'/networks/{networkId}/floorPlans'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkFloorPlan(self, networkId: str, name: str, imageContents: str, **kwargs):
-		"""
-		**Upload a floor plan**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-floor-plan
-		
-		- networkId (string): (required)
-		- name (string): The name of your floor plan.
-		- imageContents (string): The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
-		- center (object): The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
-		- bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
-		- bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
-		- topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
-		- topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'createNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans'
-
-		body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkFloorPlan(self, networkId: str, floorPlanId: str):
-		"""
-		**Find a floor plan by ID**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'getNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkFloorPlan(self, networkId: str, floorPlanId: str, **kwargs):
-		"""
-		**Update a floor plan's geolocation and other meta data**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		- name (string): The name of your floor plan.
-		- center (object): The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
-		- bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
-		- bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
-		- topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
-		- topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
-		- imageContents (string): The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'updateNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkFloorPlan(self, networkId: str, floorPlanId: str):
-		"""
-		**Destroy a floor plan**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'deleteNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkGroupPolicies(self, networkId: str):
-		"""
-		**List the group policies in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-group-policies
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'getNetworkGroupPolicies'
-		}
-		resource = f'/networks/{networkId}/groupPolicies'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkGroupPolicy(self, networkId: str, name: str, **kwargs):
-		"""
-		**Create a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-group-policy
-		
-		- networkId (string): (required)
-		- name (string): The name for your group policy. Required.
-		- scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
-
-		- bandwidth (object):     The bandwidth settings for clients bound to your group policy.
-
-		- firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
-
-		- contentFiltering (object): The content filtering settings for your group policy
-		- splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
-		- vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
-		- bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
-		"""
-
-		kwargs.update(locals())
-
-		if 'splashAuthSettings' in kwargs:
-			options = ['network default', 'bypass']
-			assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'createNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies'
-
-		body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
-		"""
-		**Display a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'getNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkGroupPolicy(self, networkId: str, groupPolicyId: str, **kwargs):
-		"""
-		**Update a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		- name (string): The name for your group policy.
-		- scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
-
-		- bandwidth (object):     The bandwidth settings for clients bound to your group policy.
-
-		- firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
-
-		- contentFiltering (object): The content filtering settings for your group policy
-		- splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
-		- vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
-		- bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
-		"""
-
-		kwargs.update(locals())
-
-		if 'splashAuthSettings' in kwargs:
-			options = ['network default', 'bypass']
-			assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'updateNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
-		"""
-		**Delete a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'deleteNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkMerakiAuthUsers(self, networkId: str):
-		"""
-		**List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-users
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'getNetworkMerakiAuthUsers'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkMerakiAuthUser(self, networkId: str, email: str, name: str, password: str, authorizations: list, **kwargs):
-		"""
-		**Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- email (string): Email address of the user
-		- name (string): Name of the user
-		- password (string): The password for this user account
-		- authorizations (array): Authorization zones and expiration dates for the user.
-		- accountType (string): Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'.
-		- emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
-		"""
-
-		kwargs.update(locals())
-
-		if 'accountType' in kwargs:
-			options = ['Guest', '802.1X', 'Client VPN']
-			assert kwargs['accountType'] in options, f'''"accountType" cannot be "{kwargs['accountType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'createNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers'
-
-		body_params = ['email', 'name', 'password', 'accountType', 'emailPasswordToUser', 'authorizations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
-		"""
-		**Return the Meraki Auth splash guest, RADIUS, or client VPN user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'getNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		return self._session.get(metadata, resource)
-
-	def deleteNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
-		"""
-		**Deauthorize a user**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'deleteNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		return self._session.delete(metadata, resource)
-
-	def updateNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str, **kwargs):
-		"""
-		**Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		- name (string): Name of the user
-		- password (string): The password for this user account
-		- emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
-		- authorizations (array): Authorization zones and expiration dates for the user.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'updateNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		body_params = ['name', 'password', 'emailPasswordToUser', 'authorizations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkMqttBrokers(self, networkId: str):
-		"""
-		**List the MQTT brokers for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-brokers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'getNetworkMqttBrokers'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkMqttBroker(self, networkId: str, name: str, host: str, port: int):
-		"""
-		**Add an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- name (string): Name of the MQTT broker
-		- host (string): Host name/IP address where MQTT broker runs
-		- port (integer): Host port though which MQTT broker can be reached
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'createNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers'
-
-		body_params = ['name', 'host', 'port', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
-		"""
-		**Return an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'getNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkMqttBroker(self, networkId: str, mqttBrokerId: str, **kwargs):
-		"""
-		**Update an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		- name (string): Name of the mqtt config
-		- host (string): Host name where mqtt broker runs
-		- port (integer): Host port though which mqtt broker can be reached
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'updateNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		body_params = ['name', 'host', 'port', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
-		"""
-		**Delete an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'deleteNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkNetflow(self, networkId: str):
-		"""
-		**Return the NetFlow traffic reporting settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-netflow
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'netflow'],
-			'operation': 'getNetworkNetflow'
-		}
-		resource = f'/networks/{networkId}/netflow'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkNetflow(self, networkId: str, **kwargs):
-		"""
-		**Update the NetFlow traffic reporting settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-netflow
-		
-		- networkId (string): (required)
-		- reportingEnabled (boolean): Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
-		- collectorIp (string): The IPv4 address of the NetFlow collector.
-		- collectorPort (integer): The port that the NetFlow collector will be listening on.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'netflow'],
-			'operation': 'updateNetworkNetflow'
-		}
-		resource = f'/networks/{networkId}/netflow'
-
-		body_params = ['reportingEnabled', 'collectorIp', 'collectorPort', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkNetworkHealthChannelUtilization(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Get the channel utilization over each radio for all APs in a network.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-network-health-channel-utilization
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'networkHealth', 'channelUtilization'],
-			'operation': 'getNetworkNetworkHealthChannelUtilization'
-		}
-		resource = f'/networks/{networkId}/networkHealth/channelUtilization'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkPiiPiiKeys(self, networkId: str, **kwargs):
-		"""
-		**List the keys required to access Personally Identifiable Information (PII) for a given identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-pii-keys
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'piiKeys'],
-			'operation': 'getNetworkPiiPiiKeys'
-		}
-		resource = f'/networks/{networkId}/pii/piiKeys'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkPiiRequests(self, networkId: str):
-		"""
-		**List the PII requests for this network or organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-requests
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'getNetworkPiiRequests'
-		}
-		resource = f'/networks/{networkId}/pii/requests'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkPiiRequest(self, networkId: str, **kwargs):
-		"""
-		**Submit a new delete or restrict processing PII request**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-pii-request
-		
-		- networkId (string): (required)
-		- type (string): One of "delete" or "restrict processing"
-		- datasets (array): The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
-		- username (string): The username of a network log in. Only applies to "delete" requests.
-		- email (string): The email of a network user account. Only applies to "delete" requests.
-		- mac (string): The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
-		- smDeviceId (string): The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
-		- smUserId (string): The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
-		"""
-
-		kwargs.update(locals())
-
-		if 'type' in kwargs:
-			options = ['delete', 'restrict processing']
-			assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'createNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests'
-
-		body_params = ['type', 'datasets', 'username', 'email', 'mac', 'smDeviceId', 'smUserId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkPiiRequest(self, networkId: str, requestId: str):
-		"""
-		**Return a PII request**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-request
-		
-		- networkId (string): (required)
-		- requestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'getNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests/{requestId}'
-
-		return self._session.get(metadata, resource)
-
-	def deleteNetworkPiiRequest(self, networkId: str, requestId: str):
-		"""
-		**Delete a restrict processing PII request**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-pii-request
-		
-		- networkId (string): (required)
-		- requestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'deleteNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests/{requestId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkPiiSmDevicesForKey(self, networkId: str, **kwargs):
-		"""
-		**Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-devices-for-key
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'smDevicesForKey'],
-			'operation': 'getNetworkPiiSmDevicesForKey'
-		}
-		resource = f'/networks/{networkId}/pii/smDevicesForKey'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkPiiSmOwnersForKey(self, networkId: str, **kwargs):
-		"""
-		**Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-owners-for-key
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'smOwnersForKey'],
-			'operation': 'getNetworkPiiSmOwnersForKey'
-		}
-		resource = f'/networks/{networkId}/pii/smOwnersForKey'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkSettings(self, networkId: str):
-		"""
-		**Return the settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'settings'],
-			'operation': 'getNetworkSettings'
-		}
-		resource = f'/networks/{networkId}/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-settings
-		
-		- networkId (string): (required)
-		- localStatusPageEnabled (boolean): Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
-		- remoteStatusPageEnabled (boolean): Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
-		- secureConnect (object): A hash of SecureConnect options applied to the Network.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'settings'],
-			'operation': 'updateNetworkSettings'
-		}
-		resource = f'/networks/{networkId}/settings'
-
-		body_params = ['localStatusPageEnabled', 'remoteStatusPageEnabled', 'secureConnect', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkSnmp(self, networkId: str):
-		"""
-		**Return the SNMP settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-snmp
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'snmp'],
-			'operation': 'getNetworkSnmp'
-		}
-		resource = f'/networks/{networkId}/snmp'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSnmp(self, networkId: str, **kwargs):
-		"""
-		**Update the SNMP settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-snmp
-		
-		- networkId (string): (required)
-		- access (string): The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
-		- communityString (string): The SNMP community string. Only relevant if 'access' is set to 'community'.
-		- users (array): The list of SNMP users. Only relevant if 'access' is set to 'users'.
-		"""
-
-		kwargs.update(locals())
-
-		if 'access' in kwargs:
-			options = ['none', 'community', 'users']
-			assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'snmp'],
-			'operation': 'updateNetworkSnmp'
-		}
-		resource = f'/networks/{networkId}/snmp'
-
-		body_params = ['access', 'communityString', 'users', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkSplashLoginAttempts(self, networkId: str, **kwargs):
-		"""
-		**List the splash login attempts for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-splash-login-attempts
-		
-		- networkId (string): (required)
-		- ssidNumber (integer): Only return the login attempts for the specified SSID
-		- loginIdentifier (string): The username, email, or phone number used during login
-		- timespan (integer): The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'splashLoginAttempts'],
-			'operation': 'getNetworkSplashLoginAttempts'
-		}
-		resource = f'/networks/{networkId}/splashLoginAttempts'
-
-		query_params = ['ssidNumber', 'loginIdentifier', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def splitNetwork(self, networkId: str):
-		"""
-		**Split a combined network into individual networks for each type of device**
-		https://developer.cisco.com/meraki/api-v1/#!split-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'splitNetwork'
-		}
-		resource = f'/networks/{networkId}/split'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSyslogServers(self, networkId: str):
-		"""
-		**List the syslog servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-syslog-servers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'syslogServers'],
-			'operation': 'getNetworkSyslogServers'
-		}
-		resource = f'/networks/{networkId}/syslogServers'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSyslogServers(self, networkId: str, servers: list):
-		"""
-		**Update the syslog servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-syslog-servers
-		
-		- networkId (string): (required)
-		- servers (array): A list of the syslog servers for this network
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'syslogServers'],
-			'operation': 'updateNetworkSyslogServers'
-		}
-		resource = f'/networks/{networkId}/syslogServers'
-
-		body_params = ['servers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkTraffic(self, networkId: str, **kwargs):
-		"""
-		**Return the traffic analysis data for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.
-		- deviceType (string): Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.
-		"""
-
-		kwargs.update(locals())
-
-		if 'deviceType' in kwargs:
-			options = ['combined', 'wireless', 'switch', 'appliance']
-			assert kwargs['deviceType'] in options, f'''"deviceType" cannot be "{kwargs['deviceType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'traffic'],
-			'operation': 'getNetworkTraffic'
-		}
-		resource = f'/networks/{networkId}/traffic'
-
-		query_params = ['t0', 'timespan', 'deviceType', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkTrafficAnalysis(self, networkId: str):
-		"""
-		**Return the traffic analysis settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-analysis
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficAnalysis'],
-			'operation': 'getNetworkTrafficAnalysis'
-		}
-		resource = f'/networks/{networkId}/trafficAnalysis'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkTrafficAnalysis(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic analysis settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-traffic-analysis
-		
-		- networkId (string): (required)
-		- mode (string):     The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
-    'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
-
-		- customPieChartItems (array): The list of items that make up the custom pie chart for traffic reporting.
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['disabled', 'basic', 'detailed']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficAnalysis'],
-			'operation': 'updateNetworkTrafficAnalysis'
-		}
-		resource = f'/networks/{networkId}/trafficAnalysis'
-
-		body_params = ['mode', 'customPieChartItems', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkTrafficShapingApplicationCategories(self, networkId: str):
-		"""
-		**Returns the application categories for traffic shaping rules.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-application-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficShaping', 'applicationCategories'],
-			'operation': 'getNetworkTrafficShapingApplicationCategories'
-		}
-		resource = f'/networks/{networkId}/trafficShaping/applicationCategories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkTrafficShapingDscpTaggingOptions(self, networkId: str):
-		"""
-		**Returns the available DSCP tagging options for your traffic shaping rules.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-dscp-tagging-options
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficShaping', 'dscpTaggingOptions'],
-			'operation': 'getNetworkTrafficShapingDscpTaggingOptions'
-		}
-		resource = f'/networks/{networkId}/trafficShaping/dscpTaggingOptions'
-
-		return self._session.get(metadata, resource)
-
-	def unbindNetwork(self, networkId: str):
-		"""
-		**Unbind a network from a template.**
-		https://developer.cisco.com/meraki/api-v1/#!unbind-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'unbindNetwork'
-		}
-		resource = f'/networks/{networkId}/unbind'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkWebhooksHttpServers(self, networkId: str):
-		"""
-		**List the HTTP servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-servers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'getNetworkWebhooksHttpServers'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkWebhooksHttpServer(self, networkId: str, name: str, url: str, **kwargs):
-		"""
-		**Add an HTTP server to a network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- name (string): A name for easy reference to the HTTP server
-		- url (string): The URL of the HTTP server
-		- sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'createNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers'
-
-		body_params = ['name', 'url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
-		"""
-		**Return an HTTP server for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'getNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str, **kwargs):
-		"""
-		**Update an HTTP server**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		- name (string): A name for easy reference to the HTTP server
-		- url (string): The URL of the HTTP server
-		- sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'updateNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		body_params = ['name', 'url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
-		"""
-		**Delete an HTTP server from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'deleteNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		return self._session.delete(metadata, resource)
-
-	def createNetworkWebhooksWebhookTest(self, networkId: str, url: str, **kwargs):
-		"""
-		**Send a test webhook for a network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-webhook-test
-		
-		- networkId (string): (required)
-		- url (string): The URL where the test webhook will be sent
-		- sharedSecret (string): The shared secret the test webhook will send. Optional. Defaults to an empty string.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
-			'operation': 'createNetworkWebhooksWebhookTest'
-		}
-		resource = f'/networks/{networkId}/webhooks/webhookTests'
-
-		body_params = ['url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkWebhooksWebhookTest(self, networkId: str, webhookTestId: str):
-		"""
-		**Return the status of a webhook test for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-webhook-test
-		
-		- networkId (string): (required)
-		- webhookTestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
-			'operation': 'getNetworkWebhooksWebhookTest'
-		}
-		resource = f'/networks/{networkId}/webhooks/webhookTests/{webhookTestId}'
-
-		return self._session.get(metadata, resource)
+class AsyncNetworks:
+    def __init__(self, session):
+        super().__init__()
+        self._session = session
+        
+
+
+    def getNetwork(self, networkId: str):
+        """
+        **Return a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'getNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetwork(self, networkId: str, **kwargs):
+        """
+        **Update a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network
+
+        - networkId (string): (required)
+        - name (string): The name of the network
+        - timeZone (string): The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
+        - tags (array): A list of tags to be applied to the network
+        - enrollmentString (string): A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
+        - notes (string): Add any notes or additional information about this network here.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'updateNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        body_params = ['name', 'timeZone', 'tags', 'enrollmentString', 'notes', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetwork(self, networkId: str):
+        """
+        **Delete a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'deleteNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkAlertsSettings(self, networkId: str):
+        """
+        **Return the alert configuration for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-alerts-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'alerts', 'settings'],
+            'operation': 'getNetworkAlertsSettings'
+        }
+        resource = f'/networks/{networkId}/alerts/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkAlertsSettings(self, networkId: str, **kwargs):
+        """
+        **Update the alert configuration for this network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-alerts-settings
+
+        - networkId (string): (required)
+        - defaultDestinations (object): The network-wide destinations for all alerts on the network.
+        - alerts (array): Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'alerts', 'settings'],
+            'operation': 'updateNetworkAlertsSettings'
+        }
+        resource = f'/networks/{networkId}/alerts/settings'
+
+        body_params = ['defaultDestinations', 'alerts', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def bindNetwork(self, networkId: str, configTemplateId: str, **kwargs):
+        """
+        **Bind a network to a template.**
+        https://developer.cisco.com/meraki/api-v1/#!bind-network
+
+        - networkId (string): (required)
+        - configTemplateId (string): The ID of the template to which the network should be bound.
+        - autoBind (boolean): Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'bindNetwork'
+        }
+        resource = f'/networks/{networkId}/bind'
+
+        body_params = ['configTemplateId', 'autoBind', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkBluetoothClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the Bluetooth clients seen by APs in this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-clients
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - includeConnectivityHistory (boolean): Include the connectivity history for this client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'bluetoothClients'],
+            'operation': 'getNetworkBluetoothClients'
+        }
+        resource = f'/networks/{networkId}/bluetoothClients'
+
+        query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'includeConnectivityHistory', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkBluetoothClient(self, networkId: str, bluetoothClientId: str, **kwargs):
+        """
+        **Return a Bluetooth client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-client
+
+        - networkId (string): (required)
+        - bluetoothClientId (string): (required)
+        - includeConnectivityHistory (boolean): Include the connectivity history for this client
+        - connectivityHistoryTimespan (integer): The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'bluetoothClients'],
+            'operation': 'getNetworkBluetoothClient'
+        }
+        resource = f'/networks/{networkId}/bluetoothClients/{bluetoothClientId}'
+
+        query_params = ['includeConnectivityHistory', 'connectivityHistoryTimespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the clients that have used this network in the timespan**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients'],
+            'operation': 'getNetworkClients'
+        }
+        resource = f'/networks/{networkId}/clients'
+
+        query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClientsApplicationUsage(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the application usage data for clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients-application-usage
+
+        - networkId (string): (required)
+        - clients (string): A list of client keys, MACs or IPs separated by comma.
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - ssidNumber (integer): An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'applicationUsage'],
+            'operation': 'getNetworkClientsApplicationUsage'
+        }
+        resource = f'/networks/{networkId}/clients/applicationUsage'
+
+        query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def provisionNetworkClients(self, networkId: str, clients: list, devicePolicy: str, **kwargs):
+        """
+        **Provisions a client with a name and policy**
+        https://developer.cisco.com/meraki/api-v1/#!provision-network-clients
+
+        - networkId (string): (required)
+        - clients (array): The array of clients to provision
+        - devicePolicy (string): The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
+        - groupPolicyId (string): The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
+        - policiesBySecurityAppliance (object): An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
+        - policiesBySsid (object): An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
+        """
+
+        kwargs.update(locals())
+
+        if 'devicePolicy' in kwargs:
+            options = ['Group policy', 'Allowed', 'Blocked', 'Per connection', 'Normal']
+            assert kwargs['devicePolicy'] in options, f'''"devicePolicy" cannot be "{kwargs['devicePolicy']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients'],
+            'operation': 'provisionNetworkClients'
+        }
+        resource = f'/networks/{networkId}/clients/provision'
+
+        body_params = ['clients', 'devicePolicy', 'groupPolicyId', 'policiesBySecurityAppliance', 'policiesBySsid', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkClientsUsageHistories(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the usage histories for clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients-usage-histories
+
+        - networkId (string): (required)
+        - clients (string): A list of client keys, MACs or IPs separated by comma.
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'usageHistories'],
+            'operation': 'getNetworkClientsUsageHistories'
+        }
+        resource = f'/networks/{networkId}/clients/usageHistories'
+
+        query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClient(self, networkId: str, clientId: str):
+        """
+        **Return the client associated with the given identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients'],
+            'operation': 'getNetworkClient'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkClientPolicy(self, networkId: str, clientId: str):
+        """
+        **Return the policy assigned to a client on the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-policy
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'policy'],
+            'operation': 'getNetworkClientPolicy'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/policy'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkClientPolicy(self, networkId: str, clientId: str, devicePolicy: str, **kwargs):
+        """
+        **Update the policy assigned to a client on the network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-client-policy
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - devicePolicy (string): The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
+        - groupPolicyId (string): [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'policy'],
+            'operation': 'updateNetworkClientPolicy'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/policy'
+
+        body_params = ['devicePolicy', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str):
+        """
+        **Return the splash authorization for a client, for each SSID they've associated with through splash**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-splash-authorization-status
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
+            'operation': 'getNetworkClientSplashAuthorizationStatus'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str, ssids: dict):
+        """
+        **Update a client's splash authorization**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-client-splash-authorization-status
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - ssids (object): The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
+            'operation': 'updateNetworkClientSplashAuthorizationStatus'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
+
+        body_params = ['ssids', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkClientTrafficHistory(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the client's network traffic data over time**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-traffic-history
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'trafficHistory'],
+            'operation': 'getNetworkClientTrafficHistory'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/trafficHistory'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClientUsageHistory(self, networkId: str, clientId: str):
+        """
+        **Return the client's daily usage history**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-usage-history
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'usageHistory'],
+            'operation': 'getNetworkClientUsageHistory'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/usageHistory'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkDevices(self, networkId: str):
+        """
+        **List the devices in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-devices
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'getNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def claimNetworkDevices(self, networkId: str, serials: list):
+        """
+        **Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)**
+        https://developer.cisco.com/meraki/api-v1/#!claim-network-devices
+
+        - networkId (string): (required)
+        - serials (array): A list of serials of devices to claim
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'claimNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices/claim'
+
+        body_params = ['serials', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def removeNetworkDevices(self, networkId: str, serial: str):
+        """
+        **Remove a single device**
+        https://developer.cisco.com/meraki/api-v1/#!remove-network-devices
+
+        - networkId (string): (required)
+        - serial (string): The serial of a device
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'removeNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices/remove'
+
+        body_params = ['serial', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkEvents(self, networkId: str, total_pages=1, direction='prev', event_log_end_time=None, **kwargs):
+        """
+        **List the events for the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-events
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" or "prev" (default) page
+        - event_log_end_time (string): ISO8601 Zulu/UTC time, to use in conjunction with startingAfter, to retrieve events within a time window
+        - productType (string): The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental
+        - includedEventTypes (array): A list of event types. The returned events will be filtered to only include events with these types.
+        - excludedEventTypes (array): A list of event types. The returned events will be filtered to exclude events with these types.
+        - deviceMac (string): The MAC address of the Meraki device which the list of events will be filtered with
+        - deviceSerial (string): The serial of the Meraki device which the list of events will be filtered with
+        - deviceName (string): The name of the Meraki device which the list of events will be filtered with
+        - clientIp (string): The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.
+        - clientMac (string): The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.
+        - clientName (string): The name, or partial name, of the client which the list of events will be filtered with
+        - smDeviceMac (string): The MAC address of the Systems Manager device which the list of events will be filtered with
+        - smDeviceName (string): The name of the Systems Manager device which the list of events will be filtered with
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'events'],
+            'operation': 'getNetworkEvents'
+        }
+        resource = f'/networks/{networkId}/events'
+
+        query_params = ['productType', 'includedEventTypes', 'excludedEventTypes', 'deviceMac', 'deviceSerial', 'deviceName', 'clientIp', 'clientMac', 'clientName', 'smDeviceMac', 'smDeviceName', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['includedEventTypes', 'excludedEventTypes', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction, event_log_end_time)
+        
+
+
+    def getNetworkEventsEventTypes(self, networkId: str):
+        """
+        **List the event type to human-readable description**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-events-event-types
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'events', 'eventTypes'],
+            'operation': 'getNetworkEventsEventTypes'
+        }
+        resource = f'/networks/{networkId}/events/eventTypes'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkFirmwareUpgrades(self, networkId: str):
+        """
+        **Get firmware upgrade information for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-firmware-upgrades
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades'],
+            'operation': 'getNetworkFirmwareUpgrades'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkFirmwareUpgrades(self, networkId: str, **kwargs):
+        """
+        **Update firmware upgrade information for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-firmware-upgrades
+
+        - networkId (string): (required)
+        - upgradeWindow (object): Upgrade window for devices in network
+        - timezone (string): The timezone for the network
+        - products (object): Contains information about the network to update
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades'],
+            'operation': 'updateNetworkFirmwareUpgrades'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades'
+
+        body_params = ['upgradeWindow', 'timezone', 'products', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def createNetworkFirmwareUpgradesRollback(self, networkId: str, reasons: list, **kwargs):
+        """
+        **Rollback a Firmware Upgrade For A Network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-firmware-upgrades-rollback
+
+        - networkId (string): (required)
+        - reasons (array): Reasons for the rollback
+        - product (string): Product type to rollback (if the network is a combined network)
+        - time (string): Scheduled time for the rollback
+        - toVersion (object): Version to downgrade to (if the network has firmware flexibility)
+        """
+
+        kwargs.update(locals())
+
+        if 'product' in kwargs:
+            options = ['wireless', 'switch', 'appliance', 'camera', 'vmxHost', 'cellularGateway']
+            assert kwargs['product'] in options, f'''"product" cannot be "{kwargs['product']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades', 'rollbacks'],
+            'operation': 'createNetworkFirmwareUpgradesRollback'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades/rollbacks'
+
+        body_params = ['product', 'time', 'reasons', 'toVersion', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkFloorPlans(self, networkId: str):
+        """
+        **List the floor plans that belong to your network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plans
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'getNetworkFloorPlans'
+        }
+        resource = f'/networks/{networkId}/floorPlans'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkFloorPlan(self, networkId: str, name: str, imageContents: str, **kwargs):
+        """
+        **Upload a floor plan**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-floor-plan
+
+        - networkId (string): (required)
+        - name (string): The name of your floor plan.
+        - imageContents (string): The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
+        - center (object): The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
+        - bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
+        - bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
+        - topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
+        - topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'createNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans'
+
+        body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkFloorPlan(self, networkId: str, floorPlanId: str):
+        """
+        **Find a floor plan by ID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'getNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkFloorPlan(self, networkId: str, floorPlanId: str, **kwargs):
+        """
+        **Update a floor plan's geolocation and other meta data**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        - name (string): The name of your floor plan.
+        - center (object): The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
+        - bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
+        - bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
+        - topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
+        - topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
+        - imageContents (string): The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'updateNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkFloorPlan(self, networkId: str, floorPlanId: str):
+        """
+        **Destroy a floor plan**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'deleteNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkGroupPolicies(self, networkId: str):
+        """
+        **List the group policies in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-group-policies
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'getNetworkGroupPolicies'
+        }
+        resource = f'/networks/{networkId}/groupPolicies'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkGroupPolicy(self, networkId: str, name: str, **kwargs):
+        """
+        **Create a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-group-policy
+
+        - networkId (string): (required)
+        - name (string): The name for your group policy. Required.
+        - scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
+
+        - bandwidth (object):     The bandwidth settings for clients bound to your group policy.
+
+        - firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
+
+        - contentFiltering (object): The content filtering settings for your group policy
+        - splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
+        - vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
+        - bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
+        """
+
+        kwargs.update(locals())
+
+        if 'splashAuthSettings' in kwargs:
+            options = ['network default', 'bypass']
+            assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'createNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies'
+
+        body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
+        """
+        **Display a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'getNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkGroupPolicy(self, networkId: str, groupPolicyId: str, **kwargs):
+        """
+        **Update a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        - name (string): The name for your group policy.
+        - scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
+
+        - bandwidth (object):     The bandwidth settings for clients bound to your group policy.
+
+        - firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
+
+        - contentFiltering (object): The content filtering settings for your group policy
+        - splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
+        - vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
+        - bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
+        """
+
+        kwargs.update(locals())
+
+        if 'splashAuthSettings' in kwargs:
+            options = ['network default', 'bypass']
+            assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'updateNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
+        """
+        **Delete a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'deleteNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkMerakiAuthUsers(self, networkId: str):
+        """
+        **List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-users
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'getNetworkMerakiAuthUsers'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkMerakiAuthUser(self, networkId: str, email: str, name: str, password: str, authorizations: list, **kwargs):
+        """
+        **Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - email (string): Email address of the user
+        - name (string): Name of the user
+        - password (string): The password for this user account
+        - authorizations (array): Authorization zones and expiration dates for the user.
+        - accountType (string): Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'.
+        - emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
+        """
+
+        kwargs.update(locals())
+
+        if 'accountType' in kwargs:
+            options = ['Guest', '802.1X', 'Client VPN']
+            assert kwargs['accountType'] in options, f'''"accountType" cannot be "{kwargs['accountType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'createNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers'
+
+        body_params = ['email', 'name', 'password', 'accountType', 'emailPasswordToUser', 'authorizations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
+        """
+        **Return the Meraki Auth splash guest, RADIUS, or client VPN user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'getNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def deleteNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
+        """
+        **Deauthorize a user**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'deleteNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def updateNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str, **kwargs):
+        """
+        **Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        - name (string): Name of the user
+        - password (string): The password for this user account
+        - emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
+        - authorizations (array): Authorization zones and expiration dates for the user.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'updateNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        body_params = ['name', 'password', 'emailPasswordToUser', 'authorizations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkMqttBrokers(self, networkId: str):
+        """
+        **List the MQTT brokers for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-brokers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'getNetworkMqttBrokers'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkMqttBroker(self, networkId: str, name: str, host: str, port: int):
+        """
+        **Add an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-mqtt-broker
+
+        - networkId (string): (required)
+        - name (string): Name of the MQTT broker
+        - host (string): Host name/IP address where MQTT broker runs
+        - port (integer): Host port though which MQTT broker can be reached
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'createNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers'
+
+        body_params = ['name', 'host', 'port', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
+        """
+        **Return an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'getNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkMqttBroker(self, networkId: str, mqttBrokerId: str, **kwargs):
+        """
+        **Update an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        - name (string): Name of the mqtt config
+        - host (string): Host name where mqtt broker runs
+        - port (integer): Host port though which mqtt broker can be reached
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'updateNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        body_params = ['name', 'host', 'port', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
+        """
+        **Delete an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'deleteNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkNetflow(self, networkId: str):
+        """
+        **Return the NetFlow traffic reporting settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-netflow
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'netflow'],
+            'operation': 'getNetworkNetflow'
+        }
+        resource = f'/networks/{networkId}/netflow'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkNetflow(self, networkId: str, **kwargs):
+        """
+        **Update the NetFlow traffic reporting settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-netflow
+
+        - networkId (string): (required)
+        - reportingEnabled (boolean): Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
+        - collectorIp (string): The IPv4 address of the NetFlow collector.
+        - collectorPort (integer): The port that the NetFlow collector will be listening on.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'netflow'],
+            'operation': 'updateNetworkNetflow'
+        }
+        resource = f'/networks/{networkId}/netflow'
+
+        body_params = ['reportingEnabled', 'collectorIp', 'collectorPort', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkNetworkHealthChannelUtilization(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Get the channel utilization over each radio for all APs in a network.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-network-health-channel-utilization
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'networkHealth', 'channelUtilization'],
+            'operation': 'getNetworkNetworkHealthChannelUtilization'
+        }
+        resource = f'/networks/{networkId}/networkHealth/channelUtilization'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkPiiPiiKeys(self, networkId: str, **kwargs):
+        """
+        **List the keys required to access Personally Identifiable Information (PII) for a given identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-pii-keys
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'piiKeys'],
+            'operation': 'getNetworkPiiPiiKeys'
+        }
+        resource = f'/networks/{networkId}/pii/piiKeys'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkPiiRequests(self, networkId: str):
+        """
+        **List the PII requests for this network or organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-requests
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'getNetworkPiiRequests'
+        }
+        resource = f'/networks/{networkId}/pii/requests'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkPiiRequest(self, networkId: str, **kwargs):
+        """
+        **Submit a new delete or restrict processing PII request**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-pii-request
+
+        - networkId (string): (required)
+        - type (string): One of "delete" or "restrict processing"
+        - datasets (array): The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
+        - username (string): The username of a network log in. Only applies to "delete" requests.
+        - email (string): The email of a network user account. Only applies to "delete" requests.
+        - mac (string): The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
+        - smDeviceId (string): The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
+        - smUserId (string): The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
+        """
+
+        kwargs.update(locals())
+
+        if 'type' in kwargs:
+            options = ['delete', 'restrict processing']
+            assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'createNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests'
+
+        body_params = ['type', 'datasets', 'username', 'email', 'mac', 'smDeviceId', 'smUserId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkPiiRequest(self, networkId: str, requestId: str):
+        """
+        **Return a PII request**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-request
+
+        - networkId (string): (required)
+        - requestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'getNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests/{requestId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def deleteNetworkPiiRequest(self, networkId: str, requestId: str):
+        """
+        **Delete a restrict processing PII request**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-pii-request
+
+        - networkId (string): (required)
+        - requestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'deleteNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests/{requestId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkPiiSmDevicesForKey(self, networkId: str, **kwargs):
+        """
+        **Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-devices-for-key
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'smDevicesForKey'],
+            'operation': 'getNetworkPiiSmDevicesForKey'
+        }
+        resource = f'/networks/{networkId}/pii/smDevicesForKey'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkPiiSmOwnersForKey(self, networkId: str, **kwargs):
+        """
+        **Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-owners-for-key
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'smOwnersForKey'],
+            'operation': 'getNetworkPiiSmOwnersForKey'
+        }
+        resource = f'/networks/{networkId}/pii/smOwnersForKey'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkSettings(self, networkId: str):
+        """
+        **Return the settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'settings'],
+            'operation': 'getNetworkSettings'
+        }
+        resource = f'/networks/{networkId}/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSettings(self, networkId: str, **kwargs):
+        """
+        **Update the settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-settings
+
+        - networkId (string): (required)
+        - localStatusPageEnabled (boolean): Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
+        - remoteStatusPageEnabled (boolean): Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
+        - secureConnect (object): A hash of SecureConnect options applied to the Network.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'settings'],
+            'operation': 'updateNetworkSettings'
+        }
+        resource = f'/networks/{networkId}/settings'
+
+        body_params = ['localStatusPageEnabled', 'remoteStatusPageEnabled', 'secureConnect', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkSnmp(self, networkId: str):
+        """
+        **Return the SNMP settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-snmp
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'snmp'],
+            'operation': 'getNetworkSnmp'
+        }
+        resource = f'/networks/{networkId}/snmp'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSnmp(self, networkId: str, **kwargs):
+        """
+        **Update the SNMP settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-snmp
+
+        - networkId (string): (required)
+        - access (string): The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
+        - communityString (string): The SNMP community string. Only relevant if 'access' is set to 'community'.
+        - users (array): The list of SNMP users. Only relevant if 'access' is set to 'users'.
+        """
+
+        kwargs.update(locals())
+
+        if 'access' in kwargs:
+            options = ['none', 'community', 'users']
+            assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'snmp'],
+            'operation': 'updateNetworkSnmp'
+        }
+        resource = f'/networks/{networkId}/snmp'
+
+        body_params = ['access', 'communityString', 'users', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkSplashLoginAttempts(self, networkId: str, **kwargs):
+        """
+        **List the splash login attempts for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-splash-login-attempts
+
+        - networkId (string): (required)
+        - ssidNumber (integer): Only return the login attempts for the specified SSID
+        - loginIdentifier (string): The username, email, or phone number used during login
+        - timespan (integer): The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'splashLoginAttempts'],
+            'operation': 'getNetworkSplashLoginAttempts'
+        }
+        resource = f'/networks/{networkId}/splashLoginAttempts'
+
+        query_params = ['ssidNumber', 'loginIdentifier', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def splitNetwork(self, networkId: str):
+        """
+        **Split a combined network into individual networks for each type of device**
+        https://developer.cisco.com/meraki/api-v1/#!split-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'splitNetwork'
+        }
+        resource = f'/networks/{networkId}/split'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSyslogServers(self, networkId: str):
+        """
+        **List the syslog servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-syslog-servers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'syslogServers'],
+            'operation': 'getNetworkSyslogServers'
+        }
+        resource = f'/networks/{networkId}/syslogServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSyslogServers(self, networkId: str, servers: list):
+        """
+        **Update the syslog servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-syslog-servers
+
+        - networkId (string): (required)
+        - servers (array): A list of the syslog servers for this network
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'syslogServers'],
+            'operation': 'updateNetworkSyslogServers'
+        }
+        resource = f'/networks/{networkId}/syslogServers'
+
+        body_params = ['servers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkTraffic(self, networkId: str, **kwargs):
+        """
+        **Return the traffic analysis data for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.
+        - deviceType (string): Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.
+        """
+
+        kwargs.update(locals())
+
+        if 'deviceType' in kwargs:
+            options = ['combined', 'wireless', 'switch', 'appliance']
+            assert kwargs['deviceType'] in options, f'''"deviceType" cannot be "{kwargs['deviceType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'traffic'],
+            'operation': 'getNetworkTraffic'
+        }
+        resource = f'/networks/{networkId}/traffic'
+
+        query_params = ['t0', 'timespan', 'deviceType', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkTrafficAnalysis(self, networkId: str):
+        """
+        **Return the traffic analysis settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-analysis
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficAnalysis'],
+            'operation': 'getNetworkTrafficAnalysis'
+        }
+        resource = f'/networks/{networkId}/trafficAnalysis'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkTrafficAnalysis(self, networkId: str, **kwargs):
+        """
+        **Update the traffic analysis settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-traffic-analysis
+
+        - networkId (string): (required)
+        - mode (string):     The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
+    'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
+
+        - customPieChartItems (array): The list of items that make up the custom pie chart for traffic reporting.
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['disabled', 'basic', 'detailed']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficAnalysis'],
+            'operation': 'updateNetworkTrafficAnalysis'
+        }
+        resource = f'/networks/{networkId}/trafficAnalysis'
+
+        body_params = ['mode', 'customPieChartItems', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkTrafficShapingApplicationCategories(self, networkId: str):
+        """
+        **Returns the application categories for traffic shaping rules.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-application-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficShaping', 'applicationCategories'],
+            'operation': 'getNetworkTrafficShapingApplicationCategories'
+        }
+        resource = f'/networks/{networkId}/trafficShaping/applicationCategories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkTrafficShapingDscpTaggingOptions(self, networkId: str):
+        """
+        **Returns the available DSCP tagging options for your traffic shaping rules.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-dscp-tagging-options
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficShaping', 'dscpTaggingOptions'],
+            'operation': 'getNetworkTrafficShapingDscpTaggingOptions'
+        }
+        resource = f'/networks/{networkId}/trafficShaping/dscpTaggingOptions'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def unbindNetwork(self, networkId: str):
+        """
+        **Unbind a network from a template.**
+        https://developer.cisco.com/meraki/api-v1/#!unbind-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'unbindNetwork'
+        }
+        resource = f'/networks/{networkId}/unbind'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkWebhooksHttpServers(self, networkId: str):
+        """
+        **List the HTTP servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-servers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'getNetworkWebhooksHttpServers'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkWebhooksHttpServer(self, networkId: str, name: str, url: str, **kwargs):
+        """
+        **Add an HTTP server to a network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - name (string): A name for easy reference to the HTTP server
+        - url (string): The URL of the HTTP server
+        - sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'createNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers'
+
+        body_params = ['name', 'url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
+        """
+        **Return an HTTP server for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'getNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str, **kwargs):
+        """
+        **Update an HTTP server**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        - name (string): A name for easy reference to the HTTP server
+        - url (string): The URL of the HTTP server
+        - sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'updateNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        body_params = ['name', 'url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
+        """
+        **Delete an HTTP server from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'deleteNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def createNetworkWebhooksWebhookTest(self, networkId: str, url: str, **kwargs):
+        """
+        **Send a test webhook for a network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-webhook-test
+
+        - networkId (string): (required)
+        - url (string): The URL where the test webhook will be sent
+        - sharedSecret (string): The shared secret the test webhook will send. Optional. Defaults to an empty string.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
+            'operation': 'createNetworkWebhooksWebhookTest'
+        }
+        resource = f'/networks/{networkId}/webhooks/webhookTests'
+
+        body_params = ['url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkWebhooksWebhookTest(self, networkId: str, webhookTestId: str):
+        """
+        **Return the status of a webhook test for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-webhook-test
+
+        - networkId (string): (required)
+        - webhookTestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
+            'operation': 'getNetworkWebhooksWebhookTest'
+        }
+        resource = f'/networks/{networkId}/webhooks/webhookTests/{webhookTestId}'
+
+        return self._session.get(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/aio/api/sm.py` & `meraki-1.7.2/meraki/aio/api/sm.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,800 +1,875 @@
-class AsyncSm:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def createNetworkSmBypassActivationLockAttempt(self, networkId: str, ids: list):
-		"""
-		**Bypass activation lock attempt**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-sm-bypass-activation-lock-attempt
-		
-		- networkId (string): (required)
-		- ids (array): The ids of the devices to attempt activation lock bypass.
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
-			'operation': 'createNetworkSmBypassActivationLockAttempt'
-		}
-		resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts'
-
-		body_params = ['ids', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmBypassActivationLockAttempt(self, networkId: str, attemptId: str):
-		"""
-		**Bypass activation lock attempt status**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-bypass-activation-lock-attempt
-		
-		- networkId (string): (required)
-		- attemptId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
-			'operation': 'getNetworkSmBypassActivationLockAttempt'
-		}
-		resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the devices enrolled in an SM network with various specified fields and filters**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-devices
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- fields (array): Additional fields that will be displayed for each device.
-    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
-    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
-    ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
-    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
-    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
-    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion.
-		- wifiMacs (array): Filter devices by wifi mac(s).
-		- serials (array): Filter devices by serial(s).
-		- ids (array): Filter devices by id(s).
-		- scope (array): Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'getNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices'
-
-		query_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def checkinNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Force check-in a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!checkin-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMacs (array): The wifiMacs of the devices to be checked-in.
-		- ids (array): The ids of the devices to be checked-in.
-		- serials (array): The serials of the devices to be checked-in.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'checkinNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/checkin'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def updateNetworkSmDevicesFields(self, networkId: str, deviceFields: dict, **kwargs):
-		"""
-		**Modify the fields of a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-sm-devices-fields
-		
-		- networkId (string): (required)
-		- deviceFields (object): The new fields of the device. Each field of this object is optional.
-		- wifiMac (string): The wifiMac of the device to be modified.
-		- id (string): The id of the device to be modified.
-		- serial (string): The serial of the device to be modified.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'fields'],
-			'operation': 'updateNetworkSmDevicesFields'
-		}
-		resource = f'/networks/{networkId}/sm/devices/fields'
-
-		body_params = ['wifiMac', 'id', 'serial', 'deviceFields', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def lockNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Lock a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!lock-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMacs (array): The wifiMacs of the devices to be locked.
-		- ids (array): The ids of the devices to be locked.
-		- serials (array): The serials of the devices to be locked.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
-		- pin (integer): The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'lockNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/lock'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'pin', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def modifyNetworkSmDevicesTags(self, networkId: str, tags: list, updateAction: str, **kwargs):
-		"""
-		**Add, delete, or update the tags of a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!modify-network-sm-devices-tags
-		
-		- networkId (string): (required)
-		- tags (array): The tags to be added, deleted, or updated.
-		- updateAction (string): One of add, delete, or update. Only devices that have been modified will be returned.
-		- wifiMacs (array): The wifiMacs of the devices to be modified.
-		- ids (array): The ids of the devices to be modified.
-		- serials (array): The serials of the devices to be modified.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'modifyNetworkSmDevicesTags'
-		}
-		resource = f'/networks/{networkId}/sm/devices/modifyTags'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'tags', 'updateAction', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def moveNetworkSmDevices(self, networkId: str, newNetwork: str, **kwargs):
-		"""
-		**Move a set of devices to a new network**
-		https://developer.cisco.com/meraki/api-v1/#!move-network-sm-devices
-		
-		- networkId (string): (required)
-		- newNetwork (string): The new network to which the devices will be moved.
-		- wifiMacs (array): The wifiMacs of the devices to be moved.
-		- ids (array): The ids of the devices to be moved.
-		- serials (array): The serials of the devices to be moved.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'moveNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/move'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'newNetwork', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def wipeNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Wipe a device**
-		https://developer.cisco.com/meraki/api-v1/#!wipe-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMac (string): The wifiMac of the device to be wiped.
-		- id (string): The id of the device to be wiped.
-		- serial (string): The serial of the device to be wiped.
-		- pin (integer): The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'wipeNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/wipe'
-
-		body_params = ['wifiMac', 'id', 'serial', 'pin', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmDeviceCellularUsageHistory(self, networkId: str, deviceId: str):
-		"""
-		**Return the client's daily cellular data usage history**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-cellular-usage-history
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'cellularUsageHistory'],
-			'operation': 'getNetworkSmDeviceCellularUsageHistory'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceCerts(self, networkId: str, deviceId: str):
-		"""
-		**List the certs on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-certs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'certs'],
-			'operation': 'getNetworkSmDeviceCerts'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/certs'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceConnectivity(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Returns historical connectivity data (whether a device is regularly checking in to Dashboard).**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-connectivity
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'connectivity'],
-			'operation': 'getNetworkSmDeviceConnectivity'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/connectivity'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDesktopLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of various Systems Manager network connection details for desktop devices.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-desktop-logs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'desktopLogs'],
-			'operation': 'getNetworkSmDeviceDesktopLogs'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/desktopLogs'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDeviceCommandLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of commands sent to Systems Manager devices**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-command-logs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'deviceCommandLogs'],
-			'operation': 'getNetworkSmDeviceDeviceCommandLogs'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDeviceProfiles(self, networkId: str, deviceId: str):
-		"""
-		**Get the profiles associated with a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-profiles
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'deviceProfiles'],
-			'operation': 'getNetworkSmDeviceDeviceProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceNetworkAdapters(self, networkId: str, deviceId: str):
-		"""
-		**List the network adapters of a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-network-adapters
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'networkAdapters'],
-			'operation': 'getNetworkSmDeviceNetworkAdapters'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/networkAdapters'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDevicePerformanceHistory(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of various Systems Manager client metrics for desktop devices.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-performance-history
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'performanceHistory'],
-			'operation': 'getNetworkSmDevicePerformanceHistory'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/performanceHistory'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def refreshNetworkSmDeviceDetails(self, networkId: str, deviceId: str):
-		"""
-		**Refresh the details of a device**
-		https://developer.cisco.com/meraki/api-v1/#!refresh-network-sm-device-details
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'refreshNetworkSmDeviceDetails'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/refreshDetails'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSmDeviceRestrictions(self, networkId: str, deviceId: str):
-		"""
-		**List the restrictions on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-restrictions
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'restrictions'],
-			'operation': 'getNetworkSmDeviceRestrictions'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/restrictions'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceSecurityCenters(self, networkId: str, deviceId: str):
-		"""
-		**List the security centers on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-security-centers
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'securityCenters'],
-			'operation': 'getNetworkSmDeviceSecurityCenters'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/securityCenters'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceSoftwares(self, networkId: str, deviceId: str):
-		"""
-		**Get a list of softwares associated with a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-softwares
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'softwares'],
-			'operation': 'getNetworkSmDeviceSoftwares'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/softwares'
-
-		return self._session.get(metadata, resource)
-
-	def unenrollNetworkSmDevice(self, networkId: str, deviceId: str):
-		"""
-		**Unenroll a device**
-		https://developer.cisco.com/meraki/api-v1/#!unenroll-network-sm-device
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'unenrollNetworkSmDevice'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/unenroll'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSmDeviceWlanLists(self, networkId: str, deviceId: str):
-		"""
-		**List the saved SSID names on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-wlan-lists
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'wlanLists'],
-			'operation': 'getNetworkSmDeviceWlanLists'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/wlanLists'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmProfiles(self, networkId: str):
-		"""
-		**List all profiles in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-profiles
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'profiles'],
-			'operation': 'getNetworkSmProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/profiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmTargetGroups(self, networkId: str, **kwargs):
-		"""
-		**List the target groups in this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-groups
-		
-		- networkId (string): (required)
-		- withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'getNetworkSmTargetGroups'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups'
-
-		query_params = ['withDetails', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def createNetworkSmTargetGroup(self, networkId: str, **kwargs):
-		"""
-		**Add a target group**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-sm-target-group
-		
-		- networkId (string): (required)
-		- name (string): The name of this target group
-		- scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'createNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups'
-
-		body_params = ['name', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
-		"""
-		**Return a target group**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		- withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'getNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		query_params = ['withDetails', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def updateNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
-		"""
-		**Update a target group**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		- name (string): The name of this target group
-		- scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'updateNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		body_params = ['name', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkSmTargetGroup(self, networkId: str, targetGroupId: str):
-		"""
-		**Delete a target group from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'deleteNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkSmUserAccessDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List User Access Devices and its Trusted Access Connections**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-access-devices
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'userAccessDevices'],
-			'operation': 'getNetworkSmUserAccessDevices'
-		}
-		resource = f'/networks/{networkId}/sm/userAccessDevices'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
-		"""
-		**Delete a User Access Device**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
-		
-		- networkId (string): (required)
-		- userAccessDeviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'userAccessDevices'],
-			'operation': 'deleteNetworkSmUserAccessDevice'
-		}
-		resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkSmUsers(self, networkId: str, **kwargs):
-		"""
-		**List the owners in an SM network with various specified fields and filters**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-users
-		
-		- networkId (string): (required)
-		- ids (array): Filter users by id(s).
-		- usernames (array): Filter users by username(s).
-		- emails (array): Filter users by email(s).
-		- scope (array): Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users'],
-			'operation': 'getNetworkSmUsers'
-		}
-		resource = f'/networks/{networkId}/sm/users'
-
-		query_params = ['ids', 'usernames', 'emails', 'scope', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['ids', 'usernames', 'emails', 'scope', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkSmUserDeviceProfiles(self, networkId: str, userId: str):
-		"""
-		**Get the profiles associated with a user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-device-profiles
-		
-		- networkId (string): (required)
-		- userId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users', 'deviceProfiles'],
-			'operation': 'getNetworkSmUserDeviceProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/users/{userId}/deviceProfiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmUserSoftwares(self, networkId: str, userId: str):
-		"""
-		**Get a list of softwares associated with a user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-softwares
-		
-		- networkId (string): (required)
-		- userId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users', 'softwares'],
-			'operation': 'getNetworkSmUserSoftwares'
-		}
-		resource = f'/networks/{networkId}/sm/users/{userId}/softwares'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmApnsCert(self, organizationId: str):
-		"""
-		**Get the organization's APNS certificate**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-apns-cert
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'apnsCert'],
-			'operation': 'getOrganizationSmApnsCert'
-		}
-		resource = f'/organizations/{organizationId}/sm/apnsCert'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmVppAccounts(self, organizationId: str):
-		"""
-		**List the VPP accounts in the organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-accounts
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'vppAccounts'],
-			'operation': 'getOrganizationSmVppAccounts'
-		}
-		resource = f'/organizations/{organizationId}/sm/vppAccounts'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmVppAccount(self, organizationId: str, vppAccountId: str):
-		"""
-		**Get a hash containing the unparsed token of the VPP account with the given ID**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-account
-		
-		- organizationId (string): (required)
-		- vppAccountId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'vppAccounts'],
-			'operation': 'getOrganizationSmVppAccount'
-		}
-		resource = f'/organizations/{organizationId}/sm/vppAccounts/{vppAccountId}'
-
-		return self._session.get(metadata, resource)
+class AsyncSm:
+    def __init__(self, session):
+        super().__init__()
+        self._session = session
+        
+
+
+    def createNetworkSmBypassActivationLockAttempt(self, networkId: str, ids: list):
+        """
+        **Bypass activation lock attempt**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-sm-bypass-activation-lock-attempt
+
+        - networkId (string): (required)
+        - ids (array): The ids of the devices to attempt activation lock bypass.
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
+            'operation': 'createNetworkSmBypassActivationLockAttempt'
+        }
+        resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts'
+
+        body_params = ['ids', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmBypassActivationLockAttempt(self, networkId: str, attemptId: str):
+        """
+        **Bypass activation lock attempt status**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-bypass-activation-lock-attempt
+
+        - networkId (string): (required)
+        - attemptId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
+            'operation': 'getNetworkSmBypassActivationLockAttempt'
+        }
+        resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the devices enrolled in an SM network with various specified fields and filters**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-devices
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - fields (array): Additional fields that will be displayed for each device.
+    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
+    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
+    ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
+    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
+    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
+    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion.
+        - wifiMacs (array): Filter devices by wifi mac(s).
+        - serials (array): Filter devices by serial(s).
+        - ids (array): Filter devices by id(s).
+        - scope (array): Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'getNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices'
+
+        query_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def checkinNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Force check-in a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!checkin-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMacs (array): The wifiMacs of the devices to be checked-in.
+        - ids (array): The ids of the devices to be checked-in.
+        - serials (array): The serials of the devices to be checked-in.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'checkinNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/checkin'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def updateNetworkSmDevicesFields(self, networkId: str, deviceFields: dict, **kwargs):
+        """
+        **Modify the fields of a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-sm-devices-fields
+
+        - networkId (string): (required)
+        - deviceFields (object): The new fields of the device. Each field of this object is optional.
+        - wifiMac (string): The wifiMac of the device to be modified.
+        - id (string): The id of the device to be modified.
+        - serial (string): The serial of the device to be modified.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'fields'],
+            'operation': 'updateNetworkSmDevicesFields'
+        }
+        resource = f'/networks/{networkId}/sm/devices/fields'
+
+        body_params = ['wifiMac', 'id', 'serial', 'deviceFields', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def lockNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Lock a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!lock-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMacs (array): The wifiMacs of the devices to be locked.
+        - ids (array): The ids of the devices to be locked.
+        - serials (array): The serials of the devices to be locked.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
+        - pin (integer): The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'lockNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/lock'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'pin', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def modifyNetworkSmDevicesTags(self, networkId: str, tags: list, updateAction: str, **kwargs):
+        """
+        **Add, delete, or update the tags of a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!modify-network-sm-devices-tags
+
+        - networkId (string): (required)
+        - tags (array): The tags to be added, deleted, or updated.
+        - updateAction (string): One of add, delete, or update. Only devices that have been modified will be returned.
+        - wifiMacs (array): The wifiMacs of the devices to be modified.
+        - ids (array): The ids of the devices to be modified.
+        - serials (array): The serials of the devices to be modified.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'modifyNetworkSmDevicesTags'
+        }
+        resource = f'/networks/{networkId}/sm/devices/modifyTags'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'tags', 'updateAction', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def moveNetworkSmDevices(self, networkId: str, newNetwork: str, **kwargs):
+        """
+        **Move a set of devices to a new network**
+        https://developer.cisco.com/meraki/api-v1/#!move-network-sm-devices
+
+        - networkId (string): (required)
+        - newNetwork (string): The new network to which the devices will be moved.
+        - wifiMacs (array): The wifiMacs of the devices to be moved.
+        - ids (array): The ids of the devices to be moved.
+        - serials (array): The serials of the devices to be moved.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'moveNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/move'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'newNetwork', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def wipeNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Wipe a device**
+        https://developer.cisco.com/meraki/api-v1/#!wipe-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMac (string): The wifiMac of the device to be wiped.
+        - id (string): The id of the device to be wiped.
+        - serial (string): The serial of the device to be wiped.
+        - pin (integer): The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'wipeNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/wipe'
+
+        body_params = ['wifiMac', 'id', 'serial', 'pin', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmDeviceCellularUsageHistory(self, networkId: str, deviceId: str):
+        """
+        **Return the client's daily cellular data usage history**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-cellular-usage-history
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'cellularUsageHistory'],
+            'operation': 'getNetworkSmDeviceCellularUsageHistory'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceCerts(self, networkId: str, deviceId: str):
+        """
+        **List the certs on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-certs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'certs'],
+            'operation': 'getNetworkSmDeviceCerts'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/certs'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceConnectivity(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Returns historical connectivity data (whether a device is regularly checking in to Dashboard).**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-connectivity
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'connectivity'],
+            'operation': 'getNetworkSmDeviceConnectivity'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/connectivity'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDesktopLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of various Systems Manager network connection details for desktop devices.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-desktop-logs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'desktopLogs'],
+            'operation': 'getNetworkSmDeviceDesktopLogs'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/desktopLogs'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDeviceCommandLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of commands sent to Systems Manager devices**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-command-logs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'deviceCommandLogs'],
+            'operation': 'getNetworkSmDeviceDeviceCommandLogs'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDeviceProfiles(self, networkId: str, deviceId: str):
+        """
+        **Get the profiles associated with a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-profiles
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'deviceProfiles'],
+            'operation': 'getNetworkSmDeviceDeviceProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceNetworkAdapters(self, networkId: str, deviceId: str):
+        """
+        **List the network adapters of a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-network-adapters
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'networkAdapters'],
+            'operation': 'getNetworkSmDeviceNetworkAdapters'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/networkAdapters'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDevicePerformanceHistory(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of various Systems Manager client metrics for desktop devices.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-performance-history
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'performanceHistory'],
+            'operation': 'getNetworkSmDevicePerformanceHistory'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/performanceHistory'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def refreshNetworkSmDeviceDetails(self, networkId: str, deviceId: str):
+        """
+        **Refresh the details of a device**
+        https://developer.cisco.com/meraki/api-v1/#!refresh-network-sm-device-details
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'refreshNetworkSmDeviceDetails'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/refreshDetails'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceRestrictions(self, networkId: str, deviceId: str):
+        """
+        **List the restrictions on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-restrictions
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'restrictions'],
+            'operation': 'getNetworkSmDeviceRestrictions'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/restrictions'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceSecurityCenters(self, networkId: str, deviceId: str):
+        """
+        **List the security centers on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-security-centers
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'securityCenters'],
+            'operation': 'getNetworkSmDeviceSecurityCenters'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/securityCenters'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceSoftwares(self, networkId: str, deviceId: str):
+        """
+        **Get a list of softwares associated with a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-softwares
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'softwares'],
+            'operation': 'getNetworkSmDeviceSoftwares'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/softwares'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def unenrollNetworkSmDevice(self, networkId: str, deviceId: str):
+        """
+        **Unenroll a device**
+        https://developer.cisco.com/meraki/api-v1/#!unenroll-network-sm-device
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'unenrollNetworkSmDevice'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/unenroll'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceWlanLists(self, networkId: str, deviceId: str):
+        """
+        **List the saved SSID names on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-wlan-lists
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'wlanLists'],
+            'operation': 'getNetworkSmDeviceWlanLists'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/wlanLists'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmProfiles(self, networkId: str):
+        """
+        **List all profiles in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-profiles
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'profiles'],
+            'operation': 'getNetworkSmProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/profiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmTargetGroups(self, networkId: str, **kwargs):
+        """
+        **List the target groups in this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-groups
+
+        - networkId (string): (required)
+        - withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'getNetworkSmTargetGroups'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups'
+
+        query_params = ['withDetails', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def createNetworkSmTargetGroup(self, networkId: str, **kwargs):
+        """
+        **Add a target group**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-sm-target-group
+
+        - networkId (string): (required)
+        - name (string): The name of this target group
+        - scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'createNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups'
+
+        body_params = ['name', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
+        """
+        **Return a target group**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        - withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'getNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        query_params = ['withDetails', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def updateNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
+        """
+        **Update a target group**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        - name (string): The name of this target group
+        - scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'updateNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        body_params = ['name', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkSmTargetGroup(self, networkId: str, targetGroupId: str):
+        """
+        **Delete a target group from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'deleteNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkSmUserAccessDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List User Access Devices and its Trusted Access Connections**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-access-devices
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'userAccessDevices'],
+            'operation': 'getNetworkSmUserAccessDevices'
+        }
+        resource = f'/networks/{networkId}/sm/userAccessDevices'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
+        """
+        **Delete a User Access Device**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
+
+        - networkId (string): (required)
+        - userAccessDeviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'userAccessDevices'],
+            'operation': 'deleteNetworkSmUserAccessDevice'
+        }
+        resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkSmUsers(self, networkId: str, **kwargs):
+        """
+        **List the owners in an SM network with various specified fields and filters**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-users
+
+        - networkId (string): (required)
+        - ids (array): Filter users by id(s).
+        - usernames (array): Filter users by username(s).
+        - emails (array): Filter users by email(s).
+        - scope (array): Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users'],
+            'operation': 'getNetworkSmUsers'
+        }
+        resource = f'/networks/{networkId}/sm/users'
+
+        query_params = ['ids', 'usernames', 'emails', 'scope', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['ids', 'usernames', 'emails', 'scope', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkSmUserDeviceProfiles(self, networkId: str, userId: str):
+        """
+        **Get the profiles associated with a user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-device-profiles
+
+        - networkId (string): (required)
+        - userId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users', 'deviceProfiles'],
+            'operation': 'getNetworkSmUserDeviceProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/users/{userId}/deviceProfiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmUserSoftwares(self, networkId: str, userId: str):
+        """
+        **Get a list of softwares associated with a user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-softwares
+
+        - networkId (string): (required)
+        - userId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users', 'softwares'],
+            'operation': 'getNetworkSmUserSoftwares'
+        }
+        resource = f'/networks/{networkId}/sm/users/{userId}/softwares'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmApnsCert(self, organizationId: str):
+        """
+        **Get the organization's APNS certificate**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-apns-cert
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'apnsCert'],
+            'operation': 'getOrganizationSmApnsCert'
+        }
+        resource = f'/organizations/{organizationId}/sm/apnsCert'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmVppAccounts(self, organizationId: str):
+        """
+        **List the VPP accounts in the organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-accounts
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'vppAccounts'],
+            'operation': 'getOrganizationSmVppAccounts'
+        }
+        resource = f'/organizations/{organizationId}/sm/vppAccounts'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmVppAccount(self, organizationId: str, vppAccountId: str):
+        """
+        **Get a hash containing the unparsed token of the VPP account with the given ID**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-account
+
+        - organizationId (string): (required)
+        - vppAccountId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'vppAccounts'],
+            'operation': 'getOrganizationSmVppAccount'
+        }
+        resource = f'/organizations/{organizationId}/sm/vppAccounts/{vppAccountId}'
+
+        return self._session.get(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/aio/api/wireless.py` & `meraki-1.7.2/meraki/api/wireless.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,1557 +1,1763 @@
-class AsyncWireless:
-	def __init__(self, session):
-		super().__init__()
-		self._session = session
-
-	def getDeviceWirelessBluetoothSettings(self, serial: str):
-		"""
-		**Return the bluetooth settings for a wireless device**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-bluetooth-settings
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
-			'operation': 'getDeviceWirelessBluetoothSettings'
-		}
-		resource = f'/devices/{serial}/wireless/bluetooth/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateDeviceWirelessBluetoothSettings(self, serial: str, **kwargs):
-		"""
-		**Update the bluetooth settings for a wireless device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-bluetooth-settings
-		
-		- serial (string): (required)
-		- uuid (string): Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		- major (integer): Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		- minor (integer): Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
-			'operation': 'updateDeviceWirelessBluetoothSettings'
-		}
-		resource = f'/devices/{serial}/wireless/bluetooth/settings'
-
-		body_params = ['uuid', 'major', 'minor', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getDeviceWirelessConnectionStats(self, serial: str, **kwargs):
-		"""
-		**Aggregated connectivity info for a given AP on this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-connection-stats
-		
-		- serial (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'connectionStats'],
-			'operation': 'getDeviceWirelessConnectionStats'
-		}
-		resource = f'/devices/{serial}/wireless/connectionStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getDeviceWirelessLatencyStats(self, serial: str, **kwargs):
-		"""
-		**Aggregated latency info for a given AP on this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-latency-stats
-		
-		- serial (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'latencyStats'],
-			'operation': 'getDeviceWirelessLatencyStats'
-		}
-		resource = f'/devices/{serial}/wireless/latencyStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getDeviceWirelessRadioSettings(self, serial: str):
-		"""
-		**Return the radio settings of a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-radio-settings
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'radio', 'settings'],
-			'operation': 'getDeviceWirelessRadioSettings'
-		}
-		resource = f'/devices/{serial}/wireless/radio/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateDeviceWirelessRadioSettings(self, serial: str, **kwargs):
-		"""
-		**Update the radio settings of a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-radio-settings
-		
-		- serial (string): (required)
-		- rfProfileId (integer): The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power).
-		- twoFourGhzSettings (object): Manual radio settings for 2.4 GHz.
-		- fiveGhzSettings (object): Manual radio settings for 5 GHz.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'radio', 'settings'],
-			'operation': 'updateDeviceWirelessRadioSettings'
-		}
-		resource = f'/devices/{serial}/wireless/radio/settings'
-
-		body_params = ['rfProfileId', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getDeviceWirelessStatus(self, serial: str):
-		"""
-		**Return the SSID statuses of an access point**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-status
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'status'],
-			'operation': 'getDeviceWirelessStatus'
-		}
-		resource = f'/devices/{serial}/wireless/status'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkWirelessAirMarshal(self, networkId: str, **kwargs):
-		"""
-		**List Air Marshal scan results from a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-air-marshal
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'airMarshal'],
-			'operation': 'getNetworkWirelessAirMarshal'
-		}
-		resource = f'/networks/{networkId}/wireless/airMarshal'
-
-		query_params = ['t0', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessAlternateManagementInterface(self, networkId: str):
-		"""
-		**Return alternate management interface and devices with IP assigned**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-alternate-management-interface
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'alternateManagementInterface'],
-			'operation': 'getNetworkWirelessAlternateManagementInterface'
-		}
-		resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessAlternateManagementInterface(self, networkId: str, **kwargs):
-		"""
-		**Update alternate management interface and device static IP**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-alternate-management-interface
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable alternate management interface
-		- vlanId (integer): Alternate management interface VLAN, must be between 1 and 4094
-		- protocols (array): Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap'
-		- accessPoints (array): Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'alternateManagementInterface'],
-			'operation': 'updateNetworkWirelessAlternateManagementInterface'
-		}
-		resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
-
-		body_params = ['enabled', 'vlanId', 'protocols', 'accessPoints', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessBilling(self, networkId: str):
-		"""
-		**Return the billing settings of this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-billing
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'billing'],
-			'operation': 'getNetworkWirelessBilling'
-		}
-		resource = f'/networks/{networkId}/wireless/billing'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessBilling(self, networkId: str, **kwargs):
-		"""
-		**Update the billing settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-billing
-		
-		- networkId (string): (required)
-		- currency (string): The currency code of this node group's billing plans
-		- plans (array): Array of billing plans in the node group. (Can configure a maximum of 5)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'billing'],
-			'operation': 'updateNetworkWirelessBilling'
-		}
-		resource = f'/networks/{networkId}/wireless/billing'
-
-		body_params = ['currency', 'plans', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessBluetoothSettings(self, networkId: str):
-		"""
-		**Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-bluetooth-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
-			'operation': 'getNetworkWirelessBluetoothSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/bluetooth/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessBluetoothSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the Bluetooth settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-bluetooth-settings
-		
-		- networkId (string): (required)
-		- scanningEnabled (boolean): Whether APs will scan for Bluetooth enabled clients. (true, false)
-		- advertisingEnabled (boolean): Whether APs will advertise beacons. (true, false)
-		- uuid (string): The UUID to be used in the beacon identifier.
-		- majorMinorAssignmentMode (string): The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
-		- major (integer): The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
-		- minor (integer): The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
-		"""
-
-		kwargs.update(locals())
-
-		if 'majorMinorAssignmentMode' in kwargs:
-			options = ['Unique', 'Non-unique']
-			assert kwargs['majorMinorAssignmentMode'] in options, f'''"majorMinorAssignmentMode" cannot be "{kwargs['majorMinorAssignmentMode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
-			'operation': 'updateNetworkWirelessBluetoothSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/bluetooth/settings'
-
-		body_params = ['scanningEnabled', 'advertisingEnabled', 'uuid', 'majorMinorAssignmentMode', 'major', 'minor', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessChannelUtilizationHistory(self, networkId: str, **kwargs):
-		"""
-		**Return AP channel utilization over time for a device or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-channel-utilization-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
-		- deviceSerial (string): Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
-		- apTag (string): Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
-		- band (string): Filter results by band (either '2.4' or '5').
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'channelUtilizationHistory'],
-			'operation': 'getNetworkWirelessChannelUtilizationHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/channelUtilizationHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientCountHistory(self, networkId: str, **kwargs):
-		"""
-		**Return wireless client counts over time for a network, device, or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-count-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
-		- deviceSerial (string): Filter results by device.
-		- apTag (string): Filter results by AP tag.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssid (integer): Filter results by SSID number.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clientCountHistory'],
-			'operation': 'getNetworkWirelessClientCountHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/clientCountHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientsConnectionStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated connectivity info for this network, grouped by clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-clients-connection-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'connectionStats'],
-			'operation': 'getNetworkWirelessClientsConnectionStats'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/connectionStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientsLatencyStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated latency info for this network, grouped by clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-clients-latency-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'latencyStats'],
-			'operation': 'getNetworkWirelessClientsLatencyStats'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/latencyStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientConnectionStats(self, networkId: str, clientId: str, **kwargs):
-		"""
-		**Aggregated connectivity info for a given client on this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-connection-stats
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'connectionStats'],
-			'operation': 'getNetworkWirelessClientConnectionStats'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/{clientId}/connectionStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientConnectivityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the wireless connectivity events for a client within a network in the timespan.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-connectivity-events
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		- types (array): A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
-		- includedSeverities (array): A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
-		- deviceSerial (string): Filter results by an AP's serial number.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'connectivityEvents'],
-			'operation': 'getNetworkWirelessClientConnectivityEvents'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', 'types', 'includedSeverities', 'band', 'ssidNumber', 'deviceSerial', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['types', 'includedSeverities', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkWirelessClientLatencyHistory(self, networkId: str, clientId: str, **kwargs):
-		"""
-		**Return the latency history for a client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-latency-history
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'latencyHistory'],
-			'operation': 'getNetworkWirelessClientLatencyHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/{clientId}/latencyHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessClientLatencyStats(self, networkId: str, clientId: str, **kwargs):
-		"""
-		**Aggregated latency info for a given client on this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-latency-stats
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'clients', 'latencyStats'],
-			'operation': 'getNetworkWirelessClientLatencyStats'
-		}
-		resource = f'/networks/{networkId}/wireless/clients/{clientId}/latencyStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessConnectionStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated connectivity info for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-connection-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'connectionStats'],
-			'operation': 'getNetworkWirelessConnectionStats'
-		}
-		resource = f'/networks/{networkId}/wireless/connectionStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessDataRateHistory(self, networkId: str, **kwargs):
-		"""
-		**Return PHY data rates over time for a network, device, or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-data-rate-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client.
-		- deviceSerial (string): Filter results by device.
-		- apTag (string): Filter results by AP tag.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssid (integer): Filter results by SSID number.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'dataRateHistory'],
-			'operation': 'getNetworkWirelessDataRateHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/dataRateHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessDevicesConnectionStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated connectivity info for this network, grouped by node**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-devices-connection-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'devices', 'connectionStats'],
-			'operation': 'getNetworkWirelessDevicesConnectionStats'
-		}
-		resource = f'/networks/{networkId}/wireless/devices/connectionStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessDevicesLatencyStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated latency info for this network, grouped by node**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-devices-latency-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'devices', 'latencyStats'],
-			'operation': 'getNetworkWirelessDevicesLatencyStats'
-		}
-		resource = f'/networks/{networkId}/wireless/devices/latencyStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessFailedConnections(self, networkId: str, **kwargs):
-		"""
-		**List of all failed client connection events on this network in a given time range**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-failed-connections
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- serial (string): Filter by AP
-		- clientId (string): Filter by client MAC
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'failedConnections'],
-			'operation': 'getNetworkWirelessFailedConnections'
-		}
-		resource = f'/networks/{networkId}/wireless/failedConnections'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'serial', 'clientId', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessLatencyHistory(self, networkId: str, **kwargs):
-		"""
-		**Return average wireless latency over time for a network, device, or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-latency-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client.
-		- deviceSerial (string): Filter results by device.
-		- apTag (string): Filter results by AP tag.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssid (integer): Filter results by SSID number.
-		- accessCategory (string): Filter by access category.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-		if 'accessCategory' in kwargs:
-			options = ['backgroundTraffic', 'bestEffortTraffic', 'videoTraffic', 'voiceTraffic']
-			assert kwargs['accessCategory'] in options, f'''"accessCategory" cannot be "{kwargs['accessCategory']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'latencyHistory'],
-			'operation': 'getNetworkWirelessLatencyHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/latencyHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', 'accessCategory', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessLatencyStats(self, networkId: str, **kwargs):
-		"""
-		**Aggregated latency info for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-latency-stats
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
-		- band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
-		- ssid (integer): Filter results by SSID
-		- vlan (integer): Filter results by VLAN
-		- apTag (string): Filter results by AP Tag
-		- fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'latencyStats'],
-			'operation': 'getNetworkWirelessLatencyStats'
-		}
-		resource = f'/networks/{networkId}/wireless/latencyStats'
-
-		query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessMeshStatuses(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List wireless mesh statuses for repeaters**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-mesh-statuses
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'meshStatuses'],
-			'operation': 'getNetworkWirelessMeshStatuses'
-		}
-		resource = f'/networks/{networkId}/wireless/meshStatuses'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkWirelessRfProfiles(self, networkId: str, **kwargs):
-		"""
-		**List the non-basic RF profiles for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-rf-profiles
-		
-		- networkId (string): (required)
-		- includeTemplateProfiles (boolean): If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'getNetworkWirelessRfProfiles'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles'
-
-		query_params = ['includeTemplateProfiles', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def createNetworkWirelessRfProfile(self, networkId: str, name: str, bandSelectionType: str, **kwargs):
-		"""
-		**Creates new RF profile for this network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- name (string): The name of the new profile. Must be unique. This param is required on creation.
-		- bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
-		- clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false. Defaults to true.
-		- minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
-		- apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
-		- twoFourGhzSettings (object): Settings related to 2.4Ghz band
-		- fiveGhzSettings (object): Settings related to 5Ghz band
-		"""
-
-		kwargs.update(locals())
-
-		if 'minBitrateType' in kwargs:
-			options = ['band', 'ssid']
-			assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
-		if 'bandSelectionType' in kwargs:
-			options = ['ssid', 'ap']
-			assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'createNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles'
-
-		body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def updateNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str, **kwargs):
-		"""
-		**Updates specified RF profile for this network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- rfProfileId (string): (required)
-		- name (string): The name of the new profile. Must be unique.
-		- clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false.
-		- minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'.
-		- bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'.
-		- apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
-		- twoFourGhzSettings (object): Settings related to 2.4Ghz band
-		- fiveGhzSettings (object): Settings related to 5Ghz band
-		"""
-
-		kwargs.update(locals())
-
-		if 'minBitrateType' in kwargs:
-			options = ['band', 'ssid']
-			assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
-		if 'bandSelectionType' in kwargs:
-			options = ['ssid', 'ap']
-			assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'updateNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
-
-		body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
-		"""
-		**Delete a RF Profile**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- rfProfileId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'deleteNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
-		"""
-		**Return a RF profile**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- rfProfileId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'getNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkWirelessSettings(self, networkId: str):
-		"""
-		**Return the wireless settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'settings'],
-			'operation': 'getNetworkWirelessSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the wireless settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-settings
-		
-		- networkId (string): (required)
-		- meshingEnabled (boolean): Toggle for enabling or disabling meshing in a network
-		- ipv6BridgeEnabled (boolean): Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
-		- locationAnalyticsEnabled (boolean): Toggle for enabling or disabling location analytics for your network
-		- upgradeStrategy (string): The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
-		- ledLightsOn (boolean): Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
-		"""
-
-		kwargs.update(locals())
-
-		if 'upgradeStrategy' in kwargs:
-			options = ['minimizeUpgradeTime', 'minimizeClientDowntime']
-			assert kwargs['upgradeStrategy'] in options, f'''"upgradeStrategy" cannot be "{kwargs['upgradeStrategy']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'settings'],
-			'operation': 'updateNetworkWirelessSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/settings'
-
-		body_params = ['meshingEnabled', 'ipv6BridgeEnabled', 'locationAnalyticsEnabled', 'upgradeStrategy', 'ledLightsOn', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSignalQualityHistory(self, networkId: str, **kwargs):
-		"""
-		**Return signal quality (SNR/RSSI) over time for a device or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-signal-quality-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client.
-		- deviceSerial (string): Filter results by device.
-		- apTag (string): Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssid (integer): Filter results by SSID number.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'signalQualityHistory'],
-			'operation': 'getNetworkWirelessSignalQualityHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/signalQualityHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkWirelessSsids(self, networkId: str):
-		"""
-		**List the MR SSIDs in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssids
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids'],
-			'operation': 'getNetworkWirelessSsids'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkWirelessSsid(self, networkId: str, number: str):
-		"""
-		**Return a single MR SSID**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids'],
-			'operation': 'getNetworkWirelessSsid'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsid(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the attributes of an MR SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- name (string): The name of the SSID
-		- enabled (boolean): Whether or not the SSID is enabled
-		- authMode (string): The association control method for the SSID ('open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
-		- enterpriseAdminAccess (string): Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
-		- encryptionMode (string): The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
-		- psk (string): The passkey for the SSID. This param is only valid if the authMode is 'psk'
-		- wpaEncryptionMode (string): The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
-		- dot11w (object): The current setting for Protected Management Frames (802.11w).
-		- dot11r (object): The current setting for 802.11r
-		- splashPage (string): The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest' or 'Cisco ISE'). This attribute is not supported for template children.
-		- splashGuestSponsorDomains (array): Array of valid sponsor email domains for sponsored guest splash type.
-		- ldap (object): The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
-		- activeDirectory (object): The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
-		- radiusServers (array): The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
-		- radiusProxyEnabled (boolean): If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
-		- radiusTestingEnabled (boolean): If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
-		- radiusCalledStationId (string): The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
-		- radiusAuthenticationNasId (string): The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
-		- radiusServerTimeout (integer): The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
-		- radiusServerAttemptsLimit (integer): The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
-		- radiusFallbackEnabled (boolean): Whether or not higher priority RADIUS servers should be retried after 60 seconds.
-		- radiusCoaEnabled (boolean): If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
-		- radiusFailoverPolicy (string): This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
-		- radiusLoadBalancingPolicy (string): This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
-		- radiusAccountingEnabled (boolean): Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
-		- radiusAccountingServers (array): The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
-		- radiusAccountingInterimInterval (integer): The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
-		- radiusAttributeForGroupPolicies (string): Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
-		- ipAssignmentMode (string): The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
-		- useVlanTagging (boolean): Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- concentratorNetworkId (string): The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
-		- vlanId (integer): The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
-		- defaultVlanId (integer): The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- apTagsAndVlanIds (array): The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- walledGardenEnabled (boolean): Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
-		- walledGardenRanges (array): Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
-		- radiusOverride (boolean): If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
-		- radiusGuestVlanEnabled (boolean): Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
-		- radiusGuestVlanId (integer): VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
-		- minBitrate (number): The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
-		- bandSelection (string): The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
-		- perClientBandwidthLimitUp (integer): The upload bandwidth limit in Kbps. (0 represents no limit.)
-		- perClientBandwidthLimitDown (integer): The download bandwidth limit in Kbps. (0 represents no limit.)
-		- perSsidBandwidthLimitUp (integer): The total upload bandwidth limit in Kbps. (0 represents no limit.)
-		- perSsidBandwidthLimitDown (integer): The total download bandwidth limit in Kbps. (0 represents no limit.)
-		- lanIsolationEnabled (boolean): Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
-		- visible (boolean): Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
-		- availableOnAllAps (boolean): Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
-		- availabilityTags (array): Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
-		- adaptivePolicyGroupId (string): Adaptive policy group ID this SSID is assigned to.
-		- mandatoryDhcpEnabled (boolean): If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
-		- adultContentFilteringEnabled (boolean): Boolean indicating whether or not adult content will be blocked
-		"""
-
-		kwargs.update(locals())
-
-		if 'authMode' in kwargs:
-			options = ['open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius', 'ipsk-without-radius']
-			assert kwargs['authMode'] in options, f'''"authMode" cannot be "{kwargs['authMode']}", & must be set to one of: {options}'''
-		if 'enterpriseAdminAccess' in kwargs:
-			options = ['access disabled', 'access enabled']
-			assert kwargs['enterpriseAdminAccess'] in options, f'''"enterpriseAdminAccess" cannot be "{kwargs['enterpriseAdminAccess']}", & must be set to one of: {options}'''
-		if 'encryptionMode' in kwargs:
-			options = ['wep', 'wpa']
-			assert kwargs['encryptionMode'] in options, f'''"encryptionMode" cannot be "{kwargs['encryptionMode']}", & must be set to one of: {options}'''
-		if 'wpaEncryptionMode' in kwargs:
-			options = ['WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only']
-			assert kwargs['wpaEncryptionMode'] in options, f'''"wpaEncryptionMode" cannot be "{kwargs['wpaEncryptionMode']}", & must be set to one of: {options}'''
-		if 'splashPage' in kwargs:
-			options = ['None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE']
-			assert kwargs['splashPage'] in options, f'''"splashPage" cannot be "{kwargs['splashPage']}", & must be set to one of: {options}'''
-		if 'radiusFailoverPolicy' in kwargs:
-			options = ['Deny access', 'Allow access']
-			assert kwargs['radiusFailoverPolicy'] in options, f'''"radiusFailoverPolicy" cannot be "{kwargs['radiusFailoverPolicy']}", & must be set to one of: {options}'''
-		if 'radiusLoadBalancingPolicy' in kwargs:
-			options = ['Strict priority order', 'Round robin']
-			assert kwargs['radiusLoadBalancingPolicy'] in options, f'''"radiusLoadBalancingPolicy" cannot be "{kwargs['radiusLoadBalancingPolicy']}", & must be set to one of: {options}'''
-		if 'radiusAttributeForGroupPolicies' in kwargs:
-			options = ['Filter-Id', 'Reply-Message', 'Airespace-ACL-Name', 'Aruba-User-Role']
-			assert kwargs['radiusAttributeForGroupPolicies'] in options, f'''"radiusAttributeForGroupPolicies" cannot be "{kwargs['radiusAttributeForGroupPolicies']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids'],
-			'operation': 'updateNetworkWirelessSsid'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}'
-
-		body_params = ['name', 'enabled', 'authMode', 'enterpriseAdminAccess', 'encryptionMode', 'psk', 'wpaEncryptionMode', 'dot11w', 'dot11r', 'splashPage', 'splashGuestSponsorDomains', 'ldap', 'activeDirectory', 'radiusServers', 'radiusProxyEnabled', 'radiusTestingEnabled', 'radiusCalledStationId', 'radiusAuthenticationNasId', 'radiusServerTimeout', 'radiusServerAttemptsLimit', 'radiusFallbackEnabled', 'radiusCoaEnabled', 'radiusFailoverPolicy', 'radiusLoadBalancingPolicy', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusAccountingInterimInterval', 'radiusAttributeForGroupPolicies', 'ipAssignmentMode', 'useVlanTagging', 'concentratorNetworkId', 'vlanId', 'defaultVlanId', 'apTagsAndVlanIds', 'walledGardenEnabled', 'walledGardenRanges', 'radiusOverride', 'radiusGuestVlanEnabled', 'radiusGuestVlanId', 'minBitrate', 'bandSelection', 'perClientBandwidthLimitUp', 'perClientBandwidthLimitDown', 'perSsidBandwidthLimitUp', 'perSsidBandwidthLimitDown', 'lanIsolationEnabled', 'visible', 'availableOnAllAps', 'availabilityTags', 'adaptivePolicyGroupId', 'mandatoryDhcpEnabled', 'adultContentFilteringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str):
-		"""
-		**List the device type group policies for the SSID**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-device-type-group-policies
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
-			'operation': 'getNetworkWirelessSsidDeviceTypeGroupPolicies'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the device type group policies for the SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-device-type-group-policies
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- enabled (boolean): If true, the SSID device type group policies are enabled.
-		- deviceTypePolicies (array): List of device type policies.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
-			'operation': 'updateNetworkWirelessSsidDeviceTypeGroupPolicies'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
-
-		body_params = ['enabled', 'deviceTypePolicies', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSsidFirewallL3FirewallRules(self, networkId: str, number: str):
-		"""
-		**Return the L3 firewall rules for an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l3FirewallRules'],
-			'operation': 'getNetworkWirelessSsidFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsidFirewallL3FirewallRules(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the L3 firewall rules of an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- rules (array): An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule)
-		- allowLanAccess (boolean): Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l3FirewallRules'],
-			'operation': 'updateNetworkWirelessSsidFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules'
-
-		body_params = ['rules', 'allowLanAccess', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str):
-		"""
-		**Return the L7 firewall rules for an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
-			'operation': 'getNetworkWirelessSsidFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the L7 firewall rules of an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- rules (array): An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
-			'operation': 'updateNetworkWirelessSsidFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSsidIdentityPsks(self, networkId: str, number: str):
-		"""
-		**List all Identity PSKs in a wireless network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-identity-psks
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'getNetworkWirelessSsidIdentityPsks'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, name: str, passphrase: str, groupPolicyId: str):
-		"""
-		**Create an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- name (string): The name of the Identity PSK
-		- passphrase (string): The passphrase for client authentication
-		- groupPolicyId (string): The group policy to be applied to clients
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'createNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
-
-		body_params = ['name', 'passphrase', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
-		"""
-		**Return an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- identityPskId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'getNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str, **kwargs):
-		"""
-		**Update an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- identityPskId (string): (required)
-		- name (string): The name of the Identity PSK
-		- passphrase (string): The passphrase for client authentication
-		- groupPolicyId (string): The group policy to be applied to clients
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'updateNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
-
-		body_params = ['name', 'passphrase', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
-		"""
-		**Delete an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- identityPskId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'deleteNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkWirelessSsidSplashSettings(self, networkId: str, number: str):
-		"""
-		**Display the splash page settings for the given SSID**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-splash-settings
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
-			'operation': 'getNetworkWirelessSsidSplashSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWirelessSsidSplashSettings(self, networkId: str, number: str, **kwargs):
-		"""
-		**Modify the splash page settings for the given SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-splash-settings
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- splashUrl (string): [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
-		- useSplashUrl (boolean): [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
-		- splashTimeout (integer): Splash timeout in minutes. This will determine how often users will see the splash page.
-		- redirectUrl (string): The custom redirect URL where the users will go after the splash page.
-		- useRedirectUrl (boolean): The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.
-		- welcomeMessage (string): The welcome message for the users on the splash page.
-		- splashLogo (object): The logo used in the splash page.
-		- splashImage (object): The image used in the splash page.
-		- splashPrepaidFront (object): The prepaid front image used in the splash page.
-		- blockAllTrafficBeforeSignOn (boolean): How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
-		- controllerDisconnectionBehavior (string): How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.
-		- allowSimultaneousLogins (boolean): Whether or not to allow simultaneous logins from different devices.
-		- guestSponsorship (object): Details associated with guest sponsored splash.
-		- billing (object): Details associated with billing splash.
-		"""
-
-		kwargs.update(locals())
-
-		if 'controllerDisconnectionBehavior' in kwargs:
-			options = ['open', 'restricted', 'default']
-			assert kwargs['controllerDisconnectionBehavior'] in options, f'''"controllerDisconnectionBehavior" cannot be "{kwargs['controllerDisconnectionBehavior']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
-			'operation': 'updateNetworkWirelessSsidSplashSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
-
-		body_params = ['splashUrl', 'useSplashUrl', 'splashTimeout', 'redirectUrl', 'useRedirectUrl', 'welcomeMessage', 'splashLogo', 'splashImage', 'splashPrepaidFront', 'blockAllTrafficBeforeSignOn', 'controllerDisconnectionBehavior', 'allowSimultaneousLogins', 'guestSponsorship', 'billing', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def updateNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the traffic shaping settings for an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- trafficShapingEnabled (boolean): Whether traffic shaping rules are applied to clients on your SSID.
-		- defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
-		- rules (array):     An array of traffic shaping rules. Rules are applied in the order that
-    they are specified in. An empty list (or null) means no rules. Note that
-    you are allowed a maximum of 8 rules.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
-			'operation': 'updateNetworkWirelessSsidTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
-
-		body_params = ['trafficShapingEnabled', 'defaultRulesEnabled', 'rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str):
-		"""
-		**Display the traffic shaping settings for a SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
-			'operation': 'getNetworkWirelessSsidTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkWirelessUsageHistory(self, networkId: str, **kwargs):
-		"""
-		**Return AP usage over time for a device or network client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-usage-history
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
-		- autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
-		- clientId (string): Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
-		- deviceSerial (string): Filter results by device. Requires :band.
-		- apTag (string): Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
-		- band (string): Filter results by band (either '2.4' or '5').
-		- ssid (integer): Filter results by SSID number.
-		"""
-
-		kwargs.update(locals())
-
-		if 'band' in kwargs:
-			options = ['2.4', '5']
-			assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'monitor', 'usageHistory'],
-			'operation': 'getNetworkWirelessUsageHistory'
-		}
-		resource = f'/networks/{networkId}/wireless/usageHistory'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
+class Wireless(object):
+    def __init__(self, session):
+        super(Wireless, self).__init__()
+        self._session = session
+        
+
+
+    def getDeviceWirelessBluetoothSettings(self, serial: str):
+        """
+        **Return the bluetooth settings for a wireless device**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-bluetooth-settings
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
+            'operation': 'getDeviceWirelessBluetoothSettings'
+        }
+        resource = f'/devices/{serial}/wireless/bluetooth/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateDeviceWirelessBluetoothSettings(self, serial: str, **kwargs):
+        """
+        **Update the bluetooth settings for a wireless device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-bluetooth-settings
+
+        - serial (string): (required)
+        - uuid (string): Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        - major (integer): Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        - minor (integer): Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
+            'operation': 'updateDeviceWirelessBluetoothSettings'
+        }
+        resource = f'/devices/{serial}/wireless/bluetooth/settings'
+
+        body_params = ['uuid', 'major', 'minor', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getDeviceWirelessConnectionStats(self, serial: str, **kwargs):
+        """
+        **Aggregated connectivity info for a given AP on this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-connection-stats
+
+        - serial (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'connectionStats'],
+            'operation': 'getDeviceWirelessConnectionStats'
+        }
+        resource = f'/devices/{serial}/wireless/connectionStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getDeviceWirelessLatencyStats(self, serial: str, **kwargs):
+        """
+        **Aggregated latency info for a given AP on this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-latency-stats
+
+        - serial (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'latencyStats'],
+            'operation': 'getDeviceWirelessLatencyStats'
+        }
+        resource = f'/devices/{serial}/wireless/latencyStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getDeviceWirelessRadioSettings(self, serial: str):
+        """
+        **Return the radio settings of a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-radio-settings
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'radio', 'settings'],
+            'operation': 'getDeviceWirelessRadioSettings'
+        }
+        resource = f'/devices/{serial}/wireless/radio/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateDeviceWirelessRadioSettings(self, serial: str, **kwargs):
+        """
+        **Update the radio settings of a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-radio-settings
+
+        - serial (string): (required)
+        - rfProfileId (integer): The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power).
+        - twoFourGhzSettings (object): Manual radio settings for 2.4 GHz.
+        - fiveGhzSettings (object): Manual radio settings for 5 GHz.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'radio', 'settings'],
+            'operation': 'updateDeviceWirelessRadioSettings'
+        }
+        resource = f'/devices/{serial}/wireless/radio/settings'
+
+        body_params = ['rfProfileId', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getDeviceWirelessStatus(self, serial: str):
+        """
+        **Return the SSID statuses of an access point**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-wireless-status
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'status'],
+            'operation': 'getDeviceWirelessStatus'
+        }
+        resource = f'/devices/{serial}/wireless/status'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkWirelessAirMarshal(self, networkId: str, **kwargs):
+        """
+        **List Air Marshal scan results from a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-air-marshal
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'airMarshal'],
+            'operation': 'getNetworkWirelessAirMarshal'
+        }
+        resource = f'/networks/{networkId}/wireless/airMarshal'
+
+        query_params = ['t0', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessAlternateManagementInterface(self, networkId: str):
+        """
+        **Return alternate management interface and devices with IP assigned**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-alternate-management-interface
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'alternateManagementInterface'],
+            'operation': 'getNetworkWirelessAlternateManagementInterface'
+        }
+        resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessAlternateManagementInterface(self, networkId: str, **kwargs):
+        """
+        **Update alternate management interface and device static IP**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-alternate-management-interface
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable alternate management interface
+        - vlanId (integer): Alternate management interface VLAN, must be between 1 and 4094
+        - protocols (array): Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap'
+        - accessPoints (array): Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'alternateManagementInterface'],
+            'operation': 'updateNetworkWirelessAlternateManagementInterface'
+        }
+        resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
+
+        body_params = ['enabled', 'vlanId', 'protocols', 'accessPoints', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessBilling(self, networkId: str):
+        """
+        **Return the billing settings of this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-billing
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'billing'],
+            'operation': 'getNetworkWirelessBilling'
+        }
+        resource = f'/networks/{networkId}/wireless/billing'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessBilling(self, networkId: str, **kwargs):
+        """
+        **Update the billing settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-billing
+
+        - networkId (string): (required)
+        - currency (string): The currency code of this node group's billing plans
+        - plans (array): Array of billing plans in the node group. (Can configure a maximum of 5)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'billing'],
+            'operation': 'updateNetworkWirelessBilling'
+        }
+        resource = f'/networks/{networkId}/wireless/billing'
+
+        body_params = ['currency', 'plans', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessBluetoothSettings(self, networkId: str):
+        """
+        **Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-bluetooth-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
+            'operation': 'getNetworkWirelessBluetoothSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/bluetooth/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessBluetoothSettings(self, networkId: str, **kwargs):
+        """
+        **Update the Bluetooth settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-bluetooth-settings
+
+        - networkId (string): (required)
+        - scanningEnabled (boolean): Whether APs will scan for Bluetooth enabled clients. (true, false)
+        - advertisingEnabled (boolean): Whether APs will advertise beacons. (true, false)
+        - uuid (string): The UUID to be used in the beacon identifier.
+        - majorMinorAssignmentMode (string): The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
+        - major (integer): The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
+        - minor (integer): The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
+        """
+
+        kwargs.update(locals())
+
+        if 'majorMinorAssignmentMode' in kwargs:
+            options = ['Unique', 'Non-unique']
+            assert kwargs['majorMinorAssignmentMode'] in options, f'''"majorMinorAssignmentMode" cannot be "{kwargs['majorMinorAssignmentMode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
+            'operation': 'updateNetworkWirelessBluetoothSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/bluetooth/settings'
+
+        body_params = ['scanningEnabled', 'advertisingEnabled', 'uuid', 'majorMinorAssignmentMode', 'major', 'minor', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessChannelUtilizationHistory(self, networkId: str, **kwargs):
+        """
+        **Return AP channel utilization over time for a device or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-channel-utilization-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
+        - deviceSerial (string): Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
+        - apTag (string): Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
+        - band (string): Filter results by band (either '2.4' or '5').
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'channelUtilizationHistory'],
+            'operation': 'getNetworkWirelessChannelUtilizationHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/channelUtilizationHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientCountHistory(self, networkId: str, **kwargs):
+        """
+        **Return wireless client counts over time for a network, device, or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-count-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
+        - deviceSerial (string): Filter results by device.
+        - apTag (string): Filter results by AP tag.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssid (integer): Filter results by SSID number.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clientCountHistory'],
+            'operation': 'getNetworkWirelessClientCountHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/clientCountHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientsConnectionStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated connectivity info for this network, grouped by clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-clients-connection-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'connectionStats'],
+            'operation': 'getNetworkWirelessClientsConnectionStats'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/connectionStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientsLatencyStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated latency info for this network, grouped by clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-clients-latency-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'latencyStats'],
+            'operation': 'getNetworkWirelessClientsLatencyStats'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/latencyStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientConnectionStats(self, networkId: str, clientId: str, **kwargs):
+        """
+        **Aggregated connectivity info for a given client on this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-connection-stats
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'connectionStats'],
+            'operation': 'getNetworkWirelessClientConnectionStats'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/{clientId}/connectionStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientConnectivityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the wireless connectivity events for a client within a network in the timespan.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-connectivity-events
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        - types (array): A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
+        - includedSeverities (array): A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
+        - deviceSerial (string): Filter results by an AP's serial number.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'connectivityEvents'],
+            'operation': 'getNetworkWirelessClientConnectivityEvents'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', 'types', 'includedSeverities', 'band', 'ssidNumber', 'deviceSerial', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['types', 'includedSeverities', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkWirelessClientLatencyHistory(self, networkId: str, clientId: str, **kwargs):
+        """
+        **Return the latency history for a client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-latency-history
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'latencyHistory'],
+            'operation': 'getNetworkWirelessClientLatencyHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/{clientId}/latencyHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessClientLatencyStats(self, networkId: str, clientId: str, **kwargs):
+        """
+        **Aggregated latency info for a given client on this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-client-latency-stats
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'clients', 'latencyStats'],
+            'operation': 'getNetworkWirelessClientLatencyStats'
+        }
+        resource = f'/networks/{networkId}/wireless/clients/{clientId}/latencyStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessConnectionStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated connectivity info for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-connection-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'connectionStats'],
+            'operation': 'getNetworkWirelessConnectionStats'
+        }
+        resource = f'/networks/{networkId}/wireless/connectionStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessDataRateHistory(self, networkId: str, **kwargs):
+        """
+        **Return PHY data rates over time for a network, device, or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-data-rate-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client.
+        - deviceSerial (string): Filter results by device.
+        - apTag (string): Filter results by AP tag.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssid (integer): Filter results by SSID number.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'dataRateHistory'],
+            'operation': 'getNetworkWirelessDataRateHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/dataRateHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessDevicesConnectionStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated connectivity info for this network, grouped by node**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-devices-connection-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'devices', 'connectionStats'],
+            'operation': 'getNetworkWirelessDevicesConnectionStats'
+        }
+        resource = f'/networks/{networkId}/wireless/devices/connectionStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessDevicesLatencyStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated latency info for this network, grouped by node**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-devices-latency-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'devices', 'latencyStats'],
+            'operation': 'getNetworkWirelessDevicesLatencyStats'
+        }
+        resource = f'/networks/{networkId}/wireless/devices/latencyStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessFailedConnections(self, networkId: str, **kwargs):
+        """
+        **List of all failed client connection events on this network in a given time range**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-failed-connections
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - serial (string): Filter by AP
+        - clientId (string): Filter by client MAC
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'failedConnections'],
+            'operation': 'getNetworkWirelessFailedConnections'
+        }
+        resource = f'/networks/{networkId}/wireless/failedConnections'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'serial', 'clientId', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessLatencyHistory(self, networkId: str, **kwargs):
+        """
+        **Return average wireless latency over time for a network, device, or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-latency-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client.
+        - deviceSerial (string): Filter results by device.
+        - apTag (string): Filter results by AP tag.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssid (integer): Filter results by SSID number.
+        - accessCategory (string): Filter by access category.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+        if 'accessCategory' in kwargs:
+            options = ['backgroundTraffic', 'bestEffortTraffic', 'videoTraffic', 'voiceTraffic']
+            assert kwargs['accessCategory'] in options, f'''"accessCategory" cannot be "{kwargs['accessCategory']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'latencyHistory'],
+            'operation': 'getNetworkWirelessLatencyHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/latencyHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', 'accessCategory', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessLatencyStats(self, networkId: str, **kwargs):
+        """
+        **Aggregated latency info for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-latency-stats
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
+        - band (string): Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.
+        - ssid (integer): Filter results by SSID
+        - vlan (integer): Filter results by VLAN
+        - apTag (string): Filter results by AP Tag
+        - fields (string): Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'latencyStats'],
+            'operation': 'getNetworkWirelessLatencyStats'
+        }
+        resource = f'/networks/{networkId}/wireless/latencyStats'
+
+        query_params = ['t0', 't1', 'timespan', 'band', 'ssid', 'vlan', 'apTag', 'fields', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessMeshStatuses(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List wireless mesh statuses for repeaters**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-mesh-statuses
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'meshStatuses'],
+            'operation': 'getNetworkWirelessMeshStatuses'
+        }
+        resource = f'/networks/{networkId}/wireless/meshStatuses'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkWirelessRfProfiles(self, networkId: str, **kwargs):
+        """
+        **List the non-basic RF profiles for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-rf-profiles
+
+        - networkId (string): (required)
+        - includeTemplateProfiles (boolean): If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'getNetworkWirelessRfProfiles'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles'
+
+        query_params = ['includeTemplateProfiles', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def createNetworkWirelessRfProfile(self, networkId: str, name: str, bandSelectionType: str, **kwargs):
+        """
+        **Creates new RF profile for this network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - name (string): The name of the new profile. Must be unique. This param is required on creation.
+        - bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
+        - clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false. Defaults to true.
+        - minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
+        - apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
+        - twoFourGhzSettings (object): Settings related to 2.4Ghz band
+        - fiveGhzSettings (object): Settings related to 5Ghz band
+        """
+
+        kwargs.update(locals())
+
+        if 'minBitrateType' in kwargs:
+            options = ['band', 'ssid']
+            assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
+        if 'bandSelectionType' in kwargs:
+            options = ['ssid', 'ap']
+            assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'createNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles'
+
+        body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def updateNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str, **kwargs):
+        """
+        **Updates specified RF profile for this network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - rfProfileId (string): (required)
+        - name (string): The name of the new profile. Must be unique.
+        - clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false.
+        - minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'.
+        - bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'.
+        - apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
+        - twoFourGhzSettings (object): Settings related to 2.4Ghz band
+        - fiveGhzSettings (object): Settings related to 5Ghz band
+        """
+
+        kwargs.update(locals())
+
+        if 'minBitrateType' in kwargs:
+            options = ['band', 'ssid']
+            assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
+        if 'bandSelectionType' in kwargs:
+            options = ['ssid', 'ap']
+            assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'updateNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
+
+        body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
+        """
+        **Delete a RF Profile**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - rfProfileId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'deleteNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
+        """
+        **Return a RF profile**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - rfProfileId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'getNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkWirelessSettings(self, networkId: str):
+        """
+        **Return the wireless settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'settings'],
+            'operation': 'getNetworkWirelessSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSettings(self, networkId: str, **kwargs):
+        """
+        **Update the wireless settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-settings
+
+        - networkId (string): (required)
+        - meshingEnabled (boolean): Toggle for enabling or disabling meshing in a network
+        - ipv6BridgeEnabled (boolean): Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
+        - locationAnalyticsEnabled (boolean): Toggle for enabling or disabling location analytics for your network
+        - upgradeStrategy (string): The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
+        - ledLightsOn (boolean): Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
+        """
+
+        kwargs.update(locals())
+
+        if 'upgradeStrategy' in kwargs:
+            options = ['minimizeUpgradeTime', 'minimizeClientDowntime']
+            assert kwargs['upgradeStrategy'] in options, f'''"upgradeStrategy" cannot be "{kwargs['upgradeStrategy']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'settings'],
+            'operation': 'updateNetworkWirelessSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/settings'
+
+        body_params = ['meshingEnabled', 'ipv6BridgeEnabled', 'locationAnalyticsEnabled', 'upgradeStrategy', 'ledLightsOn', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSignalQualityHistory(self, networkId: str, **kwargs):
+        """
+        **Return signal quality (SNR/RSSI) over time for a device or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-signal-quality-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client.
+        - deviceSerial (string): Filter results by device.
+        - apTag (string): Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssid (integer): Filter results by SSID number.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'signalQualityHistory'],
+            'operation': 'getNetworkWirelessSignalQualityHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/signalQualityHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkWirelessSsids(self, networkId: str):
+        """
+        **List the MR SSIDs in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssids
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids'],
+            'operation': 'getNetworkWirelessSsids'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkWirelessSsid(self, networkId: str, number: str):
+        """
+        **Return a single MR SSID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids'],
+            'operation': 'getNetworkWirelessSsid'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsid(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the attributes of an MR SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - name (string): The name of the SSID
+        - enabled (boolean): Whether or not the SSID is enabled
+        - authMode (string): The association control method for the SSID ('open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
+        - enterpriseAdminAccess (string): Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
+        - encryptionMode (string): The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
+        - psk (string): The passkey for the SSID. This param is only valid if the authMode is 'psk'
+        - wpaEncryptionMode (string): The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
+        - dot11w (object): The current setting for Protected Management Frames (802.11w).
+        - dot11r (object): The current setting for 802.11r
+        - splashPage (string): The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
+        - splashGuestSponsorDomains (array): Array of valid sponsor email domains for sponsored guest splash type.
+        - oauth (object): The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
+        - localRadius (object): The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
+        - ldap (object): The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
+        - activeDirectory (object): The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
+        - radiusServers (array): The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
+        - radiusProxyEnabled (boolean): If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
+        - radiusTestingEnabled (boolean): If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
+        - radiusCalledStationId (string): The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
+        - radiusAuthenticationNasId (string): The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
+        - radiusServerTimeout (integer): The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
+        - radiusServerAttemptsLimit (integer): The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
+        - radiusFallbackEnabled (boolean): Whether or not higher priority RADIUS servers should be retried after 60 seconds.
+        - radiusCoaEnabled (boolean): If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
+        - radiusFailoverPolicy (string): This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
+        - radiusLoadBalancingPolicy (string): This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
+        - radiusAccountingEnabled (boolean): Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
+        - radiusAccountingServers (array): The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
+        - radiusAccountingInterimInterval (integer): The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
+        - radiusAttributeForGroupPolicies (string): Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
+        - ipAssignmentMode (string): The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
+        - useVlanTagging (boolean): Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - concentratorNetworkId (string): The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
+        - vlanId (integer): The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
+        - defaultVlanId (integer): The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - apTagsAndVlanIds (array): The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - walledGardenEnabled (boolean): Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
+        - walledGardenRanges (array): Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
+        - radiusOverride (boolean): If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
+        - radiusGuestVlanEnabled (boolean): Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
+        - radiusGuestVlanId (integer): VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
+        - minBitrate (number): The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
+        - bandSelection (string): The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
+        - perClientBandwidthLimitUp (integer): The upload bandwidth limit in Kbps. (0 represents no limit.)
+        - perClientBandwidthLimitDown (integer): The download bandwidth limit in Kbps. (0 represents no limit.)
+        - perSsidBandwidthLimitUp (integer): The total upload bandwidth limit in Kbps. (0 represents no limit.)
+        - perSsidBandwidthLimitDown (integer): The total download bandwidth limit in Kbps. (0 represents no limit.)
+        - lanIsolationEnabled (boolean): Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
+        - visible (boolean): Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
+        - availableOnAllAps (boolean): Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
+        - availabilityTags (array): Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
+        - mandatoryDhcpEnabled (boolean): If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
+        - adultContentFilteringEnabled (boolean): Boolean indicating whether or not adult content will be blocked
+        - dnsRewrite (object): DNS servers rewrite settings
+        """
+
+        kwargs.update(locals())
+
+        if 'authMode' in kwargs:
+            options = ['open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius', 'ipsk-without-radius']
+            assert kwargs['authMode'] in options, f'''"authMode" cannot be "{kwargs['authMode']}", & must be set to one of: {options}'''
+        if 'enterpriseAdminAccess' in kwargs:
+            options = ['access disabled', 'access enabled']
+            assert kwargs['enterpriseAdminAccess'] in options, f'''"enterpriseAdminAccess" cannot be "{kwargs['enterpriseAdminAccess']}", & must be set to one of: {options}'''
+        if 'encryptionMode' in kwargs:
+            options = ['wep', 'wpa']
+            assert kwargs['encryptionMode'] in options, f'''"encryptionMode" cannot be "{kwargs['encryptionMode']}", & must be set to one of: {options}'''
+        if 'wpaEncryptionMode' in kwargs:
+            options = ['WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only']
+            assert kwargs['wpaEncryptionMode'] in options, f'''"wpaEncryptionMode" cannot be "{kwargs['wpaEncryptionMode']}", & must be set to one of: {options}'''
+        if 'splashPage' in kwargs:
+            options = ['None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE', 'Google Apps domain']
+            assert kwargs['splashPage'] in options, f'''"splashPage" cannot be "{kwargs['splashPage']}", & must be set to one of: {options}'''
+        if 'radiusFailoverPolicy' in kwargs:
+            options = ['Deny access', 'Allow access']
+            assert kwargs['radiusFailoverPolicy'] in options, f'''"radiusFailoverPolicy" cannot be "{kwargs['radiusFailoverPolicy']}", & must be set to one of: {options}'''
+        if 'radiusLoadBalancingPolicy' in kwargs:
+            options = ['Strict priority order', 'Round robin']
+            assert kwargs['radiusLoadBalancingPolicy'] in options, f'''"radiusLoadBalancingPolicy" cannot be "{kwargs['radiusLoadBalancingPolicy']}", & must be set to one of: {options}'''
+        if 'radiusAttributeForGroupPolicies' in kwargs:
+            options = ['Filter-Id', 'Reply-Message', 'Airespace-ACL-Name', 'Aruba-User-Role']
+            assert kwargs['radiusAttributeForGroupPolicies'] in options, f'''"radiusAttributeForGroupPolicies" cannot be "{kwargs['radiusAttributeForGroupPolicies']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids'],
+            'operation': 'updateNetworkWirelessSsid'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}'
+
+        body_params = ['name', 'enabled', 'authMode', 'enterpriseAdminAccess', 'encryptionMode', 'psk', 'wpaEncryptionMode', 'dot11w', 'dot11r', 'splashPage', 'splashGuestSponsorDomains', 'oauth', 'localRadius', 'ldap', 'activeDirectory', 'radiusServers', 'radiusProxyEnabled', 'radiusTestingEnabled', 'radiusCalledStationId', 'radiusAuthenticationNasId', 'radiusServerTimeout', 'radiusServerAttemptsLimit', 'radiusFallbackEnabled', 'radiusCoaEnabled', 'radiusFailoverPolicy', 'radiusLoadBalancingPolicy', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusAccountingInterimInterval', 'radiusAttributeForGroupPolicies', 'ipAssignmentMode', 'useVlanTagging', 'concentratorNetworkId', 'vlanId', 'defaultVlanId', 'apTagsAndVlanIds', 'walledGardenEnabled', 'walledGardenRanges', 'radiusOverride', 'radiusGuestVlanEnabled', 'radiusGuestVlanId', 'minBitrate', 'bandSelection', 'perClientBandwidthLimitUp', 'perClientBandwidthLimitDown', 'perSsidBandwidthLimitUp', 'perSsidBandwidthLimitDown', 'lanIsolationEnabled', 'visible', 'availableOnAllAps', 'availabilityTags', 'mandatoryDhcpEnabled', 'adultContentFilteringEnabled', 'dnsRewrite', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidBonjourForwarding(self, networkId: str, number: str):
+        """
+        **List the Bonjour forwarding setting and rules for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-bonjour-forwarding
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'bonjourForwarding'],
+            'operation': 'getNetworkWirelessSsidBonjourForwarding'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidBonjourForwarding(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the bonjour forwarding setting and rules for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-bonjour-forwarding
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - enabled (boolean): If true, Bonjour forwarding is enabled on this SSID.
+        - rules (array): List of bonjour forwarding rules.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'bonjourForwarding'],
+            'operation': 'updateNetworkWirelessSsidBonjourForwarding'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding'
+
+        body_params = ['enabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str):
+        """
+        **List the device type group policies for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-device-type-group-policies
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
+            'operation': 'getNetworkWirelessSsidDeviceTypeGroupPolicies'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the device type group policies for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-device-type-group-policies
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - enabled (boolean): If true, the SSID device type group policies are enabled.
+        - deviceTypePolicies (array): List of device type policies.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
+            'operation': 'updateNetworkWirelessSsidDeviceTypeGroupPolicies'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
+
+        body_params = ['enabled', 'deviceTypePolicies', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidFirewallL3FirewallRules(self, networkId: str, number: str):
+        """
+        **Return the L3 firewall rules for an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l3FirewallRules'],
+            'operation': 'getNetworkWirelessSsidFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidFirewallL3FirewallRules(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the L3 firewall rules of an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - rules (array): An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule)
+        - allowLanAccess (boolean): Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l3FirewallRules'],
+            'operation': 'updateNetworkWirelessSsidFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules'
+
+        body_params = ['rules', 'allowLanAccess', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str):
+        """
+        **Return the L7 firewall rules for an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
+            'operation': 'getNetworkWirelessSsidFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the L7 firewall rules of an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - rules (array): An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
+            'operation': 'updateNetworkWirelessSsidFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidIdentityPsks(self, networkId: str, number: str):
+        """
+        **List all Identity PSKs in a wireless network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-identity-psks
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'getNetworkWirelessSsidIdentityPsks'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, name: str, passphrase: str, groupPolicyId: str):
+        """
+        **Create an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - name (string): The name of the Identity PSK
+        - passphrase (string): The passphrase for client authentication
+        - groupPolicyId (string): The group policy to be applied to clients
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'createNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
+
+        body_params = ['name', 'passphrase', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
+        """
+        **Return an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - identityPskId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'getNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str, **kwargs):
+        """
+        **Update an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - identityPskId (string): (required)
+        - name (string): The name of the Identity PSK
+        - passphrase (string): The passphrase for client authentication
+        - groupPolicyId (string): The group policy to be applied to clients
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'updateNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
+
+        body_params = ['name', 'passphrase', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
+        """
+        **Delete an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - identityPskId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'deleteNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkWirelessSsidSplashSettings(self, networkId: str, number: str):
+        """
+        **Display the splash page settings for the given SSID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-splash-settings
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
+            'operation': 'getNetworkWirelessSsidSplashSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidSplashSettings(self, networkId: str, number: str, **kwargs):
+        """
+        **Modify the splash page settings for the given SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-splash-settings
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - splashUrl (string): [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
+        - useSplashUrl (boolean): [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
+        - splashTimeout (integer): Splash timeout in minutes. This will determine how often users will see the splash page.
+        - redirectUrl (string): The custom redirect URL where the users will go after the splash page.
+        - useRedirectUrl (boolean): The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.
+        - welcomeMessage (string): The welcome message for the users on the splash page.
+        - splashLogo (object): The logo used in the splash page.
+        - splashImage (object): The image used in the splash page.
+        - splashPrepaidFront (object): The prepaid front image used in the splash page.
+        - blockAllTrafficBeforeSignOn (boolean): How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
+        - controllerDisconnectionBehavior (string): How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.
+        - allowSimultaneousLogins (boolean): Whether or not to allow simultaneous logins from different devices.
+        - guestSponsorship (object): Details associated with guest sponsored splash.
+        - billing (object): Details associated with billing splash.
+        """
+
+        kwargs.update(locals())
+
+        if 'controllerDisconnectionBehavior' in kwargs:
+            options = ['open', 'restricted', 'default']
+            assert kwargs['controllerDisconnectionBehavior'] in options, f'''"controllerDisconnectionBehavior" cannot be "{kwargs['controllerDisconnectionBehavior']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
+            'operation': 'updateNetworkWirelessSsidSplashSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
+
+        body_params = ['splashUrl', 'useSplashUrl', 'splashTimeout', 'redirectUrl', 'useRedirectUrl', 'welcomeMessage', 'splashLogo', 'splashImage', 'splashPrepaidFront', 'blockAllTrafficBeforeSignOn', 'controllerDisconnectionBehavior', 'allowSimultaneousLogins', 'guestSponsorship', 'billing', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def updateNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the traffic shaping settings for an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - trafficShapingEnabled (boolean): Whether traffic shaping rules are applied to clients on your SSID.
+        - defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
+        - rules (array):     An array of traffic shaping rules. Rules are applied in the order that
+    they are specified in. An empty list (or null) means no rules. Note that
+    you are allowed a maximum of 8 rules.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
+            'operation': 'updateNetworkWirelessSsidTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
+
+        body_params = ['trafficShapingEnabled', 'defaultRulesEnabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str):
+        """
+        **Display the traffic shaping settings for a SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
+            'operation': 'getNetworkWirelessSsidTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkWirelessSsidVpn(self, networkId: str, number: str):
+        """
+        **List the VPN settings for the SSID.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-ssid-vpn
+
+        - networkId (string): (required)
+        - number (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'vpn'],
+            'operation': 'getNetworkWirelessSsidVpn'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/vpn'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWirelessSsidVpn(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the VPN settings for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-vpn
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - splitTunnel (object): The VPN split tunnel settings for this SSID.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'vpn'],
+            'operation': 'updateNetworkWirelessSsidVpn'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/vpn'
+
+        body_params = ['splitTunnel', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkWirelessUsageHistory(self, networkId: str, **kwargs):
+        """
+        **Return AP usage over time for a device or network client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-wireless-usage-history
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
+        - autoResolution (boolean): Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
+        - clientId (string): Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
+        - deviceSerial (string): Filter results by device. Requires :band.
+        - apTag (string): Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
+        - band (string): Filter results by band (either '2.4' or '5').
+        - ssid (integer): Filter results by SSID number.
+        """
+
+        kwargs.update(locals())
+
+        if 'band' in kwargs:
+            options = ['2.4', '5']
+            assert kwargs['band'] in options, f'''"band" cannot be "{kwargs['band']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'monitor', 'usageHistory'],
+            'operation': 'getNetworkWirelessUsageHistory'
+        }
+        resource = f'/networks/{networkId}/wireless/usageHistory'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'autoResolution', 'clientId', 'deviceSerial', 'apTag', 'band', 'ssid', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+
```

### Comparing `meraki-1.7.1/meraki/aio/rest_session.py` & `meraki-1.7.2/meraki/aio/rest_session.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,486 +1,486 @@
-import asyncio
-import json
-import platform
-import random
-import ssl
-import sys
-import urllib.parse
-from datetime import datetime
-
-import aiohttp
-
-from ..__init__ import __version__
-from ..config import *
-from ..exceptions import *
-from ..rest_session import user_agent_extended
-
-
-# Main module interface
-class AsyncRestSession:
-    def __init__(
-        self,
-        logger,
-        api_key,
-        base_url=DEFAULT_BASE_URL,
-        single_request_timeout=SINGLE_REQUEST_TIMEOUT,
-        certificate_path=CERTIFICATE_PATH,
-        requests_proxy=REQUESTS_PROXY,
-        wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
-        nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
-        action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
-        retry_4xx_error=RETRY_4XX_ERROR,
-        retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
-        maximum_retries=MAXIMUM_RETRIES,
-        simulate=SIMULATE_API_CALLS,
-        maximum_concurrent_requests=AIO_MAXIMUM_CONCURRENT_REQUESTS,
-        be_geo_id=BE_GEO_ID,
-        caller=MERAKI_PYTHON_SDK_CALLER,
-        use_iterator_for_get_pages=False,
-    ):
-        super().__init__()
-
-        # Initialize attributes and properties
-        self._version = __version__
-        self._api_key = str(api_key)
-        self._base_url = str(base_url)
-        self._single_request_timeout = single_request_timeout
-        self._certificate_path = certificate_path
-        self._requests_proxy = requests_proxy
-        self._wait_on_rate_limit = wait_on_rate_limit
-        self._nginx_429_retry_wait_time = nginx_429_retry_wait_time
-        self._action_batch_retry_wait_time = action_batch_retry_wait_time
-        self._retry_4xx_error = retry_4xx_error
-        self._retry_4xx_error_wait_time = retry_4xx_error_wait_time
-        self._maximum_retries = maximum_retries
-        self._simulate = simulate
-        self._concurrent_requests_semaphore = asyncio.Semaphore(
-            maximum_concurrent_requests
-        )
-        self._be_geo_id = be_geo_id
-        self._caller = caller
-
-        self.use_iterator_for_get_pages = use_iterator_for_get_pages
-
-        # Check base URL
-        if "v0" in self._base_url:
-            sys.exit(
-                f"If you want to use the Python library with v0 paths ({self._base_url} was configured as the base"
-                f' URL), then install the v0 library. See the "Setup" section @ https://github.com/meraki/dashboard-api-python/'
-            )
-        elif self._base_url[-1] == "/":
-            self._base_url = self._base_url[:-1]
-
-        # Update the headers for the session
-        self._headers = {
-            "Authorization": "Bearer " + self._api_key,
-            "Content-Type": "application/json",
-            "User-Agent": f"python-meraki/aio-{self._version} "
-            + user_agent_extended(self._be_geo_id, self._caller),
-        }
-        if self._certificate_path:
-            self._sslcontext = ssl.create_default_context()
-            self._sslcontext.load_verify_locations(certificate_path)
-
-        # Initialize a new `aiohttp` session
-        self._req_session = aiohttp.ClientSession(
-            headers=self._headers,
-            timeout=aiohttp.ClientTimeout(total=single_request_timeout),
-        )
-
-        # Log API calls
-        self._logger = logger
-        self._parameters = {"version": self._version}
-        self._parameters.update(locals())
-        self._parameters.pop("self")
-        self._parameters.pop("logger")
-        self._parameters.pop("__class__")
-        self._parameters["api_key"] = "*" * 36 + self._api_key[-4:]
-        if self._logger:
-            self._logger.info(
-                f"Meraki dashboard API session initialized with these parameters: {self._parameters}"
-            )
-
-    @property
-    def use_iterator_for_get_pages(self):
-        return self._use_iterator_for_get_pages
-
-    @use_iterator_for_get_pages.setter
-    def use_iterator_for_get_pages(self, value):
-        if value:
-            self.get_pages = self._get_pages_iterator
-        else:
-            self.get_pages = self._get_pages_legacy
-
-        self._use_iterator_for_get_pages = value
-
-    async def request(self, metadata, method, url, **kwargs):
-        async with self._concurrent_requests_semaphore:
-            return await self._request(
-                metadata, method, url, allow_redirects=False, **kwargs
-            )
-
-    async def _request(self, metadata, method, url, **kwargs):
-        # Metadata on endpoint
-        tag = metadata["tags"][0]
-        operation = metadata["operation"]
-
-        # Update request kwargs with session defaults
-        if self._certificate_path:
-            kwargs.setdefault("ssl", self._sslcontext)
-        if self._requests_proxy:
-            kwargs.setdefault("proxy", self._requests_proxy)
-        kwargs.setdefault("timeout", self._single_request_timeout)
-
-        # Ensure proper base URL
-        url = str(url)
-        if "meraki.com" in url or "meraki.cn" in url:
-            abs_url = url
-        else:
-            abs_url = self._base_url + url
-
-        # Set maximum number of retries
-        retries = self._maximum_retries
-
-        # Option to simulate non-safe API calls without actually sending them
-        if self._logger:
-            self._logger.debug(metadata)
-        if self._simulate and method != "GET":
-            if self._logger:
-                self._logger.info(f"{tag}, {operation} > {abs_url} - SIMULATED")
-            return None
-        else:
-            response = None
-            message = None
-            for _ in range(retries):
-                # Make sure that the response object gets closed during retries
-                if response:
-                    response.release()
-                    response = None
-
-                # Make the HTTP request to the API endpoint
-                try:
-                    if self._logger:
-                        self._logger.info(f"{method} {abs_url}")
-                    response = await self._req_session.request(
-                        method, abs_url, **kwargs
-                    )
-                    reason = response.reason if response.reason else None
-                    status = response.status
-                except Exception as e:
-                    if self._logger:
-                        self._logger.warning(
-                            f"{tag}, {operation} > {abs_url} - {e}, retrying in 1 second"
-                        )
-                    await asyncio.sleep(1)
-                    continue
-
-                if 200 <= status < 300:
-                    if "page" in metadata:
-                        counter = metadata["page"]
-                        if self._logger:
-                            self._logger.info(
-                                f"{tag}, {operation}; page {counter} > {abs_url} - {status} {reason}"
-                            )
-                    else:
-                        if self._logger:
-                            self._logger.info(
-                                f"{tag}, {operation} > {abs_url} - {status} {reason}"
-                            )
-                    # For non-empty response to GET, ensure valid JSON
-                    try:
-                        if method == "GET":
-                            await response.json()
-                        return response
-                    except (
-                        json.decoder.JSONDecodeError,
-                        aiohttp.client_exceptions.ContentTypeError,
-                    ) as e:
-                        if self._logger:
-                            self._logger.warning(
-                                f"{tag}, {operation} > {abs_url} - {e}, retrying in 1 second"
-                            )
-                        await asyncio.sleep(1)
-                # Handle 3XX redirects automatically
-                elif 300 <= status < 400:
-                    abs_url = response.headers["Location"]
-                    substring = "meraki.com/api/v"
-                    if substring not in abs_url:
-                        substring = "meraki.cn/api/v"
-                    self._base_url = abs_url[
-                        : abs_url.find(substring) + len(substring) + 1
-                    ]
-                # Rate limit 429 errors
-                elif status == 429:
-                    wait = 0
-                    if "Retry-After" in response.headers:
-                        wait = int(response.headers["Retry-After"])
-                    else:
-                        wait = random.randint(1, self._nginx_429_retry_wait_time)
-                    if self._logger:
-                        self._logger.warning(
-                            f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
-                        )
-                    await asyncio.sleep(wait)
-                # 5XX errors
-                elif status >= 500:
-                    if self._logger:
-                        self._logger.warning(
-                            f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in 1 second"
-                        )
-                    await asyncio.sleep(1)
-                # 4XX errors
-                else:
-                    try:
-                        message = await response.json()
-                    except aiohttp.client_exceptions.ContentTypeError:
-                        try:
-                            message = (await response.text())[:100]
-                        except:
-                            message = None
-
-                    # Check specifically for action batch concurrency error
-                    action_batch_concurrency_error = {
-                        "errors": [
-                            "Too many concurrently executing batches. Maximum is 5 confirmed but not yet executed batches."
-                        ]
-                    }
-                    if message == action_batch_concurrency_error:
-                        wait = self._action_batch_retry_wait_time
-                        if self._logger:
-                            self._logger.warning(
-                                f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
-                            )
-                        await asyncio.sleep(wait)
-
-                    elif self._retry_4xx_error:
-                        wait = random.randint(1, self._retry_4xx_error_wait_time)
-                        if self._logger:
-                            self._logger.warning(
-                                f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
-                            )
-                        await asyncio.sleep(wait)
-
-                    # All other client-side errors
-                    else:
-                        if self._logger:
-                            self._logger.error(
-                                f"{tag}, {operation} > {abs_url} - {status} {reason}, {message}"
-                            )
-                        raise AsyncAPIError(metadata, response, message)
-            raise AsyncAPIError(
-                metadata, response, "Reached retry limit: " + str(message)
-            )
-
-    async def get(self, metadata, url, params=None):
-        metadata["method"] = "GET"
-        metadata["url"] = url
-        metadata["params"] = params
-        async with await self.request(metadata, "GET", url, params=params) as response:
-            return await response.json()
-
-    async def get_pages(
-        self,
-        metadata,
-        url,
-        params=None,
-        total_pages=-1,
-        direction="next",
-        event_log_end_time=None,
-    ):
-        pass
-
-    async def _download_page(self, request):
-        response = await request
-        result = await response.json()
-        return response, result
-
-    async def _get_pages_iterator(
-        self,
-        metadata,
-        url,
-        params=None,
-        total_pages=-1,
-        direction="next",
-        event_log_end_time=None,
-    ):
-        if type(total_pages) == str and total_pages.lower() == "all":
-            total_pages = -1
-        elif type(total_pages) == str and total_pages.isnumeric():
-            total_pages = int(total_pages)
-        metadata["page"] = 1
-
-        request_task = asyncio.create_task(
-            self._download_page(self.request(metadata, "GET", url, params=params))
-        )
-
-        # Get additional pages if more than one requested
-        while total_pages != 0:
-            response, results = await request_task
-            links = response.links
-
-            # GET the subsequent page
-            if direction == "next" and "next" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes forward
-                if metadata["operation"] == "getNetworkEvents":
-                    starting_after = urllib.parse.unquote(
-                        str(links["next"]["url"]).split("startingAfter=")[1]
-                    )
-                    delta = datetime.utcnow() - datetime.fromisoformat(
-                        starting_after[:-1]
-                    )
-                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
-                    if delta.total_seconds() < 300:
-                        break
-                    # Or if next page is past the specified window's end time
-                    elif event_log_end_time and starting_after > event_log_end_time:
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["next"]["url"]
-            elif direction == "prev" and "prev" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
-                if metadata["operation"] == "getNetworkEvents":
-                    ending_before = urllib.parse.unquote(
-                        str(links["prev"]["url"]).split("endingBefore=")[1]
-                    )
-                    # Break out of loop if endingBefore returned from prev link is before 2014
-                    if ending_before < "2014-01-01":
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["prev"]["url"]
-            else:
-                break
-
-            response.release()
-
-            total_pages = total_pages - 1
-
-            if total_pages != 0:
-                request_task = asyncio.create_task(
-                    self._download_page(self.request(metadata, "GET", nextlink))
-                )
-
-            return_items = []
-            # just prepare the list
-            if type(results) == list:
-                return_items = results
-            # For event log endpoint
-            elif type(results) == dict:
-                if direction == "next":
-                    return_items = results["events"][::-1]
-                else:
-                    return_items = results["events"]
-
-            for item in return_items:
-                yield item
-
-    async def _get_pages_legacy(
-        self,
-        metadata,
-        url,
-        params=None,
-        total_pages=-1,
-        direction="next",
-        event_log_end_time=None,
-    ):
-        if type(total_pages) == str and total_pages.lower() == "all":
-            total_pages = -1
-        elif type(total_pages) == str and total_pages.isnumeric():
-            total_pages = int(total_pages)
-        metadata["page"] = 1
-
-        async with await self.request(metadata, "GET", url, params=params) as response:
-            results = await response.json()
-
-            # For event log endpoint when using 'next' direction, so results/events are sorted chronologically
-            if (
-                type(results) == dict
-                and metadata["operation"] == "getNetworkEvents"
-                and direction == "next"
-            ):
-                results["events"] = results["events"][::-1]
-
-            links = response.links
-
-        # Get additional pages if more than one requested
-        while total_pages != 1:
-            # GET the subsequent page
-            if direction == "next" and "next" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes forward
-                if metadata["operation"] == "getNetworkEvents":
-                    starting_after = urllib.parse.unquote(
-                        str(links["next"]["url"]).split("startingAfter=")[1]
-                    )
-                    delta = datetime.utcnow() - datetime.fromisoformat(
-                        starting_after[:-1]
-                    )
-                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
-                    if delta.total_seconds() < 300:
-                        break
-                    # Or if next page is past the specified window's end time
-                    elif event_log_end_time and starting_after > event_log_end_time:
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["next"]["url"]
-            elif direction == "prev" and "prev" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
-                if metadata["operation"] == "getNetworkEvents":
-                    ending_before = urllib.parse.unquote(
-                        str(links["prev"]["url"]).split("endingBefore=")[1]
-                    )
-                    # Break out of loop if endingBefore returned from prev link is before 2014
-                    if ending_before < "2014-01-01":
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["prev"]["url"]
-            else:
-                break
-
-            async with await self.request(metadata, "GET", nextlink) as response:
-                links = response.links
-                # Append that page's results, depending on the endpoint
-                if type(results) == list:
-                    results.extend(await response.json())
-                # For event log endpoint
-                elif type(results) == dict:
-                    json_response = await response.json()
-                    start = json_response["pageStartAt"]
-                    end = json_response["pageEndAt"]
-                    events = json_response["events"]
-                    if direction == "next":
-                        events = events[::-1]
-                    if start < results["pageStartAt"]:
-                        results["pageStartAt"] = start
-                    if end > results["pageEndAt"]:
-                        results["pageEndAt"] = end
-                    results["events"].extend(events)
-
-            total_pages = total_pages - 1
-
-        return results
-
-    async def post(self, metadata, url, json=None):
-        metadata["method"] = "POST"
-        metadata["url"] = url
-        metadata["json"] = json
-        async with await self.request(metadata, "POST", url, json=json) as response:
-            return await response.json()
-
-    async def put(self, metadata, url, json=None):
-        metadata["method"] = "PUT"
-        metadata["url"] = url
-        metadata["json"] = json
-        async with await self.request(metadata, "PUT", url, json=json) as response:
-            return await response.json()
-
-    async def delete(self, metadata, url):
-        metadata["method"] = "DELETE"
-        metadata["url"] = url
-        async with await self.request(metadata, "DELETE", url) as response:
-            return None
-
-    async def close(self):
-        await self._req_session.close()
+import asyncio
+import json
+import platform
+import random
+import ssl
+import sys
+import urllib.parse
+from datetime import datetime
+
+import aiohttp
+
+from ..__init__ import __version__
+from ..config import *
+from ..exceptions import *
+from ..rest_session import user_agent_extended
+
+
+# Main module interface
+class AsyncRestSession:
+    def __init__(
+            self,
+            logger,
+            api_key,
+            base_url=DEFAULT_BASE_URL,
+            single_request_timeout=SINGLE_REQUEST_TIMEOUT,
+            certificate_path=CERTIFICATE_PATH,
+            requests_proxy=REQUESTS_PROXY,
+            wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
+            nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
+            action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
+            retry_4xx_error=RETRY_4XX_ERROR,
+            retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
+            maximum_retries=MAXIMUM_RETRIES,
+            simulate=SIMULATE_API_CALLS,
+            maximum_concurrent_requests=AIO_MAXIMUM_CONCURRENT_REQUESTS,
+            be_geo_id=BE_GEO_ID,
+            caller=MERAKI_PYTHON_SDK_CALLER,
+            use_iterator_for_get_pages=False,
+    ):
+        super().__init__()
+
+        # Initialize attributes and properties
+        self._version = __version__
+        self._api_key = str(api_key)
+        self._base_url = str(base_url)
+        self._single_request_timeout = single_request_timeout
+        self._certificate_path = certificate_path
+        self._requests_proxy = requests_proxy
+        self._wait_on_rate_limit = wait_on_rate_limit
+        self._nginx_429_retry_wait_time = nginx_429_retry_wait_time
+        self._action_batch_retry_wait_time = action_batch_retry_wait_time
+        self._retry_4xx_error = retry_4xx_error
+        self._retry_4xx_error_wait_time = retry_4xx_error_wait_time
+        self._maximum_retries = maximum_retries
+        self._simulate = simulate
+        self._concurrent_requests_semaphore = asyncio.Semaphore(
+            maximum_concurrent_requests
+        )
+        self._be_geo_id = be_geo_id
+        self._caller = caller
+
+        self.use_iterator_for_get_pages = use_iterator_for_get_pages
+
+        # Check base URL
+        if "v0" in self._base_url:
+            sys.exit(
+                f"If you want to use the Python library with v0 paths ({self._base_url} was configured as the base"
+                f' URL), then install the v0 library. See the "Setup" section @ https://github.com/meraki/dashboard-api-python/'
+            )
+        elif self._base_url[-1] == "/":
+            self._base_url = self._base_url[:-1]
+
+        # Update the headers for the session
+        self._headers = {
+            "Authorization": "Bearer " + self._api_key,
+            "Content-Type": "application/json",
+            "User-Agent": f"python-meraki/aio-{self._version} "
+                          + user_agent_extended(self._be_geo_id, self._caller),
+        }
+        if self._certificate_path:
+            self._sslcontext = ssl.create_default_context()
+            self._sslcontext.load_verify_locations(certificate_path)
+
+        # Initialize a new `aiohttp` session
+        self._req_session = aiohttp.ClientSession(
+            headers=self._headers,
+            timeout=aiohttp.ClientTimeout(total=single_request_timeout),
+        )
+
+        # Log API calls
+        self._logger = logger
+        self._parameters = {"version": self._version}
+        self._parameters.update(locals())
+        self._parameters.pop("self")
+        self._parameters.pop("logger")
+        self._parameters.pop("__class__")
+        self._parameters["api_key"] = "*" * 36 + self._api_key[-4:]
+        if self._logger:
+            self._logger.info(
+                f"Meraki dashboard API session initialized with these parameters: {self._parameters}"
+            )
+
+    @property
+    def use_iterator_for_get_pages(self):
+        return self._use_iterator_for_get_pages
+
+    @use_iterator_for_get_pages.setter
+    def use_iterator_for_get_pages(self, value):
+        if value:
+            self.get_pages = self._get_pages_iterator
+        else:
+            self.get_pages = self._get_pages_legacy
+
+        self._use_iterator_for_get_pages = value
+
+    async def request(self, metadata, method, url, **kwargs):
+        async with self._concurrent_requests_semaphore:
+            return await self._request(
+                metadata, method, url, allow_redirects=False, **kwargs
+            )
+
+    async def _request(self, metadata, method, url, **kwargs):
+        # Metadata on endpoint
+        tag = metadata["tags"][0]
+        operation = metadata["operation"]
+
+        # Update request kwargs with session defaults
+        if self._certificate_path:
+            kwargs.setdefault("ssl", self._sslcontext)
+        if self._requests_proxy:
+            kwargs.setdefault("proxy", self._requests_proxy)
+        kwargs.setdefault("timeout", self._single_request_timeout)
+
+        # Ensure proper base URL
+        url = str(url)
+        if "meraki.com" in url or "meraki.cn" in url:
+            abs_url = url
+        else:
+            abs_url = self._base_url + url
+
+        # Set maximum number of retries
+        retries = self._maximum_retries
+
+        # Option to simulate non-safe API calls without actually sending them
+        if self._logger:
+            self._logger.debug(metadata)
+        if self._simulate and method != "GET":
+            if self._logger:
+                self._logger.info(f"{tag}, {operation} > {abs_url} - SIMULATED")
+            return None
+        else:
+            response = None
+            message = None
+            for _ in range(retries):
+                # Make sure that the response object gets closed during retries
+                if response:
+                    response.release()
+                    response = None
+
+                # Make the HTTP request to the API endpoint
+                try:
+                    if self._logger:
+                        self._logger.info(f"{method} {abs_url}")
+                    response = await self._req_session.request(
+                        method, abs_url, **kwargs
+                    )
+                    reason = response.reason if response.reason else None
+                    status = response.status
+                except Exception as e:
+                    if self._logger:
+                        self._logger.warning(
+                            f"{tag}, {operation} > {abs_url} - {e}, retrying in 1 second"
+                        )
+                    await asyncio.sleep(1)
+                    continue
+
+                if 200 <= status < 300:
+                    if "page" in metadata:
+                        counter = metadata["page"]
+                        if self._logger:
+                            self._logger.info(
+                                f"{tag}, {operation}; page {counter} > {abs_url} - {status} {reason}"
+                            )
+                    else:
+                        if self._logger:
+                            self._logger.info(
+                                f"{tag}, {operation} > {abs_url} - {status} {reason}"
+                            )
+                    # For non-empty response to GET, ensure valid JSON
+                    try:
+                        if method == "GET":
+                            await response.json()
+                        return response
+                    except (
+                            json.decoder.JSONDecodeError,
+                            aiohttp.client_exceptions.ContentTypeError,
+                    ) as e:
+                        if self._logger:
+                            self._logger.warning(
+                                f"{tag}, {operation} > {abs_url} - {e}, retrying in 1 second"
+                            )
+                        await asyncio.sleep(1)
+                # Handle 3XX redirects automatically
+                elif 300 <= status < 400:
+                    abs_url = response.headers["Location"]
+                    substring = "meraki.com/api/v"
+                    if substring not in abs_url:
+                        substring = "meraki.cn/api/v"
+                    self._base_url = abs_url[
+                                     : abs_url.find(substring) + len(substring) + 1
+                                     ]
+                # Rate limit 429 errors
+                elif status == 429:
+                    wait = 0
+                    if "Retry-After" in response.headers:
+                        wait = int(response.headers["Retry-After"])
+                    else:
+                        wait = random.randint(1, self._nginx_429_retry_wait_time)
+                    if self._logger:
+                        self._logger.warning(
+                            f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
+                        )
+                    await asyncio.sleep(wait)
+                # 5XX errors
+                elif status >= 500:
+                    if self._logger:
+                        self._logger.warning(
+                            f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in 1 second"
+                        )
+                    await asyncio.sleep(1)
+                # 4XX errors
+                else:
+                    try:
+                        message = await response.json()
+                    except aiohttp.client_exceptions.ContentTypeError:
+                        try:
+                            message = (await response.text())[:100]
+                        except:
+                            message = None
+
+                    # Check specifically for action batch concurrency error
+                    action_batch_concurrency_error = {
+                        "errors": [
+                            "Too many concurrently executing batches. Maximum is 5 confirmed but not yet executed batches."
+                        ]
+                    }
+                    if message == action_batch_concurrency_error:
+                        wait = self._action_batch_retry_wait_time
+                        if self._logger:
+                            self._logger.warning(
+                                f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
+                            )
+                        await asyncio.sleep(wait)
+
+                    elif self._retry_4xx_error:
+                        wait = random.randint(1, self._retry_4xx_error_wait_time)
+                        if self._logger:
+                            self._logger.warning(
+                                f"{tag}, {operation} > {abs_url} - {status} {reason}, retrying in {wait} seconds"
+                            )
+                        await asyncio.sleep(wait)
+
+                    # All other client-side errors
+                    else:
+                        if self._logger:
+                            self._logger.error(
+                                f"{tag}, {operation} > {abs_url} - {status} {reason}, {message}"
+                            )
+                        raise AsyncAPIError(metadata, response, message)
+            raise AsyncAPIError(
+                metadata, response, "Reached retry limit: " + str(message)
+            )
+
+    async def get(self, metadata, url, params=None):
+        metadata["method"] = "GET"
+        metadata["url"] = url
+        metadata["params"] = params
+        async with await self.request(metadata, "GET", url, params=params) as response:
+            return await response.json()
+
+    async def get_pages(
+            self,
+            metadata,
+            url,
+            params=None,
+            total_pages=-1,
+            direction="next",
+            event_log_end_time=None,
+    ):
+        pass
+
+    async def _download_page(self, request):
+        response = await request
+        result = await response.json()
+        return response, result
+
+    async def _get_pages_iterator(
+            self,
+            metadata,
+            url,
+            params=None,
+            total_pages=-1,
+            direction="next",
+            event_log_end_time=None,
+    ):
+        if type(total_pages) == str and total_pages.lower() == "all":
+            total_pages = -1
+        elif type(total_pages) == str and total_pages.isnumeric():
+            total_pages = int(total_pages)
+        metadata["page"] = 1
+
+        request_task = asyncio.create_task(
+            self._download_page(self.request(metadata, "GET", url, params=params))
+        )
+
+        # Get additional pages if more than one requested
+        while total_pages != 0:
+            response, results = await request_task
+            links = response.links
+
+            # GET the subsequent page
+            if direction == "next" and "next" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes forward
+                if metadata["operation"] == "getNetworkEvents":
+                    starting_after = urllib.parse.unquote(
+                        str(links["next"]["url"]).split("startingAfter=")[1]
+                    )
+                    delta = datetime.utcnow() - datetime.fromisoformat(
+                        starting_after[:-1]
+                    )
+                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
+                    if delta.total_seconds() < 300:
+                        break
+                    # Or if next page is past the specified window's end time
+                    elif event_log_end_time and starting_after > event_log_end_time:
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["next"]["url"]
+            elif direction == "prev" and "prev" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
+                if metadata["operation"] == "getNetworkEvents":
+                    ending_before = urllib.parse.unquote(
+                        str(links["prev"]["url"]).split("endingBefore=")[1]
+                    )
+                    # Break out of loop if endingBefore returned from prev link is before 2014
+                    if ending_before < "2014-01-01":
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["prev"]["url"]
+            else:
+                break
+
+            response.release()
+
+            total_pages = total_pages - 1
+
+            if total_pages != 0:
+                request_task = asyncio.create_task(
+                    self._download_page(self.request(metadata, "GET", nextlink))
+                )
+
+            return_items = []
+            # just prepare the list
+            if type(results) == list:
+                return_items = results
+            # For event log endpoint
+            elif type(results) == dict:
+                if direction == "next":
+                    return_items = results["events"][::-1]
+                else:
+                    return_items = results["events"]
+
+            for item in return_items:
+                yield item
+
+    async def _get_pages_legacy(
+            self,
+            metadata,
+            url,
+            params=None,
+            total_pages=-1,
+            direction="next",
+            event_log_end_time=None,
+    ):
+        if type(total_pages) == str and total_pages.lower() == "all":
+            total_pages = -1
+        elif type(total_pages) == str and total_pages.isnumeric():
+            total_pages = int(total_pages)
+        metadata["page"] = 1
+
+        async with await self.request(metadata, "GET", url, params=params) as response:
+            results = await response.json()
+
+            # For event log endpoint when using 'next' direction, so results/events are sorted chronologically
+            if (
+                    type(results) == dict
+                    and metadata["operation"] == "getNetworkEvents"
+                    and direction == "next"
+            ):
+                results["events"] = results["events"][::-1]
+
+            links = response.links
+
+        # Get additional pages if more than one requested
+        while total_pages != 1:
+            # GET the subsequent page
+            if direction == "next" and "next" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes forward
+                if metadata["operation"] == "getNetworkEvents":
+                    starting_after = urllib.parse.unquote(
+                        str(links["next"]["url"]).split("startingAfter=")[1]
+                    )
+                    delta = datetime.utcnow() - datetime.fromisoformat(
+                        starting_after[:-1]
+                    )
+                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
+                    if delta.total_seconds() < 300:
+                        break
+                    # Or if next page is past the specified window's end time
+                    elif event_log_end_time and starting_after > event_log_end_time:
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["next"]["url"]
+            elif direction == "prev" and "prev" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
+                if metadata["operation"] == "getNetworkEvents":
+                    ending_before = urllib.parse.unquote(
+                        str(links["prev"]["url"]).split("endingBefore=")[1]
+                    )
+                    # Break out of loop if endingBefore returned from prev link is before 2014
+                    if ending_before < "2014-01-01":
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["prev"]["url"]
+            else:
+                break
+
+            async with await self.request(metadata, "GET", nextlink) as response:
+                links = response.links
+                # Append that page's results, depending on the endpoint
+                if type(results) == list:
+                    results.extend(await response.json())
+                # For event log endpoint
+                elif type(results) == dict:
+                    json_response = await response.json()
+                    start = json_response["pageStartAt"]
+                    end = json_response["pageEndAt"]
+                    events = json_response["events"]
+                    if direction == "next":
+                        events = events[::-1]
+                    if start < results["pageStartAt"]:
+                        results["pageStartAt"] = start
+                    if end > results["pageEndAt"]:
+                        results["pageEndAt"] = end
+                    results["events"].extend(events)
+
+            total_pages = total_pages - 1
+
+        return results
+
+    async def post(self, metadata, url, json=None):
+        metadata["method"] = "POST"
+        metadata["url"] = url
+        metadata["json"] = json
+        async with await self.request(metadata, "POST", url, json=json) as response:
+            return await response.json()
+
+    async def put(self, metadata, url, json=None):
+        metadata["method"] = "PUT"
+        metadata["url"] = url
+        metadata["json"] = json
+        async with await self.request(metadata, "PUT", url, json=json) as response:
+            return await response.json()
+
+    async def delete(self, metadata, url):
+        metadata["method"] = "DELETE"
+        metadata["url"] = url
+        async with await self.request(metadata, "DELETE", url) as response:
+            return None
+
+    async def close(self):
+        await self._req_session.close()
```

### Comparing `meraki-1.7.1/meraki/api/appliance.py` & `meraki-1.7.2/meraki/api/appliance.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,1677 +1,1836 @@
-class Appliance(object):
-	def __init__(self, session):
-		super(Appliance, self).__init__()
-		self._session = session
-
-	def getDeviceApplianceDhcpSubnets(self, serial: str):
-		"""
-		**Return the DHCP subnet information for an appliance**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-dhcp-subnets
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'dhcp', 'subnets'],
-			'operation': 'getDeviceApplianceDhcpSubnets'
-		}
-		resource = f'/devices/{serial}/appliance/dhcp/subnets'
-
-		return self._session.get(metadata, resource)
-
-	def getDeviceAppliancePerformance(self, serial: str):
-		"""
-		**Return the performance score for a single MX**
-		https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-performance
-		
-		- serial (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'performance'],
-			'operation': 'getDeviceAppliancePerformance'
-		}
-		resource = f'/devices/{serial}/appliance/performance'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceClientSecurityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for a client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-client-security-events
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'clients', 'security', 'events'],
-			'operation': 'getNetworkApplianceClientSecurityEvents'
-		}
-		resource = f'/networks/{networkId}/appliance/clients/{clientId}/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str):
-		"""
-		**Return the connectivity testing destinations for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'getNetworkApplianceConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
-		"""
-		**Update the connectivity testing destinations for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		- destinations (array): The list of connectivity monitoring destinations
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
-
-		body_params = ['destinations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceContentFiltering(self, networkId: str):
-		"""
-		**Return the content filtering settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering'],
-			'operation': 'getNetworkApplianceContentFiltering'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceContentFiltering(self, networkId: str, **kwargs):
-		"""
-		**Update the content filtering settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-content-filtering
-		
-		- networkId (string): (required)
-		- allowedUrlPatterns (array): A list of URL patterns that are allowed
-		- blockedUrlPatterns (array): A list of URL patterns that are blocked
-		- blockedUrlCategories (array): A list of URL categories to block
-		- urlCategoryListSize (string): URL category list size which is either 'topSites' or 'fullList'
-		"""
-
-		kwargs.update(locals())
-
-		if 'urlCategoryListSize' in kwargs:
-			options = ['topSites', 'fullList']
-			assert kwargs['urlCategoryListSize'] in options, f'''"urlCategoryListSize" cannot be "{kwargs['urlCategoryListSize']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering'],
-			'operation': 'updateNetworkApplianceContentFiltering'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering'
-
-		body_params = ['allowedUrlPatterns', 'blockedUrlPatterns', 'blockedUrlCategories', 'urlCategoryListSize', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceContentFilteringCategories(self, networkId: str):
-		"""
-		**List all available content filtering categories for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'contentFiltering', 'categories'],
-			'operation': 'getNetworkApplianceContentFilteringCategories'
-		}
-		resource = f'/networks/{networkId}/appliance/contentFiltering/categories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallCellularFirewallRules(self, networkId: str):
-		"""
-		**Return the cellular firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-cellular-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
-			'operation': 'getNetworkApplianceFirewallCellularFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallCellularFirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the cellular firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-cellular-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallCellularFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallFirewalledServices(self, networkId: str):
-		"""
-		**List the appliance services and their accessibility rules**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-services
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'getNetworkApplianceFirewallFirewalledServices'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str):
-		"""
-		**Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-service
-		
-		- networkId (string): (required)
-		- service (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'getNetworkApplianceFirewallFirewalledService'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str, access: str, **kwargs):
-		"""
-		**Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-firewalled-service
-		
-		- networkId (string): (required)
-		- service (string): (required)
-		- access (string): A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
-		- allowedIps (array): An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored
-		"""
-
-		kwargs.update(locals())
-
-		if 'access' in kwargs:
-			options = ['blocked', 'restricted', 'unrestricted']
-			assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
-			'operation': 'updateNetworkApplianceFirewallFirewalledService'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
-
-		body_params = ['access', 'allowedIps', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallInboundFirewallRules(self, networkId: str):
-		"""
-		**Return the inbound firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-inbound-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
-			'operation': 'getNetworkApplianceFirewallInboundFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallInboundFirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the inbound firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-inbound-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallInboundFirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL3FirewallRules(self, networkId: str):
-		"""
-		**Return the L3 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
-			'operation': 'getNetworkApplianceFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallL3FirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the L3 firewall rules of an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-3-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallL3FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL7FirewallRules(self, networkId: str):
-		"""
-		**List the MX L7 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
-			'operation': 'getNetworkApplianceFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the MX L7 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the MX L7 firewall rules
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallL7FirewallRulesApplicationCategories(self, networkId: str):
-		"""
-		**Return the L7 firewall application categories and their associated applications for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules-application-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules', 'applicationCategories'],
-			'operation': 'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceFirewallOneToManyNatRules(self, networkId: str):
-		"""
-		**Return the 1:Many NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-many-nat-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
-			'operation': 'getNetworkApplianceFirewallOneToManyNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallOneToManyNatRules(self, networkId: str, rules: list):
-		"""
-		**Set the 1:Many NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-many-nat-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of 1:Many nat rules
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
-			'operation': 'updateNetworkApplianceFirewallOneToManyNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallOneToOneNatRules(self, networkId: str):
-		"""
-		**Return the 1:1 NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-one-nat-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
-			'operation': 'getNetworkApplianceFirewallOneToOneNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallOneToOneNatRules(self, networkId: str, rules: list):
-		"""
-		**Set the 1:1 NAT mapping rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-one-nat-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of 1:1 nat rules
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
-			'operation': 'updateNetworkApplianceFirewallOneToOneNatRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceFirewallPortForwardingRules(self, networkId: str):
-		"""
-		**Return the port forwarding rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-port-forwarding-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
-			'operation': 'getNetworkApplianceFirewallPortForwardingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceFirewallPortForwardingRules(self, networkId: str, rules: list):
-		"""
-		**Update the port forwarding rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-port-forwarding-rules
-		
-		- networkId (string): (required)
-		- rules (array): An array of port forwarding params
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
-			'operation': 'updateNetworkApplianceFirewallPortForwardingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkAppliancePorts(self, networkId: str):
-		"""
-		**List per-port VLAN settings for all ports of a MX.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-ports
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'getNetworkAppliancePorts'
-		}
-		resource = f'/networks/{networkId}/appliance/ports'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkAppliancePort(self, networkId: str, portId: str):
-		"""
-		**Return per-port VLAN settings for a single MX port.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-port
-		
-		- networkId (string): (required)
-		- portId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'getNetworkAppliancePort'
-		}
-		resource = f'/networks/{networkId}/appliance/ports/{portId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
-		"""
-		**Update the per-port VLAN settings for a single MX port.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
-		
-		- networkId (string): (required)
-		- portId (string): (required)
-		- enabled (boolean): The status of the port
-		- dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
-		- type (string): The type of the port: 'access' or 'trunk'.
-		- vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
-		- allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
-		- accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'updateNetworkAppliancePort'
-		}
-		resource = f'/networks/{networkId}/appliance/ports/{portId}'
-
-		body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSecurityEvents(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-events
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'security', 'events'],
-			'operation': 'getNetworkApplianceSecurityEvents'
-		}
-		resource = f'/networks/{networkId}/appliance/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkApplianceSecurityIntrusion(self, networkId: str):
-		"""
-		**Returns all supported intrusion settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-intrusion
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'getNetworkApplianceSecurityIntrusion'
-		}
-		resource = f'/networks/{networkId}/appliance/security/intrusion'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSecurityIntrusion(self, networkId: str, **kwargs):
-		"""
-		**Set the supported intrusion settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-intrusion
-		
-		- networkId (string): (required)
-		- mode (string): Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
-		- idsRulesets (string): Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
-		- protectedNetworks (object): Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['prevention', 'detection', 'disabled']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-		if 'idsRulesets' in kwargs:
-			options = ['connectivity', 'balanced', 'security']
-			assert kwargs['idsRulesets'] in options, f'''"idsRulesets" cannot be "{kwargs['idsRulesets']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'updateNetworkApplianceSecurityIntrusion'
-		}
-		resource = f'/networks/{networkId}/appliance/security/intrusion'
-
-		body_params = ['mode', 'idsRulesets', 'protectedNetworks', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSecurityMalware(self, networkId: str):
-		"""
-		**Returns all supported malware settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-malware
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'malware'],
-			'operation': 'getNetworkApplianceSecurityMalware'
-		}
-		resource = f'/networks/{networkId}/appliance/security/malware'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSecurityMalware(self, networkId: str, mode: str, **kwargs):
-		"""
-		**Set the supported malware settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-malware
-		
-		- networkId (string): (required)
-		- mode (string): Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
-		- allowedUrls (array): The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
-		- allowedFiles (array): The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['enabled', 'disabled']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'malware'],
-			'operation': 'updateNetworkApplianceSecurityMalware'
-		}
-		resource = f'/networks/{networkId}/appliance/security/malware'
-
-		body_params = ['mode', 'allowedUrls', 'allowedFiles', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceSettings(self, networkId: str):
-		"""
-		**Return the appliance settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'settings'],
-			'operation': 'getNetworkApplianceSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/settings'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceSingleLan(self, networkId: str):
-		"""
-		**Return single LAN configuration**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-single-lan
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'singleLan'],
-			'operation': 'getNetworkApplianceSingleLan'
-		}
-		resource = f'/networks/{networkId}/appliance/singleLan'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
-		"""
-		**Update single LAN configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
-		
-		- networkId (string): (required)
-		- subnet (string): The subnet of the single LAN configuration
-		- applianceIp (string): The appliance IP address of the single LAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'singleLan'],
-			'operation': 'updateNetworkApplianceSingleLan'
-		}
-		resource = f'/networks/{networkId}/appliance/singleLan'
-
-		body_params = ['subnet', 'applianceIp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceStaticRoutes(self, networkId: str):
-		"""
-		**List the static routes for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-routes
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'getNetworkApplianceStaticRoutes'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceStaticRoute(self, networkId: str, name: str, subnet: str, gatewayIp: str):
-		"""
-		**Add a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- name (string): The name of the new static route
-		- subnet (string): The subnet of the static route
-		- gatewayIp (string): The gateway IP (next hop) of the static route
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'createNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes'
-
-		body_params = ['name', 'subnet', 'gatewayIp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
-		"""
-		**Return a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'getNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str, **kwargs):
-		"""
-		**Update a static route for an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		- name (string): The name of the static route
-		- subnet (string): The subnet of the static route
-		- gatewayIp (string): The gateway IP (next hop) of the static route
-		- enabled (boolean): The enabled state of the static route
-		- fixedIpAssignments (object): The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
-		- reservedIpRanges (array): The DHCP reserved IP ranges on the static route
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'updateNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		body_params = ['name', 'subnet', 'gatewayIp', 'enabled', 'fixedIpAssignments', 'reservedIpRanges', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
-		"""
-		**Delete a static route from an MX or teleworker network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-static-route
-		
-		- networkId (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'staticRoutes'],
-			'operation': 'deleteNetworkApplianceStaticRoute'
-		}
-		resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkApplianceTrafficShaping(self, networkId: str):
-		"""
-		**Display the traffic shaping settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping'],
-			'operation': 'getNetworkApplianceTrafficShaping'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShaping(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic shaping settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping
-		
-		- networkId (string): (required)
-		- globalBandwidthLimits (object): Global per-client bandwidth limit
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping'],
-			'operation': 'updateNetworkApplianceTrafficShaping'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping'
-
-		body_params = ['globalBandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingCustomPerformanceClasses(self, networkId: str):
-		"""
-		**List all custom performance classes for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-classes
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClasses'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
-		"""
-		**Add a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
-		"""
-		**Return a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
-		"""
-		**Update a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
-		"""
-		**Delete a custom performance class from an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		return self._session.delete(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic shaping settings rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
-		- rules (array):     An array of traffic shaping rules. Rules are applied in the order that
-    they are specified in. An empty list (or null) means no rules. Note that
-    you are allowed a maximum of 8 rules.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
-			'operation': 'updateNetworkApplianceTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
-
-		body_params = ['defaultRulesEnabled', 'rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingRules(self, networkId: str):
-		"""
-		**Display the traffic shaping settings rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
-			'operation': 'getNetworkApplianceTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str):
-		"""
-		**Returns the uplink bandwidth settings for your MX network.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-bandwidth
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
-			'operation': 'getNetworkApplianceTrafficShapingUplinkBandwidth'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
-		"""
-		**Updates the uplink bandwidth settings for your MX network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
-		
-		- networkId (string): (required)
-		- bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
-
-		body_params = ['bandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str):
-		"""
-		**Show uplink selection settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-selection
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
-			'operation': 'getNetworkApplianceTrafficShapingUplinkSelection'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
-		"""
-		**Update uplink selection settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
-		
-		- networkId (string): (required)
-		- activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
-		- defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
-		- loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
-		- wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
-		- vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
-		"""
-
-		kwargs.update(locals())
-
-		if 'defaultUplink' in kwargs:
-			options = ['wan1', 'wan2']
-			assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
-
-		body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVlans(self, networkId: str):
-		"""
-		**List the VLANs for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'getNetworkApplianceVlans'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
-		"""
-		**Add a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
-		- name (string): The name of the new VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'createNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans'
-
-		body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkApplianceVlansSettings(self, networkId: str):
-		"""
-		**Returns the enabled status of VLANs for the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans', 'settings'],
-			'operation': 'getNetworkApplianceVlansSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
-		"""
-		**Enable/Disable VLANs for the given network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
-		
-		- networkId (string): (required)
-		- vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans', 'settings'],
-			'operation': 'updateNetworkApplianceVlansSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/settings'
-
-		body_params = ['vlansEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVlan(self, networkId: str, vlanId: str):
-		"""
-		**Return a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'getNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
-		"""
-		**Update a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		- name (string): The name of the VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		- vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
-		- dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
-		- dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
-		- dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
-		- dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
-		- dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
-		- dhcpBootFilename (string): DHCP boot option for boot filename
-		- fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
-		- reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
-		- dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
-		- dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
-		"""
-
-		kwargs.update(locals())
-
-		if 'dhcpHandling' in kwargs:
-			options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
-			assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
-		if 'dhcpLeaseTime' in kwargs:
-			options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
-			assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'updateNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
-		"""
-		**Delete a VLAN from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'deleteNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkApplianceVpnBgp(self, networkId: str):
-		"""
-		**Return a Hub BGP Configuration**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-bgp
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'bgp'],
-			'operation': 'getNetworkApplianceVpnBgp'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/bgp'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update a Hub BGP Configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
-		- asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
-		- ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
-		- neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'bgp'],
-			'operation': 'updateNetworkApplianceVpnBgp'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/bgp'
-
-		body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceVpnSiteToSiteVpn(self, networkId: str):
-		"""
-		**Return the site-to-site VPN settings of a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-site-to-site-vpn
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
-			'operation': 'getNetworkApplianceVpnSiteToSiteVpn'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
-		"""
-		**Update the site-to-site VPN settings of a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
-		
-		- networkId (string): (required)
-		- mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
-		- hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
-		- subnets (array): The list of subnets and their VPN presence.
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['none', 'spoke', 'hub']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
-			'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
-
-		body_params = ['mode', 'hubs', 'subnets', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkApplianceWarmSpare(self, networkId: str):
-		"""
-		**Return MX warm spare settings**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'getNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update MX warm spare settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		- enabled (boolean): Enable warm spare
-		- spareSerial (string): Serial number of the warm spare appliance
-		- uplinkMode (string): Uplink mode, either virtual or public
-		- virtualIp1 (string): The WAN 1 shared IP
-		- virtualIp2 (string): The WAN 2 shared IP
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'updateNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare'
-
-		body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def swapNetworkApplianceWarmSpare(self, networkId: str):
-		"""
-		**Swap MX primary and warm spare appliances**
-		https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'swapNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare/swap'
-
-		return self._session.post(metadata, resource)
-
-	def getOrganizationApplianceSecurityEvents(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the security events for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-events
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
-		"""
-
-		kwargs.update(locals())
-
-		if 'sortOrder' in kwargs:
-			options = ['ascending', 'descending']
-			assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'security', 'events'],
-			'operation': 'getOrganizationApplianceSecurityEvents'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/events'
-
-		query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceSecurityIntrusion(self, organizationId: str):
-		"""
-		**Returns all supported intrusion settings for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-intrusion
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'getOrganizationApplianceSecurityIntrusion'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/intrusion'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceSecurityIntrusion(self, organizationId: str, allowedRules: list):
-		"""
-		**Sets supported intrusion settings for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-security-intrusion
-		
-		- organizationId (string): (required)
-		- allowedRules (array): Sets a list of specific SNORT signatures to allow
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'security', 'intrusion'],
-			'operation': 'updateOrganizationApplianceSecurityIntrusion'
-		}
-		resource = f'/organizations/{organizationId}/appliance/security/intrusion'
-
-		body_params = ['allowedRules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getOrganizationApplianceUplinkStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the uplink status of every Meraki MX and Z series appliances in the organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-uplink-statuses
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of network IDs. The returned devices will be filtered to only include these networks.
-		- serials (array): A list of serial numbers. The returned devices will be filtered to only include these serials.
-		- iccids (array): A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'uplink', 'statuses'],
-			'operation': 'getOrganizationApplianceUplinkStatuses'
-		}
-		resource = f'/organizations/{organizationId}/appliance/uplink/statuses'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 'serials', 'iccids', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', 'serials', 'iccids', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnStats(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Show VPN history stat for networks in an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-stats
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'vpn', 'stats'],
-			'operation': 'getOrganizationApplianceVpnStats'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/stats'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Show VPN status for networks in an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-statuses
-		
-		- organizationId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'monitor', 'vpn', 'statuses'],
-			'operation': 'getOrganizationApplianceVpnStatuses'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/statuses'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['networkIds', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str):
-		"""
-		**Return the third party VPN peers for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-third-party-v-p-n-peers
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
-			'operation': 'getOrganizationApplianceVpnThirdPartyVPNPeers'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str, peers: list):
-		"""
-		**Update the third party VPN peers for an organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-third-party-v-p-n-peers
-		
-		- organizationId (string): (required)
-		- peers (array): The list of VPN peers
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
-			'operation': 'updateOrganizationApplianceVpnThirdPartyVPNPeers'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
-
-		body_params = ['peers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str):
-		"""
-		**Return the firewall rules for an organization's site-to-site VPN**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-vpn-firewall-rules
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
-			'operation': 'getOrganizationApplianceVpnVpnFirewallRules'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str, **kwargs):
-		"""
-		**Update the firewall rules of an organization's site-to-site VPN**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-vpn-firewall-rules
-		
-		- organizationId (string): (required)
-		- rules (array): An ordered array of the firewall rules (not including the default rule)
-		- syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
-			'operation': 'updateOrganizationApplianceVpnVpnFirewallRules'
-		}
-		resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
-
-		body_params = ['rules', 'syslogDefaultRule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
+class Appliance(object):
+    def __init__(self, session):
+        super(Appliance, self).__init__()
+        self._session = session
+        
+
+
+    def getDeviceApplianceDhcpSubnets(self, serial: str):
+        """
+        **Return the DHCP subnet information for an appliance**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-dhcp-subnets
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'dhcp', 'subnets'],
+            'operation': 'getDeviceApplianceDhcpSubnets'
+        }
+        resource = f'/devices/{serial}/appliance/dhcp/subnets'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getDeviceAppliancePerformance(self, serial: str):
+        """
+        **Return the performance score for a single MX**
+        https://developer.cisco.com/meraki/api-v1/#!get-device-appliance-performance
+
+        - serial (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'performance'],
+            'operation': 'getDeviceAppliancePerformance'
+        }
+        resource = f'/devices/{serial}/appliance/performance'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceClientSecurityEvents(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for a client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-client-security-events
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'clients', 'security', 'events'],
+            'operation': 'getNetworkApplianceClientSecurityEvents'
+        }
+        resource = f'/networks/{networkId}/appliance/clients/{clientId}/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str):
+        """
+        **Return the connectivity testing destinations for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'getNetworkApplianceConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
+        """
+        **Update the connectivity testing destinations for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        - destinations (array): The list of connectivity monitoring destinations
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
+
+        body_params = ['destinations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceContentFiltering(self, networkId: str):
+        """
+        **Return the content filtering settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering'],
+            'operation': 'getNetworkApplianceContentFiltering'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceContentFiltering(self, networkId: str, **kwargs):
+        """
+        **Update the content filtering settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-content-filtering
+
+        - networkId (string): (required)
+        - allowedUrlPatterns (array): A list of URL patterns that are allowed
+        - blockedUrlPatterns (array): A list of URL patterns that are blocked
+        - blockedUrlCategories (array): A list of URL categories to block
+        - urlCategoryListSize (string): URL category list size which is either 'topSites' or 'fullList'
+        """
+
+        kwargs.update(locals())
+
+        if 'urlCategoryListSize' in kwargs:
+            options = ['topSites', 'fullList']
+            assert kwargs['urlCategoryListSize'] in options, f'''"urlCategoryListSize" cannot be "{kwargs['urlCategoryListSize']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering'],
+            'operation': 'updateNetworkApplianceContentFiltering'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering'
+
+        body_params = ['allowedUrlPatterns', 'blockedUrlPatterns', 'blockedUrlCategories', 'urlCategoryListSize', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceContentFilteringCategories(self, networkId: str):
+        """
+        **List all available content filtering categories for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-content-filtering-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'contentFiltering', 'categories'],
+            'operation': 'getNetworkApplianceContentFilteringCategories'
+        }
+        resource = f'/networks/{networkId}/appliance/contentFiltering/categories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallCellularFirewallRules(self, networkId: str):
+        """
+        **Return the cellular firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-cellular-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
+            'operation': 'getNetworkApplianceFirewallCellularFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallCellularFirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the cellular firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-cellular-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'cellularFirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallCellularFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/cellularFirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallFirewalledServices(self, networkId: str):
+        """
+        **List the appliance services and their accessibility rules**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-services
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'getNetworkApplianceFirewallFirewalledServices'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str):
+        """
+        **Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-firewalled-service
+
+        - networkId (string): (required)
+        - service (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'getNetworkApplianceFirewallFirewalledService'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallFirewalledService(self, networkId: str, service: str, access: str, **kwargs):
+        """
+        **Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-firewalled-service
+
+        - networkId (string): (required)
+        - service (string): (required)
+        - access (string): A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
+        - allowedIps (array): An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored
+        """
+
+        kwargs.update(locals())
+
+        if 'access' in kwargs:
+            options = ['blocked', 'restricted', 'unrestricted']
+            assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'firewalledServices'],
+            'operation': 'updateNetworkApplianceFirewallFirewalledService'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/firewalledServices/{service}'
+
+        body_params = ['access', 'allowedIps', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallInboundFirewallRules(self, networkId: str):
+        """
+        **Return the inbound firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-inbound-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
+            'operation': 'getNetworkApplianceFirewallInboundFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallInboundFirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the inbound firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-inbound-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'inboundFirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallInboundFirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/inboundFirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL3FirewallRules(self, networkId: str):
+        """
+        **Return the L3 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
+            'operation': 'getNetworkApplianceFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallL3FirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the L3 firewall rules of an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-3-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l3FirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallL3FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l3FirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL7FirewallRules(self, networkId: str):
+        """
+        **List the MX L7 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
+            'operation': 'getNetworkApplianceFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the MX L7 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the MX L7 firewall rules
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallL7FirewallRulesApplicationCategories(self, networkId: str):
+        """
+        **Return the L7 firewall application categories and their associated applications for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-l-7-firewall-rules-application-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules', 'applicationCategories'],
+            'operation': 'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceFirewallOneToManyNatRules(self, networkId: str):
+        """
+        **Return the 1:Many NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-many-nat-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
+            'operation': 'getNetworkApplianceFirewallOneToManyNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallOneToManyNatRules(self, networkId: str, rules: list):
+        """
+        **Set the 1:Many NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-many-nat-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of 1:Many nat rules
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToManyNatRules'],
+            'operation': 'updateNetworkApplianceFirewallOneToManyNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToManyNatRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallOneToOneNatRules(self, networkId: str):
+        """
+        **Return the 1:1 NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-one-to-one-nat-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
+            'operation': 'getNetworkApplianceFirewallOneToOneNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallOneToOneNatRules(self, networkId: str, rules: list):
+        """
+        **Set the 1:1 NAT mapping rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-one-to-one-nat-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of 1:1 nat rules
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'oneToOneNatRules'],
+            'operation': 'updateNetworkApplianceFirewallOneToOneNatRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/oneToOneNatRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceFirewallPortForwardingRules(self, networkId: str):
+        """
+        **Return the port forwarding rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-firewall-port-forwarding-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
+            'operation': 'getNetworkApplianceFirewallPortForwardingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceFirewallPortForwardingRules(self, networkId: str, rules: list):
+        """
+        **Update the port forwarding rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-port-forwarding-rules
+
+        - networkId (string): (required)
+        - rules (array): An array of port forwarding params
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'portForwardingRules'],
+            'operation': 'updateNetworkApplianceFirewallPortForwardingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/portForwardingRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkAppliancePorts(self, networkId: str):
+        """
+        **List per-port VLAN settings for all ports of a MX.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-ports
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'getNetworkAppliancePorts'
+        }
+        resource = f'/networks/{networkId}/appliance/ports'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkAppliancePort(self, networkId: str, portId: str):
+        """
+        **Return per-port VLAN settings for a single MX port.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-port
+
+        - networkId (string): (required)
+        - portId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'getNetworkAppliancePort'
+        }
+        resource = f'/networks/{networkId}/appliance/ports/{portId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
+        """
+        **Update the per-port VLAN settings for a single MX port.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
+
+        - networkId (string): (required)
+        - portId (string): (required)
+        - enabled (boolean): The status of the port
+        - dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
+        - type (string): The type of the port: 'access' or 'trunk'.
+        - vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
+        - allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
+        - accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'updateNetworkAppliancePort'
+        }
+        resource = f'/networks/{networkId}/appliance/ports/{portId}'
+
+        body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSecurityEvents(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-events
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'security', 'events'],
+            'operation': 'getNetworkApplianceSecurityEvents'
+        }
+        resource = f'/networks/{networkId}/appliance/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkApplianceSecurityIntrusion(self, networkId: str):
+        """
+        **Returns all supported intrusion settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-intrusion
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'getNetworkApplianceSecurityIntrusion'
+        }
+        resource = f'/networks/{networkId}/appliance/security/intrusion'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSecurityIntrusion(self, networkId: str, **kwargs):
+        """
+        **Set the supported intrusion settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-intrusion
+
+        - networkId (string): (required)
+        - mode (string): Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
+        - idsRulesets (string): Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
+        - protectedNetworks (object): Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['prevention', 'detection', 'disabled']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+        if 'idsRulesets' in kwargs:
+            options = ['connectivity', 'balanced', 'security']
+            assert kwargs['idsRulesets'] in options, f'''"idsRulesets" cannot be "{kwargs['idsRulesets']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'updateNetworkApplianceSecurityIntrusion'
+        }
+        resource = f'/networks/{networkId}/appliance/security/intrusion'
+
+        body_params = ['mode', 'idsRulesets', 'protectedNetworks', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSecurityMalware(self, networkId: str):
+        """
+        **Returns all supported malware settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-security-malware
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'malware'],
+            'operation': 'getNetworkApplianceSecurityMalware'
+        }
+        resource = f'/networks/{networkId}/appliance/security/malware'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSecurityMalware(self, networkId: str, mode: str, **kwargs):
+        """
+        **Set the supported malware settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-security-malware
+
+        - networkId (string): (required)
+        - mode (string): Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
+        - allowedUrls (array): The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
+        - allowedFiles (array): The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['enabled', 'disabled']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'malware'],
+            'operation': 'updateNetworkApplianceSecurityMalware'
+        }
+        resource = f'/networks/{networkId}/appliance/security/malware'
+
+        body_params = ['mode', 'allowedUrls', 'allowedFiles', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceSettings(self, networkId: str):
+        """
+        **Return the appliance settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'settings'],
+            'operation': 'getNetworkApplianceSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceSingleLan(self, networkId: str):
+        """
+        **Return single LAN configuration**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-single-lan
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'singleLan'],
+            'operation': 'getNetworkApplianceSingleLan'
+        }
+        resource = f'/networks/{networkId}/appliance/singleLan'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
+        """
+        **Update single LAN configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
+
+        - networkId (string): (required)
+        - subnet (string): The subnet of the single LAN configuration
+        - applianceIp (string): The appliance IP address of the single LAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'singleLan'],
+            'operation': 'updateNetworkApplianceSingleLan'
+        }
+        resource = f'/networks/{networkId}/appliance/singleLan'
+
+        body_params = ['subnet', 'applianceIp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceStaticRoutes(self, networkId: str):
+        """
+        **List the static routes for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-routes
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'getNetworkApplianceStaticRoutes'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceStaticRoute(self, networkId: str, name: str, subnet: str, gatewayIp: str):
+        """
+        **Add a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-static-route
+
+        - networkId (string): (required)
+        - name (string): The name of the new static route
+        - subnet (string): The subnet of the static route
+        - gatewayIp (string): The gateway IP (next hop) of the static route
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'createNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes'
+
+        body_params = ['name', 'subnet', 'gatewayIp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
+        """
+        **Return a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'getNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str, **kwargs):
+        """
+        **Update a static route for an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        - name (string): The name of the static route
+        - subnet (string): The subnet of the static route
+        - gatewayIp (string): The gateway IP (next hop) of the static route
+        - enabled (boolean): The enabled state of the static route
+        - fixedIpAssignments (object): The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
+        - reservedIpRanges (array): The DHCP reserved IP ranges on the static route
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'updateNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        body_params = ['name', 'subnet', 'gatewayIp', 'enabled', 'fixedIpAssignments', 'reservedIpRanges', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceStaticRoute(self, networkId: str, staticRouteId: str):
+        """
+        **Delete a static route from an MX or teleworker network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-static-route
+
+        - networkId (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'staticRoutes'],
+            'operation': 'deleteNetworkApplianceStaticRoute'
+        }
+        resource = f'/networks/{networkId}/appliance/staticRoutes/{staticRouteId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkApplianceTrafficShaping(self, networkId: str):
+        """
+        **Display the traffic shaping settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping'],
+            'operation': 'getNetworkApplianceTrafficShaping'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShaping(self, networkId: str, **kwargs):
+        """
+        **Update the traffic shaping settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping
+
+        - networkId (string): (required)
+        - globalBandwidthLimits (object): Global per-client bandwidth limit
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping'],
+            'operation': 'updateNetworkApplianceTrafficShaping'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping'
+
+        body_params = ['globalBandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingCustomPerformanceClasses(self, networkId: str):
+        """
+        **List all custom performance classes for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-classes
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClasses'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
+        """
+        **Add a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
+        """
+        **Return a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'getNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
+        """
+        **Update a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
+        """
+        **Delete a custom performance class from an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
+        """
+        **Update the traffic shaping settings rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
+        - rules (array):     An array of traffic shaping rules. Rules are applied in the order that
+    they are specified in. An empty list (or null) means no rules. Note that
+    you are allowed a maximum of 8 rules.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
+            'operation': 'updateNetworkApplianceTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
+
+        body_params = ['defaultRulesEnabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingRules(self, networkId: str):
+        """
+        **Display the traffic shaping settings rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-rules
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
+            'operation': 'getNetworkApplianceTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str):
+        """
+        **Returns the uplink bandwidth settings for your MX network.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-bandwidth
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
+            'operation': 'getNetworkApplianceTrafficShapingUplinkBandwidth'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
+        """
+        **Updates the uplink bandwidth settings for your MX network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
+
+        - networkId (string): (required)
+        - bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
+
+        body_params = ['bandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str):
+        """
+        **Show uplink selection settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-traffic-shaping-uplink-selection
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
+            'operation': 'getNetworkApplianceTrafficShapingUplinkSelection'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
+        """
+        **Update uplink selection settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
+
+        - networkId (string): (required)
+        - activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
+        - defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
+        - loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
+        - wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
+        - vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
+        """
+
+        kwargs.update(locals())
+
+        if 'defaultUplink' in kwargs:
+            options = ['wan1', 'wan2']
+            assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
+
+        body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlans(self, networkId: str):
+        """
+        **List the VLANs for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'getNetworkApplianceVlans'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
+        """
+        **Add a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
+
+        - networkId (string): (required)
+        - id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
+        - name (string): The name of the new VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'createNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans'
+
+        body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlansSettings(self, networkId: str):
+        """
+        **Returns the enabled status of VLANs for the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlans-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans', 'settings'],
+            'operation': 'getNetworkApplianceVlansSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
+        """
+        **Enable/Disable VLANs for the given network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
+
+        - networkId (string): (required)
+        - vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans', 'settings'],
+            'operation': 'updateNetworkApplianceVlansSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/settings'
+
+        body_params = ['vlansEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVlan(self, networkId: str, vlanId: str):
+        """
+        **Return a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'getNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
+        """
+        **Update a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        - name (string): The name of the VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        - vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
+        - dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
+        - dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
+        - dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
+        - dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
+        - dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
+        - dhcpBootFilename (string): DHCP boot option for boot filename
+        - fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
+        - reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
+        - dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
+        - dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
+        """
+
+        kwargs.update(locals())
+
+        if 'dhcpHandling' in kwargs:
+            options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
+            assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
+        if 'dhcpLeaseTime' in kwargs:
+            options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
+            assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'updateNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
+        """
+        **Delete a VLAN from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'deleteNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkApplianceVpnBgp(self, networkId: str):
+        """
+        **Return a Hub BGP Configuration**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-bgp
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'bgp'],
+            'operation': 'getNetworkApplianceVpnBgp'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/bgp'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update a Hub BGP Configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
+        - asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
+        - ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
+        - neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'bgp'],
+            'operation': 'updateNetworkApplianceVpnBgp'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/bgp'
+
+        body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceVpnSiteToSiteVpn(self, networkId: str):
+        """
+        **Return the site-to-site VPN settings of a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-vpn-site-to-site-vpn
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
+            'operation': 'getNetworkApplianceVpnSiteToSiteVpn'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
+        """
+        **Update the site-to-site VPN settings of a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
+
+        - networkId (string): (required)
+        - mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
+        - hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
+        - subnets (array): The list of subnets and their VPN presence.
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['none', 'spoke', 'hub']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
+            'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
+
+        body_params = ['mode', 'hubs', 'subnets', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkApplianceWarmSpare(self, networkId: str):
+        """
+        **Return MX warm spare settings**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'getNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update MX warm spare settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        - enabled (boolean): Enable warm spare
+        - spareSerial (string): Serial number of the warm spare appliance
+        - uplinkMode (string): Uplink mode, either virtual or public
+        - virtualIp1 (string): The WAN 1 shared IP
+        - virtualIp2 (string): The WAN 2 shared IP
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'updateNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare'
+
+        body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def swapNetworkApplianceWarmSpare(self, networkId: str):
+        """
+        **Swap MX primary and warm spare appliances**
+        https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'swapNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare/swap'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getOrganizationApplianceSecurityEvents(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the security events for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-events
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - sortOrder (string): Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
+        """
+
+        kwargs.update(locals())
+
+        if 'sortOrder' in kwargs:
+            options = ['ascending', 'descending']
+            assert kwargs['sortOrder'] in options, f'''"sortOrder" cannot be "{kwargs['sortOrder']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'security', 'events'],
+            'operation': 'getOrganizationApplianceSecurityEvents'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/events'
+
+        query_params = ['t0', 't1', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'sortOrder', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceSecurityIntrusion(self, organizationId: str):
+        """
+        **Returns all supported intrusion settings for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-security-intrusion
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'getOrganizationApplianceSecurityIntrusion'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/intrusion'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceSecurityIntrusion(self, organizationId: str, allowedRules: list):
+        """
+        **Sets supported intrusion settings for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-security-intrusion
+
+        - organizationId (string): (required)
+        - allowedRules (array): Sets a list of specific SNORT signatures to allow
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'security', 'intrusion'],
+            'operation': 'updateOrganizationApplianceSecurityIntrusion'
+        }
+        resource = f'/organizations/{organizationId}/appliance/security/intrusion'
+
+        body_params = ['allowedRules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getOrganizationApplianceUplinkStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the uplink status of every Meraki MX and Z series appliances in the organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-uplink-statuses
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of network IDs. The returned devices will be filtered to only include these networks.
+        - serials (array): A list of serial numbers. The returned devices will be filtered to only include these serials.
+        - iccids (array): A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'uplink', 'statuses'],
+            'operation': 'getOrganizationApplianceUplinkStatuses'
+        }
+        resource = f'/organizations/{organizationId}/appliance/uplink/statuses'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 'serials', 'iccids', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', 'serials', 'iccids', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnStats(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Show VPN history stat for networks in an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-stats
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'vpn', 'stats'],
+            'operation': 'getOrganizationApplianceVpnStats'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/stats'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnStatuses(self, organizationId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Show VPN status for networks in an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-statuses
+
+        - organizationId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - networkIds (array): A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'monitor', 'vpn', 'statuses'],
+            'operation': 'getOrganizationApplianceVpnStatuses'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/statuses'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', 'networkIds', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['networkIds', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str):
+        """
+        **Return the third party VPN peers for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-third-party-v-p-n-peers
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
+            'operation': 'getOrganizationApplianceVpnThirdPartyVPNPeers'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceVpnThirdPartyVPNPeers(self, organizationId: str, peers: list):
+        """
+        **Update the third party VPN peers for an organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-third-party-v-p-n-peers
+
+        - organizationId (string): (required)
+        - peers (array): The list of VPN peers
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'thirdPartyVPNPeers'],
+            'operation': 'updateOrganizationApplianceVpnThirdPartyVPNPeers'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers'
+
+        body_params = ['peers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str):
+        """
+        **Return the firewall rules for an organization's site-to-site VPN**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-appliance-vpn-vpn-firewall-rules
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
+            'operation': 'getOrganizationApplianceVpnVpnFirewallRules'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationApplianceVpnVpnFirewallRules(self, organizationId: str, **kwargs):
+        """
+        **Update the firewall rules of an organization's site-to-site VPN**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-appliance-vpn-vpn-firewall-rules
+
+        - organizationId (string): (required)
+        - rules (array): An ordered array of the firewall rules (not including the default rule)
+        - syslogDefaultRule (boolean): Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'vpnFirewallRules'],
+            'operation': 'updateOrganizationApplianceVpnVpnFirewallRules'
+        }
+        resource = f'/organizations/{organizationId}/appliance/vpn/vpnFirewallRules'
+
+        body_params = ['rules', 'syslogDefaultRule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/appliance.py` & `meraki-1.7.2/meraki/api/batch/appliance.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,612 +1,614 @@
-class ActionBatchAppliance(object):
-	def __init__(self):
-		super(ActionBatchAppliance, self).__init__()
-
-	def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
-		"""
-		**Update the connectivity testing destinations for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		- destinations (array): The list of connectivity monitoring destinations
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
-
-		body_params = ['destinations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
-		"""
-		**Update the MX L7 firewall rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- rules (array): An ordered array of the MX L7 firewall rules
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
-			'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
-		"""
-		**Update the per-port VLAN settings for a single MX port.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
-		
-		- networkId (string): (required)
-		- portId (string): (required)
-		- enabled (boolean): The status of the port
-		- dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
-		- type (string): The type of the port: 'access' or 'trunk'.
-		- vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
-		- allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
-		- accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'ports'],
-			'operation': 'updateNetworkAppliancePort'
-		}
-		resource = f'/networks/{networkId}/appliance/ports/{portId}'
-
-		body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
-		"""
-		**Update single LAN configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
-		
-		- networkId (string): (required)
-		- subnet (string): The subnet of the single LAN configuration
-		- applianceIp (string): The appliance IP address of the single LAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'singleLan'],
-			'operation': 'updateNetworkApplianceSingleLan'
-		}
-		resource = f'/networks/{networkId}/appliance/singleLan'
-
-		body_params = ['subnet', 'applianceIp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
-		"""
-		**Add a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
-		"""
-		**Update a custom performance class for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		- name (string): Name of the custom performance class
-		- maxLatency (integer): Maximum latency in milliseconds
-		- maxJitter (integer): Maximum jitter in milliseconds
-		- maxLossPercentage (integer): Maximum percentage of packet loss
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
-		"""
-		**Delete a custom performance class from an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
-		
-		- networkId (string): (required)
-		- customPerformanceClassId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
-			'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic shaping settings rules for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
-		- rules (array):     An array of traffic shaping rules. Rules are applied in the order that
-    they are specified in. An empty list (or null) means no rules. Note that
-    you are allowed a maximum of 8 rules.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
-			'operation': 'updateNetworkApplianceTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
-
-		body_params = ['defaultRulesEnabled', 'rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
-		"""
-		**Updates the uplink bandwidth settings for your MX network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
-		
-		- networkId (string): (required)
-		- bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
-
-		body_params = ['bandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
-		"""
-		**Update uplink selection settings for an MX network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
-		
-		- networkId (string): (required)
-		- activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
-		- defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
-		- loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
-		- wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
-		- vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
-		"""
-
-		kwargs.update(locals())
-
-		if 'defaultUplink' in kwargs:
-			options = ['wan1', 'wan2']
-			assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
-			'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
-		}
-		resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
-
-		body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
-		"""
-		**Add a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
-		- name (string): The name of the new VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'createNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans'
-
-		body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
-		"""
-		**Enable/Disable VLANs for the given network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
-		
-		- networkId (string): (required)
-		- vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans', 'settings'],
-			'operation': 'updateNetworkApplianceVlansSettings'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/settings'
-
-		body_params = ['vlansEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
-		"""
-		**Update a VLAN**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		- name (string): The name of the VLAN
-		- subnet (string): The subnet of the VLAN
-		- applianceIp (string): The local IP of the appliance on the VLAN
-		- groupPolicyId (string): The id of the desired group policy to apply to the VLAN
-		- vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
-		- dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
-		- dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
-		- dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
-		- dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
-		- dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
-		- dhcpBootFilename (string): DHCP boot option for boot filename
-		- fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
-		- reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
-		- dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
-		- dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
-		"""
-
-		kwargs.update(locals())
-
-		if 'dhcpHandling' in kwargs:
-			options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
-			assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
-		if 'dhcpLeaseTime' in kwargs:
-			options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
-			assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'updateNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
-		"""
-		**Delete a VLAN from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
-		
-		- networkId (string): (required)
-		- vlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vlans'],
-			'operation': 'deleteNetworkApplianceVlan'
-		}
-		resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update a Hub BGP Configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
-		- asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
-		- ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
-		- neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'bgp'],
-			'operation': 'updateNetworkApplianceVpnBgp'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/bgp'
-
-		body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
-		"""
-		**Update the site-to-site VPN settings of a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
-		
-		- networkId (string): (required)
-		- mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
-		- hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
-		- subnets (array): The list of subnets and their VPN presence.
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['none', 'spoke', 'hub']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
-			'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
-		}
-		resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
-
-		body_params = ['mode', 'hubs', 'subnets', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
-		"""
-		**Update MX warm spare settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		- enabled (boolean): Enable warm spare
-		- spareSerial (string): Serial number of the warm spare appliance
-		- uplinkMode (string): Uplink mode, either virtual or public
-		- virtualIp1 (string): The WAN 1 shared IP
-		- virtualIp2 (string): The WAN 2 shared IP
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'updateNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare'
-
-		body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def swapNetworkApplianceWarmSpare(self, networkId: str):
-		"""
-		**Swap MX primary and warm spare appliances**
-		https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['appliance', 'configure', 'warmSpare'],
-			'operation': 'swapNetworkApplianceWarmSpare'
-		}
-		resource = f'/networks/{networkId}/appliance/warmSpare/swap'
-
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchAppliance(object):
+    def __init__(self):
+        super(ActionBatchAppliance, self).__init__()
+        
+
+
+    def updateNetworkApplianceConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
+        """
+        **Update the connectivity testing destinations for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        - destinations (array): The list of connectivity monitoring destinations
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'updateNetworkApplianceConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/appliance/connectivityMonitoringDestinations'
+
+        body_params = ['destinations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceFirewallL7FirewallRules(self, networkId: str, **kwargs):
+        """
+        **Update the MX L7 firewall rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - rules (array): An ordered array of the MX L7 firewall rules
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'firewall', 'l7FirewallRules'],
+            'operation': 'updateNetworkApplianceFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/appliance/firewall/l7FirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkAppliancePort(self, networkId: str, portId: str, **kwargs):
+        """
+        **Update the per-port VLAN settings for a single MX port.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-port
+
+        - networkId (string): (required)
+        - portId (string): (required)
+        - enabled (boolean): The status of the port
+        - dropUntaggedTraffic (boolean): Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
+        - type (string): The type of the port: 'access' or 'trunk'.
+        - vlan (integer): Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
+        - allowedVlans (string): Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
+        - accessPolicy (string): The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'ports'],
+            'operation': 'updateNetworkAppliancePort'
+        }
+        resource = f'/networks/{networkId}/appliance/ports/{portId}'
+
+        body_params = ['enabled', 'dropUntaggedTraffic', 'type', 'vlan', 'allowedVlans', 'accessPolicy', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceSingleLan(self, networkId: str, **kwargs):
+        """
+        **Update single LAN configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-single-lan
+
+        - networkId (string): (required)
+        - subnet (string): The subnet of the single LAN configuration
+        - applianceIp (string): The appliance IP address of the single LAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'singleLan'],
+            'operation': 'updateNetworkApplianceSingleLan'
+        }
+        resource = f'/networks/{networkId}/appliance/singleLan'
+
+        body_params = ['subnet', 'applianceIp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, name: str, **kwargs):
+        """
+        **Add a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str, **kwargs):
+        """
+        **Update a custom performance class for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        - name (string): Name of the custom performance class
+        - maxLatency (integer): Maximum latency in milliseconds
+        - maxJitter (integer): Maximum jitter in milliseconds
+        - maxLossPercentage (integer): Maximum percentage of packet loss
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        body_params = ['name', 'maxLatency', 'maxJitter', 'maxLossPercentage', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkApplianceTrafficShapingCustomPerformanceClass(self, networkId: str, customPerformanceClassId: str):
+        """
+        **Delete a custom performance class from an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-traffic-shaping-custom-performance-class
+
+        - networkId (string): (required)
+        - customPerformanceClassId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'customPerformanceClasses'],
+            'operation': 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceTrafficShapingRules(self, networkId: str, **kwargs):
+        """
+        **Update the traffic shaping settings rules for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
+        - rules (array):     An array of traffic shaping rules. Rules are applied in the order that
+    they are specified in. An empty list (or null) means no rules. Note that
+    you are allowed a maximum of 8 rules.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'rules'],
+            'operation': 'updateNetworkApplianceTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/rules'
+
+        body_params = ['defaultRulesEnabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceTrafficShapingUplinkBandwidth(self, networkId: str, **kwargs):
+        """
+        **Updates the uplink bandwidth settings for your MX network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-bandwidth
+
+        - networkId (string): (required)
+        - bandwidthLimits (object): A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkBandwidth'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth'
+
+        body_params = ['bandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceTrafficShapingUplinkSelection(self, networkId: str, **kwargs):
+        """
+        **Update uplink selection settings for an MX network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-traffic-shaping-uplink-selection
+
+        - networkId (string): (required)
+        - activeActiveAutoVpnEnabled (boolean): Toggle for enabling or disabling active-active AutoVPN
+        - defaultUplink (string): The default uplink. Must be one of: 'wan1' or 'wan2'
+        - loadBalancingEnabled (boolean): Toggle for enabling or disabling load balancing
+        - wanTrafficUplinkPreferences (array): Array of uplink preference rules for WAN traffic
+        - vpnTrafficUplinkPreferences (array): Array of uplink preference rules for VPN traffic
+        """
+
+        kwargs.update(locals())
+
+        if 'defaultUplink' in kwargs:
+            options = ['wan1', 'wan2']
+            assert kwargs['defaultUplink'] in options, f'''"defaultUplink" cannot be "{kwargs['defaultUplink']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'trafficShaping', 'uplinkSelection'],
+            'operation': 'updateNetworkApplianceTrafficShapingUplinkSelection'
+        }
+        resource = f'/networks/{networkId}/appliance/trafficShaping/uplinkSelection'
+
+        body_params = ['activeActiveAutoVpnEnabled', 'defaultUplink', 'loadBalancingEnabled', 'wanTrafficUplinkPreferences', 'vpnTrafficUplinkPreferences', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkApplianceVlan(self, networkId: str, id: str, name: str, **kwargs):
+        """
+        **Add a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-appliance-vlan
+
+        - networkId (string): (required)
+        - id (string): The VLAN ID of the new VLAN (must be between 1 and 4094)
+        - name (string): The name of the new VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'createNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans'
+
+        body_params = ['id', 'name', 'subnet', 'applianceIp', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceVlansSettings(self, networkId: str, **kwargs):
+        """
+        **Enable/Disable VLANs for the given network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlans-settings
+
+        - networkId (string): (required)
+        - vlansEnabled (boolean): Boolean indicating whether to enable (true) or disable (false) VLANs for the network
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans', 'settings'],
+            'operation': 'updateNetworkApplianceVlansSettings'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/settings'
+
+        body_params = ['vlansEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceVlan(self, networkId: str, vlanId: str, **kwargs):
+        """
+        **Update a VLAN**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        - name (string): The name of the VLAN
+        - subnet (string): The subnet of the VLAN
+        - applianceIp (string): The local IP of the appliance on the VLAN
+        - groupPolicyId (string): The id of the desired group policy to apply to the VLAN
+        - vpnNatSubnet (string): The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
+        - dhcpHandling (string): The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
+        - dhcpRelayServerIps (array): The IPs of the DHCP servers that DHCP requests should be relayed to
+        - dhcpLeaseTime (string): The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
+        - dhcpBootOptionsEnabled (boolean): Use DHCP boot options specified in other properties
+        - dhcpBootNextServer (string): DHCP boot option to direct boot clients to the server to load the boot file from
+        - dhcpBootFilename (string): DHCP boot option for boot filename
+        - fixedIpAssignments (object): The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
+        - reservedIpRanges (array): The DHCP reserved IP ranges on the VLAN
+        - dnsNameservers (string): The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
+        - dhcpOptions (array): The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
+        """
+
+        kwargs.update(locals())
+
+        if 'dhcpHandling' in kwargs:
+            options = ['Run a DHCP server', 'Relay DHCP to another server', 'Do not respond to DHCP requests']
+            assert kwargs['dhcpHandling'] in options, f'''"dhcpHandling" cannot be "{kwargs['dhcpHandling']}", & must be set to one of: {options}'''
+        if 'dhcpLeaseTime' in kwargs:
+            options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
+            assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'updateNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        body_params = ['name', 'subnet', 'applianceIp', 'groupPolicyId', 'vpnNatSubnet', 'dhcpHandling', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dhcpBootOptionsEnabled', 'dhcpBootNextServer', 'dhcpBootFilename', 'fixedIpAssignments', 'reservedIpRanges', 'dnsNameservers', 'dhcpOptions', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkApplianceVlan(self, networkId: str, vlanId: str):
+        """
+        **Delete a VLAN from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-appliance-vlan
+
+        - networkId (string): (required)
+        - vlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vlans'],
+            'operation': 'deleteNetworkApplianceVlan'
+        }
+        resource = f'/networks/{networkId}/appliance/vlans/{vlanId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceVpnBgp(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update a Hub BGP Configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-bgp
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
+        - asNumber (integer): An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
+        - ibgpHoldTimer (integer): The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
+        - neighbors (array): List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'bgp'],
+            'operation': 'updateNetworkApplianceVpnBgp'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/bgp'
+
+        body_params = ['enabled', 'asNumber', 'ibgpHoldTimer', 'neighbors', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceVpnSiteToSiteVpn(self, networkId: str, mode: str, **kwargs):
+        """
+        **Update the site-to-site VPN settings of a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-vpn-site-to-site-vpn
+
+        - networkId (string): (required)
+        - mode (string): The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
+        - hubs (array): The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
+        - subnets (array): The list of subnets and their VPN presence.
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['none', 'spoke', 'hub']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'vpn', 'siteToSiteVpn'],
+            'operation': 'updateNetworkApplianceVpnSiteToSiteVpn'
+        }
+        resource = f'/networks/{networkId}/appliance/vpn/siteToSiteVpn'
+
+        body_params = ['mode', 'hubs', 'subnets', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkApplianceWarmSpare(self, networkId: str, enabled: bool, **kwargs):
+        """
+        **Update MX warm spare settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        - enabled (boolean): Enable warm spare
+        - spareSerial (string): Serial number of the warm spare appliance
+        - uplinkMode (string): Uplink mode, either virtual or public
+        - virtualIp1 (string): The WAN 1 shared IP
+        - virtualIp2 (string): The WAN 2 shared IP
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'updateNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare'
+
+        body_params = ['enabled', 'spareSerial', 'uplinkMode', 'virtualIp1', 'virtualIp2', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def swapNetworkApplianceWarmSpare(self, networkId: str):
+        """
+        **Swap MX primary and warm spare appliances**
+        https://developer.cisco.com/meraki/api-v1/#!swap-network-appliance-warm-spare
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['appliance', 'configure', 'warmSpare'],
+            'operation': 'swapNetworkApplianceWarmSpare'
+        }
+        resource = f'/networks/{networkId}/appliance/warmSpare/swap'
+
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/camera.py` & `meraki-1.7.2/meraki/api/batch/camera.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,113 +1,115 @@
-class ActionBatchCamera(object):
-	def __init__(self):
-		super(ActionBatchCamera, self).__init__()
-
-	def updateDeviceCameraQualityAndRetention(self, serial: str, **kwargs):
-		"""
-		**Update quality and retention settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-quality-and-retention
-		
-		- serial (string): (required)
-		- profileId (string): The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.
-		- motionBasedRetentionEnabled (boolean): Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera.
-		- audioRecordingEnabled (boolean): Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera
-		- restrictedBandwidthModeEnabled (boolean): Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera
-		- quality (string): Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.
-		- resolution (string): Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model.
-		- motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
-		"""
-
-		kwargs.update(locals())
-
-		if 'quality' in kwargs:
-			options = ['Standard', 'High', 'Enhanced']
-			assert kwargs['quality'] in options, f'''"quality" cannot be "{kwargs['quality']}", & must be set to one of: {options}'''
-		if 'resolution' in kwargs:
-			options = ['1280x720', '1920x1080', '1080x1080', '2058x2058']
-			assert kwargs['resolution'] in options, f'''"resolution" cannot be "{kwargs['resolution']}", & must be set to one of: {options}'''
-		if 'motionDetectorVersion' in kwargs:
-			options = [1, 2]
-			assert kwargs['motionDetectorVersion'] in options, f'''"motionDetectorVersion" cannot be "{kwargs['motionDetectorVersion']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['camera', 'configure', 'qualityAndRetention'],
-			'operation': 'updateDeviceCameraQualityAndRetention'
-		}
-		resource = f'/devices/{serial}/camera/qualityAndRetention'
-
-		body_params = ['profileId', 'motionBasedRetentionEnabled', 'audioRecordingEnabled', 'restrictedBandwidthModeEnabled', 'quality', 'resolution', 'motionDetectorVersion', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceCameraSense(self, serial: str, **kwargs):
-		"""
-		**Update sense settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-sense
-		
-		- serial (string): (required)
-		- senseEnabled (boolean): Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera
-		- mqttBrokerId (string): The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera
-		- detectionModelId (string): The ID of the object detection model
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'sense'],
-			'operation': 'updateDeviceCameraSense'
-		}
-		resource = f'/devices/{serial}/camera/sense'
-
-		body_params = ['senseEnabled', 'mqttBrokerId', 'detectionModelId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceCameraVideoSettings(self, serial: str, **kwargs):
-		"""
-		**Update video settings for the given camera**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-camera-video-settings
-		
-		- serial (string): (required)
-		- externalRtspEnabled (boolean): Boolean indicating if external rtsp stream is exposed
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['camera', 'configure', 'video', 'settings'],
-			'operation': 'updateDeviceCameraVideoSettings'
-		}
-		resource = f'/devices/{serial}/camera/video/settings'
-
-		body_params = ['externalRtspEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchCamera(object):
+    def __init__(self):
+        super(ActionBatchCamera, self).__init__()
+        
+
+
+    def updateDeviceCameraQualityAndRetention(self, serial: str, **kwargs):
+        """
+        **Update quality and retention settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-quality-and-retention
+
+        - serial (string): (required)
+        - profileId (string): The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.
+        - motionBasedRetentionEnabled (boolean): Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera.
+        - audioRecordingEnabled (boolean): Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera
+        - restrictedBandwidthModeEnabled (boolean): Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera
+        - quality (string): Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.
+        - resolution (string): Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model.
+        - motionDetectorVersion (integer): The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
+        """
+
+        kwargs.update(locals())
+
+        if 'quality' in kwargs:
+            options = ['Standard', 'High', 'Enhanced']
+            assert kwargs['quality'] in options, f'''"quality" cannot be "{kwargs['quality']}", & must be set to one of: {options}'''
+        if 'resolution' in kwargs:
+            options = ['1280x720', '1920x1080', '1080x1080', '2058x2058']
+            assert kwargs['resolution'] in options, f'''"resolution" cannot be "{kwargs['resolution']}", & must be set to one of: {options}'''
+        if 'motionDetectorVersion' in kwargs:
+            options = [1, 2]
+            assert kwargs['motionDetectorVersion'] in options, f'''"motionDetectorVersion" cannot be "{kwargs['motionDetectorVersion']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['camera', 'configure', 'qualityAndRetention'],
+            'operation': 'updateDeviceCameraQualityAndRetention'
+        }
+        resource = f'/devices/{serial}/camera/qualityAndRetention'
+
+        body_params = ['profileId', 'motionBasedRetentionEnabled', 'audioRecordingEnabled', 'restrictedBandwidthModeEnabled', 'quality', 'resolution', 'motionDetectorVersion', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceCameraSense(self, serial: str, **kwargs):
+        """
+        **Update sense settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-sense
+
+        - serial (string): (required)
+        - senseEnabled (boolean): Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera
+        - mqttBrokerId (string): The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera
+        - detectionModelId (string): The ID of the object detection model
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'sense'],
+            'operation': 'updateDeviceCameraSense'
+        }
+        resource = f'/devices/{serial}/camera/sense'
+
+        body_params = ['senseEnabled', 'mqttBrokerId', 'detectionModelId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceCameraVideoSettings(self, serial: str, **kwargs):
+        """
+        **Update video settings for the given camera**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-camera-video-settings
+
+        - serial (string): (required)
+        - externalRtspEnabled (boolean): Boolean indicating if external rtsp stream is exposed
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['camera', 'configure', 'video', 'settings'],
+            'operation': 'updateDeviceCameraVideoSettings'
+        }
+        resource = f'/devices/{serial}/camera/video/settings'
+
+        body_params = ['externalRtspEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/cellularGateway.py` & `meraki-1.7.2/meraki/api/batch/cellularGateway.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,192 +1,194 @@
-class ActionBatchCellularGateway(object):
-	def __init__(self):
-		super(ActionBatchCellularGateway, self).__init__()
-
-	def updateDeviceCellularGatewayLan(self, serial: str, **kwargs):
-		"""
-		**Update the LAN Settings for a single MG.**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-cellular-gateway-lan
-		
-		- serial (string): (required)
-		- reservedIpRanges (array): list of all reserved IP ranges for a single MG
-		- fixedIpAssignments (array): list of all fixed IP assignments for a single MG
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'lan'],
-			'operation': 'updateDeviceCellularGatewayLan'
-		}
-		resource = f'/devices/{serial}/cellularGateway/lan'
-
-		body_params = ['reservedIpRanges', 'fixedIpAssignments', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceCellularGatewayPortForwardingRules(self, serial: str, **kwargs):
-		"""
-		**Updates the port forwarding rules for a single MG.**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-cellular-gateway-port-forwarding-rules
-		
-		- serial (string): (required)
-		- rules (array): An array of port forwarding params
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'portForwardingRules'],
-			'operation': 'updateDeviceCellularGatewayPortForwardingRules'
-		}
-		resource = f'/devices/{serial}/cellularGateway/portForwardingRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkCellularGatewayConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
-		"""
-		**Update the connectivity testing destinations for an MG network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-connectivity-monitoring-destinations
-		
-		- networkId (string): (required)
-		- destinations (array): The list of connectivity monitoring destinations
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'connectivityMonitoringDestinations'],
-			'operation': 'updateNetworkCellularGatewayConnectivityMonitoringDestinations'
-		}
-		resource = f'/networks/{networkId}/cellularGateway/connectivityMonitoringDestinations'
-
-		body_params = ['destinations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkCellularGatewayDhcp(self, networkId: str, **kwargs):
-		"""
-		**Update common DHCP settings of MGs**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-dhcp
-		
-		- networkId (string): (required)
-		- dhcpLeaseTime (string): DHCP Lease time for all MG of the network. It can be '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'.
-		- dnsNameservers (string): DNS name servers mode for all MG of the network. It can take 4 different values: 'upstream_dns', 'google_dns', 'opendns', 'custom'.
-		- dnsCustomNameservers (array): list of fixed IP representing the the DNS Name servers when the mode is 'custom'
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'dhcp'],
-			'operation': 'updateNetworkCellularGatewayDhcp'
-		}
-		resource = f'/networks/{networkId}/cellularGateway/dhcp'
-
-		body_params = ['dhcpLeaseTime', 'dnsNameservers', 'dnsCustomNameservers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkCellularGatewaySubnetPool(self, networkId: str, **kwargs):
-		"""
-		**Update the subnet pool and mask configuration for MGs in the network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-subnet-pool
-		
-		- networkId (string): (required)
-		- mask (integer): Mask used for the subnet of all MGs in  this network.
-		- cidr (string): CIDR of the pool of subnets. Each MG in this network will automatically pick a subnet from this pool.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'subnetPool'],
-			'operation': 'updateNetworkCellularGatewaySubnetPool'
-		}
-		resource = f'/networks/{networkId}/cellularGateway/subnetPool'
-
-		body_params = ['mask', 'cidr', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkCellularGatewayUplink(self, networkId: str, **kwargs):
-		"""
-		**Updates the uplink settings for your MG network.**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-uplink
-		
-		- networkId (string): (required)
-		- bandwidthLimits (object): The bandwidth settings for the 'cellular' uplink
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['cellularGateway', 'configure', 'uplink'],
-			'operation': 'updateNetworkCellularGatewayUplink'
-		}
-		resource = f'/networks/{networkId}/cellularGateway/uplink'
-
-		body_params = ['bandwidthLimits', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchCellularGateway(object):
+    def __init__(self):
+        super(ActionBatchCellularGateway, self).__init__()
+        
+
+
+    def updateDeviceCellularGatewayLan(self, serial: str, **kwargs):
+        """
+        **Update the LAN Settings for a single MG.**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-cellular-gateway-lan
+
+        - serial (string): (required)
+        - reservedIpRanges (array): list of all reserved IP ranges for a single MG
+        - fixedIpAssignments (array): list of all fixed IP assignments for a single MG
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'lan'],
+            'operation': 'updateDeviceCellularGatewayLan'
+        }
+        resource = f'/devices/{serial}/cellularGateway/lan'
+
+        body_params = ['reservedIpRanges', 'fixedIpAssignments', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceCellularGatewayPortForwardingRules(self, serial: str, **kwargs):
+        """
+        **Updates the port forwarding rules for a single MG.**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-cellular-gateway-port-forwarding-rules
+
+        - serial (string): (required)
+        - rules (array): An array of port forwarding params
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'portForwardingRules'],
+            'operation': 'updateDeviceCellularGatewayPortForwardingRules'
+        }
+        resource = f'/devices/{serial}/cellularGateway/portForwardingRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkCellularGatewayConnectivityMonitoringDestinations(self, networkId: str, **kwargs):
+        """
+        **Update the connectivity testing destinations for an MG network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-connectivity-monitoring-destinations
+
+        - networkId (string): (required)
+        - destinations (array): The list of connectivity monitoring destinations
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'connectivityMonitoringDestinations'],
+            'operation': 'updateNetworkCellularGatewayConnectivityMonitoringDestinations'
+        }
+        resource = f'/networks/{networkId}/cellularGateway/connectivityMonitoringDestinations'
+
+        body_params = ['destinations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkCellularGatewayDhcp(self, networkId: str, **kwargs):
+        """
+        **Update common DHCP settings of MGs**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-dhcp
+
+        - networkId (string): (required)
+        - dhcpLeaseTime (string): DHCP Lease time for all MG of the network. It can be '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'.
+        - dnsNameservers (string): DNS name servers mode for all MG of the network. It can take 4 different values: 'upstream_dns', 'google_dns', 'opendns', 'custom'.
+        - dnsCustomNameservers (array): list of fixed IP representing the the DNS Name servers when the mode is 'custom'
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'dhcp'],
+            'operation': 'updateNetworkCellularGatewayDhcp'
+        }
+        resource = f'/networks/{networkId}/cellularGateway/dhcp'
+
+        body_params = ['dhcpLeaseTime', 'dnsNameservers', 'dnsCustomNameservers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkCellularGatewaySubnetPool(self, networkId: str, **kwargs):
+        """
+        **Update the subnet pool and mask configuration for MGs in the network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-subnet-pool
+
+        - networkId (string): (required)
+        - mask (integer): Mask used for the subnet of all MGs in  this network.
+        - cidr (string): CIDR of the pool of subnets. Each MG in this network will automatically pick a subnet from this pool.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'subnetPool'],
+            'operation': 'updateNetworkCellularGatewaySubnetPool'
+        }
+        resource = f'/networks/{networkId}/cellularGateway/subnetPool'
+
+        body_params = ['mask', 'cidr', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkCellularGatewayUplink(self, networkId: str, **kwargs):
+        """
+        **Updates the uplink settings for your MG network.**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-cellular-gateway-uplink
+
+        - networkId (string): (required)
+        - bandwidthLimits (object): The bandwidth settings for the 'cellular' uplink
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['cellularGateway', 'configure', 'uplink'],
+            'operation': 'updateNetworkCellularGatewayUplink'
+        }
+        resource = f'/networks/{networkId}/cellularGateway/uplink'
+
+        body_params = ['bandwidthLimits', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/devices.py` & `meraki-1.7.2/meraki/api/batch/devices.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,73 +1,75 @@
-class ActionBatchDevices(object):
-	def __init__(self):
-		super(ActionBatchDevices, self).__init__()
-
-	def updateDevice(self, serial: str, **kwargs):
-		"""
-		**Update the attributes of a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device
-		
-		- serial (string): (required)
-		- name (string): The name of a device
-		- tags (array): The list of tags of a device
-		- lat (number): The latitude of a device
-		- lng (number): The longitude of a device
-		- address (string): The address of a device
-		- notes (string): The notes for the device. String. Limited to 255 characters.
-		- moveMapMarker (boolean): Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified.
-		- switchProfileId (string): The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template.
-		- floorPlanId (string): The floor plan to associate to this device. null disassociates the device from the floorplan.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['devices', 'configure'],
-			'operation': 'updateDevice'
-		}
-		resource = f'/devices/{serial}'
-
-		body_params = ['name', 'tags', 'lat', 'lng', 'address', 'notes', 'moveMapMarker', 'switchProfileId', 'floorPlanId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceManagementInterface(self, serial: str, **kwargs):
-		"""
-		**Update the management interface settings for a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-management-interface
-		
-		- serial (string): (required)
-		- wan1 (object): WAN 1 settings
-		- wan2 (object): WAN 2 settings (only for MX devices)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['devices', 'configure', 'managementInterface'],
-			'operation': 'updateDeviceManagementInterface'
-		}
-		resource = f'/devices/{serial}/managementInterface'
-
-		body_params = ['wan1', 'wan2', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchDevices(object):
+    def __init__(self):
+        super(ActionBatchDevices, self).__init__()
+        
+
+
+    def updateDevice(self, serial: str, **kwargs):
+        """
+        **Update the attributes of a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device
+
+        - serial (string): (required)
+        - name (string): The name of a device
+        - tags (array): The list of tags of a device
+        - lat (number): The latitude of a device
+        - lng (number): The longitude of a device
+        - address (string): The address of a device
+        - notes (string): The notes for the device. String. Limited to 255 characters.
+        - moveMapMarker (boolean): Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified.
+        - switchProfileId (string): The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template.
+        - floorPlanId (string): The floor plan to associate to this device. null disassociates the device from the floorplan.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['devices', 'configure'],
+            'operation': 'updateDevice'
+        }
+        resource = f'/devices/{serial}'
+
+        body_params = ['name', 'tags', 'lat', 'lng', 'address', 'notes', 'moveMapMarker', 'switchProfileId', 'floorPlanId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceManagementInterface(self, serial: str, **kwargs):
+        """
+        **Update the management interface settings for a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-management-interface
+
+        - serial (string): (required)
+        - wan1 (object): WAN 1 settings
+        - wan2 (object): WAN 2 settings (only for MX devices)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['devices', 'configure', 'managementInterface'],
+            'operation': 'updateDeviceManagementInterface'
+        }
+        resource = f'/devices/{serial}/managementInterface'
+
+        body_params = ['wan1', 'wan2', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/insight.py` & `meraki-1.7.2/meraki/api/batch/insight.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,96 +1,98 @@
-class ActionBatchInsight(object):
-	def __init__(self):
-		super(ActionBatchInsight, self).__init__()
-
-	def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
-		"""
-		**Add a media server to be monitored for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'createOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
-		"""
-		**Update a monitored media server for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'updateOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
-		"""
-		**Delete a monitored media server from this organization**
-		https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'deleteOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchInsight(object):
+    def __init__(self):
+        super(ActionBatchInsight, self).__init__()
+        
+
+
+    def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
+        """
+        **Add a media server to be monitored for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'createOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
+        """
+        **Update a monitored media server for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'updateOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
+        """
+        **Delete a monitored media server from this organization**
+        https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'deleteOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/sm.py` & `meraki-1.7.2/meraki/api/batch/sm.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,29 +1,31 @@
-class ActionBatchSm(object):
-	def __init__(self):
-		super(ActionBatchSm, self).__init__()
-
-	def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
-		"""
-		**Delete a User Access Device**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
-		
-		- networkId (string): (required)
-		- userAccessDeviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'userAccessDevices'],
-			'operation': 'deleteNetworkSmUserAccessDevice'
-		}
-		resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchSm(object):
+    def __init__(self):
+        super(ActionBatchSm, self).__init__()
+        
+
+
+    def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
+        """
+        **Delete a User Access Device**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
+
+        - networkId (string): (required)
+        - userAccessDeviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'userAccessDevices'],
+            'operation': 'deleteNetworkSmUserAccessDevice'
+        }
+        resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/switch.py` & `meraki-1.7.2/meraki/api/batch/switch.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,1512 +1,1514 @@
-class ActionBatchSwitch(object):
-	def __init__(self):
-		super(ActionBatchSwitch, self).__init__()
-
-	def cycleDeviceSwitchPorts(self, serial: str, ports: list):
-		"""
-		**Cycle a set of switch ports**
-		https://developer.cisco.com/meraki/api-v1/#!cycle-device-switch-ports
-		
-		- serial (string): (required)
-		- ports (array): List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'liveTools', 'ports'],
-			'operation': 'cycleDeviceSwitchPorts'
-		}
-		resource = f'/devices/{serial}/switch/ports/cycle'
-
-		body_params = ['ports', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceSwitchPort(self, serial: str, portId: str, **kwargs):
-		"""
-		**Update a switch port**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-switch-port
-		
-		- serial (string): (required)
-		- portId (string): (required)
-		- name (string): The name of the switch port
-		- tags (array): The list of tags of the switch port
-		- enabled (boolean): The status of the switch port
-		- type (string): The type of the switch port ('trunk' or 'access')
-		- vlan (integer): The VLAN of the switch port. A null value will clear the value set for trunk ports.
-		- voiceVlan (integer): The voice VLAN of the switch port. Only applicable to access ports.
-		- allowedVlans (string): The VLANs allowed on the switch port. Only applicable to trunk ports.
-		- poeEnabled (boolean): The PoE status of the switch port
-		- isolationEnabled (boolean): The isolation status of the switch port
-		- rstpEnabled (boolean): The rapid spanning tree protocol status
-		- stpGuard (string): The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')
-		- linkNegotiation (string): The link speed for the switch port
-		- portScheduleId (string): The ID of the port schedule. A value of null will clear the port schedule.
-		- udld (string): The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
-		- accessPolicyType (string): The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'
-		- accessPolicyNumber (integer): The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'
-		- macAllowList (array): Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'
-		- stickyMacAllowList (array): The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
-		- stickyMacAllowListLimit (integer): The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
-		- stormControlEnabled (boolean): The storm control status of the switch port
-		- flexibleStackingEnabled (boolean): For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
-		"""
-
-		kwargs.update(locals())
-
-		if 'type' in kwargs:
-			options = ['trunk', 'access']
-			assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
-		if 'stpGuard' in kwargs:
-			options = ['disabled', 'root guard', 'bpdu guard', 'loop guard']
-			assert kwargs['stpGuard'] in options, f'''"stpGuard" cannot be "{kwargs['stpGuard']}", & must be set to one of: {options}'''
-		if 'udld' in kwargs:
-			options = ['Alert only', 'Enforce']
-			assert kwargs['udld'] in options, f'''"udld" cannot be "{kwargs['udld']}", & must be set to one of: {options}'''
-		if 'accessPolicyType' in kwargs:
-			options = ['Open', 'Custom access policy', 'MAC allow list', 'Sticky MAC allow list']
-			assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'ports'],
-			'operation': 'updateDeviceSwitchPort'
-		}
-		resource = f'/devices/{serial}/switch/ports/{portId}'
-
-		body_params = ['name', 'tags', 'enabled', 'type', 'vlan', 'voiceVlan', 'allowedVlans', 'poeEnabled', 'isolationEnabled', 'rstpEnabled', 'stpGuard', 'linkNegotiation', 'portScheduleId', 'udld', 'accessPolicyType', 'accessPolicyNumber', 'macAllowList', 'stickyMacAllowList', 'stickyMacAllowListLimit', 'stormControlEnabled', 'flexibleStackingEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createDeviceSwitchRoutingInterface(self, serial: str, name: str, interfaceIp: str, vlanId: int, **kwargs):
-		"""
-		**Create a layer 3 interface for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-interface
-		
-		- serial (string): (required)
-		- name (string): A friendly name or description for the interface or VLAN.
-		- interfaceIp (string): The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
-		- vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
-		- subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
-		- multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
-		- defaultGateway (string): The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
-		- ospfSettings (object): The OSPF routing settings of the interface.
-		"""
-
-		kwargs.update(locals())
-
-		if 'multicastRouting' in kwargs:
-			options = ['disabled', 'enabled', 'IGMP snooping querier']
-			assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'interfaces'],
-			'operation': 'createDeviceSwitchRoutingInterface'
-		}
-		resource = f'/devices/{serial}/switch/routing/interfaces'
-
-		body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'defaultGateway', 'ospfSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceSwitchRoutingInterface(self, serial: str, interfaceId: str, **kwargs):
-		"""
-		**Update a layer 3 interface for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface
-		
-		- serial (string): (required)
-		- interfaceId (string): (required)
-		- name (string): A friendly name or description for the interface or VLAN.
-		- subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
-		- interfaceIp (string): The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
-		- multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'.
-		- vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
-		- ospfSettings (object): The OSPF routing settings of the interface.
-		"""
-
-		kwargs.update(locals())
-
-		if 'multicastRouting' in kwargs:
-			options = ['disabled', 'enabled', 'IGMP snooping querier']
-			assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'interfaces'],
-			'operation': 'updateDeviceSwitchRoutingInterface'
-		}
-		resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}'
-
-		body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'ospfSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteDeviceSwitchRoutingInterface(self, serial: str, interfaceId: str):
-		"""
-		**Delete a layer 3 interface from the switch**
-		https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-interface
-		
-		- serial (string): (required)
-		- interfaceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'interfaces'],
-			'operation': 'deleteDeviceSwitchRoutingInterface'
-		}
-		resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceSwitchRoutingInterfaceDhcp(self, serial: str, interfaceId: str, **kwargs):
-		"""
-		**Update a layer 3 interface DHCP configuration for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface-dhcp
-		
-		- serial (string): (required)
-		- interfaceId (string): (required)
-		- dhcpMode (string): The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
-		- dhcpRelayServerIps (array): The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface
-		- dhcpLeaseTime (string): The DHCP lease time config for the dhcp server running on switch interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
-		- dnsNameserversOption (string): The DHCP name server option for the dhcp server running on the switch interface ('googlePublicDns', 'openDns' or 'custom')
-		- dnsCustomNameservers (array): The DHCP name server IPs when DHCP name server option is 'custom'
-		- bootOptionsEnabled (boolean): Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch interface
-		- bootNextServer (string): The PXE boot server IP for the DHCP server running on the switch interface
-		- bootFileName (string): The PXE boot server filename for the DHCP server running on the switch interface
-		- dhcpOptions (array): Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface
-		- reservedIpRanges (array): Array of DHCP reserved IP assignments for the DHCP server running on the switch interface
-		- fixedIpAssignments (array): Array of DHCP fixed IP assignments for the DHCP server running on the switch interface
-		"""
-
-		kwargs.update(locals())
-
-		if 'dhcpMode' in kwargs:
-			options = ['dhcpDisabled', 'dhcpRelay', 'dhcpServer']
-			assert kwargs['dhcpMode'] in options, f'''"dhcpMode" cannot be "{kwargs['dhcpMode']}", & must be set to one of: {options}'''
-		if 'dhcpLeaseTime' in kwargs:
-			options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
-			assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
-		if 'dnsNameserversOption' in kwargs:
-			options = ['googlePublicDns', 'openDns', 'custom']
-			assert kwargs['dnsNameserversOption'] in options, f'''"dnsNameserversOption" cannot be "{kwargs['dnsNameserversOption']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'interfaces', 'dhcp'],
-			'operation': 'updateDeviceSwitchRoutingInterfaceDhcp'
-		}
-		resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp'
-
-		body_params = ['dhcpMode', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dnsNameserversOption', 'dnsCustomNameservers', 'bootOptionsEnabled', 'bootNextServer', 'bootFileName', 'dhcpOptions', 'reservedIpRanges', 'fixedIpAssignments', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createDeviceSwitchRoutingStaticRoute(self, serial: str, subnet: str, nextHopIp: str, **kwargs):
-		"""
-		**Create a layer 3 static route for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-static-route
-		
-		- serial (string): (required)
-		- subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
-		- nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
-		- name (string): Name or description for layer 3 static route
-		- advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
-		- preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
-			'operation': 'createDeviceSwitchRoutingStaticRoute'
-		}
-		resource = f'/devices/{serial}/switch/routing/staticRoutes'
-
-		body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceSwitchRoutingStaticRoute(self, serial: str, staticRouteId: str, **kwargs):
-		"""
-		**Update a layer 3 static route for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-static-route
-		
-		- serial (string): (required)
-		- staticRouteId (string): (required)
-		- name (string): Name or description for layer 3 static route
-		- subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
-		- nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
-		- advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
-		- preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
-			'operation': 'updateDeviceSwitchRoutingStaticRoute'
-		}
-		resource = f'/devices/{serial}/switch/routing/staticRoutes/{staticRouteId}'
-
-		body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteDeviceSwitchRoutingStaticRoute(self, serial: str, staticRouteId: str):
-		"""
-		**Delete a layer 3 static route for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-static-route
-		
-		- serial (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
-			'operation': 'deleteDeviceSwitchRoutingStaticRoute'
-		}
-		resource = f'/devices/{serial}/switch/routing/staticRoutes/{staticRouteId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceSwitchWarmSpare(self, serial: str, enabled: bool, **kwargs):
-		"""
-		**Update warm spare configuration for a switch**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-switch-warm-spare
-		
-		- serial (string): (required)
-		- enabled (boolean): Enable or disable warm spare for a switch
-		- spareSerial (string): Serial number of the warm spare switch
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'warmSpare'],
-			'operation': 'updateDeviceSwitchWarmSpare'
-		}
-		resource = f'/devices/{serial}/switch/warmSpare'
-
-		body_params = ['enabled', 'spareSerial', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchAccessPolicy(self, networkId: str, name: str, radiusServers: list, radiusTestingEnabled: bool, radiusCoaSupportEnabled: bool, radiusAccountingEnabled: bool, hostMode: str, urlRedirectWalledGardenEnabled: bool, **kwargs):
-		"""
-		**Create an access policy for a switch network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-access-policy
-		
-		- networkId (string): (required)
-		- name (string): Name of the access policy
-		- radiusServers (array): List of RADIUS servers to require connecting devices to authenticate against before granting network access
-		- radiusTestingEnabled (boolean): If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
-		- radiusCoaSupportEnabled (boolean): Change of authentication for RADIUS re-authentication and disconnection
-		- radiusAccountingEnabled (boolean): Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
-		- hostMode (string): Choose the Host Mode for the access policy.
-		- urlRedirectWalledGardenEnabled (boolean): Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
-		- radiusAccountingServers (array): List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
-		- radiusGroupAttribute (string): Acceptable values are `""` for None, or `"11"` for Group Policies ACL
-		- accessPolicyType (string): Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
-		- increaseAccessSpeed (boolean): Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
-		- guestVlanId (integer): ID for the guest VLAN allow unauthorized devices access to limited network resources
-		- voiceVlanClients (boolean): CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
-		- urlRedirectWalledGardenRanges (array): IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
-		"""
-
-		kwargs.update(locals())
-
-		if 'hostMode' in kwargs:
-			options = ['Single-Host', 'Multi-Domain', 'Multi-Host', 'Multi-Auth']
-			assert kwargs['hostMode'] in options, f'''"hostMode" cannot be "{kwargs['hostMode']}", & must be set to one of: {options}'''
-		if 'accessPolicyType' in kwargs:
-			options = ['802.1x', 'MAC authentication bypass', 'Hybrid authentication']
-			assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'accessPolicies'],
-			'operation': 'createNetworkSwitchAccessPolicy'
-		}
-		resource = f'/networks/{networkId}/switch/accessPolicies'
-
-		body_params = ['name', 'radiusServers', 'radiusTestingEnabled', 'radiusCoaSupportEnabled', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusGroupAttribute', 'hostMode', 'accessPolicyType', 'increaseAccessSpeed', 'guestVlanId', 'voiceVlanClients', 'urlRedirectWalledGardenEnabled', 'urlRedirectWalledGardenRanges', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchAccessPolicy(self, networkId: str, accessPolicyNumber: str, **kwargs):
-		"""
-		**Update an access policy for a switch network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-access-policy
-		
-		- networkId (string): (required)
-		- accessPolicyNumber (string): (required)
-		- name (string): Name of the access policy
-		- radiusServers (array): List of RADIUS servers to require connecting devices to authenticate against before granting network access
-		- radiusTestingEnabled (boolean): If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
-		- radiusCoaSupportEnabled (boolean): Change of authentication for RADIUS re-authentication and disconnection
-		- radiusAccountingEnabled (boolean): Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
-		- radiusAccountingServers (array): List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
-		- radiusGroupAttribute (string): Can be either `""`, which means `None` on Dashboard, or `"11"`, which means `Filter-Id` on Dashboard and will use Group Policy ACLs when supported (firmware 14+)
-		- hostMode (string): Choose the Host Mode for the access policy.
-		- accessPolicyType (string): Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
-		- increaseAccessSpeed (boolean): Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
-		- guestVlanId (integer): ID for the guest VLAN allow unauthorized devices access to limited network resources
-		- voiceVlanClients (boolean): CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
-		- urlRedirectWalledGardenEnabled (boolean): Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
-		- urlRedirectWalledGardenRanges (array): IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
-		"""
-
-		kwargs.update(locals())
-
-		if 'hostMode' in kwargs:
-			options = ['Single-Host', 'Multi-Domain', 'Multi-Host', 'Multi-Auth']
-			assert kwargs['hostMode'] in options, f'''"hostMode" cannot be "{kwargs['hostMode']}", & must be set to one of: {options}'''
-		if 'accessPolicyType' in kwargs:
-			options = ['802.1x', 'MAC authentication bypass', 'Hybrid authentication']
-			assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'accessPolicies'],
-			'operation': 'updateNetworkSwitchAccessPolicy'
-		}
-		resource = f'/networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}'
-
-		body_params = ['name', 'radiusServers', 'radiusTestingEnabled', 'radiusCoaSupportEnabled', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusGroupAttribute', 'hostMode', 'accessPolicyType', 'increaseAccessSpeed', 'guestVlanId', 'voiceVlanClients', 'urlRedirectWalledGardenEnabled', 'urlRedirectWalledGardenRanges', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchAccessPolicy(self, networkId: str, accessPolicyNumber: str):
-		"""
-		**Delete an access policy for a switch network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-access-policy
-		
-		- networkId (string): (required)
-		- accessPolicyNumber (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'accessPolicies'],
-			'operation': 'deleteNetworkSwitchAccessPolicy'
-		}
-		resource = f'/networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchAlternateManagementInterface(self, networkId: str, **kwargs):
-		"""
-		**Update the switch alternate management interface for the network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-alternate-management-interface
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
-		- vlanId (integer): Alternate management VLAN, must be between 1 and 4094
-		- protocols (array): Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
-		- switches (array): Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'alternateManagementInterface'],
-			'operation': 'updateNetworkSwitchAlternateManagementInterface'
-		}
-		resource = f'/networks/{networkId}/switch/alternateManagementInterface'
-
-		body_params = ['enabled', 'vlanId', 'protocols', 'switches', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchDhcpServerPolicy(self, networkId: str, **kwargs):
-		"""
-		**Update the DHCP server policy**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dhcp-server-policy
-		
-		- networkId (string): (required)
-		- defaultPolicy (string): 'allow' or 'block' new DHCP servers. Default value is 'allow'.
-		- allowedServers (array): List the MAC addresses of DHCP servers to permit on the network. Applicable only if defaultPolicy is set to block. An empty array will clear the entries.
-		- blockedServers (array): List the MAC addresses of DHCP servers to block on the network. Applicable only if defaultPolicy is set to allow. An empty array will clear the entries.
-		"""
-
-		kwargs.update(locals())
-
-		if 'defaultPolicy' in kwargs:
-			options = ['allow', 'block']
-			assert kwargs['defaultPolicy'] in options, f'''"defaultPolicy" cannot be "{kwargs['defaultPolicy']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'dhcpServerPolicy'],
-			'operation': 'updateNetworkSwitchDhcpServerPolicy'
-		}
-		resource = f'/networks/{networkId}/switch/dhcpServerPolicy'
-
-		body_params = ['defaultPolicy', 'allowedServers', 'blockedServers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchDscpToCosMappings(self, networkId: str, mappings: list):
-		"""
-		**Update the DSCP to CoS mappings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dscp-to-cos-mappings
-		
-		- networkId (string): (required)
-		- mappings (array): An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'configure', 'dscpToCosMappings'],
-			'operation': 'updateNetworkSwitchDscpToCosMappings'
-		}
-		resource = f'/networks/{networkId}/switch/dscpToCosMappings'
-
-		body_params = ['mappings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchLinkAggregation(self, networkId: str, **kwargs):
-		"""
-		**Create a link aggregation group**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-link-aggregation
-		
-		- networkId (string): (required)
-		- switchPorts (array): Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
-		- switchProfilePorts (array): Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'linkAggregations'],
-			'operation': 'createNetworkSwitchLinkAggregation'
-		}
-		resource = f'/networks/{networkId}/switch/linkAggregations'
-
-		body_params = ['switchPorts', 'switchProfilePorts', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchLinkAggregation(self, networkId: str, linkAggregationId: str, **kwargs):
-		"""
-		**Update a link aggregation group**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-link-aggregation
-		
-		- networkId (string): (required)
-		- linkAggregationId (string): (required)
-		- switchPorts (array): Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
-		- switchProfilePorts (array): Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'linkAggregations'],
-			'operation': 'updateNetworkSwitchLinkAggregation'
-		}
-		resource = f'/networks/{networkId}/switch/linkAggregations/{linkAggregationId}'
-
-		body_params = ['switchPorts', 'switchProfilePorts', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchLinkAggregation(self, networkId: str, linkAggregationId: str):
-		"""
-		**Split a link aggregation group into separate ports**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-link-aggregation
-		
-		- networkId (string): (required)
-		- linkAggregationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'linkAggregations'],
-			'operation': 'deleteNetworkSwitchLinkAggregation'
-		}
-		resource = f'/networks/{networkId}/switch/linkAggregations/{linkAggregationId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchMtu(self, networkId: str, **kwargs):
-		"""
-		**Update the MTU configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-mtu
-		
-		- networkId (string): (required)
-		- defaultMtuSize (integer): MTU size for the entire network. Default value is 9578.
-		- overrides (array): Override MTU size for individual switches or switch profiles. An empty array will clear overrides.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'mtu'],
-			'operation': 'updateNetworkSwitchMtu'
-		}
-		resource = f'/networks/{networkId}/switch/mtu'
-
-		body_params = ['defaultMtuSize', 'overrides', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchPortSchedule(self, networkId: str, portScheduleId: str, **kwargs):
-		"""
-		**Update a switch port schedule**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-port-schedule
-		
-		- networkId (string): (required)
-		- portScheduleId (string): (required)
-		- name (string): The name for your port schedule.
-		- portSchedule (object):     The schedule for switch port scheduling. Schedules are applied to days of the week.
-    When it's empty, default schedule with all days of a week are configured.
-    Any unspecified day in the schedule is added as a default schedule configuration of the day.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'portSchedules'],
-			'operation': 'updateNetworkSwitchPortSchedule'
-		}
-		resource = f'/networks/{networkId}/switch/portSchedules/{portScheduleId}'
-
-		body_params = ['name', 'portSchedule', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchQosRule(self, networkId: str, vlan: int, **kwargs):
-		"""
-		**Add a quality of service rule**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-qos-rule
-		
-		- networkId (string): (required)
-		- vlan (integer): The VLAN of the incoming packet. A null value will match any VLAN.
-		- protocol (string): The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY"
-		- srcPort (integer): The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
-		- srcPortRange (string): The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
-		- dstPort (integer): The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
-		- dstPortRange (string): The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
-		- dscp (integer): DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0
-		"""
-
-		kwargs.update(locals())
-
-		if 'protocol' in kwargs:
-			options = ['ANY', 'TCP', 'UDP']
-			assert kwargs['protocol'] in options, f'''"protocol" cannot be "{kwargs['protocol']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'qosRules'],
-			'operation': 'createNetworkSwitchQosRule'
-		}
-		resource = f'/networks/{networkId}/switch/qosRules'
-
-		body_params = ['vlan', 'protocol', 'srcPort', 'srcPortRange', 'dstPort', 'dstPortRange', 'dscp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchQosRulesOrder(self, networkId: str, ruleIds: list):
-		"""
-		**Update the order in which the rules should be processed by the switch**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rules-order
-		
-		- networkId (string): (required)
-		- ruleIds (array): A list of quality of service rule IDs arranged in order in which they should be processed by the switch.
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'configure', 'qosRules', 'order'],
-			'operation': 'updateNetworkSwitchQosRulesOrder'
-		}
-		resource = f'/networks/{networkId}/switch/qosRules/order'
-
-		body_params = ['ruleIds', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchQosRule(self, networkId: str, qosRuleId: str):
-		"""
-		**Delete a quality of service rule**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-qos-rule
-		
-		- networkId (string): (required)
-		- qosRuleId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'qosRules'],
-			'operation': 'deleteNetworkSwitchQosRule'
-		}
-		resource = f'/networks/{networkId}/switch/qosRules/{qosRuleId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchQosRule(self, networkId: str, qosRuleId: str, **kwargs):
-		"""
-		**Update a quality of service rule**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rule
-		
-		- networkId (string): (required)
-		- qosRuleId (string): (required)
-		- vlan (integer): The VLAN of the incoming packet. A null value will match any VLAN.
-		- protocol (string): The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY".
-		- srcPort (integer): The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
-		- srcPortRange (string): The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
-		- dstPort (integer): The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
-		- dstPortRange (string): The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
-		- dscp (integer): DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0.
-		"""
-
-		kwargs.update(locals())
-
-		if 'protocol' in kwargs:
-			options = ['ANY', 'TCP', 'UDP']
-			assert kwargs['protocol'] in options, f'''"protocol" cannot be "{kwargs['protocol']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'qosRules'],
-			'operation': 'updateNetworkSwitchQosRule'
-		}
-		resource = f'/networks/{networkId}/switch/qosRules/{qosRuleId}'
-
-		body_params = ['vlan', 'protocol', 'srcPort', 'srcPortRange', 'dstPort', 'dstPortRange', 'dscp', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchRoutingMulticast(self, networkId: str, **kwargs):
-		"""
-		**Update multicast settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast
-		
-		- networkId (string): (required)
-		- defaultSettings (object): Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default.
-		- overrides (array): Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'multicast'],
-			'operation': 'updateNetworkSwitchRoutingMulticast'
-		}
-		resource = f'/networks/{networkId}/switch/routing/multicast'
-
-		body_params = ['defaultSettings', 'overrides', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, interfaceIp: str, multicastGroup: str):
-		"""
-		**Create a multicast rendezvous point**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-routing-multicast-rendezvous-point
-		
-		- networkId (string): (required)
-		- interfaceIp (string): The IP address of the interface where the RP needs to be created.
-		- multicastGroup (string): 'Any', or the IP address of a multicast group
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
-			'operation': 'createNetworkSwitchRoutingMulticastRendezvousPoint'
-		}
-		resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints'
-
-		body_params = ['interfaceIp', 'multicastGroup', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, rendezvousPointId: str):
-		"""
-		**Delete a multicast rendezvous point**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-routing-multicast-rendezvous-point
-		
-		- networkId (string): (required)
-		- rendezvousPointId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
-			'operation': 'deleteNetworkSwitchRoutingMulticastRendezvousPoint'
-		}
-		resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, rendezvousPointId: str, interfaceIp: str, multicastGroup: str):
-		"""
-		**Update a multicast rendezvous point**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast-rendezvous-point
-		
-		- networkId (string): (required)
-		- rendezvousPointId (string): (required)
-		- interfaceIp (string): The IP address of the interface to use
-		- multicastGroup (string): 'Any', or the IP address of a multicast group
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
-			'operation': 'updateNetworkSwitchRoutingMulticastRendezvousPoint'
-		}
-		resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}'
-
-		body_params = ['interfaceIp', 'multicastGroup', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchRoutingOspf(self, networkId: str, **kwargs):
-		"""
-		**Update layer 3 OSPF routing configuration**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-ospf
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default.
-		- helloTimerInSeconds (integer): Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds
-		- deadTimerInSeconds (integer): Time interval to determine when the peer will be declare inactive/dead. Value must be between 1 and 65535
-		- areas (array): OSPF areas
-		- md5AuthenticationEnabled (boolean): Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default.
-		- md5AuthenticationKey (object): MD5 authentication credentials. This param is only relevant if md5AuthenticationEnabled is true
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'routing', 'ospf'],
-			'operation': 'updateNetworkSwitchRoutingOspf'
-		}
-		resource = f'/networks/{networkId}/switch/routing/ospf'
-
-		body_params = ['enabled', 'helloTimerInSeconds', 'deadTimerInSeconds', 'areas', 'md5AuthenticationEnabled', 'md5AuthenticationKey', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, name: str, subnet: str, interfaceIp: str, vlanId: int, **kwargs):
-		"""
-		**Create a layer 3 interface for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-interface
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- name (string): A friendly name or description for the interface or VLAN.
-		- subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
-		- interfaceIp (string): The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
-		- vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
-		- multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
-		- defaultGateway (string): The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
-		- ospfSettings (object): The OSPF routing settings of the interface.
-		"""
-
-		kwargs.update(locals())
-
-		if 'multicastRouting' in kwargs:
-			options = ['disabled', 'enabled', 'IGMP snooping querier']
-			assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
-			'operation': 'createNetworkSwitchStackRoutingInterface'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces'
-
-		body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'defaultGateway', 'ospfSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, interfaceId: str, **kwargs):
-		"""
-		**Update a layer 3 interface for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- interfaceId (string): (required)
-		- name (string): A friendly name or description for the interface or VLAN.
-		- subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
-		- interfaceIp (string): The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
-		- multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'.
-		- vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
-		- ospfSettings (object): The OSPF routing settings of the interface.
-		"""
-
-		kwargs.update(locals())
-
-		if 'multicastRouting' in kwargs:
-			options = ['disabled', 'enabled', 'IGMP snooping querier']
-			assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
-			'operation': 'updateNetworkSwitchStackRoutingInterface'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}'
-
-		body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'ospfSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, interfaceId: str):
-		"""
-		**Delete a layer 3 interface from a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-interface
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- interfaceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
-			'operation': 'deleteNetworkSwitchStackRoutingInterface'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchStackRoutingInterfaceDhcp(self, networkId: str, switchStackId: str, interfaceId: str, **kwargs):
-		"""
-		**Update a layer 3 interface DHCP configuration for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface-dhcp
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- interfaceId (string): (required)
-		- dhcpMode (string): The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
-		- dhcpRelayServerIps (array): The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
-		- dhcpLeaseTime (string): The DHCP lease time config for the dhcp server running on switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
-		- dnsNameserversOption (string): The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
-		- dnsCustomNameservers (array): The DHCP name server IPs when DHCP name server option is 'custom'
-		- bootOptionsEnabled (boolean): Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
-		- bootNextServer (string): The PXE boot server IP for the DHCP server running on the switch stack interface
-		- bootFileName (string): The PXE boot server file name for the DHCP server running on the switch stack interface
-		- dhcpOptions (array): Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
-		- reservedIpRanges (array): Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
-		- fixedIpAssignments (array): Array of DHCP fixed IP assignments for the DHCP server running on the switch stack interface
-		"""
-
-		kwargs.update(locals())
-
-		if 'dhcpMode' in kwargs:
-			options = ['dhcpDisabled', 'dhcpRelay', 'dhcpServer']
-			assert kwargs['dhcpMode'] in options, f'''"dhcpMode" cannot be "{kwargs['dhcpMode']}", & must be set to one of: {options}'''
-		if 'dhcpLeaseTime' in kwargs:
-			options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
-			assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
-		if 'dnsNameserversOption' in kwargs:
-			options = ['googlePublicDns', 'openDns', 'custom']
-			assert kwargs['dnsNameserversOption'] in options, f'''"dnsNameserversOption" cannot be "{kwargs['dnsNameserversOption']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces', 'dhcp'],
-			'operation': 'updateNetworkSwitchStackRoutingInterfaceDhcp'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp'
-
-		body_params = ['dhcpMode', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dnsNameserversOption', 'dnsCustomNameservers', 'bootOptionsEnabled', 'bootNextServer', 'bootFileName', 'dhcpOptions', 'reservedIpRanges', 'fixedIpAssignments', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, subnet: str, nextHopIp: str, **kwargs):
-		"""
-		**Create a layer 3 static route for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-static-route
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
-		- nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
-		- name (string): Name or description for layer 3 static route
-		- advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
-		- preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
-			'operation': 'createNetworkSwitchStackRoutingStaticRoute'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes'
-
-		body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, staticRouteId: str, **kwargs):
-		"""
-		**Update a layer 3 static route for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-static-route
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- staticRouteId (string): (required)
-		- name (string): Name or description for layer 3 static route
-		- subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
-		- nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
-		- advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
-		- preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
-			'operation': 'updateNetworkSwitchStackRoutingStaticRoute'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}'
-
-		body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, staticRouteId: str):
-		"""
-		**Delete a layer 3 static route for a switch stack**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-static-route
-		
-		- networkId (string): (required)
-		- switchStackId (string): (required)
-		- staticRouteId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
-			'operation': 'deleteNetworkSwitchStackRoutingStaticRoute'
-		}
-		resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchStormControl(self, networkId: str, **kwargs):
-		"""
-		**Update the storm control configuration for a switch network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-storm-control
-		
-		- networkId (string): (required)
-		- broadcastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration.
-		- multicastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration.
-		- unknownUnicastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stormControl'],
-			'operation': 'updateNetworkSwitchStormControl'
-		}
-		resource = f'/networks/{networkId}/switch/stormControl'
-
-		body_params = ['broadcastThreshold', 'multicastThreshold', 'unknownUnicastThreshold', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkSwitchStp(self, networkId: str, **kwargs):
-		"""
-		**Updates STP settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stp
-		
-		- networkId (string): (required)
-		- rstpEnabled (boolean): The spanning tree protocol status in network
-		- stpBridgePriority (array): STP bridge priority for switches/stacks or switch profiles. An empty array will clear the STP bridge priority settings.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['switch', 'configure', 'stp'],
-			'operation': 'updateNetworkSwitchStp'
-		}
-		resource = f'/networks/{networkId}/switch/stp'
-
-		body_params = ['rstpEnabled', 'stpBridgePriority', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateOrganizationConfigTemplateSwitchProfilePort(self, organizationId: str, configTemplateId: str, profileId: str, portId: str, **kwargs):
-		"""
-		**Update a switch profile port**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-config-template-switch-profile-port
-		
-		- organizationId (string): (required)
-		- configTemplateId (string): (required)
-		- profileId (string): (required)
-		- portId (string): (required)
-		- name (string): The name of the switch profile port
-		- tags (array): The list of tags of the switch profile port
-		- enabled (boolean): The status of the switch profile port
-		- type (string): The type of the switch profile port ('trunk' or 'access')
-		- vlan (integer): The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
-		- voiceVlan (integer): The voice VLAN of the switch profile port. Only applicable to access ports
-		- allowedVlans (string): The VLANs allowed on the switch profile port. Only applicable to trunk ports
-		- poeEnabled (boolean): The PoE status of the switch profile port
-		- isolationEnabled (boolean): The isolation status of the switch profile port
-		- rstpEnabled (boolean): The rapid spanning tree protocol status
-		- stpGuard (string): The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')
-		- linkNegotiation (string): The link speed for the switch profile port
-		- portScheduleId (string): The ID of the port schedule. A value of null will clear the port schedule.
-		- udld (string): The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
-		- accessPolicyType (string): The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'
-		- accessPolicyNumber (integer): The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'
-		- macAllowList (array): Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'
-		- stickyMacAllowList (array): The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
-		- stickyMacAllowListLimit (integer): The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
-		- stormControlEnabled (boolean): The storm control status of the switch profile port
-		- flexibleStackingEnabled (boolean): For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
-		"""
-
-		kwargs.update(locals())
-
-		if 'type' in kwargs:
-			options = ['trunk', 'access']
-			assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
-		if 'stpGuard' in kwargs:
-			options = ['disabled', 'root guard', 'bpdu guard', 'loop guard']
-			assert kwargs['stpGuard'] in options, f'''"stpGuard" cannot be "{kwargs['stpGuard']}", & must be set to one of: {options}'''
-		if 'udld' in kwargs:
-			options = ['Alert only', 'Enforce']
-			assert kwargs['udld'] in options, f'''"udld" cannot be "{kwargs['udld']}", & must be set to one of: {options}'''
-		if 'accessPolicyType' in kwargs:
-			options = ['Open', 'Custom access policy', 'MAC allow list', 'Sticky MAC allow list']
-			assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['switch', 'configure', 'configTemplates', 'profiles', 'ports'],
-			'operation': 'updateOrganizationConfigTemplateSwitchProfilePort'
-		}
-		resource = f'/organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}'
-
-		body_params = ['name', 'tags', 'enabled', 'type', 'vlan', 'voiceVlan', 'allowedVlans', 'poeEnabled', 'isolationEnabled', 'rstpEnabled', 'stpGuard', 'linkNegotiation', 'portScheduleId', 'udld', 'accessPolicyType', 'accessPolicyNumber', 'macAllowList', 'stickyMacAllowList', 'stickyMacAllowListLimit', 'stormControlEnabled', 'flexibleStackingEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def cloneOrganizationSwitchDevices(self, organizationId: str, sourceSerial: str, targetSerials: list):
-		"""
-		**Clone port-level and some switch-level configuration settings from a source switch to one or more target switches**
-		https://developer.cisco.com/meraki/api-v1/#!clone-organization-switch-devices
-		
-		- organizationId (string): (required)
-		- sourceSerial (string): Serial number of the source switch (must be on a network not bound to a template)
-		- targetSerials (array): Array of serial numbers of one or more target switches (must be on a network not bound to a template)
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['switch', 'configure', 'devices'],
-			'operation': 'cloneOrganizationSwitchDevices'
-		}
-		resource = f'/organizations/{organizationId}/switch/devices/clone'
-
-		body_params = ['sourceSerial', 'targetSerials', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchSwitch(object):
+    def __init__(self):
+        super(ActionBatchSwitch, self).__init__()
+        
+
+
+    def cycleDeviceSwitchPorts(self, serial: str, ports: list):
+        """
+        **Cycle a set of switch ports**
+        https://developer.cisco.com/meraki/api-v1/#!cycle-device-switch-ports
+
+        - serial (string): (required)
+        - ports (array): List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'liveTools', 'ports'],
+            'operation': 'cycleDeviceSwitchPorts'
+        }
+        resource = f'/devices/{serial}/switch/ports/cycle'
+
+        body_params = ['ports', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceSwitchPort(self, serial: str, portId: str, **kwargs):
+        """
+        **Update a switch port**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-switch-port
+
+        - serial (string): (required)
+        - portId (string): (required)
+        - name (string): The name of the switch port
+        - tags (array): The list of tags of the switch port
+        - enabled (boolean): The status of the switch port
+        - type (string): The type of the switch port ('trunk' or 'access')
+        - vlan (integer): The VLAN of the switch port. A null value will clear the value set for trunk ports.
+        - voiceVlan (integer): The voice VLAN of the switch port. Only applicable to access ports.
+        - allowedVlans (string): The VLANs allowed on the switch port. Only applicable to trunk ports.
+        - poeEnabled (boolean): The PoE status of the switch port
+        - isolationEnabled (boolean): The isolation status of the switch port
+        - rstpEnabled (boolean): The rapid spanning tree protocol status
+        - stpGuard (string): The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')
+        - linkNegotiation (string): The link speed for the switch port
+        - portScheduleId (string): The ID of the port schedule. A value of null will clear the port schedule.
+        - udld (string): The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
+        - accessPolicyType (string): The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'
+        - accessPolicyNumber (integer): The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'
+        - macAllowList (array): Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'
+        - stickyMacAllowList (array): The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
+        - stickyMacAllowListLimit (integer): The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
+        - stormControlEnabled (boolean): The storm control status of the switch port
+        - flexibleStackingEnabled (boolean): For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
+        """
+
+        kwargs.update(locals())
+
+        if 'type' in kwargs:
+            options = ['trunk', 'access']
+            assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
+        if 'stpGuard' in kwargs:
+            options = ['disabled', 'root guard', 'bpdu guard', 'loop guard']
+            assert kwargs['stpGuard'] in options, f'''"stpGuard" cannot be "{kwargs['stpGuard']}", & must be set to one of: {options}'''
+        if 'udld' in kwargs:
+            options = ['Alert only', 'Enforce']
+            assert kwargs['udld'] in options, f'''"udld" cannot be "{kwargs['udld']}", & must be set to one of: {options}'''
+        if 'accessPolicyType' in kwargs:
+            options = ['Open', 'Custom access policy', 'MAC allow list', 'Sticky MAC allow list']
+            assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'ports'],
+            'operation': 'updateDeviceSwitchPort'
+        }
+        resource = f'/devices/{serial}/switch/ports/{portId}'
+
+        body_params = ['name', 'tags', 'enabled', 'type', 'vlan', 'voiceVlan', 'allowedVlans', 'poeEnabled', 'isolationEnabled', 'rstpEnabled', 'stpGuard', 'linkNegotiation', 'portScheduleId', 'udld', 'accessPolicyType', 'accessPolicyNumber', 'macAllowList', 'stickyMacAllowList', 'stickyMacAllowListLimit', 'stormControlEnabled', 'flexibleStackingEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createDeviceSwitchRoutingInterface(self, serial: str, name: str, interfaceIp: str, vlanId: int, **kwargs):
+        """
+        **Create a layer 3 interface for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-interface
+
+        - serial (string): (required)
+        - name (string): A friendly name or description for the interface or VLAN.
+        - interfaceIp (string): The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
+        - vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
+        - subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
+        - multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
+        - defaultGateway (string): The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
+        - ospfSettings (object): The OSPF routing settings of the interface.
+        """
+
+        kwargs.update(locals())
+
+        if 'multicastRouting' in kwargs:
+            options = ['disabled', 'enabled', 'IGMP snooping querier']
+            assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'interfaces'],
+            'operation': 'createDeviceSwitchRoutingInterface'
+        }
+        resource = f'/devices/{serial}/switch/routing/interfaces'
+
+        body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'defaultGateway', 'ospfSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceSwitchRoutingInterface(self, serial: str, interfaceId: str, **kwargs):
+        """
+        **Update a layer 3 interface for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface
+
+        - serial (string): (required)
+        - interfaceId (string): (required)
+        - name (string): A friendly name or description for the interface or VLAN.
+        - subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
+        - interfaceIp (string): The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
+        - multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'.
+        - vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
+        - ospfSettings (object): The OSPF routing settings of the interface.
+        """
+
+        kwargs.update(locals())
+
+        if 'multicastRouting' in kwargs:
+            options = ['disabled', 'enabled', 'IGMP snooping querier']
+            assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'interfaces'],
+            'operation': 'updateDeviceSwitchRoutingInterface'
+        }
+        resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}'
+
+        body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'ospfSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteDeviceSwitchRoutingInterface(self, serial: str, interfaceId: str):
+        """
+        **Delete a layer 3 interface from the switch**
+        https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-interface
+
+        - serial (string): (required)
+        - interfaceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'interfaces'],
+            'operation': 'deleteDeviceSwitchRoutingInterface'
+        }
+        resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceSwitchRoutingInterfaceDhcp(self, serial: str, interfaceId: str, **kwargs):
+        """
+        **Update a layer 3 interface DHCP configuration for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface-dhcp
+
+        - serial (string): (required)
+        - interfaceId (string): (required)
+        - dhcpMode (string): The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
+        - dhcpRelayServerIps (array): The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface
+        - dhcpLeaseTime (string): The DHCP lease time config for the dhcp server running on switch interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
+        - dnsNameserversOption (string): The DHCP name server option for the dhcp server running on the switch interface ('googlePublicDns', 'openDns' or 'custom')
+        - dnsCustomNameservers (array): The DHCP name server IPs when DHCP name server option is 'custom'
+        - bootOptionsEnabled (boolean): Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch interface
+        - bootNextServer (string): The PXE boot server IP for the DHCP server running on the switch interface
+        - bootFileName (string): The PXE boot server filename for the DHCP server running on the switch interface
+        - dhcpOptions (array): Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface
+        - reservedIpRanges (array): Array of DHCP reserved IP assignments for the DHCP server running on the switch interface
+        - fixedIpAssignments (array): Array of DHCP fixed IP assignments for the DHCP server running on the switch interface
+        """
+
+        kwargs.update(locals())
+
+        if 'dhcpMode' in kwargs:
+            options = ['dhcpDisabled', 'dhcpRelay', 'dhcpServer']
+            assert kwargs['dhcpMode'] in options, f'''"dhcpMode" cannot be "{kwargs['dhcpMode']}", & must be set to one of: {options}'''
+        if 'dhcpLeaseTime' in kwargs:
+            options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
+            assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
+        if 'dnsNameserversOption' in kwargs:
+            options = ['googlePublicDns', 'openDns', 'custom']
+            assert kwargs['dnsNameserversOption'] in options, f'''"dnsNameserversOption" cannot be "{kwargs['dnsNameserversOption']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'interfaces', 'dhcp'],
+            'operation': 'updateDeviceSwitchRoutingInterfaceDhcp'
+        }
+        resource = f'/devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp'
+
+        body_params = ['dhcpMode', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dnsNameserversOption', 'dnsCustomNameservers', 'bootOptionsEnabled', 'bootNextServer', 'bootFileName', 'dhcpOptions', 'reservedIpRanges', 'fixedIpAssignments', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createDeviceSwitchRoutingStaticRoute(self, serial: str, subnet: str, nextHopIp: str, **kwargs):
+        """
+        **Create a layer 3 static route for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-static-route
+
+        - serial (string): (required)
+        - subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
+        - nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
+        - name (string): Name or description for layer 3 static route
+        - advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
+        - preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
+            'operation': 'createDeviceSwitchRoutingStaticRoute'
+        }
+        resource = f'/devices/{serial}/switch/routing/staticRoutes'
+
+        body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceSwitchRoutingStaticRoute(self, serial: str, staticRouteId: str, **kwargs):
+        """
+        **Update a layer 3 static route for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-static-route
+
+        - serial (string): (required)
+        - staticRouteId (string): (required)
+        - name (string): Name or description for layer 3 static route
+        - subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
+        - nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
+        - advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
+        - preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
+            'operation': 'updateDeviceSwitchRoutingStaticRoute'
+        }
+        resource = f'/devices/{serial}/switch/routing/staticRoutes/{staticRouteId}'
+
+        body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteDeviceSwitchRoutingStaticRoute(self, serial: str, staticRouteId: str):
+        """
+        **Delete a layer 3 static route for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-static-route
+
+        - serial (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'staticRoutes'],
+            'operation': 'deleteDeviceSwitchRoutingStaticRoute'
+        }
+        resource = f'/devices/{serial}/switch/routing/staticRoutes/{staticRouteId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceSwitchWarmSpare(self, serial: str, enabled: bool, **kwargs):
+        """
+        **Update warm spare configuration for a switch**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-switch-warm-spare
+
+        - serial (string): (required)
+        - enabled (boolean): Enable or disable warm spare for a switch
+        - spareSerial (string): Serial number of the warm spare switch
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'warmSpare'],
+            'operation': 'updateDeviceSwitchWarmSpare'
+        }
+        resource = f'/devices/{serial}/switch/warmSpare'
+
+        body_params = ['enabled', 'spareSerial', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchAccessPolicy(self, networkId: str, name: str, radiusServers: list, radiusTestingEnabled: bool, radiusCoaSupportEnabled: bool, radiusAccountingEnabled: bool, hostMode: str, urlRedirectWalledGardenEnabled: bool, **kwargs):
+        """
+        **Create an access policy for a switch network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-access-policy
+
+        - networkId (string): (required)
+        - name (string): Name of the access policy
+        - radiusServers (array): List of RADIUS servers to require connecting devices to authenticate against before granting network access
+        - radiusTestingEnabled (boolean): If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
+        - radiusCoaSupportEnabled (boolean): Change of authentication for RADIUS re-authentication and disconnection
+        - radiusAccountingEnabled (boolean): Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
+        - hostMode (string): Choose the Host Mode for the access policy.
+        - urlRedirectWalledGardenEnabled (boolean): Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
+        - radiusAccountingServers (array): List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
+        - radiusGroupAttribute (string): Acceptable values are `""` for None, or `"11"` for Group Policies ACL
+        - accessPolicyType (string): Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
+        - increaseAccessSpeed (boolean): Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
+        - guestVlanId (integer): ID for the guest VLAN allow unauthorized devices access to limited network resources
+        - voiceVlanClients (boolean): CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
+        - urlRedirectWalledGardenRanges (array): IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
+        """
+
+        kwargs.update(locals())
+
+        if 'hostMode' in kwargs:
+            options = ['Single-Host', 'Multi-Domain', 'Multi-Host', 'Multi-Auth']
+            assert kwargs['hostMode'] in options, f'''"hostMode" cannot be "{kwargs['hostMode']}", & must be set to one of: {options}'''
+        if 'accessPolicyType' in kwargs:
+            options = ['802.1x', 'MAC authentication bypass', 'Hybrid authentication']
+            assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'accessPolicies'],
+            'operation': 'createNetworkSwitchAccessPolicy'
+        }
+        resource = f'/networks/{networkId}/switch/accessPolicies'
+
+        body_params = ['name', 'radiusServers', 'radiusTestingEnabled', 'radiusCoaSupportEnabled', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusGroupAttribute', 'hostMode', 'accessPolicyType', 'increaseAccessSpeed', 'guestVlanId', 'voiceVlanClients', 'urlRedirectWalledGardenEnabled', 'urlRedirectWalledGardenRanges', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchAccessPolicy(self, networkId: str, accessPolicyNumber: str, **kwargs):
+        """
+        **Update an access policy for a switch network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-access-policy
+
+        - networkId (string): (required)
+        - accessPolicyNumber (string): (required)
+        - name (string): Name of the access policy
+        - radiusServers (array): List of RADIUS servers to require connecting devices to authenticate against before granting network access
+        - radiusTestingEnabled (boolean): If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
+        - radiusCoaSupportEnabled (boolean): Change of authentication for RADIUS re-authentication and disconnection
+        - radiusAccountingEnabled (boolean): Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
+        - radiusAccountingServers (array): List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
+        - radiusGroupAttribute (string): Can be either `""`, which means `None` on Dashboard, or `"11"`, which means `Filter-Id` on Dashboard and will use Group Policy ACLs when supported (firmware 14+)
+        - hostMode (string): Choose the Host Mode for the access policy.
+        - accessPolicyType (string): Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
+        - increaseAccessSpeed (boolean): Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
+        - guestVlanId (integer): ID for the guest VLAN allow unauthorized devices access to limited network resources
+        - voiceVlanClients (boolean): CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
+        - urlRedirectWalledGardenEnabled (boolean): Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
+        - urlRedirectWalledGardenRanges (array): IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
+        """
+
+        kwargs.update(locals())
+
+        if 'hostMode' in kwargs:
+            options = ['Single-Host', 'Multi-Domain', 'Multi-Host', 'Multi-Auth']
+            assert kwargs['hostMode'] in options, f'''"hostMode" cannot be "{kwargs['hostMode']}", & must be set to one of: {options}'''
+        if 'accessPolicyType' in kwargs:
+            options = ['802.1x', 'MAC authentication bypass', 'Hybrid authentication']
+            assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'accessPolicies'],
+            'operation': 'updateNetworkSwitchAccessPolicy'
+        }
+        resource = f'/networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}'
+
+        body_params = ['name', 'radiusServers', 'radiusTestingEnabled', 'radiusCoaSupportEnabled', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusGroupAttribute', 'hostMode', 'accessPolicyType', 'increaseAccessSpeed', 'guestVlanId', 'voiceVlanClients', 'urlRedirectWalledGardenEnabled', 'urlRedirectWalledGardenRanges', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchAccessPolicy(self, networkId: str, accessPolicyNumber: str):
+        """
+        **Delete an access policy for a switch network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-access-policy
+
+        - networkId (string): (required)
+        - accessPolicyNumber (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'accessPolicies'],
+            'operation': 'deleteNetworkSwitchAccessPolicy'
+        }
+        resource = f'/networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchAlternateManagementInterface(self, networkId: str, **kwargs):
+        """
+        **Update the switch alternate management interface for the network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-alternate-management-interface
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
+        - vlanId (integer): Alternate management VLAN, must be between 1 and 4094
+        - protocols (array): Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
+        - switches (array): Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'alternateManagementInterface'],
+            'operation': 'updateNetworkSwitchAlternateManagementInterface'
+        }
+        resource = f'/networks/{networkId}/switch/alternateManagementInterface'
+
+        body_params = ['enabled', 'vlanId', 'protocols', 'switches', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchDhcpServerPolicy(self, networkId: str, **kwargs):
+        """
+        **Update the DHCP server policy**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dhcp-server-policy
+
+        - networkId (string): (required)
+        - defaultPolicy (string): 'allow' or 'block' new DHCP servers. Default value is 'allow'.
+        - allowedServers (array): List the MAC addresses of DHCP servers to permit on the network. Applicable only if defaultPolicy is set to block. An empty array will clear the entries.
+        - blockedServers (array): List the MAC addresses of DHCP servers to block on the network. Applicable only if defaultPolicy is set to allow. An empty array will clear the entries.
+        """
+
+        kwargs.update(locals())
+
+        if 'defaultPolicy' in kwargs:
+            options = ['allow', 'block']
+            assert kwargs['defaultPolicy'] in options, f'''"defaultPolicy" cannot be "{kwargs['defaultPolicy']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'dhcpServerPolicy'],
+            'operation': 'updateNetworkSwitchDhcpServerPolicy'
+        }
+        resource = f'/networks/{networkId}/switch/dhcpServerPolicy'
+
+        body_params = ['defaultPolicy', 'allowedServers', 'blockedServers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchDscpToCosMappings(self, networkId: str, mappings: list):
+        """
+        **Update the DSCP to CoS mappings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dscp-to-cos-mappings
+
+        - networkId (string): (required)
+        - mappings (array): An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'configure', 'dscpToCosMappings'],
+            'operation': 'updateNetworkSwitchDscpToCosMappings'
+        }
+        resource = f'/networks/{networkId}/switch/dscpToCosMappings'
+
+        body_params = ['mappings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchLinkAggregation(self, networkId: str, **kwargs):
+        """
+        **Create a link aggregation group**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-link-aggregation
+
+        - networkId (string): (required)
+        - switchPorts (array): Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
+        - switchProfilePorts (array): Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'linkAggregations'],
+            'operation': 'createNetworkSwitchLinkAggregation'
+        }
+        resource = f'/networks/{networkId}/switch/linkAggregations'
+
+        body_params = ['switchPorts', 'switchProfilePorts', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchLinkAggregation(self, networkId: str, linkAggregationId: str, **kwargs):
+        """
+        **Update a link aggregation group**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-link-aggregation
+
+        - networkId (string): (required)
+        - linkAggregationId (string): (required)
+        - switchPorts (array): Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
+        - switchProfilePorts (array): Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'linkAggregations'],
+            'operation': 'updateNetworkSwitchLinkAggregation'
+        }
+        resource = f'/networks/{networkId}/switch/linkAggregations/{linkAggregationId}'
+
+        body_params = ['switchPorts', 'switchProfilePorts', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchLinkAggregation(self, networkId: str, linkAggregationId: str):
+        """
+        **Split a link aggregation group into separate ports**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-link-aggregation
+
+        - networkId (string): (required)
+        - linkAggregationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'linkAggregations'],
+            'operation': 'deleteNetworkSwitchLinkAggregation'
+        }
+        resource = f'/networks/{networkId}/switch/linkAggregations/{linkAggregationId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchMtu(self, networkId: str, **kwargs):
+        """
+        **Update the MTU configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-mtu
+
+        - networkId (string): (required)
+        - defaultMtuSize (integer): MTU size for the entire network. Default value is 9578.
+        - overrides (array): Override MTU size for individual switches or switch profiles. An empty array will clear overrides.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'mtu'],
+            'operation': 'updateNetworkSwitchMtu'
+        }
+        resource = f'/networks/{networkId}/switch/mtu'
+
+        body_params = ['defaultMtuSize', 'overrides', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchPortSchedule(self, networkId: str, portScheduleId: str, **kwargs):
+        """
+        **Update a switch port schedule**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-port-schedule
+
+        - networkId (string): (required)
+        - portScheduleId (string): (required)
+        - name (string): The name for your port schedule.
+        - portSchedule (object):     The schedule for switch port scheduling. Schedules are applied to days of the week.
+    When it's empty, default schedule with all days of a week are configured.
+    Any unspecified day in the schedule is added as a default schedule configuration of the day.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'portSchedules'],
+            'operation': 'updateNetworkSwitchPortSchedule'
+        }
+        resource = f'/networks/{networkId}/switch/portSchedules/{portScheduleId}'
+
+        body_params = ['name', 'portSchedule', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchQosRule(self, networkId: str, vlan: int, **kwargs):
+        """
+        **Add a quality of service rule**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-qos-rule
+
+        - networkId (string): (required)
+        - vlan (integer): The VLAN of the incoming packet. A null value will match any VLAN.
+        - protocol (string): The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY"
+        - srcPort (integer): The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
+        - srcPortRange (string): The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
+        - dstPort (integer): The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
+        - dstPortRange (string): The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
+        - dscp (integer): DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0
+        """
+
+        kwargs.update(locals())
+
+        if 'protocol' in kwargs:
+            options = ['ANY', 'TCP', 'UDP']
+            assert kwargs['protocol'] in options, f'''"protocol" cannot be "{kwargs['protocol']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'qosRules'],
+            'operation': 'createNetworkSwitchQosRule'
+        }
+        resource = f'/networks/{networkId}/switch/qosRules'
+
+        body_params = ['vlan', 'protocol', 'srcPort', 'srcPortRange', 'dstPort', 'dstPortRange', 'dscp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchQosRulesOrder(self, networkId: str, ruleIds: list):
+        """
+        **Update the order in which the rules should be processed by the switch**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rules-order
+
+        - networkId (string): (required)
+        - ruleIds (array): A list of quality of service rule IDs arranged in order in which they should be processed by the switch.
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'configure', 'qosRules', 'order'],
+            'operation': 'updateNetworkSwitchQosRulesOrder'
+        }
+        resource = f'/networks/{networkId}/switch/qosRules/order'
+
+        body_params = ['ruleIds', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchQosRule(self, networkId: str, qosRuleId: str):
+        """
+        **Delete a quality of service rule**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-qos-rule
+
+        - networkId (string): (required)
+        - qosRuleId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'qosRules'],
+            'operation': 'deleteNetworkSwitchQosRule'
+        }
+        resource = f'/networks/{networkId}/switch/qosRules/{qosRuleId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchQosRule(self, networkId: str, qosRuleId: str, **kwargs):
+        """
+        **Update a quality of service rule**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rule
+
+        - networkId (string): (required)
+        - qosRuleId (string): (required)
+        - vlan (integer): The VLAN of the incoming packet. A null value will match any VLAN.
+        - protocol (string): The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY".
+        - srcPort (integer): The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
+        - srcPortRange (string): The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
+        - dstPort (integer): The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
+        - dstPortRange (string): The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
+        - dscp (integer): DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0.
+        """
+
+        kwargs.update(locals())
+
+        if 'protocol' in kwargs:
+            options = ['ANY', 'TCP', 'UDP']
+            assert kwargs['protocol'] in options, f'''"protocol" cannot be "{kwargs['protocol']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'qosRules'],
+            'operation': 'updateNetworkSwitchQosRule'
+        }
+        resource = f'/networks/{networkId}/switch/qosRules/{qosRuleId}'
+
+        body_params = ['vlan', 'protocol', 'srcPort', 'srcPortRange', 'dstPort', 'dstPortRange', 'dscp', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchRoutingMulticast(self, networkId: str, **kwargs):
+        """
+        **Update multicast settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast
+
+        - networkId (string): (required)
+        - defaultSettings (object): Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default.
+        - overrides (array): Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'multicast'],
+            'operation': 'updateNetworkSwitchRoutingMulticast'
+        }
+        resource = f'/networks/{networkId}/switch/routing/multicast'
+
+        body_params = ['defaultSettings', 'overrides', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, interfaceIp: str, multicastGroup: str):
+        """
+        **Create a multicast rendezvous point**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-routing-multicast-rendezvous-point
+
+        - networkId (string): (required)
+        - interfaceIp (string): The IP address of the interface where the RP needs to be created.
+        - multicastGroup (string): 'Any', or the IP address of a multicast group
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
+            'operation': 'createNetworkSwitchRoutingMulticastRendezvousPoint'
+        }
+        resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints'
+
+        body_params = ['interfaceIp', 'multicastGroup', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, rendezvousPointId: str):
+        """
+        **Delete a multicast rendezvous point**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-routing-multicast-rendezvous-point
+
+        - networkId (string): (required)
+        - rendezvousPointId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
+            'operation': 'deleteNetworkSwitchRoutingMulticastRendezvousPoint'
+        }
+        resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchRoutingMulticastRendezvousPoint(self, networkId: str, rendezvousPointId: str, interfaceIp: str, multicastGroup: str):
+        """
+        **Update a multicast rendezvous point**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast-rendezvous-point
+
+        - networkId (string): (required)
+        - rendezvousPointId (string): (required)
+        - interfaceIp (string): The IP address of the interface to use
+        - multicastGroup (string): 'Any', or the IP address of a multicast group
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'multicast', 'rendezvousPoints'],
+            'operation': 'updateNetworkSwitchRoutingMulticastRendezvousPoint'
+        }
+        resource = f'/networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}'
+
+        body_params = ['interfaceIp', 'multicastGroup', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchRoutingOspf(self, networkId: str, **kwargs):
+        """
+        **Update layer 3 OSPF routing configuration**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-ospf
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default.
+        - helloTimerInSeconds (integer): Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds
+        - deadTimerInSeconds (integer): Time interval to determine when the peer will be declare inactive/dead. Value must be between 1 and 65535
+        - areas (array): OSPF areas
+        - md5AuthenticationEnabled (boolean): Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default.
+        - md5AuthenticationKey (object): MD5 authentication credentials. This param is only relevant if md5AuthenticationEnabled is true
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'routing', 'ospf'],
+            'operation': 'updateNetworkSwitchRoutingOspf'
+        }
+        resource = f'/networks/{networkId}/switch/routing/ospf'
+
+        body_params = ['enabled', 'helloTimerInSeconds', 'deadTimerInSeconds', 'areas', 'md5AuthenticationEnabled', 'md5AuthenticationKey', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, name: str, subnet: str, interfaceIp: str, vlanId: int, **kwargs):
+        """
+        **Create a layer 3 interface for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-interface
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - name (string): A friendly name or description for the interface or VLAN.
+        - subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
+        - interfaceIp (string): The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
+        - vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
+        - multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
+        - defaultGateway (string): The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
+        - ospfSettings (object): The OSPF routing settings of the interface.
+        """
+
+        kwargs.update(locals())
+
+        if 'multicastRouting' in kwargs:
+            options = ['disabled', 'enabled', 'IGMP snooping querier']
+            assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
+            'operation': 'createNetworkSwitchStackRoutingInterface'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces'
+
+        body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'defaultGateway', 'ospfSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, interfaceId: str, **kwargs):
+        """
+        **Update a layer 3 interface for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - interfaceId (string): (required)
+        - name (string): A friendly name or description for the interface or VLAN.
+        - subnet (string): The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
+        - interfaceIp (string): The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
+        - multicastRouting (string): Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'.
+        - vlanId (integer): The VLAN this routed interface is on. VLAN must be between 1 and 4094.
+        - ospfSettings (object): The OSPF routing settings of the interface.
+        """
+
+        kwargs.update(locals())
+
+        if 'multicastRouting' in kwargs:
+            options = ['disabled', 'enabled', 'IGMP snooping querier']
+            assert kwargs['multicastRouting'] in options, f'''"multicastRouting" cannot be "{kwargs['multicastRouting']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
+            'operation': 'updateNetworkSwitchStackRoutingInterface'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}'
+
+        body_params = ['name', 'subnet', 'interfaceIp', 'multicastRouting', 'vlanId', 'ospfSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchStackRoutingInterface(self, networkId: str, switchStackId: str, interfaceId: str):
+        """
+        **Delete a layer 3 interface from a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-interface
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - interfaceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces'],
+            'operation': 'deleteNetworkSwitchStackRoutingInterface'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchStackRoutingInterfaceDhcp(self, networkId: str, switchStackId: str, interfaceId: str, **kwargs):
+        """
+        **Update a layer 3 interface DHCP configuration for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface-dhcp
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - interfaceId (string): (required)
+        - dhcpMode (string): The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
+        - dhcpRelayServerIps (array): The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
+        - dhcpLeaseTime (string): The DHCP lease time config for the dhcp server running on switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
+        - dnsNameserversOption (string): The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
+        - dnsCustomNameservers (array): The DHCP name server IPs when DHCP name server option is 'custom'
+        - bootOptionsEnabled (boolean): Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
+        - bootNextServer (string): The PXE boot server IP for the DHCP server running on the switch stack interface
+        - bootFileName (string): The PXE boot server file name for the DHCP server running on the switch stack interface
+        - dhcpOptions (array): Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
+        - reservedIpRanges (array): Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
+        - fixedIpAssignments (array): Array of DHCP fixed IP assignments for the DHCP server running on the switch stack interface
+        """
+
+        kwargs.update(locals())
+
+        if 'dhcpMode' in kwargs:
+            options = ['dhcpDisabled', 'dhcpRelay', 'dhcpServer']
+            assert kwargs['dhcpMode'] in options, f'''"dhcpMode" cannot be "{kwargs['dhcpMode']}", & must be set to one of: {options}'''
+        if 'dhcpLeaseTime' in kwargs:
+            options = ['30 minutes', '1 hour', '4 hours', '12 hours', '1 day', '1 week']
+            assert kwargs['dhcpLeaseTime'] in options, f'''"dhcpLeaseTime" cannot be "{kwargs['dhcpLeaseTime']}", & must be set to one of: {options}'''
+        if 'dnsNameserversOption' in kwargs:
+            options = ['googlePublicDns', 'openDns', 'custom']
+            assert kwargs['dnsNameserversOption'] in options, f'''"dnsNameserversOption" cannot be "{kwargs['dnsNameserversOption']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'interfaces', 'dhcp'],
+            'operation': 'updateNetworkSwitchStackRoutingInterfaceDhcp'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp'
+
+        body_params = ['dhcpMode', 'dhcpRelayServerIps', 'dhcpLeaseTime', 'dnsNameserversOption', 'dnsCustomNameservers', 'bootOptionsEnabled', 'bootNextServer', 'bootFileName', 'dhcpOptions', 'reservedIpRanges', 'fixedIpAssignments', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, subnet: str, nextHopIp: str, **kwargs):
+        """
+        **Create a layer 3 static route for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-static-route
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
+        - nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
+        - name (string): Name or description for layer 3 static route
+        - advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
+        - preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
+            'operation': 'createNetworkSwitchStackRoutingStaticRoute'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes'
+
+        body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, staticRouteId: str, **kwargs):
+        """
+        **Update a layer 3 static route for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-static-route
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - staticRouteId (string): (required)
+        - name (string): Name or description for layer 3 static route
+        - subnet (string): The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
+        - nextHopIp (string): IP address of the next hop device to which the device sends its traffic for the subnet
+        - advertiseViaOspfEnabled (boolean): Option to advertise static route via OSPF
+        - preferOverOspfRoutesEnabled (boolean): Option to prefer static route over OSPF routes
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
+            'operation': 'updateNetworkSwitchStackRoutingStaticRoute'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}'
+
+        body_params = ['name', 'subnet', 'nextHopIp', 'advertiseViaOspfEnabled', 'preferOverOspfRoutesEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkSwitchStackRoutingStaticRoute(self, networkId: str, switchStackId: str, staticRouteId: str):
+        """
+        **Delete a layer 3 static route for a switch stack**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-static-route
+
+        - networkId (string): (required)
+        - switchStackId (string): (required)
+        - staticRouteId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stacks', 'routing', 'staticRoutes'],
+            'operation': 'deleteNetworkSwitchStackRoutingStaticRoute'
+        }
+        resource = f'/networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchStormControl(self, networkId: str, **kwargs):
+        """
+        **Update the storm control configuration for a switch network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-storm-control
+
+        - networkId (string): (required)
+        - broadcastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration.
+        - multicastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration.
+        - unknownUnicastThreshold (integer): Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stormControl'],
+            'operation': 'updateNetworkSwitchStormControl'
+        }
+        resource = f'/networks/{networkId}/switch/stormControl'
+
+        body_params = ['broadcastThreshold', 'multicastThreshold', 'unknownUnicastThreshold', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkSwitchStp(self, networkId: str, **kwargs):
+        """
+        **Updates STP settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stp
+
+        - networkId (string): (required)
+        - rstpEnabled (boolean): The spanning tree protocol status in network
+        - stpBridgePriority (array): STP bridge priority for switches/stacks or switch profiles. An empty array will clear the STP bridge priority settings.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['switch', 'configure', 'stp'],
+            'operation': 'updateNetworkSwitchStp'
+        }
+        resource = f'/networks/{networkId}/switch/stp'
+
+        body_params = ['rstpEnabled', 'stpBridgePriority', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateOrganizationConfigTemplateSwitchProfilePort(self, organizationId: str, configTemplateId: str, profileId: str, portId: str, **kwargs):
+        """
+        **Update a switch profile port**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-config-template-switch-profile-port
+
+        - organizationId (string): (required)
+        - configTemplateId (string): (required)
+        - profileId (string): (required)
+        - portId (string): (required)
+        - name (string): The name of the switch profile port
+        - tags (array): The list of tags of the switch profile port
+        - enabled (boolean): The status of the switch profile port
+        - type (string): The type of the switch profile port ('trunk' or 'access')
+        - vlan (integer): The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
+        - voiceVlan (integer): The voice VLAN of the switch profile port. Only applicable to access ports
+        - allowedVlans (string): The VLANs allowed on the switch profile port. Only applicable to trunk ports
+        - poeEnabled (boolean): The PoE status of the switch profile port
+        - isolationEnabled (boolean): The isolation status of the switch profile port
+        - rstpEnabled (boolean): The rapid spanning tree protocol status
+        - stpGuard (string): The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')
+        - linkNegotiation (string): The link speed for the switch profile port
+        - portScheduleId (string): The ID of the port schedule. A value of null will clear the port schedule.
+        - udld (string): The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
+        - accessPolicyType (string): The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'
+        - accessPolicyNumber (integer): The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'
+        - macAllowList (array): Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'
+        - stickyMacAllowList (array): The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
+        - stickyMacAllowListLimit (integer): The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'
+        - stormControlEnabled (boolean): The storm control status of the switch profile port
+        - flexibleStackingEnabled (boolean): For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
+        """
+
+        kwargs.update(locals())
+
+        if 'type' in kwargs:
+            options = ['trunk', 'access']
+            assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
+        if 'stpGuard' in kwargs:
+            options = ['disabled', 'root guard', 'bpdu guard', 'loop guard']
+            assert kwargs['stpGuard'] in options, f'''"stpGuard" cannot be "{kwargs['stpGuard']}", & must be set to one of: {options}'''
+        if 'udld' in kwargs:
+            options = ['Alert only', 'Enforce']
+            assert kwargs['udld'] in options, f'''"udld" cannot be "{kwargs['udld']}", & must be set to one of: {options}'''
+        if 'accessPolicyType' in kwargs:
+            options = ['Open', 'Custom access policy', 'MAC allow list', 'Sticky MAC allow list']
+            assert kwargs['accessPolicyType'] in options, f'''"accessPolicyType" cannot be "{kwargs['accessPolicyType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['switch', 'configure', 'configTemplates', 'profiles', 'ports'],
+            'operation': 'updateOrganizationConfigTemplateSwitchProfilePort'
+        }
+        resource = f'/organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}'
+
+        body_params = ['name', 'tags', 'enabled', 'type', 'vlan', 'voiceVlan', 'allowedVlans', 'poeEnabled', 'isolationEnabled', 'rstpEnabled', 'stpGuard', 'linkNegotiation', 'portScheduleId', 'udld', 'accessPolicyType', 'accessPolicyNumber', 'macAllowList', 'stickyMacAllowList', 'stickyMacAllowListLimit', 'stormControlEnabled', 'flexibleStackingEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def cloneOrganizationSwitchDevices(self, organizationId: str, sourceSerial: str, targetSerials: list):
+        """
+        **Clone port-level and some switch-level configuration settings from a source switch to one or more target switches**
+        https://developer.cisco.com/meraki/api-v1/#!clone-organization-switch-devices
+
+        - organizationId (string): (required)
+        - sourceSerial (string): Serial number of the source switch (must be on a network not bound to a template)
+        - targetSerials (array): Array of serial numbers of one or more target switches (must be on a network not bound to a template)
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['switch', 'configure', 'devices'],
+            'operation': 'cloneOrganizationSwitchDevices'
+        }
+        resource = f'/organizations/{organizationId}/switch/devices/clone'
+
+        body_params = ['sourceSerial', 'targetSerials', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/batch/wireless.py` & `meraki-1.7.2/meraki/api/batch/wireless.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,645 +1,714 @@
-class ActionBatchWireless(object):
-	def __init__(self):
-		super(ActionBatchWireless, self).__init__()
-
-	def updateDeviceWirelessBluetoothSettings(self, serial: str, **kwargs):
-		"""
-		**Update the bluetooth settings for a wireless device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-bluetooth-settings
-		
-		- serial (string): (required)
-		- uuid (string): Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		- major (integer): Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		- minor (integer): Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
-			'operation': 'updateDeviceWirelessBluetoothSettings'
-		}
-		resource = f'/devices/{serial}/wireless/bluetooth/settings'
-
-		body_params = ['uuid', 'major', 'minor', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateDeviceWirelessRadioSettings(self, serial: str, **kwargs):
-		"""
-		**Update the radio settings of a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-radio-settings
-		
-		- serial (string): (required)
-		- rfProfileId (integer): The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power).
-		- twoFourGhzSettings (object): Manual radio settings for 2.4 GHz.
-		- fiveGhzSettings (object): Manual radio settings for 5 GHz.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'radio', 'settings'],
-			'operation': 'updateDeviceWirelessRadioSettings'
-		}
-		resource = f'/devices/{serial}/wireless/radio/settings'
-
-		body_params = ['rfProfileId', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessAlternateManagementInterface(self, networkId: str, **kwargs):
-		"""
-		**Update alternate management interface and device static IP**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-alternate-management-interface
-		
-		- networkId (string): (required)
-		- enabled (boolean): Boolean value to enable or disable alternate management interface
-		- vlanId (integer): Alternate management interface VLAN, must be between 1 and 4094
-		- protocols (array): Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap'
-		- accessPoints (array): Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'alternateManagementInterface'],
-			'operation': 'updateNetworkWirelessAlternateManagementInterface'
-		}
-		resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
-
-		body_params = ['enabled', 'vlanId', 'protocols', 'accessPoints', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessBilling(self, networkId: str, **kwargs):
-		"""
-		**Update the billing settings**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-billing
-		
-		- networkId (string): (required)
-		- currency (string): The currency code of this node group's billing plans
-		- plans (array): Array of billing plans in the node group. (Can configure a maximum of 5)
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'billing'],
-			'operation': 'updateNetworkWirelessBilling'
-		}
-		resource = f'/networks/{networkId}/wireless/billing'
-
-		body_params = ['currency', 'plans', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkWirelessRfProfile(self, networkId: str, name: str, bandSelectionType: str, **kwargs):
-		"""
-		**Creates new RF profile for this network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- name (string): The name of the new profile. Must be unique. This param is required on creation.
-		- bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
-		- clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false. Defaults to true.
-		- minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
-		- apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
-		- twoFourGhzSettings (object): Settings related to 2.4Ghz band
-		- fiveGhzSettings (object): Settings related to 5Ghz band
-		"""
-
-		kwargs.update(locals())
-
-		if 'minBitrateType' in kwargs:
-			options = ['band', 'ssid']
-			assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
-		if 'bandSelectionType' in kwargs:
-			options = ['ssid', 'ap']
-			assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'createNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles'
-
-		body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str, **kwargs):
-		"""
-		**Updates specified RF profile for this network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- rfProfileId (string): (required)
-		- name (string): The name of the new profile. Must be unique.
-		- clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false.
-		- minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'.
-		- bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'.
-		- apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
-		- twoFourGhzSettings (object): Settings related to 2.4Ghz band
-		- fiveGhzSettings (object): Settings related to 5Ghz band
-		"""
-
-		kwargs.update(locals())
-
-		if 'minBitrateType' in kwargs:
-			options = ['band', 'ssid']
-			assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
-		if 'bandSelectionType' in kwargs:
-			options = ['ssid', 'ap']
-			assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'updateNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
-
-		body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
-		"""
-		**Delete a RF Profile**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-rf-profile
-		
-		- networkId (string): (required)
-		- rfProfileId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'rfProfiles'],
-			'operation': 'deleteNetworkWirelessRfProfile'
-		}
-		resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the wireless settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-settings
-		
-		- networkId (string): (required)
-		- meshingEnabled (boolean): Toggle for enabling or disabling meshing in a network
-		- ipv6BridgeEnabled (boolean): Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
-		- locationAnalyticsEnabled (boolean): Toggle for enabling or disabling location analytics for your network
-		- upgradeStrategy (string): The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
-		- ledLightsOn (boolean): Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
-		"""
-
-		kwargs.update(locals())
-
-		if 'upgradeStrategy' in kwargs:
-			options = ['minimizeUpgradeTime', 'minimizeClientDowntime']
-			assert kwargs['upgradeStrategy'] in options, f'''"upgradeStrategy" cannot be "{kwargs['upgradeStrategy']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'settings'],
-			'operation': 'updateNetworkWirelessSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/settings'
-
-		body_params = ['meshingEnabled', 'ipv6BridgeEnabled', 'locationAnalyticsEnabled', 'upgradeStrategy', 'ledLightsOn', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsid(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the attributes of an MR SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- name (string): The name of the SSID
-		- enabled (boolean): Whether or not the SSID is enabled
-		- authMode (string): The association control method for the SSID ('open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
-		- enterpriseAdminAccess (string): Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
-		- encryptionMode (string): The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
-		- psk (string): The passkey for the SSID. This param is only valid if the authMode is 'psk'
-		- wpaEncryptionMode (string): The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
-		- dot11w (object): The current setting for Protected Management Frames (802.11w).
-		- dot11r (object): The current setting for 802.11r
-		- splashPage (string): The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest' or 'Cisco ISE'). This attribute is not supported for template children.
-		- splashGuestSponsorDomains (array): Array of valid sponsor email domains for sponsored guest splash type.
-		- ldap (object): The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
-		- activeDirectory (object): The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
-		- radiusServers (array): The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
-		- radiusProxyEnabled (boolean): If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
-		- radiusTestingEnabled (boolean): If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
-		- radiusCalledStationId (string): The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
-		- radiusAuthenticationNasId (string): The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
-		- radiusServerTimeout (integer): The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
-		- radiusServerAttemptsLimit (integer): The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
-		- radiusFallbackEnabled (boolean): Whether or not higher priority RADIUS servers should be retried after 60 seconds.
-		- radiusCoaEnabled (boolean): If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
-		- radiusFailoverPolicy (string): This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
-		- radiusLoadBalancingPolicy (string): This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
-		- radiusAccountingEnabled (boolean): Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
-		- radiusAccountingServers (array): The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
-		- radiusAccountingInterimInterval (integer): The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
-		- radiusAttributeForGroupPolicies (string): Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
-		- ipAssignmentMode (string): The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
-		- useVlanTagging (boolean): Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- concentratorNetworkId (string): The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
-		- vlanId (integer): The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
-		- defaultVlanId (integer): The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- apTagsAndVlanIds (array): The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
-		- walledGardenEnabled (boolean): Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
-		- walledGardenRanges (array): Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
-		- radiusOverride (boolean): If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
-		- radiusGuestVlanEnabled (boolean): Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
-		- radiusGuestVlanId (integer): VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
-		- minBitrate (number): The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
-		- bandSelection (string): The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
-		- perClientBandwidthLimitUp (integer): The upload bandwidth limit in Kbps. (0 represents no limit.)
-		- perClientBandwidthLimitDown (integer): The download bandwidth limit in Kbps. (0 represents no limit.)
-		- perSsidBandwidthLimitUp (integer): The total upload bandwidth limit in Kbps. (0 represents no limit.)
-		- perSsidBandwidthLimitDown (integer): The total download bandwidth limit in Kbps. (0 represents no limit.)
-		- lanIsolationEnabled (boolean): Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
-		- visible (boolean): Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
-		- availableOnAllAps (boolean): Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
-		- availabilityTags (array): Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
-		- adaptivePolicyGroupId (string): Adaptive policy group ID this SSID is assigned to.
-		- mandatoryDhcpEnabled (boolean): If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
-		- adultContentFilteringEnabled (boolean): Boolean indicating whether or not adult content will be blocked
-		"""
-
-		kwargs.update(locals())
-
-		if 'authMode' in kwargs:
-			options = ['open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius', 'ipsk-without-radius']
-			assert kwargs['authMode'] in options, f'''"authMode" cannot be "{kwargs['authMode']}", & must be set to one of: {options}'''
-		if 'enterpriseAdminAccess' in kwargs:
-			options = ['access disabled', 'access enabled']
-			assert kwargs['enterpriseAdminAccess'] in options, f'''"enterpriseAdminAccess" cannot be "{kwargs['enterpriseAdminAccess']}", & must be set to one of: {options}'''
-		if 'encryptionMode' in kwargs:
-			options = ['wep', 'wpa']
-			assert kwargs['encryptionMode'] in options, f'''"encryptionMode" cannot be "{kwargs['encryptionMode']}", & must be set to one of: {options}'''
-		if 'wpaEncryptionMode' in kwargs:
-			options = ['WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only']
-			assert kwargs['wpaEncryptionMode'] in options, f'''"wpaEncryptionMode" cannot be "{kwargs['wpaEncryptionMode']}", & must be set to one of: {options}'''
-		if 'splashPage' in kwargs:
-			options = ['None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE']
-			assert kwargs['splashPage'] in options, f'''"splashPage" cannot be "{kwargs['splashPage']}", & must be set to one of: {options}'''
-		if 'radiusFailoverPolicy' in kwargs:
-			options = ['Deny access', 'Allow access']
-			assert kwargs['radiusFailoverPolicy'] in options, f'''"radiusFailoverPolicy" cannot be "{kwargs['radiusFailoverPolicy']}", & must be set to one of: {options}'''
-		if 'radiusLoadBalancingPolicy' in kwargs:
-			options = ['Strict priority order', 'Round robin']
-			assert kwargs['radiusLoadBalancingPolicy'] in options, f'''"radiusLoadBalancingPolicy" cannot be "{kwargs['radiusLoadBalancingPolicy']}", & must be set to one of: {options}'''
-		if 'radiusAttributeForGroupPolicies' in kwargs:
-			options = ['Filter-Id', 'Reply-Message', 'Airespace-ACL-Name', 'Aruba-User-Role']
-			assert kwargs['radiusAttributeForGroupPolicies'] in options, f'''"radiusAttributeForGroupPolicies" cannot be "{kwargs['radiusAttributeForGroupPolicies']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids'],
-			'operation': 'updateNetworkWirelessSsid'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}'
-
-		body_params = ['name', 'enabled', 'authMode', 'enterpriseAdminAccess', 'encryptionMode', 'psk', 'wpaEncryptionMode', 'dot11w', 'dot11r', 'splashPage', 'splashGuestSponsorDomains', 'ldap', 'activeDirectory', 'radiusServers', 'radiusProxyEnabled', 'radiusTestingEnabled', 'radiusCalledStationId', 'radiusAuthenticationNasId', 'radiusServerTimeout', 'radiusServerAttemptsLimit', 'radiusFallbackEnabled', 'radiusCoaEnabled', 'radiusFailoverPolicy', 'radiusLoadBalancingPolicy', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusAccountingInterimInterval', 'radiusAttributeForGroupPolicies', 'ipAssignmentMode', 'useVlanTagging', 'concentratorNetworkId', 'vlanId', 'defaultVlanId', 'apTagsAndVlanIds', 'walledGardenEnabled', 'walledGardenRanges', 'radiusOverride', 'radiusGuestVlanEnabled', 'radiusGuestVlanId', 'minBitrate', 'bandSelection', 'perClientBandwidthLimitUp', 'perClientBandwidthLimitDown', 'perSsidBandwidthLimitUp', 'perSsidBandwidthLimitDown', 'lanIsolationEnabled', 'visible', 'availableOnAllAps', 'availabilityTags', 'adaptivePolicyGroupId', 'mandatoryDhcpEnabled', 'adultContentFilteringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the device type group policies for the SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-device-type-group-policies
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- enabled (boolean): If true, the SSID device type group policies are enabled.
-		- deviceTypePolicies (array): List of device type policies.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
-			'operation': 'updateNetworkWirelessSsidDeviceTypeGroupPolicies'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
-
-		body_params = ['enabled', 'deviceTypePolicies', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the L7 firewall rules of an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-7-firewall-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- rules (array): An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
-			'operation': 'updateNetworkWirelessSsidFirewallL7FirewallRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
-
-		body_params = ['rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def createNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, name: str, passphrase: str, groupPolicyId: str):
-		"""
-		**Create an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- name (string): The name of the Identity PSK
-		- passphrase (string): The passphrase for client authentication
-		- groupPolicyId (string): The group policy to be applied to clients
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'createNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
-
-		body_params = ['name', 'passphrase', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "create",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str, **kwargs):
-		"""
-		**Update an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- identityPskId (string): (required)
-		- name (string): The name of the Identity PSK
-		- passphrase (string): The passphrase for client authentication
-		- groupPolicyId (string): The group policy to be applied to clients
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'updateNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
-
-		body_params = ['name', 'passphrase', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def deleteNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
-		"""
-		**Delete an Identity PSK**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-ssid-identity-psk
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- identityPskId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
-			'operation': 'deleteNetworkWirelessSsidIdentityPsk'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
-
-		action = {
-			"resource": resource,
-			"operation": "destroy",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsidSplashSettings(self, networkId: str, number: str, **kwargs):
-		"""
-		**Modify the splash page settings for the given SSID**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-splash-settings
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- splashUrl (string): [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
-		- useSplashUrl (boolean): [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
-		- splashTimeout (integer): Splash timeout in minutes. This will determine how often users will see the splash page.
-		- redirectUrl (string): The custom redirect URL where the users will go after the splash page.
-		- useRedirectUrl (boolean): The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.
-		- welcomeMessage (string): The welcome message for the users on the splash page.
-		- splashLogo (object): The logo used in the splash page.
-		- splashImage (object): The image used in the splash page.
-		- splashPrepaidFront (object): The prepaid front image used in the splash page.
-		- blockAllTrafficBeforeSignOn (boolean): How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
-		- controllerDisconnectionBehavior (string): How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.
-		- allowSimultaneousLogins (boolean): Whether or not to allow simultaneous logins from different devices.
-		- guestSponsorship (object): Details associated with guest sponsored splash.
-		- billing (object): Details associated with billing splash.
-		"""
-
-		kwargs.update(locals())
-
-		if 'controllerDisconnectionBehavior' in kwargs:
-			options = ['open', 'restricted', 'default']
-			assert kwargs['controllerDisconnectionBehavior'] in options, f'''"controllerDisconnectionBehavior" cannot be "{kwargs['controllerDisconnectionBehavior']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
-			'operation': 'updateNetworkWirelessSsidSplashSettings'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
-
-		body_params = ['splashUrl', 'useSplashUrl', 'splashTimeout', 'redirectUrl', 'useRedirectUrl', 'welcomeMessage', 'splashLogo', 'splashImage', 'splashPrepaidFront', 'blockAllTrafficBeforeSignOn', 'controllerDisconnectionBehavior', 'allowSimultaneousLogins', 'guestSponsorship', 'billing', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
-
-
-	def updateNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str, **kwargs):
-		"""
-		**Update the traffic shaping settings for an SSID on an MR network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-traffic-shaping-rules
-		
-		- networkId (string): (required)
-		- number (string): (required)
-		- trafficShapingEnabled (boolean): Whether traffic shaping rules are applied to clients on your SSID.
-		- defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
-		- rules (array):     An array of traffic shaping rules. Rules are applied in the order that
-    they are specified in. An empty list (or null) means no rules. Note that
-    you are allowed a maximum of 8 rules.
-
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
-			'operation': 'updateNetworkWirelessSsidTrafficShapingRules'
-		}
-		resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
-
-		body_params = ['trafficShapingEnabled', 'defaultRulesEnabled', 'rules', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-		action = {
-			"resource": resource,
-			"operation": "update",
-			"body": payload
-		}
-		return action
-
-
-
-
+class ActionBatchWireless(object):
+    def __init__(self):
+        super(ActionBatchWireless, self).__init__()
+        
+
+
+    def updateDeviceWirelessBluetoothSettings(self, serial: str, **kwargs):
+        """
+        **Update the bluetooth settings for a wireless device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-bluetooth-settings
+
+        - serial (string): (required)
+        - uuid (string): Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        - major (integer): Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        - minor (integer): Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'bluetooth', 'settings'],
+            'operation': 'updateDeviceWirelessBluetoothSettings'
+        }
+        resource = f'/devices/{serial}/wireless/bluetooth/settings'
+
+        body_params = ['uuid', 'major', 'minor', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateDeviceWirelessRadioSettings(self, serial: str, **kwargs):
+        """
+        **Update the radio settings of a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-device-wireless-radio-settings
+
+        - serial (string): (required)
+        - rfProfileId (integer): The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power).
+        - twoFourGhzSettings (object): Manual radio settings for 2.4 GHz.
+        - fiveGhzSettings (object): Manual radio settings for 5 GHz.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'radio', 'settings'],
+            'operation': 'updateDeviceWirelessRadioSettings'
+        }
+        resource = f'/devices/{serial}/wireless/radio/settings'
+
+        body_params = ['rfProfileId', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessAlternateManagementInterface(self, networkId: str, **kwargs):
+        """
+        **Update alternate management interface and device static IP**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-alternate-management-interface
+
+        - networkId (string): (required)
+        - enabled (boolean): Boolean value to enable or disable alternate management interface
+        - vlanId (integer): Alternate management interface VLAN, must be between 1 and 4094
+        - protocols (array): Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap'
+        - accessPoints (array): Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'alternateManagementInterface'],
+            'operation': 'updateNetworkWirelessAlternateManagementInterface'
+        }
+        resource = f'/networks/{networkId}/wireless/alternateManagementInterface'
+
+        body_params = ['enabled', 'vlanId', 'protocols', 'accessPoints', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessBilling(self, networkId: str, **kwargs):
+        """
+        **Update the billing settings**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-billing
+
+        - networkId (string): (required)
+        - currency (string): The currency code of this node group's billing plans
+        - plans (array): Array of billing plans in the node group. (Can configure a maximum of 5)
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'billing'],
+            'operation': 'updateNetworkWirelessBilling'
+        }
+        resource = f'/networks/{networkId}/wireless/billing'
+
+        body_params = ['currency', 'plans', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkWirelessRfProfile(self, networkId: str, name: str, bandSelectionType: str, **kwargs):
+        """
+        **Creates new RF profile for this network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - name (string): The name of the new profile. Must be unique. This param is required on creation.
+        - bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
+        - clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false. Defaults to true.
+        - minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
+        - apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
+        - twoFourGhzSettings (object): Settings related to 2.4Ghz band
+        - fiveGhzSettings (object): Settings related to 5Ghz band
+        """
+
+        kwargs.update(locals())
+
+        if 'minBitrateType' in kwargs:
+            options = ['band', 'ssid']
+            assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
+        if 'bandSelectionType' in kwargs:
+            options = ['ssid', 'ap']
+            assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'createNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles'
+
+        body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str, **kwargs):
+        """
+        **Updates specified RF profile for this network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - rfProfileId (string): (required)
+        - name (string): The name of the new profile. Must be unique.
+        - clientBalancingEnabled (boolean): Steers client to best available access point. Can be either true or false.
+        - minBitrateType (string): Minimum bitrate can be set to either 'band' or 'ssid'.
+        - bandSelectionType (string): Band selection can be set to either 'ssid' or 'ap'.
+        - apBandSettings (object): Settings that will be enabled if selectionType is set to 'ap'.
+        - twoFourGhzSettings (object): Settings related to 2.4Ghz band
+        - fiveGhzSettings (object): Settings related to 5Ghz band
+        """
+
+        kwargs.update(locals())
+
+        if 'minBitrateType' in kwargs:
+            options = ['band', 'ssid']
+            assert kwargs['minBitrateType'] in options, f'''"minBitrateType" cannot be "{kwargs['minBitrateType']}", & must be set to one of: {options}'''
+        if 'bandSelectionType' in kwargs:
+            options = ['ssid', 'ap']
+            assert kwargs['bandSelectionType'] in options, f'''"bandSelectionType" cannot be "{kwargs['bandSelectionType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'updateNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
+
+        body_params = ['name', 'clientBalancingEnabled', 'minBitrateType', 'bandSelectionType', 'apBandSettings', 'twoFourGhzSettings', 'fiveGhzSettings', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkWirelessRfProfile(self, networkId: str, rfProfileId: str):
+        """
+        **Delete a RF Profile**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-rf-profile
+
+        - networkId (string): (required)
+        - rfProfileId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'rfProfiles'],
+            'operation': 'deleteNetworkWirelessRfProfile'
+        }
+        resource = f'/networks/{networkId}/wireless/rfProfiles/{rfProfileId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSettings(self, networkId: str, **kwargs):
+        """
+        **Update the wireless settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-settings
+
+        - networkId (string): (required)
+        - meshingEnabled (boolean): Toggle for enabling or disabling meshing in a network
+        - ipv6BridgeEnabled (boolean): Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
+        - locationAnalyticsEnabled (boolean): Toggle for enabling or disabling location analytics for your network
+        - upgradeStrategy (string): The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
+        - ledLightsOn (boolean): Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
+        """
+
+        kwargs.update(locals())
+
+        if 'upgradeStrategy' in kwargs:
+            options = ['minimizeUpgradeTime', 'minimizeClientDowntime']
+            assert kwargs['upgradeStrategy'] in options, f'''"upgradeStrategy" cannot be "{kwargs['upgradeStrategy']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'settings'],
+            'operation': 'updateNetworkWirelessSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/settings'
+
+        body_params = ['meshingEnabled', 'ipv6BridgeEnabled', 'locationAnalyticsEnabled', 'upgradeStrategy', 'ledLightsOn', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsid(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the attributes of an MR SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - name (string): The name of the SSID
+        - enabled (boolean): Whether or not the SSID is enabled
+        - authMode (string): The association control method for the SSID ('open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
+        - enterpriseAdminAccess (string): Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
+        - encryptionMode (string): The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
+        - psk (string): The passkey for the SSID. This param is only valid if the authMode is 'psk'
+        - wpaEncryptionMode (string): The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
+        - dot11w (object): The current setting for Protected Management Frames (802.11w).
+        - dot11r (object): The current setting for 802.11r
+        - splashPage (string): The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
+        - splashGuestSponsorDomains (array): Array of valid sponsor email domains for sponsored guest splash type.
+        - oauth (object): The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
+        - localRadius (object): The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
+        - ldap (object): The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
+        - activeDirectory (object): The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
+        - radiusServers (array): The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
+        - radiusProxyEnabled (boolean): If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
+        - radiusTestingEnabled (boolean): If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
+        - radiusCalledStationId (string): The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
+        - radiusAuthenticationNasId (string): The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
+        - radiusServerTimeout (integer): The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
+        - radiusServerAttemptsLimit (integer): The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
+        - radiusFallbackEnabled (boolean): Whether or not higher priority RADIUS servers should be retried after 60 seconds.
+        - radiusCoaEnabled (boolean): If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
+        - radiusFailoverPolicy (string): This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
+        - radiusLoadBalancingPolicy (string): This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
+        - radiusAccountingEnabled (boolean): Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
+        - radiusAccountingServers (array): The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
+        - radiusAccountingInterimInterval (integer): The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
+        - radiusAttributeForGroupPolicies (string): Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
+        - ipAssignmentMode (string): The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
+        - useVlanTagging (boolean): Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - concentratorNetworkId (string): The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
+        - vlanId (integer): The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
+        - defaultVlanId (integer): The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - apTagsAndVlanIds (array): The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
+        - walledGardenEnabled (boolean): Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
+        - walledGardenRanges (array): Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
+        - radiusOverride (boolean): If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
+        - radiusGuestVlanEnabled (boolean): Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
+        - radiusGuestVlanId (integer): VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
+        - minBitrate (number): The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
+        - bandSelection (string): The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
+        - perClientBandwidthLimitUp (integer): The upload bandwidth limit in Kbps. (0 represents no limit.)
+        - perClientBandwidthLimitDown (integer): The download bandwidth limit in Kbps. (0 represents no limit.)
+        - perSsidBandwidthLimitUp (integer): The total upload bandwidth limit in Kbps. (0 represents no limit.)
+        - perSsidBandwidthLimitDown (integer): The total download bandwidth limit in Kbps. (0 represents no limit.)
+        - lanIsolationEnabled (boolean): Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
+        - visible (boolean): Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
+        - availableOnAllAps (boolean): Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
+        - availabilityTags (array): Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
+        - mandatoryDhcpEnabled (boolean): If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
+        - adultContentFilteringEnabled (boolean): Boolean indicating whether or not adult content will be blocked
+        - dnsRewrite (object): DNS servers rewrite settings
+        """
+
+        kwargs.update(locals())
+
+        if 'authMode' in kwargs:
+            options = ['open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius', 'ipsk-without-radius']
+            assert kwargs['authMode'] in options, f'''"authMode" cannot be "{kwargs['authMode']}", & must be set to one of: {options}'''
+        if 'enterpriseAdminAccess' in kwargs:
+            options = ['access disabled', 'access enabled']
+            assert kwargs['enterpriseAdminAccess'] in options, f'''"enterpriseAdminAccess" cannot be "{kwargs['enterpriseAdminAccess']}", & must be set to one of: {options}'''
+        if 'encryptionMode' in kwargs:
+            options = ['wep', 'wpa']
+            assert kwargs['encryptionMode'] in options, f'''"encryptionMode" cannot be "{kwargs['encryptionMode']}", & must be set to one of: {options}'''
+        if 'wpaEncryptionMode' in kwargs:
+            options = ['WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only']
+            assert kwargs['wpaEncryptionMode'] in options, f'''"wpaEncryptionMode" cannot be "{kwargs['wpaEncryptionMode']}", & must be set to one of: {options}'''
+        if 'splashPage' in kwargs:
+            options = ['None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE', 'Google Apps domain']
+            assert kwargs['splashPage'] in options, f'''"splashPage" cannot be "{kwargs['splashPage']}", & must be set to one of: {options}'''
+        if 'radiusFailoverPolicy' in kwargs:
+            options = ['Deny access', 'Allow access']
+            assert kwargs['radiusFailoverPolicy'] in options, f'''"radiusFailoverPolicy" cannot be "{kwargs['radiusFailoverPolicy']}", & must be set to one of: {options}'''
+        if 'radiusLoadBalancingPolicy' in kwargs:
+            options = ['Strict priority order', 'Round robin']
+            assert kwargs['radiusLoadBalancingPolicy'] in options, f'''"radiusLoadBalancingPolicy" cannot be "{kwargs['radiusLoadBalancingPolicy']}", & must be set to one of: {options}'''
+        if 'radiusAttributeForGroupPolicies' in kwargs:
+            options = ['Filter-Id', 'Reply-Message', 'Airespace-ACL-Name', 'Aruba-User-Role']
+            assert kwargs['radiusAttributeForGroupPolicies'] in options, f'''"radiusAttributeForGroupPolicies" cannot be "{kwargs['radiusAttributeForGroupPolicies']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids'],
+            'operation': 'updateNetworkWirelessSsid'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}'
+
+        body_params = ['name', 'enabled', 'authMode', 'enterpriseAdminAccess', 'encryptionMode', 'psk', 'wpaEncryptionMode', 'dot11w', 'dot11r', 'splashPage', 'splashGuestSponsorDomains', 'oauth', 'localRadius', 'ldap', 'activeDirectory', 'radiusServers', 'radiusProxyEnabled', 'radiusTestingEnabled', 'radiusCalledStationId', 'radiusAuthenticationNasId', 'radiusServerTimeout', 'radiusServerAttemptsLimit', 'radiusFallbackEnabled', 'radiusCoaEnabled', 'radiusFailoverPolicy', 'radiusLoadBalancingPolicy', 'radiusAccountingEnabled', 'radiusAccountingServers', 'radiusAccountingInterimInterval', 'radiusAttributeForGroupPolicies', 'ipAssignmentMode', 'useVlanTagging', 'concentratorNetworkId', 'vlanId', 'defaultVlanId', 'apTagsAndVlanIds', 'walledGardenEnabled', 'walledGardenRanges', 'radiusOverride', 'radiusGuestVlanEnabled', 'radiusGuestVlanId', 'minBitrate', 'bandSelection', 'perClientBandwidthLimitUp', 'perClientBandwidthLimitDown', 'perSsidBandwidthLimitUp', 'perSsidBandwidthLimitDown', 'lanIsolationEnabled', 'visible', 'availableOnAllAps', 'availabilityTags', 'mandatoryDhcpEnabled', 'adultContentFilteringEnabled', 'dnsRewrite', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidBonjourForwarding(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the bonjour forwarding setting and rules for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-bonjour-forwarding
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - enabled (boolean): If true, Bonjour forwarding is enabled on this SSID.
+        - rules (array): List of bonjour forwarding rules.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'bonjourForwarding'],
+            'operation': 'updateNetworkWirelessSsidBonjourForwarding'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding'
+
+        body_params = ['enabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidDeviceTypeGroupPolicies(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the device type group policies for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-device-type-group-policies
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - enabled (boolean): If true, the SSID device type group policies are enabled.
+        - deviceTypePolicies (array): List of device type policies.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'deviceTypeGroupPolicies'],
+            'operation': 'updateNetworkWirelessSsidDeviceTypeGroupPolicies'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies'
+
+        body_params = ['enabled', 'deviceTypePolicies', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidFirewallL7FirewallRules(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the L7 firewall rules of an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-firewall-l-7-firewall-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - rules (array): An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'firewall', 'l7FirewallRules'],
+            'operation': 'updateNetworkWirelessSsidFirewallL7FirewallRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules'
+
+        body_params = ['rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def createNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, name: str, passphrase: str, groupPolicyId: str):
+        """
+        **Create an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - name (string): The name of the Identity PSK
+        - passphrase (string): The passphrase for client authentication
+        - groupPolicyId (string): The group policy to be applied to clients
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'createNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks'
+
+        body_params = ['name', 'passphrase', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "create",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str, **kwargs):
+        """
+        **Update an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - identityPskId (string): (required)
+        - name (string): The name of the Identity PSK
+        - passphrase (string): The passphrase for client authentication
+        - groupPolicyId (string): The group policy to be applied to clients
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'updateNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
+
+        body_params = ['name', 'passphrase', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def deleteNetworkWirelessSsidIdentityPsk(self, networkId: str, number: str, identityPskId: str):
+        """
+        **Delete an Identity PSK**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-wireless-ssid-identity-psk
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - identityPskId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'identityPsks'],
+            'operation': 'deleteNetworkWirelessSsidIdentityPsk'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}'
+
+        action = {
+            "resource": resource,
+            "operation": "destroy",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidSplashSettings(self, networkId: str, number: str, **kwargs):
+        """
+        **Modify the splash page settings for the given SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-splash-settings
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - splashUrl (string): [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
+        - useSplashUrl (boolean): [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
+        - splashTimeout (integer): Splash timeout in minutes. This will determine how often users will see the splash page.
+        - redirectUrl (string): The custom redirect URL where the users will go after the splash page.
+        - useRedirectUrl (boolean): The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.
+        - welcomeMessage (string): The welcome message for the users on the splash page.
+        - splashLogo (object): The logo used in the splash page.
+        - splashImage (object): The image used in the splash page.
+        - splashPrepaidFront (object): The prepaid front image used in the splash page.
+        - blockAllTrafficBeforeSignOn (boolean): How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
+        - controllerDisconnectionBehavior (string): How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.
+        - allowSimultaneousLogins (boolean): Whether or not to allow simultaneous logins from different devices.
+        - guestSponsorship (object): Details associated with guest sponsored splash.
+        - billing (object): Details associated with billing splash.
+        """
+
+        kwargs.update(locals())
+
+        if 'controllerDisconnectionBehavior' in kwargs:
+            options = ['open', 'restricted', 'default']
+            assert kwargs['controllerDisconnectionBehavior'] in options, f'''"controllerDisconnectionBehavior" cannot be "{kwargs['controllerDisconnectionBehavior']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'splash', 'settings'],
+            'operation': 'updateNetworkWirelessSsidSplashSettings'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/splash/settings'
+
+        body_params = ['splashUrl', 'useSplashUrl', 'splashTimeout', 'redirectUrl', 'useRedirectUrl', 'welcomeMessage', 'splashLogo', 'splashImage', 'splashPrepaidFront', 'blockAllTrafficBeforeSignOn', 'controllerDisconnectionBehavior', 'allowSimultaneousLogins', 'guestSponsorship', 'billing', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidTrafficShapingRules(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the traffic shaping settings for an SSID on an MR network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-traffic-shaping-rules
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - trafficShapingEnabled (boolean): Whether traffic shaping rules are applied to clients on your SSID.
+        - defaultRulesEnabled (boolean): Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
+        - rules (array):     An array of traffic shaping rules. Rules are applied in the order that
+    they are specified in. An empty list (or null) means no rules. Note that
+    you are allowed a maximum of 8 rules.
+
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'trafficShaping', 'rules'],
+            'operation': 'updateNetworkWirelessSsidTrafficShapingRules'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules'
+
+        body_params = ['trafficShapingEnabled', 'defaultRulesEnabled', 'rules', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
+
+
+    def updateNetworkWirelessSsidVpn(self, networkId: str, number: str, **kwargs):
+        """
+        **Update the VPN settings for the SSID**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-wireless-ssid-vpn
+
+        - networkId (string): (required)
+        - number (string): (required)
+        - splitTunnel (object): The VPN split tunnel settings for this SSID.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['wireless', 'configure', 'ssids', 'vpn'],
+            'operation': 'updateNetworkWirelessSsidVpn'
+        }
+        resource = f'/networks/{networkId}/wireless/ssids/{number}/vpn'
+
+        body_params = ['splitTunnel', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+        action = {
+            "resource": resource,
+            "operation": "update",
+            "body": payload
+        }
+        return action
+        
+
+
+
```

### Comparing `meraki-1.7.1/meraki/api/insight.py` & `meraki-1.7.2/meraki/api/insight.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,103 +1,114 @@
-class Insight(object):
-	def __init__(self, session):
-		super(Insight, self).__init__()
-		self._session = session
-
-	def getOrganizationInsightMonitoredMediaServers(self, organizationId: str):
-		"""
-		**List the monitored media servers for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-servers
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'getOrganizationInsightMonitoredMediaServers'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
-
-		return self._session.get(metadata, resource)
-
-	def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
-		"""
-		**Add a media server to be monitored for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'createOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
-		"""
-		**Return a monitored media server for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'getOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
-		"""
-		**Update a monitored media server for this organization**
-		https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		- name (string): The name of the VoIP provider
-		- address (string): The IP address (IPv4 only) or hostname of the media server to monitor
-		- bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'updateOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
-		"""
-		**Delete a monitored media server from this organization**
-		https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
-		
-		- organizationId (string): (required)
-		- monitoredMediaServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['insight', 'configure', 'monitoredMediaServers'],
-			'operation': 'deleteOrganizationInsightMonitoredMediaServer'
-		}
-		resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
-
-		return self._session.delete(metadata, resource)
+class Insight(object):
+    def __init__(self, session):
+        super(Insight, self).__init__()
+        self._session = session
+        
+
+
+    def getOrganizationInsightMonitoredMediaServers(self, organizationId: str):
+        """
+        **List the monitored media servers for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-servers
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'getOrganizationInsightMonitoredMediaServers'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createOrganizationInsightMonitoredMediaServer(self, organizationId: str, name: str, address: str, **kwargs):
+        """
+        **Add a media server to be monitored for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!create-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'createOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
+        """
+        **Return a monitored media server for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'getOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str, **kwargs):
+        """
+        **Update a monitored media server for this organization**
+        https://developer.cisco.com/meraki/api-v1/#!update-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        - name (string): The name of the VoIP provider
+        - address (string): The IP address (IPv4 only) or hostname of the media server to monitor
+        - bestEffortMonitoringEnabled (boolean): Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'updateOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        body_params = ['name', 'address', 'bestEffortMonitoringEnabled', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteOrganizationInsightMonitoredMediaServer(self, organizationId: str, monitoredMediaServerId: str):
+        """
+        **Delete a monitored media server from this organization**
+        https://developer.cisco.com/meraki/api-v1/#!delete-organization-insight-monitored-media-server
+
+        - organizationId (string): (required)
+        - monitoredMediaServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['insight', 'configure', 'monitoredMediaServers'],
+            'operation': 'deleteOrganizationInsightMonitoredMediaServer'
+        }
+        resource = f'/organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}'
+
+        return self._session.delete(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/api/networks.py` & `meraki-1.7.2/meraki/api/networks.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,1700 +1,1888 @@
-class Networks(object):
-	def __init__(self, session):
-		super(Networks, self).__init__()
-		self._session = session
-
-	def getNetwork(self, networkId: str):
-		"""
-		**Return a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'getNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetwork(self, networkId: str, **kwargs):
-		"""
-		**Update a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network
-		
-		- networkId (string): (required)
-		- name (string): The name of the network
-		- timeZone (string): The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
-		- tags (array): A list of tags to be applied to the network
-		- enrollmentString (string): A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
-		- notes (string): Add any notes or additional information about this network here.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'updateNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		body_params = ['name', 'timeZone', 'tags', 'enrollmentString', 'notes', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetwork(self, networkId: str):
-		"""
-		**Delete a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'deleteNetwork'
-		}
-		resource = f'/networks/{networkId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkAlertsSettings(self, networkId: str):
-		"""
-		**Return the alert configuration for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-alerts-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'alerts', 'settings'],
-			'operation': 'getNetworkAlertsSettings'
-		}
-		resource = f'/networks/{networkId}/alerts/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkAlertsSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the alert configuration for this network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-alerts-settings
-		
-		- networkId (string): (required)
-		- defaultDestinations (object): The network-wide destinations for all alerts on the network.
-		- alerts (array): Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'alerts', 'settings'],
-			'operation': 'updateNetworkAlertsSettings'
-		}
-		resource = f'/networks/{networkId}/alerts/settings'
-
-		body_params = ['defaultDestinations', 'alerts', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def bindNetwork(self, networkId: str, configTemplateId: str, **kwargs):
-		"""
-		**Bind a network to a template.**
-		https://developer.cisco.com/meraki/api-v1/#!bind-network
-		
-		- networkId (string): (required)
-		- configTemplateId (string): The ID of the template to which the network should be bound.
-		- autoBind (boolean): Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'bindNetwork'
-		}
-		resource = f'/networks/{networkId}/bind'
-
-		body_params = ['configTemplateId', 'autoBind', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkBluetoothClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the Bluetooth clients seen by APs in this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-clients
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- includeConnectivityHistory (boolean): Include the connectivity history for this client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'bluetoothClients'],
-			'operation': 'getNetworkBluetoothClients'
-		}
-		resource = f'/networks/{networkId}/bluetoothClients'
-
-		query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'includeConnectivityHistory', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkBluetoothClient(self, networkId: str, bluetoothClientId: str, **kwargs):
-		"""
-		**Return a Bluetooth client**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-client
-		
-		- networkId (string): (required)
-		- bluetoothClientId (string): (required)
-		- includeConnectivityHistory (boolean): Include the connectivity history for this client
-		- connectivityHistoryTimespan (integer): The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'bluetoothClients'],
-			'operation': 'getNetworkBluetoothClient'
-		}
-		resource = f'/networks/{networkId}/bluetoothClients/{bluetoothClientId}'
-
-		query_params = ['includeConnectivityHistory', 'connectivityHistoryTimespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the clients that have used this network in the timespan**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients'],
-			'operation': 'getNetworkClients'
-		}
-		resource = f'/networks/{networkId}/clients'
-
-		query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClientsApplicationUsage(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the application usage data for clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients-application-usage
-		
-		- networkId (string): (required)
-		- clients (string): A list of client keys, MACs or IPs separated by comma.
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- ssidNumber (integer): An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'applicationUsage'],
-			'operation': 'getNetworkClientsApplicationUsage'
-		}
-		resource = f'/networks/{networkId}/clients/applicationUsage'
-
-		query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def provisionNetworkClients(self, networkId: str, clients: list, devicePolicy: str, **kwargs):
-		"""
-		**Provisions a client with a name and policy**
-		https://developer.cisco.com/meraki/api-v1/#!provision-network-clients
-		
-		- networkId (string): (required)
-		- clients (array): The array of clients to provision
-		- devicePolicy (string): The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
-		- groupPolicyId (string): The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
-		- policiesBySecurityAppliance (object): An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
-		- policiesBySsid (object): An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
-		"""
-
-		kwargs.update(locals())
-
-		if 'devicePolicy' in kwargs:
-			options = ['Group policy', 'Allowed', 'Blocked', 'Per connection', 'Normal']
-			assert kwargs['devicePolicy'] in options, f'''"devicePolicy" cannot be "{kwargs['devicePolicy']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients'],
-			'operation': 'provisionNetworkClients'
-		}
-		resource = f'/networks/{networkId}/clients/provision'
-
-		body_params = ['clients', 'devicePolicy', 'groupPolicyId', 'policiesBySecurityAppliance', 'policiesBySsid', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkClientsUsageHistories(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the usage histories for clients**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-clients-usage-histories
-		
-		- networkId (string): (required)
-		- clients (string): A list of client keys, MACs or IPs separated by comma.
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'usageHistories'],
-			'operation': 'getNetworkClientsUsageHistories'
-		}
-		resource = f'/networks/{networkId}/clients/usageHistories'
-
-		query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClient(self, networkId: str, clientId: str):
-		"""
-		**Return the client associated with the given identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients'],
-			'operation': 'getNetworkClient'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkClientPolicy(self, networkId: str, clientId: str):
-		"""
-		**Return the policy assigned to a client on the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-policy
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'policy'],
-			'operation': 'getNetworkClientPolicy'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/policy'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkClientPolicy(self, networkId: str, clientId: str, devicePolicy: str, **kwargs):
-		"""
-		**Update the policy assigned to a client on the network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-client-policy
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- devicePolicy (string): The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
-		- groupPolicyId (string): [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'policy'],
-			'operation': 'updateNetworkClientPolicy'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/policy'
-
-		body_params = ['devicePolicy', 'groupPolicyId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str):
-		"""
-		**Return the splash authorization for a client, for each SSID they've associated with through splash**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-splash-authorization-status
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
-			'operation': 'getNetworkClientSplashAuthorizationStatus'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str, ssids: dict):
-		"""
-		**Update a client's splash authorization**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-client-splash-authorization-status
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- ssids (object): The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
-			'operation': 'updateNetworkClientSplashAuthorizationStatus'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
-
-		body_params = ['ssids', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkClientTrafficHistory(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return the client's network traffic data over time**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-traffic-history
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'trafficHistory'],
-			'operation': 'getNetworkClientTrafficHistory'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/trafficHistory'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkClientUsageHistory(self, networkId: str, clientId: str):
-		"""
-		**Return the client's daily usage history**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-client-usage-history
-		
-		- networkId (string): (required)
-		- clientId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'clients', 'usageHistory'],
-			'operation': 'getNetworkClientUsageHistory'
-		}
-		resource = f'/networks/{networkId}/clients/{clientId}/usageHistory'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkDevices(self, networkId: str):
-		"""
-		**List the devices in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-devices
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'getNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices'
-
-		return self._session.get(metadata, resource)
-
-	def claimNetworkDevices(self, networkId: str, serials: list):
-		"""
-		**Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)**
-		https://developer.cisco.com/meraki/api-v1/#!claim-network-devices
-		
-		- networkId (string): (required)
-		- serials (array): A list of serials of devices to claim
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'claimNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices/claim'
-
-		body_params = ['serials', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def removeNetworkDevices(self, networkId: str, serial: str):
-		"""
-		**Remove a single device**
-		https://developer.cisco.com/meraki/api-v1/#!remove-network-devices
-		
-		- networkId (string): (required)
-		- serial (string): The serial of a device
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'devices'],
-			'operation': 'removeNetworkDevices'
-		}
-		resource = f'/networks/{networkId}/devices/remove'
-
-		body_params = ['serial', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkEvents(self, networkId: str, total_pages=1, direction='prev', event_log_end_time=None, **kwargs):
-		"""
-		**List the events for the network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-events
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" or "prev" (default) page
-		- event_log_end_time (string): ISO8601 Zulu/UTC time, to use in conjunction with startingAfter, to retrieve events within a time window
-		- productType (string): The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental
-		- includedEventTypes (array): A list of event types. The returned events will be filtered to only include events with these types.
-		- excludedEventTypes (array): A list of event types. The returned events will be filtered to exclude events with these types.
-		- deviceMac (string): The MAC address of the Meraki device which the list of events will be filtered with
-		- deviceSerial (string): The serial of the Meraki device which the list of events will be filtered with
-		- deviceName (string): The name of the Meraki device which the list of events will be filtered with
-		- clientIp (string): The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.
-		- clientMac (string): The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.
-		- clientName (string): The name, or partial name, of the client which the list of events will be filtered with
-		- smDeviceMac (string): The MAC address of the Systems Manager device which the list of events will be filtered with
-		- smDeviceName (string): The name of the Systems Manager device which the list of events will be filtered with
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'events'],
-			'operation': 'getNetworkEvents'
-		}
-		resource = f'/networks/{networkId}/events'
-
-		query_params = ['productType', 'includedEventTypes', 'excludedEventTypes', 'deviceMac', 'deviceSerial', 'deviceName', 'clientIp', 'clientMac', 'clientName', 'smDeviceMac', 'smDeviceName', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['includedEventTypes', 'excludedEventTypes', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction, event_log_end_time)
-
-	def getNetworkEventsEventTypes(self, networkId: str):
-		"""
-		**List the event type to human-readable description**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-events-event-types
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'events', 'eventTypes'],
-			'operation': 'getNetworkEventsEventTypes'
-		}
-		resource = f'/networks/{networkId}/events/eventTypes'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkFirmwareUpgrades(self, networkId: str):
-		"""
-		**Get current maintenance window for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-firmware-upgrades
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'firmwareUpgrades'],
-			'operation': 'getNetworkFirmwareUpgrades'
-		}
-		resource = f'/networks/{networkId}/firmwareUpgrades'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkFirmwareUpgrades(self, networkId: str, **kwargs):
-		"""
-		**Update current maintenance window for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-firmware-upgrades
-		
-		- networkId (string): (required)
-		- upgradeWindow (object): Upgrade window for devices in network
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'firmwareUpgrades'],
-			'operation': 'updateNetworkFirmwareUpgrades'
-		}
-		resource = f'/networks/{networkId}/firmwareUpgrades'
-
-		body_params = ['upgradeWindow', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkFloorPlans(self, networkId: str):
-		"""
-		**List the floor plans that belong to your network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plans
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'getNetworkFloorPlans'
-		}
-		resource = f'/networks/{networkId}/floorPlans'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkFloorPlan(self, networkId: str, name: str, imageContents: str, **kwargs):
-		"""
-		**Upload a floor plan**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-floor-plan
-		
-		- networkId (string): (required)
-		- name (string): The name of your floor plan.
-		- imageContents (string): The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
-		- center (object): The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
-		- bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
-		- bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
-		- topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
-		- topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'createNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans'
-
-		body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkFloorPlan(self, networkId: str, floorPlanId: str):
-		"""
-		**Find a floor plan by ID**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'getNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkFloorPlan(self, networkId: str, floorPlanId: str, **kwargs):
-		"""
-		**Update a floor plan's geolocation and other meta data**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		- name (string): The name of your floor plan.
-		- center (object): The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
-		- bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
-		- bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
-		- topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
-		- topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
-		- imageContents (string): The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'updateNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkFloorPlan(self, networkId: str, floorPlanId: str):
-		"""
-		**Destroy a floor plan**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-floor-plan
-		
-		- networkId (string): (required)
-		- floorPlanId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'floorPlans'],
-			'operation': 'deleteNetworkFloorPlan'
-		}
-		resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkGroupPolicies(self, networkId: str):
-		"""
-		**List the group policies in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-group-policies
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'getNetworkGroupPolicies'
-		}
-		resource = f'/networks/{networkId}/groupPolicies'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkGroupPolicy(self, networkId: str, name: str, **kwargs):
-		"""
-		**Create a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-group-policy
-		
-		- networkId (string): (required)
-		- name (string): The name for your group policy. Required.
-		- scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
-
-		- bandwidth (object):     The bandwidth settings for clients bound to your group policy.
-
-		- firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
-
-		- contentFiltering (object): The content filtering settings for your group policy
-		- splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
-		- vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
-		- bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
-		"""
-
-		kwargs.update(locals())
-
-		if 'splashAuthSettings' in kwargs:
-			options = ['network default', 'bypass']
-			assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'createNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies'
-
-		body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
-		"""
-		**Display a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'getNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkGroupPolicy(self, networkId: str, groupPolicyId: str, **kwargs):
-		"""
-		**Update a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		- name (string): The name for your group policy.
-		- scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
-
-		- bandwidth (object):     The bandwidth settings for clients bound to your group policy.
-
-		- firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
-
-		- contentFiltering (object): The content filtering settings for your group policy
-		- splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
-		- vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
-		- bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
-		"""
-
-		kwargs.update(locals())
-
-		if 'splashAuthSettings' in kwargs:
-			options = ['network default', 'bypass']
-			assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'updateNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
-		"""
-		**Delete a group policy**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-group-policy
-		
-		- networkId (string): (required)
-		- groupPolicyId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'groupPolicies'],
-			'operation': 'deleteNetworkGroupPolicy'
-		}
-		resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkMerakiAuthUsers(self, networkId: str):
-		"""
-		**List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-users
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'getNetworkMerakiAuthUsers'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkMerakiAuthUser(self, networkId: str, email: str, name: str, password: str, authorizations: list, **kwargs):
-		"""
-		**Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- email (string): Email address of the user
-		- name (string): Name of the user
-		- password (string): The password for this user account
-		- authorizations (array): Authorization zones and expiration dates for the user.
-		- accountType (string): Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'.
-		- emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
-		"""
-
-		kwargs.update(locals())
-
-		if 'accountType' in kwargs:
-			options = ['Guest', '802.1X', 'Client VPN']
-			assert kwargs['accountType'] in options, f'''"accountType" cannot be "{kwargs['accountType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'createNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers'
-
-		body_params = ['email', 'name', 'password', 'accountType', 'emailPasswordToUser', 'authorizations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
-		"""
-		**Return the Meraki Auth splash guest, RADIUS, or client VPN user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'getNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		return self._session.get(metadata, resource)
-
-	def deleteNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
-		"""
-		**Deauthorize a user**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'deleteNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		return self._session.delete(metadata, resource)
-
-	def updateNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str, **kwargs):
-		"""
-		**Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-meraki-auth-user
-		
-		- networkId (string): (required)
-		- merakiAuthUserId (string): (required)
-		- name (string): Name of the user
-		- password (string): The password for this user account
-		- emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
-		- authorizations (array): Authorization zones and expiration dates for the user.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'merakiAuthUsers'],
-			'operation': 'updateNetworkMerakiAuthUser'
-		}
-		resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
-
-		body_params = ['name', 'password', 'emailPasswordToUser', 'authorizations', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkMqttBrokers(self, networkId: str):
-		"""
-		**List the MQTT brokers for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-brokers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'getNetworkMqttBrokers'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkMqttBroker(self, networkId: str, name: str, host: str, port: int):
-		"""
-		**Add an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- name (string): Name of the MQTT broker
-		- host (string): Host name/IP address where MQTT broker runs
-		- port (integer): Host port though which MQTT broker can be reached
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'createNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers'
-
-		body_params = ['name', 'host', 'port', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
-		"""
-		**Return an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'getNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkMqttBroker(self, networkId: str, mqttBrokerId: str, **kwargs):
-		"""
-		**Update an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		- name (string): Name of the mqtt config
-		- host (string): Host name where mqtt broker runs
-		- port (integer): Host port though which mqtt broker can be reached
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'updateNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		body_params = ['name', 'host', 'port', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
-		"""
-		**Delete an MQTT broker**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-mqtt-broker
-		
-		- networkId (string): (required)
-		- mqttBrokerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'mqttBrokers'],
-			'operation': 'deleteNetworkMqttBroker'
-		}
-		resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkNetflow(self, networkId: str):
-		"""
-		**Return the NetFlow traffic reporting settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-netflow
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'netflow'],
-			'operation': 'getNetworkNetflow'
-		}
-		resource = f'/networks/{networkId}/netflow'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkNetflow(self, networkId: str, **kwargs):
-		"""
-		**Update the NetFlow traffic reporting settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-netflow
-		
-		- networkId (string): (required)
-		- reportingEnabled (boolean): Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
-		- collectorIp (string): The IPv4 address of the NetFlow collector.
-		- collectorPort (integer): The port that the NetFlow collector will be listening on.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'netflow'],
-			'operation': 'updateNetworkNetflow'
-		}
-		resource = f'/networks/{networkId}/netflow'
-
-		body_params = ['reportingEnabled', 'collectorIp', 'collectorPort', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkNetworkHealthChannelUtilization(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Get the channel utilization over each radio for all APs in a network.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-network-health-channel-utilization
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
-		- t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
-		- resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'networkHealth', 'channelUtilization'],
-			'operation': 'getNetworkNetworkHealthChannelUtilization'
-		}
-		resource = f'/networks/{networkId}/networkHealth/channelUtilization'
-
-		query_params = ['t0', 't1', 'timespan', 'resolution', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkPiiPiiKeys(self, networkId: str, **kwargs):
-		"""
-		**List the keys required to access Personally Identifiable Information (PII) for a given identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-pii-keys
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'piiKeys'],
-			'operation': 'getNetworkPiiPiiKeys'
-		}
-		resource = f'/networks/{networkId}/pii/piiKeys'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkPiiRequests(self, networkId: str):
-		"""
-		**List the PII requests for this network or organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-requests
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'getNetworkPiiRequests'
-		}
-		resource = f'/networks/{networkId}/pii/requests'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkPiiRequest(self, networkId: str, **kwargs):
-		"""
-		**Submit a new delete or restrict processing PII request**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-pii-request
-		
-		- networkId (string): (required)
-		- type (string): One of "delete" or "restrict processing"
-		- datasets (array): The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
-		- username (string): The username of a network log in. Only applies to "delete" requests.
-		- email (string): The email of a network user account. Only applies to "delete" requests.
-		- mac (string): The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
-		- smDeviceId (string): The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
-		- smUserId (string): The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
-		"""
-
-		kwargs.update(locals())
-
-		if 'type' in kwargs:
-			options = ['delete', 'restrict processing']
-			assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'createNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests'
-
-		body_params = ['type', 'datasets', 'username', 'email', 'mac', 'smDeviceId', 'smUserId', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkPiiRequest(self, networkId: str, requestId: str):
-		"""
-		**Return a PII request**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-request
-		
-		- networkId (string): (required)
-		- requestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'getNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests/{requestId}'
-
-		return self._session.get(metadata, resource)
-
-	def deleteNetworkPiiRequest(self, networkId: str, requestId: str):
-		"""
-		**Delete a restrict processing PII request**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-pii-request
-		
-		- networkId (string): (required)
-		- requestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'requests'],
-			'operation': 'deleteNetworkPiiRequest'
-		}
-		resource = f'/networks/{networkId}/pii/requests/{requestId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkPiiSmDevicesForKey(self, networkId: str, **kwargs):
-		"""
-		**Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-devices-for-key
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'smDevicesForKey'],
-			'operation': 'getNetworkPiiSmDevicesForKey'
-		}
-		resource = f'/networks/{networkId}/pii/smDevicesForKey'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkPiiSmOwnersForKey(self, networkId: str, **kwargs):
-		"""
-		**Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-owners-for-key
-		
-		- networkId (string): (required)
-		- username (string): The username of a Systems Manager user
-		- email (string): The email of a network user account or a Systems Manager device
-		- mac (string): The MAC of a network client device or a Systems Manager device
-		- serial (string): The serial of a Systems Manager device
-		- imei (string): The IMEI of a Systems Manager device
-		- bluetoothMac (string): The MAC of a Bluetooth client
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'pii', 'smOwnersForKey'],
-			'operation': 'getNetworkPiiSmOwnersForKey'
-		}
-		resource = f'/networks/{networkId}/pii/smOwnersForKey'
-
-		query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkSettings(self, networkId: str):
-		"""
-		**Return the settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-settings
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'settings'],
-			'operation': 'getNetworkSettings'
-		}
-		resource = f'/networks/{networkId}/settings'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSettings(self, networkId: str, **kwargs):
-		"""
-		**Update the settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-settings
-		
-		- networkId (string): (required)
-		- localStatusPageEnabled (boolean): Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
-		- remoteStatusPageEnabled (boolean): Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
-		- secureConnect (object): A hash of SecureConnect options applied to the Network.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'settings'],
-			'operation': 'updateNetworkSettings'
-		}
-		resource = f'/networks/{networkId}/settings'
-
-		body_params = ['localStatusPageEnabled', 'remoteStatusPageEnabled', 'secureConnect', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkSnmp(self, networkId: str):
-		"""
-		**Return the SNMP settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-snmp
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'snmp'],
-			'operation': 'getNetworkSnmp'
-		}
-		resource = f'/networks/{networkId}/snmp'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSnmp(self, networkId: str, **kwargs):
-		"""
-		**Update the SNMP settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-snmp
-		
-		- networkId (string): (required)
-		- access (string): The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
-		- communityString (string): The SNMP community string. Only relevant if 'access' is set to 'community'.
-		- users (array): The list of SNMP users. Only relevant if 'access' is set to 'users'.
-		"""
-
-		kwargs.update(locals())
-
-		if 'access' in kwargs:
-			options = ['none', 'community', 'users']
-			assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'snmp'],
-			'operation': 'updateNetworkSnmp'
-		}
-		resource = f'/networks/{networkId}/snmp'
-
-		body_params = ['access', 'communityString', 'users', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkSplashLoginAttempts(self, networkId: str, **kwargs):
-		"""
-		**List the splash login attempts for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-splash-login-attempts
-		
-		- networkId (string): (required)
-		- ssidNumber (integer): Only return the login attempts for the specified SSID
-		- loginIdentifier (string): The username, email, or phone number used during login
-		- timespan (integer): The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months
-		"""
-
-		kwargs.update(locals())
-
-		if 'ssidNumber' in kwargs:
-			options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
-			assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'splashLoginAttempts'],
-			'operation': 'getNetworkSplashLoginAttempts'
-		}
-		resource = f'/networks/{networkId}/splashLoginAttempts'
-
-		query_params = ['ssidNumber', 'loginIdentifier', 'timespan', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def splitNetwork(self, networkId: str):
-		"""
-		**Split a combined network into individual networks for each type of device**
-		https://developer.cisco.com/meraki/api-v1/#!split-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'splitNetwork'
-		}
-		resource = f'/networks/{networkId}/split'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSyslogServers(self, networkId: str):
-		"""
-		**List the syslog servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-syslog-servers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'syslogServers'],
-			'operation': 'getNetworkSyslogServers'
-		}
-		resource = f'/networks/{networkId}/syslogServers'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkSyslogServers(self, networkId: str, servers: list):
-		"""
-		**Update the syslog servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-syslog-servers
-		
-		- networkId (string): (required)
-		- servers (array): A list of the syslog servers for this network
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['networks', 'configure', 'syslogServers'],
-			'operation': 'updateNetworkSyslogServers'
-		}
-		resource = f'/networks/{networkId}/syslogServers'
-
-		body_params = ['servers', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkTraffic(self, networkId: str, **kwargs):
-		"""
-		**Return the traffic analysis data for this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic
-		
-		- networkId (string): (required)
-		- t0 (string): The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
-		- timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.
-		- deviceType (string): Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.
-		"""
-
-		kwargs.update(locals())
-
-		if 'deviceType' in kwargs:
-			options = ['combined', 'wireless', 'switch', 'appliance']
-			assert kwargs['deviceType'] in options, f'''"deviceType" cannot be "{kwargs['deviceType']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'monitor', 'traffic'],
-			'operation': 'getNetworkTraffic'
-		}
-		resource = f'/networks/{networkId}/traffic'
-
-		query_params = ['t0', 'timespan', 'deviceType', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkTrafficAnalysis(self, networkId: str):
-		"""
-		**Return the traffic analysis settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-analysis
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficAnalysis'],
-			'operation': 'getNetworkTrafficAnalysis'
-		}
-		resource = f'/networks/{networkId}/trafficAnalysis'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkTrafficAnalysis(self, networkId: str, **kwargs):
-		"""
-		**Update the traffic analysis settings for a network**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-traffic-analysis
-		
-		- networkId (string): (required)
-		- mode (string):     The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
-    'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
-
-		- customPieChartItems (array): The list of items that make up the custom pie chart for traffic reporting.
-		"""
-
-		kwargs.update(locals())
-
-		if 'mode' in kwargs:
-			options = ['disabled', 'basic', 'detailed']
-			assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficAnalysis'],
-			'operation': 'updateNetworkTrafficAnalysis'
-		}
-		resource = f'/networks/{networkId}/trafficAnalysis'
-
-		body_params = ['mode', 'customPieChartItems', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def getNetworkTrafficShapingApplicationCategories(self, networkId: str):
-		"""
-		**Returns the application categories for traffic shaping rules.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-application-categories
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficShaping', 'applicationCategories'],
-			'operation': 'getNetworkTrafficShapingApplicationCategories'
-		}
-		resource = f'/networks/{networkId}/trafficShaping/applicationCategories'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkTrafficShapingDscpTaggingOptions(self, networkId: str):
-		"""
-		**Returns the available DSCP tagging options for your traffic shaping rules.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-dscp-tagging-options
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'trafficShaping', 'dscpTaggingOptions'],
-			'operation': 'getNetworkTrafficShapingDscpTaggingOptions'
-		}
-		resource = f'/networks/{networkId}/trafficShaping/dscpTaggingOptions'
-
-		return self._session.get(metadata, resource)
-
-	def unbindNetwork(self, networkId: str):
-		"""
-		**Unbind a network from a template.**
-		https://developer.cisco.com/meraki/api-v1/#!unbind-network
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure'],
-			'operation': 'unbindNetwork'
-		}
-		resource = f'/networks/{networkId}/unbind'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkWebhooksHttpServers(self, networkId: str):
-		"""
-		**List the HTTP servers for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-servers
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'getNetworkWebhooksHttpServers'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers'
-
-		return self._session.get(metadata, resource)
-
-	def createNetworkWebhooksHttpServer(self, networkId: str, name: str, url: str, **kwargs):
-		"""
-		**Add an HTTP server to a network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- name (string): A name for easy reference to the HTTP server
-		- url (string): The URL of the HTTP server
-		- sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'createNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers'
-
-		body_params = ['name', 'url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
-		"""
-		**Return an HTTP server for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'getNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		return self._session.get(metadata, resource)
-
-	def updateNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str, **kwargs):
-		"""
-		**Update an HTTP server**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		- name (string): A name for easy reference to the HTTP server
-		- url (string): The URL of the HTTP server
-		- sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'updateNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		body_params = ['name', 'url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
-		"""
-		**Delete an HTTP server from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-webhooks-http-server
-		
-		- networkId (string): (required)
-		- httpServerId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
-			'operation': 'deleteNetworkWebhooksHttpServer'
-		}
-		resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
-
-		return self._session.delete(metadata, resource)
-
-	def createNetworkWebhooksWebhookTest(self, networkId: str, url: str, **kwargs):
-		"""
-		**Send a test webhook for a network**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-webhook-test
-		
-		- networkId (string): (required)
-		- url (string): The URL where the test webhook will be sent
-		- sharedSecret (string): The shared secret the test webhook will send. Optional. Defaults to an empty string.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
-			'operation': 'createNetworkWebhooksWebhookTest'
-		}
-		resource = f'/networks/{networkId}/webhooks/webhookTests'
-
-		body_params = ['url', 'sharedSecret', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkWebhooksWebhookTest(self, networkId: str, webhookTestId: str):
-		"""
-		**Return the status of a webhook test for a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-webhook-test
-		
-		- networkId (string): (required)
-		- webhookTestId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
-			'operation': 'getNetworkWebhooksWebhookTest'
-		}
-		resource = f'/networks/{networkId}/webhooks/webhookTests/{webhookTestId}'
-
-		return self._session.get(metadata, resource)
+class Networks(object):
+    def __init__(self, session):
+        super(Networks, self).__init__()
+        self._session = session
+        
+
+
+    def getNetwork(self, networkId: str):
+        """
+        **Return a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'getNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetwork(self, networkId: str, **kwargs):
+        """
+        **Update a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network
+
+        - networkId (string): (required)
+        - name (string): The name of the network
+        - timeZone (string): The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
+        - tags (array): A list of tags to be applied to the network
+        - enrollmentString (string): A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
+        - notes (string): Add any notes or additional information about this network here.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'updateNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        body_params = ['name', 'timeZone', 'tags', 'enrollmentString', 'notes', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetwork(self, networkId: str):
+        """
+        **Delete a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'deleteNetwork'
+        }
+        resource = f'/networks/{networkId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkAlertsSettings(self, networkId: str):
+        """
+        **Return the alert configuration for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-alerts-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'alerts', 'settings'],
+            'operation': 'getNetworkAlertsSettings'
+        }
+        resource = f'/networks/{networkId}/alerts/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkAlertsSettings(self, networkId: str, **kwargs):
+        """
+        **Update the alert configuration for this network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-alerts-settings
+
+        - networkId (string): (required)
+        - defaultDestinations (object): The network-wide destinations for all alerts on the network.
+        - alerts (array): Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'alerts', 'settings'],
+            'operation': 'updateNetworkAlertsSettings'
+        }
+        resource = f'/networks/{networkId}/alerts/settings'
+
+        body_params = ['defaultDestinations', 'alerts', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def bindNetwork(self, networkId: str, configTemplateId: str, **kwargs):
+        """
+        **Bind a network to a template.**
+        https://developer.cisco.com/meraki/api-v1/#!bind-network
+
+        - networkId (string): (required)
+        - configTemplateId (string): The ID of the template to which the network should be bound.
+        - autoBind (boolean): Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'bindNetwork'
+        }
+        resource = f'/networks/{networkId}/bind'
+
+        body_params = ['configTemplateId', 'autoBind', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkBluetoothClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the Bluetooth clients seen by APs in this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-clients
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - includeConnectivityHistory (boolean): Include the connectivity history for this client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'bluetoothClients'],
+            'operation': 'getNetworkBluetoothClients'
+        }
+        resource = f'/networks/{networkId}/bluetoothClients'
+
+        query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', 'includeConnectivityHistory', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkBluetoothClient(self, networkId: str, bluetoothClientId: str, **kwargs):
+        """
+        **Return a Bluetooth client**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-bluetooth-client
+
+        - networkId (string): (required)
+        - bluetoothClientId (string): (required)
+        - includeConnectivityHistory (boolean): Include the connectivity history for this client
+        - connectivityHistoryTimespan (integer): The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'bluetoothClients'],
+            'operation': 'getNetworkBluetoothClient'
+        }
+        resource = f'/networks/{networkId}/bluetoothClients/{bluetoothClientId}'
+
+        query_params = ['includeConnectivityHistory', 'connectivityHistoryTimespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkClients(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the clients that have used this network in the timespan**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients'],
+            'operation': 'getNetworkClients'
+        }
+        resource = f'/networks/{networkId}/clients'
+
+        query_params = ['t0', 'timespan', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClientsApplicationUsage(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the application usage data for clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients-application-usage
+
+        - networkId (string): (required)
+        - clients (string): A list of client keys, MACs or IPs separated by comma.
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - ssidNumber (integer): An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'applicationUsage'],
+            'operation': 'getNetworkClientsApplicationUsage'
+        }
+        resource = f'/networks/{networkId}/clients/applicationUsage'
+
+        query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def provisionNetworkClients(self, networkId: str, clients: list, devicePolicy: str, **kwargs):
+        """
+        **Provisions a client with a name and policy**
+        https://developer.cisco.com/meraki/api-v1/#!provision-network-clients
+
+        - networkId (string): (required)
+        - clients (array): The array of clients to provision
+        - devicePolicy (string): The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
+        - groupPolicyId (string): The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
+        - policiesBySecurityAppliance (object): An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
+        - policiesBySsid (object): An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
+        """
+
+        kwargs.update(locals())
+
+        if 'devicePolicy' in kwargs:
+            options = ['Group policy', 'Allowed', 'Blocked', 'Per connection', 'Normal']
+            assert kwargs['devicePolicy'] in options, f'''"devicePolicy" cannot be "{kwargs['devicePolicy']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients'],
+            'operation': 'provisionNetworkClients'
+        }
+        resource = f'/networks/{networkId}/clients/provision'
+
+        body_params = ['clients', 'devicePolicy', 'groupPolicyId', 'policiesBySecurityAppliance', 'policiesBySsid', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkClientsUsageHistories(self, networkId: str, clients: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the usage histories for clients**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-clients-usage-histories
+
+        - networkId (string): (required)
+        - clients (string): A list of client keys, MACs or IPs separated by comma.
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - ssidNumber (integer): An SSID number to include. If not specified, events for all SSIDs will be returned.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'usageHistories'],
+            'operation': 'getNetworkClientsUsageHistories'
+        }
+        resource = f'/networks/{networkId}/clients/usageHistories'
+
+        query_params = ['clients', 'ssidNumber', 'perPage', 'startingAfter', 'endingBefore', 't0', 't1', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClient(self, networkId: str, clientId: str):
+        """
+        **Return the client associated with the given identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients'],
+            'operation': 'getNetworkClient'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkClientPolicy(self, networkId: str, clientId: str):
+        """
+        **Return the policy assigned to a client on the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-policy
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'policy'],
+            'operation': 'getNetworkClientPolicy'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/policy'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkClientPolicy(self, networkId: str, clientId: str, devicePolicy: str, **kwargs):
+        """
+        **Update the policy assigned to a client on the network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-client-policy
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - devicePolicy (string): The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
+        - groupPolicyId (string): [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'policy'],
+            'operation': 'updateNetworkClientPolicy'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/policy'
+
+        body_params = ['devicePolicy', 'groupPolicyId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str):
+        """
+        **Return the splash authorization for a client, for each SSID they've associated with through splash**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-splash-authorization-status
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
+            'operation': 'getNetworkClientSplashAuthorizationStatus'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkClientSplashAuthorizationStatus(self, networkId: str, clientId: str, ssids: dict):
+        """
+        **Update a client's splash authorization**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-client-splash-authorization-status
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - ssids (object): The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'clients', 'splashAuthorizationStatus'],
+            'operation': 'updateNetworkClientSplashAuthorizationStatus'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus'
+
+        body_params = ['ssids', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkClientTrafficHistory(self, networkId: str, clientId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return the client's network traffic data over time**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-traffic-history
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'trafficHistory'],
+            'operation': 'getNetworkClientTrafficHistory'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/trafficHistory'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkClientUsageHistory(self, networkId: str, clientId: str):
+        """
+        **Return the client's daily usage history**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-client-usage-history
+
+        - networkId (string): (required)
+        - clientId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'clients', 'usageHistory'],
+            'operation': 'getNetworkClientUsageHistory'
+        }
+        resource = f'/networks/{networkId}/clients/{clientId}/usageHistory'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkDevices(self, networkId: str):
+        """
+        **List the devices in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-devices
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'getNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def claimNetworkDevices(self, networkId: str, serials: list):
+        """
+        **Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)**
+        https://developer.cisco.com/meraki/api-v1/#!claim-network-devices
+
+        - networkId (string): (required)
+        - serials (array): A list of serials of devices to claim
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'claimNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices/claim'
+
+        body_params = ['serials', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def removeNetworkDevices(self, networkId: str, serial: str):
+        """
+        **Remove a single device**
+        https://developer.cisco.com/meraki/api-v1/#!remove-network-devices
+
+        - networkId (string): (required)
+        - serial (string): The serial of a device
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'devices'],
+            'operation': 'removeNetworkDevices'
+        }
+        resource = f'/networks/{networkId}/devices/remove'
+
+        body_params = ['serial', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkEvents(self, networkId: str, total_pages=1, direction='prev', event_log_end_time=None, **kwargs):
+        """
+        **List the events for the network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-events
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" or "prev" (default) page
+        - event_log_end_time (string): ISO8601 Zulu/UTC time, to use in conjunction with startingAfter, to retrieve events within a time window
+        - productType (string): The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental
+        - includedEventTypes (array): A list of event types. The returned events will be filtered to only include events with these types.
+        - excludedEventTypes (array): A list of event types. The returned events will be filtered to exclude events with these types.
+        - deviceMac (string): The MAC address of the Meraki device which the list of events will be filtered with
+        - deviceSerial (string): The serial of the Meraki device which the list of events will be filtered with
+        - deviceName (string): The name of the Meraki device which the list of events will be filtered with
+        - clientIp (string): The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.
+        - clientMac (string): The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.
+        - clientName (string): The name, or partial name, of the client which the list of events will be filtered with
+        - smDeviceMac (string): The MAC address of the Systems Manager device which the list of events will be filtered with
+        - smDeviceName (string): The name of the Systems Manager device which the list of events will be filtered with
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'events'],
+            'operation': 'getNetworkEvents'
+        }
+        resource = f'/networks/{networkId}/events'
+
+        query_params = ['productType', 'includedEventTypes', 'excludedEventTypes', 'deviceMac', 'deviceSerial', 'deviceName', 'clientIp', 'clientMac', 'clientName', 'smDeviceMac', 'smDeviceName', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['includedEventTypes', 'excludedEventTypes', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction, event_log_end_time)
+        
+
+
+    def getNetworkEventsEventTypes(self, networkId: str):
+        """
+        **List the event type to human-readable description**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-events-event-types
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'events', 'eventTypes'],
+            'operation': 'getNetworkEventsEventTypes'
+        }
+        resource = f'/networks/{networkId}/events/eventTypes'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkFirmwareUpgrades(self, networkId: str):
+        """
+        **Get firmware upgrade information for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-firmware-upgrades
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades'],
+            'operation': 'getNetworkFirmwareUpgrades'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkFirmwareUpgrades(self, networkId: str, **kwargs):
+        """
+        **Update firmware upgrade information for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-firmware-upgrades
+
+        - networkId (string): (required)
+        - upgradeWindow (object): Upgrade window for devices in network
+        - timezone (string): The timezone for the network
+        - products (object): Contains information about the network to update
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades'],
+            'operation': 'updateNetworkFirmwareUpgrades'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades'
+
+        body_params = ['upgradeWindow', 'timezone', 'products', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def createNetworkFirmwareUpgradesRollback(self, networkId: str, reasons: list, **kwargs):
+        """
+        **Rollback a Firmware Upgrade For A Network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-firmware-upgrades-rollback
+
+        - networkId (string): (required)
+        - reasons (array): Reasons for the rollback
+        - product (string): Product type to rollback (if the network is a combined network)
+        - time (string): Scheduled time for the rollback
+        - toVersion (object): Version to downgrade to (if the network has firmware flexibility)
+        """
+
+        kwargs.update(locals())
+
+        if 'product' in kwargs:
+            options = ['wireless', 'switch', 'appliance', 'camera', 'vmxHost', 'cellularGateway']
+            assert kwargs['product'] in options, f'''"product" cannot be "{kwargs['product']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'firmwareUpgrades', 'rollbacks'],
+            'operation': 'createNetworkFirmwareUpgradesRollback'
+        }
+        resource = f'/networks/{networkId}/firmwareUpgrades/rollbacks'
+
+        body_params = ['product', 'time', 'reasons', 'toVersion', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkFloorPlans(self, networkId: str):
+        """
+        **List the floor plans that belong to your network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plans
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'getNetworkFloorPlans'
+        }
+        resource = f'/networks/{networkId}/floorPlans'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkFloorPlan(self, networkId: str, name: str, imageContents: str, **kwargs):
+        """
+        **Upload a floor plan**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-floor-plan
+
+        - networkId (string): (required)
+        - name (string): The name of your floor plan.
+        - imageContents (string): The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
+        - center (object): The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
+        - bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
+        - bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
+        - topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
+        - topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'createNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans'
+
+        body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkFloorPlan(self, networkId: str, floorPlanId: str):
+        """
+        **Find a floor plan by ID**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'getNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkFloorPlan(self, networkId: str, floorPlanId: str, **kwargs):
+        """
+        **Update a floor plan's geolocation and other meta data**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        - name (string): The name of your floor plan.
+        - center (object): The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
+        - bottomLeftCorner (object): The longitude and latitude of the bottom left corner of your floor plan.
+        - bottomRightCorner (object): The longitude and latitude of the bottom right corner of your floor plan.
+        - topLeftCorner (object): The longitude and latitude of the top left corner of your floor plan.
+        - topRightCorner (object): The longitude and latitude of the top right corner of your floor plan.
+        - imageContents (string): The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'updateNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        body_params = ['name', 'center', 'bottomLeftCorner', 'bottomRightCorner', 'topLeftCorner', 'topRightCorner', 'imageContents', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkFloorPlan(self, networkId: str, floorPlanId: str):
+        """
+        **Destroy a floor plan**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-floor-plan
+
+        - networkId (string): (required)
+        - floorPlanId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'floorPlans'],
+            'operation': 'deleteNetworkFloorPlan'
+        }
+        resource = f'/networks/{networkId}/floorPlans/{floorPlanId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkGroupPolicies(self, networkId: str):
+        """
+        **List the group policies in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-group-policies
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'getNetworkGroupPolicies'
+        }
+        resource = f'/networks/{networkId}/groupPolicies'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkGroupPolicy(self, networkId: str, name: str, **kwargs):
+        """
+        **Create a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-group-policy
+
+        - networkId (string): (required)
+        - name (string): The name for your group policy. Required.
+        - scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
+
+        - bandwidth (object):     The bandwidth settings for clients bound to your group policy.
+
+        - firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
+
+        - contentFiltering (object): The content filtering settings for your group policy
+        - splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
+        - vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
+        - bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
+        """
+
+        kwargs.update(locals())
+
+        if 'splashAuthSettings' in kwargs:
+            options = ['network default', 'bypass']
+            assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'createNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies'
+
+        body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
+        """
+        **Display a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'getNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkGroupPolicy(self, networkId: str, groupPolicyId: str, **kwargs):
+        """
+        **Update a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        - name (string): The name for your group policy.
+        - scheduling (object):     The schedule for the group policy. Schedules are applied to days of the week.
+
+        - bandwidth (object):     The bandwidth settings for clients bound to your group policy.
+
+        - firewallAndTrafficShaping (object):     The firewall and traffic shaping rules and settings for your policy.
+
+        - contentFiltering (object): The content filtering settings for your group policy
+        - splashAuthSettings (string): Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
+        - vlanTagging (object): The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
+        - bonjourForwarding (object): The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
+        """
+
+        kwargs.update(locals())
+
+        if 'splashAuthSettings' in kwargs:
+            options = ['network default', 'bypass']
+            assert kwargs['splashAuthSettings'] in options, f'''"splashAuthSettings" cannot be "{kwargs['splashAuthSettings']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'updateNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        body_params = ['name', 'scheduling', 'bandwidth', 'firewallAndTrafficShaping', 'contentFiltering', 'splashAuthSettings', 'vlanTagging', 'bonjourForwarding', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkGroupPolicy(self, networkId: str, groupPolicyId: str):
+        """
+        **Delete a group policy**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-group-policy
+
+        - networkId (string): (required)
+        - groupPolicyId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'groupPolicies'],
+            'operation': 'deleteNetworkGroupPolicy'
+        }
+        resource = f'/networks/{networkId}/groupPolicies/{groupPolicyId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkMerakiAuthUsers(self, networkId: str):
+        """
+        **List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-users
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'getNetworkMerakiAuthUsers'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkMerakiAuthUser(self, networkId: str, email: str, name: str, password: str, authorizations: list, **kwargs):
+        """
+        **Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - email (string): Email address of the user
+        - name (string): Name of the user
+        - password (string): The password for this user account
+        - authorizations (array): Authorization zones and expiration dates for the user.
+        - accountType (string): Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'.
+        - emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
+        """
+
+        kwargs.update(locals())
+
+        if 'accountType' in kwargs:
+            options = ['Guest', '802.1X', 'Client VPN']
+            assert kwargs['accountType'] in options, f'''"accountType" cannot be "{kwargs['accountType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'createNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers'
+
+        body_params = ['email', 'name', 'password', 'accountType', 'emailPasswordToUser', 'authorizations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
+        """
+        **Return the Meraki Auth splash guest, RADIUS, or client VPN user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'getNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def deleteNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str):
+        """
+        **Deauthorize a user**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'deleteNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def updateNetworkMerakiAuthUser(self, networkId: str, merakiAuthUserId: str, **kwargs):
+        """
+        **Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-meraki-auth-user
+
+        - networkId (string): (required)
+        - merakiAuthUserId (string): (required)
+        - name (string): Name of the user
+        - password (string): The password for this user account
+        - emailPasswordToUser (boolean): Whether or not Meraki should email the password to user. Default is false.
+        - authorizations (array): Authorization zones and expiration dates for the user.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'merakiAuthUsers'],
+            'operation': 'updateNetworkMerakiAuthUser'
+        }
+        resource = f'/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}'
+
+        body_params = ['name', 'password', 'emailPasswordToUser', 'authorizations', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkMqttBrokers(self, networkId: str):
+        """
+        **List the MQTT brokers for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-brokers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'getNetworkMqttBrokers'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkMqttBroker(self, networkId: str, name: str, host: str, port: int):
+        """
+        **Add an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-mqtt-broker
+
+        - networkId (string): (required)
+        - name (string): Name of the MQTT broker
+        - host (string): Host name/IP address where MQTT broker runs
+        - port (integer): Host port though which MQTT broker can be reached
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'createNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers'
+
+        body_params = ['name', 'host', 'port', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
+        """
+        **Return an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'getNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkMqttBroker(self, networkId: str, mqttBrokerId: str, **kwargs):
+        """
+        **Update an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        - name (string): Name of the mqtt config
+        - host (string): Host name where mqtt broker runs
+        - port (integer): Host port though which mqtt broker can be reached
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'updateNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        body_params = ['name', 'host', 'port', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkMqttBroker(self, networkId: str, mqttBrokerId: str):
+        """
+        **Delete an MQTT broker**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-mqtt-broker
+
+        - networkId (string): (required)
+        - mqttBrokerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'mqttBrokers'],
+            'operation': 'deleteNetworkMqttBroker'
+        }
+        resource = f'/networks/{networkId}/mqttBrokers/{mqttBrokerId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkNetflow(self, networkId: str):
+        """
+        **Return the NetFlow traffic reporting settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-netflow
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'netflow'],
+            'operation': 'getNetworkNetflow'
+        }
+        resource = f'/networks/{networkId}/netflow'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkNetflow(self, networkId: str, **kwargs):
+        """
+        **Update the NetFlow traffic reporting settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-netflow
+
+        - networkId (string): (required)
+        - reportingEnabled (boolean): Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
+        - collectorIp (string): The IPv4 address of the NetFlow collector.
+        - collectorPort (integer): The port that the NetFlow collector will be listening on.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'netflow'],
+            'operation': 'updateNetworkNetflow'
+        }
+        resource = f'/networks/{networkId}/netflow'
+
+        body_params = ['reportingEnabled', 'collectorIp', 'collectorPort', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkNetworkHealthChannelUtilization(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Get the channel utilization over each radio for all APs in a network.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-network-health-channel-utilization
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
+        - t1 (string): The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
+        - resolution (integer): The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'networkHealth', 'channelUtilization'],
+            'operation': 'getNetworkNetworkHealthChannelUtilization'
+        }
+        resource = f'/networks/{networkId}/networkHealth/channelUtilization'
+
+        query_params = ['t0', 't1', 'timespan', 'resolution', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkPiiPiiKeys(self, networkId: str, **kwargs):
+        """
+        **List the keys required to access Personally Identifiable Information (PII) for a given identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-pii-keys
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'piiKeys'],
+            'operation': 'getNetworkPiiPiiKeys'
+        }
+        resource = f'/networks/{networkId}/pii/piiKeys'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkPiiRequests(self, networkId: str):
+        """
+        **List the PII requests for this network or organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-requests
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'getNetworkPiiRequests'
+        }
+        resource = f'/networks/{networkId}/pii/requests'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkPiiRequest(self, networkId: str, **kwargs):
+        """
+        **Submit a new delete or restrict processing PII request**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-pii-request
+
+        - networkId (string): (required)
+        - type (string): One of "delete" or "restrict processing"
+        - datasets (array): The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
+        - username (string): The username of a network log in. Only applies to "delete" requests.
+        - email (string): The email of a network user account. Only applies to "delete" requests.
+        - mac (string): The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
+        - smDeviceId (string): The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
+        - smUserId (string): The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
+        """
+
+        kwargs.update(locals())
+
+        if 'type' in kwargs:
+            options = ['delete', 'restrict processing']
+            assert kwargs['type'] in options, f'''"type" cannot be "{kwargs['type']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'createNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests'
+
+        body_params = ['type', 'datasets', 'username', 'email', 'mac', 'smDeviceId', 'smUserId', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkPiiRequest(self, networkId: str, requestId: str):
+        """
+        **Return a PII request**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-request
+
+        - networkId (string): (required)
+        - requestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'getNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests/{requestId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def deleteNetworkPiiRequest(self, networkId: str, requestId: str):
+        """
+        **Delete a restrict processing PII request**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-pii-request
+
+        - networkId (string): (required)
+        - requestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'requests'],
+            'operation': 'deleteNetworkPiiRequest'
+        }
+        resource = f'/networks/{networkId}/pii/requests/{requestId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkPiiSmDevicesForKey(self, networkId: str, **kwargs):
+        """
+        **Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-devices-for-key
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'smDevicesForKey'],
+            'operation': 'getNetworkPiiSmDevicesForKey'
+        }
+        resource = f'/networks/{networkId}/pii/smDevicesForKey'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkPiiSmOwnersForKey(self, networkId: str, **kwargs):
+        """
+        **Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-pii-sm-owners-for-key
+
+        - networkId (string): (required)
+        - username (string): The username of a Systems Manager user
+        - email (string): The email of a network user account or a Systems Manager device
+        - mac (string): The MAC of a network client device or a Systems Manager device
+        - serial (string): The serial of a Systems Manager device
+        - imei (string): The IMEI of a Systems Manager device
+        - bluetoothMac (string): The MAC of a Bluetooth client
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'pii', 'smOwnersForKey'],
+            'operation': 'getNetworkPiiSmOwnersForKey'
+        }
+        resource = f'/networks/{networkId}/pii/smOwnersForKey'
+
+        query_params = ['username', 'email', 'mac', 'serial', 'imei', 'bluetoothMac', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkSettings(self, networkId: str):
+        """
+        **Return the settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-settings
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'settings'],
+            'operation': 'getNetworkSettings'
+        }
+        resource = f'/networks/{networkId}/settings'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSettings(self, networkId: str, **kwargs):
+        """
+        **Update the settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-settings
+
+        - networkId (string): (required)
+        - localStatusPageEnabled (boolean): Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
+        - remoteStatusPageEnabled (boolean): Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
+        - secureConnect (object): A hash of SecureConnect options applied to the Network.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'settings'],
+            'operation': 'updateNetworkSettings'
+        }
+        resource = f'/networks/{networkId}/settings'
+
+        body_params = ['localStatusPageEnabled', 'remoteStatusPageEnabled', 'secureConnect', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkSnmp(self, networkId: str):
+        """
+        **Return the SNMP settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-snmp
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'snmp'],
+            'operation': 'getNetworkSnmp'
+        }
+        resource = f'/networks/{networkId}/snmp'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSnmp(self, networkId: str, **kwargs):
+        """
+        **Update the SNMP settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-snmp
+
+        - networkId (string): (required)
+        - access (string): The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
+        - communityString (string): The SNMP community string. Only relevant if 'access' is set to 'community'.
+        - users (array): The list of SNMP users. Only relevant if 'access' is set to 'users'.
+        """
+
+        kwargs.update(locals())
+
+        if 'access' in kwargs:
+            options = ['none', 'community', 'users']
+            assert kwargs['access'] in options, f'''"access" cannot be "{kwargs['access']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'snmp'],
+            'operation': 'updateNetworkSnmp'
+        }
+        resource = f'/networks/{networkId}/snmp'
+
+        body_params = ['access', 'communityString', 'users', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkSplashLoginAttempts(self, networkId: str, **kwargs):
+        """
+        **List the splash login attempts for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-splash-login-attempts
+
+        - networkId (string): (required)
+        - ssidNumber (integer): Only return the login attempts for the specified SSID
+        - loginIdentifier (string): The username, email, or phone number used during login
+        - timespan (integer): The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months
+        """
+
+        kwargs.update(locals())
+
+        if 'ssidNumber' in kwargs:
+            options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
+            assert kwargs['ssidNumber'] in options, f'''"ssidNumber" cannot be "{kwargs['ssidNumber']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'splashLoginAttempts'],
+            'operation': 'getNetworkSplashLoginAttempts'
+        }
+        resource = f'/networks/{networkId}/splashLoginAttempts'
+
+        query_params = ['ssidNumber', 'loginIdentifier', 'timespan', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def splitNetwork(self, networkId: str):
+        """
+        **Split a combined network into individual networks for each type of device**
+        https://developer.cisco.com/meraki/api-v1/#!split-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'splitNetwork'
+        }
+        resource = f'/networks/{networkId}/split'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSyslogServers(self, networkId: str):
+        """
+        **List the syslog servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-syslog-servers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'syslogServers'],
+            'operation': 'getNetworkSyslogServers'
+        }
+        resource = f'/networks/{networkId}/syslogServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkSyslogServers(self, networkId: str, servers: list):
+        """
+        **Update the syslog servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-syslog-servers
+
+        - networkId (string): (required)
+        - servers (array): A list of the syslog servers for this network
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['networks', 'configure', 'syslogServers'],
+            'operation': 'updateNetworkSyslogServers'
+        }
+        resource = f'/networks/{networkId}/syslogServers'
+
+        body_params = ['servers', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkTraffic(self, networkId: str, **kwargs):
+        """
+        **Return the traffic analysis data for this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic
+
+        - networkId (string): (required)
+        - t0 (string): The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
+        - timespan (number): The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.
+        - deviceType (string): Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.
+        """
+
+        kwargs.update(locals())
+
+        if 'deviceType' in kwargs:
+            options = ['combined', 'wireless', 'switch', 'appliance']
+            assert kwargs['deviceType'] in options, f'''"deviceType" cannot be "{kwargs['deviceType']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'monitor', 'traffic'],
+            'operation': 'getNetworkTraffic'
+        }
+        resource = f'/networks/{networkId}/traffic'
+
+        query_params = ['t0', 'timespan', 'deviceType', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkTrafficAnalysis(self, networkId: str):
+        """
+        **Return the traffic analysis settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-analysis
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficAnalysis'],
+            'operation': 'getNetworkTrafficAnalysis'
+        }
+        resource = f'/networks/{networkId}/trafficAnalysis'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkTrafficAnalysis(self, networkId: str, **kwargs):
+        """
+        **Update the traffic analysis settings for a network**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-traffic-analysis
+
+        - networkId (string): (required)
+        - mode (string):     The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
+    'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
+
+        - customPieChartItems (array): The list of items that make up the custom pie chart for traffic reporting.
+        """
+
+        kwargs.update(locals())
+
+        if 'mode' in kwargs:
+            options = ['disabled', 'basic', 'detailed']
+            assert kwargs['mode'] in options, f'''"mode" cannot be "{kwargs['mode']}", & must be set to one of: {options}'''
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficAnalysis'],
+            'operation': 'updateNetworkTrafficAnalysis'
+        }
+        resource = f'/networks/{networkId}/trafficAnalysis'
+
+        body_params = ['mode', 'customPieChartItems', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def getNetworkTrafficShapingApplicationCategories(self, networkId: str):
+        """
+        **Returns the application categories for traffic shaping rules.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-application-categories
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficShaping', 'applicationCategories'],
+            'operation': 'getNetworkTrafficShapingApplicationCategories'
+        }
+        resource = f'/networks/{networkId}/trafficShaping/applicationCategories'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkTrafficShapingDscpTaggingOptions(self, networkId: str):
+        """
+        **Returns the available DSCP tagging options for your traffic shaping rules.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-traffic-shaping-dscp-tagging-options
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'trafficShaping', 'dscpTaggingOptions'],
+            'operation': 'getNetworkTrafficShapingDscpTaggingOptions'
+        }
+        resource = f'/networks/{networkId}/trafficShaping/dscpTaggingOptions'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def unbindNetwork(self, networkId: str):
+        """
+        **Unbind a network from a template.**
+        https://developer.cisco.com/meraki/api-v1/#!unbind-network
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure'],
+            'operation': 'unbindNetwork'
+        }
+        resource = f'/networks/{networkId}/unbind'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkWebhooksHttpServers(self, networkId: str):
+        """
+        **List the HTTP servers for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-servers
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'getNetworkWebhooksHttpServers'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def createNetworkWebhooksHttpServer(self, networkId: str, name: str, url: str, **kwargs):
+        """
+        **Add an HTTP server to a network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - name (string): A name for easy reference to the HTTP server
+        - url (string): The URL of the HTTP server
+        - sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'createNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers'
+
+        body_params = ['name', 'url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
+        """
+        **Return an HTTP server for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'getNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def updateNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str, **kwargs):
+        """
+        **Update an HTTP server**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        - name (string): A name for easy reference to the HTTP server
+        - url (string): The URL of the HTTP server
+        - sharedSecret (string): A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'updateNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        body_params = ['name', 'url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkWebhooksHttpServer(self, networkId: str, httpServerId: str):
+        """
+        **Delete an HTTP server from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-webhooks-http-server
+
+        - networkId (string): (required)
+        - httpServerId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'httpServers'],
+            'operation': 'deleteNetworkWebhooksHttpServer'
+        }
+        resource = f'/networks/{networkId}/webhooks/httpServers/{httpServerId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def createNetworkWebhooksWebhookTest(self, networkId: str, url: str, **kwargs):
+        """
+        **Send a test webhook for a network**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-webhook-test
+
+        - networkId (string): (required)
+        - url (string): The URL where the test webhook will be sent
+        - sharedSecret (string): The shared secret the test webhook will send. Optional. Defaults to an empty string.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
+            'operation': 'createNetworkWebhooksWebhookTest'
+        }
+        resource = f'/networks/{networkId}/webhooks/webhookTests'
+
+        body_params = ['url', 'sharedSecret', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkWebhooksWebhookTest(self, networkId: str, webhookTestId: str):
+        """
+        **Return the status of a webhook test for a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-webhooks-webhook-test
+
+        - networkId (string): (required)
+        - webhookTestId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['networks', 'configure', 'webhooks', 'webhookTests'],
+            'operation': 'getNetworkWebhooksWebhookTest'
+        }
+        resource = f'/networks/{networkId}/webhooks/webhookTests/{webhookTestId}'
+
+        return self._session.get(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/api/sm.py` & `meraki-1.7.2/meraki/api/sm.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,800 +1,875 @@
-class Sm(object):
-	def __init__(self, session):
-		super(Sm, self).__init__()
-		self._session = session
-
-	def createNetworkSmBypassActivationLockAttempt(self, networkId: str, ids: list):
-		"""
-		**Bypass activation lock attempt**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-sm-bypass-activation-lock-attempt
-		
-		- networkId (string): (required)
-		- ids (array): The ids of the devices to attempt activation lock bypass.
-		"""
-
-		kwargs = locals()
-
-		metadata = {
-			'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
-			'operation': 'createNetworkSmBypassActivationLockAttempt'
-		}
-		resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts'
-
-		body_params = ['ids', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmBypassActivationLockAttempt(self, networkId: str, attemptId: str):
-		"""
-		**Bypass activation lock attempt status**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-bypass-activation-lock-attempt
-		
-		- networkId (string): (required)
-		- attemptId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
-			'operation': 'getNetworkSmBypassActivationLockAttempt'
-		}
-		resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List the devices enrolled in an SM network with various specified fields and filters**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-devices
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- fields (array): Additional fields that will be displayed for each device.
-    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
-    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
-    ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
-    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
-    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
-    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion.
-		- wifiMacs (array): Filter devices by wifi mac(s).
-		- serials (array): Filter devices by serial(s).
-		- ids (array): Filter devices by id(s).
-		- scope (array): Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'getNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices'
-
-		query_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', 'perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def checkinNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Force check-in a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!checkin-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMacs (array): The wifiMacs of the devices to be checked-in.
-		- ids (array): The ids of the devices to be checked-in.
-		- serials (array): The serials of the devices to be checked-in.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'checkinNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/checkin'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def updateNetworkSmDevicesFields(self, networkId: str, deviceFields: dict, **kwargs):
-		"""
-		**Modify the fields of a device**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-sm-devices-fields
-		
-		- networkId (string): (required)
-		- deviceFields (object): The new fields of the device. Each field of this object is optional.
-		- wifiMac (string): The wifiMac of the device to be modified.
-		- id (string): The id of the device to be modified.
-		- serial (string): The serial of the device to be modified.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'fields'],
-			'operation': 'updateNetworkSmDevicesFields'
-		}
-		resource = f'/networks/{networkId}/sm/devices/fields'
-
-		body_params = ['wifiMac', 'id', 'serial', 'deviceFields', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def lockNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Lock a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!lock-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMacs (array): The wifiMacs of the devices to be locked.
-		- ids (array): The ids of the devices to be locked.
-		- serials (array): The serials of the devices to be locked.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
-		- pin (integer): The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'lockNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/lock'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'pin', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def modifyNetworkSmDevicesTags(self, networkId: str, tags: list, updateAction: str, **kwargs):
-		"""
-		**Add, delete, or update the tags of a set of devices**
-		https://developer.cisco.com/meraki/api-v1/#!modify-network-sm-devices-tags
-		
-		- networkId (string): (required)
-		- tags (array): The tags to be added, deleted, or updated.
-		- updateAction (string): One of add, delete, or update. Only devices that have been modified will be returned.
-		- wifiMacs (array): The wifiMacs of the devices to be modified.
-		- ids (array): The ids of the devices to be modified.
-		- serials (array): The serials of the devices to be modified.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'modifyNetworkSmDevicesTags'
-		}
-		resource = f'/networks/{networkId}/sm/devices/modifyTags'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'tags', 'updateAction', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def moveNetworkSmDevices(self, networkId: str, newNetwork: str, **kwargs):
-		"""
-		**Move a set of devices to a new network**
-		https://developer.cisco.com/meraki/api-v1/#!move-network-sm-devices
-		
-		- networkId (string): (required)
-		- newNetwork (string): The new network to which the devices will be moved.
-		- wifiMacs (array): The wifiMacs of the devices to be moved.
-		- ids (array): The ids of the devices to be moved.
-		- serials (array): The serials of the devices to be moved.
-		- scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'moveNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/move'
-
-		body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'newNetwork', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def wipeNetworkSmDevices(self, networkId: str, **kwargs):
-		"""
-		**Wipe a device**
-		https://developer.cisco.com/meraki/api-v1/#!wipe-network-sm-devices
-		
-		- networkId (string): (required)
-		- wifiMac (string): The wifiMac of the device to be wiped.
-		- id (string): The id of the device to be wiped.
-		- serial (string): The serial of the device to be wiped.
-		- pin (integer): The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'wipeNetworkSmDevices'
-		}
-		resource = f'/networks/{networkId}/sm/devices/wipe'
-
-		body_params = ['wifiMac', 'id', 'serial', 'pin', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmDeviceCellularUsageHistory(self, networkId: str, deviceId: str):
-		"""
-		**Return the client's daily cellular data usage history**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-cellular-usage-history
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'cellularUsageHistory'],
-			'operation': 'getNetworkSmDeviceCellularUsageHistory'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceCerts(self, networkId: str, deviceId: str):
-		"""
-		**List the certs on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-certs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'certs'],
-			'operation': 'getNetworkSmDeviceCerts'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/certs'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceConnectivity(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Returns historical connectivity data (whether a device is regularly checking in to Dashboard).**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-connectivity
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'connectivity'],
-			'operation': 'getNetworkSmDeviceConnectivity'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/connectivity'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDesktopLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of various Systems Manager network connection details for desktop devices.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-desktop-logs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'desktopLogs'],
-			'operation': 'getNetworkSmDeviceDesktopLogs'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/desktopLogs'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDeviceCommandLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of commands sent to Systems Manager devices**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-command-logs
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'deviceCommandLogs'],
-			'operation': 'getNetworkSmDeviceDeviceCommandLogs'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def getNetworkSmDeviceDeviceProfiles(self, networkId: str, deviceId: str):
-		"""
-		**Get the profiles associated with a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-profiles
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'deviceProfiles'],
-			'operation': 'getNetworkSmDeviceDeviceProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceNetworkAdapters(self, networkId: str, deviceId: str):
-		"""
-		**List the network adapters of a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-network-adapters
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'networkAdapters'],
-			'operation': 'getNetworkSmDeviceNetworkAdapters'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/networkAdapters'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDevicePerformanceHistory(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**Return historical records of various Systems Manager client metrics for desktop devices.**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-performance-history
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'monitor', 'devices', 'performanceHistory'],
-			'operation': 'getNetworkSmDevicePerformanceHistory'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/performanceHistory'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def refreshNetworkSmDeviceDetails(self, networkId: str, deviceId: str):
-		"""
-		**Refresh the details of a device**
-		https://developer.cisco.com/meraki/api-v1/#!refresh-network-sm-device-details
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'refreshNetworkSmDeviceDetails'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/refreshDetails'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSmDeviceRestrictions(self, networkId: str, deviceId: str):
-		"""
-		**List the restrictions on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-restrictions
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'restrictions'],
-			'operation': 'getNetworkSmDeviceRestrictions'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/restrictions'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceSecurityCenters(self, networkId: str, deviceId: str):
-		"""
-		**List the security centers on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-security-centers
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'securityCenters'],
-			'operation': 'getNetworkSmDeviceSecurityCenters'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/securityCenters'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmDeviceSoftwares(self, networkId: str, deviceId: str):
-		"""
-		**Get a list of softwares associated with a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-softwares
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'softwares'],
-			'operation': 'getNetworkSmDeviceSoftwares'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/softwares'
-
-		return self._session.get(metadata, resource)
-
-	def unenrollNetworkSmDevice(self, networkId: str, deviceId: str):
-		"""
-		**Unenroll a device**
-		https://developer.cisco.com/meraki/api-v1/#!unenroll-network-sm-device
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices'],
-			'operation': 'unenrollNetworkSmDevice'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/unenroll'
-
-		return self._session.post(metadata, resource)
-
-	def getNetworkSmDeviceWlanLists(self, networkId: str, deviceId: str):
-		"""
-		**List the saved SSID names on a device**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-wlan-lists
-		
-		- networkId (string): (required)
-		- deviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'devices', 'wlanLists'],
-			'operation': 'getNetworkSmDeviceWlanLists'
-		}
-		resource = f'/networks/{networkId}/sm/devices/{deviceId}/wlanLists'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmProfiles(self, networkId: str):
-		"""
-		**List all profiles in a network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-profiles
-		
-		- networkId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'profiles'],
-			'operation': 'getNetworkSmProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/profiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmTargetGroups(self, networkId: str, **kwargs):
-		"""
-		**List the target groups in this network**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-groups
-		
-		- networkId (string): (required)
-		- withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'getNetworkSmTargetGroups'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups'
-
-		query_params = ['withDetails', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def createNetworkSmTargetGroup(self, networkId: str, **kwargs):
-		"""
-		**Add a target group**
-		https://developer.cisco.com/meraki/api-v1/#!create-network-sm-target-group
-		
-		- networkId (string): (required)
-		- name (string): The name of this target group
-		- scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'createNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups'
-
-		body_params = ['name', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.post(metadata, resource, payload)
-
-	def getNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
-		"""
-		**Return a target group**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		- withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'getNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		query_params = ['withDetails', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get(metadata, resource, params)
-
-	def updateNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
-		"""
-		**Update a target group**
-		https://developer.cisco.com/meraki/api-v1/#!update-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		- name (string): The name of this target group
-		- scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'updateNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		body_params = ['name', 'scope', ]
-		payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
-
-		return self._session.put(metadata, resource, payload)
-
-	def deleteNetworkSmTargetGroup(self, networkId: str, targetGroupId: str):
-		"""
-		**Delete a target group from a network**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-target-group
-		
-		- networkId (string): (required)
-		- targetGroupId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'targetGroups'],
-			'operation': 'deleteNetworkSmTargetGroup'
-		}
-		resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkSmUserAccessDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
-		"""
-		**List User Access Devices and its Trusted Access Connections**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-access-devices
-		
-		- networkId (string): (required)
-		- total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
-		- direction (string): direction to paginate, either "next" (default) or "prev" page
-		- perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
-		- startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		- endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'userAccessDevices'],
-			'operation': 'getNetworkSmUserAccessDevices'
-		}
-		resource = f'/networks/{networkId}/sm/userAccessDevices'
-
-		query_params = ['perPage', 'startingAfter', 'endingBefore', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		return self._session.get_pages(metadata, resource, params, total_pages, direction)
-
-	def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
-		"""
-		**Delete a User Access Device**
-		https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
-		
-		- networkId (string): (required)
-		- userAccessDeviceId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'userAccessDevices'],
-			'operation': 'deleteNetworkSmUserAccessDevice'
-		}
-		resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
-
-		return self._session.delete(metadata, resource)
-
-	def getNetworkSmUsers(self, networkId: str, **kwargs):
-		"""
-		**List the owners in an SM network with various specified fields and filters**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-users
-		
-		- networkId (string): (required)
-		- ids (array): Filter users by id(s).
-		- usernames (array): Filter users by username(s).
-		- emails (array): Filter users by email(s).
-		- scope (array): Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.
-		"""
-
-		kwargs.update(locals())
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users'],
-			'operation': 'getNetworkSmUsers'
-		}
-		resource = f'/networks/{networkId}/sm/users'
-
-		query_params = ['ids', 'usernames', 'emails', 'scope', ]
-		params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
-
-		array_params = ['ids', 'usernames', 'emails', 'scope', ]
-		for k, v in kwargs.items():
-			if k.strip() in array_params:
-				params[f'{k.strip()}[]'] = kwargs[f'{k}']
-				params.pop(k.strip())
-
-		return self._session.get(metadata, resource, params)
-
-	def getNetworkSmUserDeviceProfiles(self, networkId: str, userId: str):
-		"""
-		**Get the profiles associated with a user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-device-profiles
-		
-		- networkId (string): (required)
-		- userId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users', 'deviceProfiles'],
-			'operation': 'getNetworkSmUserDeviceProfiles'
-		}
-		resource = f'/networks/{networkId}/sm/users/{userId}/deviceProfiles'
-
-		return self._session.get(metadata, resource)
-
-	def getNetworkSmUserSoftwares(self, networkId: str, userId: str):
-		"""
-		**Get a list of softwares associated with a user**
-		https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-softwares
-		
-		- networkId (string): (required)
-		- userId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'users', 'softwares'],
-			'operation': 'getNetworkSmUserSoftwares'
-		}
-		resource = f'/networks/{networkId}/sm/users/{userId}/softwares'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmApnsCert(self, organizationId: str):
-		"""
-		**Get the organization's APNS certificate**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-apns-cert
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'apnsCert'],
-			'operation': 'getOrganizationSmApnsCert'
-		}
-		resource = f'/organizations/{organizationId}/sm/apnsCert'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmVppAccounts(self, organizationId: str):
-		"""
-		**List the VPP accounts in the organization**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-accounts
-		
-		- organizationId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'vppAccounts'],
-			'operation': 'getOrganizationSmVppAccounts'
-		}
-		resource = f'/organizations/{organizationId}/sm/vppAccounts'
-
-		return self._session.get(metadata, resource)
-
-	def getOrganizationSmVppAccount(self, organizationId: str, vppAccountId: str):
-		"""
-		**Get a hash containing the unparsed token of the VPP account with the given ID**
-		https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-account
-		
-		- organizationId (string): (required)
-		- vppAccountId (string): (required)
-		"""
-
-		metadata = {
-			'tags': ['sm', 'configure', 'vppAccounts'],
-			'operation': 'getOrganizationSmVppAccount'
-		}
-		resource = f'/organizations/{organizationId}/sm/vppAccounts/{vppAccountId}'
-
-		return self._session.get(metadata, resource)
+class Sm(object):
+    def __init__(self, session):
+        super(Sm, self).__init__()
+        self._session = session
+        
+
+
+    def createNetworkSmBypassActivationLockAttempt(self, networkId: str, ids: list):
+        """
+        **Bypass activation lock attempt**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-sm-bypass-activation-lock-attempt
+
+        - networkId (string): (required)
+        - ids (array): The ids of the devices to attempt activation lock bypass.
+        """
+
+        kwargs = locals()
+
+        metadata = {
+            'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
+            'operation': 'createNetworkSmBypassActivationLockAttempt'
+        }
+        resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts'
+
+        body_params = ['ids', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmBypassActivationLockAttempt(self, networkId: str, attemptId: str):
+        """
+        **Bypass activation lock attempt status**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-bypass-activation-lock-attempt
+
+        - networkId (string): (required)
+        - attemptId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'bypassActivationLockAttempts'],
+            'operation': 'getNetworkSmBypassActivationLockAttempt'
+        }
+        resource = f'/networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List the devices enrolled in an SM network with various specified fields and filters**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-devices
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - fields (array): Additional fields that will be displayed for each device.
+    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
+    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
+    ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
+    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
+    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
+    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion.
+        - wifiMacs (array): Filter devices by wifi mac(s).
+        - serials (array): Filter devices by serial(s).
+        - ids (array): Filter devices by id(s).
+        - scope (array): Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'getNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices'
+
+        query_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', 'perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['fields', 'wifiMacs', 'serials', 'ids', 'scope', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def checkinNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Force check-in a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!checkin-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMacs (array): The wifiMacs of the devices to be checked-in.
+        - ids (array): The ids of the devices to be checked-in.
+        - serials (array): The serials of the devices to be checked-in.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'checkinNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/checkin'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def updateNetworkSmDevicesFields(self, networkId: str, deviceFields: dict, **kwargs):
+        """
+        **Modify the fields of a device**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-sm-devices-fields
+
+        - networkId (string): (required)
+        - deviceFields (object): The new fields of the device. Each field of this object is optional.
+        - wifiMac (string): The wifiMac of the device to be modified.
+        - id (string): The id of the device to be modified.
+        - serial (string): The serial of the device to be modified.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'fields'],
+            'operation': 'updateNetworkSmDevicesFields'
+        }
+        resource = f'/networks/{networkId}/sm/devices/fields'
+
+        body_params = ['wifiMac', 'id', 'serial', 'deviceFields', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def lockNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Lock a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!lock-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMacs (array): The wifiMacs of the devices to be locked.
+        - ids (array): The ids of the devices to be locked.
+        - serials (array): The serials of the devices to be locked.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
+        - pin (integer): The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'lockNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/lock'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'pin', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def modifyNetworkSmDevicesTags(self, networkId: str, tags: list, updateAction: str, **kwargs):
+        """
+        **Add, delete, or update the tags of a set of devices**
+        https://developer.cisco.com/meraki/api-v1/#!modify-network-sm-devices-tags
+
+        - networkId (string): (required)
+        - tags (array): The tags to be added, deleted, or updated.
+        - updateAction (string): One of add, delete, or update. Only devices that have been modified will be returned.
+        - wifiMacs (array): The wifiMacs of the devices to be modified.
+        - ids (array): The ids of the devices to be modified.
+        - serials (array): The serials of the devices to be modified.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'modifyNetworkSmDevicesTags'
+        }
+        resource = f'/networks/{networkId}/sm/devices/modifyTags'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'tags', 'updateAction', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def moveNetworkSmDevices(self, networkId: str, newNetwork: str, **kwargs):
+        """
+        **Move a set of devices to a new network**
+        https://developer.cisco.com/meraki/api-v1/#!move-network-sm-devices
+
+        - networkId (string): (required)
+        - newNetwork (string): The new network to which the devices will be moved.
+        - wifiMacs (array): The wifiMacs of the devices to be moved.
+        - ids (array): The ids of the devices to be moved.
+        - serials (array): The serials of the devices to be moved.
+        - scope (array): The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'moveNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/move'
+
+        body_params = ['wifiMacs', 'ids', 'serials', 'scope', 'newNetwork', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def wipeNetworkSmDevices(self, networkId: str, **kwargs):
+        """
+        **Wipe a device**
+        https://developer.cisco.com/meraki/api-v1/#!wipe-network-sm-devices
+
+        - networkId (string): (required)
+        - wifiMac (string): The wifiMac of the device to be wiped.
+        - id (string): The id of the device to be wiped.
+        - serial (string): The serial of the device to be wiped.
+        - pin (integer): The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'wipeNetworkSmDevices'
+        }
+        resource = f'/networks/{networkId}/sm/devices/wipe'
+
+        body_params = ['wifiMac', 'id', 'serial', 'pin', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmDeviceCellularUsageHistory(self, networkId: str, deviceId: str):
+        """
+        **Return the client's daily cellular data usage history**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-cellular-usage-history
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'cellularUsageHistory'],
+            'operation': 'getNetworkSmDeviceCellularUsageHistory'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceCerts(self, networkId: str, deviceId: str):
+        """
+        **List the certs on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-certs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'certs'],
+            'operation': 'getNetworkSmDeviceCerts'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/certs'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceConnectivity(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Returns historical connectivity data (whether a device is regularly checking in to Dashboard).**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-connectivity
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'connectivity'],
+            'operation': 'getNetworkSmDeviceConnectivity'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/connectivity'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDesktopLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of various Systems Manager network connection details for desktop devices.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-desktop-logs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'desktopLogs'],
+            'operation': 'getNetworkSmDeviceDesktopLogs'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/desktopLogs'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDeviceCommandLogs(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of commands sent to Systems Manager devices**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-command-logs
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'deviceCommandLogs'],
+            'operation': 'getNetworkSmDeviceDeviceCommandLogs'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def getNetworkSmDeviceDeviceProfiles(self, networkId: str, deviceId: str):
+        """
+        **Get the profiles associated with a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-device-profiles
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'deviceProfiles'],
+            'operation': 'getNetworkSmDeviceDeviceProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceNetworkAdapters(self, networkId: str, deviceId: str):
+        """
+        **List the network adapters of a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-network-adapters
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'networkAdapters'],
+            'operation': 'getNetworkSmDeviceNetworkAdapters'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/networkAdapters'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDevicePerformanceHistory(self, networkId: str, deviceId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **Return historical records of various Systems Manager client metrics for desktop devices.**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-performance-history
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'monitor', 'devices', 'performanceHistory'],
+            'operation': 'getNetworkSmDevicePerformanceHistory'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/performanceHistory'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def refreshNetworkSmDeviceDetails(self, networkId: str, deviceId: str):
+        """
+        **Refresh the details of a device**
+        https://developer.cisco.com/meraki/api-v1/#!refresh-network-sm-device-details
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'refreshNetworkSmDeviceDetails'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/refreshDetails'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceRestrictions(self, networkId: str, deviceId: str):
+        """
+        **List the restrictions on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-restrictions
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'restrictions'],
+            'operation': 'getNetworkSmDeviceRestrictions'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/restrictions'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceSecurityCenters(self, networkId: str, deviceId: str):
+        """
+        **List the security centers on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-security-centers
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'securityCenters'],
+            'operation': 'getNetworkSmDeviceSecurityCenters'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/securityCenters'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceSoftwares(self, networkId: str, deviceId: str):
+        """
+        **Get a list of softwares associated with a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-softwares
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'softwares'],
+            'operation': 'getNetworkSmDeviceSoftwares'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/softwares'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def unenrollNetworkSmDevice(self, networkId: str, deviceId: str):
+        """
+        **Unenroll a device**
+        https://developer.cisco.com/meraki/api-v1/#!unenroll-network-sm-device
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices'],
+            'operation': 'unenrollNetworkSmDevice'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/unenroll'
+
+        return self._session.post(metadata, resource)
+        
+
+
+    def getNetworkSmDeviceWlanLists(self, networkId: str, deviceId: str):
+        """
+        **List the saved SSID names on a device**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-device-wlan-lists
+
+        - networkId (string): (required)
+        - deviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'devices', 'wlanLists'],
+            'operation': 'getNetworkSmDeviceWlanLists'
+        }
+        resource = f'/networks/{networkId}/sm/devices/{deviceId}/wlanLists'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmProfiles(self, networkId: str):
+        """
+        **List all profiles in a network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-profiles
+
+        - networkId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'profiles'],
+            'operation': 'getNetworkSmProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/profiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmTargetGroups(self, networkId: str, **kwargs):
+        """
+        **List the target groups in this network**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-groups
+
+        - networkId (string): (required)
+        - withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'getNetworkSmTargetGroups'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups'
+
+        query_params = ['withDetails', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def createNetworkSmTargetGroup(self, networkId: str, **kwargs):
+        """
+        **Add a target group**
+        https://developer.cisco.com/meraki/api-v1/#!create-network-sm-target-group
+
+        - networkId (string): (required)
+        - name (string): The name of this target group
+        - scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'createNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups'
+
+        body_params = ['name', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.post(metadata, resource, payload)
+        
+
+
+    def getNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
+        """
+        **Return a target group**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        - withDetails (boolean): Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'getNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        query_params = ['withDetails', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def updateNetworkSmTargetGroup(self, networkId: str, targetGroupId: str, **kwargs):
+        """
+        **Update a target group**
+        https://developer.cisco.com/meraki/api-v1/#!update-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        - name (string): The name of this target group
+        - scope (string): The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'updateNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        body_params = ['name', 'scope', ]
+        payload = {k.strip(): v for k, v in kwargs.items() if k.strip() in body_params}
+
+        return self._session.put(metadata, resource, payload)
+        
+
+
+    def deleteNetworkSmTargetGroup(self, networkId: str, targetGroupId: str):
+        """
+        **Delete a target group from a network**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-target-group
+
+        - networkId (string): (required)
+        - targetGroupId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'targetGroups'],
+            'operation': 'deleteNetworkSmTargetGroup'
+        }
+        resource = f'/networks/{networkId}/sm/targetGroups/{targetGroupId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkSmUserAccessDevices(self, networkId: str, total_pages=1, direction='next', **kwargs):
+        """
+        **List User Access Devices and its Trusted Access Connections**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-access-devices
+
+        - networkId (string): (required)
+        - total_pages (integer or string): use with perPage to get total results up to total_pages*perPage; -1 or "all" for all pages
+        - direction (string): direction to paginate, either "next" (default) or "prev" page
+        - perPage (integer): The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
+        - startingAfter (string): A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        - endingBefore (string): A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'userAccessDevices'],
+            'operation': 'getNetworkSmUserAccessDevices'
+        }
+        resource = f'/networks/{networkId}/sm/userAccessDevices'
+
+        query_params = ['perPage', 'startingAfter', 'endingBefore', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        return self._session.get_pages(metadata, resource, params, total_pages, direction)
+        
+
+
+    def deleteNetworkSmUserAccessDevice(self, networkId: str, userAccessDeviceId: str):
+        """
+        **Delete a User Access Device**
+        https://developer.cisco.com/meraki/api-v1/#!delete-network-sm-user-access-device
+
+        - networkId (string): (required)
+        - userAccessDeviceId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'userAccessDevices'],
+            'operation': 'deleteNetworkSmUserAccessDevice'
+        }
+        resource = f'/networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}'
+
+        return self._session.delete(metadata, resource)
+        
+
+
+    def getNetworkSmUsers(self, networkId: str, **kwargs):
+        """
+        **List the owners in an SM network with various specified fields and filters**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-users
+
+        - networkId (string): (required)
+        - ids (array): Filter users by id(s).
+        - usernames (array): Filter users by username(s).
+        - emails (array): Filter users by email(s).
+        - scope (array): Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.
+        """
+
+        kwargs.update(locals())
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users'],
+            'operation': 'getNetworkSmUsers'
+        }
+        resource = f'/networks/{networkId}/sm/users'
+
+        query_params = ['ids', 'usernames', 'emails', 'scope', ]
+        params = {k.strip(): v for k, v in kwargs.items() if k.strip() in query_params}
+
+        array_params = ['ids', 'usernames', 'emails', 'scope', ]
+        for k, v in kwargs.items():
+            if k.strip() in array_params:
+                params[f'{k.strip()}[]'] = kwargs[f'{k}']
+                params.pop(k.strip())
+
+        return self._session.get(metadata, resource, params)
+        
+
+
+    def getNetworkSmUserDeviceProfiles(self, networkId: str, userId: str):
+        """
+        **Get the profiles associated with a user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-device-profiles
+
+        - networkId (string): (required)
+        - userId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users', 'deviceProfiles'],
+            'operation': 'getNetworkSmUserDeviceProfiles'
+        }
+        resource = f'/networks/{networkId}/sm/users/{userId}/deviceProfiles'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getNetworkSmUserSoftwares(self, networkId: str, userId: str):
+        """
+        **Get a list of softwares associated with a user**
+        https://developer.cisco.com/meraki/api-v1/#!get-network-sm-user-softwares
+
+        - networkId (string): (required)
+        - userId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'users', 'softwares'],
+            'operation': 'getNetworkSmUserSoftwares'
+        }
+        resource = f'/networks/{networkId}/sm/users/{userId}/softwares'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmApnsCert(self, organizationId: str):
+        """
+        **Get the organization's APNS certificate**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-apns-cert
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'apnsCert'],
+            'operation': 'getOrganizationSmApnsCert'
+        }
+        resource = f'/organizations/{organizationId}/sm/apnsCert'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmVppAccounts(self, organizationId: str):
+        """
+        **List the VPP accounts in the organization**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-accounts
+
+        - organizationId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'vppAccounts'],
+            'operation': 'getOrganizationSmVppAccounts'
+        }
+        resource = f'/organizations/{organizationId}/sm/vppAccounts'
+
+        return self._session.get(metadata, resource)
+        
+
+
+    def getOrganizationSmVppAccount(self, organizationId: str, vppAccountId: str):
+        """
+        **Get a hash containing the unparsed token of the VPP account with the given ID**
+        https://developer.cisco.com/meraki/api-v1/#!get-organization-sm-vpp-account
+
+        - organizationId (string): (required)
+        - vppAccountId (string): (required)
+        """
+
+        metadata = {
+            'tags': ['sm', 'configure', 'vppAccounts'],
+            'operation': 'getOrganizationSmVppAccount'
+        }
+        resource = f'/organizations/{organizationId}/sm/vppAccounts/{vppAccountId}'
+
+        return self._session.get(metadata, resource)
+
```

### Comparing `meraki-1.7.1/meraki/config.py` & `meraki-1.7.2/meraki_v0/config.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # Package Constants
 
 # Meraki dashboard API key, set either at instantiation or as an environment variable
 API_KEY_ENVIRONMENT_VARIABLE = 'MERAKI_DASHBOARD_API_KEY'
 
 # Base URL preceding all endpoint resources
-DEFAULT_BASE_URL = 'https://api.meraki.com/api/v1'
+DEFAULT_BASE_URL = 'https://api.meraki.com/api/v0'
 
 # Maximum number of seconds for each API call
 SINGLE_REQUEST_TIMEOUT = 60
 
 # Path for TLS/SSL certificate verification if behind local proxy
 CERTIFICATE_PATH = ''
```

### Comparing `meraki-1.7.1/meraki/rest_session.py` & `meraki-1.7.2/meraki/rest_session.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,474 +1,473 @@
-from datetime import datetime
-import json
-import platform
-import random
-import sys
-import time
-import urllib.parse
-
-import requests
-
-from .config import *
-from .exceptions import *
-from .__init__ import __version__
-
-
-def user_agent_extended(be_geo_id, caller):
-    # Generate extended portion of the User-Agent
-    user_agent_extended = be_geo_id
-    user_agent_extended = {}
-
-    # Mimic pip system data collection per https://github.com/pypa/pip/blob/master/src/pip/_internal/network/session.py
-    user_agent_extended['implementation'] = {
-            "name": platform.python_implementation(),
-        }
-
-    if user_agent_extended["implementation"]["name"] in ('CPython','Jython','IronPython'):
-        user_agent_extended["implementation"]["version"] = platform.python_version()
-    elif user_agent_extended["implementation"]["name"] == 'PyPy':
-        if sys.pypy_version_info.releaselevel == 'final':
-            pypy_version_info = sys.pypy_version_info[:3]
-        else:
-            pypy_version_info = sys.pypy_version_info
-        user_agent_extended["implementation"]["version"] = ".".join(
-            [str(x) for x in pypy_version_info]
-        )
-
-    if sys.platform.startswith("darwin") and platform.mac_ver()[0]:
-        user_agent_extended["distro"] = {"name": "macOS", "version": platform.mac_ver()[0]}
-
-    if platform.system():
-        user_agent_extended.setdefault("system", {})["name"] = platform.system()
-
-    if platform.release():
-        user_agent_extended.setdefault("system", {})["release"] = platform.release()
-
-    if platform.machine():
-        user_agent_extended["cpu"] = platform.machine()
-
-    if be_geo_id:
-        user_agent_extended["be_geo_id"] = be_geo_id
-
-    if caller:
-        user_agent_extended["caller"] = caller
-
-    return urllib.parse.quote(json.dumps(user_agent_extended))
-
-
-# Main module interface
-class RestSession(object):
-    def __init__(
-        self,
-        logger,
-        api_key,
-        base_url=DEFAULT_BASE_URL,
-        single_request_timeout=SINGLE_REQUEST_TIMEOUT,
-        certificate_path=CERTIFICATE_PATH,
-        requests_proxy=REQUESTS_PROXY,
-        wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
-        nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
-        action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
-        retry_4xx_error=RETRY_4XX_ERROR,
-        retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
-        maximum_retries=MAXIMUM_RETRIES,
-        simulate=SIMULATE_API_CALLS,
-        be_geo_id=BE_GEO_ID,
-        caller=MERAKI_PYTHON_SDK_CALLER,
-        use_iterator_for_get_pages=False,
-    ):
-        super(RestSession, self).__init__()
-
-        # Initialize attributes and properties
-        self._version = __version__
-        self._api_key = str(api_key)
-        self._base_url = str(base_url)
-        self._single_request_timeout = single_request_timeout
-        self._certificate_path = certificate_path
-        self._requests_proxy = requests_proxy
-        self._wait_on_rate_limit = wait_on_rate_limit
-        self._nginx_429_retry_wait_time = nginx_429_retry_wait_time
-        self._action_batch_retry_wait_time = action_batch_retry_wait_time
-        self._retry_4xx_error = retry_4xx_error
-        self._retry_4xx_error_wait_time = retry_4xx_error_wait_time
-        self._maximum_retries = maximum_retries
-        self._simulate = simulate
-        self._be_geo_id = be_geo_id
-        self._caller = caller
-
-        self.use_iterator_for_get_pages = use_iterator_for_get_pages
-
-        # Initialize a new `requests` session
-        self._req_session = requests.session()
-        self._req_session.encoding = 'utf-8'
-
-        # Check base URL
-        if 'v0' in self._base_url:
-            sys.exit(f'If you want to use the Python library with v0 paths ({self._base_url} was configured as the base'
-                     f' URL), then install the v0 library. See the "Setup" section @ https://github.com/meraki/dashboard-api-python/')
-        elif self._base_url[-1] == '/':
-            self._base_url = self._base_url[:-1]
-
-        # Update the headers for the session
-        self._req_session.headers = {
-            'Authorization': 'Bearer ' + self._api_key,
-            'Content-Type': 'application/json',
-            'User-Agent': f'python-meraki/{self._version} ' + user_agent_extended(self._be_geo_id, self._caller),
-        }
-
-        # Log API calls
-        self._logger = logger
-        self._parameters = {'version': self._version}
-        self._parameters.update(locals())
-        self._parameters.pop('self')
-        self._parameters.pop('logger')
-        self._parameters.pop('__class__')
-        self._parameters['api_key'] = '*' * 36 + self._api_key[-4:]
-        if self._logger:
-            self._logger.info(f'Meraki dashboard API session initialized with these parameters: {self._parameters}')
-
-    @property
-    def use_iterator_for_get_pages(self):
-        return self._use_iterator_for_get_pages
-
-    @use_iterator_for_get_pages.setter
-    def use_iterator_for_get_pages(self, value):
-        if value:
-            self.get_pages = self._get_pages_iterator
-        else:
-            self.get_pages = self._get_pages_legacy
-
-        self._use_iterator_for_get_pages = value
-
-    def request(self, metadata, method, url, **kwargs):
-        # Metadata on endpoint
-        tag = metadata['tags'][0]
-        operation = metadata['operation']
-
-        # Update request kwargs with session defaults
-        if self._certificate_path:
-            kwargs.setdefault('verify', self._certificate_path)
-        if self._requests_proxy:
-            kwargs.setdefault('proxies', {'https': self._requests_proxy})
-        kwargs.setdefault('timeout', self._single_request_timeout)
-
-        # Ensure proper base URL
-        if 'meraki.com' in url or 'meraki.cn' in url:
-            abs_url = url
-        else:
-            abs_url = self._base_url + url
-
-        # Set maximum number of retries
-        retries = self._maximum_retries
-
-        # Option to simulate non-safe API calls without actually sending them
-        if self._logger:
-            self._logger.debug(metadata)
-        if self._simulate and method != 'GET':
-            if self._logger:
-                self._logger.info(f'{tag}, {operation} - SIMULATED')
-            return None
-        else:
-            response = None
-            while retries > 0:
-                # Make the HTTP request to the API endpoint
-                try:
-                    if response:
-                        response.close()
-                    if self._logger:
-                        self._logger.info(f'{method} {abs_url}')
-                    response = self._req_session.request(method, abs_url, allow_redirects=False, **kwargs)
-                    reason = response.reason if response.reason else ''
-                    status = response.status_code
-                except requests.exceptions.RequestException as e:
-                    if self._logger:
-                        self._logger.warning(f'{tag}, {operation} - {e}, retrying in 1 second')
-                    time.sleep(1)
-                    retries -= 1
-                    if retries == 0:
-                        raise APIError(metadata, response)
-                    else:
-                        continue
-
-                # Handle 3XX redirects automatically
-                if str(status)[0] == '3':
-                    abs_url = response.headers['Location']
-                    substring = 'meraki.com/api/v'
-                    if substring not in abs_url:
-                        substring = 'meraki.cn/api/v'
-                    self._base_url = abs_url[:abs_url.find(substring) + len(substring) + 1]
-
-                # 2XX success
-                elif response.ok:
-                    if 'page' in metadata:
-                        counter = metadata['page']
-                        if self._logger:
-                            self._logger.info(f'{tag}, {operation}; page {counter} - {status} {reason}')
-                    else:
-                        if self._logger:
-                            self._logger.info(f'{tag}, {operation} - {status} {reason}')
-                    # For non-empty response to GET, ensure valid JSON
-                    try:
-                        if method == 'GET' and response.content.strip():
-                            response.json()
-                        return response
-                    except json.decoder.JSONDecodeError as e:
-                        if self._logger:
-                            self._logger.warning(f'{tag}, {operation} - {e}, retrying in 1 second')
-                        time.sleep(1)
-                        retries -= 1
-                        if retries == 0:
-                            raise APIError(metadata, response)
-                        else:
-                            continue
-
-                # Rate limit 429 errors
-                elif status == 429:
-                    if 'Retry-After' in response.headers:
-                        wait = int(response.headers['Retry-After'])
-                    else:
-                        wait = random.randint(1, self._nginx_429_retry_wait_time)
-                    if self._logger:
-                        self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
-                    time.sleep(wait)
-                    retries -= 1
-                    if retries == 0:
-                        raise APIError(metadata, response)
-
-                # 5XX errors
-                elif status >= 500:
-                    if self._logger:
-                        self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in 1 second')
-                    time.sleep(1)
-                    retries -= 1
-                    if retries == 0:
-                        raise APIError(metadata, response)
-
-                # 4XX errors
-                else:
-                    try:
-                        message = response.json()
-                    except ValueError:
-                        message = response.content[:100]
-
-                    # Check specifically for action batch concurrency error
-                    action_batch_concurrency_error = {'errors': [
-                        'Too many concurrently executing batches. Maximum is 5 confirmed but not yet executed batches.']
-                    }
-                    if message == action_batch_concurrency_error:
-                        wait = self._action_batch_retry_wait_time
-                        if self._logger:
-                            self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
-                        time.sleep(wait)
-                        retries -= 1
-                        if retries == 0:
-                            raise APIError(metadata, response)
-                    elif self._retry_4xx_error:
-                        wait = random.randint(1, self._retry_4xx_error_wait_time)
-                        if self._logger:
-                            self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
-                        time.sleep(wait)
-                        retries -= 1
-                        if retries == 0:
-                            raise APIError(metadata, response)
-
-                    # All other client-side errors
-                    else:
-                        if self._logger:
-                            self._logger.error(f'{tag}, {operation} - {status} {reason}, {message}')
-                        raise APIError(metadata, response)
-
-    def get(self, metadata, url, params=None):
-        metadata['method'] = 'GET'
-        metadata['url'] = url
-        metadata['params'] = params
-        response = self.request(metadata, 'GET', url, params=params)
-        ret = None
-        if response:
-            if response.content.strip():
-                ret = response.json()
-            response.close()
-        return ret
-
-    def get_pages(self, metadata, url, params=None, total_pages=-1, direction='next', event_log_end_time=None):
-        pass
-
-    def _get_pages_iterator(
-        self,
-        metadata,
-        url,
-        params=None,
-        total_pages=-1,
-        direction="next",
-        event_log_end_time=None,
-    ):
-        if type(total_pages) == str and total_pages.lower() == "all":
-            total_pages = -1
-        elif type(total_pages) == str and total_pages.isnumeric():
-            total_pages = int(total_pages)
-        metadata["page"] = 1
-
-
-        response = self.request(metadata, 'GET', url, params=params)
- 
-        # Get additional pages if more than one requested
-        while total_pages != 0:
-            results = response.json()
-            links = response.links
-
-            # GET the subsequent page
-            if direction == "next" and "next" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes forward
-                if metadata["operation"] == "getNetworkEvents":
-                    starting_after = urllib.parse.unquote(
-                        str(links["next"]["url"]).split("startingAfter=")[1]
-                    )
-                    delta = datetime.utcnow() - datetime.fromisoformat(
-                        starting_after[:-1]
-                    )
-                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
-                    if delta.total_seconds() < 300:
-                        break
-                    # Or if next page is past the specified window's end time
-                    elif event_log_end_time and starting_after > event_log_end_time:
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["next"]["url"]
-            elif direction == "prev" and "prev" in links:
-                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
-                if metadata["operation"] == "getNetworkEvents":
-                    ending_before = urllib.parse.unquote(
-                        str(links["prev"]["url"]).split("endingBefore=")[1]
-                    )
-                    # Break out of loop if endingBefore returned from prev link is before 2014
-                    if ending_before < "2014-01-01":
-                        break
-
-                metadata["page"] += 1
-                nextlink = links["prev"]["url"]
-            else:
-                break
-
-            response.close()
-
-            return_items = []
-            # just prepare the list
-            if type(results) == list:
-                return_items = results
-            # For event log endpoint
-            elif type(results) == dict:
-                if direction == "next":
-                    return_items = results["events"][::-1]
-                else:
-                    return_items = results["events"]
-
-            for item in return_items:
-                yield item
-
-            total_pages = total_pages - 1
-
-            if total_pages != 0:
-                response = self.request(metadata, 'GET', nextlink)
-
-    def _get_pages_legacy(self, metadata, url, params=None, total_pages=-1, direction='next', event_log_end_time=None):
-        if type(total_pages) == str and total_pages.lower() == 'all':
-            total_pages = -1
-        elif type(total_pages) == str and total_pages.isnumeric():
-            total_pages = int(total_pages)
-        metadata['page'] = 1
-
-        response = self.request(metadata, 'GET', url, params=params)
-        results = response.json()
-
-        # For event log endpoint when using 'next' direction, so results/events are sorted chronologically
-        if type(results) == dict and metadata['operation'] == 'getNetworkEvents' and direction == 'next':
-            results['events'] = results['events'][::-1]
-        
-        # Get additional pages if more than one requested
-        while total_pages != 1:
-            links = response.links
-            response.close()
-            response = None
-
-            # GET the subsequent page
-            if direction == 'next' and 'next' in links:
-                # Prevent getNetworkEvents from infinite loop as time goes forward
-                if metadata['operation'] == 'getNetworkEvents':
-                    starting_after = urllib.parse.unquote(links['next']['url'].split('startingAfter=')[1])
-                    delta = datetime.utcnow() - datetime.fromisoformat(starting_after[:-1])
-                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
-                    if delta.total_seconds() < 300:
-                        break
-                    # Or if next page is past the specified window's end time
-                    elif event_log_end_time and starting_after > event_log_end_time:
-                        break
-                
-                metadata['page'] += 1
-                response = self.request(metadata, 'GET', links['next']['url'])
-            elif direction == 'prev' and 'prev' in links:
-                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
-                if metadata['operation'] == 'getNetworkEvents':
-                    ending_before = urllib.parse.unquote(links['prev']['url'].split('endingBefore=')[1])
-                    # Break out of loop if endingBefore returned from prev link is before 2014
-                    if ending_before < '2014-01-01':
-                        break
-                
-                metadata['page'] += 1
-                response = self.request(metadata, 'GET', links['prev']['url'])
-            else:
-                break
-
-            # Append that page's results, depending on the endpoint
-            if type(results) == list:
-                results.extend(response.json())
-            # For event log endpoint
-            elif type(results) == dict:
-                start = response.json()['pageStartAt']
-                end = response.json()['pageEndAt']
-                events = response.json()['events']
-                if direction == 'next':
-                    events = events[::-1]
-                if start < results['pageStartAt']:
-                    results['pageStartAt'] = start
-                if end > results['pageEndAt']:
-                    results['pageEndAt'] = end
-                results['events'].extend(events)
-
-            total_pages -= 1
-
-        if response:
-            response.close()
-
-        return results
-
-    def post(self, metadata, url, json=None):
-        metadata['method'] = 'POST'
-        metadata['url'] = url
-        metadata['json'] = json
-        response = self.request(metadata, 'POST', url, json=json)
-        ret = None
-        if response:
-            if response.content.strip():
-                ret = response.json()
-            response.close()
-        return ret
-
-    def put(self, metadata, url, json=None):
-        metadata['method'] = 'PUT'
-        metadata['url'] = url
-        metadata['json'] = json
-        response = self.request(metadata, 'PUT', url, json=json)
-        ret = None
-        if response:
-            if response.content.strip():
-                ret = response.json()
-            response.close()
-        return ret
-
-    def delete(self, metadata, url):
-        metadata['method'] = 'DELETE'
-        metadata['url'] = url
-        response = self.request(metadata, 'DELETE', url)
-        if response:
-            response.close()
-        return None
+from datetime import datetime
+import json
+import platform
+import random
+import sys
+import time
+import urllib.parse
+
+import requests
+
+from .config import *
+from .exceptions import *
+from .__init__ import __version__
+
+
+def user_agent_extended(be_geo_id, caller):
+    # Generate extended portion of the User-Agent
+    user_agent_extended = be_geo_id
+    user_agent_extended = {}
+
+    # Mimic pip system data collection per https://github.com/pypa/pip/blob/master/src/pip/_internal/network/session.py
+    user_agent_extended['implementation'] = {
+        "name": platform.python_implementation(),
+    }
+
+    if user_agent_extended["implementation"]["name"] in ('CPython', 'Jython', 'IronPython'):
+        user_agent_extended["implementation"]["version"] = platform.python_version()
+    elif user_agent_extended["implementation"]["name"] == 'PyPy':
+        if sys.pypy_version_info.releaselevel == 'final':
+            pypy_version_info = sys.pypy_version_info[:3]
+        else:
+            pypy_version_info = sys.pypy_version_info
+        user_agent_extended["implementation"]["version"] = ".".join(
+            [str(x) for x in pypy_version_info]
+        )
+
+    if sys.platform.startswith("darwin") and platform.mac_ver()[0]:
+        user_agent_extended["distro"] = {"name": "macOS", "version": platform.mac_ver()[0]}
+
+    if platform.system():
+        user_agent_extended.setdefault("system", {})["name"] = platform.system()
+
+    if platform.release():
+        user_agent_extended.setdefault("system", {})["release"] = platform.release()
+
+    if platform.machine():
+        user_agent_extended["cpu"] = platform.machine()
+
+    if be_geo_id:
+        user_agent_extended["be_geo_id"] = be_geo_id
+
+    if caller:
+        user_agent_extended["caller"] = caller
+
+    return urllib.parse.quote(json.dumps(user_agent_extended))
+
+
+# Main module interface
+class RestSession(object):
+    def __init__(
+        self,
+        logger,
+        api_key,
+        base_url=DEFAULT_BASE_URL,
+        single_request_timeout=SINGLE_REQUEST_TIMEOUT,
+        certificate_path=CERTIFICATE_PATH,
+        requests_proxy=REQUESTS_PROXY,
+        wait_on_rate_limit=WAIT_ON_RATE_LIMIT,
+        nginx_429_retry_wait_time=NGINX_429_RETRY_WAIT_TIME,
+        action_batch_retry_wait_time=ACTION_BATCH_RETRY_WAIT_TIME,
+        retry_4xx_error=RETRY_4XX_ERROR,
+        retry_4xx_error_wait_time=RETRY_4XX_ERROR_WAIT_TIME,
+        maximum_retries=MAXIMUM_RETRIES,
+        simulate=SIMULATE_API_CALLS,
+        be_geo_id=BE_GEO_ID,
+        caller=MERAKI_PYTHON_SDK_CALLER,
+        use_iterator_for_get_pages=False,
+    ):
+        super(RestSession, self).__init__()
+
+        # Initialize attributes and properties
+        self._version = __version__
+        self._api_key = str(api_key)
+        self._base_url = str(base_url)
+        self._single_request_timeout = single_request_timeout
+        self._certificate_path = certificate_path
+        self._requests_proxy = requests_proxy
+        self._wait_on_rate_limit = wait_on_rate_limit
+        self._nginx_429_retry_wait_time = nginx_429_retry_wait_time
+        self._action_batch_retry_wait_time = action_batch_retry_wait_time
+        self._retry_4xx_error = retry_4xx_error
+        self._retry_4xx_error_wait_time = retry_4xx_error_wait_time
+        self._maximum_retries = maximum_retries
+        self._simulate = simulate
+        self._be_geo_id = be_geo_id
+        self._caller = caller
+
+        self.use_iterator_for_get_pages = use_iterator_for_get_pages
+
+        # Initialize a new `requests` session
+        self._req_session = requests.session()
+        self._req_session.encoding = 'utf-8'
+
+        # Check base URL
+        if 'v0' in self._base_url:
+            sys.exit(f'If you want to use the Python library with v0 paths ({self._base_url} was configured as the base'
+                     f' URL), then install the v0 library. See the "Setup" section @ https://github.com/meraki/dashboard-api-python/')
+        elif self._base_url[-1] == '/':
+            self._base_url = self._base_url[:-1]
+
+        # Update the headers for the session
+        self._req_session.headers = {
+            'Authorization': 'Bearer ' + self._api_key,
+            'Content-Type': 'application/json',
+            'User-Agent': f'python-meraki/{self._version} ' + user_agent_extended(self._be_geo_id, self._caller),
+        }
+
+        # Log API calls
+        self._logger = logger
+        self._parameters = {'version': self._version}
+        self._parameters.update(locals())
+        self._parameters.pop('self')
+        self._parameters.pop('logger')
+        self._parameters.pop('__class__')
+        self._parameters['api_key'] = '*' * 36 + self._api_key[-4:]
+        if self._logger:
+            self._logger.info(f'Meraki dashboard API session initialized with these parameters: {self._parameters}')
+
+    @property
+    def use_iterator_for_get_pages(self):
+        return self._use_iterator_for_get_pages
+
+    @use_iterator_for_get_pages.setter
+    def use_iterator_for_get_pages(self, value):
+        if value:
+            self.get_pages = self._get_pages_iterator
+        else:
+            self.get_pages = self._get_pages_legacy
+
+        self._use_iterator_for_get_pages = value
+
+    def request(self, metadata, method, url, **kwargs):
+        # Metadata on endpoint
+        tag = metadata['tags'][0]
+        operation = metadata['operation']
+
+        # Update request kwargs with session defaults
+        if self._certificate_path:
+            kwargs.setdefault('verify', self._certificate_path)
+        if self._requests_proxy:
+            kwargs.setdefault('proxies', {'https': self._requests_proxy})
+        kwargs.setdefault('timeout', self._single_request_timeout)
+
+        # Ensure proper base URL
+        if 'meraki.com' in url or 'meraki.cn' in url:
+            abs_url = url
+        else:
+            abs_url = self._base_url + url
+
+        # Set maximum number of retries
+        retries = self._maximum_retries
+
+        # Option to simulate non-safe API calls without actually sending them
+        if self._logger:
+            self._logger.debug(metadata)
+        if self._simulate and method != 'GET':
+            if self._logger:
+                self._logger.info(f'{tag}, {operation} - SIMULATED')
+            return None
+        else:
+            response = None
+            while retries > 0:
+                # Make the HTTP request to the API endpoint
+                try:
+                    if response:
+                        response.close()
+                    if self._logger:
+                        self._logger.info(f'{method} {abs_url}')
+                    response = self._req_session.request(method, abs_url, allow_redirects=False, **kwargs)
+                    reason = response.reason if response.reason else ''
+                    status = response.status_code
+                except requests.exceptions.RequestException as e:
+                    if self._logger:
+                        self._logger.warning(f'{tag}, {operation} - {e}, retrying in 1 second')
+                    time.sleep(1)
+                    retries -= 1
+                    if retries == 0:
+                        raise APIError(metadata, response)
+                    else:
+                        continue
+
+                # Handle 3XX redirects automatically
+                if str(status)[0] == '3':
+                    abs_url = response.headers['Location']
+                    substring = 'meraki.com/api/v'
+                    if substring not in abs_url:
+                        substring = 'meraki.cn/api/v'
+                    self._base_url = abs_url[:abs_url.find(substring) + len(substring) + 1]
+
+                # 2XX success
+                elif response.ok:
+                    if 'page' in metadata:
+                        counter = metadata['page']
+                        if self._logger:
+                            self._logger.info(f'{tag}, {operation}; page {counter} - {status} {reason}')
+                    else:
+                        if self._logger:
+                            self._logger.info(f'{tag}, {operation} - {status} {reason}')
+                    # For non-empty response to GET, ensure valid JSON
+                    try:
+                        if method == 'GET' and response.content.strip():
+                            response.json()
+                        return response
+                    except json.decoder.JSONDecodeError as e:
+                        if self._logger:
+                            self._logger.warning(f'{tag}, {operation} - {e}, retrying in 1 second')
+                        time.sleep(1)
+                        retries -= 1
+                        if retries == 0:
+                            raise APIError(metadata, response)
+                        else:
+                            continue
+
+                # Rate limit 429 errors
+                elif status == 429:
+                    if 'Retry-After' in response.headers:
+                        wait = int(response.headers['Retry-After'])
+                    else:
+                        wait = random.randint(1, self._nginx_429_retry_wait_time)
+                    if self._logger:
+                        self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
+                    time.sleep(wait)
+                    retries -= 1
+                    if retries == 0:
+                        raise APIError(metadata, response)
+
+                # 5XX errors
+                elif status >= 500:
+                    if self._logger:
+                        self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in 1 second')
+                    time.sleep(1)
+                    retries -= 1
+                    if retries == 0:
+                        raise APIError(metadata, response)
+
+                # 4XX errors
+                else:
+                    try:
+                        message = response.json()
+                    except ValueError:
+                        message = response.content[:100]
+
+                    # Check specifically for action batch concurrency error
+                    action_batch_concurrency_error = {'errors': [
+                        'Too many concurrently executing batches. Maximum is 5 confirmed but not yet executed batches.']
+                    }
+                    if message == action_batch_concurrency_error:
+                        wait = self._action_batch_retry_wait_time
+                        if self._logger:
+                            self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
+                        time.sleep(wait)
+                        retries -= 1
+                        if retries == 0:
+                            raise APIError(metadata, response)
+                    elif self._retry_4xx_error:
+                        wait = random.randint(1, self._retry_4xx_error_wait_time)
+                        if self._logger:
+                            self._logger.warning(f'{tag}, {operation} - {status} {reason}, retrying in {wait} seconds')
+                        time.sleep(wait)
+                        retries -= 1
+                        if retries == 0:
+                            raise APIError(metadata, response)
+
+                    # All other client-side errors
+                    else:
+                        if self._logger:
+                            self._logger.error(f'{tag}, {operation} - {status} {reason}, {message}')
+                        raise APIError(metadata, response)
+
+    def get(self, metadata, url, params=None):
+        metadata['method'] = 'GET'
+        metadata['url'] = url
+        metadata['params'] = params
+        response = self.request(metadata, 'GET', url, params=params)
+        ret = None
+        if response:
+            if response.content.strip():
+                ret = response.json()
+            response.close()
+        return ret
+
+    def get_pages(self, metadata, url, params=None, total_pages=-1, direction='next', event_log_end_time=None):
+        pass
+
+    def _get_pages_iterator(
+        self,
+        metadata,
+        url,
+        params=None,
+        total_pages=-1,
+        direction="next",
+        event_log_end_time=None,
+    ):
+        if type(total_pages) == str and total_pages.lower() == "all":
+            total_pages = -1
+        elif type(total_pages) == str and total_pages.isnumeric():
+            total_pages = int(total_pages)
+        metadata["page"] = 1
+
+        response = self.request(metadata, 'GET', url, params=params)
+
+        # Get additional pages if more than one requested
+        while total_pages != 0:
+            results = response.json()
+            links = response.links
+
+            # GET the subsequent page
+            if direction == "next" and "next" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes forward
+                if metadata["operation"] == "getNetworkEvents":
+                    starting_after = urllib.parse.unquote(
+                        str(links["next"]["url"]).split("startingAfter=")[1]
+                    )
+                    delta = datetime.utcnow() - datetime.fromisoformat(
+                        starting_after[:-1]
+                    )
+                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
+                    if delta.total_seconds() < 300:
+                        break
+                    # Or if next page is past the specified window's end time
+                    elif event_log_end_time and starting_after > event_log_end_time:
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["next"]["url"]
+            elif direction == "prev" and "prev" in links:
+                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
+                if metadata["operation"] == "getNetworkEvents":
+                    ending_before = urllib.parse.unquote(
+                        str(links["prev"]["url"]).split("endingBefore=")[1]
+                    )
+                    # Break out of loop if endingBefore returned from prev link is before 2014
+                    if ending_before < "2014-01-01":
+                        break
+
+                metadata["page"] += 1
+                nextlink = links["prev"]["url"]
+            else:
+                break
+
+            response.close()
+
+            return_items = []
+            # just prepare the list
+            if type(results) == list:
+                return_items = results
+            # For event log endpoint
+            elif type(results) == dict:
+                if direction == "next":
+                    return_items = results["events"][::-1]
+                else:
+                    return_items = results["events"]
+
+            for item in return_items:
+                yield item
+
+            total_pages = total_pages - 1
+
+            if total_pages != 0:
+                response = self.request(metadata, 'GET', nextlink)
+
+    def _get_pages_legacy(self, metadata, url, params=None, total_pages=-1, direction='next', event_log_end_time=None):
+        if type(total_pages) == str and total_pages.lower() == 'all':
+            total_pages = -1
+        elif type(total_pages) == str and total_pages.isnumeric():
+            total_pages = int(total_pages)
+        metadata['page'] = 1
+
+        response = self.request(metadata, 'GET', url, params=params)
+        results = response.json()
+
+        # For event log endpoint when using 'next' direction, so results/events are sorted chronologically
+        if type(results) == dict and metadata['operation'] == 'getNetworkEvents' and direction == 'next':
+            results['events'] = results['events'][::-1]
+
+        # Get additional pages if more than one requested
+        while total_pages != 1:
+            links = response.links
+            response.close()
+            response = None
+
+            # GET the subsequent page
+            if direction == 'next' and 'next' in links:
+                # Prevent getNetworkEvents from infinite loop as time goes forward
+                if metadata['operation'] == 'getNetworkEvents':
+                    starting_after = urllib.parse.unquote(links['next']['url'].split('startingAfter=')[1])
+                    delta = datetime.utcnow() - datetime.fromisoformat(starting_after[:-1])
+                    # Break out of loop if startingAfter returned from next link is within 5 minutes of current time
+                    if delta.total_seconds() < 300:
+                        break
+                    # Or if next page is past the specified window's end time
+                    elif event_log_end_time and starting_after > event_log_end_time:
+                        break
+
+                metadata['page'] += 1
+                response = self.request(metadata, 'GET', links['next']['url'])
+            elif direction == 'prev' and 'prev' in links:
+                # Prevent getNetworkEvents from infinite loop as time goes backward (to epoch 0)
+                if metadata['operation'] == 'getNetworkEvents':
+                    ending_before = urllib.parse.unquote(links['prev']['url'].split('endingBefore=')[1])
+                    # Break out of loop if endingBefore returned from prev link is before 2014
+                    if ending_before < '2014-01-01':
+                        break
+
+                metadata['page'] += 1
+                response = self.request(metadata, 'GET', links['prev']['url'])
+            else:
+                break
+
+            # Append that page's results, depending on the endpoint
+            if type(results) == list:
+                results.extend(response.json())
+            # For event log endpoint
+            elif type(results) == dict:
+                start = response.json()['pageStartAt']
+                end = response.json()['pageEndAt']
+                events = response.json()['events']
+                if direction == 'next':
+                    events = events[::-1]
+                if start < results['pageStartAt']:
+                    results['pageStartAt'] = start
+                if end > results['pageEndAt']:
+                    results['pageEndAt'] = end
+                results['events'].extend(events)
+
+            total_pages -= 1
+
+        if response:
+            response.close()
+
+        return results
+
+    def post(self, metadata, url, json=None):
+        metadata['method'] = 'POST'
+        metadata['url'] = url
+        metadata['json'] = json
+        response = self.request(metadata, 'POST', url, json=json)
+        ret = None
+        if response:
+            if response.content.strip():
+                ret = response.json()
+            response.close()
+        return ret
+
+    def put(self, metadata, url, json=None):
+        metadata['method'] = 'PUT'
+        metadata['url'] = url
+        metadata['json'] = json
+        response = self.request(metadata, 'PUT', url, json=json)
+        ret = None
+        if response:
+            if response.content.strip():
+                ret = response.json()
+            response.close()
+        return ret
+
+    def delete(self, metadata, url):
+        metadata['method'] = 'DELETE'
+        metadata['url'] = url
+        response = self.request(metadata, 'DELETE', url)
+        if response:
+            response.close()
+        return None
```

### Comparing `meraki-1.7.1/meraki.egg-info/PKG-INFO` & `meraki-1.7.2/meraki.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: meraki
-Version: 1.7.1
+Version: 1.7.2
 Summary: Cisco Meraki Dashboard API library
 Home-page: https://github.com/meraki/dashboard-api-python
 Author: Cisco Meraki
 Author-email: api-feedback@meraki.net
 License: MIT
 Description: # Meraki Dashboard API Python Library
```

### Comparing `meraki-1.7.1/meraki.egg-info/SOURCES.txt` & `meraki-1.7.2/meraki.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/__init__.py` & `meraki-1.7.2/meraki_v0/__init__.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/__init__.py` & `meraki-1.7.2/meraki_v0/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/action_batches.py` & `meraki-1.7.2/meraki_v0/aio/api/action_batches.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/admins.py` & `meraki-1.7.2/meraki_v0/aio/api/admins.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/alert_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/alert_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/api_usage.py` & `meraki-1.7.2/meraki_v0/aio/api/api_usage.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/bluetooth_clients.py` & `meraki-1.7.2/meraki_v0/aio/api/bluetooth_clients.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/bluetooth_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/bluetooth_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/camera_quality_retention_profiles.py` & `meraki-1.7.2/meraki_v0/aio/api/camera_quality_retention_profiles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/cameras.py` & `meraki-1.7.2/meraki_v0/aio/api/cameras.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/change_log.py` & `meraki-1.7.2/meraki_v0/aio/api/change_log.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/clients.py` & `meraki-1.7.2/meraki_v0/aio/api/clients.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/config_templates.py` & `meraki-1.7.2/meraki_v0/aio/api/config_templates.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/connectivity_monitoring_destinations.py` & `meraki-1.7.2/meraki_v0/aio/api/connectivity_monitoring_destinations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/content_filtering_categories.py` & `meraki-1.7.2/meraki_v0/aio/api/content_filtering_categories.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/content_filtering_rules.py` & `meraki-1.7.2/meraki_v0/aio/api/content_filtering_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/dashboard_branding_policies.py` & `meraki-1.7.2/meraki_v0/aio/api/dashboard_branding_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/devices.py` & `meraki-1.7.2/meraki_v0/aio/api/devices.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/events.py` & `meraki-1.7.2/meraki_v0/aio/api/events.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/firewalled_services.py` & `meraki-1.7.2/meraki_v0/aio/api/firewalled_services.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/floor_plans.py` & `meraki-1.7.2/meraki_v0/aio/api/floor_plans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/floorplans.py` & `meraki-1.7.2/meraki_v0/aio/api/floorplans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/group_policies.py` & `meraki-1.7.2/meraki_v0/aio/api/group_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/http_servers.py` & `meraki-1.7.2/meraki_v0/aio/api/http_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/intrusion_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/intrusion_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/licenses.py` & `meraki-1.7.2/meraki_v0/aio/api/licenses.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/link_aggregations.py` & `meraki-1.7.2/meraki_v0/aio/api/link_aggregations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/malware_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/malware_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/management_interface_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/management_interface_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/meraki_auth_users.py` & `meraki-1.7.2/meraki_v0/aio/api/meraki_auth_users.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_connectivity_monitoring_destinations.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_connectivity_monitoring_destinations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_dhcp_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_dhcp_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_lan_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_lan_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_port_forwarding_rules.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_port_forwarding_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_subnet_pool_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_subnet_pool_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mg_uplink_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/mg_uplink_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/monitored_media_servers.py` & `meraki-1.7.2/meraki_v0/aio/api/monitored_media_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mr_l3_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mr_l3_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mv_sense.py` & `meraki-1.7.2/meraki_v0/aio/api/mv_sense.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_1_1_nat_rules.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_1_1_nat_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_1_many_nat_rules.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_1_many_nat_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_cellular_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_cellular_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_inbound_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_inbound_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_l3_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_l3_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_l7_application_categories.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_l7_application_categories.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_l7_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_l7_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_port_forwarding_rules.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_port_forwarding_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_static_routes.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_static_routes.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_vlan_ports.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_vlan_ports.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_vpn_firewall.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_vpn_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/mx_warm_spare_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/mx_warm_spare_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/named_tag_scope.py` & `meraki-1.7.2/meraki_v0/aio/api/named_tag_scope.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/netflow_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/netflow_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/networks.py` & `meraki-1.7.2/meraki_v0/aio/api/networks.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/openapi_spec.py` & `meraki-1.7.2/meraki_v0/aio/api/openapi_spec.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/organizations.py` & `meraki-1.7.2/meraki_v0/aio/api/organizations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/pii.py` & `meraki-1.7.2/meraki_v0/aio/api/pii.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/radio_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/radio_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/saml_roles.py` & `meraki-1.7.2/meraki_v0/aio/api/saml_roles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/security_events.py` & `meraki-1.7.2/meraki_v0/aio/api/security_events.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/sm.py` & `meraki-1.7.2/meraki_v0/aio/api/sm.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/snmp_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/snmp_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/splash_login_attempts.py` & `meraki-1.7.2/meraki_v0/aio/api/splash_login_attempts.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/splash_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/splash_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/ssids.py` & `meraki-1.7.2/meraki_v0/aio/api/ssids.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_access_policies.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_access_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_acls.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_acls.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_port_schedules.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_port_schedules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_ports.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_ports.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_profiles.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_profiles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/switch_stacks.py` & `meraki-1.7.2/meraki_v0/aio/api/switch_stacks.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/syslog_servers.py` & `meraki-1.7.2/meraki_v0/aio/api/syslog_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/traffic_analysis_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/traffic_analysis_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/traffic_shaping.py` & `meraki-1.7.2/meraki_v0/aio/api/traffic_shaping.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/uplink_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/uplink_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/vlans.py` & `meraki-1.7.2/meraki_v0/aio/api/vlans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/webhook_logs.py` & `meraki-1.7.2/meraki_v0/aio/api/webhook_logs.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/wireless_health.py` & `meraki-1.7.2/meraki_v0/aio/api/wireless_health.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/api/wireless_settings.py` & `meraki-1.7.2/meraki_v0/aio/api/wireless_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/aio/rest_session.py` & `meraki-1.7.2/meraki_v0/aio/rest_session.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/action_batches.py` & `meraki-1.7.2/meraki_v0/api/action_batches.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/admins.py` & `meraki-1.7.2/meraki_v0/api/admins.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/alert_settings.py` & `meraki-1.7.2/meraki_v0/api/alert_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/api_usage.py` & `meraki-1.7.2/meraki_v0/api/api_usage.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/bluetooth_clients.py` & `meraki-1.7.2/meraki_v0/api/bluetooth_clients.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/bluetooth_settings.py` & `meraki-1.7.2/meraki_v0/api/bluetooth_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/camera_quality_retention_profiles.py` & `meraki-1.7.2/meraki_v0/api/camera_quality_retention_profiles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/cameras.py` & `meraki-1.7.2/meraki_v0/api/cameras.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/change_log.py` & `meraki-1.7.2/meraki_v0/api/change_log.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/clients.py` & `meraki-1.7.2/meraki_v0/api/clients.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/config_templates.py` & `meraki-1.7.2/meraki_v0/api/config_templates.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/connectivity_monitoring_destinations.py` & `meraki-1.7.2/meraki_v0/api/connectivity_monitoring_destinations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/content_filtering_categories.py` & `meraki-1.7.2/meraki_v0/api/content_filtering_categories.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/content_filtering_rules.py` & `meraki-1.7.2/meraki_v0/api/content_filtering_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/dashboard_branding_policies.py` & `meraki-1.7.2/meraki_v0/api/dashboard_branding_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/devices.py` & `meraki-1.7.2/meraki_v0/api/devices.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/events.py` & `meraki-1.7.2/meraki_v0/api/events.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/firewalled_services.py` & `meraki-1.7.2/meraki_v0/api/firewalled_services.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/floor_plans.py` & `meraki-1.7.2/meraki_v0/api/floor_plans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/floorplans.py` & `meraki-1.7.2/meraki_v0/api/floorplans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/group_policies.py` & `meraki-1.7.2/meraki_v0/api/group_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/http_servers.py` & `meraki-1.7.2/meraki_v0/api/http_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/intrusion_settings.py` & `meraki-1.7.2/meraki_v0/api/intrusion_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/licenses.py` & `meraki-1.7.2/meraki_v0/api/licenses.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/link_aggregations.py` & `meraki-1.7.2/meraki_v0/api/link_aggregations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/malware_settings.py` & `meraki-1.7.2/meraki_v0/api/malware_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/management_interface_settings.py` & `meraki-1.7.2/meraki_v0/api/management_interface_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/meraki_auth_users.py` & `meraki-1.7.2/meraki_v0/api/meraki_auth_users.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_connectivity_monitoring_destinations.py` & `meraki-1.7.2/meraki_v0/api/mg_connectivity_monitoring_destinations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_dhcp_settings.py` & `meraki-1.7.2/meraki_v0/api/mg_dhcp_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_lan_settings.py` & `meraki-1.7.2/meraki_v0/api/mg_lan_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_port_forwarding_rules.py` & `meraki-1.7.2/meraki_v0/api/mg_port_forwarding_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_subnet_pool_settings.py` & `meraki-1.7.2/meraki_v0/api/mg_subnet_pool_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mg_uplink_settings.py` & `meraki-1.7.2/meraki_v0/api/mg_uplink_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/monitored_media_servers.py` & `meraki-1.7.2/meraki_v0/api/monitored_media_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mr_l3_firewall.py` & `meraki-1.7.2/meraki_v0/api/mr_l3_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mv_sense.py` & `meraki-1.7.2/meraki_v0/api/mv_sense.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_1_1_nat_rules.py` & `meraki-1.7.2/meraki_v0/api/mx_1_1_nat_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_1_many_nat_rules.py` & `meraki-1.7.2/meraki_v0/api/mx_1_many_nat_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_cellular_firewall.py` & `meraki-1.7.2/meraki_v0/api/mx_cellular_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_inbound_firewall.py` & `meraki-1.7.2/meraki_v0/api/mx_inbound_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_l3_firewall.py` & `meraki-1.7.2/meraki_v0/api/mx_l3_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_l7_application_categories.py` & `meraki-1.7.2/meraki_v0/api/mx_l7_application_categories.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_l7_firewall.py` & `meraki-1.7.2/meraki_v0/api/mx_l7_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_port_forwarding_rules.py` & `meraki-1.7.2/meraki_v0/api/mx_port_forwarding_rules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_static_routes.py` & `meraki-1.7.2/meraki_v0/api/mx_static_routes.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_vlan_ports.py` & `meraki-1.7.2/meraki_v0/api/mx_vlan_ports.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_vpn_firewall.py` & `meraki-1.7.2/meraki_v0/api/mx_vpn_firewall.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/mx_warm_spare_settings.py` & `meraki-1.7.2/meraki_v0/api/mx_warm_spare_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/named_tag_scope.py` & `meraki-1.7.2/meraki_v0/api/named_tag_scope.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/netflow_settings.py` & `meraki-1.7.2/meraki_v0/api/netflow_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/networks.py` & `meraki-1.7.2/meraki_v0/api/networks.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/openapi_spec.py` & `meraki-1.7.2/meraki_v0/api/openapi_spec.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/organizations.py` & `meraki-1.7.2/meraki_v0/api/organizations.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/pii.py` & `meraki-1.7.2/meraki_v0/api/pii.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/radio_settings.py` & `meraki-1.7.2/meraki_v0/api/radio_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/saml_roles.py` & `meraki-1.7.2/meraki_v0/api/saml_roles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/security_events.py` & `meraki-1.7.2/meraki_v0/api/security_events.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/sm.py` & `meraki-1.7.2/meraki_v0/api/sm.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/snmp_settings.py` & `meraki-1.7.2/meraki_v0/api/snmp_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/splash_login_attempts.py` & `meraki-1.7.2/meraki_v0/api/splash_login_attempts.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/splash_settings.py` & `meraki-1.7.2/meraki_v0/api/splash_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/ssids.py` & `meraki-1.7.2/meraki_v0/api/ssids.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_access_policies.py` & `meraki-1.7.2/meraki_v0/api/switch_access_policies.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_acls.py` & `meraki-1.7.2/meraki_v0/api/switch_acls.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_port_schedules.py` & `meraki-1.7.2/meraki_v0/api/switch_port_schedules.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_ports.py` & `meraki-1.7.2/meraki_v0/api/switch_ports.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_profiles.py` & `meraki-1.7.2/meraki_v0/api/switch_profiles.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_settings.py` & `meraki-1.7.2/meraki_v0/api/switch_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/switch_stacks.py` & `meraki-1.7.2/meraki_v0/api/switch_stacks.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/syslog_servers.py` & `meraki-1.7.2/meraki_v0/api/syslog_servers.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/traffic_analysis_settings.py` & `meraki-1.7.2/meraki_v0/api/traffic_analysis_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/traffic_shaping.py` & `meraki-1.7.2/meraki_v0/api/traffic_shaping.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/uplink_settings.py` & `meraki-1.7.2/meraki_v0/api/uplink_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/vlans.py` & `meraki-1.7.2/meraki_v0/api/vlans.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/webhook_logs.py` & `meraki-1.7.2/meraki_v0/api/webhook_logs.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/wireless_health.py` & `meraki-1.7.2/meraki_v0/api/wireless_health.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/api/wireless_settings.py` & `meraki-1.7.2/meraki_v0/api/wireless_settings.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/config.py` & `meraki-1.7.2/meraki/config.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-# Package Constants
-
-# Meraki dashboard API key, set either at instantiation or as an environment variable
-API_KEY_ENVIRONMENT_VARIABLE = 'MERAKI_DASHBOARD_API_KEY'
-
-# Base URL preceding all endpoint resources
-DEFAULT_BASE_URL = 'https://api.meraki.com/api/v0'
-
-# Maximum number of seconds for each API call
-SINGLE_REQUEST_TIMEOUT = 60
-
-# Path for TLS/SSL certificate verification if behind local proxy
-CERTIFICATE_PATH = ''
-
-# Proxy server and port, if needed, for HTTPS
-REQUESTS_PROXY = ''
-
-# Retry if 429 rate limit error encountered?
-WAIT_ON_RATE_LIMIT = True
-
-# Nginx 429 retry wait time
-NGINX_429_RETRY_WAIT_TIME = 60
-
-# Action batch concurrency error retry wait time
-ACTION_BATCH_RETRY_WAIT_TIME = 60
-
-# Retry if encountering other 4XX error (besides 429)?
-RETRY_4XX_ERROR = False
-
-# Other 4XX error retry wait time
-RETRY_4XX_ERROR_WAIT_TIME = 60
-
-# Retry up to this many times when encountering 429s or other server-side errors
-MAXIMUM_RETRIES = 2
-
-# Create an output log file?
-OUTPUT_LOG = True
-
-# Path to output log; by default, working directory of script if not specified
-LOG_PATH = ''
-
-# Log file name appended with date and timestamp
-LOG_FILE_PREFIX = 'meraki_api_'
-
-# Print output logging to console?
-PRINT_TO_CONSOLE = True
-
-# Disable all logging? You're on your own then!
-SUPPRESS_LOGGING = False
-
-# Simulate POST/PUT/DELETE calls to prevent changes?
-SIMULATE_API_CALLS = False
-
-# Number of concurrent API requests for asynchronous class
-AIO_MAXIMUM_CONCURRENT_REQUESTS = 3
-
-# Optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
-BE_GEO_ID = ''
-
-# Optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
-MERAKI_PYTHON_SDK_CALLER = ''
+# Package Constants
+
+# Meraki dashboard API key, set either at instantiation or as an environment variable
+API_KEY_ENVIRONMENT_VARIABLE = 'MERAKI_DASHBOARD_API_KEY'
+
+# Base URL preceding all endpoint resources
+DEFAULT_BASE_URL = 'https://api.meraki.com/api/v1'
+
+# Maximum number of seconds for each API call
+SINGLE_REQUEST_TIMEOUT = 60
+
+# Path for TLS/SSL certificate verification if behind local proxy
+CERTIFICATE_PATH = ''
+
+# Proxy server and port, if needed, for HTTPS
+REQUESTS_PROXY = ''
+
+# Retry if 429 rate limit error encountered?
+WAIT_ON_RATE_LIMIT = True
+
+# Nginx 429 retry wait time
+NGINX_429_RETRY_WAIT_TIME = 60
+
+# Action batch concurrency error retry wait time
+ACTION_BATCH_RETRY_WAIT_TIME = 60
+
+# Retry if encountering other 4XX error (besides 429)?
+RETRY_4XX_ERROR = False
+
+# Other 4XX error retry wait time
+RETRY_4XX_ERROR_WAIT_TIME = 60
+
+# Retry up to this many times when encountering 429s or other server-side errors
+MAXIMUM_RETRIES = 2
+
+# Create an output log file?
+OUTPUT_LOG = True
+
+# Path to output log; by default, working directory of script if not specified
+LOG_PATH = ''
+
+# Log file name appended with date and timestamp
+LOG_FILE_PREFIX = 'meraki_api_'
+
+# Print output logging to console?
+PRINT_TO_CONSOLE = True
+
+# Disable all logging? You're on your own then!
+SUPPRESS_LOGGING = False
+
+# Simulate POST/PUT/DELETE calls to prevent changes?
+SIMULATE_API_CALLS = False
+
+# Number of concurrent API requests for asynchronous class
+AIO_MAXIMUM_CONCURRENT_REQUESTS = 3
+
+# Optional partner identifier for API usage tracking; can also be set as an environment variable BE_GEO_ID
+BE_GEO_ID = ''
+
+# Optional identifier for API usage tracking; can also be set as an environment variable MERAKI_PYTHON_SDK_CALLER
+MERAKI_PYTHON_SDK_CALLER = ''
```

### Comparing `meraki-1.7.1/meraki_v0/convert_to_aio.py` & `meraki-1.7.2/meraki_v0/convert_to_aio.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/exceptions.py` & `meraki-1.7.2/meraki_v0/exceptions.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/legacy.py` & `meraki-1.7.2/meraki_v0/legacy.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/meraki_v0/rest_session.py` & `meraki-1.7.2/meraki_v0/rest_session.py`

 * *Files identical despite different names*

### Comparing `meraki-1.7.1/setup.py` & `meraki-1.7.2/setup.py`

 * *Files identical despite different names*

