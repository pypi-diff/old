--- tmp/meshtastic-2.1.4.tar.gz
+++ tmp/meshtastic-2.1.5.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "meshtastic-2.1.4.tar", last modified: Wed Mar 29 00:36:52 2023, max compression
│ +gzip compressed data, was "meshtastic-2.1.5.tar", last modified: Thu Apr  6 14:20:40 2023, max compression
│   --- meshtastic-2.1.4.tar
├── +++ meshtastic-2.1.5.tar
│ ├── file list
│ │ @@ -1,48 +1,48 @@
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 00:36:52.243140 meshtastic-2.1.4/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    11358 2023-03-29 00:36:41.000000 meshtastic-2.1.4/LICENSE.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)       18 2023-03-29 00:36:41.000000 meshtastic-2.1.4/MANIFEST.in
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2319 2023-03-29 00:36:52.243140 meshtastic-2.1.4/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-03-29 00:36:41.000000 meshtastic-2.1.4/README.md
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 00:36:52.243140 meshtastic-2.1.4/meshtastic/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8107 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    45526 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/__main__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5641 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/admin_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1758 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/apponly_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/ble.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2202 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/ble_interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/cannedmessages_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2675 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/channel_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    13847 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/config_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5357 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/connection_status_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2168 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/device_metadata_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3908 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/deviceonly_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2684 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/globals.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3404 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/localonly_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    33047 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/mesh_interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    18598 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/mesh_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    12782 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/module_config_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1695 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/mqtt_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    34093 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/node.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2421 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/portnums_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3664 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/remote_hardware.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2032 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/remote_hardware_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1494 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/rtttl_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2520 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/serial_interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4719 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/storeforward_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7428 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/stream_interface.py
│ │ --rwxr-xr-x   0 runner    (1001) docker     (123)     6692 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/supported_device.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2309 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/tcp_interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5054 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/telemetry_pb2.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5827 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/test.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8025 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/tunnel.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    18955 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/util.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-03-29 00:36:41.000000 meshtastic-2.1.4/meshtastic/xmodem_pb2.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 00:36:52.243140 meshtastic-2.1.4/meshtastic.egg-info/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2319 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      110 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/entry_points.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      201 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/requires.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)       11 2023-03-29 00:36:52.000000 meshtastic-2.1.4/meshtastic.egg-info/top_level.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)       38 2023-03-29 00:36:52.243140 meshtastic-2.1.4/setup.cfg
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1682 2023-03-29 00:36:41.000000 meshtastic-2.1.4/setup.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 14:20:40.360386 meshtastic-2.1.5/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    11358 2023-04-06 14:20:27.000000 meshtastic-2.1.5/LICENSE.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-04-06 14:20:27.000000 meshtastic-2.1.5/MANIFEST.in
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2319 2023-04-06 14:20:40.360386 meshtastic-2.1.5/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-04-06 14:20:27.000000 meshtastic-2.1.5/README.md
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 14:20:40.360386 meshtastic-2.1.5/meshtastic/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8186 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    48243 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/__main__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5641 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/admin_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1758 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/apponly_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/ble.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/ble_interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/cannedmessages_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2675 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/channel_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    13847 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/config_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5357 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/connection_status_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2168 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/device_metadata_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3908 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/deviceonly_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2686 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/globals.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3404 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/localonly_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    37473 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/mesh_interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    18598 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/mesh_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    12825 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/module_config_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1695 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/mqtt_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    30559 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/node.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2421 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/portnums_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3739 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/remote_hardware.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2032 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/remote_hardware_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1494 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/rtttl_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2566 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/serial_interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4719 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/storeforward_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7812 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/stream_interface.py
│ │ +-rwxr-xr-x   0 runner    (1001) docker     (123)     6140 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/supported_device.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2334 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/tcp_interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5054 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/telemetry_pb2.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5960 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/test.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8249 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/tunnel.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    19869 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/util.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-04-06 14:20:27.000000 meshtastic-2.1.5/meshtastic/xmodem_pb2.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-06 14:20:40.360386 meshtastic-2.1.5/meshtastic.egg-info/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2319 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/entry_points.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      218 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/requires.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       11 2023-04-06 14:20:40.000000 meshtastic-2.1.5/meshtastic.egg-info/top_level.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-06 14:20:40.360386 meshtastic-2.1.5/setup.cfg
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-04-06 14:20:27.000000 meshtastic-2.1.5/setup.py
│ │   --- meshtastic-2.1.4/LICENSE.txt
│ ├── +++ meshtastic-2.1.5/LICENSE.txt
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/PKG-INFO
│ ├── +++ meshtastic-2.1.5/PKG-INFO
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: meshtastic
│ │ -Version: 2.1.4
│ │ +Version: 2.1.5
│ │  Summary: Python API & client shell for talking to Meshtastic devices
│ │  Home-page: https://github.com/meshtastic/python
│ │  Author: Meshtastic Developers
│ │  Author-email: contact@meshtastic.org
│ │  License: GPL-3.0-only
│ │  Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
│ │  Classifier: Development Status :: 4 - Beta
│ │   --- meshtastic-2.1.4/README.md
│ ├── +++ meshtastic-2.1.5/README.md
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/__init__.py
│ ├── +++ meshtastic-2.1.5/meshtastic/__init__.py
│ │┄ Files 7% similar despite different names
│ │ @@ -58,41 +58,50 @@
│ │  
│ │  import base64
│ │  import logging
│ │  import os
│ │  import platform
│ │  import random
│ │  import socket
│ │ -import sys
│ │  import stat
│ │ +import sys
│ │  import threading
│ │ -import traceback
│ │  import time
│ │ +import traceback
│ │  from datetime import datetime
│ │  from typing import *
│ │ +
│ │ +import google.protobuf.json_format
│ │  import serial
│ │  import timeago
│ │ -import google.protobuf.json_format
│ │ -from pubsub import pub
│ │  from dotmap import DotMap
│ │ -from tabulate import tabulate
│ │  from google.protobuf.json_format import MessageToJson
│ │ -from meshtastic.util import fixme, catchAndIgnore, stripnl, DeferredExecution, Timeout
│ │ -from meshtastic.node import Node
│ │ -from meshtastic import (mesh_pb2, portnums_pb2, apponly_pb2, admin_pb2,
│ │ -                        telemetry_pb2, remote_hardware_pb2,
│ │ -                        channel_pb2, config_pb2, util)
│ │ +from pubsub import pub
│ │ +from tabulate import tabulate
│ │  
│ │ +from meshtastic import (
│ │ +    admin_pb2,
│ │ +    apponly_pb2,
│ │ +    channel_pb2,
│ │ +    config_pb2,
│ │ +    mesh_pb2,
│ │ +    portnums_pb2,
│ │ +    remote_hardware_pb2,
│ │ +    telemetry_pb2,
│ │ +    util,
│ │ +)
│ │ +from meshtastic.node import Node
│ │ +from meshtastic.util import DeferredExecution, Timeout, catchAndIgnore, fixme, stripnl
│ │  
│ │  # Note: To follow PEP224, comments should be after the module variable.
│ │  
│ │  LOCAL_ADDR = "^local"
│ │  """A special ID that means the local node"""
│ │  
│ │ -BROADCAST_NUM = 0xffffffff
│ │ +BROADCAST_NUM = 0xFFFFFFFF
│ │  """if using 8 bit nodenums this will be shortend on the target"""
│ │  
│ │  BROADCAST_ADDR = "^all"
│ │  """A special ID that means broadcast"""
│ │  
│ │  OUR_APP_VERSION = 20300
│ │  """The numeric buildnumber (shared with android apps) specifying the
│ │ @@ -102,21 +111,23 @@
│ │  """
│ │  
│ │  publishingThread = DeferredExecution("publishing")
│ │  
│ │  
│ │  class ResponseHandler(NamedTuple):
│ │      """A pending response callback, waiting for a response to one of our messages"""
│ │ +
│ │      # requestId: int - used only as a key
│ │      callback: Callable
│ │      # FIXME, add timestamp and age out old requests
│ │  
│ │  
│ │  class KnownProtocol(NamedTuple):
│ │      """Used to automatically decode known protocol payloads"""
│ │ +
│ │      name: str
│ │      # portnum: int, now a key
│ │      # If set, will be called to prase as a protocol buffer
│ │      protobufFactory: Callable = None
│ │      # If set, invoked as onReceive(interface, packet)
│ │      onReceive: Callable = None
│ │  
│ │ @@ -125,41 +136,41 @@
│ │      """Special text auto parsing for received messages"""
│ │      # We don't throw if the utf8 is invalid in the text message.  Instead we just don't populate
│ │      # the decoded.data.text and we log an error message.  This at least allows some delivery to
│ │      # the app and the app can deal with the missing decoded representation.
│ │      #
│ │      # Usually btw this problem is caused by apps sending binary data but setting the payload type to
│ │      # text.
│ │ -    logging.debug(f'in _onTextReceive() asDict:{asDict}')
│ │ +    logging.debug(f"in _onTextReceive() asDict:{asDict}")
│ │      try:
│ │          asBytes = asDict["decoded"]["payload"]
│ │          asDict["decoded"]["text"] = asBytes.decode("utf-8")
│ │      except Exception as ex:
│ │          logging.error(f"Malformatted utf8 in text message: {ex}")
│ │      _receiveInfoUpdate(iface, asDict)
│ │  
│ │  
│ │  def _onPositionReceive(iface, asDict):
│ │      """Special auto parsing for received messages"""
│ │ -    logging.debug(f'in _onPositionReceive() asDict:{asDict}')
│ │ -    if 'decoded' in asDict:
│ │ -        if 'position' in asDict['decoded'] and 'from' in asDict:
│ │ +    logging.debug(f"in _onPositionReceive() asDict:{asDict}")
│ │ +    if "decoded" in asDict:
│ │ +        if "position" in asDict["decoded"] and "from" in asDict:
│ │              p = asDict["decoded"]["position"]
│ │ -            logging.debug(f'p:{p}')
│ │ +            logging.debug(f"p:{p}")
│ │              p = iface._fixupPosition(p)
│ │ -            logging.debug(f'after fixup p:{p}')
│ │ +            logging.debug(f"after fixup p:{p}")
│ │              # update node DB as needed
│ │              iface._getOrCreateByNum(asDict["from"])["position"] = p
│ │  
│ │  
│ │  def _onNodeInfoReceive(iface, asDict):
│ │      """Special auto parsing for received messages"""
│ │ -    logging.debug(f'in _onNodeInfoReceive() asDict:{asDict}')
│ │ -    if 'decoded' in asDict:
│ │ -        if 'user' in asDict['decoded'] and 'from' in asDict:
│ │ +    logging.debug(f"in _onNodeInfoReceive() asDict:{asDict}")
│ │ +    if "decoded" in asDict:
│ │ +        if "user" in asDict["decoded"] and "from" in asDict:
│ │              p = asDict["decoded"]["user"]
│ │              # decode user protobufs and update nodedb, provide decoded version as "position" in the published msg
│ │              # update node DB as needed
│ │              n = iface._getOrCreateByNum(asDict["from"])
│ │              n["user"] = p
│ │              # We now have a node ID, make sure it is uptodate in that table
│ │              iface.nodes[p["id"]] = n
│ │ @@ -172,17 +183,29 @@
│ │          iface._getOrCreateByNum(asDict["from"])["lastHeard"] = asDict.get("rxTime")
│ │          iface._getOrCreateByNum(asDict["from"])["snr"] = asDict.get("rxSnr")
│ │          iface._getOrCreateByNum(asDict["from"])["hopLimit"] = asDict.get("hopLimit")
│ │  
│ │  
│ │  """Well known message payloads can register decoders for automatic protobuf parsing"""
│ │  protocols = {
│ │ -    portnums_pb2.PortNum.TEXT_MESSAGE_APP: KnownProtocol("text", onReceive=_onTextReceive),
│ │ -    portnums_pb2.PortNum.POSITION_APP: KnownProtocol("position", mesh_pb2.Position, _onPositionReceive),
│ │ -    portnums_pb2.PortNum.NODEINFO_APP: KnownProtocol("user", mesh_pb2.User, _onNodeInfoReceive),
│ │ +    portnums_pb2.PortNum.TEXT_MESSAGE_APP: KnownProtocol(
│ │ +        "text", onReceive=_onTextReceive
│ │ +    ),
│ │ +    portnums_pb2.PortNum.POSITION_APP: KnownProtocol(
│ │ +        "position", mesh_pb2.Position, _onPositionReceive
│ │ +    ),
│ │ +    portnums_pb2.PortNum.NODEINFO_APP: KnownProtocol(
│ │ +        "user", mesh_pb2.User, _onNodeInfoReceive
│ │ +    ),
│ │      portnums_pb2.PortNum.ADMIN_APP: KnownProtocol("admin", admin_pb2.AdminMessage),
│ │      portnums_pb2.PortNum.ROUTING_APP: KnownProtocol("routing", mesh_pb2.Routing),
│ │ -    portnums_pb2.PortNum.TELEMETRY_APP: KnownProtocol("telemetry", telemetry_pb2.Telemetry),
│ │ -    portnums_pb2.PortNum.REMOTE_HARDWARE_APP: KnownProtocol("remotehw", remote_hardware_pb2.HardwareMessage),
│ │ +    portnums_pb2.PortNum.TELEMETRY_APP: KnownProtocol(
│ │ +        "telemetry", telemetry_pb2.Telemetry
│ │ +    ),
│ │ +    portnums_pb2.PortNum.REMOTE_HARDWARE_APP: KnownProtocol(
│ │ +        "remotehw", remote_hardware_pb2.HardwareMessage
│ │ +    ),
│ │      portnums_pb2.PortNum.SIMULATOR_APP: KnownProtocol("simulator", mesh_pb2.Compressed),
│ │ -    portnums_pb2.PortNum.TRACEROUTE_APP: KnownProtocol("traceroute", mesh_pb2.RouteDiscovery)
│ │ +    portnums_pb2.PortNum.TRACEROUTE_APP: KnownProtocol(
│ │ +        "traceroute", mesh_pb2.RouteDiscovery
│ │ +    ),
│ │  }
│ │   --- meshtastic-2.1.4/meshtastic/__main__.py
│ ├── +++ meshtastic-2.1.5/meshtastic/__main__.py
│ │┄ Files 12% similar despite different names
│ │ @@ -1,73 +1,80 @@
│ │  #!python3
│ │  """ Main Meshtastic
│ │  """
│ │  
│ │  import argparse
│ │ -import platform
│ │  import logging
│ │  import os
│ │ +import platform
│ │  import sys
│ │  import time
│ │ -import yaml
│ │ -from pubsub import pub
│ │ -import pyqrcode
│ │ +
│ │  import pkg_resources
│ │ +import pyqrcode
│ │ +import yaml
│ │  from google.protobuf.json_format import MessageToDict
│ │ -import meshtastic.util
│ │ +from pubsub import pub
│ │ +
│ │  import meshtastic.test
│ │ -from meshtastic import remote_hardware
│ │ +import meshtastic.util
│ │ +from meshtastic import channel_pb2, config_pb2, portnums_pb2, remote_hardware
│ │ +from meshtastic.__init__ import BROADCAST_ADDR
│ │  from meshtastic.ble_interface import BLEInterface
│ │ -from meshtastic import portnums_pb2, channel_pb2, config_pb2
│ │  from meshtastic.globals import Globals
│ │ -from meshtastic.__init__ import BROADCAST_ADDR
│ │ +
│ │  
│ │  def onReceive(packet, interface):
│ │      """Callback invoked when a packet arrives"""
│ │      our_globals = Globals.getInstance()
│ │      args = our_globals.get_args()
│ │      try:
│ │ -        d = packet.get('decoded')
│ │ -        logging.debug(f'in onReceive() d:{d}')
│ │ +        d = packet.get("decoded")
│ │ +        logging.debug(f"in onReceive() d:{d}")
│ │  
│ │          # Exit once we receive a reply
│ │ -        if args and args.sendtext and packet["to"] == interface.myInfo.my_node_num and d["portnum"] == portnums_pb2.PortNum.TEXT_MESSAGE_APP:
│ │ +        if (
│ │ +            args
│ │ +            and args.sendtext
│ │ +            and packet["to"] == interface.myInfo.my_node_num
│ │ +            and d["portnum"] == portnums_pb2.PortNum.TEXT_MESSAGE_APP
│ │ +        ):
│ │              interface.close()  # after running command then exit
│ │  
│ │          # Reply to every received message with some stats
│ │          if args and args.reply:
│ │ -            msg = d.get('text')
│ │ +            msg = d.get("text")
│ │              if msg:
│ │ -                rxSnr = packet['rxSnr']
│ │ -                hopLimit = packet['hopLimit']
│ │ +                rxSnr = packet["rxSnr"]
│ │ +                hopLimit = packet["hopLimit"]
│ │                  print(f"message: {msg}")
│ │ -                reply = f"got msg \'{msg}\' with rxSnr: {rxSnr} and hopLimit: {hopLimit}"
│ │ +                reply = f"got msg '{msg}' with rxSnr: {rxSnr} and hopLimit: {hopLimit}"
│ │                  print("Sending reply: ", reply)
│ │                  interface.sendText(reply)
│ │  
│ │      except Exception as ex:
│ │ -        print(f'Warning: There is no field {ex} in the packet.')
│ │ +        print(f"Warning: There is no field {ex} in the packet.")
│ │  
│ │  
│ │ -def onConnection(interface, topic=pub.AUTO_TOPIC): # pylint: disable=W0613
│ │ +def onConnection(interface, topic=pub.AUTO_TOPIC):  # pylint: disable=W0613
│ │      """Callback invoked when we connect/disconnect from a radio"""
│ │      print(f"Connection changed: {topic.getName()}")
│ │  
│ │  
│ │  def getPref(node, comp_name):
│ │      """Get a channel or preferences value"""
│ │  
│ │      name = splitCompoundName(comp_name)
│ │ -    wholeField = name[0] == name[1] # We want the whole field
│ │ +    wholeField = name[0] == name[1]  # We want the whole field
│ │  
│ │      camel_name = meshtastic.util.snake_to_camel(name[1])
│ │      # Note: protobufs has the keys in snake_case, so snake internally
│ │      snake_name = meshtastic.util.camel_to_snake(name[1])
│ │ -    logging.debug(f'snake_name:{snake_name} camel_name:{camel_name}')
│ │ -    logging.debug(f'use camel:{Globals.getInstance().get_camel_case()}')
│ │ +    logging.debug(f"snake_name:{snake_name} camel_name:{camel_name}")
│ │ +    logging.debug(f"use camel:{Globals.getInstance().get_camel_case()}")
│ │  
│ │      # First validate the input
│ │      localConfig = node.localConfig
│ │      moduleConfig = node.moduleConfig
│ │      found = False
│ │      for config in [localConfig, moduleConfig]:
│ │          objDesc = config.DESCRIPTOR
│ │ @@ -75,105 +82,119 @@
│ │          pref = False
│ │          if config_type:
│ │              pref = config_type.message_type.fields_by_name.get(snake_name)
│ │              if pref or wholeField:
│ │                  found = True
│ │                  break
│ │  
│ │ -    if not found: 
│ │ +    if not found:
│ │          if Globals.getInstance().get_camel_case():
│ │ -            print(f"{localConfig.__class__.__name__} and {moduleConfig.__class__.__name__} do not have an attribute {snake_name}.")
│ │ +            print(
│ │ +                f"{localConfig.__class__.__name__} and {moduleConfig.__class__.__name__} do not have an attribute {snake_name}."
│ │ +            )
│ │          else:
│ │ -            print(f"{localConfig.__class__.__name__} and {moduleConfig.__class__.__name__} do not have attribute {snake_name}.")
│ │ +            print(
│ │ +                f"{localConfig.__class__.__name__} and {moduleConfig.__class__.__name__} do not have attribute {snake_name}."
│ │ +            )
│ │          print("Choices are...")
│ │          printConfig(localConfig)
│ │          printConfig(moduleConfig)
│ │          return False
│ │  
│ │ -    # Check if we need to request the config 
│ │ +    # Check if we need to request the config
│ │      if len(config.ListFields()) != 0:
│ │          # read the value
│ │          config_values = getattr(config, config_type.name)
│ │          if not wholeField:
│ │              pref_value = getattr(config_values, pref.name)
│ │              if Globals.getInstance().get_camel_case():
│ │                  print(f"{str(config_type.name)}.{camel_name}: {str(pref_value)}")
│ │ -                logging.debug(f"{str(config_type.name)}.{camel_name}: {str(pref_value)}")
│ │ +                logging.debug(
│ │ +                    f"{str(config_type.name)}.{camel_name}: {str(pref_value)}"
│ │ +                )
│ │              else:
│ │                  print(f"{str(config_type.name)}.{snake_name}: {str(pref_value)}")
│ │ -                logging.debug(f"{str(config_type.name)}.{snake_name}: {str(pref_value)}")
│ │ +                logging.debug(
│ │ +                    f"{str(config_type.name)}.{snake_name}: {str(pref_value)}"
│ │ +                )
│ │          else:
│ │              print(f"{str(config_type.name)}:\n{str(config_values)}")
│ │              logging.debug(f"{str(config_type.name)}: {str(config_values)}")
│ │ -    else: 
│ │ +    else:
│ │          # Always show whole field for remote node
│ │          node.requestConfig(config_type)
│ │ -        
│ │ +
│ │      return True
│ │  
│ │ +
│ │  def splitCompoundName(comp_name):
│ │      """Split compound (dot separated) preference name into parts"""
│ │ -    name = comp_name.split(".",1)
│ │ +    name = comp_name.split(".", 1)
│ │      if len(name) != 2:
│ │ -        name[0]=comp_name
│ │ +        name[0] = comp_name
│ │          name.append(comp_name)
│ │      return name
│ │  
│ │ +
│ │  def setPref(config, comp_name, valStr):
│ │      """Set a channel or preferences value"""
│ │  
│ │      name = splitCompoundName(comp_name)
│ │  
│ │      snake_name = meshtastic.util.camel_to_snake(name[1])
│ │      camel_name = meshtastic.util.snake_to_camel(name[1])
│ │ -    logging.debug(f'snake_name:{snake_name}')
│ │ -    logging.debug(f'camel_name:{camel_name}')
│ │ +    logging.debug(f"snake_name:{snake_name}")
│ │ +    logging.debug(f"camel_name:{camel_name}")
│ │  
│ │      objDesc = config.DESCRIPTOR
│ │      config_type = objDesc.fields_by_name.get(name[0])
│ │      pref = False
│ │      if config_type and config_type.message_type is not None:
│ │          pref = config_type.message_type.fields_by_name.get(snake_name)
│ │      # Others like ChannelSettings are standalone
│ │      elif config_type:
│ │          pref = config_type
│ │  
│ │      if (not pref) or (not config_type):
│ │          return False
│ │  
│ │      val = meshtastic.util.fromStr(valStr)
│ │ -    logging.debug(f'valStr:{valStr} val:{val}')
│ │ +    logging.debug(f"valStr:{valStr} val:{val}")
│ │  
│ │ -    if snake_name == 'psk' and len(valStr) < 8:
│ │ +    if snake_name == "psk" and len(valStr) < 8:
│ │          print(f"Warning: wifi.psk must be 8 or more characters.")
│ │          return False
│ │  
│ │      enumType = pref.enum_type
│ │      # pylint: disable=C0123
│ │      if enumType and type(val) == str:
│ │          # We've failed so far to convert this string into an enum, try to find it by reflection
│ │          e = enumType.values_by_name.get(val)
│ │          if e:
│ │              val = e.number
│ │          else:
│ │              if Globals.getInstance().get_camel_case():
│ │ -                print(f"{name[0]}.{camel_name} does not have an enum called {val}, so you can not set it.")
│ │ +                print(
│ │ +                    f"{name[0]}.{camel_name} does not have an enum called {val}, so you can not set it."
│ │ +                )
│ │              else:
│ │ -                print(f"{name[0]}.{snake_name} does not have an enum called {val}, so you can not set it.")
│ │ +                print(
│ │ +                    f"{name[0]}.{snake_name} does not have an enum called {val}, so you can not set it."
│ │ +                )
│ │              print(f"Choices in sorted order are:")
│ │              names = []
│ │              for f in enumType.values:
│ │                  # Note: We must use the value of the enum (regardless if camel or snake case)
│ │ -                names.append(f'{f.name}')
│ │ +                names.append(f"{f.name}")
│ │              for temp_name in sorted(names):
│ │                  print(f"    {temp_name}")
│ │              return False
│ │  
│ │      # note: 'ignore_incoming' is a repeating field
│ │ -    if snake_name != 'ignore_incoming':
│ │ +    if snake_name != "ignore_incoming":
│ │          try:
│ │              if config_type.message_type is not None:
│ │                  config_values = getattr(config, config_type.name)
│ │                  setattr(config_values, pref.name, val)
│ │              else:
│ │                  setattr(config, snake_name, val)
│ │          except TypeError:
│ │ @@ -197,15 +218,17 @@
│ │  
│ │      return True
│ │  
│ │  
│ │  def onConnected(interface):
│ │      """Callback invoked when we connect to a radio"""
│ │      closeNow = False  # Should we drop the connection after we finish?
│ │ -    waitForAckNak = False  # Should we wait for an acknowledgment if we send to a remote node?
│ │ +    waitForAckNak = (
│ │ +        False  # Should we wait for an acknowledgment if we send to a remote node?
│ │ +    )
│ │      try:
│ │          our_globals = Globals.getInstance()
│ │          args = our_globals.get_args()
│ │  
│ │          # do not print this line if we are exporting the config
│ │          if not args.export_config:
│ │              print("Connected to radio")
│ │ @@ -230,37 +253,41 @@
│ │                  lon = float(args.setlon)
│ │                  localConfig.position.fixed_position = True
│ │                  print(f"Fixing longitude at {lon} degrees")
│ │  
│ │              print("Setting device position")
│ │              # can include lat/long/alt etc: latitude = 37.5, longitude = -122.1
│ │              interface.sendPosition(lat, lon, alt)
│ │ -            interface.localNode.writeConfig('position')
│ │ +            interface.localNode.writeConfig("position")
│ │          elif not args.no_time:
│ │              # We normally provide a current time to the mesh when we connect
│ │              interface.sendPosition()
│ │  
│ │          if args.set_owner:
│ │              closeNow = True
│ │              waitForAckNak = True
│ │              print(f"Setting device owner to {args.set_owner}")
│ │              interface.getNode(args.dest, False).setOwner(args.set_owner)
│ │  
│ │          if args.set_owner_short:
│ │              closeNow = True
│ │              waitForAckNak = True
│ │              print(f"Setting device owner short to {args.set_owner_short}")
│ │ -            interface.getNode(args.dest, False).setOwner(long_name=None, short_name=args.set_owner_short)
│ │ +            interface.getNode(args.dest, False).setOwner(
│ │ +                long_name=None, short_name=args.set_owner_short
│ │ +            )
│ │  
│ │          # TODO: add to export-config and configure
│ │          if args.set_canned_message:
│ │              closeNow = True
│ │              waitForAckNak = True
│ │              print(f"Setting canned plugin message to {args.set_canned_message}")
│ │ -            interface.getNode(args.dest, False).set_canned_message(args.set_canned_message)
│ │ +            interface.getNode(args.dest, False).set_canned_message(
│ │ +                args.set_canned_message
│ │ +            )
│ │  
│ │          # TODO: add to export-config and configure
│ │          if args.set_ringtone:
│ │              closeNow = True
│ │              waitForAckNak = True
│ │              print(f"Setting ringtone to {args.set_ringtone}")
│ │              interface.getNode(args.dest, False).set_ringtone(args.set_ringtone)
│ │ @@ -275,32 +302,34 @@
│ │                  for field in args.pos_fields:
│ │                      v_field = positionConfig.PositionFlags.Value(field)
│ │                      allFields |= v_field
│ │  
│ │              except ValueError:
│ │                  print("ERROR: supported position fields are:")
│ │                  print(positionConfig.PositionFlags.keys())
│ │ -                print("If no fields are specified, will read and display current value.")
│ │ +                print(
│ │ +                    "If no fields are specified, will read and display current value."
│ │ +                )
│ │  
│ │              else:
│ │                  print(f"Setting position fields to {allFields}")
│ │ -                setPref(positionConfig, 'position_flags', f'{allFields:d}')
│ │ +                setPref(positionConfig, "position_flags", f"{allFields:d}")
│ │                  print("Writing modified preferences to device")
│ │ -                interface.getNode(args.dest).writeConfig('position')
│ │ +                interface.getNode(args.dest).writeConfig("position")
│ │  
│ │          elif args.pos_fields is not None:
│ │              # If --pos-fields invoked without args, read and display current value
│ │              closeNow = True
│ │              positionConfig = interface.getNode(args.dest).localConfig.position
│ │  
│ │              fieldNames = []
│ │              for bit in positionConfig.PositionFlags.values():
│ │                  if positionConfig.position_flags & bit:
│ │                      fieldNames.append(positionConfig.PositionFlags.Name(bit))
│ │ -            print(' '.join(fieldNames))
│ │ +            print(" ".join(fieldNames))
│ │  
│ │          if args.set_ham:
│ │              closeNow = True
│ │              print(f"Setting Ham ID to {args.set_ham} and turning off encryption")
│ │              interface.getNode(args.dest).setOwner(args.set_ham, is_licensed=True)
│ │              # Must turn off encryption on primary channel
│ │              interface.getNode(args.dest).turnOffEncryptionOnPrimaryChannel()
│ │ @@ -344,65 +373,80 @@
│ │  
│ │          if args.sendtext:
│ │              closeNow = True
│ │              channelIndex = 0
│ │              if args.ch_index is not None:
│ │                  channelIndex = int(args.ch_index)
│ │              ch = interface.localNode.getChannelByChannelIndex(channelIndex)
│ │ -            logging.debug(f'ch:{ch}')
│ │ +            logging.debug(f"ch:{ch}")
│ │              if ch and ch.role != channel_pb2.Channel.Role.DISABLED:
│ │ -                print(f"Sending text message {args.sendtext} to {args.dest} on channelIndex:{channelIndex}")
│ │ -                interface.sendText(args.sendtext, args.dest, wantAck=True, channelIndex=channelIndex)
│ │ +                print(
│ │ +                    f"Sending text message {args.sendtext} to {args.dest} on channelIndex:{channelIndex}"
│ │ +                )
│ │ +                interface.sendText(
│ │ +                    args.sendtext, args.dest, wantAck=True, channelIndex=channelIndex
│ │ +                )
│ │              else:
│ │ -                meshtastic.util.our_exit(f"Warning: {channelIndex} is not a valid channel. Channel must not be DISABLED.")
│ │ +                meshtastic.util.our_exit(
│ │ +                    f"Warning: {channelIndex} is not a valid channel. Channel must not be DISABLED."
│ │ +                )
│ │  
│ │          if args.sendping:
│ │              payload = str.encode("test string")
│ │              print(f"Sending ping message to {args.dest}")
│ │ -            interface.sendData(payload, args.dest, portNum=portnums_pb2.PortNum.REPLY_APP,
│ │ -                               wantAck=True, wantResponse=True)
│ │ +            interface.sendData(
│ │ +                payload,
│ │ +                args.dest,
│ │ +                portNum=portnums_pb2.PortNum.REPLY_APP,
│ │ +                wantAck=True,
│ │ +                wantResponse=True,
│ │ +            )
│ │  
│ │          if args.traceroute:
│ │ -            loraConfig = getattr(interface.localNode.localConfig, 'lora')
│ │ -            hopLimit = getattr(loraConfig, 'hop_limit')
│ │ +            loraConfig = getattr(interface.localNode.localConfig, "lora")
│ │ +            hopLimit = getattr(loraConfig, "hop_limit")
│ │              dest = str(args.traceroute)
│ │              print(f"Sending traceroute request to {dest} (this could take a while)")
│ │              interface.sendTraceRoute(dest, hopLimit)
│ │  
│ │          if args.gpio_wrb or args.gpio_rd or args.gpio_watch:
│ │              if args.dest == BROADCAST_ADDR:
│ │                  meshtastic.util.our_exit("Warning: Must use a destination node ID.")
│ │              else:
│ │                  rhc = remote_hardware.RemoteHardwareClient(interface)
│ │  
│ │                  if args.gpio_wrb:
│ │                      bitmask = 0
│ │                      bitval = 0
│ │ -                    for wrpair in (args.gpio_wrb or []):
│ │ +                    for wrpair in args.gpio_wrb or []:
│ │                          bitmask |= 1 << int(wrpair[0])
│ │                          bitval |= int(wrpair[1]) << int(wrpair[0])
│ │ -                    print(f"Writing GPIO mask 0x{bitmask:x} with value 0x{bitval:x} to {args.dest}")
│ │ +                    print(
│ │ +                        f"Writing GPIO mask 0x{bitmask:x} with value 0x{bitval:x} to {args.dest}"
│ │ +                    )
│ │                      rhc.writeGPIOs(args.dest, bitmask, bitval)
│ │                      closeNow = True
│ │  
│ │                  if args.gpio_rd:
│ │                      bitmask = int(args.gpio_rd, 16)
│ │                      print(f"Reading GPIO mask 0x{bitmask:x} from {args.dest}")
│ │                      interface.mask = bitmask
│ │                      rhc.readGPIOs(args.dest, bitmask, None)
│ │                      # wait up to X seconds for a response
│ │                      for _ in range(10):
│ │                          time.sleep(1)
│ │                          if interface.gotResponse:
│ │                              break
│ │ -                    logging.debug(f'end of gpio_rd')
│ │ +                    logging.debug(f"end of gpio_rd")
│ │  
│ │                  if args.gpio_watch:
│ │                      bitmask = int(args.gpio_watch, 16)
│ │ -                    print(f"Watching GPIO mask 0x{bitmask:x} from {args.dest}. Press ctrl-c to exit")
│ │ +                    print(
│ │ +                        f"Watching GPIO mask 0x{bitmask:x} from {args.dest}. Press ctrl-c to exit"
│ │ +                    )
│ │                      while True:
│ │                          rhc.watchGPIOs(args.dest, bitmask)
│ │                          time.sleep(1)
│ │  
│ │          # handle settings
│ │          if args.set:
│ │              closeNow = True
│ │ @@ -414,96 +458,122 @@
│ │              for pref in args.set:
│ │                  found = False
│ │                  field = splitCompoundName(pref[0].lower())[0]
│ │                  for config in [node.localConfig, node.moduleConfig]:
│ │                      config_type = config.DESCRIPTOR.fields_by_name.get(field)
│ │                      if config_type:
│ │                          if len(config.ListFields()) == 0:
│ │ -                            node.requestConfig(config.DESCRIPTOR.fields_by_name.get(field))
│ │ +                            node.requestConfig(
│ │ +                                config.DESCRIPTOR.fields_by_name.get(field)
│ │ +                            )
│ │                          found = setPref(config, pref[0], pref[1])
│ │                          if found:
│ │                              break
│ │  
│ │              if found:
│ │                  print("Writing modified preferences to device")
│ │                  node.writeConfig(field)
│ │              else:
│ │                  if Globals.getInstance().get_camel_case():
│ │ -                    print(f"{node.localConfig.__class__.__name__} and {node.moduleConfig.__class__.__name__} do not have an attribute {pref[0]}.")
│ │ +                    print(
│ │ +                        f"{node.localConfig.__class__.__name__} and {node.moduleConfig.__class__.__name__} do not have an attribute {pref[0]}."
│ │ +                    )
│ │                  else:
│ │ -                    print(f"{node.localConfig.__class__.__name__} and {node.moduleConfig.__class__.__name__} do not have attribute {pref[0]}.")
│ │ +                    print(
│ │ +                        f"{node.localConfig.__class__.__name__} and {node.moduleConfig.__class__.__name__} do not have attribute {pref[0]}."
│ │ +                    )
│ │                  print("Choices are...")
│ │                  printConfig(node.localConfig)
│ │                  printConfig(node.moduleConfig)
│ │  
│ │          if args.configure:
│ │ -            with open(args.configure[0], encoding='utf8') as file:
│ │ +            with open(args.configure[0], encoding="utf8") as file:
│ │                  configuration = yaml.safe_load(file)
│ │                  closeNow = True
│ │  
│ │                  interface.getNode(args.dest, False).beginSettingsTransaction()
│ │  
│ │ -                if 'owner' in configuration:
│ │ +                if "owner" in configuration:
│ │                      print(f"Setting device owner to {configuration['owner']}")
│ │                      waitForAckNak = True
│ │ -                    interface.getNode(args.dest, False).setOwner(configuration['owner'])
│ │ +                    interface.getNode(args.dest, False).setOwner(configuration["owner"])
│ │  
│ │ -                if 'owner_short' in configuration:
│ │ -                    print(f"Setting device owner short to {configuration['owner_short']}")
│ │ +                if "owner_short" in configuration:
│ │ +                    print(
│ │ +                        f"Setting device owner short to {configuration['owner_short']}"
│ │ +                    )
│ │                      waitForAckNak = True
│ │ -                    interface.getNode(args.dest, False).setOwner(long_name=None, short_name=configuration['owner_short'])
│ │ -
│ │ -                if 'ownerShort' in configuration:
│ │ -                    print(f"Setting device owner short to {configuration['ownerShort']}")
│ │ +                    interface.getNode(args.dest, False).setOwner(
│ │ +                        long_name=None, short_name=configuration["owner_short"]
│ │ +                    )
│ │ +
│ │ +                if "ownerShort" in configuration:
│ │ +                    print(
│ │ +                        f"Setting device owner short to {configuration['ownerShort']}"
│ │ +                    )
│ │                      waitForAckNak = True
│ │ -                    interface.getNode(args.dest, False).setOwner(long_name=None, short_name=configuration['ownerShort'])
│ │ -
│ │ -                if 'channel_url' in configuration:
│ │ -                    print("Setting channel url to", configuration['channel_url'])
│ │ -                    interface.getNode(args.dest).setURL(configuration['channel_url'])
│ │ +                    interface.getNode(args.dest, False).setOwner(
│ │ +                        long_name=None, short_name=configuration["ownerShort"]
│ │ +                    )
│ │ +
│ │ +                if "channel_url" in configuration:
│ │ +                    print("Setting channel url to", configuration["channel_url"])
│ │ +                    interface.getNode(args.dest).setURL(configuration["channel_url"])
│ │ +
│ │ +                if "channelUrl" in configuration:
│ │ +                    print("Setting channel url to", configuration["channelUrl"])
│ │ +                    interface.getNode(args.dest).setURL(configuration["channelUrl"])
│ │  
│ │ -                if 'channelUrl' in configuration:
│ │ -                    print("Setting channel url to", configuration['channelUrl'])
│ │ -                    interface.getNode(args.dest).setURL(configuration['channelUrl'])
│ │ -
│ │ -                if 'location' in configuration:
│ │ +                if "location" in configuration:
│ │                      alt = 0
│ │                      lat = 0.0
│ │                      lon = 0.0
│ │                      localConfig = interface.localNode.localConfig
│ │  
│ │ -                    if 'alt' in configuration['location']:
│ │ -                        alt = int(configuration['location']['alt'])
│ │ +                    if "alt" in configuration["location"]:
│ │ +                        alt = int(configuration["location"]["alt"])
│ │                          localConfig.position.fixed_position = True
│ │                          print(f"Fixing altitude at {alt} meters")
│ │ -                    if 'lat' in configuration['location']:
│ │ -                        lat = float(configuration['location']['lat'])
│ │ +                    if "lat" in configuration["location"]:
│ │ +                        lat = float(configuration["location"]["lat"])
│ │                          localConfig.position.fixed_position = True
│ │                          print(f"Fixing latitude at {lat} degrees")
│ │ -                    if 'lon' in configuration['location']:
│ │ -                        lon = float(configuration['location']['lon'])
│ │ +                    if "lon" in configuration["location"]:
│ │ +                        lon = float(configuration["location"]["lon"])
│ │                          localConfig.position.fixed_position = True
│ │                          print(f"Fixing longitude at {lon} degrees")
│ │                      print("Setting device position")
│ │                      interface.sendPosition(lat, lon, alt)
│ │ -                    interface.localNode.writeConfig('position')
│ │ +                    interface.localNode.writeConfig("position")
│ │  
│ │ -                if 'config' in configuration:
│ │ +                if "config" in configuration:
│ │                      localConfig = interface.getNode(args.dest).localConfig
│ │ -                    for section in configuration['config']:
│ │ -                        for pref in configuration['config'][section]:
│ │ -                            setPref(localConfig, f"{meshtastic.util.camel_to_snake(section)}.{pref}", str(configuration['config'][section][pref]))
│ │ -                        interface.getNode(args.dest).writeConfig(meshtastic.util.camel_to_snake(section))
│ │ +                    for section in configuration["config"]:
│ │ +                        for pref in configuration["config"][section]:
│ │ +                            setPref(
│ │ +                                localConfig,
│ │ +                                f"{meshtastic.util.camel_to_snake(section)}.{pref}",
│ │ +                                str(configuration["config"][section][pref]),
│ │ +                            )
│ │ +                        interface.getNode(args.dest).writeConfig(
│ │ +                            meshtastic.util.camel_to_snake(section)
│ │ +                        )
│ │  
│ │ -                if 'module_config' in configuration:
│ │ +                if "module_config" in configuration:
│ │                      moduleConfig = interface.getNode(args.dest).moduleConfig
│ │ -                    for section in configuration['module_config']:
│ │ -                        for pref in configuration['module_config'][section]:
│ │ -                            setPref(moduleConfig, f"{meshtastic.util.camel_to_snake(section)}.{pref}", str(configuration['module_config'][section][pref]))
│ │ -                        interface.getNode(args.dest).writeConfig(meshtastic.util.camel_to_snake(section))
│ │ +                    for section in configuration["module_config"]:
│ │ +                        for pref in configuration["module_config"][section]:
│ │ +                            setPref(
│ │ +                                moduleConfig,
│ │ +                                f"{meshtastic.util.camel_to_snake(section)}.{pref}",
│ │ +                                str(configuration["module_config"][section][pref]),
│ │ +                            )
│ │ +                        interface.getNode(args.dest).writeConfig(
│ │ +                            meshtastic.util.camel_to_snake(section)
│ │ +                        )
│ │  
│ │                  interface.getNode(args.dest, False).commitSettingsTransaction()
│ │                  print("Writing modified configuration to device")
│ │  
│ │          if args.export_config:
│ │              # export the configuration (the opposite of '--configure')
│ │              closeNow = True
│ │ @@ -514,19 +584,23 @@
│ │              interface.getNode(args.dest).setURL(args.seturl)
│ │  
│ │          # handle changing channels
│ │  
│ │          if args.ch_add:
│ │              closeNow = True
│ │              if len(args.ch_add) > 10:
│ │ -                meshtastic.util.our_exit("Warning: Channel name must be shorter. Channel not added.")
│ │ +                meshtastic.util.our_exit(
│ │ +                    "Warning: Channel name must be shorter. Channel not added."
│ │ +                )
│ │              n = interface.getNode(args.dest)
│ │              ch = n.getChannelByName(args.ch_add)
│ │              if ch:
│ │ -                meshtastic.util.our_exit(f"Warning: This node already has a '{args.ch_add}' channel. No changes were made.")
│ │ +                meshtastic.util.our_exit(
│ │ +                    f"Warning: This node already has a '{args.ch_add}' channel. No changes were made."
│ │ +                )
│ │              else:
│ │                  # get the first channel that is disabled (i.e., available)
│ │                  ch = n.getDisabledChannel()
│ │                  if not ch:
│ │                      meshtastic.util.our_exit("Warning: No free channels were found")
│ │                  chs = channel_pb2.ChannelSettings()
│ │                  chs.psk = meshtastic.util.genPSK256()
│ │ @@ -537,28 +611,32 @@
│ │                  n.writeChannel(ch.index)
│ │  
│ │          if args.ch_del:
│ │              closeNow = True
│ │  
│ │              channelIndex = our_globals.get_channel_index()
│ │              if channelIndex is None:
│ │ -                meshtastic.util.our_exit("Warning: Need to specify '--ch-index' for '--ch-del'.", 1)
│ │ +                meshtastic.util.our_exit(
│ │ +                    "Warning: Need to specify '--ch-index' for '--ch-del'.", 1
│ │ +                )
│ │              else:
│ │                  if channelIndex == 0:
│ │ -                    meshtastic.util.our_exit("Warning: Cannot delete primary channel.", 1)
│ │ +                    meshtastic.util.our_exit(
│ │ +                        "Warning: Cannot delete primary channel.", 1
│ │ +                    )
│ │                  else:
│ │                      print(f"Deleting channel {channelIndex}")
│ │                      ch = interface.getNode(args.dest).deleteChannel(channelIndex)
│ │  
│ │          def setSimpleConfig(modem_preset):
│ │              """Set one of the simple modem_config"""
│ │              # Overwrite modem_preset
│ │              prefs = interface.getNode(args.dest).localConfig
│ │              prefs.lora.modem_preset = modem_preset
│ │ -            interface.getNode(args.dest).writeConfig('lora')
│ │ +            interface.getNode(args.dest).writeConfig("lora")
│ │  
│ │          # handle the simple radio set commands
│ │          if args.ch_vlongslow:
│ │              setSimpleConfig(config_pb2.Config.LoRaConfig.ModemPreset.VERY_LONG_SLOW)
│ │  
│ │          if args.ch_longslow:
│ │              setSimpleConfig(config_pb2.Config.LoRaConfig.ModemPreset.LONG_SLOW)
│ │ @@ -583,35 +661,39 @@
│ │  
│ │              channelIndex = our_globals.get_channel_index()
│ │              if channelIndex is None:
│ │                  meshtastic.util.our_exit("Warning: Need to specify '--ch-index'.", 1)
│ │              ch = interface.getNode(args.dest).channels[channelIndex]
│ │  
│ │              if args.ch_enable or args.ch_disable:
│ │ -
│ │                  if channelIndex == 0:
│ │ -                    meshtastic.util.our_exit("Warning: Cannot enable/disable PRIMARY channel.")
│ │ +                    meshtastic.util.our_exit(
│ │ +                        "Warning: Cannot enable/disable PRIMARY channel."
│ │ +                    )
│ │  
│ │                  enable = True  # default to enable
│ │                  if args.ch_enable:
│ │                      enable = True
│ │                  if args.ch_disable:
│ │                      enable = False
│ │  
│ │              # Handle the channel settings
│ │ -            for pref in (args.ch_set or []):
│ │ +            for pref in args.ch_set or []:
│ │                  if pref[0] == "psk":
│ │                      ch.settings.psk = meshtastic.util.fromPSK(pref[1])
│ │                  else:
│ │                      setPref(ch.settings, pref[0], pref[1])
│ │                  enable = True  # If we set any pref, assume the user wants to enable the channel
│ │  
│ │              if enable:
│ │ -                ch.role = channel_pb2.Channel.Role.PRIMARY if (
│ │ -                    channelIndex == 0) else channel_pb2.Channel.Role.SECONDARY
│ │ +                ch.role = (
│ │ +                    channel_pb2.Channel.Role.PRIMARY
│ │ +                    if (channelIndex == 0)
│ │ +                    else channel_pb2.Channel.Role.SECONDARY
│ │ +                )
│ │              else:
│ │                  ch.role = channel_pb2.Channel.Role.DISABLED
│ │  
│ │              print(f"Writing modified channels to device")
│ │              interface.getNode(args.dest).writeChannel(channelIndex)
│ │  
│ │          if args.get_canned_message:
│ │ @@ -629,17 +711,25 @@
│ │              # If we aren't trying to talk to our local node, don't show it
│ │              if args.dest == BROADCAST_ADDR:
│ │                  interface.showInfo()
│ │                  print("")
│ │                  interface.getNode(args.dest).showInfo()
│ │                  closeNow = True
│ │                  print("")
│ │ +                pypi_version = meshtastic.util.check_if_newer_version()
│ │ +                if pypi_version:
│ │ +                    print(
│ │ +                        f"*** A newer version v{pypi_version} is available!"
│ │ +                        ' Consider running "pip install --upgrade meshtastic" ***\n'
│ │ +                    )
│ │              else:
│ │                  print("Showing info of remote node is not supported.")
│ │ -                print("Use the '--get' command for a specific configuration (e.g. 'lora') instead.")
│ │ +                print(
│ │ +                    "Use the '--get' command for a specific configuration (e.g. 'lora') instead."
│ │ +                )
│ │  
│ │          if args.get:
│ │              closeNow = True
│ │              node = interface.getNode(args.dest, False)
│ │              for pref in args.get:
│ │                  found = getPref(node, pref[0])
│ │  
│ │ @@ -656,53 +746,58 @@
│ │          if args.qr:
│ │              closeNow = True
│ │              url = interface.localNode.getURL(includeAll=False)
│ │              print(f"Primary channel URL {url}")
│ │              qr = pyqrcode.create(url)
│ │              print(qr.terminal())
│ │  
│ │ -        have_tunnel = platform.system() == 'Linux'
│ │ +        have_tunnel = platform.system() == "Linux"
│ │          if have_tunnel and args.tunnel:
│ │              # pylint: disable=C0415
│ │              from . import tunnel
│ │ +
│ │              # Even if others said we could close, stay open if the user asked for a tunnel
│ │              closeNow = False
│ │              if interface.noProto:
│ │                  logging.warning(f"Not starting Tunnel - disabled by noProto")
│ │              else:
│ │                  tunnel.Tunnel(interface, subnet=args.tunnel_net)
│ │  
│ │          if args.dest != BROADCAST_ADDR and waitForAckNak:
│ │ -            print(f"Waiting for an acknowledgment from remote node (this could take a while)")
│ │ +            print(
│ │ +                f"Waiting for an acknowledgment from remote node (this could take a while)"
│ │ +            )
│ │              interface.getNode(args.dest, False).iface.waitForAckNak()
│ │  
│ │          # if the user didn't ask for serial debugging output, we might want to exit after we've done our operation
│ │          if (not args.seriallog) and closeNow:
│ │              interface.close()  # after running command then exit
│ │  
│ │      except Exception as ex:
│ │          print(f"Aborting due to: {ex}")
│ │          interface.close()  # close the connection now, so that our app exits
│ │  
│ │ +
│ │  def printConfig(config):
│ │      """print configuration"""
│ │      objDesc = config.DESCRIPTOR
│ │      for config_section in objDesc.fields:
│ │          if config_section.name != "version":
│ │              config = objDesc.fields_by_name.get(config_section.name)
│ │              print(f"{config_section.name}:")
│ │              names = []
│ │              for field in config.message_type.fields:
│ │ -                tmp_name = f'{config_section.name}.{field.name}'
│ │ +                tmp_name = f"{config_section.name}.{field.name}"
│ │                  if Globals.getInstance().get_camel_case():
│ │                      tmp_name = meshtastic.util.snake_to_camel(tmp_name)
│ │                  names.append(tmp_name)
│ │              for temp_name in sorted(names):
│ │                  print(f"    {temp_name}")
│ │  
│ │ +
│ │  def onNode(node):
│ │      """Callback invoked when the node DB changes"""
│ │      print(f"Node changed: {node}")
│ │  
│ │  
│ │  def subscribe():
│ │      """Subscribe to the topics the user probably wants to see, prints output to stdout"""
│ │ @@ -719,34 +814,34 @@
│ │      """used in--export-config"""
│ │      configObj = {}
│ │  
│ │      owner = interface.getLongName()
│ │      owner_short = interface.getShortName()
│ │      channel_url = interface.localNode.getURL()
│ │      myinfo = interface.getMyNodeInfo()
│ │ -    pos = myinfo.get('position')
│ │ +    pos = myinfo.get("position")
│ │      lat = None
│ │      lon = None
│ │      alt = None
│ │      if pos:
│ │ -        lat = pos.get('latitude')
│ │ -        lon = pos.get('longitude')
│ │ -        alt = pos.get('altitude')
│ │ +        lat = pos.get("latitude")
│ │ +        lon = pos.get("longitude")
│ │ +        alt = pos.get("altitude")
│ │  
│ │      if owner:
│ │          configObj["owner"] = owner
│ │      if owner_short:
│ │          configObj["owner_short"] = owner_short
│ │      if channel_url:
│ │          if Globals.getInstance().get_camel_case():
│ │              configObj["channelUrl"] = channel_url
│ │          else:
│ │              configObj["channel_url"] = channel_url
│ │      if lat or lon or alt:
│ │ -        configObj["location"] = { "lat": lat, "lon": lon, "alt": alt }
│ │ +        configObj["location"] = {"lat": lat, "lon": lon, "alt": alt}
│ │  
│ │      config = MessageToDict(interface.localNode.localConfig)
│ │      if config:
│ │          # Convert inner keys to correct snake/camelCase
│ │          prefs = {}
│ │          for pref in config:
│ │              if Globals.getInstance().get_camel_case():
│ │ @@ -778,16 +873,18 @@
│ │  
│ │  def common():
│ │      """Shared code for all of our command line wrappers"""
│ │      logfile = None
│ │      our_globals = Globals.getInstance()
│ │      args = our_globals.get_args()
│ │      parser = our_globals.get_parser()
│ │ -    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO,
│ │ -                        format='%(levelname)s file:%(filename)s %(funcName)s line:%(lineno)s %(message)s')
│ │ +    logging.basicConfig(
│ │ +        level=logging.DEBUG if args.debug else logging.INFO,
│ │ +        format="%(levelname)s file:%(filename)s %(funcName)s line:%(lineno)s %(message)s",
│ │ +    )
│ │  
│ │      if len(sys.argv) == 1:
│ │          parser.print_help(sys.stderr)
│ │          meshtastic.util.our_exit("", 1)
│ │      else:
│ │          if args.support:
│ │              meshtastic.util.support_info()
│ │ @@ -804,17 +901,18 @@
│ │              if args.noproto:
│ │                  args.seriallog = "stdout"
│ │              else:
│ │                  args.seriallog = "none"  # assume no debug output in this case
│ │  
│ │          if args.deprecated is not None:
│ │              logging.error(
│ │ -                'This option has been deprecated, see help below for the correct replacement...')
│ │ +                "This option has been deprecated, see help below for the correct replacement..."
│ │ +            )
│ │              parser.print_help(sys.stderr)
│ │ -            meshtastic.util.our_exit('', 1)
│ │ +            meshtastic.util.our_exit("", 1)
│ │          elif args.test:
│ │              result = meshtastic.test.testAll()
│ │              if not result:
│ │                  meshtastic.util.our_exit("Warning: Test was not successful.")
│ │              else:
│ │                  meshtastic.util.our_exit("Test was a success.", 0)
│ │          else:
│ │ @@ -824,39 +922,47 @@
│ │                  args.seriallog = None
│ │                  logging.debug("Not logging serial output")
│ │                  logfile = None
│ │              else:
│ │                  logging.info(f"Logging serial output to {args.seriallog}")
│ │                  # Note: using "line buffering"
│ │                  # pylint: disable=R1732
│ │ -                logfile = open(args.seriallog, 'w+', buffering=1, encoding='utf8')
│ │ +                logfile = open(args.seriallog, "w+", buffering=1, encoding="utf8")
│ │                  our_globals.set_logfile(logfile)
│ │  
│ │              subscribe()
│ │              if args.ble:
│ │                  client = BLEInterface(args.ble, debugOut=logfile, noProto=args.noproto)
│ │              elif args.host:
│ │ -                client = meshtastic.tcp_interface.TCPInterface(args.host, debugOut=logfile, noProto=args.noproto)
│ │ +                client = meshtastic.tcp_interface.TCPInterface(
│ │ +                    args.host, debugOut=logfile, noProto=args.noproto
│ │ +                )
│ │              else:
│ │                  try:
│ │ -                    client = meshtastic.serial_interface.SerialInterface(args.port, debugOut=logfile, noProto=args.noproto)
│ │ +                    client = meshtastic.serial_interface.SerialInterface(
│ │ +                        args.port, debugOut=logfile, noProto=args.noproto
│ │ +                    )
│ │                  except PermissionError as ex:
│ │                      username = os.getlogin()
│ │                      message = "Permission Error:\n"
│ │ -                    message += "  Need to add yourself to the 'dialout' group by running:\n"
│ │ +                    message += (
│ │ +                        "  Need to add yourself to the 'dialout' group by running:\n"
│ │ +                    )
│ │                      message += f"     sudo usermod -a -G dialout {username}\n"
│ │                      message += "  After running that command, log out and re-login for it to take effect.\n"
│ │                      message += f"Error was:{ex}"
│ │                      meshtastic.util.our_exit(message)
│ │  
│ │              # We assume client is fully connected now
│ │              onConnected(client)
│ │  
│ │ -            have_tunnel = platform.system() == 'Linux'
│ │ -            if args.noproto or args.reply or (have_tunnel and args.tunnel):  # loop until someone presses ctrlc
│ │ +            have_tunnel = platform.system() == "Linux"
│ │ +            if (
│ │ +                args.noproto or args.reply or (have_tunnel and args.tunnel)
│ │ +            ):  # loop until someone presses ctrlc
│ │                  while True:
│ │                      time.sleep(1000)
│ │  
│ │          # don't call exit, background threads might be running still
│ │          # sys.exit(0)
│ │  
│ │  
│ │ @@ -865,218 +971,349 @@
│ │      our_globals = Globals.getInstance()
│ │      parser = our_globals.get_parser()
│ │      args = our_globals.get_args()
│ │  
│ │      parser.add_argument(
│ │          "--configure",
│ │          help="Specify a path to a yaml(.yml) file containing the desired settings for the connected device.",
│ │ -        action='append')
│ │ +        action="append",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │          "--export-config",
│ │          help="Export the configuration in yaml(.yml) format.",
│ │ -        action='store_true')
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │          "--port",
│ │          help="The port the Meshtastic device is connected to, i.e. /dev/ttyUSB0. If unspecified, we'll try to find it.",
│ │ -        default=None)
│ │ +        default=None,
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │          "--host",
│ │          help="The hostname/ipaddr of the device to connect to (over TCP)",
│ │ -        default=None)
│ │ +        default=None,
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │          "--seriallog",
│ │ -        help="Log device serial output to either 'stdout', 'none' or a filename to append to.")
│ │ +        help="Log device serial output to either 'stdout', 'none' or a filename to append to.",
│ │ +    )
│ │  
│ │ -    parser.add_argument("--info", help="Read and display the radio config information",
│ │ -                        action="store_true")
│ │ -
│ │ -    parser.add_argument("--get-canned-message", help="Show the canned message plugin message",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--info",
│ │ +        help="Read and display the radio config information",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    parser.add_argument("--get-ringtone", help="Show the stored ringtone",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--get-canned-message",
│ │ +        help="Show the canned message plugin message",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    parser.add_argument("--nodes", help="Print Node List in a pretty formatted table",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--get-ringtone", help="Show the stored ringtone", action="store_true"
│ │ +    )
│ │  
│ │ -    parser.add_argument("--qr", help="Display the QR code that corresponds to the current channel",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--nodes",
│ │ +        help="Print Node List in a pretty formatted table",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--get", help=("Get a preferences field. Use an invalid field such as '0' to get a list of all fields."
│ │ -                       " Can use either snake_case or camelCase format. (ex: 'ls_secs' or 'lsSecs')"),
│ │ -                       nargs=1, action='append')
│ │ +        "--qr",
│ │ +        help="Display the QR code that corresponds to the current channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--set", help="Set a preferences field. Can use either snake_case or camelCase format. (ex: 'ls_secs' or 'lsSecs')", nargs=2, action='append')
│ │ +        "--get",
│ │ +        help=(
│ │ +            "Get a preferences field. Use an invalid field such as '0' to get a list of all fields."
│ │ +            " Can use either snake_case or camelCase format. (ex: 'ls_secs' or 'lsSecs')"
│ │ +        ),
│ │ +        nargs=1,
│ │ +        action="append",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--seturl", help="Set a channel URL", action="store")
│ │ +        "--set",
│ │ +        help="Set a preferences field. Can use either snake_case or camelCase format. (ex: 'ls_secs' or 'lsSecs')",
│ │ +        nargs=2,
│ │ +        action="append",
│ │ +    )
│ │ +
│ │ +    parser.add_argument("--seturl", help="Set a channel URL", action="store")
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-index", help="Set the specified channel index. Channels start at 0 (0 is the PRIMARY channel).", action="store")
│ │ +        "--ch-index",
│ │ +        help="Set the specified channel index. Channels start at 0 (0 is the PRIMARY channel).",
│ │ +        action="store",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-add", help="Add a secondary channel, you must specify a channel name", default=None)
│ │ +        "--ch-add",
│ │ +        help="Add a secondary channel, you must specify a channel name",
│ │ +        default=None,
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-del", help="Delete the ch-index channel", action='store_true')
│ │ +        "--ch-del", help="Delete the ch-index channel", action="store_true"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-enable", help="Enable the specified channel", action="store_true", dest="ch_enable", default=False)
│ │ +        "--ch-enable",
│ │ +        help="Enable the specified channel",
│ │ +        action="store_true",
│ │ +        dest="ch_enable",
│ │ +        default=False,
│ │ +    )
│ │  
│ │      # Note: We are doing a double negative here (Do we want to disable? If ch_disable==True, then disable.)
│ │      parser.add_argument(
│ │ -        "--ch-disable", help="Disable the specified channel", action="store_true", dest="ch_disable", default=False)
│ │ +        "--ch-disable",
│ │ +        help="Disable the specified channel",
│ │ +        action="store_true",
│ │ +        dest="ch_disable",
│ │ +        default=False,
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-set", help=("Set a channel parameter. To see channel settings available:'--ch-set all all --ch-index 0'. "
│ │ -                          "Can set the 'psk' using this command. To disable encryption on primary channel:'--ch-set psk none --ch-index 0'. "
│ │ -                          "To set encryption with a new random key on second channel:'--ch-set psk random --ch-index 1'. "
│ │ -                          "To set encryption back to the default:'--ch-set psk default --ch-index 0'. To set encryption with your "
│ │ -                          "own key: '--ch-set psk 0x1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b --ch-index 0'."),
│ │ -                          nargs=2, action='append')
│ │ +        "--ch-set",
│ │ +        help=(
│ │ +            "Set a channel parameter. To see channel settings available:'--ch-set all all --ch-index 0'. "
│ │ +            "Can set the 'psk' using this command. To disable encryption on primary channel:'--ch-set psk none --ch-index 0'. "
│ │ +            "To set encryption with a new random key on second channel:'--ch-set psk random --ch-index 1'. "
│ │ +            "To set encryption back to the default:'--ch-set psk default --ch-index 0'. To set encryption with your "
│ │ +            "own key: '--ch-set psk 0x1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b1a1a1a1a2b2b2b2b --ch-index 0'."
│ │ +        ),
│ │ +        nargs=2,
│ │ +        action="append",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-vlongslow", help="Change to the very long-range and slow channel", action='store_true')
│ │ +        "--ch-vlongslow",
│ │ +        help="Change to the very long-range and slow channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-longslow", help="Change to the long-range and slow channel", action='store_true')
│ │ +        "--ch-longslow",
│ │ +        help="Change to the long-range and slow channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-longfast", help="Change to the long-range and fast channel", action='store_true')
│ │ +        "--ch-longfast",
│ │ +        help="Change to the long-range and fast channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-medslow", help="Change to the med-range and slow channel", action='store_true')
│ │ +        "--ch-medslow",
│ │ +        help="Change to the med-range and slow channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-medfast", help="Change to the med-range and fast channel", action='store_true')
│ │ +        "--ch-medfast",
│ │ +        help="Change to the med-range and fast channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-shortslow", help="Change to the short-range and slow channel", action='store_true')
│ │ +        "--ch-shortslow",
│ │ +        help="Change to the short-range and slow channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--ch-shortfast", help="Change to the short-range and fast channel", action='store_true')
│ │ +        "--ch-shortfast",
│ │ +        help="Change to the short-range and fast channel",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    parser.add_argument(
│ │ -        "--set-owner", help="Set device owner name", action="store")
│ │ +    parser.add_argument("--set-owner", help="Set device owner name", action="store")
│ │  
│ │      parser.add_argument(
│ │ -        "--set-canned-message", help="Set the canned messages plugin message (up to 200 characters).", action="store")
│ │ +        "--set-canned-message",
│ │ +        help="Set the canned messages plugin message (up to 200 characters).",
│ │ +        action="store",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--set-ringtone", help="Set the Notification Ringtone (up to 230 characters).", action="store")
│ │ +        "--set-ringtone",
│ │ +        help="Set the Notification Ringtone (up to 230 characters).",
│ │ +        action="store",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--set-owner-short", help="Set device owner short name", action="store")
│ │ +        "--set-owner-short", help="Set device owner short name", action="store"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--set-ham", help="Set licensed Ham ID and turn off encryption", action="store")
│ │ +        "--set-ham", help="Set licensed Ham ID and turn off encryption", action="store"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--dest", help="The destination node id for any sent commands, if not set '^all' or '^local' is assumed as appropriate", default=None)
│ │ +        "--dest",
│ │ +        help="The destination node id for any sent commands, if not set '^all' or '^local' is assumed as appropriate",
│ │ +        default=None,
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--sendtext", help="Send a text message. Can specify a destination '--dest' and/or channel index '--ch-index'.")
│ │ +        "--sendtext",
│ │ +        help="Send a text message. Can specify a destination '--dest' and/or channel index '--ch-index'.",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--sendping", help="Send a ping message (which requests a reply)", action="store_true")
│ │ +        "--sendping",
│ │ +        help="Send a ping message (which requests a reply)",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--traceroute", help="Traceroute from connected node to a destination. " \
│ │ -                             "You need pass the destination ID as argument, like " \
│ │ -                             "this: '--traceroute !ba4bf9d0' " \
│ │ -                             "Only nodes that have the encryption key can be traced.")
│ │ +        "--traceroute",
│ │ +        help="Traceroute from connected node to a destination. "
│ │ +        "You need pass the destination ID as argument, like "
│ │ +        "this: '--traceroute !ba4bf9d0' "
│ │ +        "Only nodes that have the encryption key can be traced.",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--reboot", help="Tell the destination node to reboot", action="store_true")
│ │ +        "--reboot", help="Tell the destination node to reboot", action="store_true"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--reboot-ota", help="Tell the destination node to reboot into factory firmware", action="store_true")
│ │ +        "--reboot-ota",
│ │ +        help="Tell the destination node to reboot into factory firmware",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--shutdown", help="Tell the destination node to shutdown", action="store_true")
│ │ +        "--shutdown", help="Tell the destination node to shutdown", action="store_true"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--device-metadata", help="Get the device metadata from the node", action="store_true")
│ │ +        "--device-metadata",
│ │ +        help="Get the device metadata from the node",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--begin-edit", help="Tell the node to open a transaction to edit settings", action="store_true")
│ │ +        "--begin-edit",
│ │ +        help="Tell the node to open a transaction to edit settings",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--commit-edit", help="Tell the node to commit open settings transaction", action="store_true")
│ │ +        "--commit-edit",
│ │ +        help="Tell the node to commit open settings transaction",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--factory-reset", help="Tell the destination node to install the default config", action="store_true")
│ │ +        "--factory-reset",
│ │ +        help="Tell the destination node to install the default config",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--reset-nodedb", help="Tell the destination node clear its list of nodes", action="store_true")
│ │ +        "--reset-nodedb",
│ │ +        help="Tell the destination node clear its list of nodes",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--reply", help="Reply to received messages",
│ │ -        action="store_true")
│ │ +        "--reply", help="Reply to received messages", action="store_true"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--gpio-wrb", nargs=2, help="Set a particular GPIO # to 1 or 0", action='append')
│ │ +        "--gpio-wrb", nargs=2, help="Set a particular GPIO # to 1 or 0", action="append"
│ │ +    )
│ │  
│ │ -    parser.add_argument(
│ │ -        "--gpio-rd", help="Read from a GPIO mask (ex: '0x10')")
│ │ +    parser.add_argument("--gpio-rd", help="Read from a GPIO mask (ex: '0x10')")
│ │  
│ │      parser.add_argument(
│ │ -        "--gpio-watch", help="Start watching a GPIO mask for changes (ex: '0x10')")
│ │ +        "--gpio-watch", help="Start watching a GPIO mask for changes (ex: '0x10')"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--no-time", help="Suppress sending the current time to the mesh", action="store_true")
│ │ +        "--no-time",
│ │ +        help="Suppress sending the current time to the mesh",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    parser.add_argument(
│ │ -        "--setalt", help="Set device altitude (allows use without GPS)")
│ │ +    parser.add_argument("--setalt", help="Set device altitude (allows use without GPS)")
│ │  
│ │ -    parser.add_argument(
│ │ -        "--setlat", help="Set device latitude (allows use without GPS)")
│ │ +    parser.add_argument("--setlat", help="Set device latitude (allows use without GPS)")
│ │  
│ │      parser.add_argument(
│ │ -        "--setlon", help="Set device longitude (allows use without GPS)")
│ │ +        "--setlon", help="Set device longitude (allows use without GPS)"
│ │ +    )
│ │  
│ │      parser.add_argument(
│ │ -        "--pos-fields", help="Specify fields to send when sending a position. Use no argument for a list of valid values. "\
│ │ -                             "Can pass multiple values as a space separated list like "\
│ │ -                             "this: '--pos-fields POS_ALTITUDE POS_ALT_MSL'",
│ │ -        nargs="*", action="store")
│ │ +        "--pos-fields",
│ │ +        help="Specify fields to send when sending a position. Use no argument for a list of valid values. "
│ │ +        "Can pass multiple values as a space separated list like "
│ │ +        "this: '--pos-fields POS_ALTITUDE POS_ALT_MSL'",
│ │ +        nargs="*",
│ │ +        action="store",
│ │ +    )
│ │  
│ │ -    parser.add_argument("--debug", help="Show API library debug log messages",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--debug", help="Show API library debug log messages", action="store_true"
│ │ +    )
│ │  
│ │ -    parser.add_argument("--test", help="Run stress test against all connected Meshtastic devices",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--test",
│ │ +        help="Run stress test against all connected Meshtastic devices",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    parser.add_argument("--ble", help="BLE mac address to connect to (BLE is not yet supported for this tool)",
│ │ -                        default=None)
│ │ +    parser.add_argument(
│ │ +        "--ble",
│ │ +        help="BLE mac address to connect to (BLE is not yet supported for this tool)",
│ │ +        default=None,
│ │ +    )
│ │  
│ │ -    parser.add_argument("--noproto", help="Don't start the API, just function as a dumb serial terminal.",
│ │ -                        action="store_true")
│ │ +    parser.add_argument(
│ │ +        "--noproto",
│ │ +        help="Don't start the API, just function as a dumb serial terminal.",
│ │ +        action="store_true",
│ │ +    )
│ │  
│ │ -    have_tunnel = platform.system() == 'Linux'
│ │ +    have_tunnel = platform.system() == "Linux"
│ │      if have_tunnel:
│ │ -        parser.add_argument('--tunnel', action='store_true',
│ │ -                            help="Create a TUN tunnel device for forwarding IP packets over the mesh")
│ │ -        parser.add_argument("--subnet", dest='tunnel_net',
│ │ -                            help="Sets the local-end subnet address for the TUN IP bridge. (ex: 10.115' which is the default)",
│ │ -                            default=None)
│ │ +        parser.add_argument(
│ │ +            "--tunnel",
│ │ +            action="store_true",
│ │ +            help="Create a TUN tunnel device for forwarding IP packets over the mesh",
│ │ +        )
│ │ +        parser.add_argument(
│ │ +            "--subnet",
│ │ +            dest="tunnel_net",
│ │ +            help="Sets the local-end subnet address for the TUN IP bridge. (ex: 10.115' which is the default)",
│ │ +            default=None,
│ │ +        )
│ │  
│ │      parser.set_defaults(deprecated=None)
│ │  
│ │      the_version = pkg_resources.get_distribution("meshtastic").version
│ │ -    parser.add_argument('--version', action='version', version=f"{the_version}")
│ │ +    parser.add_argument("--version", action="version", version=f"{the_version}")
│ │  
│ │      parser.add_argument(
│ │ -        "--support", action='store_true', help="Show support info (useful when troubleshooting an issue)")
│ │ +        "--support",
│ │ +        action="store_true",
│ │ +        help="Show support info (useful when troubleshooting an issue)",
│ │ +    )
│ │  
│ │      args = parser.parse_args()
│ │      our_globals.set_args(args)
│ │      our_globals.set_parser(parser)
│ │  
│ │  
│ │  def main():
│ │ @@ -1087,15 +1324,14 @@
│ │      initParser()
│ │      common()
│ │      logfile = our_globals.get_logfile()
│ │      if logfile:
│ │          logfile.close()
│ │  
│ │  
│ │ -
│ │  def tunnelMain():
│ │      """Run a meshtastic IP tunnel"""
│ │      our_globals = Globals.getInstance()
│ │      parser = argparse.ArgumentParser()
│ │      our_globals.set_parser(parser)
│ │      initParser()
│ │      args = our_globals.get_args()
│ │   --- meshtastic-2.1.4/meshtastic/admin_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/admin_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/apponly_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/apponly_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/ble_interface.py
│ ├── +++ meshtastic-2.1.5/meshtastic/ble_interface.py
│ │┄ Files 4% similar despite different names
│ │ @@ -2,31 +2,30 @@
│ │  """
│ │  import logging
│ │  import platform
│ │  
│ │  from meshtastic.mesh_interface import MeshInterface
│ │  from meshtastic.util import our_exit
│ │  
│ │ -if platform.system() == 'Linux':
│ │ +if platform.system() == "Linux":
│ │      # pylint: disable=E0401
│ │      import pygatt
│ │  
│ │  
│ │ -
│ │  # Our standard BLE characteristics
│ │  TORADIO_UUID = "f75c76d2-129e-4dad-a1dd-7866124401e7"
│ │  FROMRADIO_UUID = "8ba2bcc2-ee02-4a55-a531-c525c5e454d5"
│ │  FROMNUM_UUID = "ed9da18c-a800-4f66-a670-aa7547e34453"
│ │  
│ │  
│ │  class BLEInterface(MeshInterface):
│ │      """A not quite ready - FIXME - BLE interface to devices"""
│ │  
│ │      def __init__(self, address, noProto=False, debugOut=None):
│ │ -        if platform.system() != 'Linux':
│ │ +        if platform.system() != "Linux":
│ │              our_exit("Linux is the only platform with experimental BLE support.", 1)
│ │          self.address = address
│ │          if not noProto:
│ │              self.adapter = pygatt.GATTToolBackend()  # BGAPIBackend()
│ │              self.adapter.start()
│ │              logging.debug(f"Connecting to {self.address}")
│ │              self.device = self.adapter.connect(address)
│ │ @@ -35,23 +34,23 @@
│ │              self.device = None
│ │          logging.debug("Connected to device")
│ │          # fromradio = self.device.char_read(FROMRADIO_UUID)
│ │          MeshInterface.__init__(self, debugOut=debugOut, noProto=noProto)
│ │  
│ │          self._readFromRadio()  # read the initial responses
│ │  
│ │ -        def handle_data(handle, data): # pylint: disable=W0613
│ │ +        def handle_data(handle, data):  # pylint: disable=W0613
│ │              self._handleFromRadio(data)
│ │  
│ │          if self.device:
│ │              self.device.subscribe(FROMNUM_UUID, callback=handle_data)
│ │  
│ │      def _sendToRadioImpl(self, toRadio):
│ │          """Send a ToRadio protobuf to the device"""
│ │ -        #logging.debug(f"Sending: {stripnl(toRadio)}")
│ │ +        # logging.debug(f"Sending: {stripnl(toRadio)}")
│ │          b = toRadio.SerializeToString()
│ │          self.device.char_write(TORADIO_UUID, b)
│ │  
│ │      def close(self):
│ │          MeshInterface.close(self)
│ │          if self.adapter:
│ │              self.adapter.stop()
│ │   --- meshtastic-2.1.4/meshtastic/cannedmessages_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/cannedmessages_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/channel_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/channel_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/config_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/config_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/connection_status_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/connection_status_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/device_metadata_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/device_metadata_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/deviceonly_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/deviceonly_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/globals.py
│ ├── +++ meshtastic-2.1.5/meshtastic/globals.py
│ │┄ Files 0% similar despite different names
│ │ @@ -4,16 +4,18 @@
│ │     This is not much better than using python's globals, but it allows
│ │     us to better test meshtastic. Plus, there are some weird python
│ │     global issues/gotcha that we can hopefully avoid by using this
│ │     class instead.
│ │  
│ │  """
│ │  
│ │ +
│ │  class Globals:
│ │      """Globals class is a Singleton."""
│ │ +
│ │      __instance = None
│ │  
│ │      @staticmethod
│ │      def getInstance():
│ │          """Get an instance of the Globals class."""
│ │          if Globals.__instance is None:
│ │              Globals()
│ │   --- meshtastic-2.1.4/meshtastic/localonly_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/localonly_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/mesh_interface.py
│ ├── +++ meshtastic-2.1.5/meshtastic/mesh_interface.py
│ │┄ Files 6% similar despite different names
│ │ @@ -1,29 +1,46 @@
│ │  """Mesh Interface class
│ │  """
│ │ -import sys
│ │ -import random
│ │ -import time
│ │ +
│ │ +import collections
│ │  import logging
│ │ -from typing import AnyStr
│ │ +import random
│ │ +import sys
│ │  import threading
│ │ +import time
│ │ +import json
│ │  from datetime import datetime
│ │ -import timeago
│ │ -from tabulate import tabulate
│ │ +from typing import AnyStr
│ │  
│ │  import google.protobuf.json_format
│ │ -
│ │ -from pubsub import pub
│ │ +import timeago
│ │  from google.protobuf.json_format import MessageToJson
│ │ -
│ │ +from pubsub import pub
│ │ +from tabulate import tabulate
│ │  
│ │  import meshtastic.node
│ │ -from meshtastic import portnums_pb2, mesh_pb2
│ │ -from meshtastic.util import stripnl, Timeout, Acknowledgment, our_exit, remove_keys_from_dict, convert_mac_addr
│ │ -from meshtastic.__init__ import LOCAL_ADDR, BROADCAST_NUM, BROADCAST_ADDR, ResponseHandler, publishingThread, OUR_APP_VERSION, protocols
│ │ +from meshtastic import mesh_pb2, portnums_pb2
│ │ +from meshtastic.__init__ import (
│ │ +    BROADCAST_ADDR,
│ │ +    BROADCAST_NUM,
│ │ +    LOCAL_ADDR,
│ │ +    OUR_APP_VERSION,
│ │ +    ResponseHandler,
│ │ +    protocols,
│ │ +    publishingThread,
│ │ +)
│ │ +from meshtastic.util import (
│ │ +    Acknowledgment,
│ │ +    Timeout,
│ │ +    convert_mac_addr,
│ │ +    our_exit,
│ │ +    remove_keys_from_dict,
│ │ +    stripnl,
│ │ +)
│ │ +
│ │  
│ │  class MeshInterface:
│ │      """Interface class for meshtastic devices
│ │  
│ │      Properties:
│ │  
│ │      isConnected
│ │ @@ -41,159 +58,189 @@
│ │          self.debugOut = debugOut
│ │          self.nodes = None  # FIXME
│ │          self.isConnected = threading.Event()
│ │          self.noProto = noProto
│ │          self.localNode = meshtastic.node.Node(self, -1)  # We fixup nodenum later
│ │          self.myInfo = None  # We don't have device info yet
│ │          self.responseHandlers = {}  # A map from request ID to the handler
│ │ -        self.failure = None  # If we've encountered a fatal exception it will be kept here
│ │ +        self.failure = (
│ │ +            None  # If we've encountered a fatal exception it will be kept here
│ │ +        )
│ │          self._timeout = Timeout()
│ │          self._acknowledgment = Acknowledgment()
│ │          self.heartbeatTimer = None
│ │          random.seed()  # FIXME, we should not clobber the random seedval here, instead tell user they must call it
│ │ -        self.currentPacketId = random.randint(0, 0xffffffff)
│ │ +        self.currentPacketId = random.randint(0, 0xFFFFFFFF)
│ │          self.nodesByNum = None
│ │          self.configId = None
│ │ -        self.gotResponse = False # used in gpio read
│ │ -        self.mask = None # used in gpio read and gpio watch
│ │ +        self.gotResponse = False  # used in gpio read
│ │ +        self.mask = None  # used in gpio read and gpio watch
│ │ +        self.queueStatus = None
│ │ +        self.queue = collections.OrderedDict()
│ │  
│ │      def close(self):
│ │          """Shutdown this interface"""
│ │          if self.heartbeatTimer:
│ │              self.heartbeatTimer.cancel()
│ │  
│ │          self._sendDisconnect()
│ │  
│ │      def __enter__(self):
│ │          return self
│ │  
│ │      def __exit__(self, exc_type, exc_value, traceback):
│ │          if exc_type is not None and exc_value is not None:
│ │ -            logging.error(f'An exception of type {exc_type} with value {exc_value} has occurred')
│ │ +            logging.error(
│ │ +                f"An exception of type {exc_type} with value {exc_value} has occurred"
│ │ +            )
│ │          if traceback is not None:
│ │ -            logging.error(f'Traceback: {traceback}')
│ │ +            logging.error(f"Traceback: {traceback}")
│ │          self.close()
│ │  
│ │ -    def showInfo(self, file=sys.stdout): # pylint: disable=W0613
│ │ +    def showInfo(self, file=sys.stdout):  # pylint: disable=W0613
│ │          """Show human readable summary about this object"""
│ │          owner = f"Owner: {self.getLongName()} ({self.getShortName()})"
│ │ -        myinfo = ''
│ │ +        myinfo = ""
│ │          if self.myInfo:
│ │              myinfo = f"\nMy info: {stripnl(MessageToJson(self.myInfo))}"
│ │ -        mesh = "\nNodes in mesh:"
│ │ -        nodes = ""
│ │ +        mesh = "\n\nNodes in mesh: "
│ │ +        nodes = {}
│ │          if self.nodes:
│ │              for n in self.nodes.values():
│ │                  # when the TBeam is first booted, it sometimes shows the raw data
│ │                  # so, we will just remove any raw keys
│ │ -                keys_to_remove = ('raw', 'decoded', 'payload')
│ │ +                keys_to_remove = ("raw", "decoded", "payload")
│ │                  n2 = remove_keys_from_dict(keys_to_remove, n)
│ │  
│ │                  # if we have 'macaddr', re-format it
│ │ -                if 'macaddr' in n2['user']:
│ │ -                    val = n2['user']['macaddr']
│ │ +                if "macaddr" in n2["user"]:
│ │ +                    val = n2["user"]["macaddr"]
│ │                      # decode the base64 value
│ │                      addr = convert_mac_addr(val)
│ │ -                    n2['user']['macaddr'] = addr
│ │ +                    n2["user"]["macaddr"] = addr
│ │  
│ │ -                nodes = nodes + f"  {stripnl(n2)}"
│ │ -        infos = owner + myinfo + mesh + nodes
│ │ +                # use id as dictionary key for correct json format in list of nodes
│ │ +                nodeid = n2['user']['id']
│ │ +                n2['user'].pop('id')
│ │ +                nodes[nodeid] = n2
│ │ +        infos = owner + myinfo + mesh + json.dumps(nodes)
│ │          print(infos)
│ │          return infos
│ │  
│ │ -    def showNodes(self, includeSelf=True, file=sys.stdout): # pylint: disable=W0613
│ │ +    def showNodes(self, includeSelf=True, file=sys.stdout):  # pylint: disable=W0613
│ │          """Show table summary of nodes in mesh"""
│ │ -        def formatFloat(value, precision=2, unit=''):
│ │ +
│ │ +        def formatFloat(value, precision=2, unit=""):
│ │              """Format a float value with precsion."""
│ │ -            return f'{value:.{precision}f}{unit}' if value else None
│ │ +            return f"{value:.{precision}f}{unit}" if value else None
│ │  
│ │          def getLH(ts):
│ │              """Format last heard"""
│ │ -            return datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S') if ts else None
│ │ +            return (
│ │ +                datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S") if ts else None
│ │ +            )
│ │  
│ │          def getTimeAgo(ts):
│ │              """Format how long ago have we heard from this node (aka timeago)."""
│ │ -            return timeago.format(datetime.fromtimestamp(ts), datetime.now()) if ts else None
│ │ +            return (
│ │ +                timeago.format(datetime.fromtimestamp(ts), datetime.now())
│ │ +                if ts
│ │ +                else None
│ │ +            )
│ │  
│ │          rows = []
│ │          if self.nodes:
│ │ -            logging.debug(f'self.nodes:{self.nodes}')
│ │ +            logging.debug(f"self.nodes:{self.nodes}")
│ │              for node in self.nodes.values():
│ │ -                if not includeSelf and node['num'] == self.localNode.nodeNum:
│ │ +                if not includeSelf and node["num"] == self.localNode.nodeNum:
│ │                      continue
│ │  
│ │                  row = {"N": 0}
│ │  
│ │ -                user = node.get('user')
│ │ +                user = node.get("user")
│ │                  if user:
│ │ -                    row.update({
│ │ -                        "User": user['longName'],
│ │ -                        "AKA":  user['shortName'],
│ │ -                        "ID":   user['id'],
│ │ -                    })
│ │ +                    row.update(
│ │ +                        {
│ │ +                            "User": user.get("longName", "N/A"),
│ │ +                            "AKA": user.get("shortName", "N/A"),
│ │ +                            "ID": user["id"],
│ │ +                        }
│ │ +                    )
│ │  
│ │ -                pos = node.get('position')
│ │ +                pos = node.get("position")
│ │                  if pos:
│ │ -                    row.update({
│ │ -                        "Latitude":  formatFloat(pos.get("latitude"),     4, "°"),
│ │ -                        "Longitude": formatFloat(pos.get("longitude"),    4, "°"),
│ │ -                        "Altitude":  formatFloat(pos.get("altitude"),     0, " m"),
│ │ -                    })
│ │ -                
│ │ -                metrics = node.get('deviceMetrics')
│ │ -                if metrics: 
│ │ -                    batteryLevel = metrics.get('batteryLevel')
│ │ +                    row.update(
│ │ +                        {
│ │ +                            "Latitude": formatFloat(pos.get("latitude"), 4, "°"),
│ │ +                            "Longitude": formatFloat(pos.get("longitude"), 4, "°"),
│ │ +                            "Altitude": formatFloat(pos.get("altitude"), 0, " m"),
│ │ +                        }
│ │ +                    )
│ │ +
│ │ +                metrics = node.get("deviceMetrics")
│ │ +                if metrics:
│ │ +                    batteryLevel = metrics.get("batteryLevel")
│ │                      if batteryLevel is not None:
│ │                          if batteryLevel == 0:
│ │                              batteryString = "Powered"
│ │                          else:
│ │ -                            batteryString = str(batteryLevel)+"%"
│ │ -                        row.update({"Battery":   batteryString})
│ │ -                    row.update({
│ │ -                        "Channel util.": formatFloat(metrics.get('channelUtilization'), 2, "%"), 
│ │ -                        "Tx air util.": formatFloat(metrics.get('airUtilTx'), 2, "%"), 
│ │ -                    })
│ │ -
│ │ -                row.update({
│ │ -                    "SNR":       formatFloat(node.get("snr"), 2, " dB"),
│ │ -                    "LastHeard": getLH(node.get("lastHeard")),
│ │ -                    "Since":     getTimeAgo(node.get("lastHeard")),
│ │ -                })
│ │ +                            batteryString = str(batteryLevel) + "%"
│ │ +                        row.update({"Battery": batteryString})
│ │ +                    row.update(
│ │ +                        {
│ │ +                            "Channel util.": formatFloat(
│ │ +                                metrics.get("channelUtilization"), 2, "%"
│ │ +                            ),
│ │ +                            "Tx air util.": formatFloat(
│ │ +                                metrics.get("airUtilTx"), 2, "%"
│ │ +                            ),
│ │ +                        }
│ │ +                    )
│ │ +
│ │ +                row.update(
│ │ +                    {
│ │ +                        "SNR": formatFloat(node.get("snr"), 2, " dB"),
│ │ +                        "LastHeard": getLH(node.get("lastHeard")),
│ │ +                        "Since": getTimeAgo(node.get("lastHeard")),
│ │ +                    }
│ │ +                )
│ │  
│ │                  rows.append(row)
│ │  
│ │ -        rows.sort(key=lambda r: r.get('LastHeard') or '0000', reverse=True)
│ │ +        rows.sort(key=lambda r: r.get("LastHeard") or "0000", reverse=True)
│ │          for i, row in enumerate(rows):
│ │ -            row['N'] = i+1
│ │ +            row["N"] = i + 1
│ │  
│ │ -        table = tabulate(rows, headers='keys', missingval='N/A', tablefmt='fancy_grid')
│ │ +        table = tabulate(rows, headers="keys", missingval="N/A", tablefmt="fancy_grid")
│ │          print(table)
│ │          return table
│ │  
│ │ -
│ │      def getNode(self, nodeId, requestChannels=True):
│ │          """Return a node object which contains device settings and channel info"""
│ │          if nodeId in (LOCAL_ADDR, BROADCAST_ADDR):
│ │              return self.localNode
│ │          else:
│ │              n = meshtastic.node.Node(self, nodeId)
│ │              # Only request device settings and channel info when necessary
│ │              if requestChannels:
│ │                  logging.debug("About to requestChannels")
│ │                  n.requestChannels()
│ │                  if not n.waitForConfig():
│ │                      our_exit("Error: Timed out waiting for channels")
│ │              return n
│ │  
│ │ -    def sendText(self, text: AnyStr,
│ │ -                 destinationId=BROADCAST_ADDR,
│ │ -                 wantAck=False,
│ │ -                 wantResponse=False,
│ │ -                 onResponse=None,
│ │ -                 channelIndex=0):
│ │ +    def sendText(
│ │ +        self,
│ │ +        text: AnyStr,
│ │ +        destinationId=BROADCAST_ADDR,
│ │ +        wantAck=False,
│ │ +        wantResponse=False,
│ │ +        onResponse=None,
│ │ +        channelIndex=0,
│ │ +    ):
│ │          """Send a utf8 string to some other node, if the node has a display it
│ │             will also be shown on the device.
│ │  
│ │          Arguments:
│ │              text {string} -- The text to send
│ │  
│ │          Keyword Arguments:
│ │ @@ -206,26 +253,34 @@
│ │              wantResponse -- True if you want the service on the other side to
│ │                              send an application layer response
│ │  
│ │          Returns the sent packet. The id field will be populated in this packet
│ │          and can be used to track future message acks/naks.
│ │          """
│ │  
│ │ -        return self.sendData(text.encode("utf-8"), destinationId,
│ │ -                             portNum=portnums_pb2.PortNum.TEXT_MESSAGE_APP,
│ │ -                             wantAck=wantAck,
│ │ -                             wantResponse=wantResponse,
│ │ -                             onResponse=onResponse,
│ │ -                             channelIndex=channelIndex)
│ │ -
│ │ -    def sendData(self, data, destinationId=BROADCAST_ADDR,
│ │ -                 portNum=portnums_pb2.PortNum.PRIVATE_APP, wantAck=False,
│ │ -                 wantResponse=False,
│ │ -                 onResponse=None,
│ │ -                 channelIndex=0):
│ │ +        return self.sendData(
│ │ +            text.encode("utf-8"),
│ │ +            destinationId,
│ │ +            portNum=portnums_pb2.PortNum.TEXT_MESSAGE_APP,
│ │ +            wantAck=wantAck,
│ │ +            wantResponse=wantResponse,
│ │ +            onResponse=onResponse,
│ │ +            channelIndex=channelIndex,
│ │ +        )
│ │ +
│ │ +    def sendData(
│ │ +        self,
│ │ +        data,
│ │ +        destinationId=BROADCAST_ADDR,
│ │ +        portNum=portnums_pb2.PortNum.PRIVATE_APP,
│ │ +        wantAck=False,
│ │ +        wantResponse=False,
│ │ +        onResponse=None,
│ │ +        channelIndex=0,
│ │ +    ):
│ │          """Send a data packet to some other node
│ │  
│ │          Keyword Arguments:
│ │              data -- the data to send, either as an array of bytes or
│ │                      as a protobuf (which will be automatically
│ │                      serialized to bytes)
│ │              destinationId {nodeId or nodeNum} -- where to send this
│ │ @@ -246,76 +301,96 @@
│ │          """
│ │  
│ │          if getattr(data, "SerializeToString", None):
│ │              logging.debug(f"Serializing protobuf as data: {stripnl(data)}")
│ │              data = data.SerializeToString()
│ │  
│ │          logging.debug(f"len(data): {len(data)}")
│ │ -        logging.debug(f"mesh_pb2.Constants.DATA_PAYLOAD_LEN: {mesh_pb2.Constants.DATA_PAYLOAD_LEN}")
│ │ +        logging.debug(
│ │ +            f"mesh_pb2.Constants.DATA_PAYLOAD_LEN: {mesh_pb2.Constants.DATA_PAYLOAD_LEN}"
│ │ +        )
│ │          if len(data) > mesh_pb2.Constants.DATA_PAYLOAD_LEN:
│ │              raise Exception("Data payload too big")
│ │  
│ │ -        if portNum == portnums_pb2.PortNum.UNKNOWN_APP:  # we are now more strict wrt port numbers
│ │ +        if (
│ │ +            portNum == portnums_pb2.PortNum.UNKNOWN_APP
│ │ +        ):  # we are now more strict wrt port numbers
│ │              our_exit("Warning: A non-zero port number must be specified")
│ │  
│ │          meshPacket = mesh_pb2.MeshPacket()
│ │          meshPacket.channel = channelIndex
│ │          meshPacket.decoded.payload = data
│ │          meshPacket.decoded.portnum = portNum
│ │          meshPacket.decoded.want_response = wantResponse
│ │          meshPacket.id = self._generatePacketId()
│ │  
│ │          if onResponse is not None:
│ │              self._addResponseHandler(meshPacket.id, onResponse)
│ │          p = self._sendPacket(meshPacket, destinationId, wantAck=wantAck)
│ │          return p
│ │  
│ │ -    def sendPosition(self, latitude=0.0, longitude=0.0, altitude=0, timeSec=0,
│ │ -                     destinationId=BROADCAST_ADDR, wantAck=False, wantResponse=False):
│ │ +    def sendPosition(
│ │ +        self,
│ │ +        latitude=0.0,
│ │ +        longitude=0.0,
│ │ +        altitude=0,
│ │ +        timeSec=0,
│ │ +        destinationId=BROADCAST_ADDR,
│ │ +        wantAck=False,
│ │ +        wantResponse=False,
│ │ +    ):
│ │          """
│ │          Send a position packet to some other node (normally a broadcast)
│ │  
│ │          Also, the device software will notice this packet and use it to automatically
│ │          set its notion of the local position.
│ │  
│ │          If timeSec is not specified (recommended), we will use the local machine time.
│ │  
│ │          Returns the sent packet. The id field will be populated in this packet and
│ │          can be used to track future message acks/naks.
│ │          """
│ │          p = mesh_pb2.Position()
│ │          if latitude != 0.0:
│ │              p.latitude_i = int(latitude / 1e-7)
│ │ -            logging.debug(f'p.latitude_i:{p.latitude_i}')
│ │ +            logging.debug(f"p.latitude_i:{p.latitude_i}")
│ │  
│ │          if longitude != 0.0:
│ │              p.longitude_i = int(longitude / 1e-7)
│ │ -            logging.debug(f'p.longitude_i:{p.longitude_i}')
│ │ +            logging.debug(f"p.longitude_i:{p.longitude_i}")
│ │  
│ │          if altitude != 0:
│ │              p.altitude = int(altitude)
│ │ -            logging.debug(f'p.altitude:{p.altitude}')
│ │ +            logging.debug(f"p.altitude:{p.altitude}")
│ │  
│ │          if timeSec == 0:
│ │              timeSec = time.time()  # returns unix timestamp in seconds
│ │          p.time = int(timeSec)
│ │ -        logging.debug(f'p.time:{p.time}')
│ │ +        logging.debug(f"p.time:{p.time}")
│ │  
│ │ -        return self.sendData(p, destinationId,
│ │ -                             portNum=portnums_pb2.PortNum.POSITION_APP,
│ │ -                             wantAck=wantAck,
│ │ -                             wantResponse=wantResponse)
│ │ +        return self.sendData(
│ │ +            p,
│ │ +            destinationId,
│ │ +            portNum=portnums_pb2.PortNum.POSITION_APP,
│ │ +            wantAck=wantAck,
│ │ +            wantResponse=wantResponse,
│ │ +        )
│ │  
│ │      def sendTraceRoute(self, dest, hopLimit):
│ │          """Send the trace route"""
│ │          r = mesh_pb2.RouteDiscovery()
│ │ -        self.sendData(r, destinationId=dest, portNum=portnums_pb2.PortNum.TRACEROUTE_APP,
│ │ -                      wantResponse=True, onResponse=self.onResponseTraceRoute)
│ │ +        self.sendData(
│ │ +            r,
│ │ +            destinationId=dest,
│ │ +            portNum=portnums_pb2.PortNum.TRACEROUTE_APP,
│ │ +            wantResponse=True,
│ │ +            onResponse=self.onResponseTraceRoute,
│ │ +        )
│ │          # extend timeout based on number of nodes, limit by configured hopLimit
│ │ -        waitFactor = min(len(self.nodes)-1, hopLimit)
│ │ +        waitFactor = min(len(self.nodes) - 1, hopLimit)
│ │          self.waitForTraceRoute(waitFactor)
│ │  
│ │      def onResponseTraceRoute(self, p):
│ │          """on response for trace route"""
│ │          routeDiscovery = mesh_pb2.RouteDiscovery()
│ │          routeDiscovery.ParseFromString(p["decoded"]["payload"])
│ │          asDict = google.protobuf.json_format.MessageToDict(routeDiscovery)
│ │ @@ -329,26 +404,24 @@
│ │          print(routeStr)
│ │  
│ │          self._acknowledgment.receivedTraceRoute = True
│ │  
│ │      def _addResponseHandler(self, requestId, callback):
│ │          self.responseHandlers[requestId] = ResponseHandler(callback)
│ │  
│ │ -    def _sendPacket(self, meshPacket,
│ │ -                    destinationId=BROADCAST_ADDR,
│ │ -                    wantAck=False):
│ │ +    def _sendPacket(self, meshPacket, destinationId=BROADCAST_ADDR, wantAck=False):
│ │          """Send a MeshPacket to the specified node (or if unspecified, broadcast).
│ │          You probably don't want this - use sendData instead.
│ │  
│ │          Returns the sent packet. The id field will be populated in this packet and
│ │          can be used to track future message acks/naks.
│ │          """
│ │  
│ │          # We allow users to talk to the local node before we've completed the full connection flow...
│ │ -        if(self.myInfo is not None and destinationId != self.myInfo.my_node_num):
│ │ +        if self.myInfo is not None and destinationId != self.myInfo.my_node_num:
│ │              self._waitConnected()
│ │  
│ │          toRadio = mesh_pb2.ToRadio()
│ │  
│ │          nodeNum = 0
│ │          if destinationId is None:
│ │              our_exit("Warning: destinationId must not be None")
│ │ @@ -365,40 +438,45 @@
│ │          elif destinationId.startswith("!"):
│ │              nodeNum = int(destinationId[1:], 16)
│ │          else:
│ │              if self.nodes:
│ │                  node = self.nodes.get(destinationId)
│ │                  if not node:
│ │                      our_exit(f"Warning: NodeId {destinationId} not found in DB")
│ │ -                nodeNum = node['num']
│ │ +                nodeNum = node["num"]
│ │              else:
│ │                  logging.warning("Warning: There were no self.nodes.")
│ │  
│ │          meshPacket.to = nodeNum
│ │          meshPacket.want_ack = wantAck
│ │ -        loraConfig = getattr(self.localNode.localConfig, 'lora')
│ │ -        hopLimit = getattr(loraConfig, 'hop_limit')
│ │ +        loraConfig = getattr(self.localNode.localConfig, "lora")
│ │ +        hopLimit = getattr(loraConfig, "hop_limit")
│ │          meshPacket.hop_limit = hopLimit
│ │  
│ │          # if the user hasn't set an ID for this packet (likely and recommended),
│ │          # we should pick a new unique ID so the message can be tracked.
│ │          if meshPacket.id == 0:
│ │              meshPacket.id = self._generatePacketId()
│ │  
│ │          toRadio.packet.CopyFrom(meshPacket)
│ │          if self.noProto:
│ │ -            logging.warning(f"Not sending packet because protocol use is disabled by noProto")
│ │ +            logging.warning(
│ │ +                f"Not sending packet because protocol use is disabled by noProto"
│ │ +            )
│ │          else:
│ │              logging.debug(f"Sending packet: {stripnl(meshPacket)}")
│ │              self._sendToRadio(toRadio)
│ │          return meshPacket
│ │  
│ │      def waitForConfig(self):
│ │          """Block until radio config is received. Returns True if config has been received."""
│ │ -        success = self._timeout.waitForSet(self, attrs=('myInfo', 'nodes')) and self.localNode.waitForConfig()
│ │ +        success = (
│ │ +            self._timeout.waitForSet(self, attrs=("myInfo", "nodes"))
│ │ +            and self.localNode.waitForConfig()
│ │ +        )
│ │          if not success:
│ │              raise Exception("Timed out waiting for interface config")
│ │  
│ │      def waitForAckNak(self):
│ │          """Wait for the ack/nak"""
│ │          success = self._timeout.waitForAckNak(self._acknowledgment)
│ │          if not success:
│ │ @@ -410,36 +488,36 @@
│ │          if not success:
│ │              raise Exception("Timed out waiting for traceroute")
│ │  
│ │      def getMyNodeInfo(self):
│ │          """Get info about my node."""
│ │          if self.myInfo is None:
│ │              return None
│ │ -        logging.debug(f'self.nodesByNum:{self.nodesByNum}')
│ │ +        logging.debug(f"self.nodesByNum:{self.nodesByNum}")
│ │          return self.nodesByNum.get(self.myInfo.my_node_num)
│ │  
│ │      def getMyUser(self):
│ │          """Get user"""
│ │          nodeInfo = self.getMyNodeInfo()
│ │          if nodeInfo is not None:
│ │ -            return nodeInfo.get('user')
│ │ +            return nodeInfo.get("user")
│ │          return None
│ │  
│ │      def getLongName(self):
│ │          """Get long name"""
│ │          user = self.getMyUser()
│ │          if user is not None:
│ │ -            return user.get('longName', None)
│ │ +            return user.get("longName", None)
│ │          return None
│ │  
│ │      def getShortName(self):
│ │          """Get short name"""
│ │          user = self.getMyUser()
│ │          if user is not None:
│ │ -            return user.get('shortName', None)
│ │ +            return user.get("shortName", None)
│ │          return None
│ │  
│ │      def _waitConnected(self, timeout=15.0):
│ │          """Block until the initial node db download is complete, or timeout
│ │          and raise an exception"""
│ │          if not self.noProto:
│ │              if not self.isConnected.wait(timeout):  # timeout after x seconds
│ │ @@ -450,109 +528,192 @@
│ │              raise self.failure
│ │  
│ │      def _generatePacketId(self):
│ │          """Get a new unique packet ID"""
│ │          if self.currentPacketId is None:
│ │              raise Exception("Not connected yet, can not generate packet")
│ │          else:
│ │ -            self.currentPacketId = (self.currentPacketId + 1) & 0xffffffff
│ │ +            self.currentPacketId = (self.currentPacketId + 1) & 0xFFFFFFFF
│ │              return self.currentPacketId
│ │  
│ │      def _disconnected(self):
│ │          """Called by subclasses to tell clients this interface has disconnected"""
│ │          self.isConnected.clear()
│ │ -        publishingThread.queueWork(lambda: pub.sendMessage("meshtastic.connection.lost", interface=self))
│ │ +        publishingThread.queueWork(
│ │ +            lambda: pub.sendMessage("meshtastic.connection.lost", interface=self)
│ │ +        )
│ │  
│ │      def _startHeartbeat(self):
│ │          """We need to send a heartbeat message to the device every X seconds"""
│ │ +
│ │          def callback():
│ │              self.heartbeatTimer = None
│ │              prefs = self.localNode.localConfig
│ │              i = prefs.power.ls_secs / 2
│ │              logging.debug(f"Sending heartbeat, interval {i}")
│ │              if i != 0:
│ │                  self.heartbeatTimer = threading.Timer(i, callback)
│ │                  self.heartbeatTimer.start()
│ │                  p = mesh_pb2.ToRadio()
│ │                  self._sendToRadio(p)
│ │  
│ │          callback()  # run our periodic callback now, it will make another timer if necessary
│ │  
│ │      def _connected(self):
│ │ -        """Called by this class to tell clients we are now fully connected to a node
│ │ -        """
│ │ +        """Called by this class to tell clients we are now fully connected to a node"""
│ │          # (because I'm lazy) _connected might be called when remote Node
│ │          # objects complete their config reads, don't generate redundant isConnected
│ │          # for the local interface
│ │          if not self.isConnected.is_set():
│ │              self.isConnected.set()
│ │              self._startHeartbeat()
│ │ -            publishingThread.queueWork(lambda: pub.sendMessage("meshtastic.connection.established", interface=self))
│ │ +            publishingThread.queueWork(
│ │ +                lambda: pub.sendMessage(
│ │ +                    "meshtastic.connection.established", interface=self
│ │ +                )
│ │ +            )
│ │  
│ │      def _startConfig(self):
│ │          """Start device packets flowing"""
│ │          self.myInfo = None
│ │          self.nodes = {}  # nodes keyed by ID
│ │          self.nodesByNum = {}  # nodes keyed by nodenum
│ │  
│ │          startConfig = mesh_pb2.ToRadio()
│ │ -        self.configId = random.randint(0, 0xffffffff)
│ │ +        self.configId = random.randint(0, 0xFFFFFFFF)
│ │          startConfig.want_config_id = self.configId
│ │          self._sendToRadio(startConfig)
│ │  
│ │      def _sendDisconnect(self):
│ │          """Tell device we are done using it"""
│ │          m = mesh_pb2.ToRadio()
│ │          m.disconnect = True
│ │          self._sendToRadio(m)
│ │  
│ │ +    def _queueHasFreeSpace(self):
│ │ +        # We never got queueStatus, maybe the firmware is old
│ │ +        if self.queueStatus is None:
│ │ +            return True
│ │ +        return self.queueStatus.free > 0
│ │ +
│ │ +    def _queueClaim(self):
│ │ +        if self.queueStatus is None:
│ │ +            return
│ │ +        self.queueStatus.free -= 1
│ │ +
│ │      def _sendToRadio(self, toRadio):
│ │          """Send a ToRadio protobuf to the device"""
│ │          if self.noProto:
│ │ -            logging.warning(f"Not sending packet because protocol use is disabled by noProto")
│ │ +            logging.warning(
│ │ +                f"Not sending packet because protocol use is disabled by noProto"
│ │ +            )
│ │          else:
│ │ -            #logging.debug(f"Sending toRadio: {stripnl(toRadio)}")
│ │ -            self._sendToRadioImpl(toRadio)
│ │ +            # logging.debug(f"Sending toRadio: {stripnl(toRadio)}")
│ │ +
│ │ +            if not toRadio.HasField("packet"):
│ │ +                # not a meshpacket -- send immediately, give queue a chance,
│ │ +                # this makes heartbeat trigger queue
│ │ +                self._sendToRadioImpl(toRadio)
│ │ +            else:
│ │ +                # meshpacket -- queue
│ │ +                self.queue[toRadio.packet.id] = toRadio
│ │ +
│ │ +            resentQueue = collections.OrderedDict()
│ │ +
│ │ +            while self.queue:
│ │ +                # logging.warn("queue: " + " ".join(f'{k:08x}' for k in self.queue))
│ │ +                while not self._queueHasFreeSpace():
│ │ +                    logging.debug("Waiting for free space in TX Queue")
│ │ +                    time.sleep(0.5)
│ │ +                try:
│ │ +                    toResend = self.queue.popitem(last=False)
│ │ +                except KeyError:
│ │ +                    break
│ │ +                packetId, packet = toResend
│ │ +                # logging.warn(f"packet: {packetId:08x} {packet}")
│ │ +                resentQueue[packetId] = packet
│ │ +                if packet is False:
│ │ +                    continue
│ │ +                self._queueClaim()
│ │ +                if packet != toRadio:
│ │ +                    logging.debug(f"Resending packet ID {packetId:08x} {packet}")
│ │ +                self._sendToRadioImpl(packet)
│ │ +
│ │ +            # logging.warn("resentQueue: " + " ".join(f'{k:08x}' for k in resentQueue))
│ │ +            for packetId, packet in resentQueue.items():
│ │ +                if (
│ │ +                    self.queue.pop(packetId, False) is False
│ │ +                ):  # Packet got acked under us
│ │ +                    logging.debug(f"packet {packetId:08x} got acked under us")
│ │ +                    continue
│ │ +                if packet:
│ │ +                    self.queue[packetId] = packet
│ │ +            # logging.warn("queue + resentQueue: " + " ".join(f'{k:08x}' for k in self.queue))
│ │  
│ │      def _sendToRadioImpl(self, toRadio):
│ │          """Send a ToRadio protobuf to the device"""
│ │          logging.error(f"Subclass must provide toradio: {toRadio}")
│ │  
│ │      def _handleConfigComplete(self):
│ │          """
│ │          Done with initial config messages, now send regular MeshPackets
│ │          to ask for settings and channels
│ │          """
│ │          self.localNode.requestChannels()
│ │  
│ │ +    def _handleQueueStatusFromRadio(self, queueStatus):
│ │ +        self.queueStatus = queueStatus
│ │ +        logging.debug(
│ │ +            f"TX QUEUE free {queueStatus.free} of {queueStatus.maxlen}, res = {queueStatus.res}, id = {queueStatus.mesh_packet_id:08x} "
│ │ +        )
│ │ +
│ │ +        if queueStatus.res:
│ │ +            return
│ │ +
│ │ +        # logging.warn("queue: " + " ".join(f'{k:08x}' for k in self.queue))
│ │ +        justQueued = self.queue.pop(queueStatus.mesh_packet_id, None)
│ │ +
│ │ +        if justQueued is None and queueStatus.mesh_packet_id != 0:
│ │ +            self.queue[queueStatus.mesh_packet_id] = False
│ │ +            logging.debug(
│ │ +                f"Reply for unexpected packet ID {queueStatus.mesh_packet_id:08x}"
│ │ +            )
│ │ +        # logging.warn("queue: " + " ".join(f'{k:08x}' for k in self.queue))
│ │ +
│ │      def _handleFromRadio(self, fromRadioBytes):
│ │          """
│ │          Handle a packet that arrived from the radio(update model and publish events)
│ │  
│ │          Called by subclasses."""
│ │          fromRadio = mesh_pb2.FromRadio()
│ │          fromRadio.ParseFromString(fromRadioBytes)
│ │ -        logging.debug(f"in mesh_interface.py _handleFromRadio() fromRadioBytes: {fromRadioBytes}")
│ │ +        logging.debug(
│ │ +            f"in mesh_interface.py _handleFromRadio() fromRadioBytes: {fromRadioBytes}"
│ │ +        )
│ │          asDict = google.protobuf.json_format.MessageToDict(fromRadio)
│ │          logging.debug(f"Received from radio: {fromRadio}")
│ │          if fromRadio.HasField("my_info"):
│ │              self.myInfo = fromRadio.my_info
│ │              self.localNode.nodeNum = self.myInfo.my_node_num
│ │              logging.debug(f"Received myinfo: {stripnl(fromRadio.my_info)}")
│ │  
│ │              failmsg = None
│ │              # Check for app too old
│ │              if self.myInfo.min_app_version > OUR_APP_VERSION:
│ │ -                failmsg = "This device needs a newer python client, run 'pip install --upgrade meshtastic'."\
│ │ -                          "For more information see https://tinyurl.com/5bjsxu32"
│ │ +                failmsg = (
│ │ +                    "This device needs a newer python client, run 'pip install --upgrade meshtastic'."
│ │ +                    "For more information see https://tinyurl.com/5bjsxu32"
│ │ +                )
│ │  
│ │              # check for firmware too old
│ │              if self.myInfo.max_channels == 0:
│ │ -                failmsg = "This version of meshtastic-python requires device firmware version 1.2 or later. "\
│ │ -                          "For more information see https://tinyurl.com/5bjsxu32"
│ │ +                failmsg = (
│ │ +                    "This version of meshtastic-python requires device firmware version 1.2 or later. "
│ │ +                    "For more information see https://tinyurl.com/5bjsxu32"
│ │ +                )
│ │  
│ │              if failmsg:
│ │                  self.failure = Exception(failmsg)
│ │                  self.isConnected.set()  # let waitConnected return this exception
│ │                  self.close()
│ │  
│ │          elif fromRadio.HasField("node_info"):
│ │ @@ -565,25 +726,31 @@
│ │  
│ │              logging.debug(f"Received nodeinfo: {node}")
│ │  
│ │              self.nodesByNum[node["num"]] = node
│ │              if "user" in node:  # Some nodes might not have user/ids assigned yet
│ │                  if "id" in node["user"]:
│ │                      self.nodes[node["user"]["id"]] = node
│ │ -            publishingThread.queueWork(lambda: pub.sendMessage("meshtastic.node.updated",
│ │ -                                                               node=node, interface=self))
│ │ +            publishingThread.queueWork(
│ │ +                lambda: pub.sendMessage(
│ │ +                    "meshtastic.node.updated", node=node, interface=self
│ │ +                )
│ │ +            )
│ │          elif fromRadio.config_complete_id == self.configId:
│ │              # we ignore the config_complete_id, it is unneeded for our
│ │              # stream API fromRadio.config_complete_id
│ │              logging.debug(f"Config complete ID {self.configId}")
│ │              self._handleConfigComplete()
│ │  
│ │          elif fromRadio.HasField("packet"):
│ │              self._handlePacketFromRadio(fromRadio.packet)
│ │  
│ │ +        elif fromRadio.HasField("queueStatus"):
│ │ +            self._handleQueueStatusFromRadio(fromRadio.queueStatus)
│ │ +
│ │          elif fromRadio.rebooted:
│ │              # Tell clients the device went away.  Careful not to call the overridden
│ │              # subclass version that closes the serial port
│ │              MeshInterface._disconnected(self)
│ │  
│ │              self._startConfig()  # redownload the node db etc...
│ │  
│ │ @@ -597,32 +764,46 @@
│ │              elif fromRadio.config.HasField("network"):
│ │                  self.localNode.localConfig.network.CopyFrom(fromRadio.config.network)
│ │              elif fromRadio.config.HasField("display"):
│ │                  self.localNode.localConfig.display.CopyFrom(fromRadio.config.display)
│ │              elif fromRadio.config.HasField("lora"):
│ │                  self.localNode.localConfig.lora.CopyFrom(fromRadio.config.lora)
│ │              elif fromRadio.config.HasField("bluetooth"):
│ │ -                self.localNode.localConfig.bluetooth.CopyFrom(fromRadio.config.bluetooth)
│ │ +                self.localNode.localConfig.bluetooth.CopyFrom(
│ │ +                    fromRadio.config.bluetooth
│ │ +                )
│ │  
│ │              elif fromRadio.moduleConfig.HasField("mqtt"):
│ │                  self.localNode.moduleConfig.mqtt.CopyFrom(fromRadio.moduleConfig.mqtt)
│ │              elif fromRadio.moduleConfig.HasField("serial"):
│ │ -                self.localNode.moduleConfig.serial.CopyFrom(fromRadio.moduleConfig.serial)
│ │ +                self.localNode.moduleConfig.serial.CopyFrom(
│ │ +                    fromRadio.moduleConfig.serial
│ │ +                )
│ │              elif fromRadio.moduleConfig.HasField("external_notification"):
│ │ -                self.localNode.moduleConfig.external_notification.CopyFrom(fromRadio.moduleConfig.external_notification)
│ │ +                self.localNode.moduleConfig.external_notification.CopyFrom(
│ │ +                    fromRadio.moduleConfig.external_notification
│ │ +                )
│ │              elif fromRadio.moduleConfig.HasField("range_test"):
│ │ -                self.localNode.moduleConfig.range_test.CopyFrom(fromRadio.moduleConfig.range_test)
│ │ +                self.localNode.moduleConfig.range_test.CopyFrom(
│ │ +                    fromRadio.moduleConfig.range_test
│ │ +                )
│ │              elif fromRadio.moduleConfig.HasField("telemetry"):
│ │ -                self.localNode.moduleConfig.telemetry.CopyFrom(fromRadio.moduleConfig.telemetry)
│ │ +                self.localNode.moduleConfig.telemetry.CopyFrom(
│ │ +                    fromRadio.moduleConfig.telemetry
│ │ +                )
│ │              elif fromRadio.moduleConfig.HasField("canned_message"):
│ │ -                self.localNode.moduleConfig.canned_message.CopyFrom(fromRadio.moduleConfig.canned_message)
│ │ +                self.localNode.moduleConfig.canned_message.CopyFrom(
│ │ +                    fromRadio.moduleConfig.canned_message
│ │ +                )
│ │              elif fromRadio.moduleConfig.HasField("audio"):
│ │                  self.localNode.moduleConfig.audio.CopyFrom(fromRadio.moduleConfig.audio)
│ │              elif fromRadio.moduleConfig.HasField("remote_hardware"):
│ │ -                self.localNode.moduleConfig.remote_hardware.CopyFrom(fromRadio.moduleConfig.remote_hardware)
│ │ +                self.localNode.moduleConfig.remote_hardware.CopyFrom(
│ │ +                    fromRadio.moduleConfig.remote_hardware
│ │ +                )
│ │  
│ │          else:
│ │              logging.debug("Unexpected FromRadio payload")
│ │  
│ │      def _fixupPosition(self, position):
│ │          """Convert integer lat/lon into floats
│ │  
│ │ @@ -688,16 +869,20 @@
│ │          # doesn't need to understand protobufs.  But advanced clients might
│ │          # want the raw protobuf, so we provide it in "raw"
│ │          asDict["raw"] = meshPacket
│ │  
│ │          # from might be missing if the nodenum was zero.
│ │          if not hack and "from" not in asDict:
│ │              asDict["from"] = 0
│ │ -            logging.error(f"Device returned a packet we sent, ignoring: {stripnl(asDict)}")
│ │ -            print(f"Error: Device returned a packet we sent, ignoring: {stripnl(asDict)}")
│ │ +            logging.error(
│ │ +                f"Device returned a packet we sent, ignoring: {stripnl(asDict)}"
│ │ +            )
│ │ +            print(
│ │ +                f"Error: Device returned a packet we sent, ignoring: {stripnl(asDict)}"
│ │ +            )
│ │              return
│ │          if "to" not in asDict:
│ │              asDict["to"] = 0
│ │  
│ │          # /add fromId and toId fields based on the node ID
│ │          try:
│ │              asDict["fromId"] = self._nodeNumToId(asDict["from"])
│ │ @@ -709,15 +894,15 @@
│ │              logging.warning(f"Not populating toId {ex}")
│ │  
│ │          # We could provide our objects as DotMaps - which work with . notation or as dictionaries
│ │          # asObj = DotMap(asDict)
│ │          topic = "meshtastic.receive"  # Generic unknown packet type
│ │  
│ │          decoded = None
│ │ -        if 'decoded' in asDict:
│ │ +        if "decoded" in asDict:
│ │              decoded = asDict["decoded"]
│ │              # The default MessageToDict converts byte arrays into base64 strings.
│ │              # We don't want that - it messes up data payload.  So slam in the correct
│ │              # byte array.
│ │              decoded["payload"] = meshPacket.decoded.payload
│ │  
│ │          # UNKNOWN_APP is the default protobuf portnum value, and therefore if not
│ │ @@ -765,9 +950,10 @@
│ │                  # we keep the responseHandler in dict until we get a non ack
│ │                  handler = self.responseHandlers.pop(requestId, None)
│ │                  if handler is not None:
│ │                      if not isAck or (isAck and handler.__name__ == "onAckNak"):
│ │                          handler.callback(asDict)
│ │  
│ │          logging.debug(f"Publishing {topic}: packet={stripnl(asDict)} ")
│ │ -        publishingThread.queueWork(lambda: pub.sendMessage(
│ │ -            topic, packet=asDict, interface=self))
│ │ +        publishingThread.queueWork(
│ │ +            lambda: pub.sendMessage(topic, packet=asDict, interface=self)
│ │ +        )
│ │   --- meshtastic-2.1.4/meshtastic/mesh_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/mesh_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/module_config_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/module_config_pb2.py
│ │┄ Files 3% similar despite different names
│ │ @@ -10,15 +10,15 @@
│ │  # @@protoc_insertion_point(imports)
│ │  
│ │  _sym_db = _symbol_database.Default()
│ │  
│ │  
│ │  
│ │  
│ │ -DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1emeshtastic/module_config.proto\"\x95\x17\n\x0cModuleConfig\x12(\n\x04mqtt\x18\x01 \x01(\x0b\x32\x18.ModuleConfig.MQTTConfigH\x00\x12,\n\x06serial\x18\x02 \x01(\x0b\x32\x1a.ModuleConfig.SerialConfigH\x00\x12I\n\x15\x65xternal_notification\x18\x03 \x01(\x0b\x32(.ModuleConfig.ExternalNotificationConfigH\x00\x12\x39\n\rstore_forward\x18\x04 \x01(\x0b\x32 .ModuleConfig.StoreForwardConfigH\x00\x12\x33\n\nrange_test\x18\x05 \x01(\x0b\x32\x1d.ModuleConfig.RangeTestConfigH\x00\x12\x32\n\ttelemetry\x18\x06 \x01(\x0b\x32\x1d.ModuleConfig.TelemetryConfigH\x00\x12;\n\x0e\x63\x61nned_message\x18\x07 \x01(\x0b\x32!.ModuleConfig.CannedMessageConfigH\x00\x12*\n\x05\x61udio\x18\x08 \x01(\x0b\x32\x19.ModuleConfig.AudioConfigH\x00\x12=\n\x0fremote_hardware\x18\t \x01(\x0b\x32\".ModuleConfig.RemoteHardwareConfigH\x00\x1a\x84\x01\n\nMQTTConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0f\n\x07\x61\x64\x64ress\x18\x02 \x01(\t\x12\x10\n\x08username\x18\x03 \x01(\t\x12\x10\n\x08password\x18\x04 \x01(\t\x12\x1a\n\x12\x65ncryption_enabled\x18\x05 \x01(\x08\x12\x14\n\x0cjson_enabled\x18\x06 \x01(\x08\x1a\'\n\x14RemoteHardwareConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x1a\xd9\x02\n\x0b\x41udioConfig\x12\x16\n\x0e\x63odec2_enabled\x18\x01 \x01(\x08\x12\x0f\n\x07ptt_pin\x18\x02 \x01(\r\x12\x35\n\x07\x62itrate\x18\x03 \x01(\x0e\x32$.ModuleConfig.AudioConfig.Audio_Baud\x12\x0e\n\x06i2s_ws\x18\x04 \x01(\r\x12\x0e\n\x06i2s_sd\x18\x05 \x01(\r\x12\x0f\n\x07i2s_din\x18\x06 \x01(\r\x12\x0f\n\x07i2s_sck\x18\x07 \x01(\r\"\xa7\x01\n\nAudio_Baud\x12\x12\n\x0e\x43ODEC2_DEFAULT\x10\x00\x12\x0f\n\x0b\x43ODEC2_3200\x10\x01\x12\x0f\n\x0b\x43ODEC2_2400\x10\x02\x12\x0f\n\x0b\x43ODEC2_1600\x10\x03\x12\x0f\n\x0b\x43ODEC2_1400\x10\x04\x12\x0f\n\x0b\x43ODEC2_1300\x10\x05\x12\x0f\n\x0b\x43ODEC2_1200\x10\x06\x12\x0e\n\nCODEC2_700\x10\x07\x12\x0f\n\x0b\x43ODEC2_700B\x10\x08\x1a\x9b\x04\n\x0cSerialConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0c\n\x04\x65\x63ho\x18\x02 \x01(\x08\x12\x0b\n\x03rxd\x18\x03 \x01(\r\x12\x0b\n\x03txd\x18\x04 \x01(\r\x12\x34\n\x04\x62\x61ud\x18\x05 \x01(\x0e\x32&.ModuleConfig.SerialConfig.Serial_Baud\x12\x0f\n\x07timeout\x18\x06 \x01(\r\x12\x34\n\x04mode\x18\x07 \x01(\x0e\x32&.ModuleConfig.SerialConfig.Serial_Mode\"\x8a\x02\n\x0bSerial_Baud\x12\x10\n\x0c\x42\x41UD_DEFAULT\x10\x00\x12\x0c\n\x08\x42\x41UD_110\x10\x01\x12\x0c\n\x08\x42\x41UD_300\x10\x02\x12\x0c\n\x08\x42\x41UD_600\x10\x03\x12\r\n\tBAUD_1200\x10\x04\x12\r\n\tBAUD_2400\x10\x05\x12\r\n\tBAUD_4800\x10\x06\x12\r\n\tBAUD_9600\x10\x07\x12\x0e\n\nBAUD_19200\x10\x08\x12\x0e\n\nBAUD_38400\x10\t\x12\x0e\n\nBAUD_57600\x10\n\x12\x0f\n\x0b\x42\x41UD_115200\x10\x0b\x12\x0f\n\x0b\x42\x41UD_230400\x10\x0c\x12\x0f\n\x0b\x42\x41UD_460800\x10\r\x12\x0f\n\x0b\x42\x41UD_576000\x10\x0e\x12\x0f\n\x0b\x42\x41UD_921600\x10\x0f\"H\n\x0bSerial_Mode\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\t\n\x05PROTO\x10\x02\x12\x0b\n\x07TEXTMSG\x10\x03\x12\x08\n\x04NMEA\x10\x04\x1a\xce\x02\n\x1a\x45xternalNotificationConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x11\n\toutput_ms\x18\x02 \x01(\r\x12\x0e\n\x06output\x18\x03 \x01(\r\x12\x14\n\x0coutput_vibra\x18\x08 \x01(\r\x12\x15\n\routput_buzzer\x18\t \x01(\r\x12\x0e\n\x06\x61\x63tive\x18\x04 \x01(\x08\x12\x15\n\ralert_message\x18\x05 \x01(\x08\x12\x1b\n\x13\x61lert_message_vibra\x18\n \x01(\x08\x12\x1c\n\x14\x61lert_message_buzzer\x18\x0b \x01(\x08\x12\x12\n\nalert_bell\x18\x06 \x01(\x08\x12\x18\n\x10\x61lert_bell_vibra\x18\x0c \x01(\x08\x12\x19\n\x11\x61lert_bell_buzzer\x18\r \x01(\x08\x12\x0f\n\x07use_pwm\x18\x07 \x01(\x08\x12\x13\n\x0bnag_timeout\x18\x0e \x01(\r\x1a\x84\x01\n\x12StoreForwardConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x11\n\theartbeat\x18\x02 \x01(\x08\x12\x0f\n\x07records\x18\x03 \x01(\r\x12\x1a\n\x12history_return_max\x18\x04 \x01(\r\x12\x1d\n\x15history_return_window\x18\x05 \x01(\r\x1a@\n\x0fRangeTestConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0e\n\x06sender\x18\x02 \x01(\r\x12\x0c\n\x04save\x18\x03 \x01(\x08\x1a\x86\x02\n\x0fTelemetryConfig\x12\x1e\n\x16\x64\x65vice_update_interval\x18\x01 \x01(\r\x12#\n\x1b\x65nvironment_update_interval\x18\x02 \x01(\r\x12\'\n\x1f\x65nvironment_measurement_enabled\x18\x03 \x01(\x08\x12\"\n\x1a\x65nvironment_screen_enabled\x18\x04 \x01(\x08\x12&\n\x1e\x65nvironment_display_fahrenheit\x18\x05 \x01(\x08\x12\x1b\n\x13\x61ir_quality_enabled\x18\x06 \x01(\x08\x12\x1c\n\x14\x61ir_quality_interval\x18\x07 \x01(\r\x1a\xb5\x04\n\x13\x43\x61nnedMessageConfig\x12\x17\n\x0frotary1_enabled\x18\x01 \x01(\x08\x12\x19\n\x11inputbroker_pin_a\x18\x02 \x01(\r\x12\x19\n\x11inputbroker_pin_b\x18\x03 \x01(\r\x12\x1d\n\x15inputbroker_pin_press\x18\x04 \x01(\r\x12N\n\x14inputbroker_event_cw\x18\x05 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12O\n\x15inputbroker_event_ccw\x18\x06 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12Q\n\x17inputbroker_event_press\x18\x07 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12\x17\n\x0fupdown1_enabled\x18\x08 \x01(\x08\x12\x0f\n\x07\x65nabled\x18\t \x01(\x08\x12\x1a\n\x12\x61llow_input_source\x18\n \x01(\t\x12\x11\n\tsend_bell\x18\x0b \x01(\x08\"c\n\x0eInputEventChar\x12\x08\n\x04NONE\x10\x00\x12\x06\n\x02UP\x10\x11\x12\x08\n\x04\x44OWN\x10\x12\x12\x08\n\x04LEFT\x10\x13\x12\t\n\x05RIGHT\x10\x14\x12\n\n\x06SELECT\x10\n\x12\x08\n\x04\x42\x41\x43K\x10\x1b\x12\n\n\x06\x43\x41NCEL\x10\x18\x42\x11\n\x0fpayload_variantBg\n\x13\x63om.geeksville.meshB\x12ModuleConfigProtosZ\"github.com/meshtastic/go/generated\xaa\x02\x14Meshtastic.Protobufs\xba\x02\x00\x62\x06proto3')
│ │ +DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1emeshtastic/module_config.proto\"\xaa\x17\n\x0cModuleConfig\x12(\n\x04mqtt\x18\x01 \x01(\x0b\x32\x18.ModuleConfig.MQTTConfigH\x00\x12,\n\x06serial\x18\x02 \x01(\x0b\x32\x1a.ModuleConfig.SerialConfigH\x00\x12I\n\x15\x65xternal_notification\x18\x03 \x01(\x0b\x32(.ModuleConfig.ExternalNotificationConfigH\x00\x12\x39\n\rstore_forward\x18\x04 \x01(\x0b\x32 .ModuleConfig.StoreForwardConfigH\x00\x12\x33\n\nrange_test\x18\x05 \x01(\x0b\x32\x1d.ModuleConfig.RangeTestConfigH\x00\x12\x32\n\ttelemetry\x18\x06 \x01(\x0b\x32\x1d.ModuleConfig.TelemetryConfigH\x00\x12;\n\x0e\x63\x61nned_message\x18\x07 \x01(\x0b\x32!.ModuleConfig.CannedMessageConfigH\x00\x12*\n\x05\x61udio\x18\x08 \x01(\x0b\x32\x19.ModuleConfig.AudioConfigH\x00\x12=\n\x0fremote_hardware\x18\t \x01(\x0b\x32\".ModuleConfig.RemoteHardwareConfigH\x00\x1a\x99\x01\n\nMQTTConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0f\n\x07\x61\x64\x64ress\x18\x02 \x01(\t\x12\x10\n\x08username\x18\x03 \x01(\t\x12\x10\n\x08password\x18\x04 \x01(\t\x12\x1a\n\x12\x65ncryption_enabled\x18\x05 \x01(\x08\x12\x14\n\x0cjson_enabled\x18\x06 \x01(\x08\x12\x13\n\x0btls_enabled\x18\x07 \x01(\x08\x1a\'\n\x14RemoteHardwareConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x1a\xd9\x02\n\x0b\x41udioConfig\x12\x16\n\x0e\x63odec2_enabled\x18\x01 \x01(\x08\x12\x0f\n\x07ptt_pin\x18\x02 \x01(\r\x12\x35\n\x07\x62itrate\x18\x03 \x01(\x0e\x32$.ModuleConfig.AudioConfig.Audio_Baud\x12\x0e\n\x06i2s_ws\x18\x04 \x01(\r\x12\x0e\n\x06i2s_sd\x18\x05 \x01(\r\x12\x0f\n\x07i2s_din\x18\x06 \x01(\r\x12\x0f\n\x07i2s_sck\x18\x07 \x01(\r\"\xa7\x01\n\nAudio_Baud\x12\x12\n\x0e\x43ODEC2_DEFAULT\x10\x00\x12\x0f\n\x0b\x43ODEC2_3200\x10\x01\x12\x0f\n\x0b\x43ODEC2_2400\x10\x02\x12\x0f\n\x0b\x43ODEC2_1600\x10\x03\x12\x0f\n\x0b\x43ODEC2_1400\x10\x04\x12\x0f\n\x0b\x43ODEC2_1300\x10\x05\x12\x0f\n\x0b\x43ODEC2_1200\x10\x06\x12\x0e\n\nCODEC2_700\x10\x07\x12\x0f\n\x0b\x43ODEC2_700B\x10\x08\x1a\x9b\x04\n\x0cSerialConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0c\n\x04\x65\x63ho\x18\x02 \x01(\x08\x12\x0b\n\x03rxd\x18\x03 \x01(\r\x12\x0b\n\x03txd\x18\x04 \x01(\r\x12\x34\n\x04\x62\x61ud\x18\x05 \x01(\x0e\x32&.ModuleConfig.SerialConfig.Serial_Baud\x12\x0f\n\x07timeout\x18\x06 \x01(\r\x12\x34\n\x04mode\x18\x07 \x01(\x0e\x32&.ModuleConfig.SerialConfig.Serial_Mode\"\x8a\x02\n\x0bSerial_Baud\x12\x10\n\x0c\x42\x41UD_DEFAULT\x10\x00\x12\x0c\n\x08\x42\x41UD_110\x10\x01\x12\x0c\n\x08\x42\x41UD_300\x10\x02\x12\x0c\n\x08\x42\x41UD_600\x10\x03\x12\r\n\tBAUD_1200\x10\x04\x12\r\n\tBAUD_2400\x10\x05\x12\r\n\tBAUD_4800\x10\x06\x12\r\n\tBAUD_9600\x10\x07\x12\x0e\n\nBAUD_19200\x10\x08\x12\x0e\n\nBAUD_38400\x10\t\x12\x0e\n\nBAUD_57600\x10\n\x12\x0f\n\x0b\x42\x41UD_115200\x10\x0b\x12\x0f\n\x0b\x42\x41UD_230400\x10\x0c\x12\x0f\n\x0b\x42\x41UD_460800\x10\r\x12\x0f\n\x0b\x42\x41UD_576000\x10\x0e\x12\x0f\n\x0b\x42\x41UD_921600\x10\x0f\"H\n\x0bSerial_Mode\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\t\n\x05PROTO\x10\x02\x12\x0b\n\x07TEXTMSG\x10\x03\x12\x08\n\x04NMEA\x10\x04\x1a\xce\x02\n\x1a\x45xternalNotificationConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x11\n\toutput_ms\x18\x02 \x01(\r\x12\x0e\n\x06output\x18\x03 \x01(\r\x12\x14\n\x0coutput_vibra\x18\x08 \x01(\r\x12\x15\n\routput_buzzer\x18\t \x01(\r\x12\x0e\n\x06\x61\x63tive\x18\x04 \x01(\x08\x12\x15\n\ralert_message\x18\x05 \x01(\x08\x12\x1b\n\x13\x61lert_message_vibra\x18\n \x01(\x08\x12\x1c\n\x14\x61lert_message_buzzer\x18\x0b \x01(\x08\x12\x12\n\nalert_bell\x18\x06 \x01(\x08\x12\x18\n\x10\x61lert_bell_vibra\x18\x0c \x01(\x08\x12\x19\n\x11\x61lert_bell_buzzer\x18\r \x01(\x08\x12\x0f\n\x07use_pwm\x18\x07 \x01(\x08\x12\x13\n\x0bnag_timeout\x18\x0e \x01(\r\x1a\x84\x01\n\x12StoreForwardConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x11\n\theartbeat\x18\x02 \x01(\x08\x12\x0f\n\x07records\x18\x03 \x01(\r\x12\x1a\n\x12history_return_max\x18\x04 \x01(\r\x12\x1d\n\x15history_return_window\x18\x05 \x01(\r\x1a@\n\x0fRangeTestConfig\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x0e\n\x06sender\x18\x02 \x01(\r\x12\x0c\n\x04save\x18\x03 \x01(\x08\x1a\x86\x02\n\x0fTelemetryConfig\x12\x1e\n\x16\x64\x65vice_update_interval\x18\x01 \x01(\r\x12#\n\x1b\x65nvironment_update_interval\x18\x02 \x01(\r\x12\'\n\x1f\x65nvironment_measurement_enabled\x18\x03 \x01(\x08\x12\"\n\x1a\x65nvironment_screen_enabled\x18\x04 \x01(\x08\x12&\n\x1e\x65nvironment_display_fahrenheit\x18\x05 \x01(\x08\x12\x1b\n\x13\x61ir_quality_enabled\x18\x06 \x01(\x08\x12\x1c\n\x14\x61ir_quality_interval\x18\x07 \x01(\r\x1a\xb5\x04\n\x13\x43\x61nnedMessageConfig\x12\x17\n\x0frotary1_enabled\x18\x01 \x01(\x08\x12\x19\n\x11inputbroker_pin_a\x18\x02 \x01(\r\x12\x19\n\x11inputbroker_pin_b\x18\x03 \x01(\r\x12\x1d\n\x15inputbroker_pin_press\x18\x04 \x01(\r\x12N\n\x14inputbroker_event_cw\x18\x05 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12O\n\x15inputbroker_event_ccw\x18\x06 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12Q\n\x17inputbroker_event_press\x18\x07 \x01(\x0e\x32\x30.ModuleConfig.CannedMessageConfig.InputEventChar\x12\x17\n\x0fupdown1_enabled\x18\x08 \x01(\x08\x12\x0f\n\x07\x65nabled\x18\t \x01(\x08\x12\x1a\n\x12\x61llow_input_source\x18\n \x01(\t\x12\x11\n\tsend_bell\x18\x0b \x01(\x08\"c\n\x0eInputEventChar\x12\x08\n\x04NONE\x10\x00\x12\x06\n\x02UP\x10\x11\x12\x08\n\x04\x44OWN\x10\x12\x12\x08\n\x04LEFT\x10\x13\x12\t\n\x05RIGHT\x10\x14\x12\n\n\x06SELECT\x10\n\x12\x08\n\x04\x42\x41\x43K\x10\x1b\x12\n\n\x06\x43\x41NCEL\x10\x18\x42\x11\n\x0fpayload_variantBg\n\x13\x63om.geeksville.meshB\x12ModuleConfigProtosZ\"github.com/meshtastic/go/generated\xaa\x02\x14Meshtastic.Protobufs\xba\x02\x00\x62\x06proto3')
│ │  
│ │  
│ │  
│ │  _MODULECONFIG = DESCRIPTOR.message_types_by_name['ModuleConfig']
│ │  _MODULECONFIG_MQTTCONFIG = _MODULECONFIG.nested_types_by_name['MQTTConfig']
│ │  _MODULECONFIG_REMOTEHARDWARECONFIG = _MODULECONFIG.nested_types_by_name['RemoteHardwareConfig']
│ │  _MODULECONFIG_AUDIOCONFIG = _MODULECONFIG.nested_types_by_name['AudioConfig']
│ │ @@ -112,35 +112,35 @@
│ │  _sym_db.RegisterMessage(ModuleConfig.CannedMessageConfig)
│ │  
│ │  if _descriptor._USE_C_DESCRIPTORS == False:
│ │  
│ │    DESCRIPTOR._options = None
│ │    DESCRIPTOR._serialized_options = b'\n\023com.geeksville.meshB\022ModuleConfigProtosZ\"github.com/meshtastic/go/generated\252\002\024Meshtastic.Protobufs\272\002\000'
│ │    _MODULECONFIG._serialized_start=35
│ │ -  _MODULECONFIG._serialized_end=3000
│ │ +  _MODULECONFIG._serialized_end=3021
│ │    _MODULECONFIG_MQTTCONFIG._serialized_start=547
│ │ -  _MODULECONFIG_MQTTCONFIG._serialized_end=679
│ │ -  _MODULECONFIG_REMOTEHARDWARECONFIG._serialized_start=681
│ │ -  _MODULECONFIG_REMOTEHARDWARECONFIG._serialized_end=720
│ │ -  _MODULECONFIG_AUDIOCONFIG._serialized_start=723
│ │ -  _MODULECONFIG_AUDIOCONFIG._serialized_end=1068
│ │ -  _MODULECONFIG_AUDIOCONFIG_AUDIO_BAUD._serialized_start=901
│ │ -  _MODULECONFIG_AUDIOCONFIG_AUDIO_BAUD._serialized_end=1068
│ │ -  _MODULECONFIG_SERIALCONFIG._serialized_start=1071
│ │ -  _MODULECONFIG_SERIALCONFIG._serialized_end=1610
│ │ -  _MODULECONFIG_SERIALCONFIG_SERIAL_BAUD._serialized_start=1270
│ │ -  _MODULECONFIG_SERIALCONFIG_SERIAL_BAUD._serialized_end=1536
│ │ -  _MODULECONFIG_SERIALCONFIG_SERIAL_MODE._serialized_start=1538
│ │ -  _MODULECONFIG_SERIALCONFIG_SERIAL_MODE._serialized_end=1610
│ │ -  _MODULECONFIG_EXTERNALNOTIFICATIONCONFIG._serialized_start=1613
│ │ -  _MODULECONFIG_EXTERNALNOTIFICATIONCONFIG._serialized_end=1947
│ │ -  _MODULECONFIG_STOREFORWARDCONFIG._serialized_start=1950
│ │ -  _MODULECONFIG_STOREFORWARDCONFIG._serialized_end=2082
│ │ -  _MODULECONFIG_RANGETESTCONFIG._serialized_start=2084
│ │ -  _MODULECONFIG_RANGETESTCONFIG._serialized_end=2148
│ │ -  _MODULECONFIG_TELEMETRYCONFIG._serialized_start=2151
│ │ -  _MODULECONFIG_TELEMETRYCONFIG._serialized_end=2413
│ │ -  _MODULECONFIG_CANNEDMESSAGECONFIG._serialized_start=2416
│ │ -  _MODULECONFIG_CANNEDMESSAGECONFIG._serialized_end=2981
│ │ -  _MODULECONFIG_CANNEDMESSAGECONFIG_INPUTEVENTCHAR._serialized_start=2882
│ │ -  _MODULECONFIG_CANNEDMESSAGECONFIG_INPUTEVENTCHAR._serialized_end=2981
│ │ +  _MODULECONFIG_MQTTCONFIG._serialized_end=700
│ │ +  _MODULECONFIG_REMOTEHARDWARECONFIG._serialized_start=702
│ │ +  _MODULECONFIG_REMOTEHARDWARECONFIG._serialized_end=741
│ │ +  _MODULECONFIG_AUDIOCONFIG._serialized_start=744
│ │ +  _MODULECONFIG_AUDIOCONFIG._serialized_end=1089
│ │ +  _MODULECONFIG_AUDIOCONFIG_AUDIO_BAUD._serialized_start=922
│ │ +  _MODULECONFIG_AUDIOCONFIG_AUDIO_BAUD._serialized_end=1089
│ │ +  _MODULECONFIG_SERIALCONFIG._serialized_start=1092
│ │ +  _MODULECONFIG_SERIALCONFIG._serialized_end=1631
│ │ +  _MODULECONFIG_SERIALCONFIG_SERIAL_BAUD._serialized_start=1291
│ │ +  _MODULECONFIG_SERIALCONFIG_SERIAL_BAUD._serialized_end=1557
│ │ +  _MODULECONFIG_SERIALCONFIG_SERIAL_MODE._serialized_start=1559
│ │ +  _MODULECONFIG_SERIALCONFIG_SERIAL_MODE._serialized_end=1631
│ │ +  _MODULECONFIG_EXTERNALNOTIFICATIONCONFIG._serialized_start=1634
│ │ +  _MODULECONFIG_EXTERNALNOTIFICATIONCONFIG._serialized_end=1968
│ │ +  _MODULECONFIG_STOREFORWARDCONFIG._serialized_start=1971
│ │ +  _MODULECONFIG_STOREFORWARDCONFIG._serialized_end=2103
│ │ +  _MODULECONFIG_RANGETESTCONFIG._serialized_start=2105
│ │ +  _MODULECONFIG_RANGETESTCONFIG._serialized_end=2169
│ │ +  _MODULECONFIG_TELEMETRYCONFIG._serialized_start=2172
│ │ +  _MODULECONFIG_TELEMETRYCONFIG._serialized_end=2434
│ │ +  _MODULECONFIG_CANNEDMESSAGECONFIG._serialized_start=2437
│ │ +  _MODULECONFIG_CANNEDMESSAGECONFIG._serialized_end=3002
│ │ +  _MODULECONFIG_CANNEDMESSAGECONFIG_INPUTEVENTCHAR._serialized_start=2903
│ │ +  _MODULECONFIG_CANNEDMESSAGECONFIG_INPUTEVENTCHAR._serialized_end=3002
│ │  # @@protoc_insertion_point(module_scope)
│ │   --- meshtastic-2.1.4/meshtastic/mqtt_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/mqtt_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/node.py
│ ├── +++ meshtastic-2.1.5/meshtastic/node.py
│ │┄ Files 8% similar despite different names
│ │ @@ -1,16 +1,25 @@
│ │  """Node class
│ │  """
│ │  
│ │ -import logging
│ │  import base64
│ │ +import logging
│ │  import time
│ │ +
│ │  from google.protobuf.json_format import MessageToJson
│ │ -from meshtastic import portnums_pb2, apponly_pb2, admin_pb2, channel_pb2, localonly_pb2
│ │ -from meshtastic.util import pskToString, stripnl, Timeout, our_exit, fromPSK, camel_to_snake
│ │ +
│ │ +from meshtastic import admin_pb2, apponly_pb2, channel_pb2, localonly_pb2, portnums_pb2
│ │ +from meshtastic.util import (
│ │ +    Timeout,
│ │ +    camel_to_snake,
│ │ +    fromPSK,
│ │ +    our_exit,
│ │ +    pskToString,
│ │ +    stripnl,
│ │ +)
│ │  
│ │  
│ │  class Node:
│ │      """A model of a (local or remote) node in the mesh
│ │  
│ │      Includes methods for localConfig, moduleConfig and channels
│ │      """
│ │ @@ -32,21 +41,23 @@
│ │  
│ │          self.gotResponse = None
│ │  
│ │      def showChannels(self):
│ │          """Show human readable description of our channels."""
│ │          print("Channels:")
│ │          if self.channels:
│ │ -            logging.debug(f'self.channels:{self.channels}')
│ │ +            logging.debug(f"self.channels:{self.channels}")
│ │              for c in self.channels:
│ │ -                #print('c.settings.psk:', c.settings.psk)
│ │ +                # print('c.settings.psk:', c.settings.psk)
│ │                  cStr = stripnl(MessageToJson(c.settings))
│ │                  # only show if there is no psk (meaning disabled channel)
│ │                  if c.settings.psk:
│ │ -                    print(f"  {channel_pb2.Channel.Role.Name(c.role)} psk={pskToString(c.settings.psk)} {cStr}")
│ │ +                    print(
│ │ +                        f"  {channel_pb2.Channel.Role.Name(c.role)} psk={pskToString(c.settings.psk)} {cStr}"
│ │ +                    )
│ │          publicURL = self.getURL(includeAll=False)
│ │          adminURL = self.getURL(includeAll=True)
│ │          print(f"\nPrimary channel URL: {publicURL}")
│ │          if adminURL != publicURL:
│ │              print(f"Complete URL (includes all channels): {adminURL}")
│ │  
│ │      def showInfo(self):
│ │ @@ -64,260 +75,158 @@
│ │      def requestChannels(self):
│ │          """Send regular MeshPackets to ask channels."""
│ │          logging.debug(f"requestChannels for nodeNum:{self.nodeNum}")
│ │          self.channels = None
│ │          self.partialChannels = []  # We keep our channels in a temp array until finished
│ │  
│ │          self._requestChannel(0)
│ │ -    
│ │ +
│ │      def onResponseRequestSettings(self, p):
│ │          """Handle the response packets for requesting settings _requestSettings()"""
│ │ -        logging.debug(f'onResponseRequestSetting() p:{p}')
│ │ +        logging.debug(f"onResponseRequestSetting() p:{p}")
│ │          if "routing" in p["decoded"]:
│ │              if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │                  print(f'Error on response: {p["decoded"]["routing"]["errorReason"]}')
│ │                  self.iface._acknowledgment.receivedNak = True
│ │          else:
│ │              self.iface._acknowledgment.receivedAck = True
│ │              print("")
│ │              adminMessage = p["decoded"]["admin"]
│ │              if "getConfigResponse" in adminMessage:
│ │                  resp = adminMessage["getConfigResponse"]
│ │                  field = list(resp.keys())[0]
│ │ -                config_type = self.localConfig.DESCRIPTOR.fields_by_name.get(camel_to_snake(field))
│ │ +                config_type = self.localConfig.DESCRIPTOR.fields_by_name.get(
│ │ +                    camel_to_snake(field)
│ │ +                )
│ │                  config_values = getattr(self.localConfig, config_type.name)
│ │              elif "getModuleConfigResponse" in adminMessage:
│ │                  resp = adminMessage["getModuleConfigResponse"]
│ │                  field = list(resp.keys())[0]
│ │ -                config_type = self.moduleConfig.DESCRIPTOR.fields_by_name.get(camel_to_snake(field))
│ │ +                config_type = self.moduleConfig.DESCRIPTOR.fields_by_name.get(
│ │ +                    camel_to_snake(field)
│ │ +                )
│ │                  config_values = getattr(self.moduleConfig, config_type.name)
│ │ -            else: 
│ │ -                print("Did not receive a valid response. Make sure to have a shared channel named 'admin'.")
│ │ +            else:
│ │ +                print(
│ │ +                    "Did not receive a valid response. Make sure to have a shared channel named 'admin'."
│ │ +                )
│ │                  return
│ │              for key, value in resp[field].items():
│ │                  setattr(config_values, camel_to_snake(key), value)
│ │              print(f"{str(camel_to_snake(field))}:\n{str(config_values)}")
│ │  
│ │      def requestConfig(self, configType):
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onResponseRequestSettings
│ │              print("Requesting current config from remote node (this can take a while).")
│ │  
│ │          msgIndex = configType.index
│ │          if configType.containing_type.full_name == "LocalConfig":
│ │              p = admin_pb2.AdminMessage()
│ │              p.get_config_request = msgIndex
│ │              self._sendAdmin(p, wantResponse=True, onResponse=onResponse)
│ │ -        else: 
│ │ +        else:
│ │              p = admin_pb2.AdminMessage()
│ │              p.get_module_config_request = msgIndex
│ │              self._sendAdmin(p, wantResponse=True, onResponse=onResponse)
│ │          if onResponse:
│ │              self.iface.waitForAckNak()
│ │  
│ │      def turnOffEncryptionOnPrimaryChannel(self):
│ │          """Turn off encryption on primary channel."""
│ │          self.channels[0].settings.psk = fromPSK("none")
│ │          print("Writing modified channels to device")
│ │          self.writeChannel(0)
│ │  
│ │ -    def waitForConfig(self, attribute='channels'):
│ │ +    def waitForConfig(self, attribute="channels"):
│ │          """Block until radio config is received. Returns True if config has been received."""
│ │ -        return self._timeout.waitForSet(self, attrs=('localConfig', attribute))
│ │ -
│ │ -    def writeConfig(self):
│ │ -        """Write the current (edited) localConfig to the device"""
│ │ -        if self.localConfig is None:
│ │ -            our_exit("Error: No localConfig has been read")
│ │ -
│ │ -        if self.localConfig.device:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.device.CopyFrom(self.localConfig.device)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote device")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.position:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.position.CopyFrom(self.localConfig.position)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote position")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.power:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.power.CopyFrom(self.localConfig.power)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote power")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.network:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.network.CopyFrom(self.localConfig.network)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote network")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.display:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.display.CopyFrom(self.localConfig.display)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote display")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.lora:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.lora.CopyFrom(self.localConfig.lora)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote lora")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.localConfig.bluetooth:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_config.bluetooth.CopyFrom(self.localConfig.bluetooth)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote bluetooth")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.mqtt:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.mqtt.CopyFrom(self.moduleConfig.mqtt)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: mqtt")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.serial:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.serial.CopyFrom(self.moduleConfig.serial)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: serial")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.external_notification:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.external_notification.CopyFrom(self.moduleConfig.external_notification)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: external_notification")
│ │ -            time.sleep(0.3)
│ │ -        
│ │ -        if self.moduleConfig.store_forward:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.store_forward.CopyFrom(self.moduleConfig.store_forward)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: store_forward")
│ │ -            time.sleep(0.3)
│ │ -        
│ │ -        if self.moduleConfig.range_test:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.range_test.CopyFrom(self.moduleConfig.range_test)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: range_test")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.telemetry:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.telemetry.CopyFrom(self.moduleConfig.telemetry)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: telemetry")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.canned_message:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.canned_message.CopyFrom(self.moduleConfig.canned_message)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: canned_message")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.audio:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.audio.CopyFrom(self.moduleConfig.audio)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: audio")
│ │ -            time.sleep(0.3)
│ │ -
│ │ -        if self.moduleConfig.remote_hardware:
│ │ -            p = admin_pb2.AdminMessage()
│ │ -            p.set_module_config.remote_hardware.CopyFrom(self.moduleConfig.remote_hardware)
│ │ -            self._sendAdmin(p)
│ │ -            logging.debug("Wrote module: remote_hardware")
│ │ -            time.sleep(0.3)
│ │ +        return self._timeout.waitForSet(self, attrs=("localConfig", attribute))
│ │  
│ │      def writeConfig(self, config_name):
│ │          """Write the current (edited) localConfig to the device"""
│ │          if self.localConfig is None:
│ │              our_exit("Error: No localConfig has been read")
│ │  
│ │          p = admin_pb2.AdminMessage()
│ │  
│ │ -        if config_name == 'device':
│ │ +        if config_name == "device":
│ │              p.set_config.device.CopyFrom(self.localConfig.device)
│ │ -        elif config_name == 'position':
│ │ +        elif config_name == "position":
│ │              p.set_config.position.CopyFrom(self.localConfig.position)
│ │ -        elif config_name == 'power':
│ │ +        elif config_name == "power":
│ │              p.set_config.power.CopyFrom(self.localConfig.power)
│ │ -        elif config_name == 'network':
│ │ +        elif config_name == "network":
│ │              p.set_config.network.CopyFrom(self.localConfig.network)
│ │ -        elif config_name == 'display':
│ │ +        elif config_name == "display":
│ │              p.set_config.display.CopyFrom(self.localConfig.display)
│ │ -        elif config_name == 'lora':
│ │ +        elif config_name == "lora":
│ │              p.set_config.lora.CopyFrom(self.localConfig.lora)
│ │ -        elif config_name == 'bluetooth':
│ │ +        elif config_name == "bluetooth":
│ │              p.set_config.bluetooth.CopyFrom(self.localConfig.bluetooth)
│ │ -        elif config_name == 'mqtt':
│ │ +        elif config_name == "mqtt":
│ │              p.set_module_config.mqtt.CopyFrom(self.moduleConfig.mqtt)
│ │ -        elif config_name == 'serial':
│ │ +        elif config_name == "serial":
│ │              p.set_module_config.serial.CopyFrom(self.moduleConfig.serial)
│ │ -        elif config_name == 'external_notification':
│ │ -            p.set_module_config.external_notification.CopyFrom(self.moduleConfig.external_notification)
│ │ -        elif config_name == 'store_forward':
│ │ +        elif config_name == "external_notification":
│ │ +            p.set_module_config.external_notification.CopyFrom(
│ │ +                self.moduleConfig.external_notification
│ │ +            )
│ │ +        elif config_name == "store_forward":
│ │              p.set_module_config.store_forward.CopyFrom(self.moduleConfig.store_forward)
│ │ -        elif config_name == 'range_test':
│ │ +        elif config_name == "range_test":
│ │              p.set_module_config.range_test.CopyFrom(self.moduleConfig.range_test)
│ │ -        elif config_name == 'telemetry':
│ │ +        elif config_name == "telemetry":
│ │              p.set_module_config.telemetry.CopyFrom(self.moduleConfig.telemetry)
│ │ -        elif config_name == 'canned_message':
│ │ -            p.set_module_config.canned_message.CopyFrom(self.moduleConfig.canned_message)
│ │ -        elif config_name == 'audio':
│ │ +        elif config_name == "canned_message":
│ │ +            p.set_module_config.canned_message.CopyFrom(
│ │ +                self.moduleConfig.canned_message
│ │ +            )
│ │ +        elif config_name == "audio":
│ │              p.set_module_config.audio.CopyFrom(self.moduleConfig.audio)
│ │ -        elif config_name == 'remote_hardware':
│ │ -            p.set_module_config.remote_hardware.CopyFrom(self.moduleConfig.remote_hardware)
│ │ +        elif config_name == "remote_hardware":
│ │ +            p.set_module_config.remote_hardware.CopyFrom(
│ │ +                self.moduleConfig.remote_hardware
│ │ +            )
│ │          else:
│ │              our_exit(f"Error: No valid config with name {config_name}")
│ │ -        
│ │ +
│ │          logging.debug(f"Wrote: {config_name}")
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def writeChannel(self, channelIndex, adminIndex=0):
│ │          """Write the current (edited) channel to the device"""
│ │  
│ │          p = admin_pb2.AdminMessage()
│ │          p.set_channel.CopyFrom(self.channels[channelIndex])
│ │          self._sendAdmin(p, adminIndex=adminIndex)
│ │          logging.debug(f"Wrote channel {channelIndex}")
│ │  
│ │      def getChannelByChannelIndex(self, channelIndex):
│ │          """Get channel by channelIndex
│ │ -            channelIndex: number, typically 0-7; based on max number channels
│ │ -            returns: None if there is no channel found
│ │ +        channelIndex: number, typically 0-7; based on max number channels
│ │ +        returns: None if there is no channel found
│ │          """
│ │          ch = None
│ │          if self.channels and 0 <= channelIndex < len(self.channels):
│ │              ch = self.channels[channelIndex]
│ │          return ch
│ │  
│ │      def deleteChannel(self, channelIndex):
│ │          """Delete the specifed channelIndex and shift other channels up"""
│ │          ch = self.channels[channelIndex]
│ │ -        if ch.role not in (channel_pb2.Channel.Role.SECONDARY, channel_pb2.Channel.Role.DISABLED):
│ │ +        if ch.role not in (
│ │ +            channel_pb2.Channel.Role.SECONDARY,
│ │ +            channel_pb2.Channel.Role.DISABLED,
│ │ +        ):
│ │              our_exit("Warning: Only SECONDARY channels can be deleted")
│ │  
│ │          # we are careful here because if we move the "admin" channel the channelIndex we need to use
│ │          # for sending admin channels will also change
│ │          adminIndex = self.iface.localNode._getAdminChannelIndex()
│ │  
│ │          self.channels.pop(channelIndex)
│ │ @@ -333,15 +242,15 @@
│ │              if (self.iface.localNode == self) and index >= adminIndex:
│ │                  # We've now passed the old location for admin index
│ │                  # (and written it), so we can start finding it by name again
│ │                  adminIndex = 0
│ │  
│ │      def getChannelByName(self, name):
│ │          """Try to find the named channel or return None"""
│ │ -        for c in (self.channels or []):
│ │ +        for c in self.channels or []:
│ │              if c.settings and c.settings.name == name:
│ │                  return c
│ │          return None
│ │  
│ │      def getDisabledChannel(self):
│ │          """Return the first channel that is disabled (i.e. available for some new use)"""
│ │          for c in self.channels:
│ │ @@ -371,36 +280,38 @@
│ │              short_name = short_name.strip()
│ │              if len(short_name) > nChars:
│ │                  short_name = short_name[:nChars]
│ │                  print(f"Maximum is 4 characters, truncated to {short_name}")
│ │              p.set_owner.short_name = short_name
│ │  
│ │          # Note: These debug lines are used in unit tests
│ │ -        logging.debug(f'p.set_owner.long_name:{p.set_owner.long_name}:')
│ │ -        logging.debug(f'p.set_owner.short_name:{p.set_owner.short_name}:')
│ │ -        logging.debug(f'p.set_owner.is_licensed:{p.set_owner.is_licensed}')
│ │ +        logging.debug(f"p.set_owner.long_name:{p.set_owner.long_name}:")
│ │ +        logging.debug(f"p.set_owner.short_name:{p.set_owner.short_name}:")
│ │ +        logging.debug(f"p.set_owner.is_licensed:{p.set_owner.is_licensed}")
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def getURL(self, includeAll: bool = True):
│ │          """The sharable URL that describes the current channel"""
│ │          # Only keep the primary/secondary channels, assume primary is first
│ │          channelSet = apponly_pb2.ChannelSet()
│ │          if self.channels:
│ │              for c in self.channels:
│ │ -                if c.role == channel_pb2.Channel.Role.PRIMARY or (includeAll and c.role == channel_pb2.Channel.Role.SECONDARY):
│ │ +                if c.role == channel_pb2.Channel.Role.PRIMARY or (
│ │ +                    includeAll and c.role == channel_pb2.Channel.Role.SECONDARY
│ │ +                ):
│ │                      channelSet.settings.append(c.settings)
│ │  
│ │          channelSet.lora_config.CopyFrom(self.localConfig.lora)
│ │          some_bytes = channelSet.SerializeToString()
│ │ -        s = base64.urlsafe_b64encode(some_bytes).decode('ascii')
│ │ +        s = base64.urlsafe_b64encode(some_bytes).decode("ascii")
│ │          s = s.replace("=", "").replace("+", "-").replace("/", "_")
│ │          return f"https://meshtastic.org/e/#{s}"
│ │  
│ │      def setURL(self, url):
│ │          """Set mesh network URL"""
│ │          if self.localConfig is None:
│ │              our_exit("Warning: No Config has been read")
│ │ @@ -411,279 +322,295 @@
│ │          b64 = splitURL[-1]
│ │  
│ │          # We normally strip padding to make for a shorter URL, but the python parser doesn't like
│ │          # that.  So add back any missing padding
│ │          # per https://stackoverflow.com/a/9807138
│ │          missing_padding = len(b64) % 4
│ │          if missing_padding:
│ │ -            b64 += '=' * (4 - missing_padding)
│ │ +            b64 += "=" * (4 - missing_padding)
│ │  
│ │          decodedURL = base64.urlsafe_b64decode(b64)
│ │          channelSet = apponly_pb2.ChannelSet()
│ │          channelSet.ParseFromString(decodedURL)
│ │  
│ │ -
│ │          if len(channelSet.settings) == 0:
│ │              our_exit("Warning: There were no settings.")
│ │  
│ │          i = 0
│ │          for chs in channelSet.settings:
│ │              ch = channel_pb2.Channel()
│ │ -            ch.role = channel_pb2.Channel.Role.PRIMARY if i == 0 else channel_pb2.Channel.Role.SECONDARY
│ │ +            ch.role = (
│ │ +                channel_pb2.Channel.Role.PRIMARY
│ │ +                if i == 0
│ │ +                else channel_pb2.Channel.Role.SECONDARY
│ │ +            )
│ │              ch.index = i
│ │              ch.settings.CopyFrom(chs)
│ │              self.channels[ch.index] = ch
│ │ -            logging.debug(f'Channel i:{i} ch:{ch}')
│ │ +            logging.debug(f"Channel i:{i} ch:{ch}")
│ │              self.writeChannel(ch.index)
│ │              i = i + 1
│ │  
│ │          p = admin_pb2.AdminMessage()
│ │          p.set_config.lora.CopyFrom(channelSet.lora_config)
│ │          self._sendAdmin(p)
│ │  
│ │      def onResponseRequestRingtone(self, p):
│ │          """Handle the response packet for requesting ringtone part 1"""
│ │ -        logging.debug(f'onResponseRequestRingtone() p:{p}')
│ │ +        logging.debug(f"onResponseRequestRingtone() p:{p}")
│ │          errorFound = False
│ │          if "routing" in p["decoded"]:
│ │              if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │                  errorFound = True
│ │                  print(f'Error on response: {p["decoded"]["routing"]["errorReason"]}')
│ │          if errorFound is False:
│ │              if "decoded" in p:
│ │                  if "admin" in p["decoded"]:
│ │                      if "raw" in p["decoded"]["admin"]:
│ │ -                        self.ringtonePart = p["decoded"]["admin"]["raw"].get_ringtone_response
│ │ -                        logging.debug(f'self.ringtonePart:{self.ringtonePart}')
│ │ +                        self.ringtonePart = p["decoded"]["admin"][
│ │ +                            "raw"
│ │ +                        ].get_ringtone_response
│ │ +                        logging.debug(f"self.ringtonePart:{self.ringtonePart}")
│ │                          self.gotResponse = True
│ │  
│ │      def get_ringtone(self):
│ │          """Get the ringtone. Concatenate all pieces together and return a single string."""
│ │ -        logging.debug(f'in get_ringtone()')
│ │ +        logging.debug(f"in get_ringtone()")
│ │          if not self.ringtone:
│ │ -
│ │              p1 = admin_pb2.AdminMessage()
│ │              p1.get_ringtone_request = True
│ │              self.gotResponse = False
│ │ -            self._sendAdmin(p1, wantResponse=True, onResponse=self.onResponseRequestRingtone)
│ │ +            self._sendAdmin(
│ │ +                p1, wantResponse=True, onResponse=self.onResponseRequestRingtone
│ │ +            )
│ │              while self.gotResponse is False:
│ │                  time.sleep(0.1)
│ │  
│ │ -            logging.debug(f'self.ringtone:{self.ringtone}')
│ │ +            logging.debug(f"self.ringtone:{self.ringtone}")
│ │  
│ │              self.ringtone = ""
│ │              if self.ringtonePart:
│ │                  self.ringtone += self.ringtonePart
│ │ -        
│ │ -        print(f'ringtone:{self.ringtone}')
│ │ -        logging.debug(f'ringtone:{self.ringtone}')
│ │ +
│ │ +        print(f"ringtone:{self.ringtone}")
│ │ +        logging.debug(f"ringtone:{self.ringtone}")
│ │          return self.ringtone
│ │  
│ │      def set_ringtone(self, ringtone):
│ │          """Set the ringtone. The ringtone length must be less than 230 character."""
│ │  
│ │          if len(ringtone) > 230:
│ │              our_exit("Warning: The ringtone must be less than 230 characters.")
│ │  
│ │          # split into chunks
│ │          chunks = []
│ │          chunks_size = 230
│ │          for i in range(0, len(ringtone), chunks_size):
│ │ -            chunks.append(ringtone[i: i + chunks_size])
│ │ +            chunks.append(ringtone[i : i + chunks_size])
│ │  
│ │          # for each chunk, send a message to set the values
│ │ -        #for i in range(0, len(chunks)):
│ │ +        # for i in range(0, len(chunks)):
│ │          for i, chunk in enumerate(chunks):
│ │              p = admin_pb2.AdminMessage()
│ │  
│ │              # TODO: should be a way to improve this
│ │              if i == 0:
│ │                  p.set_ringtone_message = chunk
│ │  
│ │              logging.debug(f"Setting ringtone '{chunk}' part {i+1}")
│ │              # If sending to a remote node, wait for ACK/NAK
│ │              if self == self.iface.localNode:
│ │                  onResponse = None
│ │ -            else: 
│ │ +            else:
│ │                  onResponse = self.onAckNak
│ │              return self._sendAdmin(p, onResponse=onResponse)
│ │ -            
│ │ +
│ │      def onResponseRequestCannedMessagePluginMessageMessages(self, p):
│ │          """Handle the response packet for requesting canned message plugin message part 1"""
│ │ -        logging.debug(f'onResponseRequestCannedMessagePluginMessageMessages() p:{p}')
│ │ +        logging.debug(f"onResponseRequestCannedMessagePluginMessageMessages() p:{p}")
│ │          errorFound = False
│ │          if "routing" in p["decoded"]:
│ │              if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │                  errorFound = True
│ │                  print(f'Error on response: {p["decoded"]["routing"]["errorReason"]}')
│ │          if errorFound is False:
│ │              if "decoded" in p:
│ │                  if "admin" in p["decoded"]:
│ │                      if "raw" in p["decoded"]["admin"]:
│ │ -                        self.cannedPluginMessageMessages = p["decoded"]["admin"]["raw"].get_canned_message_module_messages_response
│ │ -                        logging.debug(f'self.cannedPluginMessageMessages:{self.cannedPluginMessageMessages}')
│ │ +                        self.cannedPluginMessageMessages = p["decoded"]["admin"][
│ │ +                            "raw"
│ │ +                        ].get_canned_message_module_messages_response
│ │ +                        logging.debug(
│ │ +                            f"self.cannedPluginMessageMessages:{self.cannedPluginMessageMessages}"
│ │ +                        )
│ │                          self.gotResponse = True
│ │  
│ │ -
│ │      def get_canned_message(self):
│ │          """Get the canned message string. Concatenate all pieces together and return a single string."""
│ │ -        logging.debug(f'in get_canned_message()')
│ │ +        logging.debug(f"in get_canned_message()")
│ │          if not self.cannedPluginMessage:
│ │ -
│ │              p1 = admin_pb2.AdminMessage()
│ │              p1.get_canned_message_module_messages_request = True
│ │              self.gotResponse = False
│ │ -            self._sendAdmin(p1, wantResponse=True, onResponse=self.onResponseRequestCannedMessagePluginMessageMessages)
│ │ +            self._sendAdmin(
│ │ +                p1,
│ │ +                wantResponse=True,
│ │ +                onResponse=self.onResponseRequestCannedMessagePluginMessageMessages,
│ │ +            )
│ │              while self.gotResponse is False:
│ │                  time.sleep(0.1)
│ │  
│ │ -            logging.debug(f'self.cannedPluginMessageMessages:{self.cannedPluginMessageMessages}')
│ │ +            logging.debug(
│ │ +                f"self.cannedPluginMessageMessages:{self.cannedPluginMessageMessages}"
│ │ +            )
│ │  
│ │              self.cannedPluginMessage = ""
│ │              if self.cannedPluginMessageMessages:
│ │                  self.cannedPluginMessage += self.cannedPluginMessageMessages
│ │  
│ │ -        print(f'canned_plugin_message:{self.cannedPluginMessage}')
│ │ -        logging.debug(f'canned_plugin_message:{self.cannedPluginMessage}')
│ │ +        print(f"canned_plugin_message:{self.cannedPluginMessage}")
│ │ +        logging.debug(f"canned_plugin_message:{self.cannedPluginMessage}")
│ │          return self.cannedPluginMessage
│ │  
│ │      def set_canned_message(self, message):
│ │          """Set the canned message. The canned messages length must be less than 200 character."""
│ │  
│ │          if len(message) > 200:
│ │              our_exit("Warning: The canned message must be less than 200 characters.")
│ │  
│ │          # split into chunks
│ │          chunks = []
│ │          chunks_size = 200
│ │          for i in range(0, len(message), chunks_size):
│ │ -            chunks.append(message[i: i + chunks_size])
│ │ +            chunks.append(message[i : i + chunks_size])
│ │  
│ │          # for each chunk, send a message to set the values
│ │ -        #for i in range(0, len(chunks)):
│ │ +        # for i in range(0, len(chunks)):
│ │          for i, chunk in enumerate(chunks):
│ │              p = admin_pb2.AdminMessage()
│ │  
│ │              # TODO: should be a way to improve this
│ │              if i == 0:
│ │                  p.set_canned_message_module_messages = chunk
│ │  
│ │              logging.debug(f"Setting canned message '{chunk}' part {i+1}")
│ │              # If sending to a remote node, wait for ACK/NAK
│ │              if self == self.iface.localNode:
│ │                  onResponse = None
│ │ -            else: 
│ │ +            else:
│ │                  onResponse = self.onAckNak
│ │              return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def exitSimulator(self):
│ │          """Tell a simulator node to exit (this message
│ │ -           is ignored for other nodes)"""
│ │ +        is ignored for other nodes)"""
│ │          p = admin_pb2.AdminMessage()
│ │          p.exit_simulator = True
│ │ -        logging.debug('in exitSimulator()')
│ │ +        logging.debug("in exitSimulator()")
│ │  
│ │          return self._sendAdmin(p)
│ │  
│ │      def reboot(self, secs: int = 10):
│ │          """Tell the node to reboot."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.reboot_seconds = secs
│ │          logging.info(f"Telling node to reboot in {secs} seconds")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │ -    
│ │ +
│ │      def beginSettingsTransaction(self):
│ │          """Tell the node to open a transaction to edit settings."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.begin_edit_settings = True
│ │          logging.info(f"Telling open a transaction to edit settings")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def commitSettingsTransaction(self):
│ │          """Tell the node to commit the open transaction for editing settings."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.commit_edit_settings = True
│ │          logging.info(f"Telling node to commit open transaction for editing settings")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def rebootOTA(self, secs: int = 10):
│ │          """Tell the node to reboot into factory firmware."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.reboot_ota_seconds = secs
│ │          logging.info(f"Telling node to reboot to OTA in {secs} seconds")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │ -        return self._sendAdmin(p, onResponse=onResponse)        
│ │ +        return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def shutdown(self, secs: int = 10):
│ │          """Tell the node to shutdown."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.shutdown_seconds = secs
│ │          logging.info(f"Telling node to shutdown in {secs} seconds")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def getMetadata(self):
│ │          """Get the node's metadata."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.get_device_metadata_request = True
│ │          logging.info(f"Requesting device metadata")
│ │  
│ │ -        return self._sendAdmin(p, wantResponse=True, onResponse=self.onRequestGetMetadata)
│ │ +        return self._sendAdmin(
│ │ +            p, wantResponse=True, onResponse=self.onRequestGetMetadata
│ │ +        )
│ │  
│ │      def factoryReset(self):
│ │          """Tell the node to factory reset."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.factory_reset = True
│ │          logging.info(f"Telling node to factory reset")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │ -        return self._sendAdmin(p, onResponse=onResponse)  
│ │ +        return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def resetNodeDb(self):
│ │          """Tell the node to reset its list of nodes."""
│ │          p = admin_pb2.AdminMessage()
│ │          p.nodedb_reset = True
│ │          logging.info(f"Telling node to reset the NodeDB")
│ │  
│ │          # If sending to a remote node, wait for ACK/NAK
│ │          if self == self.iface.localNode:
│ │              onResponse = None
│ │ -        else: 
│ │ +        else:
│ │              onResponse = self.onAckNak
│ │          return self._sendAdmin(p, onResponse=onResponse)
│ │  
│ │      def _fixupChannels(self):
│ │          """Fixup indexes and add disabled channels as needed"""
│ │  
│ │          # Add extra disabled channels as needed
│ │ @@ -701,43 +628,50 @@
│ │          while index < self.iface.myInfo.max_channels:
│ │              ch = channel_pb2.Channel()
│ │              ch.role = channel_pb2.Channel.Role.DISABLED
│ │              ch.index = index
│ │              self.channels.append(ch)
│ │              index += 1
│ │  
│ │ -
│ │      def onRequestGetMetadata(self, p):
│ │          """Handle the response packet for requesting device metadata getMetadata()"""
│ │ -        logging.debug(f'onRequestGetMetadata() p:{p}')
│ │ +        logging.debug(f"onRequestGetMetadata() p:{p}")
│ │  
│ │ -        if p["decoded"]["portnum"] == portnums_pb2.PortNum.Name(portnums_pb2.PortNum.ROUTING_APP):
│ │ +        if p["decoded"]["portnum"] == portnums_pb2.PortNum.Name(
│ │ +            portnums_pb2.PortNum.ROUTING_APP
│ │ +        ):
│ │              if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │ -                logging.warning(f'Metadata request failed, error reason: {p["decoded"]["routing"]["errorReason"]}')
│ │ -                self._timeout.expireTime = time.time() # Do not wait any longer
│ │ -                return # Don't try to parse this routing message
│ │ +                logging.warning(
│ │ +                    f'Metadata request failed, error reason: {p["decoded"]["routing"]["errorReason"]}'
│ │ +                )
│ │ +                self._timeout.expireTime = time.time()  # Do not wait any longer
│ │ +                return  # Don't try to parse this routing message
│ │              logging.debug(f"Retrying metadata request.")
│ │              self.getMetadata()
│ │ -            return 
│ │ -            
│ │ +            return
│ │ +
│ │          c = p["decoded"]["admin"]["raw"].get_device_metadata_response
│ │          self._timeout.reset()  # We made foreward progress
│ │          logging.debug(f"Received metadata {stripnl(c)}")
│ │          print(f"\nfirmware_version: {c.firmware_version}")
│ │          print(f"device_state_version: {c.device_state_version}")
│ │  
│ │      def onResponseRequestChannel(self, p):
│ │          """Handle the response packet for requesting a channel _requestChannel()"""
│ │ -        logging.debug(f'onResponseRequestChannel() p:{p}')
│ │ +        logging.debug(f"onResponseRequestChannel() p:{p}")
│ │  
│ │ -        if p["decoded"]["portnum"] == portnums_pb2.PortNum.Name(portnums_pb2.PortNum.ROUTING_APP):
│ │ +        if p["decoded"]["portnum"] == portnums_pb2.PortNum.Name(
│ │ +            portnums_pb2.PortNum.ROUTING_APP
│ │ +        ):
│ │              if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │ -                logging.warning(f'Channel request failed, error reason: {p["decoded"]["routing"]["errorReason"]}')
│ │ -                self._timeout.expireTime = time.time() # Do not wait any longer
│ │ -                return # Don't try to parse this routing message
│ │ +                logging.warning(
│ │ +                    f'Channel request failed, error reason: {p["decoded"]["routing"]["errorReason"]}'
│ │ +                )
│ │ +                self._timeout.expireTime = time.time()  # Do not wait any longer
│ │ +                return  # Don't try to parse this routing message
│ │              lastTried = 0
│ │              if len(self.partialChannels) > 0:
│ │                  lastTried = self.partialChannels[-1].index
│ │              logging.debug(f"Retrying previous channel request.")
│ │              self._requestChannel(lastTried)
│ │              return
│ │  
│ │ @@ -748,66 +682,89 @@
│ │          index = c.index
│ │  
│ │          # for stress testing, we can always download all channels
│ │          fastChannelDownload = True
│ │  
│ │          # Once we see a response that has NO settings, assume
│ │          # we are at the end of channels and stop fetching
│ │ -        quitEarly = (c.role == channel_pb2.Channel.Role.DISABLED) and fastChannelDownload
│ │ +        quitEarly = (
│ │ +            c.role == channel_pb2.Channel.Role.DISABLED
│ │ +        ) and fastChannelDownload
│ │  
│ │          if quitEarly or index >= self.iface.myInfo.max_channels - 1:
│ │              logging.debug("Finished downloading channels")
│ │  
│ │              self.channels = self.partialChannels
│ │              self._fixupChannels()
│ │  
│ │              # FIXME, the following should only be called after we have settings and channels
│ │              self.iface._connected()  # Tell everyone else we are ready to go
│ │          else:
│ │              self._requestChannel(index + 1)
│ │  
│ │      def onAckNak(self, p):
│ │          if p["decoded"]["routing"]["errorReason"] != "NONE":
│ │ -            print(f'Received a NAK, error reason: {p["decoded"]["routing"]["errorReason"]}')
│ │ +            print(
│ │ +                f'Received a NAK, error reason: {p["decoded"]["routing"]["errorReason"]}'
│ │ +            )
│ │              self.iface._acknowledgment.receivedNak = True
│ │ -        else: 
│ │ +        else:
│ │              if int(p["from"]) == self.iface.localNode.nodeNum:
│ │ -              print(f'Received an implicit ACK. Packet will likely arrive, but cannot be guaranteed.')
│ │ -              self.iface._acknowledgment.receivedImplAck = True
│ │ -            else: 
│ │ -              print(f'Received an ACK.')
│ │ -              self.iface._acknowledgment.receivedAck = True
│ │ -            
│ │ +                print(
│ │ +                    f"Received an implicit ACK. Packet will likely arrive, but cannot be guaranteed."
│ │ +                )
│ │ +                self.iface._acknowledgment.receivedImplAck = True
│ │ +            else:
│ │ +                print(f"Received an ACK.")
│ │ +                self.iface._acknowledgment.receivedAck = True
│ │ +
│ │      def _requestChannel(self, channelNum: int):
│ │          """Done with initial config messages, now send regular
│ │ -           MeshPackets to ask for settings"""
│ │ +        MeshPackets to ask for settings"""
│ │          p = admin_pb2.AdminMessage()
│ │          p.get_channel_request = channelNum + 1
│ │  
│ │          # Show progress message for super slow operations
│ │          if self != self.iface.localNode:
│ │ -            print(f"Requesting channel {channelNum} info from remote node (this could take a while)")
│ │ -            logging.debug(f"Requesting channel {channelNum} info from remote node (this could take a while)")
│ │ +            print(
│ │ +                f"Requesting channel {channelNum} info from remote node (this could take a while)"
│ │ +            )
│ │ +            logging.debug(
│ │ +                f"Requesting channel {channelNum} info from remote node (this could take a while)"
│ │ +            )
│ │          else:
│ │              logging.debug(f"Requesting channel {channelNum}")
│ │  
│ │ -        return self._sendAdmin(p, wantResponse=True, onResponse=self.onResponseRequestChannel)
│ │ -
│ │ +        return self._sendAdmin(
│ │ +            p, wantResponse=True, onResponse=self.onResponseRequestChannel
│ │ +        )
│ │  
│ │      # pylint: disable=R1710
│ │ -    def _sendAdmin(self, p: admin_pb2.AdminMessage, wantResponse=True,
│ │ -                   onResponse=None, adminIndex=0):
│ │ +    def _sendAdmin(
│ │ +        self,
│ │ +        p: admin_pb2.AdminMessage,
│ │ +        wantResponse=True,
│ │ +        onResponse=None,
│ │ +        adminIndex=0,
│ │ +    ):
│ │          """Send an admin message to the specified node (or the local node if destNodeNum is zero)"""
│ │  
│ │          if self.noProto:
│ │ -            logging.warning(f"Not sending packet because protocol use is disabled by noProto")
│ │ +            logging.warning(
│ │ +                f"Not sending packet because protocol use is disabled by noProto"
│ │ +            )
│ │          else:
│ │ -            if adminIndex == 0:  # unless a special channel index was used, we want to use the admin index
│ │ +            if (
│ │ +                adminIndex == 0
│ │ +            ):  # unless a special channel index was used, we want to use the admin index
│ │                  adminIndex = self.iface.localNode._getAdminChannelIndex()
│ │ -            logging.debug(f'adminIndex:{adminIndex}')
│ │ -            
│ │ -            return self.iface.sendData(p, self.nodeNum,
│ │ -                                       portNum=portnums_pb2.PortNum.ADMIN_APP,
│ │ -                                       wantAck=False,
│ │ -                                       wantResponse=wantResponse,
│ │ -                                       onResponse=onResponse,
│ │ -                                       channelIndex=adminIndex)
│ │ +            logging.debug(f"adminIndex:{adminIndex}")
│ │ +
│ │ +            return self.iface.sendData(
│ │ +                p,
│ │ +                self.nodeNum,
│ │ +                portNum=portnums_pb2.PortNum.ADMIN_APP,
│ │ +                wantAck=False,
│ │ +                wantResponse=wantResponse,
│ │ +                onResponse=onResponse,
│ │ +                channelIndex=adminIndex,
│ │ +            )
│ │   --- meshtastic-2.1.4/meshtastic/portnums_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/portnums_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/remote_hardware.py
│ ├── +++ meshtastic-2.1.5/meshtastic/remote_hardware.py
│ │┄ Files 8% similar despite different names
│ │ @@ -1,33 +1,36 @@
│ │  """Remote hardware
│ │  """
│ │  import logging
│ │ +
│ │  from pubsub import pub
│ │ +
│ │  from meshtastic import portnums_pb2, remote_hardware_pb2
│ │  from meshtastic.util import our_exit
│ │  
│ │  
│ │  def onGPIOreceive(packet, interface):
│ │ -    """Callback for received GPIO responses
│ │ -    """
│ │ +    """Callback for received GPIO responses"""
│ │      logging.debug(f"packet:{packet} interface:{interface}")
│ │      gpioValue = 0
│ │      hw = packet["decoded"]["remotehw"]
│ │      if "gpioValue" in hw:
│ │          gpioValue = hw["gpioValue"]
│ │      else:
│ │          if not "gpioMask" in hw:
│ │              # we did get a reply, but due to protobufs, 0 for numeric value is not sent
│ │              # see https://developers.google.com/protocol-buffers/docs/proto3#default
│ │              # so, we set it here
│ │              gpioValue = 0
│ │  
│ │ -    #print(f'mask:{interface.mask}')
│ │ +    # print(f'mask:{interface.mask}')
│ │      value = int(gpioValue) & int(interface.mask)
│ │ -    print(f'Received RemoteHardware type={hw["type"]}, gpio_value={gpioValue} value={value}')
│ │ +    print(
│ │ +        f'Received RemoteHardware type={hw["type"]}, gpio_value={gpioValue} value={value}'
│ │ +    )
│ │      interface.gotResponse = True
│ │  
│ │  
│ │  class RemoteHardwareClient:
│ │      """
│ │      This is the client code to control/monitor simple hardware built into the
│ │      meshtastic devices.  It is intended to be both a useful API/service and example
│ │ @@ -40,50 +43,59 @@
│ │  
│ │          iface is the already open MeshInterface instance
│ │          """
│ │          self.iface = iface
│ │          ch = iface.localNode.getChannelByName("gpio")
│ │          if not ch:
│ │              our_exit(
│ │ -                "Warning: No channel named 'gpio' was found.\n"\
│ │ -                "On the sending and receive nodes create a channel named 'gpio'.\n"\
│ │ -                "For example, run '--ch-add gpio' on one device, then '--seturl' on\n"\
│ │ -                "the other devices using the url from the device where the channel was added.")
│ │ +                "Warning: No channel named 'gpio' was found.\n"
│ │ +                "On the sending and receive nodes create a channel named 'gpio'.\n"
│ │ +                "For example, run '--ch-add gpio' on one device, then '--seturl' on\n"
│ │ +                "the other devices using the url from the device where the channel was added."
│ │ +            )
│ │          self.channelIndex = ch.index
│ │  
│ │          pub.subscribe(onGPIOreceive, "meshtastic.receive.remotehw")
│ │  
│ │      def _sendHardware(self, nodeid, r, wantResponse=False, onResponse=None):
│ │          if not nodeid:
│ │ -            our_exit(r"Warning: Must use a destination node ID for this operation (use --dest \!xxxxxxxxx)")
│ │ -        return self.iface.sendData(r, nodeid, portnums_pb2.REMOTE_HARDWARE_APP,
│ │ -                                   wantAck=True, channelIndex=self.channelIndex,
│ │ -                                   wantResponse=wantResponse, onResponse=onResponse)
│ │ +            our_exit(
│ │ +                r"Warning: Must use a destination node ID for this operation (use --dest \!xxxxxxxxx)"
│ │ +            )
│ │ +        return self.iface.sendData(
│ │ +            r,
│ │ +            nodeid,
│ │ +            portnums_pb2.REMOTE_HARDWARE_APP,
│ │ +            wantAck=True,
│ │ +            channelIndex=self.channelIndex,
│ │ +            wantResponse=wantResponse,
│ │ +            onResponse=onResponse,
│ │ +        )
│ │  
│ │      def writeGPIOs(self, nodeid, mask, vals):
│ │          """
│ │          Write the specified vals bits to the device GPIOs.  Only bits in mask that
│ │          are 1 will be changed
│ │          """
│ │ -        logging.debug(f'writeGPIOs nodeid:{nodeid} mask:{mask} vals:{vals}')
│ │ +        logging.debug(f"writeGPIOs nodeid:{nodeid} mask:{mask} vals:{vals}")
│ │          r = remote_hardware_pb2.HardwareMessage()
│ │          r.type = remote_hardware_pb2.HardwareMessage.Type.WRITE_GPIOS
│ │          r.gpio_mask = mask
│ │          r.gpio_value = vals
│ │          return self._sendHardware(nodeid, r)
│ │  
│ │ -    def readGPIOs(self, nodeid, mask, onResponse = None):
│ │ +    def readGPIOs(self, nodeid, mask, onResponse=None):
│ │          """Read the specified bits from GPIO inputs on the device"""
│ │ -        logging.debug(f'readGPIOs nodeid:{nodeid} mask:{mask}')
│ │ +        logging.debug(f"readGPIOs nodeid:{nodeid} mask:{mask}")
│ │          r = remote_hardware_pb2.HardwareMessage()
│ │          r.type = remote_hardware_pb2.HardwareMessage.Type.READ_GPIOS
│ │          r.gpio_mask = mask
│ │          return self._sendHardware(nodeid, r, wantResponse=True, onResponse=onResponse)
│ │  
│ │      def watchGPIOs(self, nodeid, mask):
│ │          """Watch the specified bits from GPIO inputs on the device for changes"""
│ │ -        logging.debug(f'watchGPIOs nodeid:{nodeid} mask:{mask}')
│ │ +        logging.debug(f"watchGPIOs nodeid:{nodeid} mask:{mask}")
│ │          r = remote_hardware_pb2.HardwareMessage()
│ │          r.type = remote_hardware_pb2.HardwareMessage.Type.WATCH_GPIOS
│ │          r.gpio_mask = mask
│ │          self.iface.mask = mask
│ │          return self._sendHardware(nodeid, r)
│ │   --- meshtastic-2.1.4/meshtastic/remote_hardware_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/remote_hardware_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/rtttl_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/rtttl_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/serial_interface.py
│ ├── +++ meshtastic-2.1.5/meshtastic/serial_interface.py
│ │┄ Files 9% similar despite different names
│ │ @@ -1,20 +1,22 @@
│ │  """ Serial interface class
│ │  """
│ │  import logging
│ │ -import time
│ │  import platform
│ │ +import time
│ │ +
│ │  import serial
│ │  
│ │  import meshtastic.util
│ │  from meshtastic.stream_interface import StreamInterface
│ │  
│ │ -if platform.system() != 'Windows':
│ │ +if platform.system() != "Windows":
│ │      import termios
│ │  
│ │ +
│ │  class SerialInterface(StreamInterface):
│ │      """Interface class for meshtastic devices over a serial link"""
│ │  
│ │      def __init__(self, devPath=None, debugOut=None, noProto=False, connectNow=True):
│ │          """Constructor, opens a connection to a specified serial port, or if unspecified try to
│ │          find one Meshtastic device by probing
│ │  
│ │ @@ -38,27 +40,31 @@
│ │              else:
│ │                  self.devPath = ports[0]
│ │  
│ │          logging.debug(f"Connecting to {self.devPath}")
│ │  
│ │          # first we need to set the HUPCL so the device will not reboot based on RTS and/or DTR
│ │          # see https://github.com/pyserial/pyserial/issues/124
│ │ -        if platform.system() != 'Windows':
│ │ -            with open(self.devPath, encoding='utf8') as f:
│ │ +        if platform.system() != "Windows":
│ │ +            with open(self.devPath, encoding="utf8") as f:
│ │                  attrs = termios.tcgetattr(f)
│ │                  attrs[2] = attrs[2] & ~termios.HUPCL
│ │                  termios.tcsetattr(f, termios.TCSAFLUSH, attrs)
│ │                  f.close()
│ │              time.sleep(0.1)
│ │  
│ │ -        self.stream = serial.Serial(self.devPath, 115200, exclusive=True, timeout=0.5, write_timeout=0)
│ │ +        self.stream = serial.Serial(
│ │ +            self.devPath, 115200, exclusive=True, timeout=0.5, write_timeout=0
│ │ +        )
│ │          self.stream.flush()
│ │          time.sleep(0.1)
│ │  
│ │ -        StreamInterface.__init__(self, debugOut=debugOut, noProto=noProto, connectNow=connectNow)
│ │ +        StreamInterface.__init__(
│ │ +            self, debugOut=debugOut, noProto=noProto, connectNow=connectNow
│ │ +        )
│ │  
│ │      def close(self):
│ │          """Close a connection to the device"""
│ │          self.stream.flush()
│ │          time.sleep(0.1)
│ │          self.stream.flush()
│ │          time.sleep(0.1)
│ │   --- meshtastic-2.1.4/meshtastic/storeforward_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/storeforward_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/stream_interface.py
│ ├── +++ meshtastic-2.1.5/meshtastic/stream_interface.py
│ │┄ Files 4% similar despite different names
│ │ @@ -1,22 +1,21 @@
│ │  """Stream Interface base class
│ │  """
│ │  import logging
│ │  import threading
│ │  import time
│ │  import traceback
│ │ -import serial
│ │  
│ │ +import serial
│ │  
│ │  from meshtastic.mesh_interface import MeshInterface
│ │ -from meshtastic.util import stripnl, is_windows11
│ │ -
│ │ +from meshtastic.util import is_windows11, stripnl
│ │  
│ │  START1 = 0x94
│ │ -START2 = 0xc3
│ │ +START2 = 0xC3
│ │  HEADER_LEN = 4
│ │  MAX_TO_FROM_RADIO_SIZE = 512
│ │  
│ │  
│ │  class StreamInterface(MeshInterface):
│ │      """Interface class for meshtastic devices over a stream link (serial, TCP, etc)"""
│ │  
│ │ @@ -28,17 +27,18 @@
│ │                                   device will be emitted to that stream. (default: {None})
│ │  
│ │          Raises:
│ │              Exception: [description]
│ │              Exception: [description]
│ │          """
│ │  
│ │ -        if not hasattr(self, 'stream') and not noProto:
│ │ +        if not hasattr(self, "stream") and not noProto:
│ │              raise Exception(
│ │ -                "StreamInterface is now abstract (to update existing code create SerialInterface instead)")
│ │ +                "StreamInterface is now abstract (to update existing code create SerialInterface instead)"
│ │ +            )
│ │          self._rxBuf = bytes()  # empty
│ │          self._wantExit = False
│ │  
│ │          self.is_windows11 = is_windows11()
│ │  
│ │          # FIXME, figure out why daemon=True causes reader thread to exit too early
│ │          self._rxThread = threading.Thread(target=self.__reader, args=(), daemon=True)
│ │ @@ -106,82 +106,98 @@
│ │  
│ │      def _sendToRadioImpl(self, toRadio):
│ │          """Send a ToRadio protobuf to the device"""
│ │          logging.debug(f"Sending: {stripnl(toRadio)}")
│ │          b = toRadio.SerializeToString()
│ │          bufLen = len(b)
│ │          # We convert into a string, because the TCP code doesn't work with byte arrays
│ │ -        header = bytes([START1, START2, (bufLen >> 8) & 0xff,  bufLen & 0xff])
│ │ -        logging.debug(f'sending header:{header} b:{b}')
│ │ +        header = bytes([START1, START2, (bufLen >> 8) & 0xFF, bufLen & 0xFF])
│ │ +        logging.debug(f"sending header:{header} b:{b}")
│ │          self._writeBytes(header + b)
│ │  
│ │      def close(self):
│ │          """Close a connection to the device"""
│ │          logging.debug("Closing stream")
│ │          MeshInterface.close(self)
│ │          # pyserial cancel_read doesn't seem to work, therefore we ask the
│ │          # reader thread to close things for us
│ │          self._wantExit = True
│ │          if self._rxThread != threading.current_thread():
│ │              self._rxThread.join()  # wait for it to exit
│ │  
│ │      def __reader(self):
│ │          """The reader thread that reads bytes from our stream"""
│ │ -        logging.debug('in __reader()')
│ │ +        logging.debug("in __reader()")
│ │          empty = bytes()
│ │  
│ │          try:
│ │              while not self._wantExit:
│ │ -                #logging.debug("reading character")
│ │ +                # logging.debug("reading character")
│ │                  b = self._readBytes(1)
│ │ -                #logging.debug("In reader loop")
│ │ -                #logging.debug(f"read returned {b}")
│ │ +                # logging.debug("In reader loop")
│ │ +                # logging.debug(f"read returned {b}")
│ │                  if len(b) > 0:
│ │                      c = b[0]
│ │ -                    #logging.debug(f'c:{c}')
│ │ +                    # logging.debug(f'c:{c}')
│ │                      ptr = len(self._rxBuf)
│ │  
│ │                      # Assume we want to append this byte, fixme use bytearray instead
│ │                      self._rxBuf = self._rxBuf + b
│ │  
│ │                      if ptr == 0:  # looking for START1
│ │                          if c != START1:
│ │                              self._rxBuf = empty  # failed to find start
│ │                              if self.debugOut is not None:
│ │                                  try:
│ │                                      self.debugOut.write(b.decode("utf-8"))
│ │                                  except:
│ │ -                                    self.debugOut.write('?')
│ │ +                                    self.debugOut.write("?")
│ │  
│ │                      elif ptr == 1:  # looking for START2
│ │                          if c != START2:
│ │                              self._rxBuf = empty  # failed to find start2
│ │                      elif ptr >= HEADER_LEN - 1:  # we've at least got a header
│ │ -                        #logging.debug('at least we received a header')
│ │ +                        # logging.debug('at least we received a header')
│ │                          # big endian length follows header
│ │                          packetlen = (self._rxBuf[2] << 8) + self._rxBuf[3]
│ │  
│ │ -                        if ptr == HEADER_LEN - 1:  # we _just_ finished reading the header, validate length
│ │ +                        if (
│ │ +                            ptr == HEADER_LEN - 1
│ │ +                        ):  # we _just_ finished reading the header, validate length
│ │                              if packetlen > MAX_TO_FROM_RADIO_SIZE:
│ │ -                                self._rxBuf = empty  # length was out out bounds, restart
│ │ +                                self._rxBuf = (
│ │ +                                    empty  # length was out out bounds, restart
│ │ +                                )
│ │  
│ │                          if len(self._rxBuf) != 0 and ptr + 1 >= packetlen + HEADER_LEN:
│ │                              try:
│ │                                  self._handleFromRadio(self._rxBuf[HEADER_LEN:])
│ │                              except Exception as ex:
│ │ -                                logging.error(f"Error while handling message from radio {ex}")
│ │ +                                logging.error(
│ │ +                                    f"Error while handling message from radio {ex}"
│ │ +                                )
│ │                                  traceback.print_exc()
│ │                              self._rxBuf = empty
│ │                  else:
│ │                      # logging.debug(f"timeout")
│ │                      pass
│ │          except serial.SerialException as ex:
│ │ -            if not self._wantExit:  # We might intentionally get an exception during shutdown
│ │ -                logging.warning(f"Meshtastic serial port disconnected, disconnecting... {ex}")
│ │ +            if (
│ │ +                not self._wantExit
│ │ +            ):  # We might intentionally get an exception during shutdown
│ │ +                logging.warning(
│ │ +                    f"Meshtastic serial port disconnected, disconnecting... {ex}"
│ │ +                )
│ │          except OSError as ex:
│ │ -            if not self._wantExit:  # We might intentionally get an exception during shutdown
│ │ -                logging.error(f"Unexpected OSError, terminating meshtastic reader... {ex}")
│ │ +            if (
│ │ +                not self._wantExit
│ │ +            ):  # We might intentionally get an exception during shutdown
│ │ +                logging.error(
│ │ +                    f"Unexpected OSError, terminating meshtastic reader... {ex}"
│ │ +                )
│ │          except Exception as ex:
│ │ -            logging.error(f"Unexpected exception, terminating meshtastic reader... {ex}")
│ │ +            logging.error(
│ │ +                f"Unexpected exception, terminating meshtastic reader... {ex}"
│ │ +            )
│ │          finally:
│ │              logging.debug("reader is exiting")
│ │              self._disconnected()
│ │   --- meshtastic-2.1.4/meshtastic/tcp_interface.py
│ ├── +++ meshtastic-2.1.5/meshtastic/tcp_interface.py
│ │┄ Files 2% similar despite different names
│ │ @@ -2,19 +2,26 @@
│ │  """
│ │  import logging
│ │  import socket
│ │  from typing import AnyStr
│ │  
│ │  from meshtastic.stream_interface import StreamInterface
│ │  
│ │ +
│ │  class TCPInterface(StreamInterface):
│ │      """Interface class for meshtastic devices over a TCP link"""
│ │  
│ │ -    def __init__(self, hostname: AnyStr, debugOut=None, noProto=False,
│ │ -                 connectNow=True, portNumber=4403):
│ │ +    def __init__(
│ │ +        self,
│ │ +        hostname: AnyStr,
│ │ +        debugOut=None,
│ │ +        noProto=False,
│ │ +        connectNow=True,
│ │ +        portNumber=4403,
│ │ +    ):
│ │          """Constructor, opens a connection to a specified IP address/hostname
│ │  
│ │          Keyword Arguments:
│ │              hostname {string} -- Hostname/IP address of the device to connect to
│ │          """
│ │  
│ │          self.stream = None
│ │ @@ -26,20 +33,21 @@
│ │              logging.debug(f"Connecting to {hostname}")
│ │              server_address = (hostname, portNumber)
│ │              sock = socket.create_connection(server_address)
│ │              self.socket = sock
│ │          else:
│ │              self.socket = None
│ │  
│ │ -        StreamInterface.__init__(self, debugOut=debugOut, noProto=noProto,
│ │ -                                 connectNow=connectNow)
│ │ +        StreamInterface.__init__(
│ │ +            self, debugOut=debugOut, noProto=noProto, connectNow=connectNow
│ │ +        )
│ │  
│ │      def _socket_shutdown(self):
│ │          """Shutdown the socket.
│ │ -           Note: Broke out this line so the exception could be unit tested.
│ │ +        Note: Broke out this line so the exception could be unit tested.
│ │          """
│ │          self.socket.shutdown(socket.SHUT_RDWR)
│ │  
│ │      def myConnect(self):
│ │          """Connect to socket"""
│ │          server_address = (self.hostname, self.portNumber)
│ │          sock = socket.create_connection(server_address)
│ │   --- meshtastic-2.1.4/meshtastic/telemetry_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/telemetry_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic/test.py
│ ├── +++ meshtastic-2.1.5/meshtastic/test.py
│ │┄ Files 4% similar despite different names
│ │ @@ -1,22 +1,23 @@
│ │  """With two radios connected serially, send and receive test
│ │     messages and report back if successful.
│ │  """
│ │  import logging
│ │ -import time
│ │  import sys
│ │ +import time
│ │  import traceback
│ │ +
│ │  from dotmap import DotMap
│ │  from pubsub import pub
│ │ +
│ │  import meshtastic.util
│ │  from meshtastic.__init__ import BROADCAST_NUM
│ │  from meshtastic.serial_interface import SerialInterface
│ │  from meshtastic.tcp_interface import TCPInterface
│ │  
│ │ -
│ │  """The interfaces we are using for our tests"""
│ │  interfaces = None
│ │  
│ │  """A list of all packets we received while the current test was running"""
│ │  receivedPackets = None
│ │  
│ │  testsRunning = False
│ │ @@ -48,15 +49,17 @@
│ │  
│ │  def subscribe():
│ │      """Subscribe to the topics the user probably wants to see, prints output to stdout"""
│ │  
│ │      pub.subscribe(onNode, "meshtastic.node")
│ │  
│ │  
│ │ -def testSend(fromInterface, toInterface, isBroadcast=False, asBinary=False, wantAck=False):
│ │ +def testSend(
│ │ +    fromInterface, toInterface, isBroadcast=False, asBinary=False, wantAck=False
│ │ +):
│ │      """
│ │      Sends one test packet between two nodes and then returns success or failure
│ │  
│ │      Arguments:
│ │          fromInterface {[type]} -- [description]
│ │          toInterface {[type]} -- [description]
│ │  
│ │ @@ -69,27 +72,27 @@
│ │      fromNode = fromInterface.myInfo.my_node_num
│ │  
│ │      if isBroadcast:
│ │          toNode = BROADCAST_NUM
│ │      else:
│ │          toNode = toInterface.myInfo.my_node_num
│ │  
│ │ -    logging.debug(
│ │ -        f"Sending test wantAck={wantAck} packet from {fromNode} to {toNode}")
│ │ +    logging.debug(f"Sending test wantAck={wantAck} packet from {fromNode} to {toNode}")
│ │      # pylint: disable=W0603
│ │      global sendingInterface
│ │      sendingInterface = fromInterface
│ │      if not asBinary:
│ │          fromInterface.sendText(f"Test {testNumber}", toNode, wantAck=wantAck)
│ │      else:
│ │ -        fromInterface.sendData((f"Binary {testNumber}").encode(
│ │ -            "utf-8"), toNode, wantAck=wantAck)
│ │ +        fromInterface.sendData(
│ │ +            (f"Binary {testNumber}").encode("utf-8"), toNode, wantAck=wantAck
│ │ +        )
│ │      for _ in range(60):  # max of 60 secs before we timeout
│ │          time.sleep(1)
│ │ -        if  len(receivedPackets) >= 1:
│ │ +        if len(receivedPackets) >= 1:
│ │              return True
│ │      return False  # Failed to send
│ │  
│ │  
│ │  def runTests(numTests=50, wantAck=False, maxFailures=0):
│ │      """Run the tests."""
│ │      logging.info(f"Running {numTests} tests with wantAck={wantAck}")
│ │ @@ -98,23 +101,26 @@
│ │      for _ in range(numTests):
│ │          # pylint: disable=W0603
│ │          global testNumber
│ │          testNumber = testNumber + 1
│ │          isBroadcast = True
│ │          # asBinary=(i % 2 == 0)
│ │          success = testSend(
│ │ -            interfaces[0], interfaces[1], isBroadcast, asBinary=False, wantAck=wantAck)
│ │ +            interfaces[0], interfaces[1], isBroadcast, asBinary=False, wantAck=wantAck
│ │ +        )
│ │          if not success:
│ │              numFail = numFail + 1
│ │              logging.error(
│ │ -                f"Test {testNumber} failed, expected packet not received ({numFail} failures so far)")
│ │ +                f"Test {testNumber} failed, expected packet not received ({numFail} failures so far)"
│ │ +            )
│ │          else:
│ │              numSuccess = numSuccess + 1
│ │              logging.info(
│ │ -                f"Test {testNumber} succeeded {numSuccess} successes {numFail} failures so far")
│ │ +                f"Test {testNumber} succeeded {numSuccess} successes {numFail} failures so far"
│ │ +            )
│ │  
│ │          time.sleep(1)
│ │  
│ │      if numFail > maxFailures:
│ │          logging.error("Too many failures! Test failed!")
│ │          return False
│ │      return True
│ │ @@ -136,33 +142,41 @@
│ │      print(f"Connection changed: {topic.getName()}")
│ │  
│ │  
│ │  def openDebugLog(portName):
│ │      """Open the debug log file"""
│ │      debugname = "log" + portName.replace("/", "_")
│ │      logging.info(f"Writing serial debugging to {debugname}")
│ │ -    return open(debugname, 'w+', buffering=1, encoding='utf8')
│ │ +    return open(debugname, "w+", buffering=1, encoding="utf8")
│ │  
│ │  
│ │  def testAll(numTests=5):
│ │      """
│ │      Run a series of tests using devices we can find.
│ │      This is called from the cli with the "--test" option.
│ │  
│ │      """
│ │      ports = meshtastic.util.findPorts(True)
│ │      if len(ports) < 2:
│ │ -        meshtastic.util.our_exit("Warning: Must have at least two devices connected to USB.")
│ │ +        meshtastic.util.our_exit(
│ │ +            "Warning: Must have at least two devices connected to USB."
│ │ +        )
│ │  
│ │      pub.subscribe(onConnection, "meshtastic.connection")
│ │      pub.subscribe(onReceive, "meshtastic.receive")
│ │      # pylint: disable=W0603
│ │      global interfaces
│ │ -    interfaces = list(map(lambda port: SerialInterface(
│ │ -        port, debugOut=openDebugLog(port), connectNow=True), ports))
│ │ +    interfaces = list(
│ │ +        map(
│ │ +            lambda port: SerialInterface(
│ │ +                port, debugOut=openDebugLog(port), connectNow=True
│ │ +            ),
│ │ +            ports,
│ │ +        )
│ │ +    )
│ │  
│ │      logging.info("Ports opened, starting test")
│ │      result = testThread(numTests)
│ │  
│ │      for i in interfaces:
│ │          i.close()
│ │   --- meshtastic-2.1.4/meshtastic/tunnel.py
│ ├── +++ meshtastic-2.1.5/meshtastic/tunnel.py
│ │┄ Files 4% similar despite different names
│ │ @@ -12,51 +12,51 @@
│ │  # ping -c 1 -W 20 10.115.64.152
│ │  # ping -i 30 -W 30 10.115.64.152
│ │  
│ │  # FIXME: use a more optimal MTU
│ │  """
│ │  
│ │  import logging
│ │ -import threading
│ │  import platform
│ │ -from pubsub import pub
│ │ +import threading
│ │  
│ │ +from pubsub import pub
│ │  from pytap2 import TapDevice
│ │  
│ │  from meshtastic import portnums_pb2
│ │ -from meshtastic.util import ipstr, readnet_u16
│ │  from meshtastic.globals import Globals
│ │ +from meshtastic.util import ipstr, readnet_u16
│ │  
│ │  
│ │ -def onTunnelReceive(packet, interface): # pylint: disable=W0613
│ │ +def onTunnelReceive(packet, interface):  # pylint: disable=W0613
│ │      """Callback for received tunneled messages from mesh."""
│ │ -    logging.debug(f'in onTunnelReceive()')
│ │ +    logging.debug(f"in onTunnelReceive()")
│ │      our_globals = Globals.getInstance()
│ │      tunnelInstance = our_globals.get_tunnelInstance()
│ │      tunnelInstance.onReceive(packet)
│ │  
│ │  
│ │  class Tunnel:
│ │      """A TUN based IP tunnel over meshtastic"""
│ │  
│ │ -    def __init__(self, iface, subnet='10.115', netmask="255.255.0.0"):
│ │ +    def __init__(self, iface, subnet="10.115", netmask="255.255.0.0"):
│ │          """
│ │          Constructor
│ │  
│ │          iface is the already open MeshInterface instance
│ │          subnet is used to construct our network number (normally 10.115.x.x)
│ │          """
│ │  
│ │          if not iface:
│ │              raise Exception("Tunnel() must have a interface")
│ │  
│ │          self.iface = iface
│ │          self.subnetPrefix = subnet
│ │  
│ │ -        if platform.system() != 'Linux':
│ │ +        if platform.system() != "Linux":
│ │              raise Exception("Tunnel() can only be run instantiated on a Linux system")
│ │  
│ │          our_globals = Globals.getInstance()
│ │          our_globals.set_tunnelInstance(self)
│ │  
│ │          """A list of chatty UDP services we should never accidentally
│ │          forward to our slow network"""
│ │ @@ -76,42 +76,50 @@
│ │              0x80,  # Service-Specific Connection-Oriented Protocol in a Multilink and Connectionless Environment
│ │          }
│ │  
│ │          # A new non standard log level that is lower level than DEBUG
│ │          self.LOG_TRACE = 5
│ │  
│ │          # TODO: check if root?
│ │ -        logging.info("Starting IP to mesh tunnel (you must be root for this *pre-alpha* "\
│ │ -                     "feature to work).  Mesh members:")
│ │ +        logging.info(
│ │ +            "Starting IP to mesh tunnel (you must be root for this *pre-alpha* "
│ │ +            "feature to work).  Mesh members:"
│ │ +        )
│ │  
│ │          pub.subscribe(onTunnelReceive, "meshtastic.receive.data.IP_TUNNEL_APP")
│ │          myAddr = self._nodeNumToIp(self.iface.myInfo.my_node_num)
│ │  
│ │          if self.iface.nodes:
│ │              for node in self.iface.nodes.values():
│ │                  nodeId = node["user"]["id"]
│ │                  ip = self._nodeNumToIp(node["num"])
│ │                  logging.info(f"Node { nodeId } has IP address { ip }")
│ │  
│ │          logging.debug("creating TUN device with MTU=200")
│ │          # FIXME - figure out real max MTU, it should be 240 - the overhead bytes for SubPacket and Data
│ │          self.tun = None
│ │          if self.iface.noProto:
│ │ -            logging.warning(f"Not creating a TapDevice() because it is disabled by noProto")
│ │ +            logging.warning(
│ │ +                f"Not creating a TapDevice() because it is disabled by noProto"
│ │ +            )
│ │          else:
│ │              self.tun = TapDevice(name="mesh")
│ │              self.tun.up()
│ │              self.tun.ifconfig(address=myAddr, netmask=netmask, mtu=200)
│ │  
│ │          self._rxThread = None
│ │          if self.iface.noProto:
│ │ -            logging.warning(f"Not starting TUN reader because it is disabled by noProto")
│ │ +            logging.warning(
│ │ +                f"Not starting TUN reader because it is disabled by noProto"
│ │ +            )
│ │          else:
│ │              logging.debug(f"starting TUN reader, our IP address is {myAddr}")
│ │ -            self._rxThread = threading.Thread(target=self.__tunReader, args=(), daemon=True)
│ │ +            self._rxThread = threading.Thread(
│ │ +                target=self.__tunReader, args=(), daemon=True
│ │ +            )
│ │              self._rxThread.start()
│ │  
│ │      def onReceive(self, packet):
│ │          """onReceive"""
│ │          p = packet["decoded"]["payload"]
│ │          if packet["from"] == self.iface.myInfo.my_node_num:
│ │              logging.debug("Ignoring message we sent")
│ │ @@ -128,23 +136,27 @@
│ │          protocol = p[8 + 1]
│ │          srcaddr = p[12:16]
│ │          destAddr = p[16:20]
│ │          subheader = 20
│ │          ignore = False  # Assume we will be forwarding the packet
│ │          if protocol in self.protocolBlacklist:
│ │              ignore = True
│ │ -            logging.log(self.LOG_TRACE, f"Ignoring blacklisted protocol 0x{protocol:02x}")
│ │ +            logging.log(
│ │ +                self.LOG_TRACE, f"Ignoring blacklisted protocol 0x{protocol:02x}"
│ │ +            )
│ │          elif protocol == 0x01:  # ICMP
│ │              icmpType = p[20]
│ │              icmpCode = p[21]
│ │              checksum = p[22:24]
│ │              # pylint: disable=line-too-long
│ │ -            logging.debug(f"forwarding ICMP message src={ipstr(srcaddr)}, dest={ipstr(destAddr)}, type={icmpType}, code={icmpCode}, checksum={checksum}")
│ │ +            logging.debug(
│ │ +                f"forwarding ICMP message src={ipstr(srcaddr)}, dest={ipstr(destAddr)}, type={icmpType}, code={icmpCode}, checksum={checksum}"
│ │ +            )
│ │              # reply to pings (swap src and dest but keep rest of packet unchanged)
│ │ -            #pingback = p[:12]+p[16:20]+p[12:16]+p[20:]
│ │ +            # pingback = p[:12]+p[16:20]+p[12:16]+p[20:]
│ │              # tap.write(pingback)
│ │          elif protocol == 0x11:  # UDP
│ │              srcport = readnet_u16(p, subheader)
│ │              destport = readnet_u16(p, subheader + 2)
│ │              if destport in self.udpBlacklist:
│ │                  ignore = True
│ │                  logging.log(self.LOG_TRACE, f"ignoring blacklisted UDP port {destport}")
│ │ @@ -155,53 +167,58 @@
│ │              destport = readnet_u16(p, subheader + 2)
│ │              if destport in self.tcpBlacklist:
│ │                  ignore = True
│ │                  logging.log(self.LOG_TRACE, f"ignoring blacklisted TCP port {destport}")
│ │              else:
│ │                  logging.debug(f"forwarding tcp srcport={srcport}, destport={destport}")
│ │          else:
│ │ -            logging.warning(f"forwarding unexpected protocol 0x{protocol:02x}, "\
│ │ -                             "src={ipstr(srcaddr)}, dest={ipstr(destAddr)}")
│ │ +            logging.warning(
│ │ +                f"forwarding unexpected protocol 0x{protocol:02x}, "
│ │ +                "src={ipstr(srcaddr)}, dest={ipstr(destAddr)}"
│ │ +            )
│ │  
│ │          return ignore
│ │  
│ │      def __tunReader(self):
│ │          tap = self.tun
│ │          logging.debug("TUN reader running")
│ │          while True:
│ │              p = tap.read()
│ │ -            #logging.debug(f"IP packet received on TUN interface, type={type(p)}")
│ │ +            # logging.debug(f"IP packet received on TUN interface, type={type(p)}")
│ │              destAddr = p[16:20]
│ │  
│ │              if not self._shouldFilterPacket(p):
│ │                  self.sendPacket(destAddr, p)
│ │  
│ │      def _ipToNodeId(self, ipAddr):
│ │          # We only consider the last 16 bits of the nodenum for IP address matching
│ │          ipBits = ipAddr[2] * 256 + ipAddr[3]
│ │  
│ │ -        if ipBits == 0xffff:
│ │ +        if ipBits == 0xFFFF:
│ │              return "^all"
│ │  
│ │          for node in self.iface.nodes.values():
│ │ -            nodeNum = node["num"] & 0xffff
│ │ +            nodeNum = node["num"] & 0xFFFF
│ │              # logging.debug(f"Considering nodenum 0x{nodeNum:x} for ipBits 0x{ipBits:x}")
│ │              if (nodeNum) == ipBits:
│ │                  return node["user"]["id"]
│ │          return None
│ │  
│ │      def _nodeNumToIp(self, nodeNum):
│ │          return f"{self.subnetPrefix}.{(nodeNum >> 8) & 0xff}.{nodeNum & 0xff}"
│ │  
│ │      def sendPacket(self, destAddr, p):
│ │          """Forward the provided IP packet into the mesh"""
│ │          nodeId = self._ipToNodeId(destAddr)
│ │          if nodeId is not None:
│ │ -            logging.debug(f"Forwarding packet bytelen={len(p)} dest={ipstr(destAddr)}, destNode={nodeId}")
│ │ -            self.iface.sendData(
│ │ -                p, nodeId, portnums_pb2.IP_TUNNEL_APP, wantAck=False)
│ │ +            logging.debug(
│ │ +                f"Forwarding packet bytelen={len(p)} dest={ipstr(destAddr)}, destNode={nodeId}"
│ │ +            )
│ │ +            self.iface.sendData(p, nodeId, portnums_pb2.IP_TUNNEL_APP, wantAck=False)
│ │          else:
│ │ -            logging.warning(f"Dropping packet because no node found for destIP={ipstr(destAddr)}")
│ │ +            logging.warning(
│ │ +                f"Dropping packet because no node found for destIP={ipstr(destAddr)}"
│ │ +            )
│ │  
│ │      def close(self):
│ │          """Close"""
│ │          self.tun.close()
│ │   --- meshtastic-2.1.4/meshtastic/util.py
│ ├── +++ meshtastic-2.1.5/meshtastic/util.py
│ │┄ Files 16% similar despite different names
│ │ @@ -1,38 +1,41 @@
│ │  """Utility functions.
│ │  """
│ │ -import traceback
│ │ -from queue import Queue
│ │ +import base64
│ │ +import logging
│ │  import os
│ │ +import platform
│ │  import re
│ │ +import subprocess
│ │  import sys
│ │ -import base64
│ │ -import time
│ │ -import platform
│ │ -import logging
│ │  import threading
│ │ -import subprocess
│ │ +import time
│ │ +import traceback
│ │ +from queue import Queue
│ │ +
│ │ +import pkg_resources
│ │ +import requests
│ │  import serial
│ │  import serial.tools.list_ports
│ │ -import pkg_resources
│ │  
│ │  from meshtastic.supported_device import supported_devices
│ │  
│ │  """Some devices such as a seger jlink we never want to accidentally open"""
│ │  blacklistVids = dict.fromkeys([0x1366])
│ │  
│ │  
│ │  def quoteBooleans(a_string):
│ │      """Quote booleans
│ │ -        given a string that contains ": true", replace with ": 'true'" (or false)
│ │ +    given a string that contains ": true", replace with ": 'true'" (or false)
│ │      """
│ │      tmp = a_string.replace(": true", ": 'true'")
│ │      tmp = tmp.replace(": false", ": 'false'")
│ │      return tmp
│ │  
│ │ +
│ │  def genPSK256():
│ │      """Generate a random preshared key"""
│ │      return os.urandom(32)
│ │  
│ │  
│ │  def fromPSK(valstr):
│ │      """A special version of fromStr that assumes the user is trying to set a PSK.
│ │ @@ -57,18 +60,18 @@
│ │      Returns: an int, bool, float, str or byte array (for strings of hex digits)
│ │  
│ │      Args:
│ │          valstr (string): A user provided string
│ │      """
│ │      if len(valstr) == 0:  # Treat an emptystring as an empty bytes
│ │          val = bytes()
│ │ -    elif valstr.startswith('0x'):
│ │ +    elif valstr.startswith("0x"):
│ │          # if needed convert to string with asBytes.decode('utf-8')
│ │          val = bytes.fromhex(valstr[2:])
│ │ -    elif valstr.startswith('base64:'):
│ │ +    elif valstr.startswith("base64:"):
│ │          val = base64.b64decode(valstr[7:])
│ │      elif valstr.lower() in {"t", "true", "yes"}:
│ │          val = True
│ │      elif valstr.lower() in {"f", "false", "no"}:
│ │          val = False
│ │      else:
│ │          try:
│ │ @@ -96,15 +99,15 @@
│ │      else:
│ │          return "secret"
│ │  
│ │  
│ │  def stripnl(s):
│ │      """Remove newlines from a string (and remove extra whitespace)"""
│ │      s = str(s).replace("\n", " ")
│ │ -    return ' '.join(s.split())
│ │ +    return " ".join(s.split())
│ │  
│ │  
│ │  def fixme(message):
│ │      """Raise an exception for things that needs to be fixed"""
│ │      raise Exception(f"FIXME: {message}")
│ │  
│ │  
│ │ @@ -119,32 +122,40 @@
│ │  def findPorts(eliminate_duplicates=False):
│ │      """Find all ports that might have meshtastic devices
│ │         eliminate_duplicates will run the eliminate_duplicate_port() on the collection
│ │  
│ │      Returns:
│ │          list -- a list of device paths
│ │      """
│ │ -    l = list(map(lambda port: port.device,
│ │ -                 filter(lambda port: port.vid is not None and port.vid not in blacklistVids,
│ │ -                        serial.tools.list_ports.comports())))
│ │ +    l = list(
│ │ +        map(
│ │ +            lambda port: port.device,
│ │ +            filter(
│ │ +                lambda port: port.vid is not None and port.vid not in blacklistVids,
│ │ +                serial.tools.list_ports.comports(),
│ │ +            ),
│ │ +        )
│ │ +    )
│ │      l.sort()
│ │      if eliminate_duplicates:
│ │          l = eliminate_duplicate_port(l)
│ │      return l
│ │  
│ │  
│ │  class dotdict(dict):
│ │      """dot.notation access to dictionary attributes"""
│ │ +
│ │      __getattr__ = dict.get
│ │      __setattr__ = dict.__setitem__
│ │      __delattr__ = dict.__delitem__
│ │  
│ │  
│ │  class Timeout:
│ │      """Timeout class"""
│ │ +
│ │      def __init__(self, maxSecs=20):
│ │          self.expireTime = 0
│ │          self.sleepInterval = 0.1
│ │          self.expireTimeout = maxSecs
│ │  
│ │      def reset(self):
│ │          """Restart the waitForSet timer"""
│ │ @@ -155,290 +166,309 @@
│ │          self.reset()
│ │          while time.time() < self.expireTime:
│ │              if all(map(lambda a: getattr(target, a, None), attrs)):
│ │                  return True
│ │              time.sleep(self.sleepInterval)
│ │          return False
│ │  
│ │ -    def waitForAckNak(self, acknowledgment, attrs=('receivedAck', 'receivedNak', 'receivedImplAck')):
│ │ +    def waitForAckNak(
│ │ +        self, acknowledgment, attrs=("receivedAck", "receivedNak", "receivedImplAck")
│ │ +    ):
│ │          """Block until an ACK or NAK has been received. Returns True if ACK or NAK has been received."""
│ │          self.reset()
│ │          while time.time() < self.expireTime:
│ │              if any(map(lambda a: getattr(acknowledgment, a, None), attrs)):
│ │                  acknowledgment.reset()
│ │                  return True
│ │              time.sleep(self.sleepInterval)
│ │          return False
│ │  
│ │ -    def waitForTraceRoute(self, waitFactor, acknowledgment, attr='receivedTraceRoute'):
│ │ +    def waitForTraceRoute(self, waitFactor, acknowledgment, attr="receivedTraceRoute"):
│ │          """Block until traceroute response is received. Returns True if traceroute response has been received."""
│ │          self.expireTimeout *= waitFactor
│ │          self.reset()
│ │          while time.time() < self.expireTime:
│ │              if getattr(acknowledgment, attr, None):
│ │                  acknowledgment.reset()
│ │                  return True
│ │              time.sleep(self.sleepInterval)
│ │          return False
│ │  
│ │ +
│ │  class Acknowledgment:
│ │      "A class that records which type of acknowledgment was just received, if any."
│ │ +
│ │      def __init__(self):
│ │          """initialize"""
│ │          self.receivedAck = False
│ │          self.receivedNak = False
│ │          self.receivedImplAck = False
│ │          self.receivedTraceRoute = False
│ │  
│ │      def reset(self):
│ │          """reset"""
│ │          self.receivedAck = False
│ │          self.receivedNak = False
│ │          self.receivedImplAck = False
│ │          self.receivedTraceRoute = False
│ │  
│ │ -class DeferredExecution():
│ │ +
│ │ +class DeferredExecution:
│ │      """A thread that accepts closures to run, and runs them as they are received"""
│ │  
│ │      def __init__(self, name=None):
│ │          self.queue = Queue()
│ │          self.thread = threading.Thread(target=self._run, args=(), name=name)
│ │          self.thread.daemon = True
│ │          self.thread.start()
│ │  
│ │      def queueWork(self, runnable):
│ │ -        """ Queue up the work"""
│ │ +        """Queue up the work"""
│ │          self.queue.put(runnable)
│ │  
│ │      def _run(self):
│ │          while True:
│ │              try:
│ │                  o = self.queue.get()
│ │                  o()
│ │              except:
│ │ -                logging.error(f"Unexpected error in deferred execution {sys.exc_info()[0]}")
│ │ +                logging.error(
│ │ +                    f"Unexpected error in deferred execution {sys.exc_info()[0]}"
│ │ +                )
│ │                  print(traceback.format_exc())
│ │  
│ │  
│ │ -def our_exit(message, return_value = 1):
│ │ +def our_exit(message, return_value=1):
│ │      """Print the message and return a value.
│ │ -       return_value defaults to 1 (non-successful)
│ │ +    return_value defaults to 1 (non-successful)
│ │      """
│ │      print(message)
│ │      sys.exit(return_value)
│ │  
│ │  
│ │  def support_info():
│ │      """Print out info that helps troubleshooting of the cli."""
│ │ -    print('')
│ │ -    print('If having issues with meshtastic cli or python library')
│ │ -    print('or wish to make feature requests, visit:')
│ │ -    print('https://github.com/meshtastic/python/issues')
│ │ -    print('When adding an issue, be sure to include the following info:')
│ │ -    print(f' System: {platform.system()}')
│ │ -    print(f'   Platform: {platform.platform()}')
│ │ -    print(f'   Release: {platform.uname().release}')
│ │ -    print(f'   Machine: {platform.uname().machine}')
│ │ -    print(f'   Encoding (stdin): {sys.stdin.encoding}')
│ │ -    print(f'   Encoding (stdout): {sys.stdout.encoding}')
│ │ +    print("")
│ │ +    print("If having issues with meshtastic cli or python library")
│ │ +    print("or wish to make feature requests, visit:")
│ │ +    print("https://github.com/meshtastic/python/issues")
│ │ +    print("When adding an issue, be sure to include the following info:")
│ │ +    print(f" System: {platform.system()}")
│ │ +    print(f"   Platform: {platform.platform()}")
│ │ +    print(f"   Release: {platform.uname().release}")
│ │ +    print(f"   Machine: {platform.uname().machine}")
│ │ +    print(f"   Encoding (stdin): {sys.stdin.encoding}")
│ │ +    print(f"   Encoding (stdout): {sys.stdout.encoding}")
│ │      the_version = pkg_resources.get_distribution("meshtastic").version
│ │ -    print(f' meshtastic: v{the_version}')
│ │ -    print(f' Executable: {sys.argv[0]}')
│ │ -    print(f' Python: {platform.python_version()} {platform.python_implementation()} {platform.python_compiler()}')
│ │ -    print('')
│ │ -    print('Please add the output from the command: meshtastic --info')
│ │ +    pypi_version = check_if_newer_version()
│ │ +    if pypi_version:
│ │ +        print(
│ │ +            f" meshtastic: v{the_version} (*** newer version v{pypi_version} available ***)"
│ │ +        )
│ │ +    else:
│ │ +        print(f" meshtastic: v{the_version}")
│ │ +    print(f" Executable: {sys.argv[0]}")
│ │ +    print(
│ │ +        f" Python: {platform.python_version()} {platform.python_implementation()} {platform.python_compiler()}"
│ │ +    )
│ │ +    print("")
│ │ +    print("Please add the output from the command: meshtastic --info")
│ │  
│ │  
│ │  def remove_keys_from_dict(keys, adict):
│ │      """Return a dictionary without some keys in it.
│ │ -       Will removed nested keys.
│ │ +    Will removed nested keys.
│ │      """
│ │      for key in keys:
│ │          try:
│ │              del adict[key]
│ │          except:
│ │              pass
│ │      for val in adict.values():
│ │          if isinstance(val, dict):
│ │              remove_keys_from_dict(keys, val)
│ │      return adict
│ │  
│ │  
│ │  def hexstr(barray):
│ │      """Print a string of hex digits"""
│ │ -    return ":".join(f'{x:02x}' for x in barray)
│ │ +    return ":".join(f"{x:02x}" for x in barray)
│ │  
│ │  
│ │  def ipstr(barray):
│ │      """Print a string of ip digits"""
│ │ -    return ".".join(f'{x}' for x in barray)
│ │ +    return ".".join(f"{x}" for x in barray)
│ │  
│ │  
│ │  def readnet_u16(p, offset):
│ │      """Read big endian u16 (network byte order)"""
│ │      return p[offset] * 256 + p[offset + 1]
│ │  
│ │  
│ │  def convert_mac_addr(val):
│ │      """Convert the base 64 encoded value to a mac address
│ │ -       val - base64 encoded value (ex: '/c0gFyhb'))
│ │ -       returns: a string formatted like a mac address (ex: 'fd:cd:20:17:28:5b')
│ │ +    val - base64 encoded value (ex: '/c0gFyhb'))
│ │ +    returns: a string formatted like a mac address (ex: 'fd:cd:20:17:28:5b')
│ │      """
│ │      if not re.match("[0-9a-f]{2}([-:]?)[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", val):
│ │          val_as_bytes = base64.b64decode(val)
│ │          return hexstr(val_as_bytes)
│ │      return val
│ │  
│ │  
│ │  def snake_to_camel(a_string):
│ │      """convert snake_case to camelCase"""
│ │      # split underscore using split
│ │ -    temp = a_string.split('_')
│ │ +    temp = a_string.split("_")
│ │      # joining result
│ │ -    result = temp[0] + ''.join(ele.title() for ele in temp[1:])
│ │ +    result = temp[0] + "".join(ele.title() for ele in temp[1:])
│ │      return result
│ │  
│ │  
│ │  def camel_to_snake(a_string):
│ │      """convert camelCase to snake_case"""
│ │ -    return ''.join(['_'+i.lower() if i.isupper() else i for i in a_string]).lstrip('_')
│ │ +    return "".join(["_" + i.lower() if i.isupper() else i for i in a_string]).lstrip(
│ │ +        "_"
│ │ +    )
│ │  
│ │  
│ │  def detect_supported_devices():
│ │      """detect supported devices based on vendor id"""
│ │      system = platform.system()
│ │ -    #print(f'system:{system}')
│ │ +    # print(f'system:{system}')
│ │  
│ │      possible_devices = set()
│ │      if system == "Linux":
│ │          # if linux, run lsusb and list ports
│ │  
│ │          # linux: use lsusb
│ │          # Bus 001 Device 091: ID 10c4:ea60 Silicon Labs CP210x UART Bridge
│ │ -        _, lsusb_output = subprocess.getstatusoutput('lsusb')
│ │ +        _, lsusb_output = subprocess.getstatusoutput("lsusb")
│ │          vids = get_unique_vendor_ids()
│ │          for vid in vids:
│ │ -            #print(f'looking for {vid}...')
│ │ -            search = f' {vid}:'
│ │ -            #print(f'search:"{search}"')
│ │ +            # print(f'looking for {vid}...')
│ │ +            search = f" {vid}:"
│ │ +            # print(f'search:"{search}"')
│ │              if re.search(search, lsusb_output, re.MULTILINE):
│ │ -                #print(f'Found vendor id that matches')
│ │ +                # print(f'Found vendor id that matches')
│ │                  devices = get_devices_with_vendor_id(vid)
│ │                  for device in devices:
│ │                      possible_devices.add(device)
│ │  
│ │      elif system == "Windows":
│ │          # if windows, run Get-PnpDevice
│ │ -        _, sp_output = subprocess.getstatusoutput('powershell.exe "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8;'
│ │ -                                                  'Get-PnpDevice -PresentOnly | Format-List"')
│ │ -        #print(f'sp_output:{sp_output}')
│ │ +        _, sp_output = subprocess.getstatusoutput(
│ │ +            'powershell.exe "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8;'
│ │ +            'Get-PnpDevice -PresentOnly | Format-List"'
│ │ +        )
│ │ +        # print(f'sp_output:{sp_output}')
│ │          vids = get_unique_vendor_ids()
│ │          for vid in vids:
│ │ -            #print(f'looking for {vid.upper()}...')
│ │ -            search = f'DeviceID.*{vid.upper()}&'
│ │ -            #search = f'{vid.upper()}'
│ │ -            #print(f'search:"{search}"')
│ │ +            # print(f'looking for {vid.upper()}...')
│ │ +            search = f"DeviceID.*{vid.upper()}&"
│ │ +            # search = f'{vid.upper()}'
│ │ +            # print(f'search:"{search}"')
│ │              if re.search(search, sp_output, re.MULTILINE):
│ │ -                #print(f'Found vendor id that matches')
│ │ +                # print(f'Found vendor id that matches')
│ │                  devices = get_devices_with_vendor_id(vid)
│ │                  for device in devices:
│ │                      possible_devices.add(device)
│ │  
│ │      elif system == "Darwin":
│ │          # run: system_profiler SPUSBDataType
│ │          # Note: If in boot mode, the 19003 reports same product ID as 5005.
│ │  
│ │ -        _, sp_output = subprocess.getstatusoutput('system_profiler SPUSBDataType')
│ │ +        _, sp_output = subprocess.getstatusoutput("system_profiler SPUSBDataType")
│ │          vids = get_unique_vendor_ids()
│ │          for vid in vids:
│ │ -            #print(f'looking for {vid}...')
│ │ -            search = f'Vendor ID: 0x{vid}'
│ │ -            #print(f'search:"{search}"')
│ │ +            # print(f'looking for {vid}...')
│ │ +            search = f"Vendor ID: 0x{vid}"
│ │ +            # print(f'search:"{search}"')
│ │              if re.search(search, sp_output, re.MULTILINE):
│ │ -                #print(f'Found vendor id that matches')
│ │ +                # print(f'Found vendor id that matches')
│ │                  devices = get_devices_with_vendor_id(vid)
│ │                  for device in devices:
│ │                      possible_devices.add(device)
│ │      return possible_devices
│ │  
│ │  
│ │  def detect_windows_needs_driver(sd, print_reason=False):
│ │      """detect if Windows user needs to install driver for a supported device"""
│ │      need_to_install_driver = False
│ │  
│ │      if sd:
│ │          system = platform.system()
│ │ -        #print(f'in detect_windows_needs_driver system:{system}')
│ │ +        # print(f'in detect_windows_needs_driver system:{system}')
│ │  
│ │          if system == "Windows":
│ │              # if windows, see if we can find a DeviceId with the vendor id
│ │              # Get-PnpDevice  | Where-Object{ ($_.DeviceId -like '*10C4*')} | Format-List
│ │              command = 'powershell.exe "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8; Get-PnpDevice | Where-Object{ ($_.DeviceId -like '
│ │              command += f"'*{sd.usb_vendor_id_in_hex.upper()}*'"
│ │              command += ')} | Format-List"'
│ │  
│ │ -            #print(f'command:{command}')
│ │ +            # print(f'command:{command}')
│ │              _, sp_output = subprocess.getstatusoutput(command)
│ │ -            #print(f'sp_output:{sp_output}')
│ │ -            search = f'CM_PROB_FAILED_INSTALL'
│ │ -            #print(f'search:"{search}"')
│ │ +            # print(f'sp_output:{sp_output}')
│ │ +            search = f"CM_PROB_FAILED_INSTALL"
│ │ +            # print(f'search:"{search}"')
│ │              if re.search(search, sp_output, re.MULTILINE):
│ │                  need_to_install_driver = True
│ │                  # if the want to see the reason
│ │                  if print_reason:
│ │                      print(sp_output)
│ │      return need_to_install_driver
│ │  
│ │  
│ │  def eliminate_duplicate_port(ports):
│ │      """Sometimes we detect 2 serial ports, but we really only need to use one of the ports.
│ │  
│ │ -       ports is a list of ports
│ │ -       return a list with a single port to use, if it meets the duplicate port conditions
│ │ +    ports is a list of ports
│ │ +    return a list with a single port to use, if it meets the duplicate port conditions
│ │  
│ │ -        examples:
│ │ -            Ports: ['/dev/cu.usbserial-1430', '/dev/cu.wchusbserial1430'] => ['/dev/cu.wchusbserial1430']
│ │ -            Ports: ['/dev/cu.usbmodem11301', '/dev/cu.wchusbserial11301'] => ['/dev/cu.wchusbserial11301']
│ │ -            Ports: ['/dev/cu.SLAB_USBtoUART', '/dev/cu.usbserial-0001'] => ['/dev/cu.usbserial-0001']
│ │ +     examples:
│ │ +         Ports: ['/dev/cu.usbserial-1430', '/dev/cu.wchusbserial1430'] => ['/dev/cu.wchusbserial1430']
│ │ +         Ports: ['/dev/cu.usbmodem11301', '/dev/cu.wchusbserial11301'] => ['/dev/cu.wchusbserial11301']
│ │ +         Ports: ['/dev/cu.SLAB_USBtoUART', '/dev/cu.usbserial-0001'] => ['/dev/cu.usbserial-0001']
│ │      """
│ │      new_ports = []
│ │      if len(ports) != 2:
│ │          new_ports = ports
│ │      else:
│ │          ports.sort()
│ │ -        if 'usbserial' in ports[0] and 'wchusbserial' in ports[1]:
│ │ +        if "usbserial" in ports[0] and "wchusbserial" in ports[1]:
│ │              first = ports[0].replace("usbserial-", "")
│ │              second = ports[1].replace("wchusbserial", "")
│ │              if first == second:
│ │                  new_ports.append(ports[1])
│ │ -        elif 'usbmodem' in ports[0] and 'wchusbserial' in ports[1]:
│ │ +        elif "usbmodem" in ports[0] and "wchusbserial" in ports[1]:
│ │              first = ports[0].replace("usbmodem", "")
│ │              second = ports[1].replace("wchusbserial", "")
│ │              if first == second:
│ │                  new_ports.append(ports[1])
│ │ -        elif 'SLAB_USBtoUART' in ports[0] and 'usbserial' in ports[1]:
│ │ +        elif "SLAB_USBtoUART" in ports[0] and "usbserial" in ports[1]:
│ │              new_ports.append(ports[1])
│ │          else:
│ │              new_ports = ports
│ │      return new_ports
│ │  
│ │  
│ │  def is_windows11():
│ │      """Detect if Windows 11"""
│ │      is_win11 = False
│ │      if platform.system() == "Windows":
│ │          if float(platform.release()) >= 10.0:
│ │ -            patch = platform.version().split('.')[2]
│ │ +            patch = platform.version().split(".")[2]
│ │              # in case they add some number suffix later, just get first 5 chars of patch
│ │              patch = patch[:5]
│ │              try:
│ │                  if int(patch) >= 22000:
│ │                      is_win11 = True
│ │              except Exception as e:
│ │ -                print(f'problem detecting win11 e:{e}')
│ │ +                print(f"problem detecting win11 e:{e}")
│ │      return is_win11
│ │  
│ │  
│ │  def get_unique_vendor_ids():
│ │      """Return a set of unique vendor ids"""
│ │      vids = set()
│ │      for d in supported_devices:
│ │ @@ -470,54 +500,54 @@
│ │              baseports.add(d.baseport_on_mac)
│ │          elif system == "Windows":
│ │              baseports.add(d.baseport_on_windows)
│ │  
│ │      for bp in baseports:
│ │          if system == "Linux":
│ │              # see if we have any devices (ignoring any stderr output)
│ │ -            command = f'ls -al /dev/{bp}* 2> /dev/null'
│ │ -            #print(f'command:{command}')
│ │ +            command = f"ls -al /dev/{bp}* 2> /dev/null"
│ │ +            # print(f'command:{command}')
│ │              _, ls_output = subprocess.getstatusoutput(command)
│ │ -            #print(f'ls_output:{ls_output}')
│ │ +            # print(f'ls_output:{ls_output}')
│ │              # if we got output, there are ports
│ │              if len(ls_output) > 0:
│ │ -                #print('got output')
│ │ +                # print('got output')
│ │                  # for each line of output
│ │ -                lines = ls_output.split('\n')
│ │ -                #print(f'lines:{lines}')
│ │ +                lines = ls_output.split("\n")
│ │ +                # print(f'lines:{lines}')
│ │                  for line in lines:
│ │ -                    parts = line.split(' ')
│ │ -                    #print(f'parts:{parts}')
│ │ +                    parts = line.split(" ")
│ │ +                    # print(f'parts:{parts}')
│ │                      port = parts[-1]
│ │ -                    #print(f'port:{port}')
│ │ +                    # print(f'port:{port}')
│ │                      ports.add(port)
│ │          elif system == "Darwin":
│ │              # see if we have any devices (ignoring any stderr output)
│ │ -            command = f'ls -al /dev/{bp}* 2> /dev/null'
│ │ -            #print(f'command:{command}')
│ │ +            command = f"ls -al /dev/{bp}* 2> /dev/null"
│ │ +            # print(f'command:{command}')
│ │              _, ls_output = subprocess.getstatusoutput(command)
│ │ -            #print(f'ls_output:{ls_output}')
│ │ +            # print(f'ls_output:{ls_output}')
│ │              # if we got output, there are ports
│ │              if len(ls_output) > 0:
│ │ -                #print('got output')
│ │ +                # print('got output')
│ │                  # for each line of output
│ │ -                lines = ls_output.split('\n')
│ │ -                #print(f'lines:{lines}')
│ │ +                lines = ls_output.split("\n")
│ │ +                # print(f'lines:{lines}')
│ │                  for line in lines:
│ │ -                    parts = line.split(' ')
│ │ -                    #print(f'parts:{parts}')
│ │ +                    parts = line.split(" ")
│ │ +                    # print(f'parts:{parts}')
│ │                      port = parts[-1]
│ │ -                    #print(f'port:{port}')
│ │ +                    # print(f'port:{port}')
│ │                      ports.add(port)
│ │          elif system == "Windows":
│ │              # for each device in supported devices found
│ │              for d in sds:
│ │                  # find the port(s)
│ │                  com_ports = detect_windows_port(d)
│ │ -                #print(f'com_ports:{com_ports}')
│ │ +                # print(f'com_ports:{com_ports}')
│ │                  # add all ports
│ │                  for com_port in com_ports:
│ │                      ports.add(com_port)
│ │      if eliminate_duplicates:
│ │          ports = eliminate_duplicate_port(list(ports))
│ │          ports.sort()
│ │          ports = set(ports)
│ │ @@ -528,20 +558,39 @@
│ │      """detect if Windows port"""
│ │      ports = set()
│ │  
│ │      if sd:
│ │          system = platform.system()
│ │  
│ │          if system == "Windows":
│ │ -            command = ('powershell.exe "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8;'
│ │ -                       'Get-PnpDevice -PresentOnly | Where-Object{ ($_.DeviceId -like ')
│ │ +            command = (
│ │ +                'powershell.exe "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8;'
│ │ +                "Get-PnpDevice -PresentOnly | Where-Object{ ($_.DeviceId -like "
│ │ +            )
│ │              command += f"'*{sd.usb_vendor_id_in_hex.upper()}*'"
│ │              command += ')} | Format-List"'
│ │  
│ │ -            #print(f'command:{command}')
│ │ +            # print(f'command:{command}')
│ │              _, sp_output = subprocess.getstatusoutput(command)
│ │ -            #print(f'sp_output:{sp_output}')
│ │ -            p = re.compile(r'\(COM(.*)\)')
│ │ +            # print(f'sp_output:{sp_output}')
│ │ +            p = re.compile(r"\(COM(.*)\)")
│ │              for x in p.findall(sp_output):
│ │ -                #print(f'x:{x}')
│ │ -                ports.add(f'COM{x}')
│ │ +                # print(f'x:{x}')
│ │ +                ports.add(f"COM{x}")
│ │      return ports
│ │ +
│ │ +
│ │ +def check_if_newer_version():
│ │ +    """Check pip to see if we are running the latest version."""
│ │ +    pypi_version = None
│ │ +    try:
│ │ +        url = "https://pypi.org/pypi/meshtastic/json"
│ │ +        data = requests.get(url, timeout=5).json()
│ │ +        pypi_version = data["info"]["version"]
│ │ +    except Exception:
│ │ +        pass
│ │ +    act_version = pkg_resources.get_distribution("meshtastic").version
│ │ +    if pypi_version and pkg_resources.parse_version(
│ │ +        pypi_version
│ │ +    ) <= pkg_resources.parse_version(act_version):
│ │ +        return None
│ │ +    return pypi_version
│ │   --- meshtastic-2.1.4/meshtastic/xmodem_pb2.py
│ ├── +++ meshtastic-2.1.5/meshtastic/xmodem_pb2.py
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/meshtastic.egg-info/PKG-INFO
│ ├── +++ meshtastic-2.1.5/meshtastic.egg-info/PKG-INFO
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: meshtastic
│ │ -Version: 2.1.4
│ │ +Version: 2.1.5
│ │  Summary: Python API & client shell for talking to Meshtastic devices
│ │  Home-page: https://github.com/meshtastic/python
│ │  Author: Meshtastic Developers
│ │  Author-email: contact@meshtastic.org
│ │  License: GPL-3.0-only
│ │  Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
│ │  Classifier: Development Status :: 4 - Beta
│ │   --- meshtastic-2.1.4/meshtastic.egg-info/SOURCES.txt
│ ├── +++ meshtastic-2.1.5/meshtastic.egg-info/SOURCES.txt
│ │┄ Files identical despite different names
│ │   --- meshtastic-2.1.4/setup.py
│ ├── +++ meshtastic-2.1.5/setup.py
│ │┄ Files 4% similar despite different names
│ │ @@ -1,22 +1,23 @@
│ │  # Note: you shouldn't need to run this script manually.  It is run implicitly by the pip3 install command.
│ │  
│ │  import pathlib
│ │ +
│ │  from setuptools import setup
│ │  
│ │  # The directory containing this file
│ │  HERE = pathlib.Path(__file__).parent
│ │  
│ │  with open("README.md", "r") as fh:
│ │      long_description = fh.read()
│ │  
│ │  # This call to setup() does all the work
│ │  setup(
│ │      name="meshtastic",
│ │ -    version="2.1.4",
│ │ +    version="2.1.5",
│ │      description="Python API & client shell for talking to Meshtastic devices",
│ │      long_description=long_description,
│ │      long_description_content_type="text/markdown",
│ │      url="https://github.com/meshtastic/python",
│ │      author="Meshtastic Developers",
│ │      author_email="contact@meshtastic.org",
│ │      license="GPL-3.0-only",
│ │ @@ -26,22 +27,29 @@
│ │          "Programming Language :: Python :: 3.7",
│ │          "Programming Language :: Python :: 3.8",
│ │          "Programming Language :: Python :: 3.9",
│ │          "Programming Language :: Python :: 3.10",
│ │      ],
│ │      packages=["meshtastic"],
│ │      include_package_data=True,
│ │ -    install_requires=["pyserial>=3.4", "protobuf>=3.13.0",
│ │ -                      "pypubsub>=4.0.3", "dotmap>=1.3.14", "pexpect>=4.6.0", "pyqrcode>=1.2.1",
│ │ -                      "tabulate>=0.8.9", "timeago>=1.0.15", "pyyaml",
│ │ -                      "pygatt>=4.0.5 ; platform_system=='Linux'"],
│ │ -    extras_require={
│ │ -        'tunnel': ["pytap2>=2.0.0"]
│ │ -    },
│ │ -    python_requires='>=3.7',
│ │ +    install_requires=[
│ │ +        "pyserial>=3.4",
│ │ +        "protobuf>=3.13.0",
│ │ +        "requests>=2.25.0",
│ │ +        "pypubsub>=4.0.3",
│ │ +        "dotmap>=1.3.14",
│ │ +        "pexpect>=4.6.0",
│ │ +        "pyqrcode>=1.2.1",
│ │ +        "tabulate>=0.8.9",
│ │ +        "timeago>=1.0.15",
│ │ +        "pyyaml",
│ │ +        "pygatt>=4.0.5 ; platform_system=='Linux'",
│ │ +    ],
│ │ +    extras_require={"tunnel": ["pytap2>=2.0.0"]},
│ │ +    python_requires=">=3.7",
│ │      entry_points={
│ │          "console_scripts": [
│ │              "meshtastic=meshtastic.__main__:main",
│ │ -            "mesh-tunnel=meshtastic.__main__:tunnelMain [tunnel]"
│ │ +            "mesh-tunnel=meshtastic.__main__:tunnelMain [tunnel]",
│ │          ]
│ │      },
│ │  )
