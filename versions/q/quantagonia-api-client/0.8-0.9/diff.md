# Comparing `tmp/quantagonia_api_client-0.8-py3-none-any.whl.zip` & `tmp/quantagonia_api_client-0.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 15083 bytes, number of entries: 22
+Zip file size: 15540 bytes, number of entries: 22
 -rw-r--r--  2.0 unx        0 b- defN 22-Aug-04 14:14 quantagonia/__init__.py
 -rw-r--r--  2.0 unx      247 b- defN 22-Aug-04 14:14 quantagonia/enums.py
--rw-r--r--  2.0 unx     7605 b- defN 22-Aug-08 09:38 quantagonia/qubo.py
--rw-r--r--  2.0 unx      229 b- defN 22-Aug-04 14:51 quantagonia/runner.py
+-rw-r--r--  2.0 unx     8149 b- defN 22-Aug-08 16:42 quantagonia/qubo.py
+-rw-r--r--  2.0 unx      263 b- defN 22-Aug-08 16:42 quantagonia/runner.py
 -rw-r--r--  2.0 unx     1036 b- defN 22-Aug-05 05:36 quantagonia/runner_factory.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Aug-04 14:14 quantagonia/cloud/__init__.py
--rw-r--r--  2.0 unx     2656 b- defN 22-Aug-04 14:51 quantagonia/cloud/cloud_runner.py
--rw-r--r--  2.0 unx      688 b- defN 22-Aug-04 14:14 quantagonia/cloud/solver_log.py
+-rw-r--r--  2.0 unx     5850 b- defN 22-Aug-08 16:42 quantagonia/cloud/cloud_runner.py
+-rw-r--r--  2.0 unx      948 b- defN 22-Aug-08 16:42 quantagonia/cloud/solver_log.py
 -rw-r--r--  2.0 unx     1918 b- defN 22-Aug-04 14:14 quantagonia/cloud/spec_builder.py
 -rw-r--r--  2.0 unx      318 b- defN 22-Aug-04 14:14 quantagonia/cloud/specs_enums.py
--rw-r--r--  2.0 unx     2216 b- defN 22-Aug-05 05:36 quantagonia/cloud/specs_https_client.py
+-rw-r--r--  2.0 unx     3070 b- defN 22-Aug-08 16:42 quantagonia/cloud/specs_https_client.py
 -rw-r--r--  2.0 unx      513 b- defN 22-Aug-04 14:14 quantagonia/cloud/default_specs/cook_GPU.json
 -rw-r--r--  2.0 unx      402 b- defN 22-Aug-04 14:14 quantagonia/cloud/default_specs/fvsdp.json
 -rw-r--r--  2.0 unx      524 b- defN 22-Aug-04 14:14 quantagonia/cloud/default_specs/metropolis_CPU.json
 -rw-r--r--  2.0 unx      314 b- defN 22-Aug-04 14:14 quantagonia/pulp/__init__.py
 -rw-r--r--  2.0 unx     7558 b- defN 22-Aug-04 14:14 quantagonia/pulp/hybrid_solver_api.py
 -rw-r--r--  2.0 unx      521 b- defN 22-Aug-04 14:14 quantagonia/pulp/qpulp_adapter.py
--rw-r--r--  2.0 unx     1460 b- defN 22-Aug-08 09:38 quantagonia_api_client-0.8.dist-info/LICENSE
--rw-r--r--  2.0 unx     1545 b- defN 22-Aug-08 09:38 quantagonia_api_client-0.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Aug-08 09:38 quantagonia_api_client-0.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 22-Aug-08 09:38 quantagonia_api_client-0.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1950 b- defN 22-Aug-08 09:38 quantagonia_api_client-0.8.dist-info/RECORD
-22 files, 31804 bytes uncompressed, 11851 bytes compressed:  62.7%
+-rw-r--r--  2.0 unx     1460 b- defN 22-Aug-08 16:42 quantagonia_api_client-0.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1545 b- defN 22-Aug-08 16:42 quantagonia_api_client-0.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 22-Aug-08 16:42 quantagonia_api_client-0.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 22-Aug-08 16:42 quantagonia_api_client-0.9.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1950 b- defN 22-Aug-08 16:42 quantagonia_api_client-0.9.dist-info/RECORD
+22 files, 36690 bytes uncompressed, 12308 bytes compressed:  66.5%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: quantagonia/pulp/hybrid_solver_api.py
 Comment: 
 
 Filename: quantagonia/pulp/qpulp_adapter.py
 Comment: 
 
-Filename: quantagonia_api_client-0.8.dist-info/LICENSE
+Filename: quantagonia_api_client-0.9.dist-info/LICENSE
 Comment: 
 
-Filename: quantagonia_api_client-0.8.dist-info/METADATA
+Filename: quantagonia_api_client-0.9.dist-info/METADATA
 Comment: 
 
-Filename: quantagonia_api_client-0.8.dist-info/WHEEL
+Filename: quantagonia_api_client-0.9.dist-info/WHEEL
 Comment: 
 
-Filename: quantagonia_api_client-0.8.dist-info/top_level.txt
+Filename: quantagonia_api_client-0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: quantagonia_api_client-0.8.dist-info/RECORD
+Filename: quantagonia_api_client-0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quantagonia/qubo.py

```diff
@@ -217,48 +217,66 @@
                     f.write(f"{term.vars[0].id()} {term.vars[0].id()} {term.coefficient}\n")
                 if(term.order == 2):
                     f.write(f"{term.vars[0].id()} {term.vars[1].id()} {term.coefficient}\n")
 
     def __str__(self):
         return str(self.objective)
 
-    def solve(self, solver_type : QuboSolverType, runner : Runner):
+    def _solvePrep(self, solver_type : QuboSolverType):
 
         # temporary folder for the QUBO problem
         tmp_path = tempfile.mkdtemp()
-        tmp_problem = os.path.join(tmp_path, "pulp.qubo")
+        tmp_problem = os.path.join(tmp_path, "pyclient.qubo")
 
         # convert problem into QUBO format (i.e. a matrix)
         self.writeQUBO(tmp_problem)
 
         # Convert solver type enum to one used by specs client. Interfaces (values of enums) have to match
         spec = QUBOSpecBuilder(type=solver_type).getd()
 
-        # Actually solve the QUBO
-        res = runner.solve(tmp_problem, spec, True)
-        
+        return tmp_problem, spec
+
+    def _solveParse(self, solution):
+
         # parse solution, store assignments in variables
-        sol_string_splitted = res['solution_file'].split("\n")
+        sol_string_splitted = solution.split("\n")
 
         for var in self.vars:
             self.vars[var].assignment = int(sol_string_splitted[self.vars[var].id()])
 
+    async def solveAsync(self, solver_type : QuboSolverType, runner : Runner):
+
+        tmp_problem, spec = self._solvePrep(solver_type)
+        res = await runner.solveAsync(tmp_problem, spec)
+        
+        self._solveParse(res['solution_file'])
+
+        # return (optimal) objective
+        return self.eval()
+
+    def solve(self, solver_type : QuboSolverType, runner : Runner):
+
+        tmp_problem, spec = self._solvePrep(solver_type)
+        res = runner.solve(tmp_problem, spec)
+        
+        self._solveParse(res['solution_file'])
+
         # return (optimal) objective
         return self.eval()
 
     #######
     # PYQUBO Compatibility Layer
     #######
-    def fromPyQuboModel(self, model : pq.Model):
+    def fromPyQuboModel(self, model : pq.Model, constants : dict = {}):
         self.vars = {}
         self.objective = QuboExpression()
         self._pos_ctr = 0
 
         # guarantees that we only have terms of oders {1, 2}
-        qmodel, shift = model.to_qubo()
+        qmodel, shift = model.to_qubo(feed_dict=constants)
 
         # create objective from QUBO model
         for term in qmodel:
             if(term[0] == term[1]):
                 # unary term
                 v = self.addVariable(term[0], disable_warnings=True)
                 self.objective += QuboTerm(qmodel[term], [v])
```

## quantagonia/runner.py

```diff
@@ -1,10 +1,13 @@
 from abc import ABC, abstractmethod
 import asyncio
 import json
 
 class Runner(ABC):
 
-  # Python 3.10: -> dict | asyncio.Future
   @abstractmethod
-  def solve(self, problem_file: str, spec: dict, blocking : bool, **kwargs):
+  def solve(self, problem_file: str, spec: dict, **kwargs):
+    pass
+
+  @abstractmethod
+  def solveAsync(self, problem_file: str, spec: dict, **kwargs):
     pass
```

## quantagonia/cloud/cloud_runner.py

```diff
@@ -11,57 +11,140 @@
 from quantagonia.enums import HybridSolverServers
 
 class CloudRunner(Runner):
     def __init__(self, api_key: str, server: HybridSolverServers = HybridSolverServers.PROD, suppress_log : bool = False):
         self.https_client = SpecsHTTPSClient(api_key=api_key, target_server=server)
         self.suppress_log = suppress_log
 
-    def wait_for_job(self, jobid: int, poll_frequency: float, timeout: float, solver_log: SolverLog) -> JobStatus:
+    def _solveParseArgs(self, **kwargs):
+
+        # default values
+        poll_frequency: float = 1
+        timeout: float = 14400
+
+        # parse args
+        if "poll_frequency" in kwargs:
+            poll_frequency = kwargs["poll_frequency"]
+        if "poll_frequency" in kwargs:
+            timeout = kwargs["timeout"]
+
+        solver_log = SolverLog() 
+
+        return poll_frequency, timeout, solver_log
+
+    def waitForJob(self, jobid: int, poll_frequency: float, timeout: float, solver_log: SolverLog) -> JobStatus:
+
+        printed_created = False
+        printed_running = False
         for t in range(0,int(timeout/poll_frequency)):
+
             sleep(poll_frequency)
 
-            status = self.https_client.check_job(jobid=jobid)
+            status = self.https_client.checkJob(jobid=jobid)
             if not self.suppress_log:
-                solver_log.update_log(self.https_client.get_current_log(jobid=jobid))
+                solver_log.updateLog(self.https_client.getCurrentLog(jobid=jobid))
 
             if status == JobStatus.finished:
                 return JobStatus.finished
             elif status == JobStatus.error:
                 return JobStatus.error
-            elif status == JobStatus.running or status == JobStatus.created:
-                continue
+            elif status == JobStatus.created:
+                if not self.suppress_log:
+                    if not printed_created:
+                        printed_created = True
+                        print("Waiting for a free slot in the queue.", end="", flush=True)
+                        solver_log.nextTimeAddNewLine()
+                    else:
+                        print(".", end="", flush=True)
+
+            elif status == JobStatus.running:
+                if not printed_running and not self.suppress_log:
+                    printed_running = True
+                    print(f"\nJob {jobid} unqueued, processing...")
+
+                    solver_log.nextTimeAddNewLine()
 
         return JobStatus.timeout
 
-    # Python 3.10: -> dict | asyncio.Future
-    def solve(self, problem_file: str, spec: dict, blocking : bool, **kwargs):
+    async def waitForJobAsync(self, jobid: int, poll_frequency: float, timeout: float, solver_log: SolverLog) -> JobStatus:
 
-        # default values
-        poll_frequency: float = 1
-        timeout: float = 14400
+        printed_created = False
+        printed_running = False
+        for t in range(0,int(timeout/poll_frequency)):
 
-        # parse args
-        if "poll_frequency" in kwargs:
-            poll_frequency = kwargs["poll_frequency"]
-        if "poll_frequency" in kwargs:
-            timeout = kwargs["timeout"]
+            await asyncio.sleep(poll_frequency)
 
-        solver_log = SolverLog() 
+            status = await self.https_client.checkJobAsync(jobid=jobid)
+            if not self.suppress_log:
+                solver_log.updateLog(await self.https_client.getCurrentLogAsync(jobid=jobid))
 
-        if not blocking:
-            raise UnsupportedOperation("Non-blocking execution not yet implemented.")
+            if status == JobStatus.finished:
+                return JobStatus.finished
+            elif status == JobStatus.error:
+                return JobStatus.error
+            elif status == JobStatus.created:
+                if not self.suppress_log:
+                    if not printed_created:
+                        printed_created = True
+                        print("Waiting for a free slot in the queue.", end="", flush=True)
+                        solver_log.nextTimeAddNewLine()
+                    else:
+                        print(".", end="", flush=True)
+
+            elif status == JobStatus.running:
+                if not printed_running and not self.suppress_log:
+                    printed_running = True
+                    print(f"\nJob {jobid} unqueued, processing...")
+
+                    solver_log.nextTimeAddNewLine()
 
-        jobid = self.https_client.submit_job(problem_file=problem_file, spec=spec)
+        return JobStatus.timeout
+
+    def solve(self, problem_file: str, spec: dict, **kwargs):
+        
+        poll_frequency, timeout, solver_log = self._solveParseArgs(**kwargs)
+
+        jobid = self.https_client.submitJob(problem_file=problem_file, spec=spec)
         if not self.suppress_log:
-            print(f"Submitted job with jobid: {jobid} for execution in the Quantagonia cloud...\n")
-        status: JobStatus = self.wait_for_job(jobid=jobid, poll_frequency=poll_frequency, timeout=timeout, solver_log=solver_log)
+            print(f"Queued job with jobid: {jobid} for execution in the Quantagonia cloud...\n")
+
+        status: JobStatus = self.waitForJob(jobid=jobid, poll_frequency=poll_frequency, timeout=timeout, solver_log=solver_log)
 
         if status is not JobStatus.finished:
             raise Exception(f"Job with jobid {jobid} error. Status of the job: {status}")
-        res = self.https_client.get_results(jobid=jobid)
+        else:
+            if not self.suppress_log:
+                print(f"Finished processing job {jobid}...")
+
+        res = self.https_client.getResults(jobid=jobid)
         if not self.suppress_log:
-            solver_log.update_log(res['solver_log'])
+            solver_log.updateLog(res['solver_log'])
 
         return {
             'solver_log' : res['solver_log'],
             'solution_file' : res['solution_file']
         }
+
+    async def solveAsync(self, problem_file: str, spec: dict, **kwargs):
+        
+        poll_frequency, timeout, solver_log = self._solveParseArgs(**kwargs)
+
+        jobid = await self.https_client.submitJobAsync(problem_file=problem_file, spec=spec)
+        if not self.suppress_log:
+            print(f"Queued job with jobid: {jobid} for execution in the Quantagonia cloud...")
+
+        status: JobStatus = await self.waitForJobAsync(jobid=jobid, poll_frequency=poll_frequency, timeout=timeout, solver_log=solver_log)
+
+        if status is not JobStatus.finished:
+            raise Exception(f"Job with jobid {jobid} error. Status of the job: {status}")
+        else:
+            if not self.suppress_log:
+                print(f"Finished processing job {jobid}...")
+
+        res = await self.https_client.getResultsAsync(jobid=jobid)
+        if not self.suppress_log:
+            solver_log.updateLog(res['solver_log'])
+
+        return {
+            'solver_log' : res['solver_log'],
+            'solution_file' : res['solution_file']
+        }
```

## quantagonia/cloud/solver_log.py

```diff
@@ -1,20 +1,28 @@
 class SolverLog:
     def __init__(self):
         self.log: str = ""
+        self.add_newline = False
+
+    def nextTimeAddNewLine(self):
+        self.add_newline = True
 
     """
     takes as input the updated log. It will make sure that the old log is contained in the new log, and print the
     difference to the screen
     """
-    def update_log(self, new_log: str) -> None:
+    def updateLog(self, new_log: str, add_newline : bool = False) -> None:
         if new_log == "":
             return
 
         old_log_len = len(self.log)
 
         if self.log != new_log[:old_log_len]:
             print("WARNING: there was some suspicious discrepancy in the solver log received from the server. "
                   "The solver log might not be printed in the order as the solver generated it.")
 
-        print(new_log[old_log_len:], end='')
+        if len(new_log) != old_log_len and self.add_newline:
+            print("")
+            self.add_newline = False
+
+        print(new_log[old_log_len:], end='', flush=True)
         self.log = new_log
```

## quantagonia/cloud/specs_https_client.py

```diff
@@ -9,42 +9,68 @@
 class SpecsHTTPSClient():
     """ client class for qqvm server """
     def __init__(self, api_key: str, target_server: HybridSolverServers = HybridSolverServers.PROD) -> None:
         """ """
         self.api_key = api_key
         self.server = target_server.value
 
-    def submit_job(self, problem_file: str, spec: dict) -> uuid:
+    def _submitJob(self, problem_file: str, spec: dict) -> uuid:
         with open(problem_file, 'rb') as file:
             files = {'file': (os.path.basename(problem_file), file, 'text/plain')}
             response = requests.post(self.server + SpecsEndpoints.submitjob, files=files, params={"spec" : json.dumps(spec)}, headers={"X-api-key" : self.api_key})
 
         if not response.ok:
             raise RuntimeError(f"Request error. status: {response.status_code}, text: {response.text}")
         return response.json()['jobid']
 
-    def check_job(self, jobid: uuid) -> str:
+    def _checkJob(self, jobid: uuid) -> str:
         params = {'jobid': str(jobid)}
         response = requests.get(self.server + SpecsEndpoints.checkjob, params=params, headers={"X-api-key" : self.api_key})
         
         if not response.ok:
             raise RuntimeError(f"Request error. status: {response.status_code}, text: {response.text}")
         return response.json()['status']
 
-    def get_current_log(self, jobid: uuid) -> str:
+    def _getCurrentLog(self, jobid: uuid) -> str:
         params = {'jobid': str(jobid)}
         response = requests.get(self.server + SpecsEndpoints.getcurlog, params=params, headers={"X-api-key" : self.api_key})
 
         if not response.ok:
             raise RuntimeError(f"Request error. status: {response.status_code}, text: {response.text}")
         return response.text
 
-    def get_results(self, jobid: uuid) -> dict:
+    def _getResults(self, jobid: uuid) -> dict:
         params = {'jobid': str(jobid)}
         response = requests.get(self.server + SpecsEndpoints.getresults, params=params, headers={"X-api-key" : self.api_key})
         
         if not response.ok:
             raise RuntimeError(f"Request error. status: {response.status_code}, text: {response.text}")
         return {
             "solver_log" : response.json()['solver_log'],
             "solution_file" : response.json()['solution_file']
         }
+
+    ### blocking interface
+    def submitJob(self, problem_file: str, spec: dict) -> uuid:
+        return self._submitJob(problem_file, spec)
+
+    def checkJob(self, jobid: uuid) -> str:
+        return self._checkJob(jobid)
+
+    def getCurrentLog(self, jobid: uuid) -> str:
+        return self._getCurrentLog(jobid)
+
+    def getResults(self, jobid: uuid) -> dict:
+        return self._getResults(jobid)
+
+    ### non-blocking interface
+    async def submitJobAsync(self, problem_file: str, spec: dict) -> uuid:
+        return self._submitJob(problem_file, spec)
+
+    async def checkJobAsync(self, jobid: uuid) -> str:
+        return self._checkJob(jobid)
+
+    async def getCurrentLogAsync(self, jobid: uuid) -> str:
+        return self._getCurrentLog(jobid)
+
+    async def getResultsAsync(self, jobid: uuid) -> dict:
+        return self._getResults(jobid)
```

## Comparing `quantagonia_api_client-0.8.dist-info/LICENSE` & `quantagonia_api_client-0.9.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `quantagonia_api_client-0.8.dist-info/METADATA` & `quantagonia_api_client-0.9.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: quantagonia-api-client
-Version: 0.8
+Version: 0.9
 Summary: This package contains APIs for accessing Quantagonia's HybridSolver for solving MIPs and QUBOs through native file formats or PuLP resp. PyQUBO
 Home-page: https://www.quantagonia.com
 Author: Quantagonia GmbH
 Author-email: apis@quantagonia.com
 Keywords: Optimization,Linear Programming,Operations Research
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
```

## Comparing `quantagonia_api_client-0.8.dist-info/RECORD` & `quantagonia_api_client-0.9.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 quantagonia/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 quantagonia/enums.py,sha256=CcLehfROMtrt1aaBs8Mcicc4CFWF2q5Xj3jge6grstw,247
-quantagonia/qubo.py,sha256=fYi9JKm8jYt5s4PSgu9BrDvIyIcQwNrWYyWvn_-zFP0,7605
-quantagonia/runner.py,sha256=TX8Itms7dvZ9ddNHmgW_bCHDyxAU6eBNieSoXJ6Rgow,229
+quantagonia/qubo.py,sha256=ynJvmAW7D1WQ2QmeSejO2Q_WgXIumDk0Jwjq8WbCQgQ,8149
+quantagonia/runner.py,sha256=5OuL4yWJvVLuXtDzKM-HqVcuI41nDHlp74_lj15UEyI,263
 quantagonia/runner_factory.py,sha256=QPhC_1mpeJqmUPpaX7YEoKm3Y4j8D-BLeaHVzywR1pM,1036
 quantagonia/cloud/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-quantagonia/cloud/cloud_runner.py,sha256=Q9SgZm4IMwfRWlmJYoBJsXhmnwfBNi_l3EqgjrW3IDI,2656
-quantagonia/cloud/solver_log.py,sha256=fnW0e3MNd3aXb_pnxwkWJxoYTjTqjebIKZavGOb8aOw,688
+quantagonia/cloud/cloud_runner.py,sha256=BC-LCAQwYZnEvtEWkM2SHfUaFGEmOpirPYatCeTdNzw,5850
+quantagonia/cloud/solver_log.py,sha256=2an1CwzbMA9H6SBbdrQyQ_LYFrDkxRHIjYmaYSMNuDs,948
 quantagonia/cloud/spec_builder.py,sha256=073LCekfUAxkKth3bZXrZpb6wRr8mc8mKdM0VUyyJN0,1918
 quantagonia/cloud/specs_enums.py,sha256=hIpHsJ-SQLyiTbbtgmTG3fk4scb_9b-isgaKgkCYJ7M,318
-quantagonia/cloud/specs_https_client.py,sha256=1urmYHmp_eTjrVhrwfhiQECT_fYN-iOVOxkBr5KEu70,2216
+quantagonia/cloud/specs_https_client.py,sha256=0OFvalf65thUbBp8F2nJxTNTX5dpkoPriYCy60pDPoc,3070
 quantagonia/cloud/default_specs/cook_GPU.json,sha256=g6A0z9BWfvWFQLc0XPAD2vIqx0nrfqcyarerU7x2RCM,513
 quantagonia/cloud/default_specs/fvsdp.json,sha256=sPoALKz5PaAgZy4FlQxkafi6orAUR3aNms6wi6MNMAY,402
 quantagonia/cloud/default_specs/metropolis_CPU.json,sha256=kWB7ccgtwOsV1rm70NpX6rmOd9G0e-RlO9Gm0zAKsnA,524
 quantagonia/pulp/__init__.py,sha256=_4wJvnmmMcbtQ5Ko4PUPH-gcJBBAGGYaNhopd9IhCuM,314
 quantagonia/pulp/hybrid_solver_api.py,sha256=e7KTNQpDZS2V1KZEwqtLKH4nEOufprABDnbx7B6a-CA,7558
 quantagonia/pulp/qpulp_adapter.py,sha256=FQXfcrkhDrQmZFJlTFupaY5FsTPfq2hkO7aGEGT3Vgc,521
-quantagonia_api_client-0.8.dist-info/LICENSE,sha256=qnwjRKbj42Q0Zpp8Ed8ecPpaHP-kmMv2oVUrW2DZ20E,1460
-quantagonia_api_client-0.8.dist-info/METADATA,sha256=gCjKCCmV-BtymMUkX9THxIChnKTjUN1SM8hdR2ywj-o,1545
-quantagonia_api_client-0.8.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-quantagonia_api_client-0.8.dist-info/top_level.txt,sha256=fB-Be1N52aag-1YIKjtMlkm041Ok20ZY0Y4EEE1ieUI,12
-quantagonia_api_client-0.8.dist-info/RECORD,,
+quantagonia_api_client-0.9.dist-info/LICENSE,sha256=qnwjRKbj42Q0Zpp8Ed8ecPpaHP-kmMv2oVUrW2DZ20E,1460
+quantagonia_api_client-0.9.dist-info/METADATA,sha256=6kXkgiVQfIh084rWWNW-cdQMrp6STHNcUY5TGXwIprk,1545
+quantagonia_api_client-0.9.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+quantagonia_api_client-0.9.dist-info/top_level.txt,sha256=fB-Be1N52aag-1YIKjtMlkm041Ok20ZY0Y4EEE1ieUI,12
+quantagonia_api_client-0.9.dist-info/RECORD,,
```

