--- tmp/docker-printer-0.2.0.tar.gz
+++ tmp/docker-printer-0.3.0.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "docker-printer-0.2.0.tar", last modified: Mon Sep 12 18:19:13 2022, max compression
│ +gzip compressed data, was "docker-printer-0.3.0.tar", last modified: Thu Apr  6 17:22:14 2023, max compression
│   --- docker-printer-0.2.0.tar
├── +++ docker-printer-0.3.0.tar
│ ├── file list
│ │ @@ -1,23 +1,43 @@
│ │ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:13.878038 docker-printer-0.2.0/
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     1522 2022-09-12 18:19:13.878038 docker-printer-0.2.0/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     1039 2022-09-12 18:19:03.000000 docker-printer-0.2.0/README.md
│ │ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:13.874038 docker-printer-0.2.0/docker_printer/
│ │ --rw-r--r--   0 runner    (1001) docker     (121)       22 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     1773 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/__main__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     1931 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/cli.py
│ │ --rw-r--r--   0 runner    (1001) docker     (121)    10427 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/models.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:13.878038 docker-printer-0.2.0/docker_printer/resources/
│ │ --rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/resources/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:13.878038 docker-printer-0.2.0/docker_printer/resources/templates/
│ │ --rw-r--r--   0 runner    (1001) docker     (121)      281 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/resources/templates/base.Dockerfile.jinja2
│ │ --rw-r--r--   0 runner    (1001) docker     (121)      672 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/resources/templates/stage.Dockerfile.jinja2
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     3525 2022-09-12 18:19:03.000000 docker-printer-0.2.0/docker_printer/utils.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-12 18:19:13.878038 docker-printer-0.2.0/docker_printer.egg-info/
│ │ --rw-r--r--   0 runner    (1001) docker     (121)     1522 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (121)      543 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (121)        1 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (121)       64 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/entry_points.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (121)       20 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/requires.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (121)       15 2022-09-12 18:19:13.000000 docker-printer-0.2.0/docker_printer.egg-info/top_level.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (121)      117 2022-09-12 18:19:03.000000 docker-printer-0.2.0/pyproject.toml
│ │ --rw-r--r--   0 runner    (1001) docker     (121)      929 2022-09-12 18:19:13.878038 docker-printer-0.2.0/setup.cfg
│ │ +-rw-r--r--   0        0        0      183 2023-04-06 17:22:10.089098 docker-printer-0.3.0/.bumpversion.cfg
│ │ +-rw-r--r--   0        0        0      434 2022-08-31 23:17:03.286534 docker-printer-0.3.0/.github/workflows/docs.yml
│ │ +-rw-r--r--   0        0        0      359 2022-07-12 16:43:24.229000 docker-printer-0.3.0/.github/workflows/pre-commit.yml
│ │ +-rw-r--r--   0        0        0      702 2022-07-12 16:43:24.229000 docker-printer-0.3.0/.github/workflows/pypi.yml
│ │ +-rw-r--r--   0        0        0      869 2022-09-12 19:35:17.102613 docker-printer-0.3.0/.github/workflows/test_examples.yml
│ │ +-rw-r--r--   0        0        0     2162 2022-07-05 17:25:03.902000 docker-printer-0.3.0/.gitignore
│ │ +-rw-r--r--   0        0        0      720 2023-04-06 17:22:10.089628 docker-printer-0.3.0/.pre-commit-config.yaml
│ │ +-rw-r--r--   0        0        0     1015 2023-04-06 17:22:10.090152 docker-printer-0.3.0/.ruff.toml
│ │ +-rw-r--r--   0        0        0     1249 2022-09-12 19:35:17.103661 docker-printer-0.3.0/README.md
│ │ +-rw-r--r--   0        0        0      100 2022-08-31 23:19:52.983405 docker-printer-0.3.0/TODO.md
│ │ +-rw-r--r--   0        0        0       57 2023-04-06 17:22:10.091194 docker-printer-0.3.0/docker_printer/__init__.py
│ │ +-rw-r--r--   0        0        0     1840 2023-04-06 17:22:10.091714 docker-printer-0.3.0/docker_printer/__main__.py
│ │ +-rw-r--r--   0        0        0     2609 2023-04-06 17:22:10.092241 docker-printer-0.3.0/docker_printer/cli.py
│ │ +-rw-r--r--   0        0        0    10874 2023-04-06 17:22:10.092752 docker-printer-0.3.0/docker_printer/models.py
│ │ +-rw-r--r--   0        0        0        0 2022-09-12 18:15:06.010409 docker-printer-0.3.0/docker_printer/resources/__init__.py
│ │ +-rw-r--r--   0        0        0      281 2022-08-30 21:05:17.110772 docker-printer-0.3.0/docker_printer/resources/templates/base.Dockerfile.jinja2
│ │ +-rw-r--r--   0        0        0      672 2022-09-07 16:49:22.397957 docker-printer-0.3.0/docker_printer/resources/templates/stage.Dockerfile.jinja2
│ │ +-rw-r--r--   0        0        0     3601 2023-04-06 17:22:10.093795 docker-printer-0.3.0/docker_printer/utils.py
│ │ +-rw-r--r--   0        0        0      634 2022-08-31 21:01:38.037882 docker-printer-0.3.0/docs/Makefile
│ │ +-rw-r--r--   0        0        0     3580 2022-09-01 21:05:56.297121 docker-printer-0.3.0/docs/builds.md
│ │ +-rw-r--r--   0        0        0     1654 2023-04-06 17:22:10.094846 docker-printer-0.3.0/docs/conf.py
│ │ +-rw-r--r--   0        0        0     3810 2022-09-01 16:44:47.267891 docker-printer-0.3.0/docs/index.md
│ │ +-rwxr-xr-x   0        0        0      800 2022-08-31 21:01:38.039492 docker-printer-0.3.0/docs/make.bat
│ │ +-rw-r--r--   0        0        0     3676 2022-09-01 21:18:19.986241 docker-printer-0.3.0/docs/modules.md
│ │ +-rw-r--r--   0        0        0       54 2022-09-01 21:29:44.403790 docker-printer-0.3.0/docs/requirements.txt
│ │ +-rw-r--r--   0        0        0      325 2022-09-01 21:16:07.444924 docker-printer-0.3.0/docs/synth.md
│ │ +-rw-r--r--   0        0        0     2917 2022-09-01 17:04:05.711198 docker-printer-0.3.0/docs/targets.md
│ │ +-rw-r--r--   0        0        0      550 2022-09-01 21:21:23.785704 docker-printer-0.3.0/docs/templates.md
│ │ +-rw-r--r--   0        0        0      654 2022-09-12 19:35:17.105815 docker-printer-0.3.0/examples/fastapi_app/Dockerfile.synth
│ │ +-rw-r--r--   0        0        0        0 2022-09-12 19:35:17.106321 docker-printer-0.3.0/examples/fastapi_app/app/__init__.py
│ │ +-rw-r--r--   0        0        0      620 2022-09-12 19:35:17.107381 docker-printer-0.3.0/examples/fastapi_app/docker-bake.default.json
│ │ +-rw-r--r--   0        0        0       18 2022-09-12 19:35:17.107955 docker-printer-0.3.0/examples/fastapi_app/docker-printer/.gitignore
│ │ +-rw-r--r--   0        0        0      107 2022-09-12 19:35:17.108501 docker-printer-0.3.0/examples/fastapi_app/docker-printer/builds.yml
│ │ +-rw-r--r--   0        0        0      321 2022-09-12 19:35:17.109089 docker-printer-0.3.0/examples/fastapi_app/docker-printer/modules/app-code.yml
│ │ +-rw-r--r--   0        0        0      218 2022-09-12 19:35:17.109662 docker-printer-0.3.0/examples/fastapi_app/docker-printer/modules/app-deps.yml
│ │ +-rw-r--r--   0        0        0      296 2022-09-12 19:35:17.110171 docker-printer-0.3.0/examples/fastapi_app/docker-printer/modules/base.yml
│ │ +-rw-r--r--   0        0        0      120 2022-09-12 19:35:17.110171 docker-printer-0.3.0/examples/fastapi_app/docker-printer/targets.yml
│ │ +-rw-r--r--   0        0        0      872 2022-09-12 19:35:17.111922 docker-printer-0.3.0/examples/fastapi_app/docker-printer/templates/pip-install.Dockerfile.jinja2
│ │ +-rw-r--r--   0        0        0      108 2022-09-12 19:35:17.112504 docker-printer-0.3.0/examples/fastapi_app/requirements.txt
│ │ +-rw-r--r--   0        0        0      320 2023-04-06 17:22:10.095373 docker-printer-0.3.0/pyproject.toml
│ │ +-rw-r--r--   0        0        0       33 2022-09-12 19:35:17.113038 docker-printer-0.3.0/requirements.txt
│ │ +-rw-r--r--   0        0        0      978 2023-04-06 17:22:10.096415 docker-printer-0.3.0/setup.cfg
│ │ +-rw-r--r--   0        0        0     1466 1970-01-01 00:00:00.000000 docker-printer-0.3.0/PKG-INFO
│ │   --- docker-printer-0.2.0/PKG-INFO
│ ├── +++ docker-printer-0.3.0/README.md
│ │┄ Files 18% similar despite different names
│ │ @@ -1,29 +1,22 @@
│ │ -Metadata-Version: 2.1
│ │ -Name: docker-printer
│ │ -Version: 0.2.0
│ │ -Summary: Composer for dockerfiles
│ │ -Home-page: https://github.com/rearc-data/docker-printer
│ │ -Author: Rearc Data
│ │ -Author-email: data@rearc.io
│ │ -Project-URL: Bug Tracker, https://github.com/rearc-data/docker-printer/issues
│ │ -Classifier: Programming Language :: Python :: 3
│ │ -Classifier: License :: OSI Approved :: MIT License
│ │ -Classifier: Operating System :: OS Independent
│ │ -Requires-Python: >=3.7
│ │ -Description-Content-Type: text/markdown
│ │ -
│ │ -[![Documentation Status](https://readthedocs.org/projects/docker-printer/badge/?version=latest)](https://docker-printer.readthedocs.io/en/latest/?badge=latest)
│ │ -
│ │ -# Docker-Printer
│ │ -
│ │ -`docker-printer` is a CLI for easily managing multistep and branching dockerfiles.
│ │ -
│ │ -Regular multi-stage dockerfiles and `docker build` commands are incredibly powerful and useful; however, they are designed for building a single image. Multistage builds can be used to define multiple related images, but this quickly results in complicated dockerfiles, possibly duplicated instructions, and complicated collections of build commands.
│ │ -
│ │ -`docker-printer` addresses this in two main ways:
│ │ -- By allowing dockerfiles to be composed from re-usable modules.
│ │ -- By building bake files for use by `docker buildx bake` that consolidate the build processes of multiple images in multiple environments into a single configuration file.
│ │ -
│ │ -# Getting Started and Documentation
│ │ -
│ │ -See the [documentation](https://docker-printer.readthedocs.io/en/latest/#) for how to get started.
│ │ +[![Documentation Status](https://readthedocs.org/projects/docker-printer/badge/?version=latest)](https://docker-printer.readthedocs.io/en/latest/?badge=latest) ![PyPI](https://img.shields.io/pypi/v/docker-printer)
│ │ +
│ │ +# Docker-Printer
│ │ +
│ │ +`docker-printer` is a CLI for easily managing multistep and branching dockerfiles.
│ │ +
│ │ +Regular multi-stage dockerfiles and `docker build` commands are incredibly powerful and useful; however, they are designed for building a single image. Multistage builds can be used to define multiple related images, but this quickly results in complicated dockerfiles, possibly duplicated instructions, and complicated collections of build commands.
│ │ +
│ │ +`docker-printer` addresses this in two main ways:
│ │ +- By allowing dockerfiles to be composed from re-usable modules.
│ │ +- By building bake files for use by `docker buildx bake` that consolidate the build processes of multiple images in multiple environments into a single configuration file.
│ │ +
│ │ +# Getting Started and Documentation
│ │ +
│ │ +```
│ │ +pip install docker-printer
│ │ +docker-printer init
│ │ +```
│ │ +
│ │ +See the [documentation](https://docker-printer.readthedocs.io/en/latest/#) for how to get started.
│ │ +
│ │ +There are also example docker constructs provided in the `/examples` folder.
│ │   --- docker-printer-0.2.0/README.md
│ ├── +++ docker-printer-0.3.0/PKG-INFO
│ │┄ Files 21% similar despite different names
│ │ @@ -1,15 +1,31 @@
│ │ -[![Documentation Status](https://readthedocs.org/projects/docker-printer/badge/?version=latest)](https://docker-printer.readthedocs.io/en/latest/?badge=latest)
│ │ +Metadata-Version: 2.1
│ │ +Name: docker-printer
│ │ +Version: 0.3.0
│ │ +Summary: Composer for dockerfiles
│ │ +Author-email: Rearc Data <data@rearc.io>
│ │ +Description-Content-Type: text/markdown
│ │ +Project-URL: Home, https://github.com/rearc-data/docker-printer
│ │ +
│ │ +[![Documentation Status](https://readthedocs.org/projects/docker-printer/badge/?version=latest)](https://docker-printer.readthedocs.io/en/latest/?badge=latest) ![PyPI](https://img.shields.io/pypi/v/docker-printer)
│ │  
│ │  # Docker-Printer
│ │  
│ │  `docker-printer` is a CLI for easily managing multistep and branching dockerfiles.
│ │  
│ │  Regular multi-stage dockerfiles and `docker build` commands are incredibly powerful and useful; however, they are designed for building a single image. Multistage builds can be used to define multiple related images, but this quickly results in complicated dockerfiles, possibly duplicated instructions, and complicated collections of build commands.
│ │  
│ │  `docker-printer` addresses this in two main ways:
│ │  - By allowing dockerfiles to be composed from re-usable modules.
│ │  - By building bake files for use by `docker buildx bake` that consolidate the build processes of multiple images in multiple environments into a single configuration file.
│ │  
│ │  # Getting Started and Documentation
│ │  
│ │ +```
│ │ +pip install docker-printer
│ │ +docker-printer init
│ │ +```
│ │ +
│ │  See the [documentation](https://docker-printer.readthedocs.io/en/latest/#) for how to get started.
│ │ +
│ │ +There are also example docker constructs provided in the `/examples` folder.
│ │ +
│ │   --- docker-printer-0.2.0/docker_printer/models.py
│ ├── +++ docker-printer-0.3.0/docker_printer/models.py
│ │┄ Files 24% similar despite different names
│ │ @@ -1,331 +1,335 @@
│ │ -import json
│ │ -import re
│ │ -from collections import defaultdict
│ │ -from typing import List, Optional, Set, Dict, Any, Hashable, Union, Iterable
│ │ -
│ │ -import jinja2
│ │ -from pydantic import BaseModel, validator, PrivateAttr
│ │ -
│ │ -
│ │ -class CommonListTree:
│ │ -    class Node:
│ │ -        def __init__(self):
│ │ -            self.children = defaultdict(CommonListTree.Node)
│ │ -            self.labels = set()
│ │ -            # self.parent: CommonListTree.Node = None
│ │ -
│ │ -        def merge_list(self, vals: List[Hashable], label: str):
│ │ -            self.labels.add(label)
│ │ -            if not vals:
│ │ -                return
│ │ -
│ │ -            v, *remaining = vals
│ │ -            child = self.children[v]
│ │ -            # child.parent = self
│ │ -            child.merge_list(remaining, label)
│ │ -
│ │ -        @property
│ │ -        def terminal_labels(self):
│ │ -            return set(self.labels) - {
│ │ -                lbl for child in self.children.values() for lbl in child.labels
│ │ -            }
│ │ -
│ │ -        def print_tree(self, _indent=0):
│ │ -            for value, child in self.children.items():
│ │ -                if child.terminal_labels:
│ │ -                    suffix = f' [{", ".join(child.terminal_labels)}]'
│ │ -                else:
│ │ -                    suffix = ""
│ │ -                print("  " * _indent + f"- {value}" + suffix)
│ │ -                child.print_tree(_indent + 1)
│ │ -
│ │ -        def visit(self, func):
│ │ -            for value, child in self.children.items():
│ │ -                func(value, child, self)
│ │ -                child.visit(func)
│ │ -
│ │ -    def __init__(self):
│ │ -        self.root = CommonListTree.Node()
│ │ -
│ │ -    def merge_list(self, *args, **kwargs):
│ │ -        self.root.merge_list(*args, **kwargs)
│ │ -
│ │ -    def print_tree(self):
│ │ -        self.root.print_tree()
│ │ -
│ │ -    def visit(self, func):
│ │ -        self.root.visit(func)
│ │ -
│ │ -
│ │ -class FilledTemplate(BaseModel):
│ │ -    file: str = "stage.Dockerfile.jinja2"
│ │ -    variables: Dict[str, Any] = {}
│ │ -
│ │ -    def render(self, environment: jinja2.Environment):
│ │ -        return environment.get_template(self.file).render(**self.variables)
│ │ -
│ │ -
│ │ -class Module(BaseModel):
│ │ -    __modules__: Dict[str, "Module"] = dict()
│ │ -
│ │ -    name: str
│ │ -    depends_on: List[str] = []
│ │ -    priority: int = 0
│ │ -    template: FilledTemplate
│ │ -    image_args: Dict[str, Any] = {}
│ │ -
│ │ -    _all_modules: Set["Module"] = PrivateAttr(default=None)
│ │ -
│ │ -    def __init__(self, **kwargs):
│ │ -        super().__init__(**kwargs)
│ │ -        if self.name in self.__modules__:
│ │ -            raise RuntimeError(
│ │ -                f"Multiple modules defined with the same name: '{self.name}'"
│ │ -            )
│ │ -        self.__modules__[self.name] = self
│ │ -
│ │ -    def __hash__(self):
│ │ -        return hash(self.name)
│ │ -
│ │ -    @validator("image_args", pre=True)
│ │ -    def ensure_is_dictionary(cls, v):
│ │ -        if isinstance(v, (list, tuple)):
│ │ -            return {k: None for k in v}
│ │ -        else:
│ │ -            return v
│ │ -
│ │ -    def all_modules(self) -> Set["Module"]:
│ │ -        if self._all_modules is None:
│ │ -            self._all_modules = {self} | {
│ │ -                mod
│ │ -                for dep in self.depends_on
│ │ -                for mod in Module.__modules__[dep].all_modules()
│ │ -            }
│ │ -        return self._all_modules
│ │ -
│ │ -    def get_chunk(self, environment: jinja2.Environment, prev_name, cur_name):
│ │ -        vars = dict(self.template.variables)
│ │ -        vars.setdefault("base", prev_name)
│ │ -        vars.setdefault("name", cur_name)
│ │ -        vars.setdefault("labels", {})
│ │ -        vars.setdefault("arguments", {})
│ │ -        vars.setdefault("env", {})
│ │ -        return environment.get_template(self.template.file).render(**vars)
│ │ -
│ │ -    def __repr__(self):
│ │ -        return f"<{type(self).__name__} {self.name}>"
│ │ -
│ │ -    def __str__(self):
│ │ -        return self.name
│ │ -
│ │ -
│ │ -class Target(BaseModel):
│ │ -    __targets__: Dict[str, "Target"] = {}
│ │ -
│ │ -    name: str
│ │ -    modules: List[str] = set()
│ │ -    extends: List[str] = []
│ │ -    exclude: bool = False
│ │ -    tags: List[str] = []
│ │ -
│ │ -    _all_modules: List[Module] = PrivateAttr(default=None)
│ │ -
│ │ -    def __init__(self, **kwargs):
│ │ -        super().__init__(**kwargs)
│ │ -        if self.name in self.__targets__:
│ │ -            raise RuntimeError(
│ │ -                f"Multiple targets defined with the same name: '{self.name}'"
│ │ -            )
│ │ -        self.__targets__[self.name] = self
│ │ -
│ │ -    def __hash__(self):
│ │ -        return hash(self.name)
│ │ -
│ │ -    @property
│ │ -    def _resolved_modules(self):
│ │ -        return [Module.__modules__[m] for m in self.modules]
│ │ -
│ │ -    @property
│ │ -    def _extended_targets(self) -> Set["Target"]:
│ │ -        return {
│ │ -            target
│ │ -            for extended_target in self.extends
│ │ -            for target in Target.__targets__[extended_target].all_targets()
│ │ -        }
│ │ -
│ │ -    def all_targets(self):
│ │ -        return {self} | self._extended_targets
│ │ -
│ │ -    def all_modules(self) -> Iterable[Module]:
│ │ -        if self._all_modules is None:
│ │ -            modules = {
│ │ -                mod
│ │ -                for base_mod in self._resolved_modules
│ │ -                for mod in base_mod.all_modules()
│ │ -            } | {
│ │ -                mod for target in self._extended_targets for mod in target.all_modules()
│ │ -            }
│ │ -            self._all_modules = list(
│ │ -                sorted(modules, key=lambda m: (-m.priority, m.name))
│ │ -            )
│ │ -
│ │ -        return self._all_modules
│ │ -
│ │ -    def render_dockerfile(self, environment: jinja2.Environment):
│ │ -        image_args = {}
│ │ -        for mod in self._resolved_modules:
│ │ -            image_args.update(mod.image_args)
│ │ -
│ │ -        prev_mod = None
│ │ -        chunks = []
│ │ -        for mod in self.all_modules():
│ │ -            chunks.append(mod.get_chunk(environment, prev_mod.name, mod.name))
│ │ -            prev_mod = mod
│ │ -
│ │ -        dockerfile = environment.get_template("base.Dockerfile.jinja2").render(
│ │ -            image_arguments=image_args, chunks=chunks
│ │ -        )
│ │ -        dockerfile = re.sub(r"\n{3,}", r"\n\n", dockerfile)
│ │ -        return dockerfile
│ │ -
│ │ -    def __repr__(self):
│ │ -        return f"<{type(self).__name__} {self.name}>"
│ │ -
│ │ -    def __str__(self):
│ │ -        return self.name
│ │ -
│ │ -
│ │ -class TargetCollection(BaseModel):
│ │ -    __root__: Set[Target]
│ │ -
│ │ -    @property
│ │ -    def targets(self):
│ │ -        return [t for t in self.__root__ if not t.exclude]
│ │ -
│ │ -    # def __getitem__(self, item: str) -> Target:
│ │ -    #     try:
│ │ -    #         return next(t for t in self.targets if t.name == item)
│ │ -    #     except StopIteration:
│ │ -    #         raise KeyError(f"Name {item} not found in target collection")
│ │ -
│ │ -    def render_dockerfile(
│ │ -        self, environment: jinja2.Environment, targets: List[str] = ()
│ │ -    ):
│ │ -        targets = sorted(self.targets, key=lambda t: t.name)
│ │ -
│ │ -        pre_image_args = dict()
│ │ -        for target in targets:
│ │ -            for module in target.all_modules():
│ │ -                pre_image_args.update(module.image_args)
│ │ -
│ │ -        module_tree = CommonListTree()
│ │ -        for target in targets:
│ │ -            module_tree.merge_list(target.all_modules(), target.name)
│ │ -
│ │ -        module_tree.print_tree()
│ │ -        chunks: Dict[Union[CommonListTree.Node, str], str] = {}
│ │ -        names = {}
│ │ -        image_args = {}
│ │ -        last_chunk_per_target = {}
│ │ -
│ │ -        def visit_node(
│ │ -            module: Module, node: CommonListTree.Node, parent: CommonListTree.Node
│ │ -        ):
│ │ -            image_args.update(module.image_args)
│ │ -
│ │ -            if len(node.terminal_labels) == 1:  # This is a terminal node for a target
│ │ -                cur_name = list(node.terminal_labels)[0]
│ │ -            elif len(node.labels) == len(targets):  # All targets go through this node
│ │ -                cur_name = module.name
│ │ -            else:  # Something in between
│ │ -                cur_name = "-".join([module.name] + list(sorted(node.labels)))
│ │ -
│ │ -            for label in node.labels:
│ │ -                last_chunk_per_target[label] = cur_name
│ │ -
│ │ -            names[node] = cur_name
│ │ -            prev_name = names.get(parent)
│ │ -            chunks[node] = module.get_chunk(environment, prev_name, cur_name)
│ │ -
│ │ -        module_tree.visit(visit_node)
│ │ -        for target in targets:
│ │ -            if target.name not in names.values():
│ │ -                chunks[target.name] = environment.get_template(
│ │ -                    "stage.Dockerfile.jinja2"
│ │ -                ).render(
│ │ -                    base=last_chunk_per_target[target.name],
│ │ -                    name=target.name,
│ │ -                    labels={},
│ │ -                    arguments={},
│ │ -                    env={},
│ │ -                )
│ │ -
│ │ -        dockerfile = environment.get_template("base.Dockerfile.jinja2").render(
│ │ -            image_arguments=image_args, chunks=list(chunks.values())
│ │ -        )
│ │ -        dockerfile = re.sub(r"\n{3,}", r"\n\n", dockerfile)
│ │ -
│ │ -        return dockerfile
│ │ -
│ │ -
│ │ -class BuildConfig(BaseModel):
│ │ -    name: str
│ │ -    image: List[str]
│ │ -    tag_prefix: Optional[str]
│ │ -    tag_postfix: Optional[str]
│ │ -    build_args: Dict[str, Any] = {"load": True}
│ │ -    limit_tags: List[str] = []
│ │ -
│ │ -    @validator("image", pre=True)
│ │ -    def ensure_image_is_list(cls, v):
│ │ -        if not isinstance(v, list):
│ │ -            return [v]
│ │ -        return v
│ │ -
│ │ -    def _render_build_args(self, target: Target, args):
│ │ -        if isinstance(args, list):
│ │ -            return [self._render_build_args(target, a) for a in args]
│ │ -        elif isinstance(args, dict):
│ │ -            return {k: self._render_build_args(target, v) for k, v in args.items()}
│ │ -        elif isinstance(args, str):
│ │ -            for k, v in {
│ │ -                "${TARGET}": target.name,
│ │ -            }.items():
│ │ -                args = args.replace(k, v)
│ │ -            return args
│ │ -        else:
│ │ -            return args
│ │ -
│ │ -    def generate_bakefile(self, target_collection: TargetCollection):
│ │ -        def tag_maker(name):
│ │ -            return "-".join(v for v in [self.tag_prefix, name, self.tag_postfix] if v)
│ │ -
│ │ -        targets = [
│ │ -            t
│ │ -            for t in sorted(target_collection.targets, key=lambda t: t.name)
│ │ -            if all(tag in t.tags for tag in self.limit_tags)
│ │ -        ]
│ │ -
│ │ -        return json.dumps(
│ │ -            dict(
│ │ -                group=dict(default=dict(targets=[target.name for target in targets])),
│ │ -                target={
│ │ -                    target.name: dict(
│ │ -                        dockerfile="Dockerfile.synth",
│ │ -                        tags=[f"{img}:{tag_maker(target.name)}" for img in self.image],
│ │ -                        target=target.name,
│ │ -                        **self._render_build_args(target, self.build_args),
│ │ -                    )
│ │ -                    for target in targets
│ │ -                },
│ │ -            ),
│ │ -            indent=2,
│ │ -        )
│ │ -
│ │ -    @property
│ │ -    def build_command(self):
│ │ -        return f"docker buildx bake -f docker-bake.{self.name}.json"
│ │ -
│ │ -
│ │ -class BuildConfigCollection(BaseModel):
│ │ -    __root__: List[BuildConfig]
│ │ +import json
│ │ +import re
│ │ +from collections import defaultdict
│ │ +from typing import Any, Dict, Hashable, Iterable, List, Optional, Set, Union
│ │ +
│ │ +import jinja2
│ │ +from pydantic import BaseModel, PrivateAttr, validator
│ │ +from rich import print
│ │ +from rich.tree import Tree
│ │ +
│ │ +
│ │ +class CommonListTree:
│ │ +    class Node:
│ │ +        def __init__(self):
│ │ +            self.children = defaultdict(CommonListTree.Node)
│ │ +            self.labels = set()
│ │ +            # self.parent: CommonListTree.Node = None
│ │ +
│ │ +        def merge_list(self, vals: List[Hashable], label: str):
│ │ +            self.labels.add(label)
│ │ +            if not vals:
│ │ +                return
│ │ +
│ │ +            v, *remaining = vals
│ │ +            child = self.children[v]
│ │ +            # child.parent = self
│ │ +            child.merge_list(remaining, label)
│ │ +
│ │ +        @property
│ │ +        def terminal_labels(self):
│ │ +            return set(self.labels) - {
│ │ +                lbl for child in self.children.values() for lbl in child.labels
│ │ +            }
│ │ +
│ │ +        def tree(self, tree=None) -> Tree:
│ │ +            for value, child in self.children.items():
│ │ +                terminals = " ".join(
│ │ +                    f"[code]{lbl}[/code]" for lbl in child.terminal_labels
│ │ +                )
│ │ +                text = f"{value} {terminals}"
│ │ +                subtree = tree.add(text.strip())
│ │ +                child.tree(subtree)
│ │ +
│ │ +        def visit(self, func):
│ │ +            for value, child in self.children.items():
│ │ +                func(value, child, self)
│ │ +                child.visit(func)
│ │ +
│ │ +    def __init__(self):
│ │ +        self.root = CommonListTree.Node()
│ │ +
│ │ +    def merge_list(self, *args, **kwargs):
│ │ +        self.root.merge_list(*args, **kwargs)
│ │ +
│ │ +    def tree(self) -> Tree:
│ │ +        root = Tree("[dim]Dockerfile.synth[/dim]")
│ │ +        self.root.tree(root)
│ │ +        return root
│ │ +
│ │ +    def visit(self, func):
│ │ +        self.root.visit(func)
│ │ +
│ │ +
│ │ +class FilledTemplate(BaseModel):
│ │ +    file: str = "stage.Dockerfile.jinja2"
│ │ +    variables: Dict[str, Any] = {}
│ │ +
│ │ +    def render(self, environment: jinja2.Environment):
│ │ +        return environment.get_template(self.file).render(**self.variables)
│ │ +
│ │ +
│ │ +class Module(BaseModel):
│ │ +    __modules__: Dict[str, "Module"] = dict()
│ │ +
│ │ +    name: str
│ │ +    depends_on: List[str] = []
│ │ +    priority: int = 0
│ │ +    template: FilledTemplate
│ │ +    image_args: Dict[str, Any] = {}
│ │ +
│ │ +    _all_modules: Set["Module"] = PrivateAttr(default=None)
│ │ +
│ │ +    def __init__(self, **kwargs):
│ │ +        super().__init__(**kwargs)
│ │ +        if self.name in self.__modules__:
│ │ +            raise RuntimeError(
│ │ +                f"Multiple modules defined with the same name: '{self.name}'"
│ │ +            )
│ │ +        self.__modules__[self.name] = self
│ │ +
│ │ +    def __hash__(self):
│ │ +        return hash(self.name)
│ │ +
│ │ +    @validator("image_args", pre=True)
│ │ +    def ensure_is_dictionary(cls, v):
│ │ +        if isinstance(v, (list, tuple)):
│ │ +            return {k: None for k in v}
│ │ +        else:
│ │ +            return v
│ │ +
│ │ +    def all_modules(self) -> Set["Module"]:
│ │ +        if self._all_modules is None:
│ │ +            self._all_modules = {self} | {
│ │ +                mod
│ │ +                for dep in self.depends_on
│ │ +                for mod in Module.__modules__[dep].all_modules()
│ │ +            }
│ │ +        return self._all_modules
│ │ +
│ │ +    def get_chunk(self, environment: jinja2.Environment, prev_name, cur_name):
│ │ +        vars = dict(self.template.variables)
│ │ +        vars.setdefault("base", prev_name)
│ │ +        vars.setdefault("name", cur_name)
│ │ +        vars.setdefault("labels", {})
│ │ +        vars.setdefault("arguments", {})
│ │ +        vars.setdefault("env", {})
│ │ +        return environment.get_template(self.template.file).render(**vars)
│ │ +
│ │ +    def __repr__(self):
│ │ +        return f"<{type(self).__name__} {self.name}>"
│ │ +
│ │ +    def __str__(self):
│ │ +        return self.name
│ │ +
│ │ +
│ │ +class Target(BaseModel):
│ │ +    __targets__: Dict[str, "Target"] = {}
│ │ +
│ │ +    name: str
│ │ +    modules: List[str] = set()
│ │ +    extends: List[str] = []
│ │ +    exclude: bool = False
│ │ +    tags: List[str] = []
│ │ +
│ │ +    _all_modules: List[Module] = PrivateAttr(default=None)
│ │ +
│ │ +    def __init__(self, **kwargs):
│ │ +        super().__init__(**kwargs)
│ │ +        if self.name in self.__targets__:
│ │ +            raise RuntimeError(
│ │ +                f"Multiple targets defined with the same name: '{self.name}'"
│ │ +            )
│ │ +        self.__targets__[self.name] = self
│ │ +
│ │ +    def __hash__(self):
│ │ +        return hash(self.name)
│ │ +
│ │ +    @property
│ │ +    def _resolved_modules(self):
│ │ +        return [Module.__modules__[m] for m in self.modules]
│ │ +
│ │ +    @property
│ │ +    def _extended_targets(self) -> Set["Target"]:
│ │ +        return {
│ │ +            target
│ │ +            for extended_target in self.extends
│ │ +            for target in Target.__targets__[extended_target].all_targets()
│ │ +        }
│ │ +
│ │ +    def all_targets(self):
│ │ +        return {self} | self._extended_targets
│ │ +
│ │ +    def all_modules(self) -> Iterable[Module]:
│ │ +        if self._all_modules is None:
│ │ +            modules = {
│ │ +                mod
│ │ +                for base_mod in self._resolved_modules
│ │ +                for mod in base_mod.all_modules()
│ │ +            } | {
│ │ +                mod for target in self._extended_targets for mod in target.all_modules()
│ │ +            }
│ │ +            self._all_modules = list(
│ │ +                sorted(modules, key=lambda m: (-m.priority, m.name))
│ │ +            )
│ │ +
│ │ +        return self._all_modules
│ │ +
│ │ +    def render_dockerfile(self, environment: jinja2.Environment):
│ │ +        image_args = {}
│ │ +        for mod in self._resolved_modules:
│ │ +            image_args.update(mod.image_args)
│ │ +
│ │ +        prev_mod = None
│ │ +        chunks = []
│ │ +        for mod in self.all_modules():
│ │ +            chunks.append(mod.get_chunk(environment, prev_mod.name, mod.name))
│ │ +            prev_mod = mod
│ │ +
│ │ +        dockerfile = environment.get_template("base.Dockerfile.jinja2").render(
│ │ +            image_arguments=image_args, chunks=chunks
│ │ +        )
│ │ +        dockerfile = re.sub(r"\n{3,}", r"\n\n", dockerfile)
│ │ +        return dockerfile
│ │ +
│ │ +    def __repr__(self):
│ │ +        return f"<{type(self).__name__} {self.name}>"
│ │ +
│ │ +    def __str__(self):
│ │ +        return self.name
│ │ +
│ │ +
│ │ +class TargetCollection(BaseModel):
│ │ +    __root__: Set[Target]
│ │ +
│ │ +    @property
│ │ +    def targets(self):
│ │ +        return [t for t in self.__root__ if not t.exclude]
│ │ +
│ │ +    # def __getitem__(self, item: str) -> Target:
│ │ +    #     try:
│ │ +    #         return next(t for t in self.targets if t.name == item)
│ │ +    #     except StopIteration:
│ │ +    #         raise KeyError(f"Name {item} not found in target collection")
│ │ +
│ │ +    def render_dockerfile(
│ │ +        self, environment: jinja2.Environment, targets: List[str] = ()
│ │ +    ):
│ │ +        targets = sorted(self.targets, key=lambda t: t.name)
│ │ +
│ │ +        pre_image_args = dict()
│ │ +        for target in targets:
│ │ +            for module in target.all_modules():
│ │ +                pre_image_args.update(module.image_args)
│ │ +
│ │ +        module_tree = CommonListTree()
│ │ +        for target in targets:
│ │ +            module_tree.merge_list(target.all_modules(), target.name)
│ │ +
│ │ +        print(module_tree.tree())
│ │ +        chunks: Dict[Union[CommonListTree.Node, str], str] = {}
│ │ +        names = {}
│ │ +        image_args = {}
│ │ +        last_chunk_per_target = {}
│ │ +
│ │ +        def visit_node(
│ │ +            module: Module, node: CommonListTree.Node, parent: CommonListTree.Node
│ │ +        ):
│ │ +            image_args.update(module.image_args)
│ │ +
│ │ +            if len(node.terminal_labels) == 1:  # This is a terminal node for a target
│ │ +                cur_name = list(node.terminal_labels)[0]
│ │ +            elif len(node.labels) == len(targets):  # All targets go through this node
│ │ +                cur_name = module.name
│ │ +            else:  # Something in between
│ │ +                cur_name = "-".join([module.name] + list(sorted(node.labels)))
│ │ +
│ │ +            for label in node.labels:
│ │ +                last_chunk_per_target[label] = cur_name
│ │ +
│ │ +            names[node] = cur_name
│ │ +            prev_name = names.get(parent)
│ │ +            chunks[node] = module.get_chunk(environment, prev_name, cur_name)
│ │ +
│ │ +        module_tree.visit(visit_node)
│ │ +        for target in targets:
│ │ +            if target.name not in names.values():
│ │ +                chunks[target.name] = environment.get_template(
│ │ +                    "stage.Dockerfile.jinja2"
│ │ +                ).render(
│ │ +                    base=last_chunk_per_target[target.name],
│ │ +                    name=target.name,
│ │ +                    labels={},
│ │ +                    arguments={},
│ │ +                    env={},
│ │ +                )
│ │ +
│ │ +        dockerfile = environment.get_template("base.Dockerfile.jinja2").render(
│ │ +            image_arguments=image_args, chunks=list(chunks.values())
│ │ +        )
│ │ +        dockerfile = re.sub(r"\n{3,}", r"\n\n", dockerfile)
│ │ +
│ │ +        return dockerfile
│ │ +
│ │ +
│ │ +class BuildConfig(BaseModel):
│ │ +    name: str
│ │ +    image: List[str]
│ │ +    tag_prefix: Optional[str]
│ │ +    tag_postfix: Optional[str]
│ │ +    build_args: Dict[str, Any] = {"load": True}
│ │ +    limit_tags: List[str] = []
│ │ +
│ │ +    @validator("image", pre=True)
│ │ +    def ensure_image_is_list(cls, v):
│ │ +        if not isinstance(v, list):
│ │ +            return [v]
│ │ +        return v
│ │ +
│ │ +    def _render_build_args(self, target: Target, args):
│ │ +        if isinstance(args, list):
│ │ +            return [self._render_build_args(target, a) for a in args]
│ │ +        elif isinstance(args, dict):
│ │ +            return {k: self._render_build_args(target, v) for k, v in args.items()}
│ │ +        elif isinstance(args, str):
│ │ +            for k, v in {
│ │ +                "${TARGET}": target.name,
│ │ +            }.items():
│ │ +                args = args.replace(k, v)
│ │ +            return args
│ │ +        else:
│ │ +            return args
│ │ +
│ │ +    def generate_bakefile(self, target_collection: TargetCollection):
│ │ +        def tag_maker(name):
│ │ +            return "-".join(v for v in [self.tag_prefix, name, self.tag_postfix] if v)
│ │ +
│ │ +        targets = [
│ │ +            t
│ │ +            for t in sorted(target_collection.targets, key=lambda t: t.name)
│ │ +            if all(tag in t.tags for tag in self.limit_tags)
│ │ +        ]
│ │ +
│ │ +        return json.dumps(
│ │ +            dict(
│ │ +                group=dict(default=dict(targets=[target.name for target in targets])),
│ │ +                target={
│ │ +                    target.name: dict(
│ │ +                        dockerfile="Dockerfile.synth",
│ │ +                        tags=[f"{img}:{tag_maker(target.name)}" for img in self.image],
│ │ +                        target=target.name,
│ │ +                        **self._render_build_args(target, self.build_args),
│ │ +                    )
│ │ +                    for target in targets
│ │ +                },
│ │ +            ),
│ │ +            indent=2,
│ │ +        )
│ │ +
│ │ +    @property
│ │ +    def build_command(self):
│ │ +        return f"docker buildx bake -f docker-bake.{self.name}.json"
│ │ +
│ │ +
│ │ +class BuildConfigCollection(BaseModel):
│ │ +    __root__: List[BuildConfig]
│ │   --- docker-printer-0.2.0/docker_printer/resources/templates/stage.Dockerfile.jinja2
│ ├── +++ docker-printer-0.3.0/docker_printer/resources/templates/stage.Dockerfile.jinja2
│ │┄ Files identical despite different names
│ │   --- docker-printer-0.2.0/docker_printer/utils.py
│ ├── +++ docker-printer-0.3.0/docker_printer/utils.py
│ │┄ Files 18% similar despite different names
│ │ @@ -1,117 +1,116 @@
│ │ -import getpass
│ │ -import platform
│ │ -from functools import lru_cache
│ │ -from pathlib import Path
│ │ -from tempfile import TemporaryDirectory
│ │ -
│ │ -import jinja2
│ │ -from importlib import resources
│ │ -import yaml
│ │ -from yaml.scanner import ScannerError
│ │ -
│ │ -from .models import Module
│ │ -
│ │ -
│ │ -@lru_cache(maxsize=None)
│ │ -def base_dir(default_to_local=False) -> Path:
│ │ -    root_dir = Path().resolve()
│ │ -    while not (root_dir / "docker-printer").exists():
│ │ -        if root_dir == root_dir.parent:
│ │ -            if default_to_local:
│ │ -                return Path().resolve()
│ │ -            raise RuntimeError(
│ │ -                "Must run `docker-printer` from a folder that contains a folder "
│ │ -                "named `docker-printer` (or any subfolder of that top-level directory)"
│ │ -            )
│ │ -        root_dir = root_dir.parent
│ │ -    return root_dir
│ │ -
│ │ -
│ │ -@lru_cache(maxsize=None)
│ │ -def config_dir(default_to_local=False) -> Path:
│ │ -    return base_dir(default_to_local=default_to_local) / "docker-printer"
│ │ -
│ │ -
│ │ -def base_resources_dir() -> Path:
│ │ -    with resources.path("docker_printer", "resources") as resources_dir:
│ │ -        return resources_dir
│ │ -
│ │ -
│ │ -def jinja_env():
│ │ -    return jinja2.Environment(
│ │ -        loader=jinja2.FileSystemLoader(
│ │ -            searchpath=[
│ │ -                config_dir() / "templates",
│ │ -                base_resources_dir() / "templates",
│ │ -            ]
│ │ -        ),
│ │ -        auto_reload=True,
│ │ -    )
│ │ -
│ │ -
│ │ -def yml_load(path: Path):
│ │ -    try:
│ │ -        return yaml.safe_load(path.open())
│ │ -    except ScannerError as e:
│ │ -        raise ValueError(f"Invalid YAML file: {path.resolve()}") from e
│ │ -
│ │ -
│ │ -def preload_modules():
│ │ -    for root in [base_resources_dir(), config_dir()]:
│ │ -        for f in (root / "modules").rglob("*.yml"):
│ │ -            Module.parse_obj(yml_load(f))  # Side effect: stored in Module.__modules__
│ │ -
│ │ -
│ │ -def targets_file():
│ │ -    targets_raw_path = config_dir() / "targets.yml"
│ │ -    targets_template_path = config_dir() / "targets.yml.jinja2"
│ │ -    targets_rendered_path = config_dir() / "targets.rendered.yml"
│ │ -
│ │ -    if targets_raw_path.exists() and targets_template_path.exists():
│ │ -        raise RuntimeError(
│ │ -            f"Can only have one of {targets_raw_path} or {targets_template_path}"
│ │ -        )
│ │ -
│ │ -    elif targets_template_path.exists():
│ │ -        rendered = jinja2.Template(targets_template_path.read_text()).render()
│ │ -        targets_rendered_path.write_text(rendered)
│ │ -        return targets_rendered_path
│ │ -
│ │ -    elif targets_raw_path.exists():
│ │ -        return targets_raw_path
│ │ -
│ │ -    else:
│ │ -        raise RuntimeError(f"No targets.yml found in {config_dir()}")
│ │ -
│ │ -
│ │ -def _local_docker_architecture():
│ │ -    architecture_map = {
│ │ -        "x86_64": "amd64",
│ │ -    }
│ │ -    arch = platform.machine().lower()
│ │ -    return architecture_map.get(arch, arch)
│ │ -
│ │ -
│ │ -def builds_file():
│ │ -    builds_raw_path = config_dir() / "builds.yml"
│ │ -    builds_template_path = config_dir() / "builds.yml.jinja2"
│ │ -    builds_rendered_path = config_dir() / "builds.rendered.yml"
│ │ -
│ │ -    if builds_raw_path.exists() and builds_template_path.exists():
│ │ -        raise RuntimeError(
│ │ -            f"Can only have one of {builds_raw_path} or {builds_template_path}"
│ │ -        )
│ │ -
│ │ -    elif builds_template_path.exists():
│ │ -        rendered = jinja2.Template(builds_template_path.read_text()).render(
│ │ -            username=getpass.getuser(),
│ │ -            local_architecture=_local_docker_architecture(),
│ │ -        )
│ │ -        builds_rendered_path.write_text(rendered)
│ │ -        return builds_rendered_path
│ │ -
│ │ -    elif builds_raw_path.exists():
│ │ -        return builds_raw_path
│ │ -
│ │ -    else:
│ │ -        raise RuntimeError(f"No builds.yml found in {config_dir()}")
│ │ +import getpass
│ │ +import platform
│ │ +from functools import lru_cache
│ │ +from importlib import resources
│ │ +from pathlib import Path
│ │ +
│ │ +import jinja2
│ │ +import yaml
│ │ +from yaml.scanner import ScannerError
│ │ +
│ │ +from .models import Module
│ │ +
│ │ +
│ │ +@lru_cache(maxsize=None)
│ │ +def base_dir(default_to_local=False) -> Path:
│ │ +    root_dir = Path().resolve()
│ │ +    while not (root_dir / "docker-printer").exists():
│ │ +        if root_dir == root_dir.parent:
│ │ +            if default_to_local:
│ │ +                return Path().resolve()
│ │ +            raise RuntimeError(
│ │ +                "Must run `docker-printer` from a folder that contains a folder "
│ │ +                "named `docker-printer` (or any subfolder of that top-level directory)"
│ │ +            )
│ │ +        root_dir = root_dir.parent
│ │ +    return root_dir
│ │ +
│ │ +
│ │ +@lru_cache(maxsize=None)
│ │ +def config_dir(default_to_local=False) -> Path:
│ │ +    return base_dir(default_to_local=default_to_local) / "docker-printer"
│ │ +
│ │ +
│ │ +def base_resources_dir() -> Path:
│ │ +    with resources.path("docker_printer", "resources") as resources_dir:
│ │ +        return resources_dir
│ │ +
│ │ +
│ │ +def jinja_env():
│ │ +    return jinja2.Environment(
│ │ +        loader=jinja2.FileSystemLoader(
│ │ +            searchpath=[
│ │ +                config_dir() / "templates",
│ │ +                base_resources_dir() / "templates",
│ │ +            ]
│ │ +        ),
│ │ +        auto_reload=True,
│ │ +    )
│ │ +
│ │ +
│ │ +def yml_load(path: Path):
│ │ +    try:
│ │ +        return yaml.safe_load(path.open())
│ │ +    except ScannerError as e:
│ │ +        raise ValueError(f"Invalid YAML file: {path.resolve()}") from e
│ │ +
│ │ +
│ │ +def preload_modules():
│ │ +    for root in [base_resources_dir(), config_dir()]:
│ │ +        for f in (root / "modules").rglob("*.yml"):
│ │ +            Module.parse_obj(yml_load(f))  # Side effect: stored in Module.__modules__
│ │ +
│ │ +
│ │ +def targets_file():
│ │ +    targets_raw_path = config_dir() / "targets.yml"
│ │ +    targets_template_path = config_dir() / "targets.yml.jinja2"
│ │ +    targets_rendered_path = config_dir() / "targets.rendered.yml"
│ │ +
│ │ +    if targets_raw_path.exists() and targets_template_path.exists():
│ │ +        raise RuntimeError(
│ │ +            f"Can only have one of {targets_raw_path} or {targets_template_path}"
│ │ +        )
│ │ +
│ │ +    elif targets_template_path.exists():
│ │ +        rendered = jinja2.Template(targets_template_path.read_text()).render()
│ │ +        targets_rendered_path.write_text(rendered)
│ │ +        return targets_rendered_path
│ │ +
│ │ +    elif targets_raw_path.exists():
│ │ +        return targets_raw_path
│ │ +
│ │ +    else:
│ │ +        raise RuntimeError(f"No targets.yml found in {config_dir()}")
│ │ +
│ │ +
│ │ +def _local_docker_architecture():
│ │ +    architecture_map = {
│ │ +        "x86_64": "amd64",
│ │ +    }
│ │ +    arch = platform.machine().lower()
│ │ +    return architecture_map.get(arch, arch)
│ │ +
│ │ +
│ │ +def builds_file():
│ │ +    builds_raw_path = config_dir() / "builds.yml"
│ │ +    builds_template_path = config_dir() / "builds.yml.jinja2"
│ │ +    builds_rendered_path = config_dir() / "builds.rendered.yml"
│ │ +
│ │ +    if builds_raw_path.exists() and builds_template_path.exists():
│ │ +        raise RuntimeError(
│ │ +            f"Can only have one of {builds_raw_path} or {builds_template_path}"
│ │ +        )
│ │ +
│ │ +    elif builds_template_path.exists():
│ │ +        rendered = jinja2.Template(builds_template_path.read_text()).render(
│ │ +            username=getpass.getuser(),
│ │ +            local_architecture=_local_docker_architecture(),
│ │ +        )
│ │ +        builds_rendered_path.write_text(rendered)
│ │ +        return builds_rendered_path
│ │ +
│ │ +    elif builds_raw_path.exists():
│ │ +        return builds_raw_path
│ │ +
│ │ +    else:
│ │ +        raise RuntimeError(f"No builds.yml found in {config_dir()}")
│ │   --- docker-printer-0.2.0/setup.cfg
│ ├── +++ docker-printer-0.3.0/setup.cfg
│ │┄ Files 17% similar despite different names
│ │ @@ -1,43 +1,42 @@
│ │ -[metadata]
│ │ -version = 0.2.0
│ │ -name = docker-printer
│ │ -description = Composer for dockerfiles
│ │ -author = Rearc Data
│ │ -author_email = data@rearc.io
│ │ -long_description = file: README.md
│ │ -long_description_content_type = text/markdown
│ │ -url = https://github.com/rearc-data/docker-printer
│ │ -project_urls = 
│ │ -	Bug Tracker = https://github.com/rearc-data/docker-printer/issues
│ │ -classifiers = 
│ │ -	Programming Language :: Python :: 3
│ │ -	License :: OSI Approved :: MIT License
│ │ -	Operating System :: OS Independent
│ │ -
│ │ -[options.entry_points]
│ │ -console_scripts = 
│ │ -	docker-printer = docker_printer.__main__:main
│ │ -
│ │ -[options]
│ │ -packages = find:
│ │ -python_requires = >=3.7
│ │ -install_requires = 
│ │ -	pyyaml
│ │ -	jinja2
│ │ -	click
│ │ -include_package_data = True
│ │ -
│ │ -[options.packages.find]
│ │ -where = .
│ │ -
│ │ -[options.package_data]
│ │ -docker_printer.resources = 
│ │ -	templates/*.jinja2
│ │ -
│ │ -[tool:pytest]
│ │ -addopts = --cov=docker-printer --cov-report term-missing --cov-report html
│ │ -
│ │ -[egg_info]
│ │ -tag_build = 
│ │ -tag_date = 0
│ │ -
│ │ +[metadata]
│ │ +version = 0.3.0
│ │ +name = docker-printer
│ │ +description = Composer for dockerfiles
│ │ +author = Rearc Data
│ │ +author_email = data@rearc.io
│ │ +
│ │ +long_description = file: README.md
│ │ +long_description_content_type = text/markdown
│ │ +url = https://github.com/rearc-data/docker-printer
│ │ +
│ │ +project_urls =
│ │ +    Bug Tracker = https://github.com/rearc-data/docker-printer/issues
│ │ +classifiers =
│ │ +    Programming Language :: Python :: 3
│ │ +    License :: OSI Approved :: MIT License
│ │ +    Operating System :: OS Independent
│ │ +
│ │ +[options.entry_points]
│ │ +console_scripts =
│ │ +    docker-printer = docker_printer.__main__:main
│ │ +
│ │ +[options]
│ │ +packages = find:
│ │ +python_requires = >=3.7
│ │ +install_requires =
│ │ +    pyyaml
│ │ +    jinja2
│ │ +    typer
│ │ +    pydantic
│ │ +    rich
│ │ +include_package_data = True
│ │ +
│ │ +[options.packages.find]
│ │ +where = .
│ │ +
│ │ +[options.package_data]
│ │ +docker_printer.resources =
│ │ +    templates/*.jinja2
│ │ +
│ │ +[tool:pytest]
│ │ +addopts = --cov=docker-printer --cov-report term-missing --cov-report html
