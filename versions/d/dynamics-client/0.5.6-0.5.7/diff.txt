--- tmp/dynamics_client-0.5.6.tar.gz
+++ tmp/dynamics_client-0.5.7.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "dynamics_client-0.5.6.tar", max compression
│ +gzip compressed data, was "dynamics_client-0.5.7.tar", max compression
│   --- dynamics_client-0.5.6.tar
├── +++ dynamics_client-0.5.7.tar
│ ├── file list
│ │ @@ -1,19 +1,19 @@
│ │ --rw-r--r--   0        0        0     1069 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/LICENSE
│ │ --rw-r--r--   0        0        0     4799 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/README.md
│ │ --rw-r--r--   0        0        0      193 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/__init__.py
│ │ --rw-r--r--   0        0        0     9533 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/api_actions.py
│ │ --rw-r--r--   0        0        0     7335 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/api_functions.py
│ │ --rw-r--r--   0        0        0     2028 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/apply_functions.py
│ │ --rw-r--r--   0        0        0    33358 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/client.py
│ │ --rw-r--r--   0        0        0     4208 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/enums.py
│ │ --rw-r--r--   0        0        0     4220 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/exceptions.py
│ │ --rw-r--r--   0        0        0    33710 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/fetchxml.py
│ │ --rw-r--r--   0        0        0     1530 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/normalizers.py
│ │ --rw-r--r--   0        0        0    36553 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/query_functions.py
│ │ --rw-r--r--   0        0        0     1910 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/status.py
│ │ --rw-r--r--   0        0        0     9803 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/test.py
│ │ --rw-r--r--   0        0        0     5138 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/typing.py
│ │ --rw-r--r--   0        0        0     8175 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/dynamics/utils.py
│ │ --rw-r--r--   0        0        0     3274 2022-12-20 12:23:36.232764 dynamics_client-0.5.6/pyproject.toml
│ │ --rw-r--r--   0        0        0     5977 1970-01-01 00:00:00.000000 dynamics_client-0.5.6/setup.py
│ │ --rw-r--r--   0        0        0     6547 1970-01-01 00:00:00.000000 dynamics_client-0.5.6/PKG-INFO
│ │ +-rw-r--r--   0        0        0     1069 2023-04-06 18:35:53.482018 dynamics_client-0.5.7/LICENSE
│ │ +-rw-r--r--   0        0        0     4799 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/README.md
│ │ +-rw-r--r--   0        0        0      192 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/__init__.py
│ │ +-rw-r--r--   0        0        0     9531 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/api_actions.py
│ │ +-rw-r--r--   0        0        0     7334 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/api_functions.py
│ │ +-rw-r--r--   0        0        0     2027 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/apply_functions.py
│ │ +-rw-r--r--   0        0        0    35940 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/client.py
│ │ +-rw-r--r--   0        0        0     4207 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/enums.py
│ │ +-rw-r--r--   0        0        0     4219 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/exceptions.py
│ │ +-rw-r--r--   0        0        0    33719 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/fetchxml.py
│ │ +-rw-r--r--   0        0        0     1529 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/normalizers.py
│ │ +-rw-r--r--   0        0        0    36552 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/query_functions.py
│ │ +-rw-r--r--   0        0        0     1910 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/status.py
│ │ +-rw-r--r--   0        0        0    10051 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/test.py
│ │ +-rw-r--r--   0        0        0     5137 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/typing.py
│ │ +-rw-r--r--   0        0        0     8654 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/dynamics/utils.py
│ │ +-rw-r--r--   0        0        0     3043 2023-04-06 18:35:53.486019 dynamics_client-0.5.7/pyproject.toml
│ │ +-rw-r--r--   0        0        0     5975 1970-01-01 00:00:00.000000 dynamics_client-0.5.7/setup.py
│ │ +-rw-r--r--   0        0        0     6495 1970-01-01 00:00:00.000000 dynamics_client-0.5.7/PKG-INFO
│ │   --- dynamics_client-0.5.6/LICENSE
│ ├── +++ dynamics_client-0.5.7/LICENSE
│ │┄ Files identical despite different names
│ │   --- dynamics_client-0.5.6/README.md
│ ├── +++ dynamics_client-0.5.7/README.md
│ │┄ Files identical despite different names
│ │   --- dynamics_client-0.5.6/dynamics/api_actions.py
│ ├── +++ dynamics_client-0.5.7/dynamics/api_actions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -5,15 +5,14 @@
│ │  Documentation:
│ │  https://docs.microsoft.com/en-us/powerapps/developer/data-platform/webapi/use-web-api-actions
│ │  """
│ │  
│ │  from .enums import QuoteState
│ │  from .typing import TYPE_CHECKING, Any, Dict, List, Literal
│ │  
│ │ -
│ │  if TYPE_CHECKING:
│ │      from .client import DynamicsClient  # pylint: disable=R0401
│ │  
│ │  
│ │  __all__ = ["Actions"]
│ │  
│ │  
│ │ @@ -42,15 +41,15 @@
│ │  
│ │          https://docs.microsoft.com/en-us/dynamics365/customer-engagement/web-api/sendemailfromtemplate
│ │  
│ │          :param template_id: Dynamics template GUID to use.
│ │          :param context_table: What table to use in the context of the email.
│ │          :param context_row_id: What row to select from the context table. This row's data can be used in
│ │                                 dynamically in the body of the email template.
│ │ -        :param sender_id: Dynamics systemuser GUID that sends the email. Must have 'send-as' privilegde.
│ │ +        :param sender_id: Dynamics systemuser GUID that sends the email. Must have 'send-as' privilege.
│ │          :param to_recipient_ids: List of Dynamics contact GUIDS to add as to recipients.
│ │          :param cc_recipient_ids: List of Dynamics contact GUIDS to add as cc recipients.
│ │          :param bcc_recipient_ids: List of Dynamics contact GUIDS to add as bcc recipients.
│ │          :return: Tuple of the action name and POST data to send.
│ │          """
│ │  
│ │          def add_parties(parties_list: List[str], party_type: Literal[1, 2, 3, 4]):
│ │   --- dynamics_client-0.5.6/dynamics/api_functions.py
│ ├── +++ dynamics_client-0.5.7/dynamics/api_functions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -2,15 +2,14 @@
│ │  Functions available in the web API. Reference:
│ │  https://docs.microsoft.com/en-us/dynamics365/customer-engagement/web-api/functions
│ │  """
│ │  
│ │  from .enums import EntityFilter, TargetFieldType
│ │  from .typing import TYPE_CHECKING, Any, Dict, List
│ │  
│ │ -
│ │  if TYPE_CHECKING:
│ │      from .client import DynamicsClient  # pylint: disable=R0401
│ │  
│ │  
│ │  __all__ = ["Functions"]
│ │   --- dynamics_client-0.5.6/dynamics/apply_functions.py
│ ├── +++ dynamics_client-0.5.7/dynamics/apply_functions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -5,15 +5,14 @@
│ │  
│ │  FetchXML aggregation documentation:
│ │  https://docs.microsoft.com/en-us/powerapps/developer/data-platform/use-fetchxml-aggregation
│ │  """
│ │  
│ │  from .typing import FilterType, List, Literal
│ │  
│ │ -
│ │  __all__ = ["apl"]
│ │  
│ │  
│ │  class apl:
│ │      """Convenience functions for creating $apply parameters."""
│ │  
│ │      @staticmethod
│ │   --- dynamics_client-0.5.6/dynamics/client.py
│ ├── +++ dynamics_client-0.5.7/dynamics/client.py
│ │┄ Files 4% similar despite different names
│ │ @@ -5,18 +5,19 @@
│ │  """
│ │  import asyncio
│ │  import json
│ │  import logging
│ │  import os
│ │  from concurrent.futures import ThreadPoolExecutor
│ │  from types import TracebackType
│ │ +from typing import Union
│ │  from urllib.parse import quote
│ │  
│ │  from oauthlib.oauth2 import BackendApplicationClient, OAuth2Token
│ │ -from requests import JSONDecodeError  # noqa
│ │ +from requests import HTTPError, JSONDecodeError  # noqa
│ │  from requests_oauthlib import OAuth2Session
│ │  
│ │  from . import status
│ │  from .api_actions import Actions
│ │  from .api_functions import Functions
│ │  from .exceptions import (
│ │      APILimitsExceeded,
│ │ @@ -44,16 +45,15 @@
│ │      Optional,
│ │      OrderbyType,
│ │      P,
│ │      T,
│ │      Type,
│ │      TypeVar,
│ │  )
│ │ -from .utils import cache, error_simplification_available, sentinel, to_coroutine
│ │ -
│ │ +from .utils import Singletons, error_simplification_available, sentinel, to_coroutine
│ │  
│ │  __all__ = ["DynamicsClient"]
│ │  
│ │  
│ │  logger = logging.getLogger(__name__)
│ │  EXC = TypeVar("EXC", bound=BaseException)
│ │  DClient = TypeVar("DClient", bound="DynamicsClient")
│ │ @@ -79,33 +79,51 @@
│ │          status.HTTP_413_REQUEST_ENTITY_TOO_LARGE: PayloadTooLarge,
│ │          status.HTTP_429_TOO_MANY_REQUESTS: APILimitsExceeded,
│ │          status.HTTP_500_INTERNAL_SERVER_ERROR: DynamicsException,
│ │          status.HTTP_501_NOT_IMPLEMENTED: OperationNotImplemented,
│ │          status.HTTP_503_SERVICE_UNAVAILABLE: WebAPIUnavailable,
│ │      }
│ │  
│ │ -    def __init__(self, api_url: str, token_url: str, client_id: str, client_secret: str, scope: List[str]):
│ │ +    def __init__(
│ │ +        self,
│ │ +        api_url: str,
│ │ +        token_url: str,
│ │ +        client_id: str,
│ │ +        client_secret: str,
│ │ +        scope: Optional[Union[str, List[str]]] = None,
│ │ +        resource: Optional[str] = None,
│ │ +    ):
│ │          """Establish a Microsoft Dynamics 365 Dataverse API client connection
│ │          using OAuth 2.0 Client Credentials Flow. Client Credentials require an application user to be
│ │          created in Dynamics, and granting it an appropriate security role.
│ │  
│ │          :param api_url: API root URL. Format: https://[Organization URI]/api/data/v{api_version}
│ │          :param token_url: URL to the Dynamics/Azure token endpoint.
│ │                            Format: https://[Dynamics Token URI]/path/to/token
│ │          :param client_id: Dynamics User ID.
│ │          :param client_secret: Dynamics User Secret that proves its identity when password is required.
│ │ -        :param scope: List of urls that define the database records that the API connection has access to.
│ │ -                      Most likely in this format: https://[Organization URI]/.default
│ │ +        :param scope: Url, or list of urls, that define(s) the database records that the API connection has access to.
│ │ +                      Each most likely in this format: https://[Organization URI]/.default
│ │ +        :param resource: Url that defines the database records that the API connection has access to.
│ │ +                      Most likely in this format: https://[Organization URI]/
│ │          """
│ │  
│ │ +        if not scope and not resource:
│ │ +            raise ValueError(
│ │ +                "To instantiate a DynamicsClient, you must provide at least one of either the"
│ │ +                " scope or resource parameters."
│ │ +            )
│ │ +
│ │          self._api_url = api_url.rstrip("/") + "/"
│ │          self._session = OAuth2Session(client=BackendApplicationClient(client_id=client_id))
│ │          token = self.get_token()
│ │          if token is None:  # pragma: no cover
│ │ -            token = self._session.fetch_token(token_url=token_url, client_secret=client_secret, scope=scope)
│ │ +            token = self._session.fetch_token(
│ │ +                token_url=token_url, client_secret=client_secret, scope=scope, resource=resource
│ │ +            )
│ │              self.set_token(token)
│ │          else:
│ │              self._session.token = token
│ │  
│ │          self._select: List[str] = []
│ │          self._expand: ExpandDict = {}
│ │          self._filter: FilterType = []
│ │ @@ -144,51 +162,62 @@
│ │              finally:
│ │                  del self.__tg
│ │  
│ │      def get_token(self) -> OAuth2Token:
│ │          """Get dynamics client token in a thread, so it can be done in an async context."""
│ │  
│ │          def task() -> OAuth2Token:
│ │ -            return cache.get(self.cache_key, None)
│ │ +            return Singletons.cache().get(self.cache_key, None)
│ │  
│ │          with ThreadPoolExecutor() as executor:
│ │              future = executor.submit(task)
│ │              return future.result()
│ │  
│ │      def set_token(self, token: OAuth2Token):
│ │          """Set dynamics client token in a thread, so it can be done in an async context."""
│ │  
│ │          def task():
│ │              expires = int(token["expires_in"]) - 60
│ │ -            cache.set(self.cache_key, token, expires)
│ │ +            Singletons.cache().set(self.cache_key, token, expires)
│ │  
│ │          with ThreadPoolExecutor() as executor:
│ │              future = executor.submit(task)
│ │              return future.result()
│ │  
│ │      @classmethod
│ │      def from_environment(cls):
│ │          """Create a client from environment variables:
│ │  
│ │          * DYNAMICS_API_URL: url string
│ │          * DYNAMICS_TOKEN_URL: url string
│ │          * DYNAMICS_CLIENT_ID: client id string
│ │          * DYNAMICS_CLIENT_SECRET: client secret key string
│ │ +
│ │          * DYNAMICS_SCOPE: comma separated list of urls
│ │ +        * DYNAMICS_RESOURCE: single target url
│ │ +
│ │ +        At least one of DYNAMICS_SCOPE or DYNAMICS_RESOURCE must be provided.
│ │  
│ │          :raises KeyError: An environment variable was not configured properly
│ │          """
│ │  
│ │          api_url = os.environ["DYNAMICS_API_URL"]
│ │          token_url = os.environ["DYNAMICS_TOKEN_URL"]
│ │          client_id = os.environ["DYNAMICS_CLIENT_ID"]
│ │          client_secret = os.environ["DYNAMICS_CLIENT_SECRET"]
│ │ -        scope = os.environ["DYNAMICS_SCOPE"].split(",")
│ │  
│ │ -        return cls(api_url, token_url, client_id, client_secret, scope)
│ │ +        scope = os.environ.get("DYNAMICS_SCOPE")
│ │ +        resource = os.environ.get("DYNAMICS_RESOURCE")
│ │ +        if not scope and not resource:
│ │ +            raise KeyError("At least one of DYNAMICS_SCOPE or DYNAMICS_RESOURCE env var must be set.")
│ │ +
│ │ +        if scope is not None and "," in scope:
│ │ +            scope = scope.split(",")  # only create list if a comma exists, otherwise keep as str.
│ │ +
│ │ +        return cls(api_url, token_url, client_id, client_secret, scope, resource)
│ │  
│ │      @property
│ │      def current_query(self) -> str:
│ │          """Constructs query from current options, leaving out empty ones."""
│ │  
│ │          query = self._api_url + self.table
│ │  
│ │ @@ -202,17 +231,17 @@
│ │              if query[-1] != "/":
│ │                  query += "/"
│ │              query += self.action
│ │  
│ │          if self.add_ref_to_property:
│ │              query += f"/{self.add_ref_to_property}/$ref"
│ │  
│ │ -        query_optinos = self._compile_query_options()
│ │ -        if query_optinos:
│ │ -            query += query_optinos
│ │ +        query_options = self._compile_query_options()
│ │ +        if query_options:
│ │ +            query += query_options
│ │  
│ │          return query
│ │  
│ │      def _compile_query_options(self) -> str:
│ │          query_options = "&".join(
│ │              [
│ │                  statement
│ │ @@ -340,14 +369,24 @@
│ │  
│ │          response = self._session.get(
│ │              url=query,
│ │              headers={**self.default_headers("get"), **self.headers},
│ │          )
│ │  
│ │          try:
│ │ +            response.raise_for_status()
│ │ +        except HTTPError as error:
│ │ +            raise self.handled_error(
│ │ +                status_code=error.response.status_code,
│ │ +                error_message=f"{str(error)}. Response: {error.response.text}",
│ │ +                error_code="http_error",
│ │ +                method="get",
│ │ +            ) from error
│ │ +
│ │ +        try:
│ │              data = response.json()
│ │          except JSONDecodeError as error:
│ │              raise self.handled_error(
│ │                  status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
│ │                  error_message=f"{str(error)}. Response: {response.text}",
│ │                  error_code="invalid_json",
│ │                  method="get",
│ │ @@ -430,14 +469,24 @@
│ │              headers={**self.default_headers("post"), **self.headers},
│ │          )
│ │  
│ │          if response.status_code == status.HTTP_204_NO_CONTENT:
│ │              return {}
│ │  
│ │          try:
│ │ +            response.raise_for_status()
│ │ +        except HTTPError as error:
│ │ +            raise self.handled_error(
│ │ +                status_code=error.response.status_code,
│ │ +                error_message=f"{str(error)}. Response: {error.response.text}",
│ │ +                error_code="http_error",
│ │ +                method="post",
│ │ +            ) from error
│ │ +
│ │ +        try:
│ │              data = response.json()
│ │          except JSONDecodeError as error:
│ │              raise self.handled_error(
│ │                  status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
│ │                  error_message=f"{str(error)}. Response: {response.text}",
│ │                  error_code="invalid_json",
│ │                  method="get",
│ │ @@ -476,14 +525,24 @@
│ │              headers={**self.default_headers("patch"), **self.headers},
│ │          )
│ │  
│ │          if response.status_code == status.HTTP_204_NO_CONTENT:
│ │              return {}
│ │  
│ │          try:
│ │ +            response.raise_for_status()
│ │ +        except HTTPError as error:
│ │ +            raise self.handled_error(
│ │ +                status_code=error.response.status_code,
│ │ +                error_message=f"{str(error)}. Response: {error.response.text}",
│ │ +                error_code="http_error",
│ │ +                method="patch",
│ │ +            ) from error
│ │ +
│ │ +        try:
│ │              data = response.json()
│ │          except JSONDecodeError as error:
│ │              raise self.handled_error(
│ │                  status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
│ │                  error_message=f"{str(error)}. Response: {response.text}",
│ │                  error_code="invalid_json",
│ │                  method="get",
│ │ @@ -519,14 +578,24 @@
│ │              headers={**self.default_headers("delete"), **self.headers},
│ │          )
│ │  
│ │          if response.status_code == status.HTTP_204_NO_CONTENT:
│ │              return
│ │  
│ │          try:
│ │ +            response.raise_for_status()
│ │ +        except HTTPError as error:
│ │ +            raise self.handled_error(
│ │ +                status_code=error.response.status_code,
│ │ +                error_message=f"{str(error)}. Response: {error.response.text}",
│ │ +                error_code="http_error",
│ │ +                method="delete",
│ │ +            ) from error
│ │ +
│ │ +        try:
│ │              data = response.json()
│ │          except JSONDecodeError as error:
│ │              raise self.handled_error(
│ │                  status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
│ │                  error_message=f"{str(error)}. Response: {response.text}",
│ │                  error_code="invalid_json",
│ │                  method="get",
│ │ @@ -621,15 +690,15 @@
│ │      @add_ref_to_property.setter
│ │      def add_ref_to_property(self, value: str) -> None:
│ │          self._add_ref_to_property = value
│ │  
│ │      @property
│ │      def pre_expand(self) -> str:
│ │          """Expand/navigate to some linked table in this table
│ │ -        before taking any queryoptions into account.
│ │ +        before taking any query options into account.
│ │          This will save you having to use the expand statement itself,
│ │          if all you are looking for is under this table anyway.
│ │          """
│ │          return self._pre_expand
│ │  
│ │      @pre_expand.setter
│ │      def pre_expand(self, value: str) -> None:
│ │ @@ -693,15 +762,15 @@
│ │          1. Nested expand statements can *only* be applied to **many-to-one/single-valued** relationships.
│ │          This means nested expands for collections do not work!
│ │  
│ │          2. Each request can include a maximum of 10 expand statements.
│ │          This applies to non-nested statements as well! There is no limit on the depth of nested
│ │          expand statements, so long as the total is 10.
│ │  
│ │ -        :param items: What linked tables (a.k.a. naviagation properties) to expand and
│ │ +        :param items: What linked tables (a.k.a. navigation properties) to expand and
│ │                        what statements to apply inside the expanded tables.
│ │                        If items-dict value is set to an empty dict, no query options are used.
│ │                        Otherwise, valid keys for the items-dict are 'select', 'filter', 'top', 'orderby', and 'expand'.
│ │                        Values under these keys should be constructed in the same manner as they are
│ │                        when outside the expand statement, e.g. 'select' takes a List[str], 'top' an int, etc.
│ │          """
│ │  
│ │ @@ -909,15 +978,15 @@
│ │      @fetch_xml.setter
│ │      def fetch_xml(self, value: str) -> None:
│ │          """Set a query using the FetchXML query language.
│ │          Must set table, but cannot set any other query options!
│ │  
│ │          Queries can be constructed with the included FetchXMLBuilder.
│ │  
│ │ -        XML Shema:
│ │ +        XML Schema:
│ │          https://docs.microsoft.com/en-us/powerapps/developer/data-platform/fetchxml-schema
│ │  
│ │          How to use:
│ │          https://docs.microsoft.com/en-us/powerapps/developer/data-platform/use-fetchxml-construct-query
│ │          """
│ │  
│ │          self._fetch_xml = value
│ │   --- dynamics_client-0.5.6/dynamics/enums.py
│ ├── +++ dynamics_client-0.5.7/dynamics/enums.py
│ │┄ Files 0% similar despite different names
│ │ @@ -1,10 +1,9 @@
│ │  from enum import Enum, IntEnum
│ │  
│ │ -
│ │  __all__ = [
│ │      "QuoteState",
│ │      "OrderState",
│ │      "TargetFieldType",
│ │      "EntityFilter",
│ │      "FetchXMLOperator",
│ │  ]
│ │   --- dynamics_client-0.5.6/dynamics/exceptions.py
│ ├── +++ dynamics_client-0.5.7/dynamics/exceptions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -1,12 +1,11 @@
│ │  import logging
│ │  
│ │  from . import status
│ │  
│ │ -
│ │  try:
│ │      from rest_framework.exceptions import APIException
│ │  
│ │  except ImportError:
│ │  
│ │      class APIException(Exception):
│ │          status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
│ │   --- dynamics_client-0.5.6/dynamics/fetchxml.py
│ ├── +++ dynamics_client-0.5.7/dynamics/fetchxml.py
│ │┄ Files 0% similar despite different names
│ │ @@ -20,15 +20,14 @@
│ │      List,
│ │      Literal,
│ │      LiteralBool,
│ │      Optional,
│ │      Union,
│ │  )
│ │  
│ │ -
│ │  __all__ = [
│ │      "FetchXMLBuilder",
│ │  ]
│ │  
│ │  
│ │  def _serialize_bool(value: bool) -> LiteralBool:
│ │      return "true" if value else "false"  # type: ignore
│ │ @@ -50,15 +49,15 @@
│ │          output_format: Optional[FetchXMLOutputFormat] = None,
│ │          min_active_row_version: Optional[bool] = None,
│ │          return_total_record_count: Optional[bool] = None,
│ │          no_lock: Optional[bool] = None,
│ │      ):
│ │          """A Builder class for building FetchXML queries.
│ │  
│ │ -        XML Shema:
│ │ +        XML Schema:
│ │          https://docs.microsoft.com/en-us/powerapps/developer/data-platform/fetchxml-schema
│ │  
│ │          :param mapping: Should be "logical" for 3rd parties.
│ │          :param version: Version information.
│ │          :param page: When paging a request, this is the page number.
│ │          :param count: Then paging a request, this is the number of items per page.
│ │          :param top: Limit the number of items in the query.
│ │ @@ -144,15 +143,15 @@
│ │          alias: Optional[str] = None,
│ │          descending: Optional[bool] = None,
│ │      ) -> "FetchXMLBuilder":
│ │          """Apply ordering for the view. This is for the Reports view only.
│ │  
│ │          :param attribute: Attribute to order by.
│ │          :param alias: Attribute alias.
│ │ -        :param descending: Decending order?
│ │ +        :param descending: Descending order?
│ │          :return: The current instance of the FetchXMLBuilder.
│ │          """
│ │  
│ │          self._order = FetchXMLOrderType(attribute=attribute)
│ │          if alias is not None:
│ │              self._order["alias"] = alias
│ │          if descending is not None:
│ │ @@ -253,15 +252,15 @@
│ │      def _linked_table_count(self, value: int) -> None:
│ │          self._parent_builder._linked_table_count = value
│ │  
│ │      def with_all_attributes(self) -> "_EntityBuilder":
│ │          """Include all attributes from the main entity to the query.
│ │          Mutually exclusive with adding individual attributes.
│ │  
│ │ -        :return: The current intance of the EntityBuilder.
│ │ +        :return: The current instance of the EntityBuilder.
│ │          """
│ │  
│ │          if self._attributes:
│ │              raise ValueError("Individual attributes defined, cannot add all attributes.")
│ │          self._all_attributes = True
│ │          return self
│ │  
│ │ @@ -279,22 +278,22 @@
│ │          build: FetchXMLBuildType = None,
│ │      ) -> "_EntityBuilder":
│ │          """Add an attribute to the query for the main entity.
│ │          Mutually exclusive with adding all attributes.
│ │  
│ │          :param name: Name of the attribute to add.
│ │          :param alias: Name to alias the attribute under.
│ │ -        :param aggregate: Aggregate function to apply to the attrubte.
│ │ +        :param aggregate: Aggregate function to apply to the attribute.
│ │          :param groupby: Group by this attribute.
│ │          :param distinct: If True, remove duplicate values from the resultset.
│ │          :param date_grouping: How to group dates?
│ │          :param user_timezone: Use user's timezone?
│ │          :param added_by: Added by.
│ │          :param build: Build number.
│ │ -        :return: The current intance of the EntityBuilder.
│ │ +        :return: The current instance of the EntityBuilder.
│ │          """
│ │  
│ │          if self._all_attributes:
│ │              raise ValueError("All attributes defined, cannot add individual attributes.")
│ │  
│ │          attribute = FetchXMLAttributeType(name=name)
│ │  
│ │ @@ -368,15 +367,15 @@
│ │          alias: str = None,
│ │          descending: Optional[bool] = None,
│ │      ) -> "_EntityBuilder":
│ │          """Apply ordering for the main entity's attributes.
│ │  
│ │          :param attribute: Attribute to order by.
│ │          :param alias: Attribute alias.
│ │ -        :param descending: Decending order?
│ │ +        :param descending: Descending order?
│ │          :return: The current instance of the EntityBuilder.
│ │          """
│ │  
│ │          self._order = FetchXMLOrderType(attribute=attribute)
│ │          if alias is not None:
│ │              self._order["alias"] = alias
│ │          if descending is not None:
│ │ @@ -481,15 +480,15 @@
│ │      def _linked_table_count(self, value: int) -> None:
│ │          self._parent_builder._linked_table_count = value
│ │  
│ │      def with_all_attributes(self) -> "_LinkedEntityBuilder":
│ │          """Include all attributes from this linked entity to the query.
│ │          Mutually exclusive with adding individual attributes.
│ │  
│ │ -        :return: The current intance of the EntityBuilder.
│ │ +        :return: The current instance of the EntityBuilder.
│ │          """
│ │  
│ │          if self._attributes:
│ │              raise ValueError("Individual attributes defined, cannot add all attributes.")
│ │          self._all_attributes = True
│ │          return self
│ │  
│ │ @@ -507,22 +506,22 @@
│ │          build: Optional[FetchXMLBuildType] = None,
│ │      ) -> "_LinkedEntityBuilder":
│ │          """Add an attribute to the query for this linked entity.
│ │          Mutually exclusive with adding all attributes.
│ │  
│ │          :param name: Name of the attribute to add.
│ │          :param alias: Name to alias the attribute under.
│ │ -        :param aggregate: Aggregate function to apply to the attrubte.
│ │ +        :param aggregate: Aggregate function to apply to the attribute.
│ │          :param groupby: Group by this attribute.
│ │          :param distinct: If True, remove duplicate values from the resultset.
│ │          :param date_grouping: How to group dates?
│ │          :param user_timezone: Use user's timezone?
│ │          :param added_by: Added by.
│ │          :param build: Build number.
│ │ -        :return: The current intance of the LinkedEntityBuilder.
│ │ +        :return: The current instance of the LinkedEntityBuilder.
│ │          """
│ │  
│ │          if self._all_attributes:
│ │              raise ValueError("All attributes defined, cannot add individual attributes.")
│ │  
│ │          attribute = FetchXMLAttributeType(name=name)
│ │  
│ │ @@ -648,15 +647,15 @@
│ │          alias: Optional[str] = None,
│ │          descending: Optional[bool] = None,
│ │      ) -> "_LinkedEntityBuilder":
│ │          """Apply ordering for the linked entity's attributes.
│ │  
│ │          :param attribute: Attribute to order by.
│ │          :param alias: Attribute alias.
│ │ -        :param descending: Decending order?
│ │ +        :param descending: Descending order?
│ │          :return: The current instance of the LinkedEntityBuilder.
│ │          """
│ │  
│ │          self._order = FetchXMLOrderType(attribute=attribute)
│ │          if alias is not None:
│ │              self._order["alias"] = alias
│ │          if descending is not None:
│ │   --- dynamics_client-0.5.6/dynamics/normalizers.py
│ ├── +++ dynamics_client-0.5.7/dynamics/normalizers.py
│ │┄ Files 1% similar despite different names
│ │ @@ -5,15 +5,14 @@
│ │  """
│ │  
│ │  from datetime import datetime
│ │  
│ │  from .typing import Any, Optional
│ │  from .utils import from_dynamics_date_format
│ │  
│ │ -
│ │  __all__ = [
│ │      "as_int",
│ │      "as_float",
│ │      "as_str",
│ │      "as_bool",
│ │  ]
│ │   --- dynamics_client-0.5.6/dynamics/query_functions.py
│ ├── +++ dynamics_client-0.5.7/dynamics/query_functions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -9,15 +9,14 @@
│ │  https://docs.microsoft.com/en-us/dynamics365/customer-engagement/web-api/queryfunctions?view=dynamics-ce-odata-9
│ │  """
│ │  
│ │  
│ │  from .typing import CompType, FieldType, List, Optional, Tuple
│ │  from .utils import is_valid_uuid
│ │  
│ │ -
│ │  __all__ = ["ftr"]
│ │  
│ │  
│ │  class ftr:  # pylint: disable=R0904
│ │      """Convenience functions for creating $filter parameters."""
│ │  
│ │      # Base operations
│ │ @@ -213,15 +212,15 @@
│ │                                   provide the lambda operations item indicator here.
│ │          :param group: Group the operation inside parentheses.
│ │          """
│ │          return ftr._comp_operator(column, value, lambda_indicator, "lt", group)
│ │  
│ │      @staticmethod
│ │      def le(column: str, value: FieldType, lambda_indicator: str = None, group: bool = False) -> str:
│ │ -        """Evaluate whether the value in the given column is less than or equel to value.
│ │ +        """Evaluate whether the value in the given column is less than or equal to value.
│ │  
│ │          :param column: Column to apply the operation to.
│ │          :param value: Value that the column should less than or equal to.
│ │          :param lambda_indicator: If this operation is evaluated inside a lambda operation,
│ │                                   provide the lambda operations item indicator here.
│ │          :param group: Group the operation inside parentheses.
│ │          """
│ │   --- dynamics_client-0.5.6/dynamics/status.py
│ ├── +++ dynamics_client-0.5.7/dynamics/status.py
│ │┄ Files identical despite different names
│ │   --- dynamics_client-0.5.6/dynamics/test.py
│ ├── +++ dynamics_client-0.5.7/dynamics/test.py
│ │┄ Files 3% similar despite different names
│ │ @@ -1,30 +1,27 @@
│ │  import json
│ │  from contextlib import contextmanager
│ │  from itertools import cycle as _cycle
│ │  from unittest.mock import patch
│ │  
│ │  import pytest
│ │ +from requests import HTTPError
│ │  
│ │  from .client import DynamicsClient
│ │  from .typing import Any, Dict, Iterator, List, MethodType, Optional, ResponseType
│ │  
│ │ -
│ │ -__all__ = [
│ │ -    "MockClient",
│ │ -    "BaseMockClient",
│ │ -    "dynamics_cache",
│ │ -    "dynamics_client",
│ │ -]
│ │ +__all__ = ["MockClient", "BaseMockClient", "dynamics_cache", "dynamics_client"]
│ │  
│ │  
│ │  class BaseMockClient:
│ │      def __init__(self, *args, **kwargs):  # pylint: disable=W0613
│ │          with patch("dynamics.client.DynamicsClient.get_token"):
│ │ -            super().__init__("", "", "", "", [])
│ │ +            super().__init__(
│ │ +                "http://dynamics.local/", "http://token.local", "client_id", "client_secret", ["http://scope.local/"]
│ │ +            )
│ │  
│ │          self.__len: int = -1
│ │          self.__default_status: int = 200
│ │          self.__internal: bool = False
│ │          self.__response: ResponseType = None
│ │          self.__responses: Iterator[ResponseType] = _cycle([None])
│ │          self.__status_codes: Iterator[int] = _cycle([self.__default_status])
│ │ @@ -102,23 +99,23 @@
│ │          except TypeError as error:
│ │              raise TypeError("Cannot call 'next_exception' without setting exceptions first") from error
│ │  
│ │      @property
│ │      def current_response(self) -> ResponseType:
│ │          """Not needed if not using the 'dynamics_client.internal'.
│ │  
│ │ -        :return: The last expected reponse from the client.
│ │ +        :return: The last expected response from the client.
│ │                   Tries to correct for some of the internal logic of the
│ │                   client methods, but might not be correct all of the time.
│ │          """
│ │          return self.__response
│ │  
│ │      def _check_length(self, length: int) -> "BaseMockClient":
│ │          if self.__len not in (length, -1):
│ │ -            raise ValueError("Mismaching number of arguments given for MockResponse")
│ │ +            raise ValueError("Mismatching number of arguments given for MockResponse")
│ │          self.__len = length
│ │          return self
│ │  
│ │      @contextmanager
│ │      def _mock_method(self, method: MethodType):
│ │          try:
│ │              self.__response = next(self.__responses)
│ │ @@ -242,7 +239,11 @@
│ │          return self.response
│ │  
│ │      @property
│ │      def text(self) -> str:
│ │          if isinstance(self.response, Exception):
│ │              return str(self.response)
│ │          return json.dumps(self.response)
│ │ +
│ │ +    def raise_for_status(self) -> None:
│ │ +        if isinstance(self.response, HTTPError):
│ │ +            raise self.response
│ │   --- dynamics_client-0.5.6/dynamics/typing.py
│ ├── +++ dynamics_client-0.5.7/dynamics/typing.py
│ │┄ Files 0% similar despite different names
│ │ @@ -1,10 +1,9 @@
│ │  from .enums import FetchXMLOperator
│ │  
│ │ -
│ │  try:
│ │      from typing import (
│ │          TYPE_CHECKING,
│ │          Any,
│ │          Awaitable,
│ │          Callable,
│ │          Dict,
│ │   --- dynamics_client-0.5.6/dynamics/utils.py
│ ├── +++ dynamics_client-0.5.7/dynamics/utils.py
│ │┄ Files 5% similar despite different names
│ │ @@ -1,37 +1,37 @@
│ │  import logging
│ │  import pickle
│ │  import sqlite3
│ │ +import tempfile
│ │  from datetime import datetime, timedelta, timezone
│ │  from functools import wraps
│ │  from pathlib import Path
│ │ +from typing import Union
│ │  from uuid import UUID
│ │  
│ │  from .exceptions import DynamicsException
│ │  
│ │ -
│ │  try:
│ │      from zoneinfo import ZoneInfo
│ │  except ImportError:
│ │      from backports.zoneinfo import ZoneInfo
│ │  
│ │  from .typing import TYPE_CHECKING, Any, Awaitable, Callable, List, Optional, P, T, Type
│ │  
│ │ -
│ │  if TYPE_CHECKING:
│ │      from . import DynamicsClient
│ │  
│ │  
│ │  __all__ = [
│ │      "to_dynamics_date_format",
│ │      "from_dynamics_date_format",
│ │      "sentinel",
│ │      "is_valid_uuid",
│ │      "SQLiteCache",
│ │ -    "cache",
│ │ +    "Singletons",
│ │      "error_simplification_available",
│ │      "to_coroutine",
│ │  ]
│ │  
│ │  
│ │  logger = logging.getLogger(__name__)
│ │  
│ │ @@ -105,15 +105,15 @@
│ │          self.con.close()
│ │          return value
│ │  
│ │      return inner
│ │  
│ │  
│ │  class SQLiteCache:
│ │ -    """Dymmy cache to use if Django's cache is not installed."""
│ │ +    """Dummy cache to use if Django's cache is not installed."""
│ │  
│ │      DEFAULT_TIMEOUT = 300
│ │      DEFAULT_PRAGMA = {
│ │          "mmap_size": 2**26,  # https://www.sqlite.org/pragma.html#pragma_mmap_size
│ │          "cache_size": 8192,  # https://www.sqlite.org/pragma.html#pragma_cache_size
│ │          "wal_autocheckpoint": 1000,  # https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint
│ │          "auto_vacuum": "none",  # https://www.sqlite.org/pragma.html#pragma_auto_vacuum
│ │ @@ -135,17 +135,20 @@
│ │      _delete_sql = "DELETE FROM cache WHERE key = :key"
│ │      _clear_sql = "DELETE FROM cache"
│ │  
│ │      def __init__(self, *, filename: str = "dynamics.cache", path: str = None):
│ │          """Create a cache using sqlite3.
│ │  
│ │          :param filename: Cache file name.
│ │ -        :param path: Path string to the wanted db location. If None, use current directory.
│ │ +        :param path: Path string to the wanted db location. If None, use system temp folder.
│ │          """
│ │  
│ │ +        if path is None:
│ │ +            path = tempfile.gettempdir()
│ │ +
│ │          filepath = filename if path is None else str(Path(path) / filename)
│ │          self.connection_string = f"{filepath}:?mode=memory&cache=shared"
│ │  
│ │          self.con = sqlite3.connect(self.connection_string)
│ │          self.con.execute(self._create_sql)
│ │          self.con.execute(self._create_index_sql)
│ │          self.con.commit()
│ │ @@ -186,18 +189,31 @@
│ │          self.con.execute(self._set_sql, data)
│ │  
│ │      @sqlite_method
│ │      def clear(self) -> None:
│ │          self.con.execute(self._clear_sql)
│ │  
│ │  
│ │ -try:
│ │ -    from django.core.cache import cache
│ │ -except ImportError:
│ │ -    cache = SQLiteCache()
│ │ +class Singletons:
│ │ +    """
│ │ +    A static Singleton interface; any future singleton objects should be included here.
│ │ +    """
│ │ +
│ │ +    _cache: Any = None
│ │ +
│ │ +    @staticmethod
│ │ +    def cache() -> Union[SQLiteCache, Any]:
│ │ +        if Singletons._cache is None:
│ │ +            try:
│ │ +                from django.core.cache import cache
│ │ +            except ImportError:
│ │ +                cache = SQLiteCache()
│ │ +            Singletons._cache = cache
│ │ +
│ │ +        return Singletons._cache
│ │  
│ │  
│ │  def error_simplification_available(func: Callable[P, T]) -> Callable[P, T]:
│ │      """Errors in the function decorated with this decorator can be simplified to just a
│ │      DynamicsException with default error message using the keyword: 'simplify_errors'.
│ │      This is useful if you want to hide error details from frontend users.
│ │   --- dynamics_client-0.5.6/pyproject.toml
│ ├── +++ dynamics_client-0.5.7/pyproject.toml
│ │┄ Files 5% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  [tool.poetry]
│ │  name = "dynamics-client"
│ │ -version = "0.5.6"
│ │ +version = "0.5.7"
│ │  description = "Client for making Web API request from a Microsoft Dynamics 365 Database."
│ │  authors = [
│ │      "Matti Lamppu <lamppu.matti.akseli@gmail.com>",
│ │  ]
│ │  packages = [
│ │      { include = "dynamics" },
│ │  ]
│ │ @@ -18,15 +18,14 @@
│ │      "client"
│ │  ]
│ │  classifiers = [
│ │      "Operating System :: OS Independent",
│ │      "Programming Language :: Python",
│ │      "Programming Language :: Python :: 3",
│ │      "Programming Language :: Python :: 3 :: Only",
│ │ -    "Programming Language :: Python :: 3.7",
│ │      "Programming Language :: Python :: 3.8",
│ │      "Programming Language :: Python :: 3.9",
│ │      "Programming Language :: Python :: 3.10",
│ │      "Programming Language :: Python :: 3.11",
│ │      "Intended Audience :: Developers",
│ │      "Natural Language :: English",
│ │  ]
│ │ @@ -38,69 +37,61 @@
│ │      "tests",
│ │  ]
│ │  
│ │  [tool.poetry.urls]
│ │  "Bug Tracker" = "https://github.com/MrThearMan/dynamics-client/issues"
│ │  
│ │  [tool.poetry.dependencies]
│ │ -python = ">=3.7.2,<4"
│ │ +python = ">=3.8,<4"
│ │  oauthlib = ">=3.1.0"
│ │  requests-oauthlib = ">=1.3.0"
│ │  tzdata = ">=2021.5"
│ │  "backports.zoneinfo" = { version = ">=0.2.1", python = "<3.9" }
│ │  typing-extensions = { version = ">=4.0", python = "<3.9" }
│ │  Django = { version = ">=3.2", optional = true }
│ │  djangorestframework = { version = ">=3.12", optional = true }
│ │  
│ │  [tool.poetry.group.test.dependencies]
│ │ -pytest = "7.2.0"
│ │ +pytest = "7.2.1"
│ │  coverage = "6.5.0"
│ │  pytest-asyncio = "0.20.3"
│ │ -pre-commit = "2.20.0"
│ │ -tox = "3.25.1"
│ │ -tox-gh-actions = "2.9.1"
│ │ +pre-commit = "3.0.1"
│ │ +tox = "4.4.2"
│ │ +tox-gh-actions = "3.0.0"
│ │  coveralls = "3.3.1"
│ │  
│ │  [tool.poetry.group.docs.dependencies]
│ │  mkdocs = "1.4.2"
│ │ -pymdown-extensions = "9.9"
│ │ +pymdown-extensions = "9.9.2"
│ │  mkdocs-mermaid2-plugin = "0.6.0"
│ │  
│ │  [tool.poetry.group.lint.dependencies]
│ │  mypy = "0.991"
│ │  
│ │  [tool.poetry.extras]
│ │  django = ["Django", "djangorestframework"]
│ │  
│ │  [tool.black]
│ │  line-length = 120
│ │  
│ │ -[tool.isort]
│ │ -profile = "black"
│ │ -line_length = 120
│ │ -skip_gitignore = "True"
│ │ -lines_after_imports = 2
│ │ -
│ │  [tool.ruff]
│ │  fix = true
│ │  line-length = 120
│ │  exclude = [
│ │      "tests/*",
│ │  ]
│ │  select = [
│ │      "F",  # pyflakes
│ │      "E",  # pycodestyle errors
│ │ -    # "D",  # pydocstyle
│ │ -    # "N",  # pep8-naming
│ │ +    "I",  # isort
│ │      "S",  # flake8-bandit
│ │      "C",  # flake8-comprehensions
│ │      "B",  # flake8-bugbear
│ │      "T",  # flake8-print
│ │      "W",  # pycodestyle warnings
│ │ -    # "ANN",  # flake8-annotations
│ │  ]
│ │  ignore = [
│ │  ]
│ │  
│ │  [tool.mypy]
│ │  python_version = "3.11"
│ │  warn_return_any = "True"
│ │ @@ -124,27 +115,26 @@
│ │  
│ │  [tool.pytest.ini_options]
│ │  addopts = "-vv -s --log-cli-level=INFO"
│ │  
│ │  [tool.tox]
│ │  legacy_tox_ini = """
│ │  [tox]
│ │ -envlist = py{37, 38, 39, 310, 311}
│ │ +envlist = py{38, 39, 310, 311}
│ │  isolated_build = true
│ │  
│ │  [gh-actions]
│ │  python =
│ │ -    3.7: py37
│ │      3.8: py38
│ │      3.9: py39
│ │      3.10: py310
│ │      3.11: py311
│ │  
│ │  [testenv]
│ │ -whitelist_externals =
│ │ +allowlist_externals =
│ │      poetry
│ │  setenv =
│ │      PYTHONPATH = {toxinidir}
│ │  commands =
│ │      poetry install
│ │      poetry run coverage run -m pytest -vv -s --log-cli-level=INFO
│ │  """
│ │   --- dynamics_client-0.5.6/setup.py
│ ├── +++ dynamics_client-0.5.7/setup.py
│ │┄ Files 1% similar despite different names
│ │ @@ -13,24 +13,24 @@
│ │  extras_require = \
│ │  {':python_version < "3.9"': ['backports.zoneinfo>=0.2.1',
│ │                               'typing-extensions>=4.0'],
│ │   'django': ['Django>=3.2', 'djangorestframework>=3.12']}
│ │  
│ │  setup_kwargs = {
│ │      'name': 'dynamics-client',
│ │ -    'version': '0.5.6',
│ │ +    'version': '0.5.7',
│ │      'description': 'Client for making Web API request from a Microsoft Dynamics 365 Database.',
│ │      'long_description': '# Dynamics Web API Client\n\n[![Coverage Status][coverage-badge]][coverage]\n[![GitHub Workflow Status][status-badge]][status]\n[![PyPI][pypi-badge]][pypi]\n[![GitHub][licence-badge]][licence]\n[![GitHub Last Commit][repo-badge]][repo]\n[![GitHub Issues][issues-badge]][issues]\n[![Downloads][downloads-badge]][pypi]\n[![Python Version][version-badge]][pypi]\n\n```shell\npip install dynamics-client\n```\n\n---\n\n**Documentation**: [https://mrthearman.github.io/dynamics-client/](https://mrthearman.github.io/dynamics-client/)\n\n**Source Code**: [https://github.com/MrThearMan/dynamics-client/](https://github.com/MrThearMan/dynamics-client/)\n\n---\n\nClient for making Web API request from a Microsoft Dynamics 365 Database.\n\nYou should also read the [Dynamics Web API Reference Docs][ref-docs]:\n\n\n## Basic usage:\n\n```python\nfrom dynamics import DynamicsClient, ftr\n\n# Init the client:\nclient = DynamicsClient(...)\n\n### Example GET request:\n\nclient.table = "accounts"\n\n# Get only these columns for the account.\nclient.select = ["accountid", "name"]\n\n# Filter to only the accounts that have been created on or after the\n# given ISO date string, AND that have 200 or more employees.\nclient.filter = [\n    ftr.on_or_after("createdon", "2020-01-01T00:00:00Z"),\n    ftr.ge("numberofemployees", 200),\n]\n\n# Expand to the contacts (collection-values navigation property)\n# on the account that have \'gmail.com\' in their email address 1 OR 2.\n# Get only the \'firstname\', \'lastname\' and \'mobilephone\' columns for these contacts.\n# Also expand the primary contact (single-valued navigation property).\n# Get only the \'emailaddress1\' column for the primary contact.\nclient.expand = {\n    "contact_customer_accounts": {\n        "select": ["firstname", "lastname", "mobilephone"],\n        "filter": {\n            ftr.contains("emailaddress1", "gmail.com"),\n            ftr.contains("emailaddress2", "gmail.com"),\n        }\n    },\n    "primarycontactid": {\n        "select": ["emailaddress1"],\n    },\n}\n\nresult = client.get()\n\n# [\n#     {\n#         "accountid": ...,\n#         "name": ...,\n#         "contact_customer_accounts": [\n#             {\n#                 "contactid": ...,  # id field is always given\n#                 "firstname": ...,\n#                 "lastname": ...,\n#                 "mobilephone": ...\n#             },\n#             ...\n#         ],\n#         "primarycontactid": {\n#             "contactid": ...,\n#             "emailaddress1": ...\n#         }\n#     },\n#     ...\n# ]\n\n### Example POST request\n\n# IMPORTANT!!!\nclient.reset_query()\n\nclient.table = "contacts"\n\n# Get only these columns from the created contact\nclient.select = ["firstname", "lastname", "emailaddress1"]\n\n# The data to create the contact with. \'@odata.bind\' is used to link\n# the contact to the given navigation property.\naccountid = ...\ndata = {\n    "firstname": ...,\n    "lastname": ...,\n    "emailaddress1": ...,\n    "parentcustomerid_account@odata.bind": f"/accounts({accountid})"\n}\n\nresult = client.post(data=data)\n\n# {\n#     "contactid": ...,\n#     "firstname": ...,\n#     "lastname": ...,\n#     "emailaddress1": ...\n# }\n\n\n### Example PATCH request\n\nclient.reset_query()\n\nclient.table = "contacts"\nclient.row_id = result["contactid"]\n\ndata = {\n    "firstname": ...,\n    "lastname": ...,\n}\n\nresult = client.patch(data=data)\n\n# Return all rows on the updated contact,\n# since no select statement was given\n#\n# {\n#     ...\n#     "contactid": ...,\n#     "firstname": ...,\n#     "lastname": ...,\n#     ...\n# }\n\n\n### Example DELETE request\n\nclient.reset_query()\n\nclient.table = "contacts"\nclient.row_id = result["contactid"]\n\nclient.delete()\n```\n\n\n[ref-docs]: https://docs.microsoft.com/en-us/powerapps/developer/data-platform/webapi/query-data-web-api\n\n[coverage-badge]: https://coveralls.io/repos/github/MrThearMan/dynamics-client/badge.svg?branch=main\n[status-badge]: https://img.shields.io/github/actions/workflow/status/MrThearMan/dynamics-client/test.yml?branch=main\n[pypi-badge]: https://img.shields.io/pypi/v/dynamics-client\n[licence-badge]: https://img.shields.io/github/license/MrThearMan/dynamics-client\n[repo-badge]: https://img.shields.io/github/last-commit/MrThearMan/dynamics-client\n[issues-badge]: https://img.shields.io/github/issues-raw/MrThearMan/dynamics-client\n[version-badge]: https://img.shields.io/pypi/pyversions/dynamics-client\n[downloads-badge]: https://img.shields.io/pypi/dm/dynamics-client\n\n[coverage]: https://coveralls.io/github/MrThearMan/dynamics-client?branch=main\n[status]: https://github.com/MrThearMan/dynamics-client/actions/workflows/test.yml\n[pypi]: https://pypi.org/project/dynamics-client\n[licence]: https://github.com/MrThearMan/dynamics-client/blob/main/LICENSE\n[repo]: https://github.com/MrThearMan/dynamics-client/commits/main\n[issues]: https://github.com/MrThearMan/dynamics-client/issues\n',
│ │      'author': 'Matti Lamppu',
│ │      'author_email': 'lamppu.matti.akseli@gmail.com',
│ │      'maintainer': 'None',
│ │      'maintainer_email': 'None',
│ │      'url': 'https://github.com/MrThearMan/dynamics-client/',
│ │      'packages': packages,
│ │      'package_data': package_data,
│ │      'install_requires': install_requires,
│ │      'extras_require': extras_require,
│ │ -    'python_requires': '>=3.7.2,<4',
│ │ +    'python_requires': '>=3.8,<4',
│ │  }
│ │  
│ │  
│ │  setup(**setup_kwargs)
│ │   --- dynamics_client-0.5.6/PKG-INFO
│ ├── +++ dynamics_client-0.5.7/PKG-INFO
│ │┄ Files 2% similar despite different names
│ │ @@ -1,32 +1,31 @@
│ │  Metadata-Version: 2.1
│ │  Name: dynamics-client
│ │ -Version: 0.5.6
│ │ +Version: 0.5.7
│ │  Summary: Client for making Web API request from a Microsoft Dynamics 365 Database.
│ │  Home-page: https://github.com/MrThearMan/dynamics-client/
│ │  License: MIT
│ │  Keywords: Microsoft,Dynamics,client
│ │  Author: Matti Lamppu
│ │  Author-email: lamppu.matti.akseli@gmail.com
│ │ -Requires-Python: >=3.7.2,<4
│ │ +Requires-Python: >=3.8,<4
│ │  Classifier: Intended Audience :: Developers
│ │  Classifier: License :: OSI Approved :: MIT License
│ │  Classifier: Natural Language :: English
│ │  Classifier: Operating System :: OS Independent
│ │  Classifier: Programming Language :: Python
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: Programming Language :: Python :: 3.8
│ │  Classifier: Programming Language :: Python :: 3.9
│ │  Classifier: Programming Language :: Python :: 3.10
│ │  Classifier: Programming Language :: Python :: 3.11
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: Programming Language :: Python :: 3 :: Only
│ │  Classifier: Programming Language :: Python :: 3.10
│ │  Classifier: Programming Language :: Python :: 3.11
│ │ -Classifier: Programming Language :: Python :: 3.7
│ │  Classifier: Programming Language :: Python :: 3.8
│ │  Classifier: Programming Language :: Python :: 3.9
│ │  Provides-Extra: django
│ │  Requires-Dist: Django (>=3.2) ; extra == "django"
│ │  Requires-Dist: backports.zoneinfo (>=0.2.1) ; python_version < "3.9"
│ │  Requires-Dist: djangorestframework (>=3.12) ; extra == "django"
│ │  Requires-Dist: oauthlib (>=3.1.0)
