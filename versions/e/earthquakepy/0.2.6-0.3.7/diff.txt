--- tmp/earthquakepy-0.2.6.tar.gz
+++ tmp/earthquakepy-0.3.7.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "earthquakepy-0.2.6.tar", last modified: Tue Dec  6 15:15:28 2022, max compression
│ +gzip compressed data, was "earthquakepy-0.3.7.tar", last modified: Fri Apr  7 09:37:36 2023, max compression
│   --- earthquakepy-0.2.6.tar
├── +++ earthquakepy-0.3.7.tar
│ ├── file list
│ │ @@ -1,22 +1,23 @@
│ │ -drwxrwxr-x   0 digvijay  (1000) digvijay  (1000)        0 2022-12-06 15:15:28.400995 earthquakepy-0.2.6/
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      803 2022-12-06 15:15:28.400995 earthquakepy-0.2.6/PKG-INFO
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)       90 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/README.rst
│ │ -drwxrwxr-x   0 digvijay  (1000) digvijay  (1000)        0 2022-12-06 15:15:28.396995 earthquakepy-0.2.6/earthquakepy/
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      192 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/__init__.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     4334 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/ims.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     3779 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/multidof.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     2968 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/opensees_classes.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     1591 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/opensees_helper.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      322 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/responseMdof.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     1295 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/responseSdof.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     6882 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/singledof.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)    17897 2022-12-06 15:06:41.000000 earthquakepy-0.2.6/earthquakepy/timeseries.py
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)     5194 2022-12-06 07:40:28.000000 earthquakepy-0.2.6/earthquakepy/tsReaders.py
│ │ -drwxrwxr-x   0 digvijay  (1000) digvijay  (1000)        0 2022-12-06 15:15:28.400995 earthquakepy-0.2.6/earthquakepy.egg-info/
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      803 2022-12-06 15:15:28.000000 earthquakepy-0.2.6/earthquakepy.egg-info/PKG-INFO
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      470 2022-12-06 15:15:28.000000 earthquakepy-0.2.6/earthquakepy.egg-info/SOURCES.txt
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)        1 2022-12-06 15:15:28.000000 earthquakepy-0.2.6/earthquakepy.egg-info/dependency_links.txt
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)       23 2022-12-06 15:15:28.000000 earthquakepy-0.2.6/earthquakepy.egg-info/requires.txt
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)       13 2022-12-06 15:15:28.000000 earthquakepy-0.2.6/earthquakepy.egg-info/top_level.txt
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)       38 2022-12-06 15:15:28.400995 earthquakepy-0.2.6/setup.cfg
│ │ --rw-rw-r--   0 digvijay  (1000) digvijay  (1000)      984 2022-12-06 15:13:23.000000 earthquakepy-0.2.6/setup.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 09:37:36.394833 earthquakepy-0.3.7/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    35149 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/LICENSE
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2472 2023-04-07 09:37:36.394833 earthquakepy-0.3.7/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       90 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/README.rst
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 09:37:36.394833 earthquakepy-0.3.7/earthquakepy/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      192 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4334 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/ims.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3779 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/multidof.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2968 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/opensees_classes.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1591 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/opensees_helper.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      322 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/responseMdof.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1295 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/responseSdof.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8800 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/singledof.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    20957 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/timeseries.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6549 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/earthquakepy/tsReaders.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 09:37:36.394833 earthquakepy-0.3.7/earthquakepy.egg-info/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2472 2023-04-07 09:37:36.000000 earthquakepy-0.3.7/earthquakepy.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      478 2023-04-07 09:37:36.000000 earthquakepy-0.3.7/earthquakepy.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 09:37:36.000000 earthquakepy-0.3.7/earthquakepy.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       23 2023-04-07 09:37:36.000000 earthquakepy-0.3.7/earthquakepy.egg-info/requires.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       13 2023-04-07 09:37:36.000000 earthquakepy-0.3.7/earthquakepy.egg-info/top_level.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 09:37:36.394833 earthquakepy-0.3.7/setup.cfg
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-04-07 09:37:25.000000 earthquakepy-0.3.7/setup.py
│ │   --- earthquakepy-0.2.6/earthquakepy/ims.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/ims.py
│ │┄ Files identical despite different names
│ │   --- earthquakepy-0.2.6/earthquakepy/multidof.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/multidof.py
│ │┄ Files identical despite different names
│ │   --- earthquakepy-0.2.6/earthquakepy/opensees_classes.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/opensees_classes.py
│ │┄ Files identical despite different names
│ │   --- earthquakepy-0.2.6/earthquakepy/opensees_helper.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/opensees_helper.py
│ │┄ Files identical despite different names
│ │   --- earthquakepy-0.2.6/earthquakepy/responseSdof.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/responseSdof.py
│ │┄ Files identical despite different names
│ │   --- earthquakepy-0.2.6/earthquakepy/singledof.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/singledof.py
│ │┄ Files 16% similar despite different names
│ │ @@ -1,10 +1,11 @@
│ │  import numpy as np
│ │  from scipy.integrate import solve_ivp
│ │  from scipy.integrate._ivp.ivp import OdeResult
│ │ +from scipy.fftpack import ifft, fft, fftfreq
│ │  import matplotlib.pyplot as plt
│ │  
│ │  
│ │  class Sdof:
│ │      """
│ │      Class for single-degree-of-freedom system
│ │      Parameters :
│ │ @@ -62,16 +63,80 @@
│ │          A = np.array([[0, 1], [-k / m, -c / m]])
│ │          x = np.array(y)
│ │          f = np.array([[0.0], [ts.get_y(t) / m]])
│ │          dy = np.matmul(A, x) + f
│ │  
│ │          return dy
│ │  
│ │ -    def get_response(self, ts, tsType="baseExcitation", **kwargs):
│ │ +    def get_impulse_response(self, w=np.arange(0.1, 100, 0.1)):
│ │ +        """
│ │ +        Calculate the impulse response function G(w).
│ │ +        
│ │ +        Parameters
│ │ +        ----------
│ │ +        w (list of floats): Natural frequencies of interest in rad/s
│ │ +
│ │ +        Returns
│ │ +        -------
│ │ +        1D array of G(w) 
│ │ +        """
│ │ +        G = 1 / (2*np.pi * (self.wn**2 + 2*self.xi*w*self.wn*complex(0, 1) - w**2))
│ │ +
│ │ +        return G
│ │ +
│ │ +    def get_frequency_response(self, w=np.arange(0.1, 100.0, 0.1)):
│ │ +        r"""
│ │ +        Calculate the frequency response function H(w).
│ │ +        
│ │ +        Parameters
│ │ +        ----------
│ │ +        w (list of floats): Natural frequencies of interest in rad/s
│ │ +
│ │ +        Returns
│ │ +        -------
│ │ +        1D array of H(w) = 2 * np.pi * G(w) 
│ │ +        """
│ │ +        return 2 * np.pi * self.get_impulse_response(w=w)
│ │ +
│ │ +    def get_response_frequency_domain(self, ts, tsType="baseExcitation", **kwargs):
│ │ +        r"""
│ │ +        Calculate the sdof system response in frequency domain.
│ │ +        
│ │ +        Parameters
│ │ +        ----------
│ │ +        ts: (timeseries object) timeseries defining loading/base excitation
│ │ +
│ │ +        tsType: (string) "baseExcitation" or "force"
│ │ +
│ │ +        Returns
│ │ +        -------
│ │ +        tuple of (t, x, v, a)
│ │          """
│ │ +        if tsType == "baseExcitation":
│ │ +            f = -self.m * ts.y
│ │ +        elif tsType == "force":
│ │ +            f = ts.y
│ │ +        else:
│ │ +            raise Exception("Incorrect timeseries type given. It can be either 'baseExcitation' or 'force'.")
│ │ +
│ │ +        N = len(f)
│ │ +        dt = ts.dt  # sampling interval
│ │ +        F = fft(f)
│ │ +        freq = fftfreq(N, dt)  # [:N//2]
│ │ +
│ │ +        H = self.get_frequency_response(w=2*np.pi*freq)
│ │ +
│ │ +        X = H * F
│ │ +        V = 2*np.pi*freq * X  # Should it be multiplied by complex(0, 1)?
│ │ +        A = 2*np.pi*freq * V  # Should it be multiplied by complex(0, 1)?
│ │ +
│ │ +        return ts.t, ifft(X), ifft(V), ifft(A)
│ │ +
│ │ +    def get_response(self, ts, tsType="baseExcitation", **kwargs):
│ │ +        r"""
│ │          Wrapper around solve_ivp module from scipy.integrate. It supports all the arguments supported by solve_ivp.
│ │  
│ │          Parameters
│ │          ----------
│ │          ts: (timeseries object) timeseries defining loading/base excitation
│ │  
│ │          tsType: (string) "baseExcitation" or "force"
│ │ @@ -85,30 +150,29 @@
│ │          By default the solution will be obtained for duration = 2 * (ts.t duration). This can be changed using t_span argument. Default method : BDF.
│ │          """
│ │          if tsType == "baseExcitation":
│ │              f = -self.m * ts.y
│ │          elif tsType == "force":
│ │              f = ts.y
│ │          else:
│ │ -            raise Exception("Incorrect timeseries type given")
│ │ +            raise Exception("Incorrect timeseries type given. It can be either 'baseExcitation' or 'force'.")
│ │  
│ │          defaultArgs = {
│ │              "t_span": (ts.t[0], ts.t[-1] * 2),
│ │              "y0": [0.0, 0.0],
│ │              "method": "BDF",
│ │              "t_eval": None,
│ │              "dense_output": False,
│ │              "events": None,
│ │              "vectorized": True,
│ │              "args": (ts, 1), # additional element 1 required in tuple due to bug in solve_ivp with only one argument
│ │              "jac": np.array([[0, 1], [-self.k / self.m, -self.c / self.m]]),
│ │          }
│ │          kwargs = {**defaultArgs, **kwargs}
│ │  
│ │ -        # r = solve_ivp(self.sdof_grad, **kwargs)
│ │          r = solve_ivp(self.sdof_grad, **kwargs)
│ │          m, c, k = self.m, self.c, self.k
│ │          fv = np.interp(r.t, ts.t, f)
│ │          acc = 1 / m * (fv - c * r.y[1] - k * r.y[0])
│ │          return SdofResponseTimeSeries(r, acc)
│ │   --- earthquakepy-0.2.6/earthquakepy/timeseries.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/timeseries.py
│ │┄ Files 4% similar despite different names
│ │ @@ -1,119 +1,130 @@
│ │ +"""Define various classes to store timeseries and similar objects."""
│ │  import numpy as np
│ │  from scipy.integrate import trapz, cumtrapz
│ │  import matplotlib.pyplot as plt
│ │ -import matplotlib as mpl
│ │ -from .singledof import Sdof, SdofNL
│ │ +# import matplotlib as mpl
│ │ +from .singledof import Sdof  # , SdofNL
│ │  from scipy.fftpack import fft, fftfreq
│ │  
│ │ +np.set_printoptions(threshold=50)
│ │ +
│ │  
│ │  class TimeSeries:
│ │      """
│ │ -    TimeSeries object class. Defines time series
│ │ +    TimeSeries class. Defines time series. TimeSeries is a basic data type in the module.
│ │ +
│ │ +    Most of the calculations need a timeseries to be defined as a TimeSeries object.
│ │      """
│ │  
│ │      def __init__(self, t, y):
│ │          """
│ │ +        Define TimeSeries object.
│ │ +
│ │          Parameters
│ │          ----------
│ │          t: (scalar or 1D array) time step (if scalar) or time axis (if 1D array)
│ │          y: (1D array) ordinates
│ │          """
│ │          if (type(t) == float) or (type(t) == int):
│ │              t = np.arange(t, len(y) * t + 0.1 * t, t)
│ │          self.t = t
│ │          self.y = y
│ │ -        self.npts = len(t)
│ │ -        self.dt = t[1] - t[0]
│ │ +        self.npts = len(self.t)
│ │ +        self.dt = self.t[1] - self.t[0]
│ │ +        self.component = " "
│ │ +        self.duration = self.t[-1]
│ │ +        self.eqDate = " "
│ │ +        self.eqName = " "
│ │ +        self.filepath = " "
│ │  
│ │      def __repr__(self):
│ │ -        np.set_printoptions(threshold=50)
│ │          a = ""
│ │          for key, val in vars(self).items():
│ │              a += "{:>10s}: {}\n".format(key, val)
│ │          return a
│ │  
│ │      def set_tunit(self, unit):
│ │ -        """
│ │ -        Set unit for T(time) coordinates. Unit should be a string.
│ │ -        """
│ │ +        """Set unit for T(time) coordinates. Unit should be a string."""
│ │          self.tunit = unit
│ │  
│ │      def set_yunit(self, unit):
│ │ -        """
│ │ -        Set unit for y coordinates. Unit should be a string.
│ │ -        """
│ │ +        """Set unit for y coordinates. Unit should be a string."""
│ │          self.yunit = unit
│ │  
│ │      def set_t(self, coords):
│ │ -        """
│ │ -        Set T(time) coordinates. Should be a list or numpy array (1D)
│ │ -        """
│ │ +        """Set T(time) coordinates. Should be a list or numpy array (1D)."""
│ │          self.t = coords
│ │  
│ │      def set_eqname(self, name):
│ │ -        """Set earthquake name"""
│ │ +        """Set earthquake name."""
│ │          self.eqName = name
│ │  
│ │      def set_eqdate(self, date):
│ │ -        """Set earthquake date"""
│ │ +        """Set earthquake date."""
│ │          self.eqDate = date
│ │  
│ │      def set_station(self, station):
│ │ -        """Recording station"""
│ │ +        """Set recording station."""
│ │          self.station = station
│ │  
│ │      def set_component(self, comp):
│ │ -        """Directional component of record"""
│ │ +        """Directional component of record."""
│ │          self.component = comp
│ │  
│ │      def set_dt(self, dt):
│ │ -        """Time step between data points"""
│ │ +        """Time step between data points."""
│ │          self.dt = dt
│ │  
│ │      def set_npts(self, npts):
│ │ -        """Total number of points in the record"""
│ │ +        """Total number of points in the record."""
│ │          self.npts = npts
│ │  
│ │      def set_duration(self, duration):
│ │ -        """Total duration of the record in seconds"""
│ │ +        """Total duration of the record in seconds."""
│ │          self.duration = duration
│ │  
│ │      def set_filepath(self, filepath):
│ │ -        """Record filepath"""
│ │ +        """Set record filepath."""
│ │          self.filepath = filepath
│ │  
│ │      def plot(self, log=False, **kwargs):
│ │          """
│ │ -        Method plots time history of timeseries object. It accepts all the arguments that matplotlib.pyplot.subplots recognizes.
│ │ +        Plot time history of timeseries object.
│ │ +
│ │ +        It accepts all the arguments that matplotlib.pyplot.subplots recognize.
│ │ +        Parameters
│ │ +        ----------
│ │ +        log (boolean): Use log scale for plotting (default *False*).
│ │  
│ │          Returns
│ │          -------
│ │          Matplotlib Figure Object
│ │  
│ │          """
│ │          fig, ax = plt.subplots(**kwargs)
│ │ -        ax.plot(self.t, self.y, color = 'k', label = str(self.eqName)+ '_' + str(self.component))
│ │ +        ax.plot(self.t, self.y, color='k', label=str(self.eqName) + '_' + str(self.component))
│ │          if hasattr(self, "tunit"):
│ │              ax.set_xlabel("t ({})".format(self.tunit))
│ │          if hasattr(self, "yunit"):
│ │              ax.set_ylabel(str(self.yunit))
│ │          if log:
│ │              ax.set_xscale("log")
│ │          ax.set_xlim(left=0)
│ │          ax.legend()
│ │          # plt.show()
│ │          return fig
│ │  
│ │      def get_y(self, t):
│ │ +        """Perform 1D interpolation."""
│ │          return np.interp(t, self.t, self.y)
│ │  
│ │ -    def get_response_spectra(self, T=np.arange(0.1, 20.01, 1.0), xi=0.05):
│ │ +    def get_response_spectra_frequency_domain(self, T=np.arange(0.1, 100.001, 0.1), xi=0.05):
│ │          """
│ │ -        Calculates linear elastic response spectra associated with the timeseries.
│ │ +        Calculate linear elastic response spectra associated with the timeseries.
│ │  
│ │          Parameters
│ │          ----------
│ │          T: (1D array of floats) Periods corresponding to spectrum width
│ │          xi: (float) damping ratio
│ │  
│ │          Returns
│ │ @@ -122,68 +133,80 @@
│ │          """
│ │          specLength = len(T)
│ │          Sd = np.empty(specLength)
│ │          Sv = np.empty(specLength)
│ │          Sa = np.empty(specLength)
│ │          for i in range(specLength):
│ │              s = Sdof(T=T[i], xi=xi)
│ │ -            r = s.get_response(self, tsType="baseExcitation")
│ │ -            D = np.max(np.abs(r.y[0]))
│ │ -            V = np.max(np.abs(r.y[1]))
│ │ -            A = np.max(np.abs(r.acc))
│ │ -            Sd[i] = D
│ │ -            Sv[i] = V
│ │ -            Sa[i] = A
│ │ -        return ResponseSpectrum(T, Sd, Sv, Sa)
│ │ +            t, d, v, a = s.get_response_frequency_domain(self, tsType="baseExcitation")
│ │ +            Sd[i] = np.max(np.abs(np.real(d)))
│ │ +            Sv[i] = np.max(np.abs(np.real(v)))
│ │ +            Sa[i] = np.max(np.abs(np.real(a)))
│ │ +        return ResponseSpectra(T, Sd, Sv, Sa)
│ │  
│ │ -    def get_fourier_spectrum(self):
│ │ +    def get_response_spectra(self, T=np.arange(0.1, 100.001, 0.1), xi=0.05):
│ │          """
│ │ -        Computes fourier spectrum associated with the time series
│ │ +        Calculate linear elastic response spectra associated with the timeseries.
│ │ +
│ │ +        Parameters
│ │ +        ----------
│ │ +        T: (1D array of floats) Periods corresponding to spectrum width
│ │ +        xi: (float) damping ratio
│ │ +
│ │ +        Returns
│ │ +        -------
│ │ +        ResponseSpectrum object with T, Sd, Sv, Sa as attributes.
│ │          """
│ │ +        return self.get_response_spectra_frequency_domain(T=T, xi=xi)
│ │ +
│ │ +    def get_fourier_spectrum(self):
│ │ +        """Compute fourier spectrum associated with the time series."""
│ │          N = self.npts
│ │          T = self.dt  # sampling interval
│ │          yf = fft(self.y)
│ │          # FAmp = np.abs(yf[0:N//2])
│ │          freq = fftfreq(N, T)  # [:N//2]
│ │          return FourierSpectrum(freq, yf, N)
│ │  
│ │      def get_power_spectrum(self):
│ │ -        """
│ │ -        Computes power spectrum associated with the time series
│ │ -        """
│ │ -        N = self.npts
│ │ +        """Compute power spectrum associated with the time series."""
│ │ +        dt = self.dt
│ │          fourier_spectrum = self.get_fourier_spectrum()
│ │          freq = fourier_spectrum.frequencies
│ │ -        df = freq[1] - freq[0]
│ │ -        powerAmp = 2.0 / df * fourier_spectrum.amplitude**2
│ │ -        return PowerSpectrum(freq, powerAmp, N)
│ │ +        # Power amplitude is multiplied by 2 to consider power from positive and negative frequencies
│ │ +        # The frequency 0 and nyquist apprear only once so divided later by 2.
│ │ +        powerAmp = 2 * dt / self.npts * np.abs(fourier_spectrum.amplitude)**2
│ │ +        powerAmp[0] = powerAmp[0]/2
│ │ +        idx = np.argmax(powerAmp)
│ │ +        powerAmp[idx] = powerAmp[idx]/2
│ │ +        return PowerSpectrum(freq, powerAmp, self.npts)
│ │  
│ │      def get_mean_period(self):
│ │          """
│ │ -        Computes the simplified frequency content characterisation parameter according to  Rathje et al. [1998]
│ │ +        Compute the simplified frequency content characterisation parameter according to  Rathje et al. [1998].
│ │  
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Mean period
│ │  
│ │          """
│ │          fourier_spectrum = self.get_fourier_spectrum()
│ │          freq = fourier_spectrum.frequencies
│ │          FAmp = fourier_spectrum.amplitude
│ │ -        boolArr = (freq > 0.25) & (freq < 20)
│ │ +        boolArr = (freq >= 0.25) & (freq <= 20)
│ │          n = FAmp[boolArr] ** 2 / freq[boolArr]
│ │          n = n.sum()
│ │          d = FAmp[boolArr] ** 2
│ │          d = d.sum()
│ │          return n / d
│ │  
│ │      def get_mean_frequency(self):
│ │          """
│ │ -        Computes the simplified frequency content characterisation parameter according to  Schnabel [1973]
│ │ +        Compute the simplified frequency content characterisation parameter according to  Schnabel [1973].
│ │  
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Mean square frequency
│ │  
│ │          """
│ │ @@ -195,15 +218,15 @@
│ │          n = n.sum()
│ │          d = FAmp[boolArr] ** 2
│ │          d = d.sum()
│ │          return n / d
│ │  
│ │      def get_epsilon(self):
│ │          """
│ │ -        Computes the dimensionless frequency indicator, epsilon as given by Clough and Penzien
│ │ +        Compute the dimensionless frequency indicator, epsilon as given by Clough and Penzien.
│ │  
│ │          Returns
│ │          -------
│ │          Scalar
│ │  
│ │          """
│ │          from scipy.integrate import trapz
│ │ @@ -215,22 +238,22 @@
│ │          m2 = trapz(powerAmp * freq**2, freq)
│ │          m4 = trapz(powerAmp * freq**4, freq)
│ │          eps = np.sqrt(1 - m2**2 / (m0 * m4))
│ │          return eps
│ │  
│ │      def get_arias_intensity(self, g=False):
│ │          """
│ │ -        Computes arias intensity:
│ │ +        Compute arias intensity.
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │ -        
│ │ +
│ │          Returns
│ │          -------
│ │          array like:
│ │              Arias intensity time series
│ │  
│ │          """
│ │          acc = self.y
│ │ @@ -239,14 +262,15 @@
│ │              acc = acc * 9.81
│ │  
│ │          iaSeries = np.pi / (2 * 9.81) * cumtrapz(acc**2, dx=dt, initial=0)
│ │          return iaSeries
│ │  
│ │      def get_total_arias(self, g=False):
│ │          """
│ │ +        Calculate total arias intensity of the given signal.
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │  
│ │ @@ -262,16 +286,15 @@
│ │              acc = acc * 9.81
│ │  
│ │          ia = np.pi / (2 * 9.81) * trapz(acc**2, dx=dt)
│ │          return ia
│ │  
│ │      def get_sig_duration(self, g=False, start=0.05, stop=0.95):
│ │          """
│ │ -
│ │ -        Computes significant duration as portion of ground motion encompassing 5% to 95% of total arias intensity
│ │ +        Compute significant duration as portion of ground motion encompassing 5% to 95% of total arias intensity.
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │  
│ │ @@ -290,36 +313,36 @@
│ │          dt = self.dt
│ │          cumIa = self.get_arias_intensity(g=g)
│ │          index = np.where((cumIa > start * cumIa[-1]) & (cumIa < stop * cumIa[-1]))
│ │          return index[0][-1] * dt - index[0][0] * dt
│ │  
│ │      def get_destructive_potential(self, g=False):
│ │          """
│ │ -        Computes destructiveness potential according to Araya and Sargoni (1984)
│ │ +        Compute destructiveness potential according to Araya and Sargoni (1984).
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │ -        
│ │ +
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Destructiveness potential
│ │  
│ │          """
│ │          acc = self.y
│ │          ia = self.get_total_arias(g=True)
│ │          u0 = len(np.where(np.diff(np.sign(acc)))[0])/self.duration
│ │          return ia / u0**2
│ │  
│ │      def get_cum_abs_vel(self, g=False):
│ │          """
│ │ -        Computes cummulative absolute velocity
│ │ +        Compute cummulative absolute velocity.
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │  
│ │ @@ -334,141 +357,165 @@
│ │          if g:
│ │              acc = acc * 9.81
│ │          acc = np.absolute(acc)
│ │          return trapz(acc, dx=dt)
│ │  
│ │      def get_cum_abs_disp(self):
│ │          """
│ │ -        Computes Cummulative Absolute Displacement
│ │ +        Compute Cummulative Absolute Displacement.
│ │  
│ │          Note
│ │              Please make sure to use velocity time series as input to compute cummulative absolute displacement.
│ │  
│ │          Parameters
│ │          ----------
│ │          None
│ │ -        
│ │ +
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Cummulative Absolute Velocity
│ │  
│ │          """
│ │          vel = self.y
│ │          dt = self.dt
│ │          vel = np.absolute(vel)
│ │          return trapz(vel, dx=dt)
│ │  
│ │      def get_specific_energy(self):
│ │          """
│ │ -
│ │ -        Computes specific energy density
│ │ +        Compute specific energy density.
│ │  
│ │          Note
│ │              Please use velocity time series as input to compute specific energy density.
│ │  
│ │          Parameters
│ │          ----------
│ │          None
│ │ -        
│ │ +
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Specify Energy Density
│ │  
│ │          """
│ │          vel = self.y
│ │          dt = self.dt
│ │          return trapz(vel**2, dx=dt)
│ │  
│ │      def get_rms(self, g=False):
│ │          """
│ │ -
│ │ -        Root-mean-square value of acceleration/velocity/displacement time series
│ │ +        Root-mean-square value of acceleration/velocity/displacement time series.
│ │  
│ │          Parameters
│ │          ----------
│ │          g: Bool, optional
│ │              g=True multiplies acceleration values with g=9.81 m/sec^2.
│ │              Used when acceleration values in 'g' units are to be converted into 'm/sec^2'
│ │  
│ │ -        
│ │          Returns
│ │          -------
│ │          Scalar:
│ │              Root-mean-square value of time series values
│ │ -
│ │ -
│ │          """
│ │          val = self.y
│ │          total_time = self.duration
│ │          dt = self.dt
│ │          return np.sqrt(trapz(val**2, dx=dt) * total_time**-1)
│ │  
│ │      def get_diff(self, edge_order=1):
│ │          """
│ │ -        Differentiate the time series with respect to 't' (default).
│ │ -        Uses numpy.gradient() internally.
│ │ +        Differentiate the time series with respect to 't' (default) using numpy.gradient() internally.
│ │  
│ │          Parameters
│ │          ----------
│ │          edge_order: Same as edge_order in numpy.gradient(). Default: 1
│ │  
│ │          Returns
│ │          -------
│ │          1D array of same length as that of 't'.
│ │          """
│ │          return np.gradient(self.y, self.t, edge_order=edge_order)
│ │  
│ │      def get_int(self, **kwargs):
│ │          """
│ │ -        Integrate the time series with respect to 't' (default).
│ │ -        Uses numpy.trapz() internally.
│ │ +        Integrate the time series with respect to 't' (default) using numpy.trapz() internally.
│ │  
│ │          Parameters
│ │          ----------
│ │          All **kwargs supported by numpy.trapz()
│ │  
│ │          Returns
│ │          -------
│ │          Scalar
│ │          """
│ │          defaultArgs = {"x": self.t}
│ │          kwargs = {**defaultArgs, **kwargs}
│ │          return np.trapz(self.y, **kwargs)
│ │  
│ │ +    def get_numerical_int(self, init=0.0, **kwargs):
│ │ +        """
│ │ +        Integrate the time series numerically w.r.t. t and produce 1D array of integrated values as opposed to get_int which gives total area under the curve.
│ │ +
│ │ +        Parameters
│ │ +        ----------
│ │ +        init (scalar): Initial condition
│ │ +
│ │ +        returns
│ │ +        -------
│ │ +        1D numpy array
│ │ +        """
│ │ +        defaultArgs = {"x": self.t}
│ │ +        kwargs = {**defaultArgs, **kwargs}
│ │ +        y = self.y
│ │ +        x = kwargs["x"]
│ │ +        yshift = np.zeros(len(y))
│ │ +        yshift[0:-1] = y[1:]
│ │ +        xshift = np.zeros(len(x))
│ │ +        xshift[0:-1] = x[1:]
│ │ +        area_vec = 0.5 * (y[0:-1] + y[1:]) * (x[1:] - x[0:-1])
│ │ +        yi = np.concatenate((np.array([init]), area_vec))
│ │ +        return np.cumsum(yi)
│ │ +
│ │ +
│ │ +class ResponseSpectra:
│ │ +    """ResponseSpectrum class."""
│ │  
│ │ -class ResponseSpectrum:
│ │      def __init__(self, T, Sd, Sv, Sa):
│ │          """
│ │ -        Class for storing response spectra
│ │ +        Class for storing response spectrum.
│ │  
│ │          Parameters
│ │          ----------
│ │          T: (array of float) Natural period
│ │          Sd: (array of float) Spectral displacement
│ │          Sv: (array of float) Spectral velocity
│ │          Sa: (array of float) Spectral acceleration
│ │          """
│ │ -        self.T = T
│ │ -        self.Sd = Sd
│ │ -        self.Sv = Sv
│ │ -        self.Sa = Sa
│ │ +        self.T = np.array(T)
│ │ +        self.Sd = np.array(Sd)
│ │ +        self.Sv = np.array(Sv)
│ │ +        self.Sa = np.array(Sa)
│ │ +        self.PSv = (2*np.pi / self.T) * self.Sd
│ │ +        self.PSa = (2*np.pi / self.T) * self.PSv
│ │  
│ │      def __repr__(self):
│ │          a = ""
│ │          for key, val in vars(self).items():
│ │              a += "{:10s}:{}\n".format(key, val)
│ │          return a
│ │  
│ │      def plot(self, log=False, **kwargs):
│ │          """
│ │ -        Method plots Response Spectrum of ResponseSpectrum object
│ │ +        Plot Response Spectrum of ResponseSpectrum object.
│ │ +
│ │          Parameters
│ │          ----------
│ │ +        log (boolean): use log scale for axes (default *False*).
│ │ +
│ │          Returns
│ │          -------
│ │          Matplotlib Figure Object
│ │  
│ │          """
│ │          fig, ax = plt.subplots(nrows=1, ncols=3, constrained_layout=True, **kwargs)
│ │          ax[0].plot(self.T, self.Sd)
│ │ @@ -488,17 +535,19 @@
│ │              ax[2].set_xscale("log")
│ │              ax[2].set_yscale("log")
│ │          # plt.show()
│ │          return fig
│ │  
│ │  
│ │  class FourierSpectrum:
│ │ +    """FourierSpectrum class."""
│ │ +
│ │      def __init__(self, frequencies, ordinate, N):
│ │          """
│ │ -        Class to store fourier spectra
│ │ +        Class to store fourier spectrum.
│ │  
│ │          Parameters
│ │          ----------
│ │          Freqencies: Frequency (Hz)
│ │          Amplitude: Fourier Amplitude
│ │          """
│ │          self.frequencies = frequencies
│ │ @@ -515,24 +564,26 @@
│ │          a = ""
│ │          for key, val in vars(self).items():
│ │              a += "{:10s}:{}\n".format(key, val)
│ │          return a
│ │  
│ │      def plot(self, log=False, **kwargs):
│ │          """
│ │ -        Method plots Fourier Spectrum of FourierSpectrum object
│ │ +        Plot Fourier Spectrum of FourierSpectrum object.
│ │  
│ │          Parameters
│ │          ----------
│ │ +        log (boolean): use log scale for axes (default *False*).
│ │ +
│ │          Returns
│ │          -------
│ │          Matplotlib Figure Object
│ │  
│ │          """
│ │ -        defaultArgs = {"figsize" : (10,5)}
│ │ +        defaultArgs = {"figsize": (10, 5)}
│ │          kwargs = {**defaultArgs, **kwargs}
│ │          fig = plt.figure(constrained_layout=True, **kwargs)
│ │  
│ │          gs = plt.GridSpec(2, 2, figure=fig)
│ │          ax0 = fig.add_subplot(gs[0, :])
│ │          ax1 = fig.add_subplot(gs[1, 0])
│ │          ax2 = fig.add_subplot(gs[1, 1])
│ │ @@ -554,36 +605,62 @@
│ │          if log:
│ │              ax0.set_xscale("log")
│ │  
│ │          return fig
│ │  
│ │  
│ │  class PowerSpectrum:
│ │ +    """PowerSpectrum class."""
│ │ +
│ │      def __init__(self, frequencies, amplitude, N):
│ │          """
│ │ -        Class to store power spectra
│ │ +        Class to store power spectrum.
│ │  
│ │          Parameters
│ │          ----------
│ │          Freqencies: Frequency (Hz)
│ │          Amplitude: Power Amplitude
│ │          """
│ │          self.frequencies = frequencies
│ │          self.amplitude = amplitude
│ │          self.N = N
│ │  
│ │ +        l0 = self.get_nth_moment(n=0)
│ │ +        l1 = self.get_nth_moment(n=1)
│ │ +        l2 = self.get_nth_moment(n=2)
│ │ +        self.centralFreq = np.sqrt(l2/l0)
│ │ +        self.shapeFactor = np.sqrt(1 - l1**2 / (l0*l2))
│ │ +
│ │      def __repr__(self):
│ │          a = ""
│ │          for key, val in vars(self).items():
│ │              a += "{:10s}:{}\n".format(key, val)
│ │          return a
│ │  
│ │ +    def get_nth_moment(self, n=0):
│ │ +        """
│ │ +        Calculate the nth moment of the power spectrum amplitude.
│ │ +        
│ │ +        Parameter:
│ │ +        ----------
│ │ +        n (scalar): order of moment
│ │ +
│ │ +        returns:
│ │ +        --------
│ │ +        nth moment
│ │ +        
│ │ +        """
│ │ +        N = self.N // 2
│ │ +        amp = self.amplitude[0:N]
│ │ +        freq = self.frequencies[0:N]
│ │ +        return np.trapz(freq**n * amp, x=freq)
│ │ +
│ │      def get_compatible_timehistories(self, m=5):
│ │          """
│ │ -        Generates m compatible timehistories from power spectrum
│ │ +        Generate m compatible timehistories from power spectrum.
│ │  
│ │          Parameters
│ │          ----------
│ │          m: (int) number of compatible timehistories to generate
│ │  
│ │          Returns
│ │          -------
│ │ @@ -602,31 +679,33 @@
│ │          x = np.complex_(np.zeros((n, m)))
│ │          Xphase = np.complex_(np.zeros(n))
│ │  
│ │          ts = [None] * m
│ │  
│ │          for k in range(m):
│ │              if np.mod(n, 2) == 0:  # even number of samples
│ │ -                Xphase[1 : n // 2] = 2 * np.pi * np.random.rand(n // 2 - 1)
│ │ -                Xphase[n // 2 + 1 :] = -np.flip(Xphase[1 : n // 2])
│ │ +                Xphase[1: n // 2] = 2 * np.pi * np.random.rand(n // 2 - 1)
│ │ +                Xphase[n // 2 + 1:] = -np.flip(Xphase[1: n // 2])
│ │              else:
│ │ -                Xphase[1 : (n + 1) // 2] = n * np.pi * np.random.rand((n + 1) // 2 - 1)
│ │ -                Xphase[(n + 1) // 2 :] = -np.flip(Xphase[1 : (n + 1) // 2])
│ │ +                Xphase[1: (n + 1) // 2] = n * np.pi * np.random.rand((n + 1) // 2 - 1)
│ │ +                Xphase[(n + 1) // 2:] = -np.flip(Xphase[1: (n + 1) // 2])
│ │  
│ │              X[:, k] = Xamp * (np.cos(Xphase) + 1j * np.sin(Xphase))
│ │              x[:, k] = np.fft.ifft(X[:, k])
│ │  
│ │              ts[k] = TimeSeries(t, np.real(x[:, k]))
│ │          return ts
│ │  
│ │      def plot(self, log=False):
│ │          """
│ │ -        Method plots Power Spectrum of PowerSpectrum object
│ │ +        Plot Power Spectrum of PowerSpectrum object.
│ │ +
│ │          Parameters
│ │          ----------
│ │ +        log (boolean): use log scale for axes (default *False*).
│ │          Returns
│ │          -------
│ │          Matplotlib Figure Object
│ │  
│ │          """
│ │          fig, ax = plt.subplots()
│ │          ax.plot(
│ │   --- earthquakepy-0.2.6/earthquakepy/tsReaders.py
│ ├── +++ earthquakepy-0.3.7/earthquakepy/tsReaders.py
│ │┄ Files 20% similar despite different names
│ │ @@ -50,51 +50,57 @@
│ │      ts.set_npts(npts)
│ │      ts.set_dt(dt)
│ │      ts.set_duration(duration)
│ │      ts.set_filepath(filepath)
│ │      return ts
│ │  
│ │  
│ │ -def read_data_between_lines(text, start=0, end=None):
│ │ +def read_data_between_lines(text, start=0, end=None, **kwargs):
│ │      """
│ │      Read data between line numbers given by start and end.
│ │  
│ │      Parameters
│ │      ----------
│ │      text (list of strings): data read from file using readlines()
│ │      start (int): line number (0 indexed) to start reading the data
│ │      end (int): line number (0 indexed) to end reading the data (inclusive)
│ │  
│ │      returns
│ │      -------
│ │      1D numpy array of values
│ │      """
│ │ +    defaultArgs = {}
│ │ +    kwargs = {**defaultArgs, **kwargs}
│ │      if end is None:
│ │          end = len(text)
│ │  
│ │      v = []
│ │      for i in range(start, end):
│ │ -        line = text[i].strip().split(" ")
│ │ +        line = re.split(r"\s+", text[i].strip())
│ │ +        # line = text[i].strip().split(" ")
│ │          for j in range(len(line)):
│ │              v.append(float(line[j]))
│ │      return np.array(v)
│ │  
│ │  
│ │ -def read_cosmos_vdc_file(filename, **kwargs):
│ │ +def read_cosmos_vdc_file(filename, scale_factor=[1.0, 1.0, 1.0], **kwargs):
│ │      """
│ │      Read a cosmos db virtual data file and return three timeseries objects corresponding to acceleration, velocity and displacement record, respectively.
│ │  
│ │      Parameters
│ │      ----------
│ │      filename (string): name of the file to read
│ │ +    scale_factor (list of 3 floats): scale factors to be multiplied to acc, vel and disp timeseries, respectively
│ │  
│ │      Returns
│ │      -------
│ │      three Timeseries objects
│ │      """
│ │ +    defaultArgs = {}
│ │ +    kwargs = {**defaultArgs, **kwargs}
│ │      with open(filename, "r") as f:
│ │          text = f.readlines()
│ │  
│ │      l1 = text[0].strip()
│ │      eqName = l1.split(",")[0]
│ │      eqDate = ",".join(l1.split(",")[1:]).strip()
│ │  
│ │ @@ -130,63 +136,95 @@
│ │      vunit = re.search(".*\(in\s*(.*)\)\s*.*", text[vel_start-1])[1]
│ │      dunit = re.search(".*\(in\s*(.*)\)\s*.*", text[disp_start-1])[1]
│ │  
│ │      acc = read_data_between_lines(text, start=acc_start, end=acc_end)
│ │      vel = read_data_between_lines(text, start=vel_start, end=vel_end)
│ │      disp = read_data_between_lines(text, start=disp_start, end=disp_end)
│ │  
│ │ -    ats = timeseries.TimeSeries(dt, acc)
│ │ +    ats = timeseries.TimeSeries(dt, acc*scale_factor[0])
│ │      ats.component = comp
│ │      ats.dt = dt
│ │      ats.duration = ats.t[-1]
│ │      ats.eqDate = eqDate
│ │      ats.eqName = eqName
│ │      ats.lat = lat
│ │      ats.lon = lon
│ │      ats.station = station
│ │      ats.yunit = aunit
│ │      ats.filepath = filename
│ │      ats.meta = meta
│ │  
│ │ -    vts = timeseries.TimeSeries(dt, vel)
│ │ +    vts = timeseries.TimeSeries(dt, vel*scale_factor[1])
│ │      vts.component = comp
│ │      vts.dt = dt
│ │      vts.duration = vts.t[-1]
│ │      vts.eqDate = eqDate
│ │      vts.eqName = eqName
│ │      vts.lat = lat
│ │      vts.lon = lon
│ │      vts.station = station
│ │      vts.yunit = vunit
│ │      vts.filepath = filename
│ │      vts.meta = meta
│ │  
│ │ -    dts = timeseries.TimeSeries(dt, disp)
│ │ +    dts = timeseries.TimeSeries(dt, disp*scale_factor[2])
│ │      dts.component = comp
│ │      dts.dt = dt
│ │      dts.duration = dts.t[-1]
│ │      dts.eqDate = eqDate
│ │      dts.eqName = eqName
│ │      dts.lat = lat
│ │      dts.lon = lon
│ │      dts.station = station
│ │      dts.yunit = dunit
│ │      dts.filepath = filename
│ │      dts.meta = meta
│ │      return ats, vts, dts
│ │  
│ │  
│ │ -def read_raw_timeseries_file(filename, **kwargs):
│ │ +def read_raw_timeseries_file(filename, scale_factor=1.0, **kwargs):
│ │      """
│ │      Read a raw file readable by numpy.genfromtxt(). The first column is assumed as time and second column as ordinates. Accepts all arguments supported by genfromtxt().
│ │  
│ │      Parameters
│ │      ----------
│ │      filename: (str) filename of the file containing raw data
│ │  
│ │      Returns
│ │      -------
│ │      Timeseries object
│ │      """
│ │ +    defaultArgs = {}
│ │ +    kwargs = {**defaultArgs, **kwargs}
│ │      data = np.genfromtxt(filename, **kwargs)
│ │ -    ts = timeseries.TimeSeries(data[:, 0], data[:, 1])
│ │ +    ts = timeseries.TimeSeries(data[:, 0], data[:, 1] * scale_factor)
│ │ +    ts.filepath = filename
│ │      return ts
│ │ +
│ │ +
│ │ +def read_custom_timeseries_file(filename, dt=1.0, scale_factor=1.0, **kwargs):
│ │ +    r"""
│ │ +    Read any other file with unknown format where only the ordinates are provided with a specified dt.
│ │ +
│ │ +    This can be used in cases where the file has data as below:
│ │ +    #####
│ │ +    Meta1 : Some info Meta2: Other info
│ │ +    Meta 3: Some info
│ │ +    dt: 0.02
│ │ +    <--snip-->
│ │ +    val1 val2 val3 val4
│ │ +    val5 val6 val7 val8
│ │ +    <--snip-->
│ │ +    valn-3 valn-2 valn-1
│ │ +    ######
│ │ +    The user should provide dt, otherwise assumed as 1.0
│ │ +    """
│ │ +    defaultArgs = {"start": 0, "end": None}
│ │ +    kwargs = {**defaultArgs, **kwargs}
│ │ +    with open(filename, "r") as f:
│ │ +        text = f.readlines()
│ │ +
│ │ +    data = read_data_between_lines(text, start=kwargs["start"], end=kwargs["end"]) * scale_factor
│ │ +    ts = timeseries.TimeSeries(float(dt), data)
│ │ +    ts.filepath = filename
│ │ +    return ts
│ │ +
│ │   --- earthquakepy-0.2.6/setup.py
│ ├── +++ earthquakepy-0.3.7/setup.py
│ │┄ Files 14% similar despite different names
│ │ @@ -1,15 +1,19 @@
│ │  #!/usr/bin/env python3
│ │  
│ │  from setuptools import setup
│ │ +from pathlib import Path
│ │ +this_directory = Path(__file__).parent
│ │  
│ │  setup(
│ │      name="earthquakepy",
│ │ -    version="0.2.6",
│ │ +    version="0.3.7",
│ │      description="python library for earthquake engineers.",
│ │ +    long_description = (this_directory / "README.md").read_text(),
│ │ +    long_description_content_type="text/markdown",
│ │      url="https://github.com/gauthamrdy/earthquakepy",
│ │      author="Gautham Reddy, Digvijay Patankar",
│ │      author_email="pgrddy@gmail.com, dbpatankar@gmail.com",
│ │      license="GNU GPLv3",
│ │      packages=["earthquakepy"],
│ │      install_requires=[
│ │          "numpy",
