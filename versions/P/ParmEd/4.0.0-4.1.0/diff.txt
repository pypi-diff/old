--- tmp/ParmEd-4.0.0.tar.gz
+++ tmp/ParmEd-4.1.0.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "dist/ParmEd-4.0.0.tar", last modified: Fri Jan 27 17:03:04 2023, max compression
│ +gzip compressed data, was "ParmEd-4.1.0.tar", last modified: Fri Apr  7 14:00:47 2023, max compression
│   --- ParmEd-4.0.0.tar
├── +++ ParmEd-4.1.0.tar
│ ├── file list
│ │ @@ -1,231 +1,228 @@
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.178714 ParmEd-4.0.0/
│ │ --rw-r--r--   0 swails     (501) staff       (20)       87 2021-01-26 21:17:47.000000 ParmEd-4.0.0/MANIFEST.in
│ │ --rw-r--r--   0 swails     (501) staff       (20)      288 2023-01-27 17:03:04.179033 ParmEd-4.0.0/PKG-INFO
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.936785 ParmEd-4.0.0/ParmEd.egg-info/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      288 2023-01-27 17:03:03.000000 ParmEd-4.0.0/ParmEd.egg-info/PKG-INFO
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5618 2023-01-27 17:03:03.000000 ParmEd-4.0.0/ParmEd.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 swails     (501) staff       (20)        1 2023-01-27 17:03:03.000000 ParmEd-4.0.0/ParmEd.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 swails     (501) staff       (20)       49 2023-01-27 17:03:03.000000 ParmEd-4.0.0/ParmEd.egg-info/entry_points.txt
│ │ --rw-r--r--   0 swails     (501) staff       (20)        7 2023-01-27 17:03:03.000000 ParmEd-4.0.0/ParmEd.egg-info/top_level.txt
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5222 2023-01-27 17:00:42.000000 ParmEd-4.0.0/README.md
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.918079 ParmEd-4.0.0/examples/
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.947860 ParmEd-4.0.0/examples/amber/
│ │ --rw-r--r--   0 swails     (501) staff       (20)   499324 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/amber/ala2_solv.parm7
│ │ --rw-r--r--   0 swails     (501) staff       (20)   110534 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/amber/ala2_solv.rst7
│ │ --rw-r--r--   0 swails     (501) staff       (20)    32144 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/amber/ala5_gas.parm7
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1947 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/amber/ala5_gas.rst7
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1841 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/amber/simulate_amber_gb.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1846 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/amber/simulate_amber_pme.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.953253 ParmEd-4.0.0/examples/charmm/
│ │ --rw-r--r--   0 swails     (501) staff       (20)   280645 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/ala2_charmmgui.crd
│ │ --rw-r--r--   0 swails     (501) staff       (20)   396920 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/ala2_charmmgui.psf
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4237 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/ala5_autopsf.pdb
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12388 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/ala5_autopsf.psf
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2334 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/charmm/simulate_charmm_gb.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3157 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/charmm/simulate_charmm_gui.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.955138 ParmEd-4.0.0/examples/charmm/toppar/
│ │ --rw-r--r--   0 swails     (501) staff       (20)   184930 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/toppar/par_all36_prot.prm
│ │ --rw-r--r--   0 swails     (501) staff       (20)     9558 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/charmm/toppar/toppar_water_ions.str
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.968356 ParmEd-4.0.0/examples/gromacs/
│ │ --rw-r--r--   0 swails     (501) staff       (20)   171795 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/gromacs/dhfr_gas.gro
│ │ --rw-r--r--   0 swails     (501) staff       (20)   724872 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/gromacs/dhfr_gas.top
│ │ --rw-r--r--   0 swails     (501) staff       (20)  1926716 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/gromacs/dhfr_pme.gro
│ │ --rw-r--r--   0 swails     (501) staff       (20)   745663 2021-01-26 21:17:47.000000 ParmEd-4.0.0/examples/gromacs/dhfr_pme.top
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1828 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/gromacs/simulate_gromacs_gb.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1833 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/gromacs/simulate_gromacs_pme.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:03.969153 ParmEd-4.0.0/examples/rosetta/
│ │ --rwxr-xr-x   0 swails     (501) staff       (20)     1855 2023-01-27 17:00:40.000000 ParmEd-4.0.0/examples/rosetta/simulate_ala12_mutant.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.181143 ParmEd-4.0.0/parmed/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8196 2021-10-27 14:23:58.000000 ParmEd-4.0.0/parmed/.DS_Store
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3148 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      475 2023-01-27 17:03:04.181360 ParmEd-4.0.0/parmed/_version.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.006600 ParmEd-4.0.0/parmed/amber/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1033 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   106436 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/_amberparm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    31982 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/_chamberparm.py
│ │ --rwxr-xr-x   0 swails     (501) staff       (20)    82080 2022-05-30 13:52:13.000000 ParmEd-4.0.0/parmed/amber/_rdparm.cpython-38-darwin.so
│ │ --rwxr-xr-x   0 swails     (501) staff       (20)    76992 2023-01-26 01:30:35.000000 ParmEd-4.0.0/parmed/amber/_rdparm.cpython-39-darwin.so
│ │ --rw-r--r--   0 swails     (501) staff       (20)    54895 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/_tinkerparm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    38121 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/amberformat.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    23765 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/asciicrd.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    27441 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mask.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.011891 ParmEd-4.0.0/parmed/amber/mdin/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      100 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5977 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/cntrl.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1755 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/ewald.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12900 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/mdin.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2729 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/pb.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1628 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/qmmm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      108 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/mdin/typing.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    28478 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/netcdffiles.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    25496 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/offlib.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    33432 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/parameters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2795 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/readparm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    59549 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/amber/titratable_residues.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.015083 ParmEd-4.0.0/parmed/charmm/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1376 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/charmm/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5903 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/charmm/_charmmfile.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12862 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/charmm/charmmcrds.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    58121 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/charmm/parameters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    34285 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/charmm/psf.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2947 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/constants.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.017001 ParmEd-4.0.0/parmed/dlpoly/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      224 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/dlpoly/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6568 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/dlpoly/dlpolyconfig.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    18773 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/dlpoly/dlpolyfield.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.018990 ParmEd-4.0.0/parmed/entos/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      256 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/entos/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4475 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/entos/converters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      566 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/entos/imports.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3724 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/exceptions.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.026044 ParmEd-4.0.0/parmed/formats/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      591 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    26747 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/mol2.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    85932 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/formats/pdb.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.033030 ParmEd-4.0.0/parmed/formats/pdbx/
│ │ --rw-r--r--   0 swails     (501) staff       (20)    29471 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/pdbx/PdbxContainers.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    16529 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/pdbx/PdbxReader.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6859 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/pdbx/PdbxWriter.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      564 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/pdbx/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    14080 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/pqr.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    15182 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/psf.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8433 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/registry.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      902 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/formats/sdf.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12818 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/geometry.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.038790 ParmEd-4.0.0/parmed/gromacs/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1648 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/gromacs/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13760 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/gromacs/_cpp.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3851 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/gromacs/_gromacsfile.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13626 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/gromacs/gromacsgro.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    99523 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/gromacs/gromacstop.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.044163 ParmEd-4.0.0/parmed/modeller/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      397 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/modeller/__init__.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.080335 ParmEd-4.0.0/parmed/modeller/data/
│ │ --rw-r--r--   0 swails     (501) staff       (20) 15417391 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/modeller/data/ccd_residue_templates.json
│ │ --rw-r--r--   0 swails     (501) staff       (20)   114913 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/modeller/data/standard_residues.lib
│ │ --rw-r--r--   0 swails     (501) staff       (20)    37623 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/modeller/residue.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     7664 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/modeller/standardtemplates.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.083779 ParmEd-4.0.0/parmed/namd/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      461 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/namd/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3973 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/namd/namdbinfiles.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.088406 ParmEd-4.0.0/parmed/openmm/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      689 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    59959 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/parameters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    34237 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/reporters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    18604 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/topsystem.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4100 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/utils.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5609 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/openmm/xmlfile.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    24846 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/parameters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    17851 2023-01-25 21:18:59.000000 ParmEd-4.0.0/parmed/periodic_table.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.089790 ParmEd-4.0.0/parmed/rdkit/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      233 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/rdkit/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5425 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/rdkit/rdkit.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    10030 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/residue.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.091203 ParmEd-4.0.0/parmed/rosetta/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      171 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/rosetta/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3000 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/rosetta/pose.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     9373 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/scripts.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   190267 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/structure.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      362 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/symmetry.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.098164 ParmEd-4.0.0/parmed/tinker/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      246 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tinker/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    20114 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tinker/parameterfile.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    20424 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tinker/system.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12278 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tinker/tinkerfiles.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13218 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tinker/topologyobjects.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.111099 ParmEd-4.0.0/parmed/tools/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      233 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   186927 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/actions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     7524 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/add1264.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3517 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/addljtype.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8239 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/argumentlist.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    47981 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/changeradii.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    14722 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/checkvalidity.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4600 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/exceptions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8898 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/tools/logos.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    16297 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/parmed_cmd.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3272 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/parmlist.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.113061 ParmEd-4.0.0/parmed/tools/simulations/
│ │ --rw-r--r--   0 swails     (501) staff       (20)      111 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/tools/simulations/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    52782 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/simulations/openmm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5140 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/tools/simulations/sanderapi.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   196236 2023-01-27 17:00:42.000000 ParmEd-4.0.0/parmed/topologyobjects.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.120758 ParmEd-4.0.0/parmed/unit/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1672 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3953 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/basedimension.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6929 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/baseunit.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2171 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/constants.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13259 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/mymatrix.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6789 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/prefix.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    32230 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/quantity.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2372 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/standard_dimensions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    26390 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/unit.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13674 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/unit_definitions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4600 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/unit_math.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5693 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/unit/unit_operators.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.125160 ParmEd-4.0.0/parmed/utils/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1890 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      723 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/decorators.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.136505 ParmEd-4.0.0/parmed/utils/fortranformat/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1938 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/FortranRecordReader.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1680 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/FortranRecordWriter.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1284 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/__init__.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8498 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_edit_descriptors.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)       42 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_exceptions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12875 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_input.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5743 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_lexer.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1303 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_misc.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    24486 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_output.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13918 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/_parser.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      125 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/check_version.txt
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2199 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/fortranformat/config.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3568 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/io.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    39266 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/netcdf.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1941 2021-01-26 21:17:47.000000 ParmEd-4.0.0/parmed/utils/pairlist.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    13502 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/pandautils.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2981 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/utils/timer.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3747 2023-01-27 17:00:40.000000 ParmEd-4.0.0/parmed/vec3.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      170 2023-01-27 17:03:04.180308 ParmEd-4.0.0/setup.cfg
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5118 2023-01-27 17:00:42.000000 ParmEd-4.0.0/setup.py
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.141981 ParmEd-4.0.0/src/
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5888 2023-01-27 17:00:40.000000 ParmEd-4.0.0/src/_rdparm.cpp
│ │ --rw-r--r--   0 swails     (501) staff       (20)      720 2021-01-26 21:17:47.000000 ParmEd-4.0.0/src/main.cpp
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5348 2021-01-26 21:17:47.000000 ParmEd-4.0.0/src/readparm.cpp
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3184 2021-01-26 21:17:47.000000 ParmEd-4.0.0/src/readparm.h
│ │ -drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-01-27 17:03:04.178205 ParmEd-4.0.0/test/
│ │ --rw-r--r--   0 swails     (501) staff       (20)    21071 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_format_conversions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   103240 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_openmm_amber.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    10107 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_openmm_amber_forces.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    18028 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_openmm_charmm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    17829 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_openmm_gromacs.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    15465 2021-01-26 21:29:53.000000 ParmEd-4.0.0/test/test_openmm_reporters.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   126904 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_amber.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    63862 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_charmm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     8052 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_cif.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2117 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_dlpoly.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2023 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_entos.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   115988 2023-01-27 17:00:42.000000 ParmEd-4.0.0/test/test_parmed_formats.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     5320 2023-01-27 17:00:42.000000 ParmEd-4.0.0/test/test_parmed_genopen.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3352 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_geometry.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    63585 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_gromacs.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    12152 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_gromacs_cpp.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     3514 2021-01-26 21:17:48.000000 ParmEd-4.0.0/test/test_parmed_misc.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    65922 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_modeller.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)      596 2021-01-26 21:17:48.000000 ParmEd-4.0.0/test/test_parmed_namd.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    10616 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_netcdf.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    34894 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_openmm.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    17683 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_pandas.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     4720 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_parameterset.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2177 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_rdkit.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6255 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_residue.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     2067 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_rosetta.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    18004 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_serialization.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    77033 2023-01-27 17:00:42.000000 ParmEd-4.0.0/test/test_parmed_structure.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    21234 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_structure_slicing.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     7142 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_tinker.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    88623 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_topologyobjects.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    29949 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmed_unit.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)   176792 2023-01-27 17:00:40.000000 ParmEd-4.0.0/test/test_parmedtools_actions.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     6288 2021-01-26 21:17:48.000000 ParmEd-4.0.0/test/test_parmedtools_parmlist.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)     1872 2021-01-26 21:17:48.000000 ParmEd-4.0.0/test/test_vec3.py
│ │ --rw-r--r--   0 swails     (501) staff       (20)    64445 2021-01-26 21:17:48.000000 ParmEd-4.0.0/versioneer.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.709996 ParmEd-4.1.0/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)       87 2021-01-26 21:17:47.000000 ParmEd-4.1.0/MANIFEST.in
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      272 2023-04-07 14:00:47.710197 ParmEd-4.1.0/PKG-INFO
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.482341 ParmEd-4.1.0/ParmEd.egg-info/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      272 2023-04-07 14:00:46.000000 ParmEd-4.1.0/ParmEd.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5517 2023-04-07 14:00:47.000000 ParmEd-4.1.0/ParmEd.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 swails     (501) staff       (20)        1 2023-04-07 14:00:46.000000 ParmEd-4.1.0/ParmEd.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 swails     (501) staff       (20)       48 2023-04-07 14:00:47.000000 ParmEd-4.1.0/ParmEd.egg-info/entry_points.txt
│ │ +-rw-r--r--   0 swails     (501) staff       (20)        7 2023-04-07 14:00:47.000000 ParmEd-4.1.0/ParmEd.egg-info/top_level.txt
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5222 2023-01-27 17:00:42.000000 ParmEd-4.1.0/README.md
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.469785 ParmEd-4.1.0/examples/
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.487795 ParmEd-4.1.0/examples/amber/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   499324 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/amber/ala2_solv.parm7
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   110534 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/amber/ala2_solv.rst7
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    32144 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/amber/ala5_gas.parm7
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1947 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/amber/ala5_gas.rst7
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1841 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/amber/simulate_amber_gb.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1846 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/amber/simulate_amber_pme.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.493472 ParmEd-4.1.0/examples/charmm/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   280645 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/ala2_charmmgui.crd
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   396920 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/ala2_charmmgui.psf
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4237 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/ala5_autopsf.pdb
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12388 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/ala5_autopsf.psf
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2334 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/charmm/simulate_charmm_gb.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3157 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/charmm/simulate_charmm_gui.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.496685 ParmEd-4.1.0/examples/charmm/toppar/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   184930 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/toppar/par_all36_prot.prm
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     9558 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/charmm/toppar/toppar_water_ions.str
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.507592 ParmEd-4.1.0/examples/gromacs/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   171795 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/gromacs/dhfr_gas.gro
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   724872 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/gromacs/dhfr_gas.top
│ │ +-rw-r--r--   0 swails     (501) staff       (20)  1926716 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/gromacs/dhfr_pme.gro
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   745663 2021-01-26 21:17:47.000000 ParmEd-4.1.0/examples/gromacs/dhfr_pme.top
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1828 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/gromacs/simulate_gromacs_gb.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1833 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/gromacs/simulate_gromacs_pme.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.508275 ParmEd-4.1.0/examples/rosetta/
│ │ +-rwxr-xr-x   0 swails     (501) staff       (20)     1855 2023-01-27 17:00:40.000000 ParmEd-4.1.0/examples/rosetta/simulate_ala12_mutant.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.712302 ParmEd-4.1.0/parmed/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3148 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      475 2023-04-07 14:00:47.712459 ParmEd-4.1.0/parmed/_version.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.527273 ParmEd-4.1.0/parmed/amber/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1033 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   106436 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/_amberparm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    31982 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/_chamberparm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    54895 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/_tinkerparm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    38121 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/amberformat.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    23765 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/asciicrd.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    27441 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mask.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.530994 ParmEd-4.1.0/parmed/amber/mdin/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      100 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5977 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/cntrl.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1755 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/ewald.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12919 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/amber/mdin/mdin.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2729 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/pb.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1628 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/qmmm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      108 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/mdin/typing.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    28478 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/netcdffiles.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    25496 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/offlib.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    33432 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/parameters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2795 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/readparm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    59549 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/amber/titratable_residues.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.533769 ParmEd-4.1.0/parmed/charmm/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1376 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/charmm/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5903 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/charmm/_charmmfile.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12862 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/charmm/charmmcrds.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    58121 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/charmm/parameters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    34298 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/charmm/psf.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2947 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/constants.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.535927 ParmEd-4.1.0/parmed/dlpoly/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      224 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/dlpoly/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6568 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/dlpoly/dlpolyconfig.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    18773 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/dlpoly/dlpolyfield.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.547466 ParmEd-4.1.0/parmed/entos/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      256 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/entos/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4475 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/entos/converters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      566 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/entos/imports.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3724 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/exceptions.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.556384 ParmEd-4.1.0/parmed/formats/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      591 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    26747 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/mol2.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    86073 2023-04-07 13:53:49.000000 ParmEd-4.1.0/parmed/formats/pdb.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.561553 ParmEd-4.1.0/parmed/formats/pdbx/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    29471 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/pdbx/PdbxContainers.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    16529 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/pdbx/PdbxReader.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6859 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/pdbx/PdbxWriter.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      564 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/pdbx/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    14080 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/pqr.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    15338 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/formats/psf.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     8433 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/registry.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      902 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/formats/sdf.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12818 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/geometry.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.564422 ParmEd-4.1.0/parmed/gromacs/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1648 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/gromacs/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13760 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/gromacs/_cpp.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3851 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/gromacs/_gromacsfile.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13626 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/gromacs/gromacsgro.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    99475 2023-04-07 13:53:49.000000 ParmEd-4.1.0/parmed/gromacs/gromacstop.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.568662 ParmEd-4.1.0/parmed/modeller/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      397 2023-01-27 17:00:42.000000 ParmEd-4.1.0/parmed/modeller/__init__.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.620043 ParmEd-4.1.0/parmed/modeller/data/
│ │ +-rw-r--r--   0 swails     (501) staff       (20) 15417391 2023-01-27 17:00:42.000000 ParmEd-4.1.0/parmed/modeller/data/ccd_residue_templates.json
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   114913 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/modeller/data/standard_residues.lib
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    37657 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/modeller/residue.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     7664 2023-01-27 17:00:42.000000 ParmEd-4.1.0/parmed/modeller/standardtemplates.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.624007 ParmEd-4.1.0/parmed/namd/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      461 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/namd/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3973 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/namd/namdbinfiles.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.631543 ParmEd-4.1.0/parmed/openmm/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      689 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/openmm/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    60505 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/openmm/parameters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    34237 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/openmm/reporters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    18604 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/openmm/topsystem.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4100 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/openmm/utils.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5609 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/openmm/xmlfile.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    24846 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/parameters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    17851 2023-01-25 21:18:59.000000 ParmEd-4.1.0/parmed/periodic_table.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.633329 ParmEd-4.1.0/parmed/rdkit/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      233 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/rdkit/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5425 2023-01-27 17:00:42.000000 ParmEd-4.1.0/parmed/rdkit/rdkit.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    10030 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/residue.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.634522 ParmEd-4.1.0/parmed/rosetta/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      171 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/rosetta/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3000 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/rosetta/pose.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     9373 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/scripts.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   193366 2023-02-27 14:06:57.000000 ParmEd-4.1.0/parmed/structure.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      362 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/symmetry.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.638645 ParmEd-4.1.0/parmed/tinker/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      246 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tinker/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    20114 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tinker/parameterfile.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    20424 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tinker/system.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12278 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tinker/tinkerfiles.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13218 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tinker/topologyobjects.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.648428 ParmEd-4.1.0/parmed/tools/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      233 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   187661 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/tools/actions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     7524 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/add1264.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3517 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/addljtype.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     8239 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/argumentlist.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    47981 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/changeradii.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    14722 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/checkvalidity.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4600 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/exceptions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     8898 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/tools/logos.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    16297 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/parmed_cmd.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3272 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/parmlist.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.650667 ParmEd-4.1.0/parmed/tools/simulations/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      111 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/tools/simulations/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    52775 2023-04-06 20:47:06.000000 ParmEd-4.1.0/parmed/tools/simulations/openmm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5140 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/tools/simulations/sanderapi.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   196236 2023-01-27 17:00:42.000000 ParmEd-4.1.0/parmed/topologyobjects.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.659434 ParmEd-4.1.0/parmed/unit/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1672 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3953 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/basedimension.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6929 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/baseunit.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2171 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/constants.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13259 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/mymatrix.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6789 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/prefix.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    32230 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/quantity.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2372 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/standard_dimensions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    26390 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/unit.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13674 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/unit_definitions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4600 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/unit_math.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5693 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/unit/unit_operators.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.664687 ParmEd-4.1.0/parmed/utils/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1890 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      723 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/decorators.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.672554 ParmEd-4.1.0/parmed/utils/fortranformat/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1938 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/FortranRecordReader.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1680 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/FortranRecordWriter.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1284 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/__init__.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     8498 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_edit_descriptors.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)       42 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_exceptions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12875 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_input.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5743 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_lexer.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1303 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_misc.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    24486 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_output.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13918 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/_parser.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      125 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/check_version.txt
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2199 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/fortranformat/config.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3568 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/io.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    39266 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/netcdf.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1941 2021-01-26 21:17:47.000000 ParmEd-4.1.0/parmed/utils/pairlist.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    13502 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/pandautils.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2981 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/utils/timer.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3747 2023-01-27 17:00:40.000000 ParmEd-4.1.0/parmed/vec3.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      170 2023-04-07 14:00:47.711071 ParmEd-4.1.0/setup.cfg
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5153 2023-02-27 14:06:57.000000 ParmEd-4.1.0/setup.py
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.677640 ParmEd-4.1.0/src/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5888 2023-01-27 17:00:40.000000 ParmEd-4.1.0/src/_rdparm.cpp
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      720 2021-01-26 21:17:47.000000 ParmEd-4.1.0/src/main.cpp
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5348 2021-01-26 21:17:47.000000 ParmEd-4.1.0/src/readparm.cpp
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3184 2021-01-26 21:17:47.000000 ParmEd-4.1.0/src/readparm.h
│ │ +drwxr-xr-x   0 swails     (501) staff       (20)        0 2023-04-07 14:00:47.709559 ParmEd-4.1.0/test/
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    21071 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_format_conversions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   103240 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_openmm_amber.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    10107 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_openmm_amber_forces.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    18028 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_openmm_charmm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    17829 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_openmm_gromacs.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    15465 2021-01-26 21:29:53.000000 ParmEd-4.1.0/test/test_openmm_reporters.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   126904 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_amber.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    63862 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_charmm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     8052 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_cif.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2117 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_dlpoly.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2023 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_entos.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   116919 2023-04-07 13:53:49.000000 ParmEd-4.1.0/test/test_parmed_formats.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     5320 2023-01-27 17:00:42.000000 ParmEd-4.1.0/test/test_parmed_genopen.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3352 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_geometry.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    63585 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_gromacs.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    12152 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_gromacs_cpp.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     3514 2021-01-26 21:17:48.000000 ParmEd-4.1.0/test/test_parmed_misc.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    65922 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_modeller.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)      596 2021-01-26 21:17:48.000000 ParmEd-4.1.0/test/test_parmed_namd.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    10616 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_netcdf.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    34894 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_openmm.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    17683 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_pandas.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     4720 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_parameterset.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2177 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_rdkit.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6255 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_residue.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     2067 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_rosetta.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    18004 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_serialization.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    77033 2023-01-27 17:00:42.000000 ParmEd-4.1.0/test/test_parmed_structure.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    21234 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_structure_slicing.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     7142 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_tinker.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    88623 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_topologyobjects.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    29949 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmed_unit.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)   176792 2023-01-27 17:00:40.000000 ParmEd-4.1.0/test/test_parmedtools_actions.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     6288 2021-01-26 21:17:48.000000 ParmEd-4.1.0/test/test_parmedtools_parmlist.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)     1872 2021-01-26 21:17:48.000000 ParmEd-4.1.0/test/test_vec3.py
│ │ +-rw-r--r--   0 swails     (501) staff       (20)    64445 2021-01-26 21:17:48.000000 ParmEd-4.1.0/versioneer.py
│ │   --- ParmEd-4.0.0/ParmEd.egg-info/SOURCES.txt
│ ├── +++ ParmEd-4.1.0/ParmEd.egg-info/SOURCES.txt
│ │┄ Files 1% similar despite different names
│ │ @@ -25,15 +25,14 @@
│ │  examples/gromacs/dhfr_gas.gro
│ │  examples/gromacs/dhfr_gas.top
│ │  examples/gromacs/dhfr_pme.gro
│ │  examples/gromacs/dhfr_pme.top
│ │  examples/gromacs/simulate_gromacs_gb.py
│ │  examples/gromacs/simulate_gromacs_pme.py
│ │  examples/rosetta/simulate_ala12_mutant.py
│ │ -parmed/.DS_Store
│ │  parmed/__init__.py
│ │  parmed/_version.py
│ │  parmed/constants.py
│ │  parmed/exceptions.py
│ │  parmed/geometry.py
│ │  parmed/parameters.py
│ │  parmed/periodic_table.py
│ │ @@ -42,16 +41,14 @@
│ │  parmed/structure.py
│ │  parmed/symmetry.py
│ │  parmed/topologyobjects.py
│ │  parmed/vec3.py
│ │  parmed/amber/__init__.py
│ │  parmed/amber/_amberparm.py
│ │  parmed/amber/_chamberparm.py
│ │ -parmed/amber/_rdparm.cpython-38-darwin.so
│ │ -parmed/amber/_rdparm.cpython-39-darwin.so
│ │  parmed/amber/_tinkerparm.py
│ │  parmed/amber/amberformat.py
│ │  parmed/amber/asciicrd.py
│ │  parmed/amber/mask.py
│ │  parmed/amber/netcdffiles.py
│ │  parmed/amber/offlib.py
│ │  parmed/amber/parameters.py
│ │   --- ParmEd-4.0.0/README.md
│ ├── +++ ParmEd-4.1.0/README.md
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/ala2_solv.parm7
│ ├── +++ ParmEd-4.1.0/examples/amber/ala2_solv.parm7
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/ala2_solv.rst7
│ ├── +++ ParmEd-4.1.0/examples/amber/ala2_solv.rst7
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/ala5_gas.parm7
│ ├── +++ ParmEd-4.1.0/examples/amber/ala5_gas.parm7
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/ala5_gas.rst7
│ ├── +++ ParmEd-4.1.0/examples/amber/ala5_gas.rst7
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/simulate_amber_gb.py
│ ├── +++ ParmEd-4.1.0/examples/amber/simulate_amber_gb.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/amber/simulate_amber_pme.py
│ ├── +++ ParmEd-4.1.0/examples/amber/simulate_amber_pme.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/ala2_charmmgui.crd
│ ├── +++ ParmEd-4.1.0/examples/charmm/ala2_charmmgui.crd
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/ala2_charmmgui.psf
│ ├── +++ ParmEd-4.1.0/examples/charmm/ala2_charmmgui.psf
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/ala5_autopsf.pdb
│ ├── +++ ParmEd-4.1.0/examples/charmm/ala5_autopsf.pdb
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/ala5_autopsf.psf
│ ├── +++ ParmEd-4.1.0/examples/charmm/ala5_autopsf.psf
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/simulate_charmm_gb.py
│ ├── +++ ParmEd-4.1.0/examples/charmm/simulate_charmm_gb.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/simulate_charmm_gui.py
│ ├── +++ ParmEd-4.1.0/examples/charmm/simulate_charmm_gui.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/toppar/par_all36_prot.prm
│ ├── +++ ParmEd-4.1.0/examples/charmm/toppar/par_all36_prot.prm
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/charmm/toppar/toppar_water_ions.str
│ ├── +++ ParmEd-4.1.0/examples/charmm/toppar/toppar_water_ions.str
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/dhfr_gas.gro
│ ├── +++ ParmEd-4.1.0/examples/gromacs/dhfr_gas.gro
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/dhfr_gas.top
│ ├── +++ ParmEd-4.1.0/examples/gromacs/dhfr_gas.top
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/dhfr_pme.gro
│ ├── +++ ParmEd-4.1.0/examples/gromacs/dhfr_pme.gro
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/dhfr_pme.top
│ ├── +++ ParmEd-4.1.0/examples/gromacs/dhfr_pme.top
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/simulate_gromacs_gb.py
│ ├── +++ ParmEd-4.1.0/examples/gromacs/simulate_gromacs_gb.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/gromacs/simulate_gromacs_pme.py
│ ├── +++ ParmEd-4.1.0/examples/gromacs/simulate_gromacs_pme.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/examples/rosetta/simulate_ala12_mutant.py
│ ├── +++ ParmEd-4.1.0/examples/rosetta/simulate_ala12_mutant.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/_amberparm.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/_amberparm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/_chamberparm.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/_chamberparm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/_tinkerparm.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/_tinkerparm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/amberformat.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/amberformat.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/asciicrd.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/asciicrd.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/mask.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mask.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/mdin/cntrl.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mdin/cntrl.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/mdin/ewald.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mdin/ewald.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/mdin/mdin.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mdin/mdin.py
│ │┄ Files 1% similar despite different names
│ │ @@ -189,15 +189,15 @@
│ │              ewald=(self.ewald_nml, self.ewald_nml_defaults),
│ │              pb=(self.pb_nml, self.pb_nml_defaults),
│ │              apbs=(self.pb_nml, self.pb_nml_defaults),
│ │              qmmm=(self.qmmm_nml, self.qmmm_nml_defaults),
│ │          )
│ │  
│ │          variable = variable.lower()
│ │ -        if isinstance(value, str):
│ │ +        if isinstance(value, str) and len(value) > 0:
│ │              if (value[0] == value[-1] == "'") or (value[0] == value[-1] == '"'):
│ │                  value = value[1:-1]
│ │  
│ │          if namelist in namelist_map:
│ │              nml, nml_defaults = namelist_map[namelist]
│ │              if variable in nml:
│ │                  mytype = type(nml_defaults[variable])
│ │   --- ParmEd-4.0.0/parmed/amber/mdin/pb.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mdin/pb.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/mdin/qmmm.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/mdin/qmmm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/netcdffiles.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/netcdffiles.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/offlib.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/offlib.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/parameters.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/parameters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/readparm.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/readparm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/amber/titratable_residues.py
│ ├── +++ ParmEd-4.1.0/parmed/amber/titratable_residues.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/charmm/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/charmm/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/charmm/_charmmfile.py
│ ├── +++ ParmEd-4.1.0/parmed/charmm/_charmmfile.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/charmm/charmmcrds.py
│ ├── +++ ParmEd-4.1.0/parmed/charmm/charmmcrds.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/charmm/parameters.py
│ ├── +++ ParmEd-4.1.0/parmed/charmm/parameters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/charmm/psf.py
│ ├── +++ ParmEd-4.1.0/parmed/charmm/psf.py
│ │┄ Files 0% similar despite different names
│ │ @@ -313,15 +313,15 @@
│ │                  raise CharmmError(f"Got {len(tmp)} indexes for {ngrp} groups")
│ │              it = iter(psfsections['NGRP NST2'][1])
│ │              for i, j, k in zip(it, it, it):
│ │                  self.groups.append(Group(self.atoms[i], j, k))
│ │              # Assign all of the atoms to molecules recursively
│ │              tmp = psfsections['MOLNT'][1]
│ │              tag_molecules(self)
│ │ -            if len(tmp) == len(self.atoms):
│ │ +            if len(psfsections["NUMLP NUMLPH"][1]) != 0:
│ │                  # We have a CHARMM PSF file; now do NUMLP/NUMLPH sections
│ │                  self._process_lonepair_section(psfsections["NUMLP NUMLPH"])
│ │              # Now process the NUMANISO records if this is a drude PSF
│ │              if is_drude:
│ │                  self._process_aniso_section(psfsections["NUMANISO"])
│ │              # Now do the CMAPs
│ │              ncrterm = self._convert(psfsections['NCRTERM'][0], int, 'Number of cross-terms')
│ │   --- ParmEd-4.0.0/parmed/constants.py
│ ├── +++ ParmEd-4.1.0/parmed/constants.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/dlpoly/dlpolyconfig.py
│ ├── +++ ParmEd-4.1.0/parmed/dlpoly/dlpolyconfig.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/dlpoly/dlpolyfield.py
│ ├── +++ ParmEd-4.1.0/parmed/dlpoly/dlpolyfield.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/entos/converters.py
│ ├── +++ ParmEd-4.1.0/parmed/entos/converters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/entos/imports.py
│ ├── +++ ParmEd-4.1.0/parmed/entos/imports.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/exceptions.py
│ ├── +++ ParmEd-4.1.0/parmed/exceptions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/mol2.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/mol2.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/pdb.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pdb.py
│ │┄ Files 1% similar despite different names
│ │ @@ -585,14 +585,15 @@
│ │          except KeyError:
│ │              elem = element_by_name(parts['name'])
│ │              atomic_number = AtomicNum[elem]
│ │          parts['atomic_number'] = atomic_number
│ │          parts['mass'] = Mass[elem]
│ │          parts['bfactor'] = try_convert(parts['bfactor'], float, 0.0)
│ │          parts['occupancy'] = try_convert(parts['occupancy'], float, 0.0)
│ │ +        parts['formal_charge'] = try_convert(parts['charge'], int, None)
│ │          parts['charge'] = try_convert(parts['charge'], float, 0.0)
│ │  
│ │          return parts
│ │  
│ │      def _determine_residue_number(self, residue_number, line):
│ │          if self._last_atom is not None:
│ │              last_residue_number = self._last_atom.residue.number
│ │ @@ -676,15 +677,16 @@
│ │          residue_number = self._determine_residue_number(atom_parts['residue_number'], line)
│ │          atom_number = self._determine_atom_number(atom_parts['number'])
│ │  
│ │          AtomClass = ExtraPoint if atom_parts['name'] in ('EP', 'LP') else Atom
│ │          atom = AtomClass(atomic_number=atom_parts['atomic_number'], name=atom_parts['name'],
│ │                           charge=atom_parts['charge'], mass=atom_parts['mass'],
│ │                           occupancy=atom_parts['occupancy'], bfactor=atom_parts['bfactor'],
│ │ -                         altloc=atom_parts['alternate_location'], number=atom_number)
│ │ +                         altloc=atom_parts['alternate_location'], number=atom_number,
│ │ +                         formal_charge=atom_parts['formal_charge'])
│ │          atom.xx = atom_parts['x']
│ │          atom.xy = atom_parts['y']
│ │          atom.xz = atom_parts['z']
│ │          attribute_key = self._make_atom_key_from_parts(atom_parts)
│ │          all_attribute_key = self._make_atom_key_from_parts(atom_parts, all_parts=True)
│ │          current_atom = self._atom_map_from_attributes.get(attribute_key, None)
│ │          if (current_atom is not None and atom_parts['alternate_location'] in _ascii_letters_set and
│ │   --- ParmEd-4.0.0/parmed/formats/pdbx/PdbxContainers.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pdbx/PdbxContainers.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/pdbx/PdbxReader.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pdbx/PdbxReader.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/pdbx/PdbxWriter.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pdbx/PdbxWriter.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/pdbx/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pdbx/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/pqr.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/pqr.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/psf.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/psf.py
│ │┄ Files 0% similar despite different names
│ │ @@ -310,46 +310,47 @@
│ │                  lph_section.append("\n")
│ │                  dest.write("".join(lph_section))
│ │              dest.write('\n')
│ │              drudes = [atom for atom in struct.atoms if isinstance(atom, DrudeAtom)]
│ │              if drudes:
│ │                  n_aniso = sum(drude.anisotropy is not None for drude in drudes)
│ │                  dest.write((intfmt % n_aniso) + " !NUMANISO\n")
│ │ -                idx_section = []
│ │ -                i = 1
│ │ -                for drude in drudes:
│ │ -                    if drude.anisotropy is None:
│ │ -                        continue
│ │ -                    if any(key not in drude.anisotropy.params for key in ["k11", "k22", "k33"]):
│ │ -                        raise ValueError(
│ │ -                            "CHARMM Drude anisotropy parameters cannot be determined from just "
│ │ -                            "two polarizability scale factors."
│ │ +                if n_aniso:
│ │ +                    idx_section = []
│ │ +                    i = 1
│ │ +                    for drude in drudes:
│ │ +                        if drude.anisotropy is None:
│ │ +                            continue
│ │ +                        if any(key not in drude.anisotropy.params for key in ["k11", "k22", "k33"]):
│ │ +                            raise ValueError(
│ │ +                                "CHARMM Drude anisotropy parameters cannot be determined from just "
│ │ +                                "two polarizability scale factors."
│ │ +                            )
│ │ +                        dest.write(" " * 8)
│ │ +                        dest.write(
│ │ +                            "%14.5f%14.5f%14.5f\n" % (
│ │ +                                drude.anisotropy.params["k11"],
│ │ +                                drude.anisotropy.params["k22"],
│ │ +                                drude.anisotropy.params["k33"],
│ │ +                            )
│ │                          )
│ │ -                    dest.write(" " * 8)
│ │ -                    dest.write(
│ │ -                        "%14.5f%14.5f%14.5f\n" % (
│ │ -                            drude.anisotropy.params["k11"],
│ │ -                            drude.anisotropy.params["k22"],
│ │ -                            drude.anisotropy.params["k33"],
│ │ -                        )
│ │ -                    )
│ │ -                    for atom in [
│ │ -                        drude.anisotropy.atom1,
│ │ -                        drude.anisotropy.atom2,
│ │ -                        drude.anisotropy.atom3,
│ │ -                        drude.anisotropy.atom4,
│ │ -                    ]:
│ │ -                        idx_section.append(intfmt % (atom.idx + 1))
│ │ -                        if i % 8 == 0:
│ │ -                            idx_section.append("\n")
│ │ -                        i += 1
│ │ -                if idx_section[-1] == "\n":
│ │ -                    idx_section.pop()
│ │ -                idx_section.append("\n")
│ │ -                dest.write("".join(idx_section))
│ │ +                        for atom in [
│ │ +                            drude.anisotropy.atom1,
│ │ +                            drude.anisotropy.atom2,
│ │ +                            drude.anisotropy.atom3,
│ │ +                            drude.anisotropy.atom4,
│ │ +                        ]:
│ │ +                            idx_section.append(intfmt % (atom.idx + 1))
│ │ +                            if i % 8 == 0:
│ │ +                                idx_section.append("\n")
│ │ +                            i += 1
│ │ +                    if idx_section[-1] == "\n":
│ │ +                        idx_section.pop()
│ │ +                    idx_section.append("\n")
│ │ +                    dest.write("".join(idx_section))
│ │                  dest.write("\n")
│ │          # CMAP section
│ │          dest.write(intfmt % len(struct.cmaps) + ' !NCRTERM: cross-terms\n')
│ │          for i, cmap in enumerate(struct.cmaps):
│ │              dest.write((intfmt*8) % (cmap.atom1.idx+1, cmap.atom2.idx+1,
│ │                                       cmap.atom3.idx+1, cmap.atom4.idx+1,
│ │                                       cmap.atom2.idx+1, cmap.atom3.idx+1,
│ │   --- ParmEd-4.0.0/parmed/formats/registry.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/registry.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/formats/sdf.py
│ ├── +++ ParmEd-4.1.0/parmed/formats/sdf.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/geometry.py
│ ├── +++ ParmEd-4.1.0/parmed/geometry.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/gromacs/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/gromacs/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/gromacs/_cpp.py
│ ├── +++ ParmEd-4.1.0/parmed/gromacs/_cpp.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/gromacs/_gromacsfile.py
│ ├── +++ ParmEd-4.1.0/parmed/gromacs/_gromacsfile.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/gromacs/gromacsgro.py
│ ├── +++ ParmEd-4.1.0/parmed/gromacs/gromacsgro.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/gromacs/gromacstop.py
│ ├── +++ ParmEd-4.1.0/parmed/gromacs/gromacstop.py
│ │┄ Files 0% similar despite different names
│ │ @@ -1431,21 +1431,19 @@
│ │                      f'{self.defaults.fudgeLJ:<12.8g} {self.defaults.fudgeQQ:<12.8g}\n\n'
│ │                  )
│ │              if include_parfile is not None:
│ │                  dest.write(f'#include "{include_parfile}"\n\n')
│ │              # Print all atom types
│ │              if not itp :
│ │                  parfile.write('[ atomtypes ]\n')
│ │ -                if any(typ._bond_type is not None
│ │ -                        for key, typ in params.atom_types.items()):
│ │ +                if any(typ._bond_type is not None for key, typ in params.atom_types.items()):
│ │                      print_bond_types = True
│ │                  else:
│ │                      print_bond_types = False
│ │ -                if all(typ.atomic_number != -1
│ │ -                        for key, typ in params.atom_types.items()):
│ │ +                if all(typ.atomic_number != -1 for key, typ in params.atom_types.items()):
│ │                      print_atnum = True
│ │                  else:
│ │                      print_atnum = False
│ │                  parfile.write('; name    ')
│ │                  if print_bond_types:
│ │                      parfile.write('bond_type ')
│ │                  if print_atnum:
│ │   --- ParmEd-4.0.0/parmed/modeller/data/ccd_residue_templates.json
│ ├── +++ ParmEd-4.1.0/parmed/modeller/data/ccd_residue_templates.json
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/modeller/data/standard_residues.lib
│ ├── +++ ParmEd-4.1.0/parmed/modeller/data/standard_residues.lib
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/modeller/residue.py
│ ├── +++ ParmEd-4.1.0/parmed/modeller/residue.py
│ │┄ Files 0% similar despite different names
│ │ @@ -472,15 +472,15 @@
│ │          # Add or replace atoms
│ │          for atom in patch.atoms:
│ │              if atom.name in residue:
│ │                  # Overwrite type and charge
│ │                  residue[atom.name].type = atom.type
│ │                  residue[atom.name].charge = atom.charge
│ │              else:
│ │ -                residue.add_atom(Atom(name=atom.name, type=atom.type, charge=atom.charge))
│ │ +                residue.add_atom(Atom(name=atom.name, type=atom.type, charge=atom.charge, atomic_number=atom.atomic_number))
│ │              modifications_made = True
│ │          # Add bonds
│ │          for (atom1_name, atom2_name, order) in patch.add_bonds:
│ │              try:
│ │                  # Remove dangling bonds
│ │                  for name in [atom1_name, atom2_name]:
│ │                      if residue.head and (name == residue.head.name):
│ │   --- ParmEd-4.0.0/parmed/modeller/standardtemplates.py
│ ├── +++ ParmEd-4.1.0/parmed/modeller/standardtemplates.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/namd/namdbinfiles.py
│ ├── +++ ParmEd-4.1.0/parmed/namd/namdbinfiles.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/openmm/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/openmm/parameters.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/parameters.py
│ │┄ Files 1% similar despite different names
│ │ @@ -791,17 +791,19 @@
│ │              if patch.override_level == 0:
│ │                  patch_xml = etree.SubElement(xml_patches, 'Patch', name=patch.name)
│ │              else:
│ │                  patch_xml = etree.SubElement(xml_patches, 'Patch', name=patch.name, override=str(patch.override_level))
│ │  
│ │              # To generate the patch definition, we need to apply it to a residue and see exactly what
│ │              # changes.  We might get different definitions depending on which residue we pick, so try
│ │ -            # all possible residues to take the most common result.
│ │ +            # all possible residues to take the most common result.  We prefer versions that replace
│ │ +            # external bonds, since that is the intended use of most patches.
│ │  
│ │              versions = {}
│ │ +            versions_with_external = {}
│ │              for residue_name in valid_residues_for_patch[name]:
│ │                  try:
│ │                      residue = self.residues[residue_name]
│ │                  except KeyError as err:
│ │                      msg =  (
│ │                          'Compatible residue not found in self.residues\n'
│ │                          f'   patch name: {name}\n'
│ │ @@ -827,15 +829,15 @@
│ │                      instructions.append(('RemoveAtom', dict(name=atom_name)))
│ │  
│ │                  for bond in patch.bonds:
│ │                      instructions.append(('RemoveBond', dict(atomName1=bond.atom1.name, atomName2=bond.atom2.name)))
│ │  
│ │                  for bond in patched_residue.bonds:
│ │                      if (bond.atom1.name not in residue) or (bond.atom2.name not in residue):
│ │ -                        if (bond.atom1.atomic_number != 0) or (bond.atom2.atomic_number != 0): # CHARMM adds bonds to lone pairs, which we need to omit.
│ │ +                        if (bond.atom1.atomic_number != 0) and (bond.atom2.atomic_number != 0): # CHARMM adds bonds to lone pairs, which we need to omit.
│ │                              instructions.append(('AddBond', dict(atomName1=bond.atom1.name, atomName2=bond.atom2.name)))
│ │                  for bond in residue.bonds:
│ │                      if (bond.atom1.name not in patched_residue) or (bond.atom2.name not in patched_residue):
│ │                          instructions.append(('RemoveBond', dict(atomName1=bond.atom1.name, atomName2=bond.atom2.name)))
│ │  
│ │                  if (residue.head is not None) and (patched_residue.head is None):
│ │                      instructions.append(('RemoveExternalBond', dict(atomName=residue.head.name)))
│ │ @@ -855,16 +857,23 @@
│ │  
│ │                  # Convert to hashable types
│ │                  instructions = tuple((i[0], tuple(item for item in i[1].items())) for i in instructions)
│ │                  if instructions in versions:
│ │                      versions[instructions] += 1
│ │                  else:
│ │                      versions[instructions] = 1
│ │ +                if any(i[0] == 'RemoveExternalBond' for i in instructions):
│ │ +                    if instructions in versions_with_external:
│ │ +                        versions_with_external[instructions] += 1
│ │ +                    else:
│ │ +                        versions_with_external[instructions] = 1
│ │  
│ │              # Write the consensus definition.
│ │ +            if len(versions_with_external) > 0:
│ │ +                versions = versions_with_external
│ │              max_count = max(versions.values())
│ │              instructions = [key for key, value in versions.items() if value == max_count][0]
│ │              for command, attrib in instructions:
│ │                  etree.SubElement(patch_xml, command, dict(attrib))
│ │  
│ │      def _write_omm_bonds(self, xml_root, skip_types):
│ │          if not self.bond_types: return
│ │   --- ParmEd-4.0.0/parmed/openmm/reporters.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/reporters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/openmm/topsystem.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/topsystem.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/openmm/utils.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/utils.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/openmm/xmlfile.py
│ ├── +++ ParmEd-4.1.0/parmed/openmm/xmlfile.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/parameters.py
│ ├── +++ ParmEd-4.1.0/parmed/parameters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/periodic_table.py
│ ├── +++ ParmEd-4.1.0/parmed/periodic_table.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/rdkit/rdkit.py
│ ├── +++ ParmEd-4.1.0/parmed/rdkit/rdkit.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/residue.py
│ ├── +++ ParmEd-4.1.0/parmed/residue.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/rosetta/pose.py
│ ├── +++ ParmEd-4.1.0/parmed/rosetta/pose.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/scripts.py
│ ├── +++ ParmEd-4.1.0/parmed/scripts.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/structure.py
│ ├── +++ ParmEd-4.1.0/parmed/structure.py
│ │┄ Files 0% similar despite different names
│ │ @@ -2,15 +2,15 @@
│ │  This module contains the core base class for all of the chemical structures with
│ │  various topological and force field features.
│ │  """
│ │  import logging
│ │  import math
│ │  import os
│ │  from collections import defaultdict
│ │ -from copy import copy
│ │ +from copy import copy, deepcopy
│ │  
│ │  import numpy as np
│ │  
│ │  from . import unit as u
│ │  from . import residue
│ │  from .constants import DEG_TO_RAD, SMALL
│ │  from .exceptions import ParameterError
│ │ @@ -34,18 +34,19 @@
│ │      import openmm as mm
│ │      from openmm.app.internal.unitcell import reducePeriodicBoxVectors
│ │  except ImportError:
│ │      mm = app = None
│ │  
│ │  LOGGER = logging.getLogger(__name__)
│ │  
│ │ -#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │  
│ │  # Private attributes and methods
│ │  
│ │ +
│ │  def _strip_box_units(args):
│ │      new_args = []
│ │      for arg in args:
│ │          # Handle 3 types of arguments here: units, regular numbers, and
│ │          # iterables. Iterables have units removed recursively. But protect
│ │          # against strings, since you get infinite recursion that way
│ │          if u.is_quantity(arg):
│ │ @@ -60,51 +61,62 @@
│ │                  iter(arg)
│ │                  arg = _strip_box_units(arg)
│ │              except TypeError:
│ │                  pass
│ │              new_args.append(arg)
│ │      return new_args
│ │  
│ │ +
│ │  def _bondi(atom):
│ │ -    if atom.atomic_number == 6: return 1.7
│ │ -    if atom.atomic_number == 1: return 1.2
│ │ -    if atom.atomic_number == 7: return 1.55
│ │ -    if atom.atomic_number == 14: return 2.1
│ │ -    if atom.atomic_number == 15: return 1.85
│ │ -    if atom.atomic_number == 16: return 1.8
│ │ +    if atom.atomic_number == 6:
│ │ +        return 1.7
│ │ +    if atom.atomic_number == 1:
│ │ +        return 1.2
│ │ +    if atom.atomic_number == 7:
│ │ +        return 1.55
│ │ +    if atom.atomic_number == 14:
│ │ +        return 2.1
│ │ +    if atom.atomic_number == 15:
│ │ +        return 1.85
│ │ +    if atom.atomic_number == 16:
│ │ +        return 1.8
│ │      return 1.5
│ │  
│ │ +
│ │  def _mbondi(atom):
│ │      if atom.atomic_number == 1:
│ │          bondeds = atom.bond_partners
│ │          if not bondeds or bondeds[0].atomic_number in (6, 7):
│ │              return 1.3
│ │          if bondeds[0].atomic_number in (8, 16):
│ │              return 0.8
│ │          return 1.2
│ │      return _bondi(atom)
│ │  
│ │ +
│ │  def _mbondi2(atom):
│ │      if atom.atomic_number == 1:
│ │          if not atom.bond_partners or atom.bond_partners[0].atomic_number == 7:
│ │              return 1.3
│ │          return 1.2
│ │      return _bondi(atom)
│ │  
│ │ +
│ │  def _mbondi3(atom):
│ │      if atom.residue.name in ('GLU', 'ASP', 'GL4', 'AS4'):
│ │          if atom.name.startswith('OE') or atom.name.startswith('OD'):
│ │              return 1.4
│ │      elif atom.residue.name == 'ARG':
│ │          if atom.name.startswith('HH') or atom.name.startswith('HE'):
│ │              return 1.17
│ │      if atom.name == 'OXT':
│ │          return 1.4
│ │      return _mbondi2(atom)
│ │  
│ │ +
│ │  @needs_openmm
│ │  def _gb_rad_screen(atom, model):
│ │      """
│ │      Gets the default GB parameters for a given atom according to a specific
│ │      Generalized Born model
│ │  
│ │      Parameters
│ │ @@ -122,24 +134,32 @@
│ │          If the model is GBn2, alpha, beta, and gamma parameters are also
│ │          returned
│ │      """
│ │      if model in (app.OBC1, app.OBC2):
│ │          rad = _mbondi2(atom)
│ │      else:
│ │          rad = _mbondi(atom)
│ │ -    if atom.atomic_number == 1: return rad, 0.85
│ │ -    if atom.atomic_number == 6: return rad, 0.72
│ │ -    if atom.atomic_number == 7: return rad, 0.79
│ │ -    if atom.atomic_number == 8: return rad, 0.85
│ │ -    if atom.atomic_number == 9: return rad, 0.88
│ │ -    if atom.atomic_number == 15: return rad, 0.86
│ │ -    if atom.atomic_number == 16: return rad, 0.96
│ │ +    if atom.atomic_number == 1:
│ │ +        return rad, 0.85
│ │ +    if atom.atomic_number == 6:
│ │ +        return rad, 0.72
│ │ +    if atom.atomic_number == 7:
│ │ +        return rad, 0.79
│ │ +    if atom.atomic_number == 8:
│ │ +        return rad, 0.85
│ │ +    if atom.atomic_number == 9:
│ │ +        return rad, 0.88
│ │ +    if atom.atomic_number == 15:
│ │ +        return rad, 0.86
│ │ +    if atom.atomic_number == 16:
│ │ +        return rad, 0.96
│ │      return rad, 0.8
│ │  
│ │ -#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +
│ │  
│ │  class Structure:
│ │      """
│ │      A chemical structure composed of atoms, bonds, angles, torsions, and other
│ │      topological features
│ │  
│ │      Attributes
│ │ @@ -235,15 +255,15 @@
│ │      PI_TORSION_FORCE_GROUP = 8
│ │      STRETCH_BEND_FORCE_GROUP = 9
│ │      TORSION_TORSION_FORCE_GROUP = 10
│ │      NONBONDED_FORCE_GROUP = 11
│ │      RB_TORSION_FORCE_GROUP = 12
│ │      DRUDE_FORCE_GROUP = 13
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __init__(self):
│ │  
│ │          # Topological object lists
│ │          self.atoms = AtomList()
│ │          self.residues = ResidueList()
│ │          self.bonds = TrackedList()
│ │ @@ -288,15 +308,15 @@
│ │          self.space_group = "P 1"
│ │          self.unknown_functional = False
│ │          self.nrexcl = 3
│ │          self.title = ''
│ │          self._combining_rule = 'lorentz'
│ │          self.symmetry = None
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __repr__(self):
│ │          natom = len(self.atoms)
│ │          nres = len(self.residues)
│ │          nextra = sum([isinstance(a, ExtraPoint) for a in self.atoms])
│ │          retstr = ['<%s %d atoms' % (type(self).__name__, natom)]
│ │          if nextra > 0:
│ │ @@ -315,15 +335,15 @@
│ │          # everything else... we don't want __repr__ to be super expensive
│ │          if self.atoms[0].atom_type is UnassignedAtomType and self.atoms[0]._epsilon is None:
│ │              retstr.append('; NOT parameterized>')
│ │          else:
│ │              retstr.append('; parameterized>')
│ │          return ''.join(retstr)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def add_atom(self, atom, resname, resnum, chain='', inscode='', segid=''):
│ │          """
│ │          Adds a new atom to the Structure, adding a new residue to `residues` if
│ │          it has a different name or number as the last residue added and adding
│ │          it to the `atoms` list.
│ │  
│ │ @@ -346,15 +366,15 @@
│ │          -----
│ │          If the residue name and number differ from the last residue in this
│ │          list, a new residue is added and the atom is added to that residue
│ │          """
│ │          self.residues.add_atom(atom, resname, resnum, chain, inscode, segid)
│ │          self.atoms.append(atom)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def add_atom_to_residue(self, atom, residue):
│ │          """
│ │          Adds a new atom to the Structure at the end if the given residue
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -378,21 +398,21 @@
│ │          residue.add_atom(atom)
│ │          # Special-case if this is going to be the last atom
│ │          if not self.atoms or last_atom is self.atoms[-1]:
│ │              self.atoms.append(atom)
│ │          else:
│ │              self.atoms.insert(last_atom.idx + 1, atom)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __copy__(self):
│ │          """ A deep copy of the Structure """
│ │          return self.copy(type(self))
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def copy(self, cls, split_dihedrals=False):
│ │          """
│ │          Makes a copy of the current structure as an instance of a specified
│ │          subclass
│ │  
│ │          Parameters
│ │ @@ -409,98 +429,99 @@
│ │          *cls* instance
│ │              The instance of the Structure subclass `cls` with a copy of the
│ │              current Structure's topology information
│ │          """
│ │          c = cls()
│ │          for atom in self.atoms:
│ │              res = atom.residue
│ │ -            a = copy(atom)
│ │ -            c.add_atom(a, res.name, res.number, res.chain, res.insertion_code, res.segid)
│ │ +            a = deepcopy(atom)
│ │ +            c.add_atom(a, res.name, res.number, res.chain,
│ │ +                       res.insertion_code, res.segid)
│ │          # Now copy all of the types
│ │          for bt in self.bond_types:
│ │ -            c.bond_types.append(copy(bt))
│ │ +            c.bond_types.append(deepcopy(bt))
│ │          c.bond_types.claim()
│ │          for at in self.angle_types:
│ │ -            c.angle_types.append(copy(at))
│ │ +            c.angle_types.append(deepcopy(at))
│ │          c.angle_types.claim()
│ │          if split_dihedrals:
│ │              ndt = 0
│ │              mapdt = {}
│ │              for idt, dt in enumerate(self.dihedral_types):
│ │                  if hasattr(dt, '__iter__'):
│ │                      for t in dt:
│ │ -                        c.dihedral_types.append(copy(t))
│ │ +                        c.dihedral_types.append(deepcopy(t))
│ │                          mapdt.setdefault(idt, []).append(ndt)
│ │                          ndt += 1
│ │                  else:
│ │                      mapdt.setdefault(idt, []).append(ndt)
│ │                      ndt += 1
│ │ -                    c.dihedral_types.append(copy(dt))
│ │ +                    c.dihedral_types.append(deepcopy(dt))
│ │          else:
│ │              for dt in self.dihedral_types:
│ │ -                c.dihedral_types.append(copy(dt))
│ │ +                c.dihedral_types.append(deepcopy(dt))
│ │          c.dihedral_types.claim()
│ │          for ut in self.urey_bradley_types:
│ │ -            c.urey_bradley_types.append(copy(ut))
│ │ +            c.urey_bradley_types.append(deepcopy(ut))
│ │          c.urey_bradley_types.claim()
│ │          for it in self.improper_types:
│ │ -            c.improper_types.append(copy(it))
│ │ +            c.improper_types.append(deepcopy(it))
│ │          c.improper_types.claim()
│ │          for rt in self.rb_torsion_types:
│ │ -            c.rb_torsion_types.append(copy(rt))
│ │ +            c.rb_torsion_types.append(deepcopy(rt))
│ │          c.rb_torsion_types.claim()
│ │          for ct in self.cmap_types:
│ │ -            c.cmap_types.append(copy(ct))
│ │ +            c.cmap_types.append(deepcopy(ct))
│ │          c.cmap_types.claim()
│ │          for ta in self.trigonal_angle_types:
│ │ -            c.trigonal_angle_types.append(copy(ta))
│ │ +            c.trigonal_angle_types.append(deepcopy(ta))
│ │          c.trigonal_angle_types.claim()
│ │          for ot in self.out_of_plane_bend_types:
│ │ -            c.out_of_plane_bend_types.append(copy(ot))
│ │ +            c.out_of_plane_bend_types.append(deepcopy(ot))
│ │          c.out_of_plane_bend_types.claim()
│ │          for pt in self.pi_torsion_types:
│ │ -            c.pi_torsion_types.append(copy(pt))
│ │ +            c.pi_torsion_types.append(deepcopy(pt))
│ │          c.pi_torsion_types.claim()
│ │          for st in self.stretch_bend_types:
│ │ -            c.stretch_bend_types.append(copy(st))
│ │ +            c.stretch_bend_types.append(deepcopy(st))
│ │          c.stretch_bend_types.claim()
│ │          for tt in self.torsion_torsion_types:
│ │ -            c.torsion_torsion_types.append(copy(tt))
│ │ +            c.torsion_torsion_types.append(deepcopy(tt))
│ │          c.torsion_torsion_types.claim()
│ │          for at in self.adjust_types:
│ │ -            c.adjust_types.append(copy(at))
│ │ +            c.adjust_types.append(deepcopy(at))
│ │          c.adjust_types.claim()
│ │          # Now create the topological objects
│ │          atoms = c.atoms
│ │          for b in self.bonds:
│ │              c.bonds.append(
│ │ -                    Bond(atoms[b.atom1.idx], atoms[b.atom2.idx],
│ │ -                         b.type and c.bond_types[b.type.idx], order=b.order)
│ │ +                Bond(atoms[b.atom1.idx], atoms[b.atom2.idx],
│ │ +                     b.type and c.bond_types[b.type.idx], order=b.order)
│ │              )
│ │              c.bonds[-1].funct = b.funct
│ │          for a in self.angles:
│ │              c.angles.append(
│ │ -                    Angle(atoms[a.atom1.idx], atoms[a.atom2.idx],
│ │ -                          atoms[a.atom3.idx],
│ │ -                          a.type and c.angle_types[a.type.idx])
│ │ +                Angle(atoms[a.atom1.idx], atoms[a.atom2.idx],
│ │ +                      atoms[a.atom3.idx],
│ │ +                      a.type and c.angle_types[a.type.idx])
│ │              )
│ │              c.angles[-1].funct = a.funct
│ │          if split_dihedrals:
│ │              for d in self.dihedrals:
│ │                  if hasattr(d.type, '__iter__'):
│ │                      for i in range(len(d.type)):
│ │                          ie = d.ignore_end or i < len(d.type) - 1
│ │                          ti = mapdt[d.type.idx][i]
│ │                          c.dihedrals.append(
│ │ -                                Dihedral(atoms[d.atom1.idx],
│ │ -                                         atoms[d.atom2.idx],
│ │ -                                         atoms[d.atom3.idx],
│ │ -                                         atoms[d.atom4.idx],
│ │ -                                         improper=d.improper, ignore_end=ie,
│ │ -                                         type=c.dihedral_types[ti])
│ │ +                            Dihedral(atoms[d.atom1.idx],
│ │ +                                     atoms[d.atom2.idx],
│ │ +                                     atoms[d.atom3.idx],
│ │ +                                     atoms[d.atom4.idx],
│ │ +                                     improper=d.improper, ignore_end=ie,
│ │ +                                     type=c.dihedral_types[ti])
│ │                          )
│ │                          c.dihedrals[-1]._funct = d._funct
│ │                  else:
│ │                      ti = mapdt[d.type.idx][0]
│ │                      c.dihedrals.append(
│ │                          Dihedral(atoms[d.atom1.idx], atoms[d.atom2.idx],
│ │                                   atoms[d.atom3.idx], atoms[d.atom4.idx],
│ │ @@ -511,114 +532,118 @@
│ │          else:
│ │              for d in self.dihedrals:
│ │                  if d.type is None:
│ │                      typ = None
│ │                  else:
│ │                      typ = c.dihedral_types[d.type.idx]
│ │                  c.dihedrals.append(
│ │ -                        Dihedral(atoms[d.atom1.idx], atoms[d.atom2.idx],
│ │ -                                 atoms[d.atom3.idx], atoms[d.atom4.idx],
│ │ -                                 improper=d.improper, ignore_end=d.ignore_end,
│ │ -                                 type=typ)
│ │ +                    Dihedral(atoms[d.atom1.idx], atoms[d.atom2.idx],
│ │ +                             atoms[d.atom3.idx], atoms[d.atom4.idx],
│ │ +                             improper=d.improper, ignore_end=d.ignore_end,
│ │ +                             type=typ)
│ │                  )
│ │                  c.dihedrals[-1]._funct = d._funct
│ │          for ub in self.urey_bradleys:
│ │              if ub.type is NoUreyBradley:
│ │                  typ = NoUreyBradley
│ │              else:
│ │                  typ = ub.type and c.urey_bradley_types[ub.type.idx]
│ │              c.urey_bradleys.append(
│ │ -                    UreyBradley(atoms[ub.atom1.idx], atoms[ub.atom2.idx], typ)
│ │ +                UreyBradley(atoms[ub.atom1.idx], atoms[ub.atom2.idx], typ)
│ │              )
│ │          for i in self.impropers:
│ │              c.impropers.append(
│ │ -                    Improper(atoms[i.atom1.idx], atoms[i.atom2.idx],
│ │ -                             atoms[i.atom3.idx], atoms[i.atom4.idx],
│ │ -                             i.type and c.improper_types[i.type.idx])
│ │ +                Improper(atoms[i.atom1.idx], atoms[i.atom2.idx],
│ │ +                         atoms[i.atom3.idx], atoms[i.atom4.idx],
│ │ +                         i.type and c.improper_types[i.type.idx])
│ │              )
│ │          for r in self.rb_torsions:
│ │              c.rb_torsions.append(
│ │ -                    Dihedral(atoms[r.atom1.idx], atoms[r.atom2.idx],
│ │ -                             atoms[r.atom3.idx], atoms[r.atom4.idx],
│ │ -                             type=r.type and c.rb_torsion_types[r.type.idx])
│ │ +                Dihedral(atoms[r.atom1.idx], atoms[r.atom2.idx],
│ │ +                         atoms[r.atom3.idx], atoms[r.atom4.idx],
│ │ +                         type=r.type and c.rb_torsion_types[r.type.idx])
│ │              )
│ │              c.rb_torsions[-1]._funct = r._funct
│ │          for cm in self.cmaps:
│ │              c.cmaps.append(
│ │ -                    Cmap(atoms[cm.atom1.idx], atoms[cm.atom2.idx],
│ │ -                         atoms[cm.atom3.idx], atoms[cm.atom4.idx],
│ │ -                         atoms[cm.atom5.idx],
│ │ -                         cm.type and c.cmap_types[cm.type.idx])
│ │ +                Cmap(atoms[cm.atom1.idx], atoms[cm.atom2.idx],
│ │ +                     atoms[cm.atom3.idx], atoms[cm.atom4.idx],
│ │ +                     atoms[cm.atom5.idx],
│ │ +                     cm.type and c.cmap_types[cm.type.idx])
│ │              )
│ │              c.cmaps[-1].funct = cm.funct
│ │          for t in self.trigonal_angles:
│ │              c.trigonal_angles.append(
│ │ -                    TrigonalAngle(atoms[t.atom1.idx], atoms[t.atom2.idx],
│ │ -                                  atoms[t.atom3.idx], atoms[t.atom4.idx],
│ │ -                                  t.type and c.trigonal_angle_types[t.type.idx])
│ │ +                TrigonalAngle(atoms[t.atom1.idx], atoms[t.atom2.idx],
│ │ +                              atoms[t.atom3.idx], atoms[t.atom4.idx],
│ │ +                              t.type and c.trigonal_angle_types[t.type.idx])
│ │              )
│ │          for o in self.out_of_plane_bends:
│ │              c.out_of_plane_bends.append(
│ │ -                    OutOfPlaneBend(atoms[o.atom1.idx], atoms[o.atom2.idx],
│ │ -                                   atoms[o.atom3.idx], atoms[o.atom4.idx],
│ │ -                                   o.type and c.out_of_plane_bend_types[o.type.idx])
│ │ +                OutOfPlaneBend(atoms[o.atom1.idx], atoms[o.atom2.idx],
│ │ +                               atoms[o.atom3.idx], atoms[o.atom4.idx],
│ │ +                               o.type and c.out_of_plane_bend_types[o.type.idx])
│ │              )
│ │          for p in self.pi_torsions:
│ │              c.pi_torsions.append(
│ │ -                    PiTorsion(atoms[p.atom1.idx], atoms[p.atom2.idx],
│ │ -                              atoms[p.atom3.idx], atoms[p.atom4.idx],
│ │ -                              atoms[p.atom5.idx], atoms[p.atom6.idx],
│ │ -                              p.type and c.pi_torsion_types[p.type.idx])
│ │ +                PiTorsion(atoms[p.atom1.idx], atoms[p.atom2.idx],
│ │ +                          atoms[p.atom3.idx], atoms[p.atom4.idx],
│ │ +                          atoms[p.atom5.idx], atoms[p.atom6.idx],
│ │ +                          p.type and c.pi_torsion_types[p.type.idx])
│ │              )
│ │          for s in self.stretch_bends:
│ │              c.stretch_bends.append(
│ │ -                    StretchBend(atoms[s.atom1.idx], atoms[s.atom2.idx],
│ │ -                                atoms[s.atom3.idx],
│ │ -                                s.type and c.stretch_bend_types[s.type.idx])
│ │ +                StretchBend(atoms[s.atom1.idx], atoms[s.atom2.idx],
│ │ +                            atoms[s.atom3.idx],
│ │ +                            s.type and c.stretch_bend_types[s.type.idx])
│ │              )
│ │          for t in self.torsion_torsions:
│ │              c.torsion_torsions.append(
│ │                  TorsionTorsion(atoms[t.atom1.idx], atoms[t.atom2.idx], atoms[t.atom3.idx], atoms[t.atom4.idx],
│ │                                 atoms[t.atom5.idx], t.type and c.torsion_torsion_types[t.type.idx])
│ │              )
│ │          for ch in self.chiral_frames:
│ │              c.chiral_frames.append(
│ │ -                ChiralFrame(atoms[ch.atom1.idx], atoms[ch.atom2.idx], ch.chirality)
│ │ +                ChiralFrame(atoms[ch.atom1.idx],
│ │ +                            atoms[ch.atom2.idx], ch.chirality)
│ │              )
│ │          for m in self.multipole_frames:
│ │              c.multipole_frames.append(
│ │ -                MultipoleFrame(atoms[m.atom.idx], m.frame_pt_num, m.vectail, m.vechead, m.nvec)
│ │ +                MultipoleFrame(
│ │ +                    atoms[m.atom.idx], m.frame_pt_num, m.vectail, m.vechead, m.nvec)
│ │              )
│ │          for a in self.adjusts:
│ │              c.adjusts.append(
│ │ -                NonbondedException(atoms[a.atom1.idx], atoms[a.atom2.idx], a.type and c.adjust_types[a.type.idx])
│ │ +                NonbondedException(
│ │ +                    atoms[a.atom1.idx], atoms[a.atom2.idx], a.type and c.adjust_types[a.type.idx])
│ │              )
│ │          for a in self.acceptors:
│ │              c.acceptors.append(
│ │                  AcceptorDonor(atoms[a.atom1.idx], atoms[a.atom2.idx])
│ │              )
│ │          for d in self.donors:
│ │              c.donors.append(
│ │                  AcceptorDonor(atoms[d.atom1.idx], atoms[d.atom2.idx])
│ │              )
│ │          for g in self.groups:
│ │              c.groups.append(Group(atoms[g.atom.idx], g.type, g.move))
│ │          for l in self.links:
│ │              c.links.append(
│ │ -                Link(atoms[l.atom1.idx], atoms[l.atom2.idx], l.length, l.symmetry_op1, l.symmetry_op2)
│ │ +                Link(atoms[l.atom1.idx], atoms[l.atom2.idx],
│ │ +                     l.length, l.symmetry_op1, l.symmetry_op2)
│ │              )
│ │ -        c._box = copy(self._box)
│ │ -        c._coordinates = copy(self._coordinates)
│ │ +        c._box = deepcopy(self._box)
│ │ +        c._coordinates = deepcopy(self._coordinates)
│ │          c.combining_rule = self.combining_rule
│ │          # Transfer TER cards
│ │          for r1, r2 in zip(c.residues, self.residues):
│ │              r1.ter = r2.ter
│ │          return c
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def to_dataframe(self):
│ │          """ Generates a DataFrame from the current Structure's atomic properties
│ │  
│ │          Returns
│ │          -------
│ │          df : DataFrame
│ │ @@ -627,15 +652,15 @@
│ │          See Also
│ │          --------
│ │          :func:`parmed.utils.pandautils.create_dataframe`
│ │          """
│ │          from .utils.pandautils import create_dataframe
│ │          return create_dataframe(self)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def load_dataframe(self, df):
│ │          """ Loads atomic properties from an input DataFrame
│ │  
│ │          Parameters
│ │          ----------
│ │          df : pandas.DataFrame
│ │ @@ -645,15 +670,15 @@
│ │          See Also
│ │          --------
│ │          :func:`parmed.utils.pandautils.load_dataframe`
│ │          """
│ │          from .utils.pandautils import load_dataframe
│ │          return load_dataframe(self, df)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def is_changed(self):
│ │          """ Determines if any of the topology has changed for this structure """
│ │          return (self.atoms.changed or self.residues.changed or
│ │                  self.bonds.changed or self.trigonal_angles.changed or
│ │                  self.dihedrals.changed or self.urey_bradleys.changed or
│ │                  self.impropers.changed or self.cmaps.changed or
│ │ @@ -669,15 +694,15 @@
│ │                  self.trigonal_angle_types.changed or
│ │                  self.out_of_plane_bends.changed or
│ │                  self.stretch_bend_types.changed or
│ │                  self.torsion_torsion_types.changed or
│ │                  self.pi_torsion_types.changed or self.rb_torsions.changed or
│ │                  self.rb_torsion_types.changed)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def unchange(self):
│ │          """ Toggles all lists so that they do not indicate any changes """
│ │          self.atoms.changed = False
│ │          self.residues.changed = False
│ │          self.bonds.changed = False
│ │          self.angles.changed = False
│ │ @@ -707,15 +732,15 @@
│ │          self.trigonal_angle_types.changed = False
│ │          self.out_of_plane_bend_types.changed = False
│ │          self.pi_torsion_types.changed = False
│ │          self.stretch_bend_types.changed = False
│ │          self.torsion_torsion_types.changed = False
│ │          self.adjust_types.changed = False
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def prune_empty_terms(self):
│ │          """
│ │          Looks through all of the topological lists and gets rid of terms
│ │          in which at least one of the atoms is None or has an `idx` attribute set
│ │          to -1 (indicating that it has been removed from the `atoms` atom list)
│ │          """
│ │ @@ -731,15 +756,15 @@
│ │          self._prune_empty_pi_torsions()
│ │          self._prune_empty_stretch_bends()
│ │          self._prune_empty_torsion_torsions()
│ │          self._prune_empty_chiral_frames()
│ │          self._prune_empty_multipole_frames()
│ │          self._prune_empty_adjusts()
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def update_dihedral_exclusions(self):
│ │          """
│ │          Nonbonded exclusions and exceptions have the following priority:
│ │  
│ │          bond -> angle -> dihedral
│ │  
│ │ @@ -754,19 +779,20 @@
│ │          atoms now connected by a bond or an Angle.  OpenMM, on the other hand,
│ │          will complain about an exception specified multiple times. This method
│ │          scans through all of the dihedrals in which `ignore_end` is `False` and
│ │          turns it to `True` if the two end atoms are in the bond or angle
│ │          partners arrays
│ │          """
│ │          set14 = set()
│ │ -        deferred_dihedrals = [] # to work around pmemd tossing pn=0 dihedrals
│ │ +        deferred_dihedrals = []  # to work around pmemd tossing pn=0 dihedrals
│ │          for dihedral in self.dihedrals:
│ │ -            if dihedral.ignore_end : continue
│ │ +            if dihedral.ignore_end:
│ │ +                continue
│ │              if (dihedral.atom1 in dihedral.atom4.bond_partners or
│ │ -                dihedral.atom1 in dihedral.atom4.angle_partners):
│ │ +                    dihedral.atom1 in dihedral.atom4.angle_partners):
│ │                  dihedral.ignore_end = True
│ │              elif (dihedral.atom1.idx, dihedral.atom4.idx) in set14:
│ │                  # Avoid double counting of 1-4 in a six-membered ring
│ │                  dihedral.ignore_end = True
│ │              elif isinstance(dihedral.type, DihedralType) and dihedral.type.per == 0:
│ │                  # This needs to be done to work around a "feature" in pmemd where periodicity=0
│ │                  # torsions are thrown away. Since AmberParm never has any DihedralTypeList, we only
│ │ @@ -777,15 +803,15 @@
│ │                  set14.add((dihedral.atom4.idx, dihedral.atom1.idx))
│ │          # Only keep ignore_end = False if we *must*; i.e., if the exclusion it would have
│ │          # added was not added by anybody else
│ │          for dihedral in deferred_dihedrals:
│ │              if (dihedral.atom1.idx, dihedral.atom4.idx) in set14:
│ │                  dihedral.ignore_end = True
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def strip(self, selection):
│ │          """
│ │          Deletes a subset of the atoms corresponding to an atom-based selection.
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -817,23 +843,23 @@
│ │          self.prune_empty_terms()
│ │          self.residues.prune()
│ │          self.unchange()
│ │          # Slice out coordinates if present
│ │          if self._coordinates is not None:
│ │              if PYPY:
│ │                  # numpypy does not currently support advanced indexing it seems
│ │ -                self._coordinates = np.array( # pragma: no cover
│ │ -                        [[[x, y, z] for i, (x, y, z) in enumerate(crd)
│ │ -                            if sel[i]==0] for crd in self._coordinates]
│ │ +                self._coordinates = np.array(  # pragma: no cover
│ │ +                    [[[x, y, z] for i, (x, y, z) in enumerate(crd)
│ │ +                      if sel[i] == 0] for crd in self._coordinates]
│ │                  )
│ │              else:
│ │                  # Pure numpy is faster in CPython, so do that when we can
│ │ -                self._coordinates = self._coordinates[:, np.array(sel)==0]
│ │ +                self._coordinates = self._coordinates[:, np.array(sel) == 0]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def assign_bonds(self, *reslibs):
│ │          """
│ │          Assigns bonds to all atoms based on the provided residue template
│ │          libraries. Atoms whose names are *not* in the templates, as well as
│ │          those residues for whom no template is found, is assigned to bonds based
│ │          on distances.
│ │ @@ -893,62 +919,64 @@
│ │                      pass
│ │              ntempl = _res_in_templlib(self.residues[i+1], all_residues)
│ │              if templ is None and ntempl is None:
│ │                  # Any cross-link here picked up later
│ │                  continue
│ │              if templ is None:
│ │                  if ntempl.head is None:
│ │ -                    continue # Next residue doesn't bond to the previous one
│ │ +                    continue  # Next residue doesn't bond to the previous one
│ │                  # See if any atom in templ is close enough to bond to the head
│ │                  # atom of the next residue's template
│ │                  for head in self.residues[i+1].atoms:
│ │                      if head.name == ntempl.head.name:
│ │                          break
│ │                  else:
│ │                      LOGGER.warning('Could not find the head atom of the next template! Bond '
│ │                                     'pattern may be wrong, which could lead to extra TER cards in a '
│ │                                     'PDB file')
│ │ -                    continue # head atom not found!
│ │ +                    continue  # head atom not found!
│ │                  for a in res.atoms:
│ │ -                    maxdist = STANDARD_BOND_LENGTHS_SQUARED[(a.atomic_number, head.atomic_number)]
│ │ +                    maxdist = STANDARD_BOND_LENGTHS_SQUARED[(
│ │ +                        a.atomic_number, head.atomic_number)]
│ │                      if distance2(a, head) < maxdist:
│ │                          if a not in head.bond_partners:
│ │                              self.bonds.append(Bond(a, head))
│ │                          break
│ │                  continue
│ │              if templ.tail is None:
│ │ -                continue # This residue does not bond with the next one
│ │ +                continue  # This residue does not bond with the next one
│ │              if ntempl is None:
│ │                  # See if any atom in the next residue is bonding distance away
│ │                  # from my tail
│ │                  for tail in res.atoms:
│ │                      if tail.name == templ.tail.name:
│ │                          break
│ │                  else:
│ │ -                    continue # tail not found
│ │ +                    continue  # tail not found
│ │                  for a in self.residues[i+1].atoms:
│ │ -                    maxdist = STANDARD_BOND_LENGTHS_SQUARED[(a.atomic_number, tail.atomic_number)]
│ │ +                    maxdist = STANDARD_BOND_LENGTHS_SQUARED[(
│ │ +                        a.atomic_number, tail.atomic_number)]
│ │                      if distance2(a, tail) < maxdist:
│ │                          if a not in tail.bond_partners:
│ │                              self.bonds.append(Bond(a, tail))
│ │                          break
│ │                  continue
│ │              if ntempl.head is None:
│ │ -                continue # Next residue does not bond with this one
│ │ +                continue  # Next residue does not bond with this one
│ │              # We have templates for both atoms, and both have a head and a tail
│ │              for tail in res.atoms:
│ │                  if tail.name == templ.tail.name:
│ │                      break
│ │              else:
│ │ -                continue # head could not be found
│ │ +                continue  # head could not be found
│ │              for head in self.residues[i+1].atoms:
│ │                  if head.name == ntempl.head.name:
│ │                      break
│ │              else:
│ │ -                continue # tail could not be found
│ │ +                continue  # tail could not be found
│ │              if head not in tail.bond_partners:
│ │                  self.bonds.append(Bond(head, tail))
│ │          # Now time to find bonds based on distance. First thing to do is to find
│ │          # all CYS residues and pull out those that have an SG atom with only 1
│ │          # bond partner, since those are *very* commonly bonded by
│ │          # post-translational modifications.
│ │          for res in self.residues:
│ │ @@ -972,15 +1000,16 @@
│ │          # atoms. So in this case (and this case only), look for bond partners in
│ │          # an 'assigned' residue (but only the same residue we are part of). One
│ │          # thing this misses is when the head or tail atom is misnamed.
│ │          mindist = math.sqrt(max(STANDARD_BOND_LENGTHS_SQUARED.values()))
│ │          pairs = find_atom_pairs(self, mindist, unassigned_atoms)
│ │          for atom in unassigned_atoms:
│ │              for partner in pairs[atom.idx]:
│ │ -                maxdist = STANDARD_BOND_LENGTHS_SQUARED[(atom.atomic_number, partner.atomic_number)]
│ │ +                maxdist = STANDARD_BOND_LENGTHS_SQUARED[(
│ │ +                    atom.atomic_number, partner.atomic_number)]
│ │                  if (distance2(atom, partner) < maxdist and atom not in partner.bond_partners):
│ │                      self.bonds.append(Bond(atom, partner))
│ │              # Now look through all atoms in this template if it's a template
│ │              # that's already been assigned. If it's already in an unassigned
│ │              # residue, then all that residue's atoms were in unassigned_atoms,
│ │              # so there's no need to look through the residue again. Also, we
│ │              # added cysteine SG atoms to the unassigned atoms list to see if it
│ │ @@ -988,20 +1017,21 @@
│ │              # template match for cysteine and SG was paired correctly. So don't
│ │              # try to assign it to bonds with other atoms in the cysteine here.
│ │              if atom.residue in unassigned_residues or atom in cysteine_sg:
│ │                  continue
│ │              for partner in atom.residue.atoms:
│ │                  if partner is atom:
│ │                      continue
│ │ -                maxdist = STANDARD_BOND_LENGTHS_SQUARED[(atom.atomic_number, partner.atomic_number)]
│ │ +                maxdist = STANDARD_BOND_LENGTHS_SQUARED[(
│ │ +                    atom.atomic_number, partner.atomic_number)]
│ │                  if (distance2(atom, partner) < maxdist and atom not in partner.bond_partners):
│ │                      self.bonds.append(Bond(atom, partner))
│ │          # All reasonable bonds have now been added
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def visualize(self, *args, **kwargs):
│ │          """Use nglview for visualization. This only works with Jupyter notebook
│ │          and require to install `nglview`
│ │  
│ │          Examples
│ │          --------
│ │ @@ -1014,15 +1044,15 @@
│ │          args and kwargs : positional and keyword arguments given to nglview, optional
│ │          """
│ │          if self.coordinates is None:
│ │              raise ValueError('coordinates must not be None')
│ │          from nglview import show_parmed
│ │          return show_parmed(self, *args, **kwargs)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __getitem__(self, selection):
│ │          """
│ │          Allows extracting a single atom from the structure or a slice of atoms
│ │          as a new Structure instance. The following syntaxes are allowed:
│ │  
│ │              - struct[str] : str is interpreted as an Amber selection mask
│ │ @@ -1086,21 +1116,24 @@
│ │          for i in range(1, len(selection)):
│ │              scan.append(scan[i-1] + selection[i])
│ │          # Zero-out the unselected atoms
│ │          scan = [x * y for x, y in zip(scan, selection)]
│ │          # Copy all parameters
│ │          struct = type(self)()
│ │          for i, atom in enumerate(self.atoms):
│ │ -            if not selection[i]: continue
│ │ +            if not selection[i]:
│ │ +                continue
│ │              res = atom.residue
│ │              if res.number == 0:
│ │                  num = res.idx
│ │              else:
│ │                  num = res.number
│ │ -            struct.add_atom(copy(atom), res.name, num, res.chain, res.insertion_code, res.segid)
│ │ +            struct.add_atom(copy(atom), res.name, num,
│ │ +                            res.chain, res.insertion_code, res.segid)
│ │ +
│ │          def copy_valence_terms(oval, otyp, sval, styp, atom_attrs, extra_attrs=None):
│ │              """ Copies the valence terms from one list to another;
│ │              oval=Other VALence; otyp=Other TYPe; sval=Self VALence;
│ │              styp=Self TYPe; attrlist=ATTRibute LIST (atom1, atom2, ...)
│ │              """
│ │              otypcp = [copy(typ) for typ in styp]
│ │              used_types = [False for typ in otypcp]
│ │ @@ -1109,23 +1142,24 @@
│ │                  # Make sure all of our atoms in this valence term is "selected"
│ │                  indices = [scan[at.idx] for at in ats if isinstance(at, Atom)]
│ │                  if not all(indices):
│ │                      continue
│ │                  # Add the type if applicable
│ │                  kws = dict()
│ │                  if hasattr(val, 'type') and val.type is NoUreyBradley:
│ │ -                    kws['type'] = NoUreyBradley # special-case singleton
│ │ +                    kws['type'] = NoUreyBradley  # special-case singleton
│ │                  elif otypcp and val.type is not None:
│ │                      kws['type'] = otypcp[val.type.idx]
│ │                      used_types[val.type.idx] = True
│ │                  for i, at in enumerate(ats):
│ │                      if isinstance(at, Atom):
│ │                          ats[i] = struct.atoms[scan[at.idx]-1]
│ │                  if extra_attrs:
│ │ -                    kws.update({attr: getattr(val, attr) for attr in extra_attrs})
│ │ +                    kws.update({attr: getattr(val, attr)
│ │ +                               for attr in extra_attrs})
│ │                  oval.append(type(val)(*ats, **kws))
│ │                  if hasattr(val, 'funct'):
│ │                      oval[-1].funct = val.funct
│ │              # Now tack on the "new" types copied from `other`
│ │              for used, typ in zip(used_types, otypcp):
│ │                  if used:
│ │                      otyp.append(typ)
│ │ @@ -1163,17 +1197,20 @@
│ │                             ['atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │          copy_valence_terms(struct.chiral_frames, [], self.chiral_frames, [],
│ │                             ['atom1', 'atom2', 'chirality'])
│ │          copy_valence_terms(struct.multipole_frames, [], self.multipole_frames, [],
│ │                             ['atom', 'frame_pt_num', 'vectail', 'vechead', 'nvec'])
│ │          copy_valence_terms(struct.adjusts, struct.adjust_types, self.adjusts,
│ │                             self.adjust_types, ['atom1', 'atom2'])
│ │ -        copy_valence_terms(struct.donors, [], self.donors, [], ['atom1', 'atom2'])
│ │ -        copy_valence_terms(struct.acceptors, [], self.acceptors, [], ['atom1', 'atom2'])
│ │ -        copy_valence_terms(struct.groups, [], self.groups, [], ['atom', 'type', 'move'])
│ │ +        copy_valence_terms(struct.donors, [], self.donors,
│ │ +                           [], ['atom1', 'atom2'])
│ │ +        copy_valence_terms(struct.acceptors, [],
│ │ +                           self.acceptors, [], ['atom1', 'atom2'])
│ │ +        copy_valence_terms(struct.groups, [], self.groups,
│ │ +                           [], ['atom', 'type', 'move'])
│ │          struct._box = self._box
│ │          struct.symmetry = self.symmetry
│ │          struct.space_group = self.space_group
│ │          return struct
│ │  
│ │      def _get_selection_array(self, selection):
│ │          """
│ │ @@ -1208,17 +1245,17 @@
│ │                  has_chain = False
│ │              elif len(selection) == 3:
│ │                  chainsel, ressel, atomsel = selection
│ │                  chainmap = defaultdict(TrackedList)
│ │                  for r in self.residues:
│ │                      chainmap[r.chain].append(r)
│ │                  if (isinstance(chainsel, str) and isinstance(ressel, int) and
│ │ -                    isinstance(atomsel, int)):
│ │ +                        isinstance(atomsel, int)):
│ │                      # Special-case single-atom selection for efficiency
│ │ -                    chainmap = dict(chainmap) # no longer defaultdict
│ │ +                    chainmap = dict(chainmap)  # no longer defaultdict
│ │                      try:
│ │                          return chainmap[chainsel][ressel][atomsel]
│ │                      except KeyError:
│ │                          raise IndexError('No chain %s in Structure' % chainsel)
│ │                  if isinstance(chainsel, str):
│ │                      if chainsel in chainmap:
│ │                          chainset = set([chainsel])
│ │ @@ -1260,66 +1297,68 @@
│ │                      # To allow us to index the atoms residues from their list of
│ │                      # chains, temporarily have the chainmap lists claim the
│ │                      # residues. This must be reversed or the Structure will be
│ │                      # broken
│ │                      for chain_name, chain in chainmap.items():
│ │                          chain.claim()
│ │                      selection = [
│ │ -                            (a.residue.chain in chainset) and
│ │ -                            (a.residue.name in resset or a.residue.idx in resset) and
│ │ -                            (a.name in atomset or a.idx-a.residue[0].idx in atomset)
│ │ +                        (a.residue.chain in chainset) and
│ │ +                        (a.residue.name in resset or a.residue.idx in resset) and
│ │ +                        (a.name in atomset or a.idx -
│ │ +                         a.residue[0].idx in atomset)
│ │  
│ │ -                            for a in self.atoms
│ │ +                        for a in self.atoms
│ │                      ]
│ │                  finally:
│ │                      # Make sure that the residues list *always* reclaims its
│ │                      # contents
│ │                      self.residues.claim()
│ │              else:
│ │                  selection = [
│ │                      (a.name in atomset or a.idx-a.residue[0].idx in atomset)
│ │                      and (a.residue.name in resset or a.residue.idx in resset)
│ │ -                            for a in self.atoms
│ │ +                    for a in self.atoms
│ │                  ]
│ │          else:
│ │              # Assume it is an iterable. If it is the same length as the atoms,
│ │              # it is a boolean mask array. Otherwise, it is a list of atom
│ │              # indices to select
│ │              sel = [0 for atom in self.atoms]
│ │              selection = list(selection)
│ │              if len(selection) == len(self.atoms):
│ │                  for i, val in enumerate(selection):
│ │ -                    if val: sel[i] = 1
│ │ +                    if val:
│ │ +                        sel[i] = 1
│ │              elif len(selection) > len(self.atoms):
│ │                  raise ValueError('Selection iterable is too long')
│ │              else:
│ │                  try:
│ │                      for val in selection:
│ │                          sel[val] = 1
│ │                  except IndexError:
│ │                      raise ValueError('Selected atom out of range')
│ │              selection = sel
│ │          # Make sure we have an integer array of 0s and 1s
│ │          return [int(bool(x)) for x in selection]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def view(self):
│ │          """
│ │          Returns an indexable object that can be indexed like a standard
│ │          Structure, but returns a *view* rather than a copy
│ │  
│ │          See Also
│ │          --------
│ │          Structure.__getitem__
│ │          """
│ │          return _StructureViewerCreator(self)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def split(self):
│ │          """
│ │          Split the current Structure into separate Structure instances for each
│ │          unique molecule. A molecule is defined as all atoms connected by a graph
│ │          of covalent bonds.
│ │  
│ │ @@ -1350,42 +1389,49 @@
│ │              # (i.e., just about every solvent out there)
│ │              if len(involved_residues) == 1:
│ │                  res = sel[0].residue
│ │                  names = tuple(a.name for a in res)
│ │                  charges = tuple('%.6f' % a.charge for a in res)
│ │                  rmins = tuple('%.6f' % a.rmin for a in res)
│ │                  epsilons = tuple('%.6f' % a.epsilon for a in res)
│ │ -                oneres_key = (res.name, len(res), names, charges, rmins, epsilons)
│ │ +                oneres_key = (res.name, len(res), names,
│ │ +                              charges, rmins, epsilons)
│ │                  if oneres_key in res_molecules:
│ │                      counts[res_molecules[oneres_key]].add(i)
│ │                      continue
│ │              is_duplicate = False
│ │              for j, struct in enumerate(structs):
│ │                  if len(struct.atoms) == len(sel):
│ │                      for a1, a2 in zip(struct.atoms, sel):
│ │ -                        assert None not in (a1.residue, a2.residue), 'Residues must all be set'
│ │ -                        if a1.residue.name != a2.residue.name: break
│ │ -                        if a1.name != a2.name: break
│ │ -                        if '%.6f' % a1.charge != '%.6f' % a2.charge: break
│ │ -                        if '%.6f' % a1.rmin != '%.6f' % a2.rmin: break
│ │ -                        if '%.6f' % a1.epsilon != '%.6f' % a2.epsilon: break
│ │ +                        assert None not in (
│ │ +                            a1.residue, a2.residue), 'Residues must all be set'
│ │ +                        if a1.residue.name != a2.residue.name:
│ │ +                            break
│ │ +                        if a1.name != a2.name:
│ │ +                            break
│ │ +                        if '%.6f' % a1.charge != '%.6f' % a2.charge:
│ │ +                            break
│ │ +                        if '%.6f' % a1.rmin != '%.6f' % a2.rmin:
│ │ +                            break
│ │ +                        if '%.6f' % a1.epsilon != '%.6f' % a2.epsilon:
│ │ +                            break
│ │                      else:
│ │                          counts[j].add(i)
│ │                          is_duplicate = True
│ │                          break
│ │              if not is_duplicate:
│ │                  if len(involved_residues) == 1:
│ │                      # Cache single-residue molecules
│ │                      res_molecules[oneres_key] = len(structs)
│ │                  mol = self[[atom.marked == i+1 for atom in self.atoms]]
│ │                  structs.append(mol)
│ │                  counts.append(set([i]))
│ │          return list(zip(structs, counts))
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def save(self, fname, format=None, overwrite=False, **kwargs):
│ │          """
│ │          Saves the current Structure in the requested file format. Supported
│ │          formats can be specified explicitly or determined by file-name
│ │          extension. The following formats are supported, with the recognized
│ │          suffix and ``format`` keyword shown in parentheses:
│ │ @@ -1430,41 +1476,42 @@
│ │          whatever reason
│ │          IOError if the file cannot be written either because it exists and
│ │          ``overwrite`` is ``False``, the filesystem is read-only, or write
│ │          permissions are not granted for the user
│ │          """
│ │          from . import amber, charmm, formats, gromacs, dlpoly
│ │          extmap = {
│ │ -                '.pdb' : 'PDB',
│ │ -                '.pqr' : 'PQR',
│ │ -                '.cif' : 'CIF',
│ │ -                '.pdbx' : 'CIF',
│ │ -                '.parm7' : 'AMBER',
│ │ -                '.prmtop' : 'AMBER',
│ │ -                '.psf' : 'PSF',
│ │ -                '.top' : 'GROMACS',
│ │ -                '.gro' : 'GRO',
│ │ -                '.field' : 'FIELD',
│ │ -                '.config' : 'CONFIG',
│ │ -                '.mol2' : 'MOL2',
│ │ -                '.mol3' : 'MOL3',
│ │ -                '.crd' : 'CHARMMCRD',
│ │ -                '.rst7' : 'RST7',
│ │ -                '.inpcrd' : 'RST7',
│ │ -                '.restrt' : 'RST7',
│ │ -                '.ncrst' : 'NCRST',
│ │ +            '.pdb': 'PDB',
│ │ +            '.pqr': 'PQR',
│ │ +            '.cif': 'CIF',
│ │ +            '.pdbx': 'CIF',
│ │ +            '.parm7': 'AMBER',
│ │ +            '.prmtop': 'AMBER',
│ │ +            '.psf': 'PSF',
│ │ +            '.top': 'GROMACS',
│ │ +            '.gro': 'GRO',
│ │ +            '.field': 'FIELD',
│ │ +            '.config': 'CONFIG',
│ │ +            '.mol2': 'MOL2',
│ │ +            '.mol3': 'MOL3',
│ │ +            '.crd': 'CHARMMCRD',
│ │ +            '.rst7': 'RST7',
│ │ +            '.inpcrd': 'RST7',
│ │ +            '.restrt': 'RST7',
│ │ +            '.ncrst': 'NCRST',
│ │          }
│ │          # Basically everybody uses atom type names instead of type indexes. So
│ │          # convert to atom type names and switch back if need be
│ │          if not hasattr(fname, 'write'):
│ │              if os.path.exists(fname) and not overwrite:
│ │                  raise IOError('%s exists; not overwriting' % fname)
│ │          else:
│ │              if format is None:
│ │ -                raise RuntimeError('Must provide supported format if using file-like object')
│ │ +                raise RuntimeError(
│ │ +                    'Must provide supported format if using file-like object')
│ │          all_ints = True
│ │          for atom in self.atoms:
│ │              if (isinstance(atom.type, int) and atom.atom_type is not UnassignedAtomType):
│ │                  atom.type = str(atom.atom_type)
│ │              else:
│ │                  all_ints = False
│ │          try:
│ │ @@ -1473,15 +1520,16 @@
│ │              else:
│ │                  base, ext = os.path.splitext(fname)
│ │                  if ext in ('.bz2', '.gz'):
│ │                      ext = os.path.splitext(base)[1]
│ │                  try:
│ │                      format = extmap[ext]
│ │                  except KeyError:
│ │ -                    raise ValueError('Could not determine file type of %s' % fname)
│ │ +                    raise ValueError(
│ │ +                        'Could not determine file type of %s' % fname)
│ │              # Dispatch
│ │              if format == 'PDB':
│ │                  self.write_pdb(fname, **kwargs)
│ │              elif format == 'CIF':
│ │                  self.write_cif(fname, **kwargs)
│ │              elif format == 'PQR':
│ │                  formats.PQRFile.write(self, fname, **kwargs)
│ │ @@ -1516,44 +1564,44 @@
│ │                  else:
│ │                      try:
│ │                          s = amber.AmberParm.from_structure(self)
│ │                      except TypeError as e:
│ │                          if 'Cannot translate exceptions' in str(e):
│ │                              s = amber.ChamberParm.from_structure(self)
│ │                          else:
│ │ -                            raise # pragma: no cover
│ │ +                            raise  # pragma: no cover
│ │                      s.write_parm(fname, **kwargs)
│ │              elif format in ('RST7', 'NCRST'):
│ │                  rst7 = amber.Rst7(natom=len(self.atoms), **kwargs)
│ │                  rst7.coordinates = self.coordinates
│ │                  rst7.vels = self.velocities
│ │                  rst7.box = self.box
│ │                  rst7.write(fname, netcdf=(format == 'NCRST'))
│ │              else:
│ │                  raise ValueError('No file type matching %s' % format)
│ │          finally:
│ │              if all_ints:
│ │                  for atom in self.atoms:
│ │                      atom.type = int(atom.atom_type)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def join_dihedrals(self):
│ │          """
│ │          Joins multi-term torsions into a single term and makes all of the
│ │          parameters DihedralTypeList instances. If any dihedrals are *already*
│ │          DihedralTypeList instances, or any are not parametrized, or there are no
│ │          dihedral_types, this method returns without doing anything
│ │          """
│ │          if not self.dihedral_types:
│ │ -            return # nothing to do
│ │ +            return  # nothing to do
│ │          if any(isinstance(t, DihedralTypeList) for t in self.dihedral_types):
│ │ -            return # already done
│ │ +            return  # already done
│ │          if any(d.type is None for d in self.dihedrals):
│ │ -            return # Not fully parametrized
│ │ +            return  # Not fully parametrized
│ │          dihedrals_to_delete = list()
│ │          dihedrals_processed = dict()
│ │          new_dihedral_types = TrackedList()
│ │          for i, d in enumerate(self.dihedrals):
│ │              if d.atom1 < d.atom4:
│ │                  key = (d.atom1, d.atom2, d.atom3, d.atom4)
│ │              else:
│ │ @@ -1569,43 +1617,42 @@
│ │          # Now drop the new dihedral types into place
│ │          self.dihedral_types = new_dihedral_types
│ │          # Remove the "duplicate" dihedrals
│ │          for i in reversed(dihedrals_to_delete):
│ │              self.dihedrals[i].delete()
│ │              del self.dihedrals[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def combining_rule(self):
│ │          return self._combining_rule
│ │  
│ │      @combining_rule.setter
│ │      def combining_rule(self, thing):
│ │          if thing not in ('lorentz', 'geometric'):
│ │              raise ValueError("combining_rule must be 'lorentz' or 'geometric'")
│ │          self._combining_rule = thing
│ │  
│ │ -
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def rdkit_mol(self):
│ │          if not self.is_changed:
│ │              try:
│ │                  return self._rdkit_mol
│ │              except AttributeError:
│ │                  pass
│ │          else:
│ │              self.prune_empty_terms()
│ │              self.unchange()
│ │          self._rdkit_mol = RDKit.to_mol(self)
│ │          return self._rdkit_mol
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      @needs_openmm
│ │      def topology(self):
│ │          """
│ │          The OpenMM Topology object. Cached when possible, but any changes to the
│ │          Structure instance results in the topology being deleted and rebuilt
│ │ @@ -1640,41 +1687,43 @@
│ │                  # See if we need a new chain
│ │                  if last_chain != atom.residue.chain:
│ │                      last_chain = atom.residue.chain
│ │                      chain = top.addChain()
│ │                  last_residue = atom.residue
│ │                  last_omm_residue = top.addResidue(atom.residue.name, chain)
│ │              try:
│ │ -                elem = app.element.Element.getByAtomicNumber(atom.atomic_number)
│ │ +                elem = app.element.Element.getByAtomicNumber(
│ │ +                    atom.atomic_number)
│ │              except KeyError:
│ │                  elem = None
│ │              top.addAtom(atom.name, elem, last_omm_residue)
│ │          # Add the bonds
│ │          atoms = list(top.atoms())
│ │          for bond in self.bonds:
│ │              top.addBond(atoms[bond.atom1.idx], atoms[bond.atom2.idx])
│ │          # Set the unit cell dimensions
│ │          if self.box is not None:
│ │              top.setPeriodicBoxVectors(
│ │ -                reducePeriodicBoxVectors(box_lengths_and_angles_to_vectors(*self.box))
│ │ +                reducePeriodicBoxVectors(
│ │ +                    box_lengths_and_angles_to_vectors(*self.box))
│ │              )
│ │          return top
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def positions(self):
│ │          """
│ │          A list of 3-element Quantity tuples of dimension length representing the
│ │          atomic positions for every atom in the system. If set with unitless
│ │          numbers, those numbers are assumed to be in angstroms. If any atoms do
│ │          not have coordinates, this is simply ``None``.
│ │          """
│ │          try:
│ │ -            return [Vec3(a.xx,a.xy,a.xz) for a in self.atoms] * u.angstroms
│ │ +            return [Vec3(a.xx, a.xy, a.xz) for a in self.atoms] * u.angstroms
│ │          except AttributeError:
│ │              return None
│ │  
│ │      @positions.setter
│ │      def positions(self, value):
│ │          """
│ │          A list of 3-element Quantity tuples of dimension length representing the
│ │ @@ -1838,15 +1887,15 @@
│ │                  raise IndexError('No unit cell frames present')
│ │              return None
│ │          elif frame == 'all':
│ │              return self._box
│ │          else:
│ │              return self._box[frame]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def velocities(self):
│ │          """
│ │          A (natom, 3)-shape numpy array with atomic velocities for every atom in
│ │          the system (in units of angstrom/picosecond), or None if there are no
│ │          velocities
│ │ @@ -1867,52 +1916,55 @@
│ │          if value is None:
│ │              for atom in self.atoms:
│ │                  try:
│ │                      del atom.vx, atom.vy, atom.vz
│ │                  except AttributeError:
│ │                      pass
│ │          else:
│ │ -            value = np.array(value, copy=False).reshape((-1,len(self.atoms),3))
│ │ +            value = np.array(value, copy=False).reshape(
│ │ +                (-1, len(self.atoms), 3))
│ │              for atom, xyz in zip(self.atoms, value[0]):
│ │                  atom.vx, atom.vy, atom.vz = xyz
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def has_NBFIX(self):
│ │          """
│ │          Returns whether or not any pairs of atom types have their LJ
│ │          interactions modified by an NBFIX definition
│ │  
│ │          Returns
│ │          -------
│ │          has_nbfix : bool
│ │              If True, at least two atom types have NBFIX mod definitions
│ │          """
│ │          typemap = dict()
│ │          for a in self.atoms:
│ │ -            if a.atom_type is UnassignedAtomType: continue
│ │ +            if a.atom_type is UnassignedAtomType:
│ │ +                continue
│ │              typemap[str(a.atom_type)] = a.atom_type
│ │          # Now we have a map of all atom types that we have defined in our
│ │          # system. Look through all of the atom types and see if any of their
│ │          # NBFIX definitions are also keys in typemap
│ │          for key, type in typemap.items():
│ │              for key in type.nbfix:
│ │                  if key in typemap:
│ │                      return True
│ │          return False
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @property
│ │      def box_vectors(self):
│ │          """
│ │          3, 3-element tuple of unit cell vectors that are Quantity objects of
│ │          dimension length
│ │          """
│ │ -        if self._box is None: return None
│ │ +        if self._box is None:
│ │ +            return None
│ │          return box_lengths_and_angles_to_vectors(*self.box)
│ │  
│ │      @box_vectors.setter
│ │      def box_vectors(self, value):
│ │          """
│ │          3, 3-element tuple of unit cell vectors that are Quantity objects of
│ │          dimension length
│ │ @@ -1922,15 +1974,15 @@
│ │          b = b.value_in_unit(u.angstroms)
│ │          c = c.value_in_unit(u.angstroms)
│ │          A = A.value_in_unit(u.degrees)
│ │          B = B.value_in_unit(u.degrees)
│ │          G = G.value_in_unit(u.degrees)
│ │          self._box = np.array([[a, b, c, A, B, G]], dtype=np.float64)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def createSystem(self, nonbondedMethod=None,
│ │                       nonbondedCutoff=8.0*u.angstroms,
│ │                       switchDistance=0.0*u.angstroms,
│ │                       constraints=None,
│ │                       rigidWater=True,
│ │ @@ -2050,19 +2102,22 @@
│ │          self.omm_add_constraints(system, constraints, rigidWater)
│ │          # Prune empty terms if we have changed
│ │          if self.is_changed():
│ │              self.prune_empty_terms()
│ │              self.unchange()
│ │          # Add the various types of forces
│ │          LOGGER.info('Adding bonds...')
│ │ -        self._add_force_to_system(system, self.omm_bond_force(constraints, rigidWater, flexibleConstraints))
│ │ +        self._add_force_to_system(system, self.omm_bond_force(
│ │ +            constraints, rigidWater, flexibleConstraints))
│ │          LOGGER.info('Adding angles...')
│ │ -        self._add_force_to_system(system, self.omm_angle_force(constraints, flexibleConstraints))
│ │ +        self._add_force_to_system(system, self.omm_angle_force(
│ │ +            constraints, flexibleConstraints))
│ │          LOGGER.info('Adding dihedrals...')
│ │ -        self._add_force_to_system(system, self.omm_dihedral_force(splitDihedrals))
│ │ +        self._add_force_to_system(
│ │ +            system, self.omm_dihedral_force(splitDihedrals))
│ │          LOGGER.info('Adding Ryckaert-Bellemans torsions...')
│ │          self._add_force_to_system(system, self.omm_rb_torsion_force())
│ │          LOGGER.info('Adding Urey-Bradleys...')
│ │          self._add_force_to_system(system, self.omm_urey_bradley_force())
│ │          LOGGER.info('Adding improper torsions...')
│ │          self._add_force_to_system(system, self.omm_improper_force())
│ │          LOGGER.info('Adding CMAP torsions...')
│ │ @@ -2079,33 +2134,35 @@
│ │          self._add_force_to_system(system, self.omm_torsion_torsion_force())
│ │          LOGGER.info('Adding Nonbonded force...')
│ │          if implicitSolvent is not None:
│ │              rf_dielc = 1.0
│ │          else:
│ │              rf_dielc = 78.5
│ │          self._add_force_to_system(system,
│ │ -            self.omm_nonbonded_force(nonbondedMethod, nonbondedCutoff, switchDistance, ewaldErrorTolerance, rf_dielc)
│ │ -        )
│ │ +                                  self.omm_nonbonded_force(
│ │ +                                      nonbondedMethod, nonbondedCutoff, switchDistance, ewaldErrorTolerance, rf_dielc)
│ │ +                                  )
│ │          if implicitSolvent is not None:
│ │              LOGGER.info('Adding GB force...')
│ │              self._add_force_to_system(system,
│ │ -                self.omm_gbsa_force(implicitSolvent, nonbondedMethod, nonbondedCutoff,
│ │ -                                    soluteDielectric, solventDielectric, implicitSolventKappa,
│ │ -                                    implicitSolventSaltConc, temperature, useSASA)
│ │ -            )
│ │ +                                      self.omm_gbsa_force(implicitSolvent, nonbondedMethod, nonbondedCutoff,
│ │ +                                                          soluteDielectric, solventDielectric, implicitSolventKappa,
│ │ +                                                          implicitSolventSaltConc, temperature, useSASA)
│ │ +                                      )
│ │          if removeCMMotion:
│ │              system.addForce(mm.CMMotionRemover())
│ │          if self.box is not None:
│ │ -            system.setDefaultPeriodicBoxVectors(*reducePeriodicBoxVectors(self.box_vectors))
│ │ +            system.setDefaultPeriodicBoxVectors(
│ │ +                *reducePeriodicBoxVectors(self.box_vectors))
│ │          self.omm_set_virtual_sites(system)
│ │          if any(isinstance(atom, DrudeAtom) for atom in self.atoms):
│ │              self._add_force_to_system(system, self.omm_drude_force(drudeMass))
│ │          return system
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_add_constraints(self, system, constraints, rigidWater):
│ │          """ Adds constraints to a given system
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -2117,64 +2174,78 @@
│ │              If True, water bonds are constrained regardless of whether
│ │              constrains is None
│ │          """
│ │  
│ │          if constraints is None and not rigidWater:
│ │              return
│ │          if constraints not in (None, app.HBonds, app.AllBonds, app.HAngles):
│ │ -            raise ValueError(f"Unrecognized constraints option ({constraints})")
│ │ +            raise ValueError(
│ │ +                f"Unrecognized constraints option ({constraints})")
│ │  
│ │          length_conv = u.angstrom.conversion_factor_to(u.nanometer)
│ │  
│ │          constraint_bond_set = set()
│ │          constraint_angle_set = set()
│ │          is_water = _settler(self)
│ │  
│ │          if constraints is app.AllBonds or constraints is app.HAngles:
│ │              for bond in self.bonds:
│ │                  # Skip all extra points... don't constrain those
│ │ -                if isinstance(bond.atom1, ExtraPoint): continue
│ │ -                if isinstance(bond.atom2, ExtraPoint): continue
│ │ -                atom1, atom2 = min(bond.atom1, bond.atom2), max(bond.atom1, bond.atom2)
│ │ +                if isinstance(bond.atom1, ExtraPoint):
│ │ +                    continue
│ │ +                if isinstance(bond.atom2, ExtraPoint):
│ │ +                    continue
│ │ +                atom1, atom2 = min(bond.atom1, bond.atom2), max(
│ │ +                    bond.atom1, bond.atom2)
│ │                  constraint_bond_set.add(frozenset((atom1.idx, atom2.idx)))
│ │          elif constraints is app.HBonds:
│ │              for bond in self.bonds:
│ │ -                if isinstance(bond.atom1, ExtraPoint): continue
│ │ -                if isinstance(bond.atom2, ExtraPoint): continue
│ │ +                if isinstance(bond.atom1, ExtraPoint):
│ │ +                    continue
│ │ +                if isinstance(bond.atom2, ExtraPoint):
│ │ +                    continue
│ │                  if bond.atom1.element == 1 or bond.atom2.element == 1:
│ │ -                    atom1, atom2 = min(bond.atom1, bond.atom2), max(bond.atom1, bond.atom2)
│ │ +                    atom1, atom2 = min(bond.atom1, bond.atom2), max(
│ │ +                        bond.atom1, bond.atom2)
│ │                      constraint_bond_set.add(frozenset((atom1.idx, atom2.idx)))
│ │          if rigidWater:
│ │              for bond in self.bonds:
│ │ -                if isinstance(bond.atom1, ExtraPoint): continue
│ │ -                if isinstance(bond.atom2, ExtraPoint): continue
│ │ +                if isinstance(bond.atom1, ExtraPoint):
│ │ +                    continue
│ │ +                if isinstance(bond.atom2, ExtraPoint):
│ │ +                    continue
│ │                  if is_water[bond.atom1.residue.idx]:
│ │ -                    atom1, atom2 = min(bond.atom1, bond.atom2), max(bond.atom1, bond.atom2)
│ │ +                    atom1, atom2 = min(bond.atom1, bond.atom2), max(
│ │ +                        bond.atom1, bond.atom2)
│ │                      constraint_bond_set.add(frozenset((atom1.idx, atom2.idx)))
│ │  
│ │          # Add bond constraints
│ │          for bond in self.bonds:
│ │              if frozenset((bond.atom1.idx, bond.atom2.idx)) in constraint_bond_set:
│ │ -                system.addConstraint(bond.atom1.idx, bond.atom2.idx, bond.type.req * length_conv)
│ │ +                system.addConstraint(
│ │ +                    bond.atom1.idx, bond.atom2.idx, bond.type.req * length_conv)
│ │  
│ │          if constraints is app.HAngles:
│ │              for angle in self.angles:
│ │                  numH = 0
│ │                  if angle.atom1.element == 1:
│ │                      numH += 1
│ │                  if angle.atom3.element == 1:
│ │                      numH += 1
│ │                  if numH == 2 or (numH == 1 and angle.atom2.element == 8):
│ │ -                    atom1, atom2, atom3 = min(angle.atom1, angle.atom3), angle.atom2, max(angle.atom1, angle.atom3)
│ │ +                    atom1, atom2, atom3 = min(angle.atom1, angle.atom3), angle.atom2, max(
│ │ +                        angle.atom1, angle.atom3)
│ │                      constraint_angle_set.add((atom1.idx, atom2.idx, atom3.idx))
│ │          if rigidWater:
│ │              for angle in self.angles:
│ │                  if is_water[angle.atom1.residue.idx]:
│ │ -                    atom1, atom2, atom3 = min(angle.atom1, angle.atom3), angle.atom2, max(angle.atom1, angle.atom3)
│ │ -                    constraint_angle_set.add((angle.atom1.idx, angle.atom2.idx, angle.atom3.idx))
│ │ +                    atom1, atom2, atom3 = min(angle.atom1, angle.atom3), angle.atom2, max(
│ │ +                        angle.atom1, angle.atom3)
│ │ +                    constraint_angle_set.add(
│ │ +                        (angle.atom1.idx, angle.atom2.idx, angle.atom3.idx))
│ │          # Add angle constraints
│ │          for angle in self.angles:
│ │              if (angle.atom1.idx, angle.atom2.idx, angle.atom3.idx) in constraint_angle_set:
│ │                  if frozenset((angle.atom1.idx, angle.atom3.idx)) in constraint_bond_set:
│ │                      continue
│ │                  if frozenset((angle.atom3.idx, angle.atom1.idx)) in constraint_bond_set:
│ │                      continue
│ │ @@ -2182,19 +2253,20 @@
│ │                  l1 = l2 = None
│ │                  for bond in angle.atom2.bonds:
│ │                      if bond in angle and angle.atom1 in bond:
│ │                          l1 = bond.type.req * length_conv
│ │                      elif bond in angle and angle.atom3 in bond:
│ │                          l2 = bond.type.req * length_conv
│ │                  # Law of cosines to find the constraint distance
│ │ -                if l1 is None or l2 is None: continue  # no bonds found...
│ │ +                if l1 is None or l2 is None:
│ │ +                    continue  # no bonds found...
│ │                  cost = math.cos(angle.type.theteq * DEG_TO_RAD)
│ │                  length = math.sqrt(l1 * l1 + l2 * l2 - 2 * l1 * l2 * cost)
│ │                  system.addConstraint(angle.atom1.idx, angle.atom3.idx, length)
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_set_virtual_sites(self, system):
│ │          """
│ │          Sets the virtual sites in a given OpenMM `System` object from the extra
│ │          points defined in this system
│ │  
│ │ @@ -2213,39 +2285,44 @@
│ │              # This is a virtual site... get its frame type
│ │              typ = atom.frame_type
│ │              weights = typ.get_weights()
│ │              refatoms = typ.get_atoms()
│ │              if isinstance(typ, TwoParticleExtraPointFrame):
│ │                  a1, a2 = refatoms
│ │                  w1, w2 = weights
│ │ -                system.setVirtualSite(atom.idx, mm.TwoParticleAverageSite(a1.idx, a2.idx, w1, w2))
│ │ +                system.setVirtualSite(
│ │ +                    atom.idx, mm.TwoParticleAverageSite(a1.idx, a2.idx, w1, w2))
│ │              elif isinstance(typ, ThreeParticleExtraPointFrame):
│ │                  a1, a2, a3 = refatoms
│ │                  w1, w2, w3 = weights
│ │                  system.setVirtualSite(
│ │ -                    atom.idx, mm.ThreeParticleAverageSite(a1.idx, a2.idx, a3.idx, w1, w2, w3)
│ │ +                    atom.idx, mm.ThreeParticleAverageSite(
│ │ +                        a1.idx, a2.idx, a3.idx, w1, w2, w3)
│ │                  )
│ │              elif isinstance(typ, OutOfPlaneExtraPointFrame):
│ │                  a1, a2, a3 = refatoms
│ │                  w1, w2, w3 = weights
│ │                  system.setVirtualSite(
│ │ -                    atom.idx, mm.OutOfPlaneSite(a1.idx, a2.idx, a3.idx, w1, w2, w3)
│ │ +                    atom.idx, mm.OutOfPlaneSite(
│ │ +                        a1.idx, a2.idx, a3.idx, w1, w2, w3)
│ │                  )
│ │              elif isinstance(typ, LocalCoordinatesFrame):
│ │                  a1, a2, a3 = refatoms
│ │                  origin_weights, x_weights, y_weights, local_position = weights
│ │                  # Convert positions to nanometers
│ │                  position_nm = [0.1 * position for position in local_position]
│ │                  system.setVirtualSite(
│ │ -                    atom.idx, mm.LocalCoordinatesSite(a1.idx, a2.idx, a3.idx, origin_weights, x_weights, y_weights, position_nm)
│ │ +                    atom.idx, mm.LocalCoordinatesSite(
│ │ +                        a1.idx, a2.idx, a3.idx, origin_weights, x_weights, y_weights, position_nm)
│ │                  )
│ │              else:
│ │ -                raise RuntimeError(f"Did not recognize frame type {type(typ).__name__}")
│ │ +                raise RuntimeError(
│ │ +                    f"Did not recognize frame type {type(typ).__name__}")
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_bond_force(self, constraints=None, rigidWater=True, flexibleConstraints=True):
│ │          """
│ │          Creates an OpenMM Bond Force object (or AmoebaBondForce if the bonds are
│ │          for an Amoeba-parametrized system)
│ │  
│ │ @@ -2264,23 +2341,24 @@
│ │          Returns
│ │          -------
│ │          force
│ │              HarmonicBondForce (or AmoebaBondForce if this is an Amoeba system),
│ │              or None if there are no bonds to add
│ │          """
│ │          if not flexibleConstraints and constraints in (app.HAngles,
│ │ -                app.AllBonds) or not self.bonds:
│ │ -            return None # No bonds to add
│ │ +                                                       app.AllBonds) or not self.bonds:
│ │ +            return None  # No bonds to add
│ │          length_conv = u.angstroms.conversion_factor_to(u.nanometers)
│ │          _ambfrc = u.kilocalorie_per_mole/u.angstrom**2
│ │          _ommfrc = u.kilojoule_per_mole/u.nanometer**2
│ │          frc_conv = _ambfrc.conversion_factor_to(_ommfrc)
│ │          # See if we need to add Amoeba bonds or regular bonds
│ │          if hasattr(self.bond_types, 'degree') and hasattr(self.bond_types, 'coeffs'):
│ │ -            energy = "k*(d^2 + %s*d^3 + %s*d^4); d=r-r0" % (self.bond_types.coeffs[3]/length_conv, self.bond_types.coeffs[4]/length_conv**2)
│ │ +            energy = "k*(d^2 + %s*d^3 + %s*d^4); d=r-r0" % (
│ │ +                self.bond_types.coeffs[3]/length_conv, self.bond_types.coeffs[4]/length_conv**2)
│ │              force = mm.CustomBondForce(energy)
│ │              force.addPerBondParameter('r0')
│ │              force.addPerBondParameter('k')
│ │              force.setName('AmoebaBond')
│ │          else:
│ │              force = mm.HarmonicBondForce()
│ │          force.setForceGroup(self.BOND_FORCE_GROUP)
│ │ @@ -2307,15 +2385,15 @@
│ │                  force.addBond(bond.atom1.idx, bond.atom2.idx, (bond.type.req*length_conv,
│ │                                2*bond.type.k*frc_conv))
│ │          # Done adding the force
│ │          if force.getNumBonds() == 0:
│ │              return None
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_angle_force(self, constraints=None, flexibleConstraints=True):
│ │          """
│ │          Creates an OpenMM HarmonicAngleForce object (or AmoebaAngleForce if the
│ │          angles are for an Amoeba-parametrized system)
│ │  
│ │ @@ -2331,45 +2409,47 @@
│ │  
│ │          Returns
│ │          -------
│ │          force
│ │              HarmonicAngleForce (or AmoebaAngleForce if this is an Amoeba
│ │              system), or None if there are no angles to add
│ │          """
│ │ -        if not self.angles: return None
│ │ +        if not self.angles:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          if (hasattr(self.angle_types, 'degree') and
│ │                  hasattr(self.angle_types, 'coeffs')):
│ │              c = self.angle_types.coeffs
│ │ -            energy = "k*(d^2 + %s*d^3 + %s*d^4 + %s*d^5 + %s*d^6); d=%.15g*theta-theta0" % (c[3], c[4], c[5], c[6], 180/math.pi)
│ │ +            energy = "k*(d^2 + %s*d^3 + %s*d^4 + %s*d^5 + %s*d^6); d=%.15g*theta-theta0" % (
│ │ +                c[3], c[4], c[5], c[6], 180/math.pi)
│ │              force = mm.CustomAngleForce(energy)
│ │              force.addPerAngleParameter('theta0')
│ │              force.addPerAngleParameter('k')
│ │              force.setName('AmoebaAngle')
│ │          else:
│ │              force = mm.HarmonicAngleForce()
│ │          force.setForceGroup(self.ANGLE_FORCE_GROUP)
│ │          for angle in self.angles:
│ │              num_h = (angle.atom1.element == 1) + (angle.atom3.element == 1)
│ │              if constraints is app.HAngles and (num_h == 2 or (num_h == 1 and
│ │ -                    angle.atom2.element == 8) and not flexibleConstraints):
│ │ -                continue # pragma: no cover
│ │ +                                                              angle.atom2.element == 8) and not flexibleConstraints):
│ │ +                continue  # pragma: no cover
│ │              if angle.type is None:
│ │                  raise ParameterError('Cannot find angle parameters')
│ │              if isinstance(force, mm.HarmonicAngleForce):
│ │                  force.addAngle(angle.atom1.idx, angle.atom2.idx, angle.atom3.idx,
│ │                                 angle.type.theteq*DEG_TO_RAD, 2*angle.type.k*frc_conv)
│ │              else:
│ │                  force.addAngle(angle.atom1.idx, angle.atom2.idx, angle.atom3.idx,
│ │                                 (angle.type.theteq*DEG_TO_RAD, 2*angle.type.k*frc_conv))
│ │          if force.getNumAngles() == 0:
│ │              return None
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_dihedral_force(self, split=False):
│ │          """ Creates the OpenMM PeriodicTorsionForce modeling dihedrals
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -2380,15 +2460,16 @@
│ │              returned.
│ │  
│ │          Returns
│ │          -------
│ │          PeriodicTorsionForce[, PeriodicTorsionForce]
│ │              Or None if no torsions are present in this system
│ │          """
│ │ -        if not self.dihedrals: return None
│ │ +        if not self.dihedrals:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          proper = mm.PeriodicTorsionForce()
│ │          improper = mm.PeriodicTorsionForce()
│ │          proper.setForceGroup(self.DIHEDRAL_FORCE_GROUP)
│ │          improper.setForceGroup(self.IMPROPER_FORCE_GROUP)
│ │          for tor in self.dihedrals:
│ │              if tor.type is None:
│ │ @@ -2407,103 +2488,107 @@
│ │                                   tor.type.phi_k*frc_conv)
│ │          if proper.getNumTorsions() == 0:
│ │              return improper
│ │          if improper.getNumTorsions() == 0:
│ │              return proper
│ │          return proper, improper
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_rb_torsion_force(self):
│ │          """ Creates the OpenMM RBTorsionForce for Ryckaert-Bellemans torsions
│ │  
│ │          Returns
│ │          -------
│ │          RBTorsionForce
│ │              Or None if no torsions are present in this system
│ │          """
│ │ -        if not self.rb_torsions: return None
│ │ +        if not self.rb_torsions:
│ │ +            return None
│ │          conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          force = mm.RBTorsionForce()
│ │          force.setForceGroup(self.RB_TORSION_FORCE_GROUP)
│ │          for tor in self.rb_torsions:
│ │              if tor.type is None:
│ │                  raise ParameterError('Cannot find R-B torsion parameters')
│ │              force.addTorsion(tor.atom1.idx, tor.atom2.idx, tor.atom3.idx, tor.atom4.idx,
│ │                               tor.type.c0*conv, tor.type.c1*conv, tor.type.c2*conv,
│ │                               tor.type.c3*conv, tor.type.c4*conv, tor.type.c5*conv)
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_urey_bradley_force(self):
│ │          """ Creates the OpenMM Urey-Bradley force
│ │  
│ │          Returns
│ │          -------
│ │          HarmonicBondForce
│ │              Or None, if no urey-bradleys are present
│ │          """
│ │ -        if not self.urey_bradleys: return None
│ │ +        if not self.urey_bradleys:
│ │ +            return None
│ │          length_conv = u.angstroms.conversion_factor_to(u.nanometers)
│ │          _ambfrc = u.kilocalorie_per_mole/u.angstrom**2
│ │          _ommfrc = u.kilojoule_per_mole/u.nanometer**2
│ │          frc_conv = _ambfrc.conversion_factor_to(_ommfrc)
│ │          force = mm.HarmonicBondForce()
│ │          force.setForceGroup(self.UREY_BRADLEY_FORCE_GROUP)
│ │          for urey in self.urey_bradleys:
│ │              if urey.type is None:
│ │                  raise ParameterError('Cannot find urey-bradley parameters')
│ │              force.addBond(urey.atom1.idx, urey.atom2.idx, urey.type.req*length_conv,
│ │                            2*urey.type.k*frc_conv)
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_improper_force(self):
│ │          """ Creates the OpenMM improper torsion force (quadratic bias)
│ │  
│ │          Returns
│ │          -------
│ │          CustomTorsionForce
│ │              With the formula k*(phi-phi0)^2, or None if there are no impropers
│ │          """
│ │ -        if not self.impropers: return None
│ │ +        if not self.impropers:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          energy_function = 'k*dtheta_torus^2;'
│ │          energy_function += 'dtheta_torus = dtheta - floor(dtheta/(2*pi)+0.5)*(2*pi);'
│ │          energy_function += 'dtheta = theta - theta0;'
│ │          energy_function += 'pi = %f;' % math.pi
│ │          force = mm.CustomTorsionForce(energy_function)
│ │          force.addPerTorsionParameter('k')
│ │          force.addPerTorsionParameter('theta0')
│ │          force.setForceGroup(self.IMPROPER_FORCE_GROUP)
│ │          for imp in self.impropers:
│ │              if imp.type is None:
│ │                  raise ParameterError('Cannot find improper torsion parameters')
│ │              force.addTorsion(imp.atom1.idx, imp.atom2.idx, imp.atom3.idx,
│ │                               imp.atom4.idx, (imp.type.psi_k*frc_conv,
│ │ -                             imp.type.psi_eq*DEG_TO_RAD))
│ │ +                                             imp.type.psi_eq*DEG_TO_RAD))
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_cmap_force(self):
│ │          """ Creates the OpenMM CMAP torsion force
│ │  
│ │          Returns
│ │          -------
│ │          CMAPTorsionForce
│ │              Or None, if no CMAP terms are present
│ │          """
│ │ -        if not self.cmaps: return None
│ │ +        if not self.cmaps:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          force = mm.CMAPTorsionForce()
│ │          force.setForceGroup(self.CMAP_FORCE_GROUP)
│ │          # First get the list of cmap maps we're going to use. Just store the IDs
│ │          # so we have simple integer comparisons to do later
│ │          cmap_type_list = []
│ │          cmap_map = dict()
│ │ @@ -2522,15 +2607,15 @@
│ │          # Now add all of the cmaps
│ │          for cmap in self.cmaps:
│ │              force.addTorsion(cmap_map[id(cmap.type)], cmap.atom1.idx, cmap.atom2.idx,
│ │                               cmap.atom3.idx, cmap.atom4.idx, cmap.atom2.idx, cmap.atom3.idx,
│ │                               cmap.atom4.idx, cmap.atom5.idx)
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_nonbonded_force(self, nonbondedMethod=None, nonbondedCutoff=8*u.angstroms,
│ │                              switchDistance=0*u.angstroms, ewaldErrorTolerance=0.0005,
│ │                              reactionFieldDielectric=78.5):
│ │          """ Creates the OpenMM NonbondedForce instance
│ │  
│ │ @@ -2567,15 +2652,16 @@
│ │          Subclasses of Structure for which this nonbonded treatment is inadequate
│ │          should override this method to implement what is needed.
│ │  
│ │          If nrexcl is set to 3 and no exception parameters are stored in the
│ │          adjusts list, the 1-4 interactions are determined from the list of
│ │          dihedrals
│ │          """
│ │ -        if not self.atoms: return None
│ │ +        if not self.atoms:
│ │ +            return None
│ │          length_conv = u.angstrom.conversion_factor_to(u.nanometer)
│ │          ene_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          force = mm.NonbondedForce()
│ │          force.setForceGroup(self.NONBONDED_FORCE_GROUP)
│ │          if u.is_quantity(nonbondedCutoff):
│ │              nonbondedCutoff = nonbondedCutoff.value_in_unit(u.nanometers)
│ │          if nonbondedMethod is None or nonbondedMethod is app.NoCutoff:
│ │ @@ -2595,97 +2681,112 @@
│ │              force.setCutoffDistance(nonbondedCutoff)
│ │              force.setEwaldErrorTolerance(ewaldErrorTolerance)
│ │          elif nonbondedMethod is app.Ewald:
│ │              force.setNonbondedMethod(mm.NonbondedForce.Ewald)
│ │              force.setCutoffDistance(nonbondedCutoff)
│ │              force.setEwaldErrorTolerance(ewaldErrorTolerance)
│ │          else:
│ │ -            raise ValueError(f'Unrecognized nonbondedMethod ({nonbondedMethod})')
│ │ +            raise ValueError(
│ │ +                f'Unrecognized nonbondedMethod ({nonbondedMethod})')
│ │          force.setReactionFieldDielectric(reactionFieldDielectric)
│ │          # Now add the particles
│ │          sigma_scale = length_conv * 2 * 2**(-1/6)
│ │          for atom in self.atoms:
│ │ -            force.addParticle(atom.charge, atom.sigma*length_conv, abs(atom.epsilon*ene_conv))
│ │ +            force.addParticle(atom.charge, atom.sigma *
│ │ +                              length_conv, abs(atom.epsilon*ene_conv))
│ │          # Add exclusions from the bond graph out to nrexcl-1 bonds away (atoms
│ │          # nrexcl bonds away will be exceptions defined later)
│ │ +
│ │          def exclude_to(origin, atom, level, end):
│ │ -            if level >= end: return
│ │ +            if level >= end:
│ │ +                return
│ │              for partner in atom.bond_partners:
│ │ -                if partner is origin: continue
│ │ +                if partner is origin:
│ │ +                    continue
│ │                  if atom is not origin:
│ │ -                    force.addException(origin.idx, atom.idx, 0.0, 0.5, 0.0, True)
│ │ +                    force.addException(origin.idx, atom.idx,
│ │ +                                       0.0, 0.5, 0.0, True)
│ │                  # Exclude EP children, too
│ │                  for child in origin.children:
│ │ -                    force.addException(partner.idx, child.idx, 0.0, 0.5, 0.0, True)
│ │ +                    force.addException(
│ │ +                        partner.idx, child.idx, 0.0, 0.5, 0.0, True)
│ │                  for child in partner.children:
│ │ -                    force.addException(child.idx, origin.idx, 0.0, 0.5, 0.0, True)
│ │ +                    force.addException(child.idx, origin.idx,
│ │ +                                       0.0, 0.5, 0.0, True)
│ │                  for child in origin.children:
│ │                      for child2 in partner.children:
│ │ -                        force.addException(child.idx, child2.idx, 0.0, 0.5, 0.0, True)
│ │ +                        force.addException(
│ │ +                            child.idx, child2.idx, 0.0, 0.5, 0.0, True)
│ │                  exclude_to(origin, partner, level+1, end)
│ │          for atom in self.atoms:
│ │              exclude_to(atom, atom, 0, self.nrexcl)
│ │          # Add the exceptions from the dihedral list IFF no explicit exceptions
│ │          # (or *adjusts*) have been specified. If dihedral.ignore_end is False, a
│ │          # 1-4 with the appropriate scaling factor is used as the exception.
│ │          sigma_scale = 2**(-1/6) * length_conv
│ │          if self.combining_rule == 'lorentz':
│ │ -            comb_sig = lambda sig1, sig2: 0.5 * (sig1 + sig2)
│ │ +            def comb_sig(sig1, sig2): return 0.5 * (sig1 + sig2)
│ │          elif self.combining_rule == 'geometric':
│ │ -            comb_sig = lambda sig1, sig2: math.sqrt(sig1 * sig2)
│ │ +            def comb_sig(sig1, sig2): return math.sqrt(sig1 * sig2)
│ │          if not self.adjusts:
│ │              for dih in self.dihedrals + self.rb_torsions:
│ │ -                if dih.ignore_end: continue
│ │ +                if dih.ignore_end:
│ │ +                    continue
│ │                  if isinstance(dih.type, DihedralTypeList):
│ │                      scee = scnb = 0
│ │                      i = 0
│ │                      while (scee == 0 or scnb == 0) and i < len(dih.type):
│ │                          scee = dih.type[i].scee
│ │                          scnb = dih.type[i].scnb
│ │                          i += 1
│ │                      if scee == 0 or scnb == 0:
│ │                          raise ValueError('Detected scaling constants of 0 for '
│ │                                           'dihedral containing 1-4 info!')
│ │                  else:
│ │                      scee = dih.type.scee
│ │                      scnb = dih.type.scnb
│ │                  try:
│ │ -                    rij, wdij, rij14, wdij14 = dih.atom1.atom_type.nbfix[str(dih.atom4.atom_type)]
│ │ +                    rij, wdij, rij14, wdij14 = dih.atom1.atom_type.nbfix[str(
│ │ +                        dih.atom4.atom_type)]
│ │                  except (KeyError, AttributeError):
│ │                      epsprod = abs(dih.atom1.epsilon_14 * dih.atom4.epsilon_14)
│ │                      epsprod = math.sqrt(epsprod) * ene_conv / scnb
│ │                      sigprod = comb_sig(dih.atom1.sigma_14, dih.atom4.sigma_14)
│ │                      sigprod *= length_conv
│ │                  else:
│ │                      epsprod = wdij14 * ene_conv / scnb
│ │                      sigprod = rij14 * length_conv * sigma_scale
│ │                  chgprod = dih.atom1.charge * dih.atom4.charge / scee
│ │ -                force.addException(dih.atom1.idx, dih.atom4.idx, chgprod, sigprod, epsprod, True)
│ │ +                force.addException(dih.atom1.idx, dih.atom4.idx,
│ │ +                                   chgprod, sigprod, epsprod, True)
│ │                  for child in dih.atom1.children:
│ │                      epsprod = abs(child.epsilon_14 * dih.atom4.epsilon_14)
│ │                      epsprod = math.sqrt(epsprod) * ene_conv / scnb
│ │                      sigprod = comb_sig(child.sigma_14, dih.atom4.sigma_14)
│ │                      sigprod *= length_conv
│ │                      chgprod = (child.charge * dih.atom4.charge) / scee
│ │ -                    force.addException(child.idx, dih.atom4.idx, chgprod, sigprod, epsprod, True)
│ │ +                    force.addException(
│ │ +                        child.idx, dih.atom4.idx, chgprod, sigprod, epsprod, True)
│ │                  for child in dih.atom4.children:
│ │                      epsprod = abs(child.epsilon_14 * dih.atom1.epsilon_14)
│ │                      epsprod = math.sqrt(epsprod) * ene_conv / scnb
│ │                      sigprod = comb_sig(child.sigma_14, dih.atom1.sigma_14)
│ │                      sigprod *= length_conv
│ │                      chgprod = child.charge * dih.atom1.charge / scee
│ │ -                    force.addException(child.idx, dih.atom1.idx, chgprod, sigprod, epsprod, True)
│ │ +                    force.addException(
│ │ +                        child.idx, dih.atom1.idx, chgprod, sigprod, epsprod, True)
│ │                  for c1 in dih.atom1.children:
│ │                      for c2 in dih.atom2.children:
│ │                          epsprod = abs(c1.epsilon_14 * c2.epsilon_14)
│ │                          epsprod = math.sqrt(epsprod) * ene_conv / scnb
│ │                          sigprod = comb_sig(c1.sigma_14, c2.sigma_14)
│ │                          sigprod *= length_conv
│ │                          chgprod = c1.charge * c2.charge / scee
│ │ -                        force.addException(c1.idx, c2.idx, chgprod, sigprod, epsprod, True)
│ │ +                        force.addException(
│ │ +                            c1.idx, c2.idx, chgprod, sigprod, epsprod, True)
│ │          # Allow our specific exceptions (in adjusts) to override anything that
│ │          # came before
│ │          for pair in self.adjusts:
│ │              chgprod = pair.atom1.charge * pair.atom2.charge * pair.type.chgscale
│ │              force.addException(pair.atom1.idx, pair.atom2.idx, chgprod, pair.type.sigma*length_conv,
│ │                                 pair.type.epsilon*ene_conv, True)
│ │  
│ │ @@ -2712,22 +2813,22 @@
│ │                  return force, self._omm_geometric_force(force, nonbondedMethod)
│ │  
│ │          if self.has_NBFIX():
│ │              return force, self._omm_nbfixed_force(force, nonbondedMethod)
│ │  
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def omm_drude_force(self, drude_mass):
│ │          force = mm.DrudeForce()
│ │          force.setForceGroup(self.DRUDE_FORCE_GROUP)
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _omm_nbfixed_force(self, nonbfrc, nonbondedMethod):
│ │          """ Private method for creating a CustomNonbondedForce with a lookup
│ │          table. This should not be called by users -- you have been warned.
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -2749,24 +2850,26 @@
│ │          # First derive the type lookup tables
│ │          lj_idx_list = [0 for atom in self.atoms]
│ │          lj_radii, lj_depths = [], []
│ │          num_lj_types = 0
│ │          lj_type_list = []
│ │          for i, atom in enumerate(self.atoms):
│ │              atype = atom.atom_type
│ │ -            if lj_idx_list[i]: continue # already assigned
│ │ +            if lj_idx_list[i]:
│ │ +                continue  # already assigned
│ │              num_lj_types += 1
│ │              lj_idx_list[i] = num_lj_types
│ │              ljtype = (atype.rmin, abs(atype.epsilon))
│ │              lj_type_list.append(atype)
│ │              lj_radii.append(atype.rmin)
│ │              lj_depths.append(abs(atype.epsilon))
│ │              for j in range(i+1, len(self.atoms)):
│ │                  atype2 = self.atoms[j].atom_type
│ │ -                if lj_idx_list[j] > 0: continue # already assigned
│ │ +                if lj_idx_list[j] > 0:
│ │ +                    continue  # already assigned
│ │                  if atype2 is atype:
│ │                      lj_idx_list[j] = num_lj_types
│ │                  elif not atype.nbfix:
│ │                      # Only non-NBFIXed atom types can be compressed
│ │                      ljtype2 = (atype2.rmin, abs(atype2.epsilon))
│ │                      if ljtype == ljtype2:
│ │                          lj_idx_list[j] = num_lj_types
│ │ @@ -2785,27 +2888,30 @@
│ │                      rij *= length_conv
│ │                      wdij *= ene_conv
│ │                  rij6 = rij**6
│ │                  acoef[i+num_lj_types*j] = math.sqrt(wdij) * rij6
│ │                  bcoef[i+num_lj_types*j] = 2 * wdij * rij6
│ │          force = mm.CustomNonbondedForce('(a/r6)^2-b/r6; r6=r2*r2*r2; r2=r^2; '
│ │                                          'a=acoef(type1, type2); b=bcoef(type1, type2)')
│ │ -        force.addTabulatedFunction('acoef', mm.Discrete2DFunction(num_lj_types, num_lj_types, acoef))
│ │ -        force.addTabulatedFunction('bcoef', mm.Discrete2DFunction(num_lj_types, num_lj_types, bcoef))
│ │ +        force.addTabulatedFunction('acoef', mm.Discrete2DFunction(
│ │ +            num_lj_types, num_lj_types, acoef))
│ │ +        force.addTabulatedFunction('bcoef', mm.Discrete2DFunction(
│ │ +            num_lj_types, num_lj_types, bcoef))
│ │          force.addPerParticleParameter('type')
│ │          force.setForceGroup(self.NONBONDED_FORCE_GROUP)
│ │          force.setUseLongRangeCorrection(True)
│ │          if nonbondedMethod in (app.PME, app.Ewald, app.CutoffPeriodic, app.LJPME):
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffPeriodic)
│ │          elif nonbondedMethod is app.NoCutoff:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.NoCutoff)
│ │          elif nonbondedMethod is app.CutoffNonPeriodic:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffNonPeriodic)
│ │          else:
│ │ -            raise ValueError(f'Unrecognized nonbonded method [{nonbondedMethod}]')
│ │ +            raise ValueError(
│ │ +                f'Unrecognized nonbonded method [{nonbondedMethod}]')
│ │          # Add the particles
│ │          for i in lj_idx_list:
│ │              force.addParticle((i-1,))
│ │          # Now wipe out the L-J parameters in the nonbonded force
│ │          for i in range(nonbfrc.getNumParticles()):
│ │              chg, sig, eps = nonbfrc.getParticleParameters(i)
│ │              nonbfrc.setParticleParameters(i, chg, 0.5, 0.0)
│ │ @@ -2817,15 +2923,15 @@
│ │          force.setCutoffDistance(nonbfrc.getCutoffDistance())
│ │          if nonbfrc.getUseSwitchingFunction():
│ │              force.setUseSwitchingFunction(True)
│ │              force.setSwitchingDistance(nonbfrc.getSwitchingDistance())
│ │  
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _omm_geometric_force(self, nonbfrc, nonbondedMethod):
│ │          """ Private method for creating a CustomNonbondedForce with a lookup
│ │          table. This should not be called by users -- you have been warned.
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -2854,15 +2960,16 @@
│ │                  nonbondedMethod is app.CutoffPeriodic):
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffPeriodic)
│ │          elif nonbondedMethod is app.NoCutoff:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.NoCutoff)
│ │          elif nonbondedMethod is app.CutoffNonPeriodic:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffNonPeriodic)
│ │          else:
│ │ -            raise ValueError(f'Unrecognized nonbonded method [{nonbondedMethod}]')
│ │ +            raise ValueError(
│ │ +                f'Unrecognized nonbonded method [{nonbondedMethod}]')
│ │          # Add the particles
│ │          for atom in self.atoms:
│ │              eps = math.sqrt(atom.epsilon*ene_conv) * 2
│ │              sig = math.sqrt(atom.sigma*length_conv)
│ │              force.addParticle((eps, sig))
│ │          # Now wipe out the L-J parameters in the nonbonded force
│ │          for i in range(nonbfrc.getNumParticles()):
│ │ @@ -2877,23 +2984,24 @@
│ │          if nonbondedMethod is app.NoCutoff:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.NoCutoff)
│ │          elif nonbondedMethod is app.CutoffNonPeriodic:
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffNonPeriodic)
│ │          elif nonbondedMethod in (app.PME, app.Ewald, app.CutoffPeriodic):
│ │              force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffPeriodic)
│ │          else:
│ │ -            raise AssertionError('Unsupported nonbonded method %s' % nonbondedMethod)
│ │ +            raise AssertionError(
│ │ +                'Unsupported nonbonded method %s' % nonbondedMethod)
│ │          force.setCutoffDistance(nonbfrc.getCutoffDistance())
│ │          if nonbfrc.getUseSwitchingFunction():
│ │              force.setUseSwitchingFunction(True)
│ │              force.setSwitchingDistance(nonbfrc.getSwitchingDistance())
│ │  
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_gbsa_force(self, implicitSolvent,
│ │                         nonbondedMethod=None,
│ │                         nonbondedCutoff=30.0*u.angstroms,
│ │                         soluteDielectric=1.0,
│ │                         solventDielectric=78.5,
│ │ @@ -2931,15 +3039,16 @@
│ │              The dielectric constant of the protein interior used in GB
│ │          solventDielectric : float=78.5
│ │              The dielectric constant of the water used in GB
│ │          """
│ │          from openmm.app.internal.customgbforces import (
│ │              GBSAHCTForce, GBSAOBC1Force, GBSAOBC2Force, GBSAGBnForce, GBSAGBn2Force
│ │          )
│ │ -        if implicitSolvent is None: return None
│ │ +        if implicitSolvent is None:
│ │ +            return None
│ │          if useSASA:
│ │              sasa = 'ACE'
│ │          else:
│ │              sasa = None
│ │          if nonbondedMethod is None:
│ │              nonbondedMethod = app.NoCutoff
│ │          if implicitSolvent not in (app.HCT, app.OBC1, app.OBC2, app.GBn, app.GBn2):
│ │ @@ -2950,78 +3059,88 @@
│ │                  sc = implicitSolventSaltConc.value_in_unit(u.moles/u.liter)
│ │                  implicitSolventSaltConc = sc
│ │              if u.is_quantity(temperature):
│ │                  temperature = temperature.value_in_unit(u.kelvin)
│ │              # The constant is 1 / sqrt(eps_0 * kB / (2*NA*q^2*1000)) where NA is
│ │              # Avogadro's number, eps_0 is the permittivity of free space, q is
│ │              # the charge (this # matches Amber's conversion factor)
│ │ -            scale = math.sqrt(implicitSolventSaltConc / solventDielectric / temperature)
│ │ +            scale = math.sqrt(implicitSolventSaltConc /
│ │ +                              solventDielectric / temperature)
│ │              implicitSolventKappa = 50.33355 * scale
│ │              # Multiply by 0.73 to account for ion exclusions, and multiply by 10
│ │              # to convert to 1/nm from 1/angstroms
│ │              implicitSolventKappa *= 7.3
│ │          elif u.is_quantity(implicitSolventKappa):
│ │ -            implicitSolventKappa = implicitSolventKappa.value_in_unit(u.nanometer**-1)
│ │ +            implicitSolventKappa = implicitSolventKappa.value_in_unit(
│ │ +                u.nanometer**-1)
│ │  
│ │          if nonbondedMethod is app.NoCutoff:
│ │              cutoff = None
│ │          elif u.is_quantity(nonbondedCutoff):
│ │              cutoff = nonbondedCutoff.value_in_unit(u.nanometers)
│ │          else:
│ │              cutoff = nonbondedCutoff
│ │          if implicitSolvent is app.HCT:
│ │ -            force = GBSAHCTForce(solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │ +            force = GBSAHCTForce(
│ │ +                solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │          elif implicitSolvent is app.OBC1:
│ │ -            force = GBSAOBC1Force(solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │ +            force = GBSAOBC1Force(
│ │ +                solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │          elif implicitSolvent is app.OBC2:
│ │ -            force = GBSAOBC2Force(solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │ +            force = GBSAOBC2Force(
│ │ +                solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │          elif implicitSolvent is app.GBn:
│ │ -            force = GBSAGBnForce(solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │ +            force = GBSAGBnForce(
│ │ +                solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │          elif implicitSolvent is app.GBn2:
│ │ -            force = GBSAGBn2Force(solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │ +            force = GBSAGBn2Force(
│ │ +                solventDielectric, soluteDielectric, sasa, cutoff, kappa=implicitSolventKappa)
│ │          else:
│ │ -            raise AssertionError('Unexpected implicit solvent model... should not be here')
│ │ +            raise AssertionError(
│ │ +                'Unexpected implicit solvent model... should not be here')
│ │          for atom, parms in zip(self.atoms, gb_parms):
│ │              force.addParticle([atom.charge] + list(parms))
│ │          try:
│ │              force.finalize()
│ │          except AttributeError:
│ │              # only new versions of omm require calling finalize
│ │              pass
│ │          # Set cutoff method
│ │          if nonbondedMethod is app.NoCutoff:
│ │              force.setNonbondedMethod(mm.CustomGBForce.NoCutoff)
│ │          elif nonbondedMethod is app.CutoffNonPeriodic:
│ │              force.setNonbondedMethod(mm.CustomGBForce.CutoffNonPeriodic)
│ │              force.setCutoffDistance(cutoff)
│ │ -        else: # cutoff periodic (PME, CutoffPeriodic, Ewald)
│ │ +        else:  # cutoff periodic (PME, CutoffPeriodic, Ewald)
│ │              force.setNonbondedMethod(mm.CustomGBForce.CutoffPeriodic)
│ │              force.setCutoffDistance(cutoff)
│ │          force.setForceGroup(self.NONBONDED_FORCE_GROUP)
│ │  
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      # Amoeba-specific forces below
│ │  
│ │      @needs_openmm
│ │      def omm_trigonal_angle_force(self):
│ │          """ Creates the Amoeba trigonal-angle force
│ │  
│ │          Returns
│ │          -------
│ │          AmoebaInPlaneAngleForce
│ │              The trigonal in-plane Angle force
│ │          """
│ │ -        if not self.trigonal_angles: return None
│ │ +        if not self.trigonal_angles:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          if (not hasattr(self.trigonal_angle_types, 'degree') or
│ │ -            not hasattr(self.trigonal_angle_types, 'coeffs')):
│ │ -            raise ParameterError('Do not have the trigonal angle force table parameters')
│ │ +                not hasattr(self.trigonal_angle_types, 'coeffs')):
│ │ +            raise ParameterError(
│ │ +                'Do not have the trigonal angle force table parameters')
│ │          c = self.trigonal_angle_types.coeffs
│ │          energy = """k*(d^2 + %s*d^3 + %s*d^4 + %s*d^5 + %s*d^6); d=theta-theta0;
│ │                      theta = %.15g*pointangle(x1, y1, z1, projx, projy, projz, x3, y3, z3);
│ │                      projx = x2-nx*dot; projy = y2-ny*dot; projz = z2-nz*dot;
│ │                      dot = nx*(x2-x3) + ny*(y2-y3) + nz*(z2-z3);
│ │                      nx = px/norm; ny = py/norm; nz = pz/norm;
│ │                      norm = sqrt(px*px + py*py + pz*pz);
│ │ @@ -3033,33 +3152,35 @@
│ │          force.addPerBondParameter("k")
│ │          force.setName('AmoebaInPlaneAngle')
│ │          force.setForceGroup(self.TRIGONAL_ANGLE_FORCE_GROUP)
│ │          for ang in self.trigonal_angles:
│ │              if ang.type is None:
│ │                  raise ParameterError('Missing trigonal angle parameters')
│ │              force.addBond((ang.atom1.idx, ang.atom2.idx, ang.atom3.idx, ang.atom4.idx),
│ │ -                           (ang.type.theteq, ang.type.k*frc_conv))
│ │ +                          (ang.type.theteq, ang.type.k*frc_conv))
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_out_of_plane_bend_force(self):
│ │          """ Creates the Amoeba out-of-plane bend force
│ │  
│ │          Returns
│ │          -------
│ │          AmoebaOutOfPlaneBendForce
│ │              The out-of-plane bend Angle force
│ │          """
│ │ -        if not self.out_of_plane_bends: return None
│ │ +        if not self.out_of_plane_bends:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          if (not hasattr(self.out_of_plane_bend_types, 'degree') or
│ │ -            not hasattr(self.out_of_plane_bend_types, 'coeffs')):
│ │ -            raise ParameterError('Do not have the trigonal angle force table parameters')
│ │ +                not hasattr(self.out_of_plane_bend_types, 'coeffs')):
│ │ +            raise ParameterError(
│ │ +                'Do not have the trigonal angle force table parameters')
│ │          c = self.out_of_plane_bend_types.coeffs
│ │          energy = """k*(theta^2 + %s*theta^3 + %s*theta^4 + %s*theta^5 + %s*theta^6);
│ │                      theta = %.15g*pointangle(x2, y2, z2, x4, y4, z4, projx, projy, projz);
│ │                      projx = x2-nx*dot; projy = y2-ny*dot; projz = z2-nz*dot;
│ │                      dot = nx*(x2-x3) + ny*(y2-y3) + nz*(z2-z3);
│ │                      nx = px/norm; ny = py/norm; nz = pz/norm;
│ │                      norm = sqrt(px*px + py*py + pz*pz);
│ │ @@ -3070,29 +3191,30 @@
│ │          force.addPerBondParameter("k")
│ │          force.setName('AmoebaOutOfPlaneBend')
│ │          force.setForceGroup(self.OUT_OF_PLANE_BEND_FORCE_GROUP)
│ │          for ang in self.out_of_plane_bends:
│ │              if ang.type is None:
│ │                  raise ParameterError('Missing out-of-plane bend parameters')
│ │              force.addBond((ang.atom1.idx, ang.atom2.idx, ang.atom3.idx, ang.atom4.idx),
│ │ -                                    (2*ang.type.k*frc_conv,))
│ │ +                          (2*ang.type.k*frc_conv,))
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_pi_torsion_force(self):
│ │          """ Creates the Amoeba pi-torsion force
│ │  
│ │          Returns
│ │          -------
│ │          AmoebaPiTorsionForce
│ │              The pi-torsion force
│ │          """
│ │ -        if not self.pi_torsions: return None
│ │ +        if not self.pi_torsions:
│ │ +            return None
│ │          frc_conv = u.kilocalories.conversion_factor_to(u.kilojoules)
│ │          energy = """2*k*sin(phi)^2;
│ │                      phi = pointdihedral(x3+c1x, y3+c1y, z3+c1z, x3, y3, z3, x4, y4, z4, x4+c2x, y4+c2y, z4+c2z);
│ │                      c1x = (d14y*d24z-d14z*d24y); c1y = (d14z*d24x-d14x*d24z); c1z = (d14x*d24y-d14y*d24x);
│ │                      c2x = (d53y*d63z-d53z*d63y); c2y = (d53z*d63x-d53x*d63z); c2z = (d53x*d63y-d53y*d63x);
│ │                      d14x = x1-x4; d14y = y1-y4; d14z = z1-z4;
│ │                      d24x = x2-x4; d24y = y2-y4; d24z = z2-z4;
│ │ @@ -3102,31 +3224,32 @@
│ │          force.addPerBondParameter('k')
│ │          force.setName('AmoebaPiTorsion')
│ │          force.setForceGroup(self.PI_TORSION_FORCE_GROUP)
│ │          for ang in self.pi_torsions:
│ │              if ang.type is None:
│ │                  raise ParameterError('Missing pi-torsion parameters')
│ │              force.addBond((ang.atom1.idx, ang.atom2.idx, ang.atom3.idx, ang.atom4.idx,
│ │ -                               ang.atom5.idx, ang.atom6.idx), (ang.type.phi_k*frc_conv,))
│ │ +                           ang.atom5.idx, ang.atom6.idx), (ang.type.phi_k*frc_conv,))
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_stretch_bend_force(self):
│ │          """ Create the OpenMM Amoeba stretch-bend force for this system
│ │  
│ │          Returns
│ │          -------
│ │          AmoebaStretchBendForce
│ │              The stretch-bend force containing all terms in this system
│ │          """
│ │ -        if not self.stretch_bends: return None
│ │ +        if not self.stretch_bends:
│ │ +            return None
│ │          # Conversion factor taken from pyopenmm/processTinkerForceField.py
│ │ -        frc_conv = math.pi / 180 * 41.84 # 4.184 * 10
│ │ +        frc_conv = math.pi / 180 * 41.84  # 4.184 * 10
│ │          length_conv = u.angstroms.conversion_factor_to(u.nanometers)
│ │          energy = "(k1*(distance(p1,p2)-r12) + k2*(distance(p2,p3)-r23))*(%.15g*(angle(p1,p2,p3)-theta0))" % (180/math.pi)
│ │          force = mm.CustomCompoundBondForce(3, energy)
│ │          force.addPerBondParameter("r12")
│ │          force.addPerBondParameter("r23")
│ │          force.addPerBondParameter("theta0")
│ │          force.addPerBondParameter("k1")
│ │ @@ -3138,195 +3261,196 @@
│ │                  raise ParameterError("Missing stretch-bend parameters")
│ │              force.addBond((strbnd.atom1.idx, strbnd.atom2.idx, strbnd.atom3.idx),
│ │                            (strbnd.type.req1*length_conv, strbnd.type.req2*length_conv,
│ │                            strbnd.type.theteq*math.pi/180, strbnd.type.k1*frc_conv,
│ │                            strbnd.type.k2*frc_conv))
│ │          return force
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def omm_torsion_torsion_force(self):
│ │          """ Create the OpenMM Amoeba coupled-torsion (CMAP) force
│ │  
│ │          Returns
│ │          -------
│ │          AmoebaTorsionTorsionForce
│ │              The torsion-torsion (CMAP) force with all coupled-torsion parameters
│ │              for this system
│ │          """
│ │ -        if not self.torsion_torsions: return None
│ │ +        if not self.torsion_torsions:
│ │ +            return None
│ │          # Not implemented yet...
│ │          raise NotImplementedError("Torsion-torsions not yet implemented")
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_bonds(self):
│ │          """ Gets rid of any empty bonds """
│ │          for i in reversed(range(len(self.bonds))):
│ │              bond = self.bonds[i]
│ │              if bond.atom1 is None and bond.atom2 is None:
│ │                  del self.bonds[i]
│ │              elif bond.atom1.idx == -1 or bond.atom2.idx == -1:
│ │                  bond.delete()
│ │                  del self.bonds[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_angles(self):
│ │          """ Gets rid of any empty angles """
│ │          for i in reversed(range(len(self.angles))):
│ │              angle = self.angles[i]
│ │              if (angle.atom1 is None and angle.atom2 is None and
│ │                      angle.atom3 is None):
│ │                  del self.angles[i]
│ │              elif -1 in (angle.atom1.idx, angle.atom2.idx, angle.atom3.idx):
│ │                  angle.delete()
│ │                  del self.angles[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_dihedrals(self, dlist='dihedrals'):
│ │          """ Gets rid of any empty dihedrals """
│ │          for i in reversed(range(len(getattr(self, dlist)))):
│ │              dihed = getattr(self, dlist)[i]
│ │              if (dihed.atom1 is None and dihed.atom2 is None and
│ │ -                dihed.atom3 is None and dihed.atom4 is None):
│ │ +                    dihed.atom3 is None and dihed.atom4 is None):
│ │                  del getattr(self, dlist)[i]
│ │              elif -1 in (dihed.atom1.idx, dihed.atom2.idx, dihed.atom3.idx, dihed.atom4.idx):
│ │                  dihed.delete()
│ │                  del getattr(self, dlist)[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_rb_torsions(self):
│ │          """ Gets rid of any empty R-B torsions """
│ │          self._prune_empty_dihedrals('rb_torsions')
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_ureys(self):
│ │          """ Gets rid of any empty Urey-Bradley terms """
│ │          for i in reversed(range(len(self.urey_bradleys))):
│ │              ub = self.urey_bradleys[i]
│ │              if ub.atom1 is None and ub.atom2 is None:
│ │                  del self.urey_bradleys[i]
│ │              elif ub.atom1.idx == -1 or ub.atom2.idx == -1:
│ │                  ub.delete()
│ │                  del self.urey_bradleys[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_impropers(self):
│ │          """ Gets rid of any empty improper torsions """
│ │          for i in reversed(range(len(self.impropers))):
│ │              imp = self.impropers[i]
│ │              if imp.atom1 is None and imp.atom2 is None and imp.atom3 is None and imp.atom4 is None:
│ │                  del self.impropers[i]
│ │              elif -1 in (imp.atom1.idx, imp.atom2.idx, imp.atom3.idx, imp.atom4.idx):
│ │                  imp.delete()
│ │                  del self.impropers[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_cmaps(self):
│ │          """ Gets rid of any empty CMAP terms """
│ │          for i in reversed(range(len(self.cmaps))):
│ │              cmap = self.cmaps[i]
│ │              if (cmap.atom1 is None and cmap.atom2 is None and cmap.atom3 is None
│ │ -                and cmap.atom4 is None and cmap.atom5 is None):
│ │ +                    and cmap.atom4 is None and cmap.atom5 is None):
│ │                  del self.cmaps[i]
│ │              elif -1 in (cmap.atom1.idx, cmap.atom2.idx, cmap.atom3.idx,
│ │                          cmap.atom4.idx, cmap.atom5.idx):
│ │                  cmap.delete()
│ │                  del self.cmaps[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_trigonal_angles(self):
│ │          """ Gets rid of any empty trigonal angles """
│ │          self._prune_empty_dihedrals('trigonal_angles')
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_out_of_plane_bends(self):
│ │          """ Gets rid of any empty out-of-plane bends """
│ │          self._prune_empty_dihedrals('out_of_plane_bends')
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_pi_torsions(self):
│ │          """ Gets rid of any empty pi-torsions """
│ │          for i in reversed(range(len(self.pi_torsions))):
│ │              pit = self.pi_torsions[i]
│ │              if (pit.atom1 is None and pit.atom2 is None and pit.atom3 is None and
│ │ -                pit.atom4 is None and pit.atom5 is None and pit.atom6 is None):
│ │ +                    pit.atom4 is None and pit.atom5 is None and pit.atom6 is None):
│ │                  del self.pi_torsions[i]
│ │              elif -1 in (pit.atom1.idx, pit.atom2.idx, pit.atom3.idx, pit.atom4.idx,
│ │                          pit.atom5.idx, pit.atom6.idx):
│ │                  # Not stored anywhere, no need to call delete()
│ │                  del self.pi_torsions[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_stretch_bends(self):
│ │          """ Gets rid of any empty stretch-bend terms """
│ │          for i in reversed(range(len(self.stretch_bends))):
│ │              sb = self.stretch_bends[i]
│ │              if sb.atom1 is None and sb.atom2 is None and sb.atom3 is None:
│ │                  del self.stretch_bends[i]
│ │              elif sb.atom1.idx == -1 or sb.atom2.idx == -1 or sb.atom3.idx == -1:
│ │                  # Not stored anywhere, no need to call delete()
│ │                  del self.stretch_bends[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_torsion_torsions(self):
│ │          """ Gets rid of any empty torsion-torsion terms """
│ │          for i in reversed(range(len(self.torsion_torsions))):
│ │              tt = self.torsion_torsions[i]
│ │              if (tt.atom1 is None and tt.atom2 is None and tt.atom3 is None and
│ │ -                tt.atom4 is None and tt.atom5 is None):
│ │ +                    tt.atom4 is None and tt.atom5 is None):
│ │                  del self.torsion_torsions[i]
│ │              elif -1 in (tt.atom1.idx, tt.atom2.idx, tt.atom3.idx, tt.atom4.idx, tt.atom5.idx):
│ │                  tt.delete()
│ │                  del self.torsion_torsions[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_chiral_frames(self):
│ │          """ Gets rid of any empty chiral frame terms """
│ │          for i in reversed(range(len(self.chiral_frames))):
│ │              cf = self.chiral_frames[i]
│ │              if cf.atom1 is None or cf.atom2 is None:
│ │                  del self.chiral_frames[i]
│ │              elif cf.atom1.idx == -1 or cf.atom2.idx == -1:
│ │                  del self.chiral_frames[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_multipole_frames(self):
│ │          """ Gets rid of any empty multipole frame terms """
│ │          for i in reversed(range(len(self.multipole_frames))):
│ │              mf = self.multipole_frames[i]
│ │              if mf.atom is None or mf.atom.idx == -1:
│ │                  del self.multipole_frames[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def _prune_empty_adjusts(self):
│ │          """ Gets rid of any empty nonbonded exception adjustments """
│ │          for i in reversed(range(len(self.adjusts))):
│ │              adj = self.adjusts[i]
│ │              if adj.atom1 is None or adj.atom2 is None:
│ │                  del self.adjusts[i]
│ │              elif adj.atom1.idx == -1 or adj.atom2.idx == -1:
│ │                  del self.adjusts[i]
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @needs_openmm
│ │      def _get_gb_parameters(self, implicitSolvent):
│ │          """ Gets the GB parameters for the requested GB model used by OpenMM
│ │  
│ │          Parameters
│ │          ----------
│ │ @@ -3400,22 +3524,22 @@
│ │          length_conv = u.angstrom.conversion_factor_to(u.nanometer)
│ │          radii = [x * length_conv for x in radii]
│ │  
│ │          if implicitSolvent is app.GBn2:
│ │              return list(zip(radii, screen, alpha, beta, gamma))
│ │          return list(zip(radii, screen))
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __str__(self):
│ │          if hasattr(self, 'name') and self.name:
│ │              return self.name
│ │          return repr(self)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      # Support concatenating and replicating the Structure
│ │  
│ │      def __add__(self, other):
│ │          cp = copy(self)
│ │          cp += other
│ │          return cp
│ │ @@ -3442,30 +3566,32 @@
│ │          try:
│ │              roffset = self.residues[-1].number + 1
│ │          except IndexError:
│ │              # No residues... must be an empty structure
│ │              roffset = 0
│ │          for atom in other.atoms:
│ │              res = atom.residue
│ │ -            self.add_atom(copy(atom), res.name, res.idx+roffset, res.chain, res.insertion_code, res.segid)
│ │ +            self.add_atom(copy(atom), res.name, res.idx+roffset,
│ │ +                          res.chain, res.insertion_code, res.segid)
│ │ +
│ │          def copy_valence_terms(oval, otyp, sval, styp, attrlist):
│ │              """ Copies the valence terms from one list to another;
│ │              oval=Other VALence; otyp=Other TYPe; sval=Self VALence;
│ │              styp=Self TYPe; attrlist=ATTRibute LIST (atom1, atom2, ...)
│ │              """
│ │              otypcp = [copy(typ) for typ in otyp]
│ │              for val in oval:
│ │                  ats = [getattr(val, attr) for attr in attrlist]
│ │                  # Replace any atoms with the ones from self.atoms
│ │                  for i, at in enumerate(ats):
│ │                      if isinstance(at, Atom):
│ │                          ats[i] = self.atoms[at.idx+aoffset]
│ │                  kws = dict()
│ │                  if hasattr(val, 'type') and val.type is NoUreyBradley:
│ │ -                    kws['type'] = NoUreyBradley # special-case singleton
│ │ +                    kws['type'] = NoUreyBradley  # special-case singleton
│ │                  elif otypcp and val.type is not None:
│ │                      kws['type'] = otypcp[val.type.idx]
│ │                  sval.append(type(val)(*ats, **kws))
│ │                  if hasattr(val, 'funct'):
│ │                      sval[-1].funct = val.funct
│ │              # Now tack on the "new" types copied from `other`
│ │              styp.extend(otypcp)
│ │ @@ -3503,23 +3629,27 @@
│ │                             ['atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │          copy_valence_terms(other.chiral_frames, [], self.chiral_frames, [],
│ │                             ['atom1', 'atom2', 'chirality'])
│ │          copy_valence_terms(other.multipole_frames, [], self.multipole_frames, [],
│ │                             ['atom', 'frame_pt_num', 'vectail', 'vechead', 'nvec'])
│ │          copy_valence_terms(other.adjusts, other.adjust_types, self.adjusts,
│ │                             self.adjust_types, ['atom1', 'atom2'])
│ │ -        copy_valence_terms(other.donors, [], self.donors, [], ['atom1', 'atom2'])
│ │ -        copy_valence_terms(other.acceptors, [], self.acceptors, [], ['atom1', 'atom2'])
│ │ -        copy_valence_terms(other.groups, [], self.groups, [], ['atom', 'type', 'move'])
│ │ +        copy_valence_terms(other.donors, [], self.donors,
│ │ +                           [], ['atom1', 'atom2'])
│ │ +        copy_valence_terms(other.acceptors, [],
│ │ +                           self.acceptors, [], ['atom1', 'atom2'])
│ │ +        copy_valence_terms(other.groups, [], self.groups,
│ │ +                           [], ['atom', 'type', 'move'])
│ │          if mycrd is None or other._coordinates is None:
│ │              self._coordinates = None
│ │          else:
│ │              ocrd = other.get_coordinates('all')
│ │              nframes = min(ocrd.shape[0], mycrd.shape[0])
│ │ -            self._coordinates = np.concatenate((mycrd[:nframes,:,:], ocrd[:nframes,:,:]), axis=1)
│ │ +            self._coordinates = np.concatenate(
│ │ +                (mycrd[:nframes, :, :], ocrd[:nframes, :, :]), axis=1)
│ │          return self
│ │  
│ │      def __mul__(self, ncopies):
│ │          """ Replicates the current Structure `ncopies` times """
│ │          cp = copy(self)
│ │          return cp.__imul__(ncopies, self)
│ │  
│ │ @@ -3527,48 +3657,50 @@
│ │  
│ │      def __imul__(self, ncopies, other=None):
│ │          if not isinstance(ncopies, int):
│ │              return NotImplemented
│ │          # The basic approach here is similar to what we used in __iadd__, except
│ │          # we don't have to extend the type arrays at all -- we just point to the
│ │          # same one that the first copy pointed to.
│ │ +
│ │          def copy_valence_terms(oval, aoffset, sval, styp, attrlist):
│ │              """ Copies the valence terms from one list to another;
│ │              oval=Other VALence; otyp=Other TYPe; sval=Self VALence;
│ │              styp=Self TYPe; attrlist=ATTRibute LIST (atom1, atom2, ...)
│ │              """
│ │              for val in oval:
│ │                  ats = [getattr(val, attr) for attr in attrlist]
│ │                  # Replace any atoms with the ones from self.atoms
│ │                  for i, at in enumerate(ats):
│ │                      if isinstance(at, Atom):
│ │                          ats[i] = self.atoms[at.idx+aoffset]
│ │                  kws = dict()
│ │                  if hasattr(val, 'type') and val.type is NoUreyBradley:
│ │ -                    kws['type'] = NoUreyBradley # special-case singleton
│ │ +                    kws['type'] = NoUreyBradley  # special-case singleton
│ │                  elif styp and val.type is not None:
│ │                      kws['type'] = styp[val.type.idx]
│ │                  sval.append(type(val)(*ats, **kws))
│ │                  if hasattr(val, 'funct'):
│ │                      sval[-1].funct = val.funct
│ │ -        if other is None: other = copy(self)
│ │ +        if other is None:
│ │ +            other = copy(self)
│ │          for i in range(ncopies-1):
│ │              aoffset = len(self.atoms)
│ │              roffset = self.residues[-1].number + 1
│ │              for atom in other.atoms:
│ │                  res = atom.residue
│ │                  self.add_atom(copy(atom), res.name, res.idx+roffset, res.chain,
│ │                                res.insertion_code, res.segid)
│ │              copy_valence_terms(other.bonds, aoffset, self.bonds,
│ │                                 self.bond_types, ['atom1', 'atom2'])
│ │              copy_valence_terms(other.angles, aoffset, self.angles,
│ │                                 self.angle_types, ['atom1', 'atom2', 'atom3'])
│ │              copy_valence_terms(other.dihedrals, aoffset, self.dihedrals,
│ │                                 self.dihedral_types, ['atom1', 'atom2', 'atom3',
│ │ -                               'atom4', 'improper', 'ignore_end'])
│ │ +                                                     'atom4', 'improper', 'ignore_end'])
│ │              copy_valence_terms(other.rb_torsions, aoffset,
│ │                                 self.rb_torsions, self.rb_torsion_types,
│ │                                 ['atom1', 'atom2', 'atom3', 'atom4', 'improper', 'ignore_end'])
│ │              copy_valence_terms(other.urey_bradleys, aoffset,
│ │                                 self.urey_bradleys, self.urey_bradley_types, ['atom1', 'atom2'])
│ │              copy_valence_terms(other.impropers, aoffset, self.impropers, self.improper_types,
│ │                                 ['atom1', 'atom2', 'atom3', 'atom4'])
│ │ @@ -3587,22 +3719,26 @@
│ │                                 ['atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │              copy_valence_terms(other.chiral_frames, aoffset, self.chiral_frames,
│ │                                 [], ['atom1', 'atom2', 'chirality'])
│ │              copy_valence_terms(other.multipole_frames, aoffset, self.multipole_frames, [],
│ │                                 ['atom', 'frame_pt_num', 'vectail', 'vechead', 'nvec'])
│ │              copy_valence_terms(other.adjusts, aoffset, self.adjusts,
│ │                                 self.adjust_types, ['atom1', 'atom2'])
│ │ -            copy_valence_terms(other.donors, aoffset, self.donors, [], ['atom1', 'atom2'])
│ │ -            copy_valence_terms(other.acceptors, aoffset, self.acceptors, [], ['atom1', 'atom2'])
│ │ -            copy_valence_terms(other.groups, aoffset, self.groups, [], ['atom', 'type', 'move'])
│ │ +            copy_valence_terms(other.donors, aoffset,
│ │ +                               self.donors, [], ['atom1', 'atom2'])
│ │ +            copy_valence_terms(other.acceptors, aoffset,
│ │ +                               self.acceptors, [], ['atom1', 'atom2'])
│ │ +            copy_valence_terms(other.groups, aoffset, self.groups, [], [
│ │ +                               'atom', 'type', 'move'])
│ │          if self._coordinates is not None:
│ │ -            self._coordinates = np.hstack([self._coordinates for i in range(ncopies)])
│ │ +            self._coordinates = np.hstack(
│ │ +                [self._coordinates for i in range(ncopies)])
│ │          return self
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      # For the bool-ness of Structure. An empty structure evaluates to
│ │      # boolean-false, but this means that the structure must have no atoms,
│ │      # residues, topological features, or parameter types at all.
│ │  
│ │      def __bool__(self):
│ │          return bool(self.atoms or self.residues or self.bonds or self.angles or self.dihedrals or
│ │ @@ -3612,31 +3748,31 @@
│ │                      self.chiral_frames or self.multipole_frames or self.adjusts or self.acceptors or
│ │                      self.donors or self.groups or self.bond_types or self.angle_types or
│ │                      self.dihedral_types or self.urey_bradley_types or self.improper_types or
│ │                      self.rb_torsion_types or self.cmap_types or self.trigonal_angle_types or
│ │                      self.out_of_plane_bend_types or self.pi_torsion_types or
│ │                      self.torsion_torsion_types or self.adjust_types)
│ │  
│ │ -    __nonzero__ = __bool__ # for Python 2
│ │ +    __nonzero__ = __bool__  # for Python 2
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      @staticmethod
│ │      def _add_force_to_system(system, force):
│ │          """ Adds an OpenMM force to a system IFF the force is not None """
│ │          if force is None:
│ │              return
│ │          if isinstance(force, tuple) or isinstance(force, list):
│ │              # It's possible we got multiple forces to add
│ │              for f in force:
│ │                  system.addForce(f)
│ │              return
│ │          system.addForce(force)
│ │  
│ │ -    #===================================================
│ │ +    # ===================================================
│ │  
│ │      def __getstate__(self):
│ │          """ Serializes a structure """
│ │          retdict = dict(residues=self.residues,
│ │                         bond_types=self.bond_types,
│ │                         angle_types=self.angle_types,
│ │                         dihedral_types=self.dihedral_types,
│ │ @@ -3653,15 +3789,16 @@
│ │                         groups=self.groups,
│ │                         _coordinates=self._coordinates,
│ │                         _box=self._box,
│ │                         nrexcl=self.nrexcl,
│ │                         _combining_rule=self._combining_rule,
│ │                         unknown_functional=self.unknown_functional,
│ │                         space_group=self.space_group,
│ │ -                      )
│ │ +                       )
│ │ +
│ │          def idx(thing):
│ │              return thing.idx if thing is not None else None
│ │          retdict['bonds'] = [(b.atom1.idx, b.atom2.idx, idx(b.type))
│ │                              for b in self.bonds]
│ │          retdict['angles'] = [(a.atom1.idx, a.atom2.idx, a.atom3.idx,
│ │                                idx(a.type)) for a in self.angles]
│ │          retdict['dihedrals'] = [(d.atom1.idx, d.atom2.idx, d.atom3.idx, d.atom4.idx, d.improper,
│ │ @@ -3684,19 +3821,23 @@
│ │                                       idx(s.type)) for s in self.stretch_bends]
│ │          retdict['torsion_torsions'] = [(t.atom1.idx, t.atom2.idx, t.atom3.idx, t.atom4.idx,
│ │                                          t.atom5.idx, idx(t.type)) for t in self.torsion_torsions]
│ │          retdict['chiral_frames'] = [(c.atom1.idx, c.atom2.idx, c.chirality)
│ │                                      for c in self.chiral_frames]
│ │          retdict['multipole_frames'] = [(f.atom.idx, f.frame_pt_num, f.vectail,
│ │                                          f.vechead, f.nvec) for f in self.multipole_frames]
│ │ -        retdict['adjusts'] = [(e.atom1.idx, e.atom2.idx, idx(e.type)) for e in self.adjusts]
│ │ -        retdict['acceptors'] = [(a.atom1.idx, a.atom2.idx) for a in self.acceptors]
│ │ +        retdict['adjusts'] = [(e.atom1.idx, e.atom2.idx, idx(e.type))
│ │ +                              for e in self.adjusts]
│ │ +        retdict['acceptors'] = [(a.atom1.idx, a.atom2.idx)
│ │ +                                for a in self.acceptors]
│ │          retdict['donors'] = [(d.atom1.idx, d.atom2.idx) for d in self.donors]
│ │ -        retdict['exclusions'] = [tuple(e.idx for e in a._exclusion_partners) for a in self.atoms]
│ │ -        retdict['links'] = [(link.atom1.idx, link.atom2.idx, link.length, link.symmetry_op1, link.symmetry_op2) for link in self.links]
│ │ +        retdict['exclusions'] = [
│ │ +            tuple(e.idx for e in a._exclusion_partners) for a in self.atoms]
│ │ +        retdict['links'] = [(link.atom1.idx, link.atom2.idx, link.length,
│ │ +                             link.symmetry_op1, link.symmetry_op2) for link in self.links]
│ │  
│ │          # Now the metadata stuff, if applicable
│ │          for key in ('experimental', 'journal', 'authors', 'keywords', 'doi',
│ │                      'pmid', 'journal_authors', 'volume', 'title', 'year',
│ │                      'resolution', 'related_entries'):
│ │              try:
│ │                  retdict[key] = getattr(self, key)
│ │ @@ -3721,24 +3862,26 @@
│ │                      'resolution', 'related_entries', '_coordinates', '_box',
│ │                      'nrexcl', '_combining_rule', 'unknown_functional',
│ │                      'space_group'):
│ │              if key in d:
│ │                  setattr(self, key, d[key])
│ │  
│ │          self.atoms = AtomList()
│ │ -        for r in self.residues: self.atoms.extend(r.atoms)
│ │ +        for r in self.residues:
│ │ +            self.atoms.extend(r.atoms)
│ │  
│ │          def assign_type(typelist, idx):
│ │              if idx is None:
│ │                  return None
│ │              return typelist[idx]
│ │  
│ │          # Set the topology arrays
│ │          self.bonds = TrackedList(
│ │ -            Bond(self.atoms[it[0]], self.atoms[it[1]], type=assign_type(self.bond_types, it[2]))
│ │ +            Bond(self.atoms[it[0]], self.atoms[it[1]],
│ │ +                 type=assign_type(self.bond_types, it[2]))
│ │              for it in d['bonds']
│ │          )
│ │          self.angles = TrackedList(
│ │              Angle(self.atoms[it[0]], self.atoms[it[1]], self.atoms[it[2]],
│ │                    type=assign_type(self.angle_types, it[3]))
│ │              for it in d['angles']
│ │          )
│ │ @@ -3833,15 +3976,16 @@
│ │                  else:
│ │                      new_atom_type = copy(atom.atom_type)
│ │                      new_atom_type.name += "D"
│ │                      copied_atom_type_map[id(atom.atom_type)] = new_atom_type
│ │                  atom.type += "D"
│ │                  atom.atom_type = new_atom_type
│ │  
│ │ -#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +
│ │  
│ │  class _StructureViewerCreator(object):
│ │      """ Class responsible for creating a StructureView when indexed """
│ │  
│ │      def __init__(self, struct):
│ │          self.struct = struct
│ │  
│ │ @@ -3869,57 +4013,69 @@
│ │          for i in range(1, len(selection)):
│ │              scan.append(scan[i-1] + selection[i])
│ │          # Zero-out the unselected atoms
│ │          scan = [x * y for x, y in zip(scan, selection)]
│ │          # Copy all parameters
│ │          sel_res = set()
│ │          for i, atom in enumerate(struct.atoms):
│ │ -            if not selection[i]: continue
│ │ +            if not selection[i]:
│ │ +                continue
│ │              view.atoms.append(atom)
│ │ -            if atom.residue in sel_res: continue
│ │ +            if atom.residue in sel_res:
│ │ +                continue
│ │              view.residues.append(atom.residue)
│ │              sel_res.add(atom.residue)
│ │ +
│ │          def add_valence_terms(oval, sval, attrlist):
│ │              """ Adds the valence terms from one list to another;
│ │              oval=Other VALence; otyp=Other TYPe; sval=Self VALence;
│ │              styp=Self TYPe; attrlist=ATTRibute LIST (atom1, atom2, ...)
│ │              """
│ │              for val in sval:
│ │                  ats = [getattr(val, attr) for attr in attrlist]
│ │                  # Make sure all of our atoms in this valence term is "selected"
│ │                  indices = [scan[at.idx] for at in ats if isinstance(at, Atom)]
│ │                  if not all(indices):
│ │                      continue
│ │                  # Add the type if applicable
│ │                  oval.append(val)
│ │          add_valence_terms(view.bonds, struct.bonds, ['atom1', 'atom2'])
│ │ -        add_valence_terms(view.angles, struct.angles, ['atom1', 'atom2', 'atom3'])
│ │ -        add_valence_terms(view.dihedrals, struct.dihedrals, ['atom1', 'atom2', 'atom3', 'atom4'])
│ │ +        add_valence_terms(view.angles, struct.angles,
│ │ +                          ['atom1', 'atom2', 'atom3'])
│ │ +        add_valence_terms(view.dihedrals, struct.dihedrals, [
│ │ +                          'atom1', 'atom2', 'atom3', 'atom4'])
│ │          add_valence_terms(view.rb_torsions, struct.rb_torsions,
│ │                            ['atom1', 'atom2', 'atom3', 'atom4'])
│ │ -        add_valence_terms(view.urey_bradleys, struct.urey_bradleys, ['atom1', 'atom2'])
│ │ -        add_valence_terms(view.impropers, struct.impropers, ['atom1', 'atom2', 'atom3', 'atom4'])
│ │ -        add_valence_terms(view.cmaps, struct.cmaps, ['atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │ +        add_valence_terms(view.urey_bradleys,
│ │ +                          struct.urey_bradleys, ['atom1', 'atom2'])
│ │ +        add_valence_terms(view.impropers, struct.impropers, [
│ │ +                          'atom1', 'atom2', 'atom3', 'atom4'])
│ │ +        add_valence_terms(view.cmaps, struct.cmaps, [
│ │ +                          'atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │          add_valence_terms(view.trigonal_angles, struct.trigonal_angles,
│ │                            ['atom1', 'atom2', 'atom3', 'atom4'])
│ │          add_valence_terms(view.out_of_plane_bends, struct.out_of_plane_bends,
│ │                            ['atom1', 'atom2', 'atom3', 'atom4'])
│ │          add_valence_terms(view.pi_torsions, struct.pi_torsions,
│ │                            ['atom1', 'atom2', 'atom3', 'atom4', 'atom5', 'atom6'])
│ │ -        add_valence_terms(view.stretch_bends, struct.stretch_bends, ['atom1', 'atom2', 'atom3'])
│ │ +        add_valence_terms(view.stretch_bends, struct.stretch_bends, [
│ │ +                          'atom1', 'atom2', 'atom3'])
│ │          add_valence_terms(view.torsion_torsions, struct.torsion_torsions,
│ │                            ['atom1', 'atom2', 'atom3', 'atom4', 'atom5'])
│ │ -        add_valence_terms(view.chiral_frames, struct.chiral_frames, ['atom1', 'atom2'])
│ │ -        add_valence_terms(view.multipole_frames, struct.multipole_frames, ['atom'])
│ │ +        add_valence_terms(view.chiral_frames,
│ │ +                          struct.chiral_frames, ['atom1', 'atom2'])
│ │ +        add_valence_terms(view.multipole_frames,
│ │ +                          struct.multipole_frames, ['atom'])
│ │          add_valence_terms(view.adjusts, struct.adjusts, ['atom1', 'atom2'])
│ │          add_valence_terms(view.donors, struct.donors, ['atom1', 'atom2'])
│ │          add_valence_terms(view.acceptors, struct.acceptors, ['atom1', 'atom2'])
│ │          return view
│ │  
│ │ -#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +
│ │  
│ │  class StructureView(object):
│ │      """
│ │      A view of a Structure. In many cases, this can serve as a duck-typed
│ │      Structure and it has many of the same attributes. However, none of its lists
│ │      *own* their objects, and the lists of atoms, residues, and
│ │      parameters/topologies are regular lists, rather than TrackedList instances.
│ │ @@ -4034,15 +4190,15 @@
│ │              return np.array([[a.xx, a.xy, a.xz] for a in self.atoms])
│ │          except AttributeError:
│ │              return None
│ │  
│ │      @property
│ │      def positions(self):
│ │          try:
│ │ -            return [Vec3(a.xx,a.xy,a.xz) for a in self.atoms] * u.angstroms
│ │ +            return [Vec3(a.xx, a.xy, a.xz) for a in self.atoms] * u.angstroms
│ │          except AttributeError:
│ │              return None
│ │  
│ │      def __bool__(self):
│ │          return bool(self.atoms or self.residues or self.bonds or self.angles or
│ │                      self.dihedrals or self.impropers or self.rb_torsions or
│ │                      self.cmaps or self.torsion_torsions or self.stretch_bends or
│ │ @@ -4061,20 +4217,21 @@
│ │          if nextra > 0:
│ │              retstr.append(' [%d EPs]' % nextra)
│ │          retstr.append('; %d residues' % nres)
│ │          nbond = len(self.bonds)
│ │          retstr.append('; %d bonds>' % nbond)
│ │          return ''.join(retstr)
│ │  
│ │ -    __nonzero__ = __bool__ # For Python 2
│ │ +    __nonzero__ = __bool__  # For Python 2
│ │  
│ │      def __iter__(self):
│ │          return iter(self.atoms)
│ │  
│ │ -#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
│ │ +
│ │  
│ │  def _settler(parm):
│ │      """ Identifies residues that can have SETTLE applied to it """
│ │      is_water = []
│ │      for r in parm.residues:
│ │          na = sum(1 for a in r if not isinstance(a, ExtraPoint))
│ │          if na != 3:
│ │ @@ -4095,14 +4252,15 @@
│ │              # Don't check elements, since they may not *always* be accurate.
│ │              # It's more likely that a 3-atom residue not bonded to any other
│ │              # residue is water.
│ │              is_water.append(True)
│ │      assert len(is_water) == len(parm.residues), 'Incorrect length'
│ │      return is_water
│ │  
│ │ +
│ │  def _res_in_templlib(res, lib):
│ │      """ Returns the residue template inside lib that matches res """
│ │      if res.name in lib:
│ │          return lib[res.name]
│ │      if len(res.name) == 3 and residue.AminoAcidResidue.has(res.name):
│ │          return lib[residue.AminoAcidResidue.get(res.name).abbr]
│ │      if residue.DNAResidue.has(res.name):
│ │   --- ParmEd-4.0.0/parmed/tinker/parameterfile.py
│ ├── +++ ParmEd-4.1.0/parmed/tinker/parameterfile.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tinker/system.py
│ ├── +++ ParmEd-4.1.0/parmed/tinker/system.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tinker/tinkerfiles.py
│ ├── +++ ParmEd-4.1.0/parmed/tinker/tinkerfiles.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tinker/topologyobjects.py
│ ├── +++ ParmEd-4.1.0/parmed/tinker/topologyobjects.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/actions.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/actions.py
│ │┄ Files 0% similar despite different names
│ │ @@ -570,29 +570,36 @@
│ │              ChRad(self.parm, self.radii)
│ │  
│ │  #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
│ │  
│ │  class changeLJPair(Action):
│ │      """
│ │      Changes a particular Lennard Jones pair based on a given (pre-combined)
│ │ -    epsilon/Rmin
│ │ +    epsilon/Rmin/[C4_coef]
│ │      """
│ │ -    usage = '<mask1> <mask2> <Rmin> <epsilon>'
│ │ +    usage = '<mask1> <mask2> <Rmin> <epsilon> [<C4_coef>]'
│ │      strictly_supported = (AmberParm, ChamberParm)
│ │      def init(self, arg_list):
│ │          self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
│ │          self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
│ │          self.rmin = arg_list.get_next_float()
│ │          self.eps = arg_list.get_next_float()
│ │ +        self.c4 = arg_list.get_next_float(optional=True, default=None)
│ │  
│ │      def __str__(self):
│ │ -        return (
│ │ -            f'Setting LJ {self.mask1}-{self.mask2} pairwise interaction to have Rmin = '
│ │ -            f'{self.rmin:16.5f} and Epsilon = {self.eps:16.5f}'
│ │ -        )
│ │ +        if self.c4 is None:
│ │ +            return (
│ │ +                f'Setting LJ {self.mask1}-{self.mask2} pairwise interaction to have Rmin = '
│ │ +                f'{self.rmin:16.5f} and Epsilon = {self.eps:16.5f}'
│ │ +            )
│ │ +        else:
│ │ +            return (
│ │ +                f'Setting LJ {self.mask1}-{self.mask2} pairwise interaction to have Rmin = '
│ │ +                f'{self.rmin:16.5f}, Epsilon = {self.eps:16.5f} and C4_coef = {self.c:16.5f}'
│ │ +            )
│ │  
│ │      def execute(self):
│ │          selection1 = self.mask1.Selection()
│ │          selection2 = self.mask2.Selection()
│ │          if sum(selection1) == 0 or sum(selection2) == 0:
│ │              Action.stderr.write('Skipping empty masks in changeLJPair\n')
│ │              return 0
│ │ @@ -608,15 +615,17 @@
│ │                          raise ChangeLJPairError('First mask matches multiple atom types!')
│ │              if selection2[i] == 1:
│ │                  if attype2 is None:
│ │                      attype2 = atom.nb_idx
│ │                  else:
│ │                      if attype2 != atom.nb_idx:
│ │                          raise ChangeLJPairError('Second mask matches multiple atom types!')
│ │ -        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps)
│ │ +        if self.c4 is not None and 'LENNARD_JONES_CCOEF' not in self.parm.flag_list:
│ │ +            raise ChangeLJPairError('No C4 information in parm. Please use the "add12_6_4" command first.')
│ │ +        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps, c4=self.c4)   
│ │  
│ │  #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
│ │  
│ │  class changeLJ14Pair(Action):
│ │      """
│ │      Changes a particular 1-4 Lennard Jones pair based on a given (pre-combined)
│ │      epsilon/Rmin. Only valid for CHAMBER prmtops
│ │ @@ -658,15 +667,15 @@
│ │                  if attype2 is None:
│ │                      attype2 = atom.nb_idx
│ │                  else:
│ │                      if attype2 != atom.nb_idx:
│ │                          raise ChangeLJPairError('Second mask matches multiple atom types!')
│ │  
│ │          # Adjust 1-4 non-bonded terms as well if we're using a chamber-prmtop
│ │ -        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps, True)
│ │ +        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps, one_4=True)
│ │  
│ │  #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
│ │  
│ │  class checkValidity(Action):
│ │      """
│ │      Basic checks for prmtop validity.
│ │      """
│ │ @@ -4238,15 +4247,15 @@
│ │          changeRadii(self.parm, self.radii).execute()
│ │          self.parm_list.add_parm(self.parm)
│ │  
│ │  #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
│ │  
│ │  # Private helper methods
│ │  
│ │ -def _change_lj_pair(parm, atom_1, atom_2, rmin, eps, one_4=False):
│ │ +def _change_lj_pair(parm, atom_1, atom_2, rmin, eps, c4=None, one_4=False):
│ │  
│ │      if one_4:
│ │          key = 'LENNARD_JONES_14'
│ │      else:
│ │          key = 'LENNARD_JONES'
│ │  
│ │      # Make sure that atom type 1 comes first
│ │ @@ -4255,7 +4264,11 @@
│ │  
│ │      # Find the atom1 - atom2 interaction (adjusting for indexing from 0)
│ │      term_idx = parm.parm_data['NONBONDED_PARM_INDEX'][ntypes*(a1-1)+a2-1] - 1
│ │  
│ │      # Now change the ACOEF and BCOEF arrays, assuming pre-combined values
│ │      parm.parm_data[f'{key}_ACOEF'][term_idx] = eps * rmin**12
│ │      parm.parm_data[f'{key}_BCOEF'][term_idx] = 2 * eps * rmin**6
│ │ +    
│ │ +    # Change the CCOEF arrays if provided
│ │ +    if c4 is not None and not one_4:
│ │ +        parm.parm_data[f'{key}_CCOEF'][term_idx] = c4
│ │   --- ParmEd-4.0.0/parmed/tools/add1264.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/add1264.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/addljtype.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/addljtype.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/argumentlist.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/argumentlist.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/changeradii.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/changeradii.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/checkvalidity.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/checkvalidity.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/exceptions.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/exceptions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/logos.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/logos.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/parmed_cmd.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/parmed_cmd.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/parmlist.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/parmlist.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/tools/simulations/openmm.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/simulations/openmm.py
│ │┄ Files 1% similar despite different names
│ │ @@ -49,15 +49,15 @@
│ │  def positional_restraints(mask, weights, refc, scriptfile=None):
│ │      """
│ │      Creates a positional restraint force from CustomExternalForce using the
│ │      coordinates given in the refc restart file for the atoms specified in 'mask'
│ │      """
│ │      parm = mask.parm # store the parm object
│ │      try:
│ │ -        refc = refc.reshape((-1, len(parm.atoms), 3))
│ │ +        refc = refc.coordinates.reshape((-1, len(parm.atoms), 3))
│ │      except ValueError:
│ │          raise SimulationError('Invalid shape of coordinate array')
│ │  
│ │      # Make the (very simple) force term
│ │      if scriptfile is not None:
│ │          wt = weights.value_in_unit(u.kilocalories_per_mole/u.angstrom**2)
│ │          scriptfile.write("# Create the positional restraint force\n")
│ │ @@ -558,15 +558,15 @@
│ │                                   'enforcePeriodicBox=%s)\n)\n' % bool(mdin.cntrl_nml['ntb']))
│ │              rep = EnergyMinimizerReporter(outputfile, volume=parm.ptr('ifbox') > 0)
│ │              rep.report(simulation)
│ │              simulation.minimizeEnergy(tolerance=mdin.cntrl_nml['drms']*u.kilocalories_per_mole,
│ │                                        maxIterations=mdin.cntrl_nml['maxcyc'])
│ │              rep.report(simulation)
│ │              # Write a restart file with the new coordinates
│ │ -            restrt_reporter = RestartReporter(restart, 1, parm.ptr('natom'), False,
│ │ +            restrt_reporter = RestartReporter(restart, 1, False,
│ │                                                mdin.cntrl_nml['ntxo'] == 2, write_velocities=False)
│ │              restrt_reporter.report(simulation, simulation.context.getState(getPositions=True,
│ │                                     enforcePeriodicBox=bool(mdin.cntrl_nml['ntb'])))
│ │              timer.stop_timer('minimization')
│ │          elif mdin.cntrl_nml['imin'] == 5:
│ │              timer.add_timer('minimization', 'Structure minimization')
│ │              timer.start_timer('minimization')
│ │   --- ParmEd-4.0.0/parmed/tools/simulations/sanderapi.py
│ ├── +++ ParmEd-4.1.0/parmed/tools/simulations/sanderapi.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/topologyobjects.py
│ ├── +++ ParmEd-4.1.0/parmed/topologyobjects.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/basedimension.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/basedimension.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/baseunit.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/baseunit.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/constants.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/constants.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/mymatrix.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/mymatrix.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/prefix.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/prefix.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/quantity.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/quantity.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/standard_dimensions.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/standard_dimensions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/unit.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/unit.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/unit_definitions.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/unit_definitions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/unit_math.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/unit_math.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/unit/unit_operators.py
│ ├── +++ ParmEd-4.1.0/parmed/unit/unit_operators.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/decorators.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/decorators.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/FortranRecordReader.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/FortranRecordReader.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/FortranRecordWriter.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/FortranRecordWriter.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/__init__.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/__init__.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_edit_descriptors.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_edit_descriptors.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_input.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_input.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_lexer.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_lexer.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_misc.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_misc.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_output.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_output.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/_parser.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/_parser.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/fortranformat/config.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/fortranformat/config.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/io.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/io.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/netcdf.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/netcdf.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/pairlist.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/pairlist.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/pandautils.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/pandautils.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/utils/timer.py
│ ├── +++ ParmEd-4.1.0/parmed/utils/timer.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/parmed/vec3.py
│ ├── +++ ParmEd-4.1.0/parmed/vec3.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/setup.py
│ ├── +++ ParmEd-4.1.0/setup.py
│ │┄ Files 0% similar despite different names
│ │ @@ -122,9 +122,10 @@
│ │            author_email='jason.swails@gmail.com',
│ │            url='https://parmed.github.io/ParmEd/html/index.html',
│ │            license='LGPL',
│ │            packages=packages,
│ │            ext_modules=extensions,
│ │            cmdclass=cmdclass,
│ │            package_data={'parmed.modeller': ['data/*.lib', 'data/*.json']},
│ │ +          python_requires='>=3.8',
│ │            **kws
│ │      )
│ │   --- ParmEd-4.0.0/src/_rdparm.cpp
│ ├── +++ ParmEd-4.1.0/src/_rdparm.cpp
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/src/main.cpp
│ ├── +++ ParmEd-4.1.0/src/main.cpp
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/src/readparm.cpp
│ ├── +++ ParmEd-4.1.0/src/readparm.cpp
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/src/readparm.h
│ ├── +++ ParmEd-4.1.0/src/readparm.h
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_format_conversions.py
│ ├── +++ ParmEd-4.1.0/test/test_format_conversions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_openmm_amber.py
│ ├── +++ ParmEd-4.1.0/test/test_openmm_amber.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_openmm_amber_forces.py
│ ├── +++ ParmEd-4.1.0/test/test_openmm_amber_forces.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_openmm_charmm.py
│ ├── +++ ParmEd-4.1.0/test/test_openmm_charmm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_openmm_gromacs.py
│ ├── +++ ParmEd-4.1.0/test/test_openmm_gromacs.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_openmm_reporters.py
│ ├── +++ ParmEd-4.1.0/test/test_openmm_reporters.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_amber.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_amber.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_charmm.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_charmm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_cif.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_cif.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_dlpoly.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_dlpoly.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_entos.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_entos.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_formats.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_formats.py
│ │┄ Files 1% similar despite different names
│ │ @@ -12,16 +12,16 @@
│ │  from parmed.symmetry import Symmetry
│ │  from parmed.modeller import ResidueTemplate, ResidueTemplateContainer
│ │  from parmed.utils import PYPY
│ │  import random
│ │  import os
│ │  import sys
│ │  import unittest
│ │ +import pytest
│ │  from utils import get_fn, diff_files, run_all_tests, is_local, HAS_GROMACS, FileIOTestCase
│ │ -import warnings
│ │  
│ │  def reset_stringio(io):
│ │      """ Resets a StringIO instance to "empty-file" state """
│ │      io.seek(0)
│ │      io.truncate()
│ │      return io
│ │  
│ │ @@ -2334,7 +2334,28 @@
│ │      bond_map = {make_bond_key(bond): bond for bond in pdb_struct.bonds}
│ │      for bond in cif_struct.bonds:
│ │          pdb_bond = bond_map[make_bond_key(bond)]
│ │          assert bond.qualitative_type == pdb_bond.qualitative_type
│ │  
│ │      assert not all(bond.qualitative_type is None for bond in cif_struct.bonds)
│ │  
│ │ +
│ │ +@pytest.mark.parametrize("filename", ["1az5_charges.pdb", "1az5_charges.cif"])
│ │ +def test_formal_charge_preservation(filename: str):
│ │ +    struct = pmd.load_file(get_fn(filename), expanded_residue_template_match=True)
│ │ +
│ │ +    assert struct.atoms[0].formal_charge == -1
│ │ +    assert struct.atoms[1].formal_charge == 0
│ │ +    assert struct.atoms[2].formal_charge == 1
│ │ +    assert struct.atoms[3].formal_charge == 2
│ │ +    assert struct.atoms[4].formal_charge == 3
│ │ +    assert struct.atoms[5].formal_charge == 4
│ │ +
│ │ +    # Now the rest are assigned from templates
│ │ +    residue_template_libraries = pmd.modeller.get_standard_residue_template_library()
│ │ +    for atom in struct.atoms[6:]:
│ │ +        atom_map = pmd.formats.pdb._atom_name_to_atom_map(atom.residue.name)
│ │ +        if not atom_map:
│ │ +            continue
│ │ +        template_charge = atom_map[atom.name].formal_charge if atom.name in atom_map else None
│ │ +        assert atom.formal_charge == template_charge
│ │ +
│ │   --- ParmEd-4.0.0/test/test_parmed_genopen.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_genopen.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_geometry.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_geometry.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_gromacs.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_gromacs.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_gromacs_cpp.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_gromacs_cpp.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_misc.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_misc.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_modeller.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_modeller.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_namd.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_namd.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_netcdf.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_netcdf.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_openmm.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_openmm.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_pandas.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_pandas.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_parameterset.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_parameterset.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_rdkit.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_rdkit.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_residue.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_residue.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_rosetta.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_rosetta.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_serialization.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_serialization.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_structure.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_structure.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_structure_slicing.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_structure_slicing.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_tinker.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_tinker.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_topologyobjects.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_topologyobjects.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmed_unit.py
│ ├── +++ ParmEd-4.1.0/test/test_parmed_unit.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmedtools_actions.py
│ ├── +++ ParmEd-4.1.0/test/test_parmedtools_actions.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_parmedtools_parmlist.py
│ ├── +++ ParmEd-4.1.0/test/test_parmedtools_parmlist.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/test/test_vec3.py
│ ├── +++ ParmEd-4.1.0/test/test_vec3.py
│ │┄ Files identical despite different names
│ │   --- ParmEd-4.0.0/versioneer.py
│ ├── +++ ParmEd-4.1.0/versioneer.py
│ │┄ Files identical despite different names
