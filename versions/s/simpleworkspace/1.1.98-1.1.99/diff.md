# Comparing `tmp/SimpleWorkspace-1.1.98-py3-none-any.whl.zip` & `tmp/SimpleWorkspace-1.1.99-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 20008 bytes, number of entries: 25
--rw-rw-rw-  2.0 fat     1643 b- defN 22-Dec-29 19:56 SimpleWorkspace/App.py
--rw-rw-rw-  2.0 fat     3231 b- defN 22-Dec-29 19:56 SimpleWorkspace/LogProviders.py
--rw-rw-rw-  2.0 fat     5320 b- defN 22-Dec-29 19:56 SimpleWorkspace/SettingsProviders.py
--rw-rw-rw-  2.0 fat      298 b- defN 22-Dec-29 19:56 SimpleWorkspace/__init__.py
--rw-rw-rw-  2.0 fat      848 b- defN 22-Dec-29 19:56 SimpleWorkspace/Enums/ByteEnum.py
--rw-rw-rw-  2.0 fat      128 b- defN 22-Dec-29 19:56 SimpleWorkspace/Enums/TimeEnum.py
--rw-rw-rw-  2.0 fat       61 b- defN 22-Dec-29 19:56 SimpleWorkspace/Enums/__init__.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Dec-29 19:56 SimpleWorkspace/Exceptions/__init__.py
--rw-rw-rw-  2.0 fat       21 b- defN 22-Dec-29 19:56 SimpleWorkspace/ExtLibs/__init__.py
--rw-rw-rw-  2.0 fat    24720 b- defN 22-Dec-29 20:06 SimpleWorkspace/ExtLibs/appdirs.py
--rw-rw-rw-  2.0 fat     3506 b- defN 22-Dec-29 19:56 SimpleWorkspace/IO/Directory.py
--rw-rw-rw-  2.0 fat     3650 b- defN 22-Dec-29 19:56 SimpleWorkspace/IO/File.py
--rw-rw-rw-  2.0 fat      771 b- defN 22-Dec-29 19:56 SimpleWorkspace/IO/Path.py
--rw-rw-rw-  2.0 fat       61 b- defN 22-Dec-29 19:56 SimpleWorkspace/IO/__init__.py
--rw-rw-rw-  2.0 fat     1139 b- defN 22-Dec-29 20:04 SimpleWorkspace/Utility/Console.py
--rw-rw-rw-  2.0 fat     3002 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/Log.py
--rw-rw-rw-  2.0 fat     1498 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/Module.py
--rw-rw-rw-  2.0 fat     4673 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/Regex.py
--rw-rw-rw-  2.0 fat     1851 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/StopWatch.py
--rw-rw-rw-  2.0 fat      204 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/String.py
--rw-rw-rw-  2.0 fat      101 b- defN 22-Dec-29 19:56 SimpleWorkspace/Utility/__init__.py
--rw-rw-rw-  2.0 fat      215 b- defN 22-Dec-29 20:06 SimpleWorkspace-1.1.98.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 22-Dec-29 20:06 SimpleWorkspace-1.1.98.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       16 b- defN 22-Dec-29 20:06 SimpleWorkspace-1.1.98.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2184 b- defN 22-Dec-29 20:06 SimpleWorkspace-1.1.98.dist-info/RECORD
-25 files, 59233 bytes uncompressed, 16422 bytes compressed:  72.3%
+Zip file size: 20109 bytes, number of entries: 25
+-rw-rw-rw-  2.0 fat     1679 b- defN 22-Nov-17 20:18 SimpleWorkspace/App.py
+-rw-rw-rw-  2.0 fat     3311 b- defN 22-Nov-17 20:42 SimpleWorkspace/LogProviders.py
+-rw-rw-rw-  2.0 fat     5457 b- defN 22-Nov-17 20:06 SimpleWorkspace/SettingsProviders.py
+-rw-rw-rw-  2.0 fat      305 b- defN 22-Nov-17 20:31 SimpleWorkspace/__init__.py
+-rw-rw-rw-  2.0 fat      871 b- defN 22-Nov-17 20:40 SimpleWorkspace/Enums/ByteEnum.py
+-rw-rw-rw-  2.0 fat      128 b- defN 22-Nov-17 20:31 SimpleWorkspace/Enums/TimeEnum.py
+-rw-rw-rw-  2.0 fat       61 b- defN 22-Nov-17 20:43 SimpleWorkspace/Enums/__init__.py
+-rw-rw-rw-  2.0 fat        0 b- defN 22-Nov-17 19:48 SimpleWorkspace/Exceptions/__init__.py
+-rw-rw-rw-  2.0 fat       21 b- defN 22-Nov-17 19:53 SimpleWorkspace/ExtLibs/__init__.py
+-rw-rw-rw-  2.0 fat    24720 b- defN 23-Jan-06 09:24 SimpleWorkspace/ExtLibs/appdirs.py
+-rw-rw-rw-  2.0 fat     3587 b- defN 22-Nov-17 20:06 SimpleWorkspace/IO/Directory.py
+-rw-rw-rw-  2.0 fat     3763 b- defN 22-Nov-18 09:52 SimpleWorkspace/IO/File.py
+-rw-rw-rw-  2.0 fat      794 b- defN 22-Nov-17 20:11 SimpleWorkspace/IO/Path.py
+-rw-rw-rw-  2.0 fat       61 b- defN 22-Nov-17 19:52 SimpleWorkspace/IO/__init__.py
+-rw-rw-rw-  2.0 fat     1186 b- defN 23-Jan-06 09:24 SimpleWorkspace/Utility/Console.py
+-rw-rw-rw-  2.0 fat     3095 b- defN 22-Nov-17 20:13 SimpleWorkspace/Utility/Log.py
+-rw-rw-rw-  2.0 fat     1498 b- defN 22-Nov-17 19:35 SimpleWorkspace/Utility/Module.py
+-rw-rw-rw-  2.0 fat     4673 b- defN 22-Nov-17 19:54 SimpleWorkspace/Utility/Regex.py
+-rw-rw-rw-  2.0 fat     1851 b- defN 22-Nov-18 10:32 SimpleWorkspace/Utility/StopWatch.py
+-rw-rw-rw-  2.0 fat      204 b- defN 22-Nov-17 19:37 SimpleWorkspace/Utility/String.py
+-rw-rw-rw-  2.0 fat      101 b- defN 22-Nov-17 19:52 SimpleWorkspace/Utility/__init__.py
+-rw-rw-rw-  2.0 fat      215 b- defN 23-Jan-06 09:24 SimpleWorkspace-1.1.99.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jan-06 09:24 SimpleWorkspace-1.1.99.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       16 b- defN 23-Jan-06 09:24 SimpleWorkspace-1.1.99.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2184 b- defN 23-Jan-06 09:24 SimpleWorkspace-1.1.99.dist-info/RECORD
+25 files, 59873 bytes uncompressed, 16523 bytes compressed:  72.4%
```

## zipnote {}

```diff
@@ -57,20 +57,20 @@
 
 Filename: SimpleWorkspace/Utility/String.py
 Comment: 
 
 Filename: SimpleWorkspace/Utility/__init__.py
 Comment: 
 
-Filename: SimpleWorkspace-1.1.98.dist-info/METADATA
+Filename: SimpleWorkspace-1.1.99.dist-info/METADATA
 Comment: 
 
-Filename: SimpleWorkspace-1.1.98.dist-info/WHEEL
+Filename: SimpleWorkspace-1.1.99.dist-info/WHEEL
 Comment: 
 
-Filename: SimpleWorkspace-1.1.98.dist-info/top_level.txt
+Filename: SimpleWorkspace-1.1.99.dist-info/top_level.txt
 Comment: 
 
-Filename: SimpleWorkspace-1.1.98.dist-info/RECORD
+Filename: SimpleWorkspace-1.1.99.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## SimpleWorkspace/App.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-from __future__ import annotations
-from logging import Logger
-import os as os
-import SimpleWorkspace as sw
-from SimpleWorkspace.SettingsProviders import SettingsManager_InteractiveConsole
-from SimpleWorkspace import LogProviders
-
-class App:
-    appName = None
-    appCompany = None
-    appTitle = None #example: "appname - appcompany"
-    appHash = 0 #appname + appcompany hashed together, numeric hash
-    path_currentAppData = ""            #windows example: 'C:\\Users\\username\\AppData\\Roaming\\AppCompany\\AppName'
-    path_currentAppData_storage = None  #windows example: 'C:\\Users\\username\\AppData\\Roaming\\AppCompany\\AppName\\Storage'
-
-    _loggerFilepath = None
-    logger = None #type: Logger
-    settingsManager = None #type: SettingsManager_InteractiveConsole
-
-    @staticmethod
-    def Setup(appName, appCompany=None):
-        App.appName = appName
-        App.appCompany = appCompany
-        App.appTitle = appName
-        if appCompany != None:
-            App.appTitle += " - " + appCompany
-        App.appHash = hash(App.appTitle)
-
-        App.path_currentAppData = sw.IO.Path.GetAppdataPath(appName, appCompany)
-        App.path_currentAppData_storage = os.path.join(App.path_currentAppData, "storage")
-        sw.IO.Directory.Create(App.path_currentAppData_storage)
-        
-        sw.App._loggerFilepath = os.path.join(App.path_currentAppData, "info.log")
-        sw.App.logger = LogProviders.RotatingFileLogger.GetLogger( sw.App._loggerFilepath)
-
-        sw.App.settingsManager = SettingsManager_InteractiveConsole(os.path.join(App.path_currentAppData, "config.json"))
+from __future__ import annotations
+from logging import Logger
+import os as os
+import SimpleWorkspace as sw
+from SimpleWorkspace.SettingsProviders import SettingsManager_InteractiveConsole
+from SimpleWorkspace import LogProviders
+
+class App:
+    appName = None
+    appCompany = None
+    appTitle = None #example: "appname - appcompany"
+    appHash = 0 #appname + appcompany hashed together, numeric hash
+    path_currentAppData = ""            #windows example: 'C:\\Users\\username\\AppData\\Roaming\\AppCompany\\AppName'
+    path_currentAppData_storage = None  #windows example: 'C:\\Users\\username\\AppData\\Roaming\\AppCompany\\AppName\\Storage'
+
+    _loggerFilepath = None
+    logger = None #type: Logger
+    settingsManager = None #type: SettingsManager_InteractiveConsole
+
+    @staticmethod
+    def Setup(appName, appCompany=None):
+        App.appName = appName
+        App.appCompany = appCompany
+        App.appTitle = appName
+        if appCompany != None:
+            App.appTitle += " - " + appCompany
+        App.appHash = hash(App.appTitle)
+
+        App.path_currentAppData = sw.IO.Path.GetAppdataPath(appName, appCompany)
+        App.path_currentAppData_storage = os.path.join(App.path_currentAppData, "storage")
+        sw.IO.Directory.Create(App.path_currentAppData_storage)
+        
+        sw.App._loggerFilepath = os.path.join(App.path_currentAppData, "info.log")
+        sw.App.logger = LogProviders.RotatingFileLogger.GetLogger( sw.App._loggerFilepath)
+
+        sw.App.settingsManager = SettingsManager_InteractiveConsole(os.path.join(App.path_currentAppData, "config.json"))
         sw.App.settingsManager.LoadSettings()
```

## SimpleWorkspace/LogProviders.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-from __future__ import annotations as _annotations
-import datetime as _datetime
-import gzip as _gzip
-import logging as _logging
-from logging.handlers import RotatingFileHandler as _RotatingFileHandler
-import time as _time
-import os as _os
-from SimpleWorkspace.Enums.ByteEnum import ByteEnum as _ByteEnum
-import sys as _sys
-
-class _BaseLogger:
-    @staticmethod
-    def DefaultFormatter(useUTCTime=True):
-        if useUTCTime:
-            formatter = _logging.Formatter(fmt="%(asctime)s.%(msecs)03d+0000 %(levelname)s <%(module)s,%(lineno)s>: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
-            formatter.converter = _time.gmtime
-        else:
-            timeZoneStr = _time.strftime("%z") # "+0200"
-            formatter = _logging.Formatter(fmt="%(asctime)s.%(msecs)03d" + timeZoneStr + " %(levelname)s <%(module)s,%(lineno)s>: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
-
-        return formatter
-
-
-class RotatingFileLogger:
-    @staticmethod
-    def GetLogger(filepath, minimumLogLevel=_logging.DEBUG, maxBytes=_ByteEnum.MB.value * 100, maxRotations=10, useUTCTime=True):
-        def rotator(source, dest):
-            with open(source, "rb") as sf:
-                gzip_fp = _gzip.open(dest, "wb")
-                gzip_fp.writelines(sf)
-                gzip_fp.close()
-            _os.remove(source)
-
-        logger = _logging.getLogger("__ROTATINGFILELOGGER_" + str(hash(f"{filepath}{minimumLogLevel}{maxBytes}{maxRotations}{useUTCTime}")))
-        if(logger.hasHandlers()):
-            return logger
-        logger.setLevel(minimumLogLevel)
-        handler = _RotatingFileHandler(filepath, maxBytes=maxBytes, backupCount=maxRotations)
-        handler.rotator = rotator
-        handler.namer = lambda name: name + ".gz"
-        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
-        logger.addHandler(handler)
-        return logger
-
-
-class FileLogger:
-    @staticmethod
-    def GetLogger(filepath, minimumLogLevel=_logging.DEBUG, useUTCTime=True):
-        logger = _logging.getLogger("__FILELOGGER_" + str(hash(f"{filepath}{minimumLogLevel}{useUTCTime}")))
-        if(logger.hasHandlers()):
-            return logger
-        logger.setLevel(minimumLogLevel)
-        handler = _logging.FileHandler(filepath)
-        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
-        logger.addHandler(handler)
-        return logger
-
-class StdoutLogger:
-    @staticmethod
-    def GetLogger(minimumLogLevel=_logging.DEBUG, useUTCTime=False):
-        stdoutLogger = _logging.getLogger("__STDOUTLOGGER__" + str(hash(f"{minimumLogLevel}{useUTCTime}")))
-        if(stdoutLogger.hasHandlers()):
-            return stdoutLogger
-        stdoutLogger.setLevel(minimumLogLevel)
-        handler = _logging.StreamHandler(_sys.stdout)
-        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
-        stdoutLogger.addHandler(handler)
-        return stdoutLogger
-
-
-class DummyLogger:
-    @staticmethod
-    def GetLogger():
-        dummyLogger = _logging.getLogger("@@BLACKHOLE@@")
-        if(dummyLogger.hasHandlers()):
-            return dummyLogger
-        dummyLogger.addHandler(_logging.NullHandler())
-        dummyLogger.propagate = False
-        return dummyLogger
-
+from __future__ import annotations as _annotations
+import datetime as _datetime
+import gzip as _gzip
+import logging as _logging
+from logging.handlers import RotatingFileHandler as _RotatingFileHandler
+import time as _time
+import os as _os
+from SimpleWorkspace.Enums.ByteEnum import ByteEnum as _ByteEnum
+import sys as _sys
+
+class _BaseLogger:
+    @staticmethod
+    def DefaultFormatter(useUTCTime=True):
+        if useUTCTime:
+            formatter = _logging.Formatter(fmt="%(asctime)s.%(msecs)03d+0000 %(levelname)s <%(module)s,%(lineno)s>: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
+            formatter.converter = _time.gmtime
+        else:
+            timeZoneStr = _time.strftime("%z") # "+0200"
+            formatter = _logging.Formatter(fmt="%(asctime)s.%(msecs)03d" + timeZoneStr + " %(levelname)s <%(module)s,%(lineno)s>: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
+
+        return formatter
+
+
+class RotatingFileLogger:
+    @staticmethod
+    def GetLogger(filepath, minimumLogLevel=_logging.DEBUG, maxBytes=_ByteEnum.MB.value * 100, maxRotations=10, useUTCTime=True):
+        def rotator(source, dest):
+            with open(source, "rb") as sf:
+                gzip_fp = _gzip.open(dest, "wb")
+                gzip_fp.writelines(sf)
+                gzip_fp.close()
+            _os.remove(source)
+
+        logger = _logging.getLogger("__ROTATINGFILELOGGER_" + str(hash(f"{filepath}{minimumLogLevel}{maxBytes}{maxRotations}{useUTCTime}")))
+        if(logger.hasHandlers()):
+            return logger
+        logger.setLevel(minimumLogLevel)
+        handler = _RotatingFileHandler(filepath, maxBytes=maxBytes, backupCount=maxRotations)
+        handler.rotator = rotator
+        handler.namer = lambda name: name + ".gz"
+        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
+        logger.addHandler(handler)
+        return logger
+
+
+class FileLogger:
+    @staticmethod
+    def GetLogger(filepath, minimumLogLevel=_logging.DEBUG, useUTCTime=True):
+        logger = _logging.getLogger("__FILELOGGER_" + str(hash(f"{filepath}{minimumLogLevel}{useUTCTime}")))
+        if(logger.hasHandlers()):
+            return logger
+        logger.setLevel(minimumLogLevel)
+        handler = _logging.FileHandler(filepath)
+        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
+        logger.addHandler(handler)
+        return logger
+
+class StdoutLogger:
+    @staticmethod
+    def GetLogger(minimumLogLevel=_logging.DEBUG, useUTCTime=False):
+        stdoutLogger = _logging.getLogger("__STDOUTLOGGER__" + str(hash(f"{minimumLogLevel}{useUTCTime}")))
+        if(stdoutLogger.hasHandlers()):
+            return stdoutLogger
+        stdoutLogger.setLevel(minimumLogLevel)
+        handler = _logging.StreamHandler(_sys.stdout)
+        handler.setFormatter(_BaseLogger.DefaultFormatter(useUTCTime=useUTCTime))
+        stdoutLogger.addHandler(handler)
+        return stdoutLogger
+
+
+class DummyLogger:
+    @staticmethod
+    def GetLogger():
+        dummyLogger = _logging.getLogger("@@BLACKHOLE@@")
+        if(dummyLogger.hasHandlers()):
+            return dummyLogger
+        dummyLogger.addHandler(_logging.NullHandler())
+        dummyLogger.propagate = False
+        return dummyLogger
+
```

## SimpleWorkspace/SettingsProviders.py

 * *Ordering differences only*

```diff
@@ -1,138 +1,138 @@
-from __future__ import annotations as _annotations
-from abc import ABC, abstractmethod
-from SimpleWorkspace.Utility import Console as _ConsoleUtility
-import os as _os
-import json as _json
-import SimpleWorkspace as _sw
-
-class SettingsManager_Base(ABC):
-    _settingsPath = None
-    settings = {}
-
-    def __init__(self, settingsPath):
-        self._settingsPath = settingsPath
-        self.settings = self._GetDefaultSettings()
-
-    def _GetDefaultSettings(self):
-        return {}
-
-    @abstractmethod
-    def _ParseSettingsFile(filepath):
-        pass
-    @abstractmethod
-    def _ExportSettingsFile(settingsObject, outputPath):
-        pass
-
-    def ClearSettings(self):
-        self.settings = self._GetDefaultSettings()
-
-    def LoadSettings(self):
-        self.ClearSettings()
-        if not (_os.path.exists(self._settingsPath)):
-            return
-        if _os.path.getsize(self._settingsPath) == 0:
-            return
-        try:
-            self._ParseSettingsFile(self._settingsPath)
-        except Exception as e:
-            _os.rename(self._settingsPath, self._settingsPath + ".bak")
-        return self.settings
-
-    def SaveSettings(self):
-        self._ExportSettingsFile(self.settings, self._settingsPath)
-
-
-class SettingsManager_JSON(SettingsManager_Base):
-    def _ParseSettingsFile(self, filepath):
-        self.settings = _json.loads(_sw.IO.File.Read(filepath))
-        return
-
-    def _ExportSettingsFile(self, settingsObject, outputPath):
-        jsonData = _json.dumps(settingsObject)
-        _sw.IO.File.Create(outputPath, jsonData)
-        return
-
-
-
-class SettingsManager_InteractiveConsole(SettingsManager_JSON):
-    __Command_Delete = "#delete"
-
-    def __Console_ChangeSettings(self):
-        while True:
-            _ConsoleUtility.ClearConsoleWindow()
-            _ConsoleUtility.LevelPrint(0, "[Change Settings]")
-            _ConsoleUtility.LevelPrint(1, "0. Save Settings and go back.(Type cancel to discard changes)")
-            _ConsoleUtility.LevelPrint(1, "1. Add a new setting")
-            _ConsoleUtility.LevelPrint(2, "[Current Settings]")
-            dictlist = []
-            dictlist_start = 2
-            dictlist_count = 2
-            for key in self.settings:
-                _ConsoleUtility.LevelPrint(3, str(dictlist_count) + ". " + key + " : " + str(self.settings[key]))
-                dictlist.append(key)
-                dictlist_count += 1
-            _ConsoleUtility.LevelPrint(1)
-            choice = input("-Choice: ")
-            if choice == "cancel":
-                self.LoadSettings()
-                _ConsoleUtility.AnyKeyDialog("Discarded changes!")
-                break
-            if choice == "0":
-                self.SaveSettings()
-                _ConsoleUtility.LevelPrint(1)
-                _ConsoleUtility.AnyKeyDialog("Saved Settings!")
-                break
-            elif choice == "1":
-                _ConsoleUtility.LevelPrint(1, "Setting Name:")
-                keyChoice = _ConsoleUtility.LevelInput(1, "-")
-                _ConsoleUtility.LevelPrint(1, "Setting Value")
-                valueChoice = _ConsoleUtility.LevelInput(1, "-")
-                self.settings[keyChoice] = valueChoice
-            else:
-                IntChoice = None
-                try:
-                    IntChoice = int(choice)
-                except Exception as e:
-                    pass
-                if IntChoice == None or (IntChoice >= dictlist_start and IntChoice < dictlist_count):
-                    continue
-                else:
-                    key = dictlist[IntChoice - dictlist_start]
-                    _ConsoleUtility.LevelPrint(2, '(Leave empty to cancel, or type "' + self.__Command_Delete + '" to remove setting)')
-                    _ConsoleUtility.LevelPrint(2, ">> " + str(self.settings[key]))
-                    choice = _ConsoleUtility.LevelInput(2, "Enter new value: ")
-                    if choice == "":
-                        continue
-                    elif choice == self.__Command_Delete:
-                        del self.settings[key]
-                    else:
-                        self.settings[key] = choice
-        return
-
-    def Console_PrintSettingsMenu(self):
-        while(True):
-            _ConsoleUtility.ClearConsoleWindow()
-            _ConsoleUtility.LevelPrint(0, "[Settings Menu]")
-            _ConsoleUtility.LevelPrint(1, "1.Change settings")
-            _ConsoleUtility.LevelPrint(1, "2.Reset settings")
-            _ConsoleUtility.LevelPrint(1, "3.Open Settings Directory")
-            _ConsoleUtility.LevelPrint(1, "0.Go back")
-            _ConsoleUtility.LevelPrint(1)
-            choice = input("-")
-            if choice == "1":
-                self.__Console_ChangeSettings()
-            elif choice == "2":
-                _ConsoleUtility.LevelPrint(1, "-Confirm Reset! (y/n)")
-                choice = _ConsoleUtility.LevelInput(1, "-")
-                if choice == "y":
-                    self.ClearSettings()
-                    self.SaveSettings()
-                    _ConsoleUtility.LevelPrint(1)
-                    _ConsoleUtility.AnyKeyDialog("*Settings resetted!")
-            elif choice == "3":
-                fileInfo = _sw.IO.File.FileInfo(self._settingsPath)
-                _os.startfile(fileInfo.tail)
-            else:
-                break
-        return
+from __future__ import annotations as _annotations
+from abc import ABC, abstractmethod
+from SimpleWorkspace.Utility import Console as _ConsoleUtility
+import os as _os
+import json as _json
+import SimpleWorkspace as _sw
+
+class SettingsManager_Base(ABC):
+    _settingsPath = None
+    settings = {}
+
+    def __init__(self, settingsPath):
+        self._settingsPath = settingsPath
+        self.settings = self._GetDefaultSettings()
+
+    def _GetDefaultSettings(self):
+        return {}
+
+    @abstractmethod
+    def _ParseSettingsFile(filepath):
+        pass
+    @abstractmethod
+    def _ExportSettingsFile(settingsObject, outputPath):
+        pass
+
+    def ClearSettings(self):
+        self.settings = self._GetDefaultSettings()
+
+    def LoadSettings(self):
+        self.ClearSettings()
+        if not (_os.path.exists(self._settingsPath)):
+            return
+        if _os.path.getsize(self._settingsPath) == 0:
+            return
+        try:
+            self._ParseSettingsFile(self._settingsPath)
+        except Exception as e:
+            _os.rename(self._settingsPath, self._settingsPath + ".bak")
+        return self.settings
+
+    def SaveSettings(self):
+        self._ExportSettingsFile(self.settings, self._settingsPath)
+
+
+class SettingsManager_JSON(SettingsManager_Base):
+    def _ParseSettingsFile(self, filepath):
+        self.settings = _json.loads(_sw.IO.File.Read(filepath))
+        return
+
+    def _ExportSettingsFile(self, settingsObject, outputPath):
+        jsonData = _json.dumps(settingsObject)
+        _sw.IO.File.Create(outputPath, jsonData)
+        return
+
+
+
+class SettingsManager_InteractiveConsole(SettingsManager_JSON):
+    __Command_Delete = "#delete"
+
+    def __Console_ChangeSettings(self):
+        while True:
+            _ConsoleUtility.ClearConsoleWindow()
+            _ConsoleUtility.LevelPrint(0, "[Change Settings]")
+            _ConsoleUtility.LevelPrint(1, "0. Save Settings and go back.(Type cancel to discard changes)")
+            _ConsoleUtility.LevelPrint(1, "1. Add a new setting")
+            _ConsoleUtility.LevelPrint(2, "[Current Settings]")
+            dictlist = []
+            dictlist_start = 2
+            dictlist_count = 2
+            for key in self.settings:
+                _ConsoleUtility.LevelPrint(3, str(dictlist_count) + ". " + key + " : " + str(self.settings[key]))
+                dictlist.append(key)
+                dictlist_count += 1
+            _ConsoleUtility.LevelPrint(1)
+            choice = input("-Choice: ")
+            if choice == "cancel":
+                self.LoadSettings()
+                _ConsoleUtility.AnyKeyDialog("Discarded changes!")
+                break
+            if choice == "0":
+                self.SaveSettings()
+                _ConsoleUtility.LevelPrint(1)
+                _ConsoleUtility.AnyKeyDialog("Saved Settings!")
+                break
+            elif choice == "1":
+                _ConsoleUtility.LevelPrint(1, "Setting Name:")
+                keyChoice = _ConsoleUtility.LevelInput(1, "-")
+                _ConsoleUtility.LevelPrint(1, "Setting Value")
+                valueChoice = _ConsoleUtility.LevelInput(1, "-")
+                self.settings[keyChoice] = valueChoice
+            else:
+                IntChoice = None
+                try:
+                    IntChoice = int(choice)
+                except Exception as e:
+                    pass
+                if IntChoice == None or (IntChoice >= dictlist_start and IntChoice < dictlist_count):
+                    continue
+                else:
+                    key = dictlist[IntChoice - dictlist_start]
+                    _ConsoleUtility.LevelPrint(2, '(Leave empty to cancel, or type "' + self.__Command_Delete + '" to remove setting)')
+                    _ConsoleUtility.LevelPrint(2, ">> " + str(self.settings[key]))
+                    choice = _ConsoleUtility.LevelInput(2, "Enter new value: ")
+                    if choice == "":
+                        continue
+                    elif choice == self.__Command_Delete:
+                        del self.settings[key]
+                    else:
+                        self.settings[key] = choice
+        return
+
+    def Console_PrintSettingsMenu(self):
+        while(True):
+            _ConsoleUtility.ClearConsoleWindow()
+            _ConsoleUtility.LevelPrint(0, "[Settings Menu]")
+            _ConsoleUtility.LevelPrint(1, "1.Change settings")
+            _ConsoleUtility.LevelPrint(1, "2.Reset settings")
+            _ConsoleUtility.LevelPrint(1, "3.Open Settings Directory")
+            _ConsoleUtility.LevelPrint(1, "0.Go back")
+            _ConsoleUtility.LevelPrint(1)
+            choice = input("-")
+            if choice == "1":
+                self.__Console_ChangeSettings()
+            elif choice == "2":
+                _ConsoleUtility.LevelPrint(1, "-Confirm Reset! (y/n)")
+                choice = _ConsoleUtility.LevelInput(1, "-")
+                if choice == "y":
+                    self.ClearSettings()
+                    self.SaveSettings()
+                    _ConsoleUtility.LevelPrint(1)
+                    _ConsoleUtility.AnyKeyDialog("*Settings resetted!")
+            elif choice == "3":
+                fileInfo = _sw.IO.File.FileInfo(self._settingsPath)
+                _os.startfile(fileInfo.tail)
+            else:
+                break
+        return
```

## SimpleWorkspace/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-from SimpleWorkspace import Enums
-from SimpleWorkspace import Exceptions
-from SimpleWorkspace import ExtLibs
-from SimpleWorkspace import IO
-from SimpleWorkspace import Utility
-from SimpleWorkspace import LogProviders
-from SimpleWorkspace import SettingsProviders
+from SimpleWorkspace import Enums
+from SimpleWorkspace import Exceptions
+from SimpleWorkspace import ExtLibs
+from SimpleWorkspace import IO
+from SimpleWorkspace import Utility
+from SimpleWorkspace import LogProviders
+from SimpleWorkspace import SettingsProviders
 from SimpleWorkspace.App import App
```

## SimpleWorkspace/Enums/ByteEnum.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-from enum import Enum as _Enum
-class ByteEnum(_Enum):
-    B = 1
-    KB = 1000
-    MB = KB * 1000
-    GB = MB * 1000
-    TB = GB * 1000
-
-    def GetStringRepresentation(self, byteCount: int, precisionDecimals=2):
-        """
-        :param prefix: b, kb, mb, gb
-        """
-        if self == ByteEnum.B:
-            return str(byteCount) + " B"
-        elif self == ByteEnum.KB:
-            return str(round(byteCount / ByteEnum.KB.value, precisionDecimals)) + " KB"
-        elif self == ByteEnum.MB:
-            return str(round(byteCount / ByteEnum.MB.value, precisionDecimals)) + " MB"
-        elif self == ByteEnum.GB:
-            return str(round(byteCount / ByteEnum.GB.value, precisionDecimals)) + " GB"
-        elif self == ByteEnum.TB:
-            return str(round(byteCount / ByteEnum.TB.value, precisionDecimals)) + " TB"
-        return
+from enum import Enum as _Enum
+class ByteEnum(_Enum):
+    B = 1
+    KB = 1000
+    MB = KB * 1000
+    GB = MB * 1000
+    TB = GB * 1000
+
+    def GetStringRepresentation(self, byteCount: int, precisionDecimals=2):
+        """
+        :param prefix: b, kb, mb, gb
+        """
+        if self == ByteEnum.B:
+            return str(byteCount) + " B"
+        elif self == ByteEnum.KB:
+            return str(round(byteCount / ByteEnum.KB.value, precisionDecimals)) + " KB"
+        elif self == ByteEnum.MB:
+            return str(round(byteCount / ByteEnum.MB.value, precisionDecimals)) + " MB"
+        elif self == ByteEnum.GB:
+            return str(round(byteCount / ByteEnum.GB.value, precisionDecimals)) + " GB"
+        elif self == ByteEnum.TB:
+            return str(round(byteCount / ByteEnum.TB.value, precisionDecimals)) + " TB"
+        return
```

## SimpleWorkspace/IO/Directory.py

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-from __future__ import annotations
-from typing import Callable as _Callable
-import SimpleWorkspace as _sw
-from queue import Queue as _Queue
-import os as _os
-import shutil as _shutil
-
-def Create(path: str):
-    _os.makedirs(path, exist_ok=True)
-
-def List(searchDir: str, callback: _Callable[[str], None] = None, includeDirs=True, includeFilter:str=None, satisfiedCondition: _Callable[[str], bool] = None, exceptionCallback: _Callable[[Exception], None] = None, maxRecursionDepth: int=None) -> (list[str] | None):
-    """
-    Recursively iterate all driectories in a path.
-    All encountered exceptions are ignored
-
-    @param callback
-        feeds full filepath to a callback
-    @param includeFilter
-        options takes a regex which searches full path of each file, if anyone matches a callback is called. Example: "/mySearchCriteria/i"
-    @param satisfiedCondition
-        takes a callback that returns a bool, if it returns true, no more search is performed
-    @param exceptionCallback
-        run callback on any raised exception
-    @param maxRecursionDepth
-        Specify how many levels down to list folders, level/depth 1 is basically searchDir entries
-    @returns
-        if no callback is given, a list of all found filepaths will be returned\n
-        otherwise None
-    """
-
-    if not _os.path.exists(searchDir):
-        return
-
-    # only returned if callback was not given
-    allEntries = [] if (callback is None) else None
-
-    currentFolderDepth = 1 #this is basically the base directory depth with its entries and therefore the minimum value
-    folders = _Queue()
-    folders.put(searchDir)
-    while folders.qsize() != 0:
-        currentFolder = folders.get()
-        try:
-            currentFiles = _os.listdir(currentFolder)
-            for filePath in currentFiles:
-                filePath = _os.path.join(currentFolder, filePath)
-                pathMatchesIncludeFilter = includeFilter == None or _sw.Utility.Regex.Match(includeFilter, filePath) != None
-                if _os.path.isfile(filePath):
-                    if pathMatchesIncludeFilter:
-                        if callback != None:
-                            try:
-                                callback(filePath)
-                            except Exception as e:
-                                if(exceptionCallback != None):
-                                    exceptionCallback(e)
-                        else:
-                            allEntries.append(filePath)
-                else:
-                    if includeDirs:
-                        if pathMatchesIncludeFilter:
-                            if callback != None:
-                                try:
-                                    callback(filePath)
-                                except Exception as e:
-                                    if(exceptionCallback != None):
-                                        exceptionCallback(e)
-                            else:
-                                allEntries.append(filePath)
-                    folders.put(filePath)
-                if satisfiedCondition != None and satisfiedCondition(filePath):
-                    return
-            currentFolderDepth += 1
-            if (maxRecursionDepth != None) and (currentFolderDepth > maxRecursionDepth):
-                break
-        except Exception as e:
-            if(exceptionCallback != None):
-                exceptionCallback(e)
-    return allEntries
-
-
-def Remove(path: str) -> None:
-    _shutil.rmtree(path, ignore_errors=True)
+from __future__ import annotations
+from typing import Callable as _Callable
+import SimpleWorkspace as _sw
+from queue import Queue as _Queue
+import os as _os
+import shutil as _shutil
+
+def Create(path: str):
+    _os.makedirs(path, exist_ok=True)
+
+def List(searchDir: str, callback: _Callable[[str], None] = None, includeDirs=True, includeFilter:str=None, satisfiedCondition: _Callable[[str], bool] = None, exceptionCallback: _Callable[[Exception], None] = None, maxRecursionDepth: int=None) -> (list[str] | None):
+    """
+    Recursively iterate all driectories in a path.
+    All encountered exceptions are ignored
+
+    @param callback
+        feeds full filepath to a callback
+    @param includeFilter
+        options takes a regex which searches full path of each file, if anyone matches a callback is called. Example: "/mySearchCriteria/i"
+    @param satisfiedCondition
+        takes a callback that returns a bool, if it returns true, no more search is performed
+    @param exceptionCallback
+        run callback on any raised exception
+    @param maxRecursionDepth
+        Specify how many levels down to list folders, level/depth 1 is basically searchDir entries
+    @returns
+        if no callback is given, a list of all found filepaths will be returned\n
+        otherwise None
+    """
+
+    if not _os.path.exists(searchDir):
+        return
+
+    # only returned if callback was not given
+    allEntries = [] if (callback is None) else None
+
+    currentFolderDepth = 1 #this is basically the base directory depth with its entries and therefore the minimum value
+    folders = _Queue()
+    folders.put(searchDir)
+    while folders.qsize() != 0:
+        currentFolder = folders.get()
+        try:
+            currentFiles = _os.listdir(currentFolder)
+            for filePath in currentFiles:
+                filePath = _os.path.join(currentFolder, filePath)
+                pathMatchesIncludeFilter = includeFilter == None or _sw.Utility.Regex.Match(includeFilter, filePath) != None
+                if _os.path.isfile(filePath):
+                    if pathMatchesIncludeFilter:
+                        if callback != None:
+                            try:
+                                callback(filePath)
+                            except Exception as e:
+                                if(exceptionCallback != None):
+                                    exceptionCallback(e)
+                        else:
+                            allEntries.append(filePath)
+                else:
+                    if includeDirs:
+                        if pathMatchesIncludeFilter:
+                            if callback != None:
+                                try:
+                                    callback(filePath)
+                                except Exception as e:
+                                    if(exceptionCallback != None):
+                                        exceptionCallback(e)
+                            else:
+                                allEntries.append(filePath)
+                    folders.put(filePath)
+                if satisfiedCondition != None and satisfiedCondition(filePath):
+                    return
+            currentFolderDepth += 1
+            if (maxRecursionDepth != None) and (currentFolderDepth > maxRecursionDepth):
+                break
+        except Exception as e:
+            if(exceptionCallback != None):
+                exceptionCallback(e)
+    return allEntries
+
+
+def Remove(path: str) -> None:
+    _shutil.rmtree(path, ignore_errors=True)
```

## SimpleWorkspace/IO/File.py

 * *Ordering differences only*

```diff
@@ -1,113 +1,113 @@
-from __future__ import annotations
-import hashlib as _hashlib
-import os as _os
-from typing import Callable as _Callable
-import SimpleWorkspace as _sw
-
-
-class FileInfo:
-    """
-    example case: a/b/test.exe\n
-    - filename      = test\n
-    - fileExtension = .exe\n
-    - tail          = a/b/\n
-    - head          = test.exe\n
-    - rawPath       = a/b/test.exe\n
-
-    - If no match can be found for any property, they will default to empty string
-    """
-
-    tail = ""
-    '''example case: a/b/test.exe -> a/b/'''
-    head = ""
-    '''example case: a/b/test.exe -> test.exe'''
-    filename = ""
-    '''example case: a/b/test.exe -> test'''
-    fileExtension = ""
-    '''example case: a/b/test.exe -> .exe'''
-    rawPath = ""
-    '''example case: a/b/test.exe -> a/b/test.exe'''
-
-    def __init__(self, filepath) -> None:
-        self.rawPath = filepath
-        headTail = _os.path.split(filepath)
-        self.tail = headTail[0]
-        if self.tail != "":
-            self.tail += "/"
-        self.head = headTail[1]
-        baseName = headTail[1]
-
-        fullFilename = baseName.rsplit(".", 1)
-        self.filename = fullFilename[0]
-        if len(fullFilename) == 2:
-            self.fileExtension = "." + fullFilename[1]
-
-
-def Hash(filePath: str, hashFunc=_hashlib.sha256()) -> str:
-    Read(filePath, lambda x: hashFunc.update(x), readSize=_sw.Enums.ByteEnum.MB.value * 1, getBytes=True)
-    return hashFunc.hexdigest()
-
-def Read(filePath: str, callback: _Callable[[str | bytes], None] = None, readSize=-1, readLimit=-1, getBytes=False, normalizeLineEndings=True) -> (str | bytes | None):
-    """
-    :callback:
-        the callback is triggered each time a file is read with the readSize, \n
-        callback recieves one parameter as bytes or str depending on getBytes param
-    :readSize: amount of bytes to read at each callback, default of -1 reads all at once\n
-    :ReadLimit: Max amount of bytes to read, default -1 reads until end of file\n
-    :getBytes: specifies if the data returned is in string or bytes format\n
-    :NormalizeLineEndings: default True, if getBytes is false aka reading as string, then change \\r\\n to \\n \n
-
-    :Returns
-        if no callback is used, the filecontent will be returned\n
-        otherwise None
-    """
-
-    content = b""
-    if not getBytes:
-        content = ""
-
-    if (readSize == -1 and readLimit >= 0) or (readLimit < readSize and readLimit >= 0):
-        readSize = readLimit
-
-    openMode = "rb"
-    totalRead = 0
-    with open(filePath, openMode) as fp:
-        while True:
-            if readLimit != -1 and totalRead >= readLimit:
-                break
-            data = fp.read(readSize)
-            totalRead += readSize
-            if data:
-                if not getBytes:
-                    data = data.decode()
-                    if normalizeLineEndings:
-                        data = data.replace("\r\n", "\n")
-                if callback == None:
-                    content += data
-                else:
-                    callback(data)
-            else:
-                break
-
-    if callback is None:
-        return content
-    return None
-
-
-    
-def Create(filepath: str, data: bytes | str = None):
-    if type(data) is str:
-        data = data.encode()
-    with open(filepath, "wb") as file:
-        if data is not None:
-            file.write(data)
-
-def Append(filepath: str, data: bytes | str):
-    if type(data) is bytes:
-        pass  # all good
-    elif type(data) is str:
-        data = data.encode()
-    else:
-        raise Exception("Only bytes or string can be used to append to file")
-    with open(filepath, "ab") as file:
-        file.write(data)
+from __future__ import annotations
+import hashlib as _hashlib
+import os as _os
+from typing import Callable as _Callable
+import SimpleWorkspace as _sw
+
+
+class FileInfo:
+    """
+    example case: a/b/test.exe\n
+    - filename      = test\n
+    - fileExtension = .exe\n
+    - tail          = a/b/\n
+    - head          = test.exe\n
+    - rawPath       = a/b/test.exe\n
+
+    - If no match can be found for any property, they will default to empty string
+    """
+
+    tail = ""
+    '''example case: a/b/test.exe -> a/b/'''
+    head = ""
+    '''example case: a/b/test.exe -> test.exe'''
+    filename = ""
+    '''example case: a/b/test.exe -> test'''
+    fileExtension = ""
+    '''example case: a/b/test.exe -> .exe'''
+    rawPath = ""
+    '''example case: a/b/test.exe -> a/b/test.exe'''
+
+    def __init__(self, filepath) -> None:
+        self.rawPath = filepath
+        headTail = _os.path.split(filepath)
+        self.tail = headTail[0]
+        if self.tail != "":
+            self.tail += "/"
+        self.head = headTail[1]
+        baseName = headTail[1]
+
+        fullFilename = baseName.rsplit(".", 1)
+        self.filename = fullFilename[0]
+        if len(fullFilename) == 2:
+            self.fileExtension = "." + fullFilename[1]
+
+
+def Hash(filePath: str, hashFunc=_hashlib.sha256()) -> str:
+    Read(filePath, lambda x: hashFunc.update(x), readSize=_sw.Enums.ByteEnum.MB.value * 1, getBytes=True)
+    return hashFunc.hexdigest()
+
+def Read(filePath: str, callback: _Callable[[str | bytes], None] = None, readSize=-1, readLimit=-1, getBytes=False, normalizeLineEndings=True) -> (str | bytes | None):
+    """
+    :callback:
+        the callback is triggered each time a file is read with the readSize, \n
+        callback recieves one parameter as bytes or str depending on getBytes param
+    :readSize: amount of bytes to read at each callback, default of -1 reads all at once\n
+    :ReadLimit: Max amount of bytes to read, default -1 reads until end of file\n
+    :getBytes: specifies if the data returned is in string or bytes format\n
+    :NormalizeLineEndings: default True, if getBytes is false aka reading as string, then change \\r\\n to \\n \n
+
+    :Returns
+        if no callback is used, the filecontent will be returned\n
+        otherwise None
+    """
+
+    content = b""
+    if not getBytes:
+        content = ""
+
+    if (readSize == -1 and readLimit >= 0) or (readLimit < readSize and readLimit >= 0):
+        readSize = readLimit
+
+    openMode = "rb"
+    totalRead = 0
+    with open(filePath, openMode) as fp:
+        while True:
+            if readLimit != -1 and totalRead >= readLimit:
+                break
+            data = fp.read(readSize)
+            totalRead += readSize
+            if data:
+                if not getBytes:
+                    data = data.decode()
+                    if normalizeLineEndings:
+                        data = data.replace("\r\n", "\n")
+                if callback == None:
+                    content += data
+                else:
+                    callback(data)
+            else:
+                break
+
+    if callback is None:
+        return content
+    return None
+
+
+    
+def Create(filepath: str, data: bytes | str = None):
+    if type(data) is str:
+        data = data.encode()
+    with open(filepath, "wb") as file:
+        if data is not None:
+            file.write(data)
+
+def Append(filepath: str, data: bytes | str):
+    if type(data) is bytes:
+        pass  # all good
+    elif type(data) is str:
+        data = data.encode()
+    else:
+        raise Exception("Only bytes or string can be used to append to file")
+    with open(filepath, "ab") as file:
+        file.write(data)
```

## SimpleWorkspace/IO/Path.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-from __future__ import annotations
-from SimpleWorkspace.ExtLibs import appdirs as _appdirs
-import SimpleWorkspace as _sw
-import os as _os
-
-
-def FindEmptySpot(filepath: str):
-    fileContainer = _sw.IO.File.FileInfo(filepath)
-    TmpPath = filepath
-    i = 1
-    while _os.path.exists(TmpPath) == True:
-        TmpPath = fileContainer.tail + fileContainer.filename + "(" + str(i) + ")" + fileContainer.fileEnding
-        i += 1
-    return TmpPath
-
-def GetAppdataPath(appName=None, companyName=None):
-    """
-    Retrieves roaming Appdata folder.\n
-    no arguments        -> %appdata%/\n
-    appName only        -> %appdata%/appname\n
-    appname and company -> %appdata%/appname/companyName\n
-    """
-    return _appdirs.user_data_dir(appName, companyName, roaming=True)
+from __future__ import annotations
+from SimpleWorkspace.ExtLibs import appdirs as _appdirs
+import SimpleWorkspace as _sw
+import os as _os
+
+
+def FindEmptySpot(filepath: str):
+    fileContainer = _sw.IO.File.FileInfo(filepath)
+    TmpPath = filepath
+    i = 1
+    while _os.path.exists(TmpPath) == True:
+        TmpPath = fileContainer.tail + fileContainer.filename + "(" + str(i) + ")" + fileContainer.fileEnding
+        i += 1
+    return TmpPath
+
+def GetAppdataPath(appName=None, companyName=None):
+    """
+    Retrieves roaming Appdata folder.\n
+    no arguments        -> %appdata%/\n
+    appName only        -> %appdata%/appname\n
+    appname and company -> %appdata%/appname/companyName\n
+    """
+    return _appdirs.user_data_dir(appName, companyName, roaming=True)
```

## SimpleWorkspace/Utility/Console.py

```diff
@@ -1,50 +1,50 @@
-import os as _os
-import shlex as _shlex
-
-def LevelPrint(level, msg=None):
-    for i in range(level):
-        print("    ", end="", flush=True)
-    if msg != None:
-        print(msg)
-
-
-def LevelInput(level, msg=""):
-    LevelPrint(level)
-    return input(msg)
-
-
-def AnyKeyDialog(msg=""):
-    if msg != "":
-        msg += " - "
-    msg += "Press enter to continue..."
-    input(msg)
-
-
-def ClearConsoleWindow():
-    _os.system("cls" if _os.name == "nt" else "clear")
-    return
-
-def Prompt_YesOrNo(msg) -> bool:
-    '''
-    prompts user indefinitely until one of the choices are picked
-
-    output style: <msg> - yes/no?
-    @return: boolean yes=True, no=False
-    '''
-    while(True):
-        answer = input(msg + " - yes/no?").lower()
-        if(answer == "yes"):
-            return True
-        elif(answer == "no"):
-            return False
-
-
-
-def Print_SelectFileDialog(message="Enter File Paths",printlevel=0) -> list[str]|None:
-    LevelPrint(printlevel, f"-{message}")
-    filepathString = LevelInput(printlevel, "-")
-    filepaths = _shlex.split(filepathString)
-    if(len(filepaths) == 0):
-        return None
-    return filepaths
-
+import os as _os
+import shlex as _shlex
+
+def LevelPrint(level, msg=None):
+    for i in range(level):
+        print("    ", end="", flush=True)
+    if msg != None:
+        print(msg)
+
+
+def LevelInput(level, msg=""):
+    LevelPrint(level)
+    return input(msg)
+
+
+def AnyKeyDialog(msg=""):
+    if msg != "":
+        msg += " - "
+    msg += "Press enter to continue..."
+    input(msg)
+
+
+def ClearConsoleWindow():
+    _os.system("cls" if _os.name == "nt" else "clear")
+    return
+
+def Prompt_YesOrNo(msg:str) -> bool:
+    '''
+    prompts user indefinitely until one of the choices are picked
+
+    output style: <msg>? [Y/N]:
+    @return: boolean yes=True, no=False
+    '''
+    while(True):
+        answer = input(msg + "? [Y/N]:").upper()
+        if(answer == "Y"):
+            return True
+        elif(answer == "N"):
+            return False
+
+
+
+def Print_SelectFileDialog(message="Enter File Paths",printlevel=0) -> list[str]|None:
+    LevelPrint(printlevel, f"-{message}")
+    filepathString = LevelInput(printlevel, "-")
+    filepaths = _shlex.split(filepathString)
+    if(len(filepaths) == 0):
+        return None
+    return filepaths
+
```

## SimpleWorkspace/Utility/Log.py

 * *Ordering differences only*

```diff
@@ -1,93 +1,93 @@
-from __future__ import annotations as _annotations
-import inspect as _inspect
-import logging as _logging
-import re as _re
-from typing import Callable as _Callable
-from io import StringIO as _StringIO
-import os as _os
-import SimpleWorkspace as _sw
-import gzip as _gzip
-
-class RotatingLogReader:
-    def __init__(self, logPath: str):
-        """
-        @param logPath:
-            the full path to a live log, such as /var/log/apache/access.log,
-            The parser handles already rotated files behind the scenes
-        """
-
-        self.logPath = _os.path.realpath(logPath)
-        self.logFileName = _os.path.basename(self.logPath)
-        self.logBaseDirectory = _os.path.dirname(self.logPath)
-        self._internalBuffer = None
-
-    def To_String(self):
-        """
-        @returns All logs dumped to a string
-        """
-        strBuilder = _StringIO()
-        def writeFunc(line:str):
-            strBuilder.write(line)
-            return False
-        self.Read(writeFunc)
-        return strBuilder.getvalue()
-
-    def To_File(self, outputPath):
-        """
-        Dumps all logs as one file
-        """
-
-
-        with open(outputPath, "w") as fp:
-            def writeFunc(line: str):
-                fp.write(line)
-                return False
-            self.Read(writeFunc)
-        return
-
-    def GetRelatedLogFilePaths(self) -> list[str]:
-        """
-        @returns list of paths to the log itself + all of its rotated files, sorted newest to oldest logs example [log.txt, log.txt.1, log.txt.2.gz]
-        """
-        logFiles = {}
-        def logFilesFiltering(path: str):
-            currentLogname = _os.path.basename(path)
-            if(self.logFileName not in currentLogname):
-                return
-            if(self.logFileName == currentLogname):
-                logFiles[0] = path
-                return
-            escLogName = _re.escape(self.logFileName)
-            match = _sw.Utility.Regex.Match(f"/^{escLogName}\.(\d+)/", currentLogname)[0]
-            logFiles[int(match[1])] = path
-            return
-        _sw.IO.Directory.List(self.logBaseDirectory, callback=logFilesFiltering, includeDirs=False, maxRecursionDepth=1)
-
-        sortedLogFiles = []
-        sortedKeyList = sorted(logFiles.keys())
-        for i in sortedKeyList:
-            sortedLogFiles.append(logFiles[i])
-
-        return sortedLogFiles
-
-    def Read(self, satisfiedCondition: _Callable[[str], bool]):
-        """
-        @param satisfiedCondition: recieves log line as param, return true to stop reading further
-        """
-        oldestToNewestLogs = self.GetRelatedLogFilePaths()
-        oldestToNewestLogs.reverse()
-
-        for logPath in oldestToNewestLogs:
-            fp = None
-            if(logPath.endswith(".gz")):
-                fp = _gzip.open(logPath, "rt")
-            else:
-                fp = open(logPath, "r")
-            
-            for line in fp:
-                if satisfiedCondition(line):
-                    break
-
-            fp.close()
-        return
-
+from __future__ import annotations as _annotations
+import inspect as _inspect
+import logging as _logging
+import re as _re
+from typing import Callable as _Callable
+from io import StringIO as _StringIO
+import os as _os
+import SimpleWorkspace as _sw
+import gzip as _gzip
+
+class RotatingLogReader:
+    def __init__(self, logPath: str):
+        """
+        @param logPath:
+            the full path to a live log, such as /var/log/apache/access.log,
+            The parser handles already rotated files behind the scenes
+        """
+
+        self.logPath = _os.path.realpath(logPath)
+        self.logFileName = _os.path.basename(self.logPath)
+        self.logBaseDirectory = _os.path.dirname(self.logPath)
+        self._internalBuffer = None
+
+    def To_String(self):
+        """
+        @returns All logs dumped to a string
+        """
+        strBuilder = _StringIO()
+        def writeFunc(line:str):
+            strBuilder.write(line)
+            return False
+        self.Read(writeFunc)
+        return strBuilder.getvalue()
+
+    def To_File(self, outputPath):
+        """
+        Dumps all logs as one file
+        """
+
+
+        with open(outputPath, "w") as fp:
+            def writeFunc(line: str):
+                fp.write(line)
+                return False
+            self.Read(writeFunc)
+        return
+
+    def GetRelatedLogFilePaths(self) -> list[str]:
+        """
+        @returns list of paths to the log itself + all of its rotated files, sorted newest to oldest logs example [log.txt, log.txt.1, log.txt.2.gz]
+        """
+        logFiles = {}
+        def logFilesFiltering(path: str):
+            currentLogname = _os.path.basename(path)
+            if(self.logFileName not in currentLogname):
+                return
+            if(self.logFileName == currentLogname):
+                logFiles[0] = path
+                return
+            escLogName = _re.escape(self.logFileName)
+            match = _sw.Utility.Regex.Match(f"/^{escLogName}\.(\d+)/", currentLogname)[0]
+            logFiles[int(match[1])] = path
+            return
+        _sw.IO.Directory.List(self.logBaseDirectory, callback=logFilesFiltering, includeDirs=False, maxRecursionDepth=1)
+
+        sortedLogFiles = []
+        sortedKeyList = sorted(logFiles.keys())
+        for i in sortedKeyList:
+            sortedLogFiles.append(logFiles[i])
+
+        return sortedLogFiles
+
+    def Read(self, satisfiedCondition: _Callable[[str], bool]):
+        """
+        @param satisfiedCondition: recieves log line as param, return true to stop reading further
+        """
+        oldestToNewestLogs = self.GetRelatedLogFilePaths()
+        oldestToNewestLogs.reverse()
+
+        for logPath in oldestToNewestLogs:
+            fp = None
+            if(logPath.endswith(".gz")):
+                fp = _gzip.open(logPath, "rt")
+            else:
+                fp = open(logPath, "r")
+            
+            for line in fp:
+                if satisfiedCondition(line):
+                    break
+
+            fp.close()
+        return
+
```

## Comparing `SimpleWorkspace-1.1.98.dist-info/RECORD` & `SimpleWorkspace-1.1.99.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-SimpleWorkspace/App.py,sha256=AkLRHmgFVFc0SKvNx8yCpfEi1fyFHfdXs3eQ2WHC9Js,1643
-SimpleWorkspace/LogProviders.py,sha256=8JyeWMeyhWRZDw-fETnJi0BCswWV8o-v5e8rIX1kM-E,3231
-SimpleWorkspace/SettingsProviders.py,sha256=rQf22mfWSAMpQb5ZoTo3MQLY5QKHPDWRC3ShNYxByLE,5320
-SimpleWorkspace/__init__.py,sha256=YBIGm_qkVoRwlyXM6Tvn0dzAoK2Bxz-OQbLwZPkcAPs,298
-SimpleWorkspace/Enums/ByteEnum.py,sha256=5i3l0AhCpVWa9U39kSj1VWMH2TO7Jv0DFLhW0ku9tiA,848
+SimpleWorkspace/App.py,sha256=RhhymbmefB6MqCXIDY1P8IeRjP6aoCLbc1faPDRpedo,1679
+SimpleWorkspace/LogProviders.py,sha256=FMGVjwrFlwdCjbyo3TXZ5IW_BjMXgQcie367lJGDuZs,3311
+SimpleWorkspace/SettingsProviders.py,sha256=w7uV6qiEn91PKSvAZL8qHFJEeHvtG9sgh1JIknFwWP8,5457
+SimpleWorkspace/__init__.py,sha256=vbcsL4SRFDJMKvkO3MuFas7oDeSmzhVO4wCaOw4tzS8,305
+SimpleWorkspace/Enums/ByteEnum.py,sha256=4uwu6fOGRv55ChXhqNY831k6mHop9YKPNCLz1QCCG84,871
 SimpleWorkspace/Enums/TimeEnum.py,sha256=ZwXloy9yIf_U-AMk__h7rhkiLFushD6uI_0S_f2y9TQ,128
 SimpleWorkspace/Enums/__init__.py,sha256=f4MTtWoKA0erfBRsIXGDTYKm41bjNpe4owm4irYlPyg,61
 SimpleWorkspace/Exceptions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 SimpleWorkspace/ExtLibs/__init__.py,sha256=rtkJVa1qnDGBdY8HvawLKwJiM4LA1cnok5VxdoSQKAY,21
 SimpleWorkspace/ExtLibs/appdirs.py,sha256=g99s2sXhnvTEm79oj4bWI0Toapc-_SmKKNXvOXHkVic,24720
-SimpleWorkspace/IO/Directory.py,sha256=XwSZEYAxCaEGg2Wgy-lKajp5zngj5KguOfHHXyzQsOs,3506
-SimpleWorkspace/IO/File.py,sha256=9YbUQh8-yeEDDdaIvO57oU_eRDNRVAADEornASj0hVY,3650
-SimpleWorkspace/IO/Path.py,sha256=MP4netmWUb7iwgHWXFp3yfY1FaDNaKUj1p5p4gCZgC0,771
+SimpleWorkspace/IO/Directory.py,sha256=LbWlsASW2D6LvbDJSWWCfuMArGXRnO2SYozG6j3v4ls,3587
+SimpleWorkspace/IO/File.py,sha256=r_JA1GtSHLIqjyOpk9U6e9kYDTmKeCHNYt3I8DMdiYk,3763
+SimpleWorkspace/IO/Path.py,sha256=y0dYWobURFUeNzjqcIL_Tok-1WdIAyrD4N8r6z542Z8,794
 SimpleWorkspace/IO/__init__.py,sha256=462mZZklt9YTVQf1e2qQJytpIWfAWMNsK_al9SqMw1k,61
-SimpleWorkspace/Utility/Console.py,sha256=ukaMDFjTllbmCbeeaEPWhj0U-3QPnha5i14fM8po8Jc,1139
-SimpleWorkspace/Utility/Log.py,sha256=hnMbdb7KKzR7Wy15p6qhh_k6EUkEza_MXsR2-JVGVNQ,3002
+SimpleWorkspace/Utility/Console.py,sha256=_5nkebjtccffggkGkMvwrUbG6vRGZbPrVId97SfYd2Y,1186
+SimpleWorkspace/Utility/Log.py,sha256=q_1E4mVPCNWMBCDMdYTV_gzIVoYIANXlKp-QMkZrMwc,3095
 SimpleWorkspace/Utility/Module.py,sha256=qAQwnmeMYBQAwHPdrxxW7-oK0EncV-5ptsnBoGOULrU,1498
 SimpleWorkspace/Utility/Regex.py,sha256=rNaV9BisNvtCEZqmkp9EhRL5_KSrjO4ewC40HGy6zV4,4673
 SimpleWorkspace/Utility/StopWatch.py,sha256=kwF6qKIxtD1ESGrgYOYru2vx6zbv2HFohChgOGd5I5Y,1851
 SimpleWorkspace/Utility/String.py,sha256=x9Q_siwkhjd2tyGOoqFcWbMWBHF2VABkt57TDdUucP0,204
 SimpleWorkspace/Utility/__init__.py,sha256=2w0z383Yfj20z5sUbD2tTf6SNJ04RAo4700XVqaCqNY,101
-SimpleWorkspace-1.1.98.dist-info/METADATA,sha256=iqq_UOnbl587B9qZ61zpYCFoN3NyJFtQLJYCFsgFqVQ,215
-SimpleWorkspace-1.1.98.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
-SimpleWorkspace-1.1.98.dist-info/top_level.txt,sha256=Hgx8VNBk7tIlfgdZQ_jgOoUhdcV_hItg-E19HxGfXUU,16
-SimpleWorkspace-1.1.98.dist-info/RECORD,,
+SimpleWorkspace-1.1.99.dist-info/METADATA,sha256=dwwtEPeZbHlFAdoEY9vvQcZt-eVhQKl_rtjrkEg9O44,215
+SimpleWorkspace-1.1.99.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
+SimpleWorkspace-1.1.99.dist-info/top_level.txt,sha256=Hgx8VNBk7tIlfgdZQ_jgOoUhdcV_hItg-E19HxGfXUU,16
+SimpleWorkspace-1.1.99.dist-info/RECORD,,
```

