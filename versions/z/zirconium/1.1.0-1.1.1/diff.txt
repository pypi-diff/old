--- tmp/zirconium-1.1.0.tar.gz
+++ tmp/zirconium-1.1.1.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "zirconium-1.1.0.tar", last modified: Mon Jan 30 20:19:45 2023, max compression
│ +gzip compressed data, was "C:\Users\erina\PycharmProjects\zirconium\dist\.tmp-vket62k6\zirconium-1.1.1.tar", last modified: Thu Apr  6 21:25:24 2023, max compression
│   --- zirconium-1.1.0.tar
├── +++ zirconium-1.1.1.tar
│ ├── file list
│ │ @@ -1,17 +1,21 @@
│ │ -drwxrwxrwx   0        0        0        0 2023-01-30 20:19:45.658290 zirconium-1.1.0/
│ │ --rw-rw-rw-   0        0        0     1058 2023-01-30 20:19:26.000000 zirconium-1.1.0/LICENSE
│ │ --rw-rw-rw-   0        0        0     5104 2023-01-30 20:19:45.658290 zirconium-1.1.0/PKG-INFO
│ │ --rw-rw-rw-   0        0        0     4559 2023-01-30 20:19:26.000000 zirconium-1.1.0/README.md
│ │ --rw-rw-rw-   0        0        0       88 2023-01-23 19:45:58.000000 zirconium-1.1.0/pyproject.toml
│ │ --rw-rw-rw-   0        0        0      684 2023-01-30 20:19:45.659287 zirconium-1.1.0/setup.cfg
│ │ -drwxrwxrwx   0        0        0        0 2023-01-30 20:19:45.643248 zirconium-1.1.0/src/
│ │ -drwxrwxrwx   0        0        0        0 2023-01-30 20:19:45.653321 zirconium-1.1.0/src/zirconium/
│ │ --rw-rw-rw-   0        0        0      240 2023-01-30 20:19:31.000000 zirconium-1.1.0/src/zirconium/__init__.py
│ │ --rw-rw-rw-   0        0        0    12624 2023-01-30 20:15:20.000000 zirconium-1.1.0/src/zirconium/config.py
│ │ --rw-rw-rw-   0        0        0     5180 2023-01-23 20:11:25.000000 zirconium-1.1.0/src/zirconium/parsers.py
│ │ --rw-rw-rw-   0        0        0     5447 2023-01-30 20:11:22.000000 zirconium-1.1.0/src/zirconium/utils.py
│ │ -drwxrwxrwx   0        0        0        0 2023-01-30 20:19:45.657286 zirconium-1.1.0/src/zirconium.egg-info/
│ │ --rw-rw-rw-   0        0        0     5104 2023-01-30 20:19:45.000000 zirconium-1.1.0/src/zirconium.egg-info/PKG-INFO
│ │ --rw-rw-rw-   0        0        0      288 2023-01-30 20:19:45.000000 zirconium-1.1.0/src/zirconium.egg-info/SOURCES.txt
│ │ --rw-rw-rw-   0        0        0        1 2023-01-30 20:19:45.000000 zirconium-1.1.0/src/zirconium.egg-info/dependency_links.txt
│ │ --rw-rw-rw-   0        0        0       10 2023-01-30 20:19:45.000000 zirconium-1.1.0/src/zirconium.egg-info/top_level.txt
│ │ +drwxrwxrwx   0        0        0        0 2023-04-06 21:25:24.000000 zirconium-1.1.1/
│ │ +-rw-rw-rw-   0        0        0     1058 2022-05-07 10:41:49.000000 zirconium-1.1.1/LICENSE
│ │ +-rw-rw-rw-   0        0        0     5115 2023-04-06 21:25:24.000000 zirconium-1.1.1/PKG-INFO
│ │ +-rw-rw-rw-   0        0        0     4570 2023-04-06 21:22:07.000000 zirconium-1.1.1/README.md
│ │ +-rw-rw-rw-   0        0        0       88 2022-05-07 10:39:24.000000 zirconium-1.1.1/pyproject.toml
│ │ +-rw-rw-rw-   0        0        0      684 2023-04-06 21:25:24.000000 zirconium-1.1.1/setup.cfg
│ │ +drwxrwxrwx   0        0        0        0 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/
│ │ +drwxrwxrwx   0        0        0        0 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium/
│ │ +-rw-rw-rw-   0        0        0      240 2023-04-06 21:24:54.000000 zirconium-1.1.1/src/zirconium/__init__.py
│ │ +-rw-rw-rw-   0        0        0    15986 2023-04-06 21:17:59.000000 zirconium-1.1.1/src/zirconium/config.py
│ │ +-rw-rw-rw-   0        0        0     5155 2023-04-06 21:19:22.000000 zirconium-1.1.1/src/zirconium/parsers.py
│ │ +-rw-rw-rw-   0        0        0     1148 2023-03-23 03:43:23.000000 zirconium-1.1.1/src/zirconium/sproviders.py
│ │ +-rw-rw-rw-   0        0        0     5350 2023-03-23 03:07:39.000000 zirconium-1.1.1/src/zirconium/utils.py
│ │ +drwxrwxrwx   0        0        0        0 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium.egg-info/
│ │ +-rw-rw-rw-   0        0        0     5115 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium.egg-info/PKG-INFO
│ │ +-rw-rw-rw-   0        0        0      360 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium.egg-info/SOURCES.txt
│ │ +-rw-rw-rw-   0        0        0        1 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium.egg-info/dependency_links.txt
│ │ +-rw-rw-rw-   0        0        0       10 2023-04-06 21:25:24.000000 zirconium-1.1.1/src/zirconium.egg-info/top_level.txt
│ │ +drwxrwxrwx   0        0        0        0 2023-04-06 21:25:24.000000 zirconium-1.1.1/tests/
│ │ +-rw-rw-rw-   0        0        0    14440 2022-06-14 20:53:44.000000 zirconium-1.1.1/tests/test_config.py
│ │ +-rw-rw-rw-   0        0        0    12057 2023-04-06 21:19:51.000000 zirconium-1.1.1/tests/test_handlers.py
│ ├── filetype from file(1)
│ │ @@ -1 +1 @@
│ │ -POSIX tar archive
│ │ +POSIX tar archive (GNU)
│ │   --- zirconium-1.1.0/LICENSE
│ ├── +++ zirconium-1.1.1/LICENSE
│ │┄ Files 1% similar despite different names
│ │ @@ -1,7 +1,7 @@
│ │ -Copyright 2023 Erin Turnbull
│ │ +Copyright 2022 Erin Turnbull
│ │  
│ │  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
│ │  
│ │  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
│ │  
│ │  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
│ │   --- zirconium-1.1.0/PKG-INFO
│ ├── +++ zirconium-1.1.1/PKG-INFO
│ │┄ Files 5% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: zirconium
│ │ -Version: 1.1.0
│ │ +Version: 1.1.1
│ │  Summary: Excellent configuration management for Python
│ │  Home-page: https://github.com/turnbullerin/zirconium
│ │  Author: Erin Turnbull
│ │  Author-email: erin.a.turnbull@gmail.com
│ │  Project-URL: Bug Tracker, https://github.com/turnbullerin/zirconium/issues
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: License :: OSI Approved :: MIT License
│ │ @@ -109,19 +109,17 @@
│ │          pass
│ │  
│ │  ```
│ │  
│ │  ## Change Log
│ │  
│ │  ### Version 1.1.0
│ │ -
│ │ -- Added a new `reload_config()` method. This method reloads the configuration from the original files and environment 
│ │ -  variables. If configuration was loaded manually (via load_from_dict()) it is lost when this is called. This method is
│ │ -  thread-safe.
│ │ -  
│ │ +- Added `as_list()` and `as_set()` which return as expected
│ │ +- Type-hinting added to the `as_X()` methods to help with usage in your IDE
│ │ +- Added support for `register_files()` which takes a set of directories to use and registers a set of files and default files in each.
│ │  
│ │  ### Version 1.0.0
│ │  
│ │  - Stable release after extensive testing on my own
│ │  - Python 3.11's tomllib now supported for parsing TOML files
│ │  - Using `pymitter` to manage configuration registration was proving problematic when called from
│ │    a different thread than where the application config object was instatiated. Replaced it with a more robust solution.
│ │   --- zirconium-1.1.0/README.md
│ ├── +++ zirconium-1.1.1/README.md
│ │┄ Files 4% similar despite different names
│ │ @@ -94,19 +94,17 @@
│ │          pass
│ │  
│ │  ```
│ │  
│ │  ## Change Log
│ │  
│ │  ### Version 1.1.0
│ │ -
│ │ -- Added a new `reload_config()` method. This method reloads the configuration from the original files and environment 
│ │ -  variables. If configuration was loaded manually (via load_from_dict()) it is lost when this is called. This method is
│ │ -  thread-safe.
│ │ -  
│ │ +- Added `as_list()` and `as_set()` which return as expected
│ │ +- Type-hinting added to the `as_X()` methods to help with usage in your IDE
│ │ +- Added support for `register_files()` which takes a set of directories to use and registers a set of files and default files in each.
│ │  
│ │  ### Version 1.0.0
│ │  
│ │  - Stable release after extensive testing on my own
│ │  - Python 3.11's tomllib now supported for parsing TOML files
│ │  - Using `pymitter` to manage configuration registration was proving problematic when called from
│ │    a different thread than where the application config object was instatiated. Replaced it with a more robust solution.
│ │   --- zirconium-1.1.0/setup.cfg
│ ├── +++ zirconium-1.1.1/setup.cfg
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  00000000: 5b6d 6574 6164 6174 615d 0d0a 6e61 6d65  [metadata]..name
│ │  00000010: 203d 207a 6972 636f 6e69 756d 0d0a 7665   = zirconium..ve
│ │ -00000020: 7273 696f 6e20 3d20 312e 312e 300d 0a61  rsion = 1.1.0..a
│ │ +00000020: 7273 696f 6e20 3d20 312e 312e 310d 0a61  rsion = 1.1.1..a
│ │  00000030: 7574 686f 7220 3d20 4572 696e 2054 7572  uthor = Erin Tur
│ │  00000040: 6e62 756c 6c0d 0a61 7574 686f 725f 656d  nbull..author_em
│ │  00000050: 6169 6c20 3d20 6572 696e 2e61 2e74 7572  ail = erin.a.tur
│ │  00000060: 6e62 756c 6c40 676d 6169 6c2e 636f 6d0d  nbull@gmail.com.
│ │  00000070: 0a64 6573 6372 6970 7469 6f6e 203d 2045  .description = E
│ │  00000080: 7863 656c 6c65 6e74 2063 6f6e 6669 6775  xcellent configu
│ │  00000090: 7261 7469 6f6e 206d 616e 6167 656d 656e  ration managemen
│ │   --- zirconium-1.1.0/src/zirconium/config.py
│ ├── +++ zirconium-1.1.1/src/zirconium/config.py
│ │┄ Files 24% similar despite different names
│ │ @@ -1,13 +1,17 @@
│ │  import os
│ │  import decimal
│ │  import datetime
│ │  import threading
│ │  import sys
│ │  from pathlib import Path
│ │ +import zirconium.sproviders as sp
│ │ +import logging
│ │ +import typing as t
│ │ +
│ │  
│ │  from autoinject import injector, CacheStrategy
│ │  from .parsers import JsonConfigParser, IniConfigParser, YamlConfigParser, TomlConfigParser, CfgConfigParser
│ │  from .utils import MutableDeepDict, _AppConfigHooks
│ │  
│ │  # Metadata entrypoint support depends on Python version
│ │  import importlib.util
│ │ @@ -37,27 +41,33 @@
│ │  class ApplicationConfig(MutableDeepDict):
│ │  
│ │      ach: _AppConfigHooks = None
│ │  
│ │      @injector.construct
│ │      def __init__(self, manual_init=False):
│ │          super().__init__()
│ │ +        self.log = logging.getLogger("zirconium")
│ │          self.encoding = "utf-8"
│ │          self.parsers = [
│ │              TomlConfigParser(),
│ │              YamlConfigParser(),
│ │              CfgConfigParser(),
│ │              IniConfigParser(),
│ │              JsonConfigParser(),
│ │          ]
│ │ +        self._secret_providers = {}
│ │ +        if sp.AZURE_ENABLED:
│ │ +            self._secret_providers["azure_key_vault"] = sp.azure_key_vault
│ │          self.file_registry = {
│ │              "defaults": [],
│ │              "regulars": [],
│ │              "environment": [],
│ │          }
│ │ +        self.secrets_env_map = {}
│ │ +        self.secrets_map = {}
│ │          self.environment_map = {}
│ │          self.loaded_files = []
│ │          self._init_flag = False
│ │          self._cached_gets = {}
│ │          self.registry_lock = threading.RLock()
│ │          self.cache_lock = threading.RLock()
│ │          if not manual_init:
│ │ @@ -78,22 +88,21 @@
│ │              return self._cached_gets[full_key]
│ │          with self.cache_lock:
│ │              if full_key not in self._cached_gets:
│ │                  value = super().get(*key, default=default, raise_error=raise_error)
│ │                  if blank_to_none and value == "":
│ │                      value = None
│ │                  if (not raw) and isinstance(value, str):
│ │ -                    value = ApplicationConfig.resolve_environment_references(value)
│ │ +                    value = self.resolve_environment_references(value)
│ │                  if coerce and value is not None:
│ │                      value = coerce(value)
│ │                  self._cached_gets[full_key] = value
│ │              return self._cached_gets[full_key]
│ │  
│ │ -    @staticmethod
│ │ -    def resolve_environment_references(value: str) -> str:
│ │ +    def resolve_environment_references(self, value: str) -> str:
│ │          pos = 0
│ │          # Escape rule for $ is dollar signs that precede a bracket
│ │          # ${var}
│ │          # $${not_a_var}, equivalent to string ${not_a_var}
│ │          # $$${var}, equivalent to "${}".format(os.environ["var"])
│ │          # $$$${not_a var}, equivalent to string $${not_a_var}
│ │          #
│ │ @@ -126,60 +135,67 @@
│ │                      continue
│ │              elif c == "}":
│ │                  if state == "escaping_in_ref":
│ │                      ref_buffer += "}"
│ │                      state = "in_ref"
│ │                      continue
│ │                  elif state == "in_ref":
│ │ -                    resolved += ApplicationConfig.parse_env_reference(ref_buffer)
│ │ +                    resolved += self.parse_env_reference(ref_buffer, "")
│ │                      ref_buffer = ""
│ │                      state = "buffering"
│ │                      continue
│ │              if state == "buffering":
│ │                  resolved += c
│ │              elif state == "in_ref":
│ │                  ref_buffer += c
│ │              elif state == "escaping_in_ref":
│ │                  ref_buffer += "\\" + c
│ │                  state = "in_ref"
│ │          if ref_buffer:
│ │              resolved += "${" + ref_buffer
│ │          return resolved
│ │  
│ │ -    @staticmethod
│ │ -    def parse_env_reference(name):
│ │ -        val = ""
│ │ +    def parse_env_reference(self, name, default_val=None):
│ │          if "=" in name:
│ │ -            val = name[name.find("=") + 1:]
│ │ +            default_val = name[name.find("=") + 1:]
│ │              name = name[0:name.find("=")]
│ │ -        # first check however we wrote it
│ │ -        if name in os.environ:
│ │ -            val = os.environ[name]
│ │ -            # local variables first in UNIX
│ │ -        elif name.lower() in os.environ:
│ │ -            val = os.environ[name]
│ │ -            # global variables next
│ │ -        elif name.upper() in os.environ:
│ │ -            val = os.environ[name]
│ │ -        return val
│ │ +        actual_val = self.get_env_var(name)
│ │ +        return default_val if actual_val is None else actual_val
│ │ +
│ │ +    def get_env_var(self, env_var_name):
│ │ +        if env_var_name in os.environ:
│ │ +            return os.environ[env_var_name]
│ │ +        elif env_var_name.lower() in os.environ:
│ │ +            return os.environ[env_var_name.lower()]
│ │ +        elif env_var_name.upper() in os.environ:
│ │ +            return os.environ[env_var_name.upper()]
│ │ +        elif env_var_name in self.secrets_env_map:
│ │ +            return self.get_secret(*self.secrets_env_map[env_var_name])
│ │ +        return None
│ │ +
│ │ +    def get_secret(self, secret_path, secret_provider):
│ │ +        if secret_provider not in self._secret_providers:
│ │ +            self.log.warning(f"Secret provider {secret_provider} not found")
│ │ +            return None
│ │ +        return self._secret_providers[secret_provider](secret_path)
│ │  
│ │ -    def as_date(self, key, default=None, raw=False):
│ │ +    def as_date(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[datetime.date]:
│ │          dt = self.get(key, default=default, blank_to_none=True, raw=raw)
│ │          if isinstance(dt, datetime.datetime):
│ │              return datetime.date(dt.year, dt.month, dt.day)
│ │          elif dt is None or isinstance(dt, datetime.date):
│ │              return dt
│ │          else:
│ │              try:
│ │                  return datetime.date.fromisoformat(dt)
│ │              except ValueError:
│ │                  dt = datetime.datetime.fromisoformat(dt)
│ │                  return datetime.date(dt.year, dt.month, dt.day)
│ │  
│ │ -    def as_datetime(self, key, default=None, tzinfo=None, raw=False):
│ │ +    def as_datetime(self, key: t.Union[t.Iterable, t.AnyStr], default=None, tzinfo=None, raw=False) -> t.Optional[datetime.datetime]:
│ │          dt = self.get(key, default=default, blank_to_none=True, raw=raw)
│ │          if dt is None:
│ │              return None
│ │          if isinstance(dt, datetime.datetime):
│ │              if dt.tzinfo is None and tzinfo is not None:
│ │                  return datetime.datetime(
│ │                      dt.year,
│ │ @@ -205,45 +221,65 @@
│ │                      dt.minute,
│ │                      dt.second,
│ │                      dt.microsecond,
│ │                      tzinfo
│ │                  )
│ │              return dt
│ │  
│ │ -    def as_int(self, key, default=None, raw=False):
│ │ +    def as_int(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[int]:
│ │          return self.get(key, default=default, coerce=int, blank_to_none=True, raw=raw)
│ │  
│ │ -    def as_float(self, key, default=None, raw=False):
│ │ +    def as_float(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[float]:
│ │          return self.get(key, default=default, coerce=float, blank_to_none=True, raw=raw)
│ │  
│ │ -    def as_decimal(self, key, default=None, raw=False):
│ │ +    def as_decimal(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[decimal.Decimal]:
│ │          return self.get(key, default=default, coerce=decimal.Decimal, blank_to_none=True, raw=raw)
│ │  
│ │ -    def as_str(self, key, default=None, raw=False):
│ │ +    def as_str(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[str]:
│ │          return self.get(key, default=default, coerce=str, raw=raw)
│ │  
│ │ -    def as_bool(self, key, default=None, raw=False):
│ │ +    def as_bool(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[bool]:
│ │          return bool(self.get(key, default=default, raw=raw))
│ │  
│ │ -    def as_path(self, key, default=None, raw=False):
│ │ +    def as_path(self, key: t.Union[t.Iterable, t.AnyStr], default=None, raw=False) -> t.Optional[Path]:
│ │          return self.get(key, default=default, coerce=Path, blank_to_none=True, raw=raw)
│ │  
│ │ -    def as_dict(self, key, default=None):
│ │ +    def as_set(self, key: t.Union[t.Iterable, t.AnyStr], default=None) -> t.Optional[set]:
│ │ +        return self.get(key, default=default, coerce=set, blank_to_none=True, raw=True)
│ │ +
│ │ +    def as_list(self, key: t.Union[t.Iterable, t.AnyStr], default=None) -> t.Optional[list]:
│ │ +        return self.get(key, default=default, coerce=list, blank_to_none=True, raw=True)
│ │ +
│ │ +    def as_dict(self, key: t.Union[t.Iterable, t.AnyStr], default=None) -> t.Optional[dict]:
│ │          return self.get(key, default=default, coerce=MutableDeepDict, blank_to_none=True, raw=True)
│ │  
│ │      def set_default_encoding(self, enc):
│ │          self.encoding = enc
│ │  
│ │ -    def is_truthy(self, key):
│ │ +    def is_truthy(self, key: t.Union[t.Iterable, t.AnyStr]) -> bool:
│ │          parent, k = self._navigate_to_item(key)
│ │          return parent is not None and k in parent and bool(parent[k])
│ │  
│ │      def register_parser(self, parser):
│ │          self.parsers.append(parser)
│ │  
│ │ +    def register_secret_provider(self, name, callback):
│ │ +        self._secret_providers[name] = callback
│ │ +
│ │ +    def register_files(self,
│ │ +                       search_directories: t.Iterable[t.Union[Path, t.AnyStr]],
│ │ +                       files: t.Optional[t.Iterable[str]] = None,
│ │ +                       default_files: t.Optional[t.Iterable[str]] = None):
│ │ +        for sd in search_directories:
│ │ +            sd = sd if isinstance(sd, Path) else Path(sd)
│ │ +            for file in files:
│ │ +                self.register_file(sd / file)
│ │ +            for default_file in default_files:
│ │ +                self.register_default_file(sd / default_file)
│ │ +
│ │      def register_default_file(self, file_path, weight=None, parser=None, encoding=None):
│ │          with self.registry_lock:
│ │              if weight is None:
│ │                  weight = self._next_weight("defaults")
│ │              self.file_registry["defaults"].append((file_path, weight, parser, encoding))
│ │  
│ │      def register_file(self, file_path, weight=None, parser=None, encoding=None):
│ │ @@ -262,53 +298,69 @@
│ │          if self.file_registry[key]:
│ │              return max(x[1] for x in self.file_registry[key]) + 1
│ │          return 0
│ │  
│ │      def register_environ_var(self, env_var_name, *target_config):
│ │          self.environment_map[env_var_name] = target_config
│ │  
│ │ -    def reload_config(self):
│ │ -        # We take all three locks to prevent any weird multi-threaded behaviour from happening. All writes are blocked until we are done the re-load except our own.
│ │ -        with self.lock:
│ │ -            with self.registry_lock:
│ │ -                with self.cache_lock:
│ │ -                    self._cached_gets = {}
│ │ -                    self._init_flag = False
│ │ -                    self.clear()
│ │ -                    self.init()
│ │ +    def register_secret_as_environ_var(self, secret_path, secret_provider, env_var_name):
│ │ +        self.secrets_env_map[env_var_name] = (secret_path, secret_provider)
│ │ +
│ │ +    def register_secret_config(self, secret_path, secret_provider, *target_config):
│ │ +        secret_provider = secret_provider.lower()
│ │ +        self.secrets_map[f"{secret_path}{secret_provider}"] = (secret_path, secret_provider, target_config)
│ │  
│ │      def init(self):
│ │          with self.registry_lock:
│ │              if not self._init_flag:
│ │                  self.file_registry["defaults"].sort(key=lambda x: x[1])
│ │                  for file, weight, parser, enc in self.file_registry["defaults"]:
│ │                      self.load_file(file, parser, enc)
│ │                  self.file_registry["regulars"].sort(key=lambda x: x[1])
│ │                  for file, weight, parser, enc in self.file_registry["regulars"]:
│ │                      self.load_file(file, parser, enc)
│ │                  self.file_registry["environment"].sort(key=lambda x: x[1])
│ │                  for env_name, weight, parser, enc in self.file_registry["environment"]:
│ │ -                    if env_name in os.environ:
│ │ -                        self.load_file(os.environ.get(env_name), parser, enc)
│ │ +                    env_val = self.get_env_var(env_name)
│ │ +                    if env_val:
│ │ +                        self.load_file(env_val, parser, enc)
│ │                  for env_name, target_config in self.environment_map:
│ │ -                    if env_name in os.environ:
│ │ -                        self.config[target_config] = os.environ.get(env_name)
│ │ +                    env_val = self.get_env_var(env_name)
│ │ +                    if env_val is not None:
│ │ +                        self.log.info(f"Setting config from environment variable {env_name}")
│ │ +                        self.config[target_config] = env_val
│ │ +                    else:
│ │ +                        self.log.debug(f"No environment variable set for {env_name}")
│ │ +                for key in self.secrets_map:
│ │ +                    spath, sprovider, target_config = self._secret_providers[key]
│ │ +                    secret_val = self.get_secret(sprovider, spath)
│ │ +                    if secret_val is not None:
│ │ +                        self.log.info(f"Loading secret from {sprovider} {spath}")
│ │ +                        self.config[target_config] = secret_val
│ │                  self._init_flag = True
│ │  
│ │      def load_file(self, file_path, parser=None, encoding=None):
│ │          with self.registry_lock:
│ │              if encoding is None:
│ │                  encoding = self.encoding
│ │              file_path = Path(file_path).expanduser().absolute()
│ │ -            if file_path.exists() and file_path not in self.loaded_files:
│ │ +            if file_path in self.loaded_files:
│ │ +                return
│ │ +            if file_path.exists():
│ │                  if parser:
│ │ +                    self.log.info(f"Loading config file {file_path}")
│ │                      self.load_from_dict(parser.read_dict(file_path, encoding))
│ │                      self.loaded_files.append(file_path)
│ │                  else:
│ │                      for parser in self.parsers:
│ │                          if parser.handles(file_path.name):
│ │ +                            self.log.info(f"Loading config file {file_path}")
│ │                              self.load_from_dict(parser.read_dict(file_path, encoding))
│ │                              self.loaded_files.append(file_path)
│ │                              break
│ │ +                    else:
│ │ +                        self.log.warning(f"No parser found for {file_path}")
│ │ +            else:
│ │ +                self.log.info(f"No config file found at {file_path}")
│ │  
│ │      def load_from_dict(self, d):
│ │          self.deep_update(d)
│ │   --- zirconium-1.1.0/src/zirconium/parsers.py
│ ├── +++ zirconium-1.1.1/src/zirconium/parsers.py
│ │┄ Files 2% similar despite different names
│ │ @@ -127,18 +127,18 @@
│ │              return {}
│ │          if not hasattr(t.c, val_col):
│ │              logging.getLogger(__name__).warning("Table {} does not have value column {}".format(table, val_col))
│ │              return {}
│ │          k = getattr(t.c, key_col)
│ │          v = getattr(t.c, val_col)
│ │          with engine.connect() as conn:
│ │ -            q = t.select().with_only_columns([k, v]).order_by(sqlalchemy.sql.expression.func.length(k))
│ │ +            q = t.select().with_only_columns(k, v).order_by(sqlalchemy.sql.expression.func.length(k))
│ │              d = MutableDeepDict()
│ │              for row in conn.execute(q).fetchall():
│ │ -                d[row[key_col].split(".")] = row[val_col]
│ │ +                d[row[0]] = row[1]
│ │              return d
│ │  
│ │      def _split_path(self, path):
│ │          # mysql+pymysql://scott:tiger@localhost/foo/schema.table/col1/col2
│ │          qs = ""
│ │          if "?" in path:
│ │              qs = path[path.find("?"):]
│ │   --- zirconium-1.1.0/src/zirconium/utils.py
│ ├── +++ zirconium-1.1.1/src/zirconium/utils.py
│ │┄ Files 2% similar despite different names
│ │ @@ -85,18 +85,14 @@
│ │          """ __len__ implementation """
│ │          return len(self.d)
│ │  
│ │      def __iter__(self):
│ │          """ __iter__ implementation """
│ │          return iter(self.d)
│ │  
│ │ -    def clear(self):
│ │ -        """Clear the dictionary of all entries."""
│ │ -        self.d = {}
│ │ -
│ │      def deep_update(self, d):
│ │          """ Similar to update(), but will merge dictionaries at depth. Thread-safe. """
│ │          with self.lock:
│ │              for key in d.keys():
│ │                  if key in self.d and MutableDeepDict.is_dict_like(d[key]) and MutableDeepDict.is_dict_like(self.d[key]):
│ │                      mut = MutableDeepDict(self.d[key])
│ │                      mut.deep_update(d[key])
│ │   --- zirconium-1.1.0/src/zirconium.egg-info/PKG-INFO
│ ├── +++ zirconium-1.1.1/src/zirconium.egg-info/PKG-INFO
│ │┄ Files 5% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: zirconium
│ │ -Version: 1.1.0
│ │ +Version: 1.1.1
│ │  Summary: Excellent configuration management for Python
│ │  Home-page: https://github.com/turnbullerin/zirconium
│ │  Author: Erin Turnbull
│ │  Author-email: erin.a.turnbull@gmail.com
│ │  Project-URL: Bug Tracker, https://github.com/turnbullerin/zirconium/issues
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: License :: OSI Approved :: MIT License
│ │ @@ -109,19 +109,17 @@
│ │          pass
│ │  
│ │  ```
│ │  
│ │  ## Change Log
│ │  
│ │  ### Version 1.1.0
│ │ -
│ │ -- Added a new `reload_config()` method. This method reloads the configuration from the original files and environment 
│ │ -  variables. If configuration was loaded manually (via load_from_dict()) it is lost when this is called. This method is
│ │ -  thread-safe.
│ │ -  
│ │ +- Added `as_list()` and `as_set()` which return as expected
│ │ +- Type-hinting added to the `as_X()` methods to help with usage in your IDE
│ │ +- Added support for `register_files()` which takes a set of directories to use and registers a set of files and default files in each.
│ │  
│ │  ### Version 1.0.0
│ │  
│ │  - Stable release after extensive testing on my own
│ │  - Python 3.11's tomllib now supported for parsing TOML files
│ │  - Using `pymitter` to manage configuration registration was proving problematic when called from
│ │    a different thread than where the application config object was instatiated. Replaced it with a more robust solution.
