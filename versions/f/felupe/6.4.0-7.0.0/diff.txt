--- tmp/felupe-6.4.0.tar.gz
+++ tmp/felupe-7.0.0.tar.gz
â”œâ”€â”€ filetype from file(1)
â”‚ @@ -1 +1 @@
â”‚ -gzip compressed data, was "felupe-6.4.0.tar", last modified: Sat Apr  1 08:04:16 2023, max compression
â”‚ +gzip compressed data, was "felupe-7.0.0.tar", last modified: Fri Apr  7 11:58:36 2023, max compression
â”‚   --- felupe-6.4.0.tar
â”œâ”€â”€ +++ felupe-7.0.0.tar
â”‚ â”œâ”€â”€ file list
â”‚ â”‚ @@ -1,128 +1,128 @@
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.893940 felupe-6.4.0/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    35081 2023-04-01 08:04:04.000000 felupe-6.4.0/LICENSE
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    47674 2023-04-01 08:04:16.893940 felupe-6.4.0/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5963 2023-04-01 08:04:04.000000 felupe-6.4.0/README.md
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-04-01 08:04:04.000000 felupe-6.4.0/pyproject.toml
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-01 08:04:16.893940 felupe-6.4.0/setup.cfg
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.877940 felupe-6.4.0/src/
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.877940 felupe-6.4.0/src/felupe/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       22 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/__about__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2469 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/__init__.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.881940 felupe-6.4.0/src/felupe/_assembly/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      238 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_assembly/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     6079 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_assembly/_axi.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    10950 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_assembly/_base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    23823 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_assembly/_form.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4235 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_assembly/_mixed.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.881940 felupe-6.4.0/src/felupe/_basis/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_basis/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4386 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_basis/_basis.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.881940 felupe-6.4.0/src/felupe/_field/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      176 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     6136 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_axi.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9796 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5352 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_container.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4704 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_fields.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1445 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_indices.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5501 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/_field/_planestrain.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.885940 felupe-6.4.0/src/felupe/constitution/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     6646 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_kinematics.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    17288 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_mixed.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9816 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_models_hyperelasticity.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4821 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_models_hyperelasticity_ad.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    17606 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_models_linear_elasticity.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4032 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_models_pseudo_elasticity.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8202 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_user_materials.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4403 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_user_materials_hyperelastic.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5177 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/constitution/_user_materials_models.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.885940 felupe-6.4.0/src/felupe/dof/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/dof/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4946 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/dof/_boundary.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5746 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/dof/_loadcase.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4084 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/dof/_tools.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.885940 felupe-6.4.0/src/felupe/element/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      407 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1151 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    13910 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_hexahedron.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3439 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_lagrange.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1505 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_line.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8969 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_quad.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4725 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_tetra.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3755 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/element/_triangle.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.885940 felupe-6.4.0/src/felupe/math/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      456 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/math/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2011 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/math/_field.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1741 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/math/_math.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/math/_spatial.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8763 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/math/_tensor.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/mechanics/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      463 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3076 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_curve.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3430 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_helpers.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5841 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_job.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5754 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_multipoint.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2702 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_pointload.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4633 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_solidbody.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2707 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_solidbody_gravity.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     7695 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_solidbody_incompressible.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3883 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_solidbody_pressure.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2721 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mechanics/_step.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/mesh/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      670 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2272 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4546 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_container.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9268 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_convert.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     7376 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_geometry.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4014 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_helpers.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5756 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_mesh.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1750 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_read.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    13988 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/mesh/_tools.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/quadrature/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/quadrature/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1310 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/quadrature/_base.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3911 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/quadrature/_gausslegendre.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2302 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/quadrature/_tetra.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2149 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/quadrature/_triangle.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/region/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      514 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/region/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8891 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/region/_boundary.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4758 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/region/_region.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8052 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/region/_templates.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/solve/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       37 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/solve/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2574 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/solve/_solve.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.889940 felupe-6.4.0/src/felupe/tools/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)      267 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/__init__.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1966 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_check.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     8398 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_newton.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2001 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_post.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4489 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_project.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2630 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_save.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1340 2023-04-01 08:04:04.000000 felupe-6.4.0/src/felupe/tools/_solve.py
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.881940 felupe-6.4.0/src/felupe.egg-info/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    47674 2023-04-01 08:04:16.000000 felupe-6.4.0/src/felupe.egg-info/PKG-INFO
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3213 2023-04-01 08:04:16.000000 felupe-6.4.0/src/felupe.egg-info/SOURCES.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-01 08:04:16.000000 felupe-6.4.0/src/felupe.egg-info/dependency_links.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)       63 2023-04-01 08:04:16.000000 felupe-6.4.0/src/felupe.egg-info/requires.txt
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)        7 2023-04-01 08:04:16.000000 felupe-6.4.0/src/felupe.egg-info/top_level.txt
â”‚ â”‚ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 08:04:16.893940 felupe-6.4.0/tests/
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1929 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_basis.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2283 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_bilinearform.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     1896 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_composite.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    12252 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_constitution.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3964 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_dof.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     5262 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_element.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4314 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_field.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9285 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_form.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3810 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_job.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4401 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_math.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)    13145 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_mechanics.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9996 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_mesh.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     4028 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_mpc.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3661 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_planestrain.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3970 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_quadrature.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3050 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_readme.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     3782 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_region.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     2034 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_solve.py
â”‚ â”‚ --rw-r--r--   0 runner    (1001) docker     (123)     9257 2023-04-01 08:04:04.000000 felupe-6.4.0/tests/test_tools.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.311094 felupe-7.0.0/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    35081 2023-04-07 11:58:26.000000 felupe-7.0.0/LICENSE
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    47965 2023-04-07 11:58:36.311094 felupe-7.0.0/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6203 2023-04-07 11:58:26.000000 felupe-7.0.0/README.md
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1544 2023-04-07 11:58:26.000000 felupe-7.0.0/pyproject.toml
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 11:58:36.311094 felupe-7.0.0/setup.cfg
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.291093 felupe-7.0.0/src/
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.295093 felupe-7.0.0/src/felupe/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       22 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/__about__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2618 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/__init__.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.295093 felupe-7.0.0/src/felupe/_assembly/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      238 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_assembly/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6039 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_assembly/_axi.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6422 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_assembly/_base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    23823 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_assembly/_form.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4195 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_assembly/_mixed.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.295093 felupe-7.0.0/src/felupe/_basis/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_basis/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4328 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_basis/_basis.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.299093 felupe-7.0.0/src/felupe/_field/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      176 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6136 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_axi.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     9796 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5352 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_container.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4704 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_fields.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1445 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_indices.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5501 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/_field/_planestrain.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.299093 felupe-7.0.0/src/felupe/constitution/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6588 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_kinematics.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    17288 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_mixed.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     9816 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_models_hyperelasticity.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4821 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_models_hyperelasticity_ad.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    17606 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_models_linear_elasticity.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4032 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_models_pseudo_elasticity.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8202 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_user_materials.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4403 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_user_materials_hyperelastic.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5177 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/constitution/_user_materials_models.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.299093 felupe-7.0.0/src/felupe/dof/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/dof/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4946 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/dof/_boundary.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5746 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/dof/_loadcase.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4084 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/dof/_tools.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.299093 felupe-7.0.0/src/felupe/element/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      407 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1151 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    13838 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_hexahedron.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3439 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_lagrange.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1505 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_line.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    10019 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_quad.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4725 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_tetra.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3755 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/element/_triangle.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.303094 felupe-7.0.0/src/felupe/math/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/math/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2011 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/math/_field.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1741 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/math/_math.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/math/_spatial.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8705 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/math/_tensor.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.303094 felupe-7.0.0/src/felupe/mechanics/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      463 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3076 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_curve.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3410 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_helpers.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5952 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_job.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5661 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_multipoint.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2680 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_pointload.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4565 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_solidbody.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2676 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_solidbody_gravity.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7497 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_solidbody_incompressible.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3815 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_solidbody_pressure.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2721 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mechanics/_step.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.303094 felupe-7.0.0/src/felupe/mesh/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      680 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2272 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4546 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_container.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     9293 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_convert.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3642 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_discrete_geometry.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7376 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_geometry.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4126 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_helpers.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     6990 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_mesh.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1874 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_read.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    14839 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/mesh/_tools.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.307094 felupe-7.0.0/src/felupe/quadrature/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      155 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/quadrature/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1310 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/quadrature/_base.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3911 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/quadrature/_gausslegendre.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2302 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/quadrature/_tetra.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2149 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/quadrature/_triangle.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.307094 felupe-7.0.0/src/felupe/region/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      663 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/region/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    13133 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/region/_boundary.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5172 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/region/_region.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    10142 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/region/_templates.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.307094 felupe-7.0.0/src/felupe/solve/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       37 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/solve/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2574 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/solve/_solve.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.307094 felupe-7.0.0/src/felupe/tools/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)      241 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/__init__.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8132 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/_newton.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2001 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/_post.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5250 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/_project.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2630 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/_save.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1340 2023-04-07 11:58:26.000000 felupe-7.0.0/src/felupe/tools/_solve.py
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.295093 felupe-7.0.0/src/felupe.egg-info/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    47965 2023-04-07 11:58:36.000000 felupe-7.0.0/src/felupe.egg-info/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3224 2023-04-07 11:58:36.000000 felupe-7.0.0/src/felupe.egg-info/SOURCES.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 11:58:36.000000 felupe-7.0.0/src/felupe.egg-info/dependency_links.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)       50 2023-04-07 11:58:36.000000 felupe-7.0.0/src/felupe.egg-info/requires.txt
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-04-07 11:58:36.000000 felupe-7.0.0/src/felupe.egg-info/top_level.txt
â”‚ â”‚ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 11:58:36.311094 felupe-7.0.0/tests/
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1929 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_basis.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2283 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_bilinearform.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     1896 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_composite.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    12252 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_constitution.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3964 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_dof.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     5262 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_element.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4314 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_field.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8302 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_form.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3810 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_job.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4401 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_math.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    12303 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_mechanics.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)    11203 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_mesh.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     7135 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_mpc.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3661 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_planestrain.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3970 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_quadrature.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     3050 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_readme.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     4003 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_region.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     2034 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_solve.py
â”‚ â”‚ +-rw-r--r--   0 runner    (1001) docker     (123)     8758 2023-04-07 11:58:26.000000 felupe-7.0.0/tests/test_tools.py
â”‚ â”‚   --- felupe-6.4.0/LICENSE
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/LICENSE
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/PKG-INFO
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/PKG-INFO
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: felupe
â”‚ â”‚ -Version: 6.4.0
â”‚ â”‚ +Version: 7.0.0
â”‚ â”‚  Summary: Finite Element Analysis
â”‚ â”‚  Author: Andreas Dutzler
â”‚ â”‚  Author-email: a.dutzler@gmail.com
â”‚ â”‚  License: GNU GENERAL PUBLIC LICENSE
â”‚ â”‚                                 Version 3, 29 June 2007
â”‚ â”‚          
â”‚ â”‚           Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
â”‚ â”‚ @@ -690,38 +690,39 @@
â”‚ â”‚  Classifier: Operating System :: OS Independent
â”‚ â”‚  Classifier: Programming Language :: Python
â”‚ â”‚  Classifier: Programming Language :: Python :: 3
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.7
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.8
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.9
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.10
â”‚ â”‚ +Classifier: Programming Language :: Python :: 3.11
â”‚ â”‚  Classifier: Topic :: Scientific/Engineering
â”‚ â”‚  Classifier: Topic :: Scientific/Engineering :: Mathematics
â”‚ â”‚  Classifier: Topic :: Utilities
â”‚ â”‚  Requires-Python: >=3.7
â”‚ â”‚  Description-Content-Type: text/markdown
â”‚ â”‚  Provides-Extra: all
â”‚ â”‚  License-File: LICENSE
â”‚ â”‚  
â”‚ â”‚ -# FElupe - Finite Element Analysis
â”‚ â”‚ +# ğŸ” FElupe - Finite Element Analysis
â”‚ â”‚  
â”‚ â”‚  [![PyPI version shields.io](https://img.shields.io/pypi/v/felupe.svg)](https://pypi.python.org/pypi/felupe/) [![Documentation Status](https://readthedocs.org/projects/felupe/badge/?version=latest)](https://felupe.readthedocs.io/en/latest/?badge=latest) [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) ![Made with love in Graz (Austria)](https://img.shields.io/badge/Made%20with%20%E2%9D%A4%EF%B8%8F%20in-Graz%20(Austria)-0c674a) [![codecov](https://codecov.io/gh/adtzlr/felupe/branch/main/graph/badge.svg?token=J2QP6Y6LVH)](https://codecov.io/gh/adtzlr/felupe) [![DOI](https://zenodo.org/badge/360657894.svg)](https://zenodo.org/badge/latestdoi/360657894) ![Codestyle black](https://img.shields.io/badge/code%20style-black-black) ![GitHub Repo stars](https://img.shields.io/github/stars/adtzlr/felupe?logo=github) ![PyPI - Downloads](https://img.shields.io/pypi/dm/felupe)
â”‚ â”‚  
â”‚ â”‚ -<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" width="220px"/>
â”‚ â”‚ +<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604246-5a416081-6777-4f33-afdf-efdb51338722.png" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604587-42e3e339-e08c-4cc8-8000-f7046a8d95df.png" height="120px"/>
â”‚ â”‚  
â”‚ â”‚  FElupe is a Python 3.7+ finite element analysis package focussing on the formulation and numerical solution of nonlinear problems in continuum mechanics of solid bodies. Its name is a combination of FE (finite element) and the german word *Lupe* (magnifying glass) as a synonym for getting an insight how a finite element analysis code looks like under the hood.
â”‚ â”‚  
â”‚ â”‚  # Installation
â”‚ â”‚  Install Python, fire up a terminal and run
â”‚ â”‚  
â”‚ â”‚  ```shell
â”‚ â”‚  pip install felupe[all]
â”‚ â”‚  ```
â”‚ â”‚  
â”‚ â”‚ -where `[all]` installs all optional dependencies. By default, FElupe only depends on `numpy` and `scipy`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`einsumt`, `h5py`, `meshio`, `numba`, `sparse` and `tensortrax`).
â”‚ â”‚ +where `[all]` installs all optional dependencies. By default, FElupe depends on `numpy`, `scipy` and `einsumt`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`h5py`, `meshio` and `tensortrax`).
â”‚ â”‚  
â”‚ â”‚  # Getting Started
â”‚ â”‚  A quarter model of a solid cube with hyperelastic material behaviour is subjected to a uniaxial elongation applied at a clamped end-face. This involves the creation of a mesh, a region as well as a displacement field (encapsulated in a field container). Furthermore, the boundary conditions are created by a template for a uniaxial loadcase. An isotropic pseudo-elastic Ogden-Roxburgh Mullins-softening model formulation in combination with an isotropic hyperelastic Neo-Hookean material formulation is applied on a nearly-incompressible solid body. A step generates the consecutive substep-movements of a given boundary condition. The step is further added to a list of steps of a job (here, a characteristic-curve job is used). During evaluation, each substep of each step is solved by an iterative Newton-Rhapson procedure. The solution is exported after each completed substep as a time-series XDMF file. For more details beside this high-level code snippet, please have a look at the [documentation](https://felupe.readthedocs.io/en/latest/?badge=latest).
â”‚ â”‚  
â”‚ â”‚  ```python
â”‚ â”‚  import felupe as fem
â”‚ â”‚ â”œâ”€â”€ encoding
â”‚ â”‚ â”‚ @@ -1 +1 @@
â”‚ â”‚ â”‚ -us-ascii
â”‚ â”‚ â”‚ +utf-8
â”‚ â”‚   --- felupe-6.4.0/README.md
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/README.md
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -1,23 +1,23 @@
â”‚ â”‚ -# FElupe - Finite Element Analysis
â”‚ â”‚ +# ğŸ” FElupe - Finite Element Analysis
â”‚ â”‚  
â”‚ â”‚  [![PyPI version shields.io](https://img.shields.io/pypi/v/felupe.svg)](https://pypi.python.org/pypi/felupe/) [![Documentation Status](https://readthedocs.org/projects/felupe/badge/?version=latest)](https://felupe.readthedocs.io/en/latest/?badge=latest) [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) ![Made with love in Graz (Austria)](https://img.shields.io/badge/Made%20with%20%E2%9D%A4%EF%B8%8F%20in-Graz%20(Austria)-0c674a) [![codecov](https://codecov.io/gh/adtzlr/felupe/branch/main/graph/badge.svg?token=J2QP6Y6LVH)](https://codecov.io/gh/adtzlr/felupe) [![DOI](https://zenodo.org/badge/360657894.svg)](https://zenodo.org/badge/latestdoi/360657894) ![Codestyle black](https://img.shields.io/badge/code%20style-black-black) ![GitHub Repo stars](https://img.shields.io/github/stars/adtzlr/felupe?logo=github) ![PyPI - Downloads](https://img.shields.io/pypi/dm/felupe)
â”‚ â”‚  
â”‚ â”‚ -<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" width="220px"/>
â”‚ â”‚ +<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604246-5a416081-6777-4f33-afdf-efdb51338722.png" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604587-42e3e339-e08c-4cc8-8000-f7046a8d95df.png" height="120px"/>
â”‚ â”‚  
â”‚ â”‚  FElupe is a Python 3.7+ finite element analysis package focussing on the formulation and numerical solution of nonlinear problems in continuum mechanics of solid bodies. Its name is a combination of FE (finite element) and the german word *Lupe* (magnifying glass) as a synonym for getting an insight how a finite element analysis code looks like under the hood.
â”‚ â”‚  
â”‚ â”‚  # Installation
â”‚ â”‚  Install Python, fire up a terminal and run
â”‚ â”‚  
â”‚ â”‚  ```shell
â”‚ â”‚  pip install felupe[all]
â”‚ â”‚  ```
â”‚ â”‚  
â”‚ â”‚ -where `[all]` installs all optional dependencies. By default, FElupe only depends on `numpy` and `scipy`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`einsumt`, `h5py`, `meshio`, `numba`, `sparse` and `tensortrax`).
â”‚ â”‚ +where `[all]` installs all optional dependencies. By default, FElupe depends on `numpy`, `scipy` and `einsumt`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`h5py`, `meshio` and `tensortrax`).
â”‚ â”‚  
â”‚ â”‚  # Getting Started
â”‚ â”‚  A quarter model of a solid cube with hyperelastic material behaviour is subjected to a uniaxial elongation applied at a clamped end-face. This involves the creation of a mesh, a region as well as a displacement field (encapsulated in a field container). Furthermore, the boundary conditions are created by a template for a uniaxial loadcase. An isotropic pseudo-elastic Ogden-Roxburgh Mullins-softening model formulation in combination with an isotropic hyperelastic Neo-Hookean material formulation is applied on a nearly-incompressible solid body. A step generates the consecutive substep-movements of a given boundary condition. The step is further added to a list of steps of a job (here, a characteristic-curve job is used). During evaluation, each substep of each step is solved by an iterative Newton-Rhapson procedure. The solution is exported after each completed substep as a time-series XDMF file. For more details beside this high-level code snippet, please have a look at the [documentation](https://felupe.readthedocs.io/en/latest/?badge=latest).
â”‚ â”‚  
â”‚ â”‚  ```python
â”‚ â”‚  import felupe as fem
â”‚ â”‚ â”œâ”€â”€ encoding
â”‚ â”‚ â”‚ @@ -1 +1 @@
â”‚ â”‚ â”‚ -us-ascii
â”‚ â”‚ â”‚ +utf-8
â”‚ â”‚   --- felupe-6.4.0/pyproject.toml
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/pyproject.toml
â”‚ â”‚â”„ Files 11% similar despite different names
â”‚ â”‚ @@ -30,32 +30,31 @@
â”‚ â”‚    "Operating System :: OS Independent",
â”‚ â”‚    "Programming Language :: Python",
â”‚ â”‚    "Programming Language :: Python :: 3",
â”‚ â”‚    "Programming Language :: Python :: 3.7",
â”‚ â”‚    "Programming Language :: Python :: 3.8",
â”‚ â”‚    "Programming Language :: Python :: 3.9",
â”‚ â”‚    "Programming Language :: Python :: 3.10",
â”‚ â”‚ +  "Programming Language :: Python :: 3.11",
â”‚ â”‚    "Topic :: Scientific/Engineering",
â”‚ â”‚    "Topic :: Scientific/Engineering :: Mathematics",
â”‚ â”‚    "Topic :: Utilities"
â”‚ â”‚  ]
â”‚ â”‚  dynamic = ["version"]
â”‚ â”‚  requires-python = ">=3.7"
â”‚ â”‚  dependencies = [
â”‚ â”‚    "numpy",
â”‚ â”‚    "scipy",
â”‚ â”‚ +  "einsumt",
â”‚ â”‚  ]
â”‚ â”‚  
â”‚ â”‚  [project.optional-dependencies]
â”‚ â”‚  all = [
â”‚ â”‚      "meshio",
â”‚ â”‚      "h5py",
â”‚ â”‚ -    "numba",
â”‚ â”‚ -    "sparse",
â”‚ â”‚ -    "einsumt",
â”‚ â”‚      "tensortrax",
â”‚ â”‚  ]
â”‚ â”‚  
â”‚ â”‚  [tool.setuptools.dynamic]
â”‚ â”‚  version = {attr = "felupe.__about__.__version__"}
â”‚ â”‚  
â”‚ â”‚  [project.urls]
â”‚ â”‚   --- felupe-6.4.0/src/felupe/__init__.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/__init__.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -59,31 +59,35 @@
â”‚ â”‚  from .mesh import Cube, Grid, Mesh, MeshContainer, Rectangle
â”‚ â”‚  from .quadrature import GaussLegendre, GaussLegendreBoundary
â”‚ â”‚  from .quadrature import Tetrahedron as TetrahedronQuadrature
â”‚ â”‚  from .quadrature import Triangle as TriangleQuadrature
â”‚ â”‚  from .region import (
â”‚ â”‚      Region,
â”‚ â”‚      RegionBiQuadraticQuad,
â”‚ â”‚ +    RegionBiQuadraticQuadBoundary,
â”‚ â”‚      RegionBoundary,
â”‚ â”‚      RegionConstantHexahedron,
â”‚ â”‚      RegionConstantQuad,
â”‚ â”‚      RegionHexahedron,
â”‚ â”‚      RegionHexahedronBoundary,
â”‚ â”‚      RegionLagrange,
â”‚ â”‚      RegionQuad,
â”‚ â”‚      RegionQuadBoundary,
â”‚ â”‚      RegionQuadraticHexahedron,
â”‚ â”‚ +    RegionQuadraticHexahedronBoundary,
â”‚ â”‚      RegionQuadraticQuad,
â”‚ â”‚ +    RegionQuadraticQuadBoundary,
â”‚ â”‚      RegionQuadraticTetra,
â”‚ â”‚      RegionQuadraticTriangle,
â”‚ â”‚      RegionTetra,
â”‚ â”‚      RegionTetraMINI,
â”‚ â”‚      RegionTriangle,
â”‚ â”‚      RegionTriangleMINI,
â”‚ â”‚      RegionTriQuadraticHexahedron,
â”‚ â”‚ +    RegionTriQuadraticHexahedronBoundary,
â”‚ â”‚  )
â”‚ â”‚  
â”‚ â”‚  try:
â”‚ â”‚      from .constitution import UserMaterialHyperelastic
â”‚ â”‚  except:
â”‚ â”‚      pass
â”‚ â”‚  from .mechanics import (
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_assembly/_axi.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_assembly/_axi.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -130,16 +130,16 @@
â”‚ â”‚  
â”‚ â”‚                  form_a = IntegralForm(fun, v, self.dV, u, False, False)
â”‚ â”‚  
â”‚ â”‚                  self.forms = [
â”‚ â”‚                      form_a,
â”‚ â”‚                  ]
â”‚ â”‚  
â”‚ â”‚ -    def integrate(self, parallel=False, jit=False):
â”‚ â”‚ -        values = [form.integrate(parallel=parallel, jit=jit) for form in self.forms]
â”‚ â”‚ +    def integrate(self, parallel=False):
â”‚ â”‚ +        values = [form.integrate(parallel=parallel) for form in self.forms]
â”‚ â”‚  
â”‚ â”‚          if self.mode == 1:
â”‚ â”‚              values[0] += np.pad(values[1], ((0, 0), (1, 0), (0, 0)))
â”‚ â”‚              val = values[0]
â”‚ â”‚  
â”‚ â”‚          if self.mode == 30:
â”‚ â”‚              if len(values[0].shape) > 4:
â”‚ â”‚ @@ -171,11 +171,11 @@
â”‚ â”‚              val = values[0]
â”‚ â”‚  
â”‚ â”‚          elif self.mode == 10 or self.mode == 40:
â”‚ â”‚              val = values[0]
â”‚ â”‚  
â”‚ â”‚          return val
â”‚ â”‚  
â”‚ â”‚ -    def assemble(self, values=None, parallel=False, jit=False):
â”‚ â”‚ +    def assemble(self, values=None, parallel=False):
â”‚ â”‚          if values is None:
â”‚ â”‚ -            values = self.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ +            values = self.integrate(parallel=parallel)
â”‚ â”‚          return self.forms[0].assemble(values)
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_assembly/_form.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_assembly/_form.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_assembly/_mixed.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_assembly/_mixed.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -98,23 +98,23 @@
â”‚ â”‚                      grad_v=self.grad_v[i],
â”‚ â”‚                      grad_u=self.grad_u[j],
â”‚ â”‚                  )
â”‚ â”‚                  self.forms.append(f)
â”‚ â”‚          else:
â”‚ â”‚              raise ValueError("Unknown input format.")
â”‚ â”‚  
â”‚ â”‚ -    def assemble(self, values=None, parallel=False, jit=False, block=True):
â”‚ â”‚ +    def assemble(self, values=None, parallel=False, block=True):
â”‚ â”‚  
â”‚ â”‚          out = []
â”‚ â”‚  
â”‚ â”‚          if values is None:
â”‚ â”‚              values = [None] * len(self.forms)
â”‚ â”‚  
â”‚ â”‚          for val, form in zip(values, self.forms):
â”‚ â”‚ -            out.append(form.assemble(val, parallel=parallel, jit=jit))
â”‚ â”‚ +            out.append(form.assemble(val, parallel=parallel))
â”‚ â”‚  
â”‚ â”‚          if block and self.mode == 2:
â”‚ â”‚              K = np.zeros((self.nv, self.nv), dtype=object)
â”‚ â”‚              for a, (i, j) in enumerate(zip(self.i, self.j)):
â”‚ â”‚                  K[i, j] = out[a]
â”‚ â”‚                  if i != j:
â”‚ â”‚                      K[j, i] = out[a].T
â”‚ â”‚ @@ -123,14 +123,14 @@
â”‚ â”‚  
â”‚ â”‚          if block and self.mode == 1:
â”‚ â”‚              return vstack(out).tocsr()
â”‚ â”‚  
â”‚ â”‚          else:
â”‚ â”‚              return out
â”‚ â”‚  
â”‚ â”‚ -    def integrate(self, parallel=False, jit=False):
â”‚ â”‚ +    def integrate(self, parallel=False):
â”‚ â”‚  
â”‚ â”‚          out = []
â”‚ â”‚          for form in self.forms:
â”‚ â”‚ -            out.append(form.integrate(parallel=parallel, jit=jit))
â”‚ â”‚ +            out.append(form.integrate(parallel=parallel))
â”‚ â”‚  
â”‚ â”‚          return out
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_basis/_basis.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_basis/_basis.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -22,19 +22,15 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚ -try:
â”‚ â”‚ -    from einsumt import einsumt
â”‚ â”‚ -except:
â”‚ â”‚ -    from numpy import einsum as einsumt
â”‚ â”‚ +from einsumt import einsumt
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Basis:
â”‚ â”‚      r"""A basis and its gradient built on top of a scalar- or vector-valued
â”‚ â”‚      field. *Basis* refers to the trial and test field, either values or
â”‚ â”‚      gradients evaluated at quadrature points. The first two indices of a basis
â”‚ â”‚      are used for looping over the element shape functions ``a`` and its
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_axi.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_axi.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_base.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_base.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_container.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_container.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_fields.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_fields.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_indices.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_indices.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/_field/_planestrain.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/_field/_planestrain.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/__init__.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/__init__.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_kinematics.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_kinematics.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -22,19 +22,15 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚ -try:
â”‚ â”‚ -    from einsumt import einsumt
â”‚ â”‚ -except:
â”‚ â”‚ -    from numpy import einsum as einsumt
â”‚ â”‚ +from einsumt import einsumt
â”‚ â”‚  
â”‚ â”‚  from ..math import cdya_ik, cdya_il, det, dot, dya, identity, inv, transpose
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class LineChange:
â”‚ â”‚      r"""Line Change.
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_mixed.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_mixed.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_models_hyperelasticity.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_models_hyperelasticity.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_models_hyperelasticity_ad.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_models_hyperelasticity_ad.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_models_linear_elasticity.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_models_linear_elasticity.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_models_pseudo_elasticity.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_models_pseudo_elasticity.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_user_materials.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_user_materials.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_user_materials_hyperelastic.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_user_materials_hyperelastic.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/constitution/_user_materials_models.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/constitution/_user_materials_models.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/dof/_boundary.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/dof/_boundary.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/dof/_loadcase.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/dof/_loadcase.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/dof/_tools.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/dof/_tools.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_base.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_base.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_hexahedron.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_hexahedron.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -338,27 +338,24 @@
â”‚ â”‚                  #
â”‚ â”‚                  [0, -1, 1],
â”‚ â”‚                  [1, 0, 1],
â”‚ â”‚                  [0, 1, 1],
â”‚ â”‚                  [-1, 0, 1],
â”‚ â”‚                  #
â”‚ â”‚                  [-1, -1, 0],
â”‚ â”‚ -                [1, 1, 0],
â”‚ â”‚ +                [1, -1, 0],
â”‚ â”‚                  [1, 1, 0],
â”‚ â”‚                  [-1, 1, 0],
â”‚ â”‚                  #
â”‚ â”‚ -                [0, -1, 0],
â”‚ â”‚ -                [1, 0, 0],
â”‚ â”‚ -                [0, 1, 0],
â”‚ â”‚ -                [-1, 0, 0],
â”‚ â”‚ -                #
â”‚ â”‚                  [-1, 0, 0],
â”‚ â”‚                  [1, 0, 0],
â”‚ â”‚                  [0, -1, 0],
â”‚ â”‚                  [0, 1, 0],
â”‚ â”‚ +                [0, 0, -1],
â”‚ â”‚ +                [0, 0, 1],
â”‚ â”‚                  #
â”‚ â”‚                  [0, 0, 0],
â”‚ â”‚              ],
â”‚ â”‚              dtype=float,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          self._lagrange = ArbitraryOrderLagrange(order=2, dim=3)
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_lagrange.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_lagrange.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_line.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_line.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_quad.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_quad.py
â”‚ â”‚â”„ Files 12% similar despite different names
â”‚ â”‚ @@ -292,14 +292,40 @@
â”‚ â”‚          dhds[ra == 0] = (1 - r**2) * sa[ra == 0] / 2
â”‚ â”‚          dhds[sa == 0] = (1 + ra[sa == 0] * r) * -2 * s / 2
â”‚ â”‚  
â”‚ â”‚          return np.vstack([dhdr, dhds]).T
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class BiQuadraticQuad(Element):
â”‚ â”‚ +    r"""Bi-Quadratic Lagrange quadrilateral element.
â”‚ â”‚ +
â”‚ â”‚ +    ..  code-block::
â”‚ â”‚ +
â”‚ â”‚ +                      ^ s
â”‚ â”‚ +         3 (-1/ 1)    |6 ( 0/ 1)   2 ( 1/ 1)
â”‚ â”‚ +          o-----------o-----------o
â”‚ â”‚ +          |           |           |
â”‚ â”‚ +          |           |           |
â”‚ â”‚ +          |           |           |
â”‚ â”‚ +          |7 (-1/ 0)  |8 ( 0/ 0)  |5 ( 1/ 0)
â”‚ â”‚ +          o      -----o-----------o-----> r
â”‚ â”‚ +          |           |           |
â”‚ â”‚ +          |           |           |
â”‚ â”‚ +          |                       |
â”‚ â”‚ +          |                       |
â”‚ â”‚ +          o-----------o-----------o
â”‚ â”‚ +        0 (-1/-1)     4 ( 0/-1)    1 ( 1/-1)
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚ +    Attributes
â”‚ â”‚ +    ----------
â”‚ â”‚ +    points : ndarray
â”‚ â”‚ +        Array with point locations in natural coordinate system
â”‚ â”‚ +    """
â”‚ â”‚ +
â”‚ â”‚      def __init__(self):
â”‚ â”‚          super().__init__(shape=(9, 2))
â”‚ â”‚  
â”‚ â”‚          self._lagrange = ArbitraryOrderLagrange(order=2, dim=2)
â”‚ â”‚  
â”‚ â”‚          self._vertices = np.array([0, 2, 8, 6])
â”‚ â”‚          self._edges = np.array([1, 5, 7, 3])
â”‚ â”‚ @@ -308,16 +334,27 @@
â”‚ â”‚  
â”‚ â”‚          self._permute = np.concatenate(
â”‚ â”‚              (self._vertices, self._edges, self._faces, self._volume)
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          self.points = self._lagrange.points[self._permute]
â”‚ â”‚  
â”‚ â”‚ -    def function(self, rst):
â”‚ â”‚ -        "quadratic quad shape functions"
â”‚ â”‚ +    def function(self, rs):
â”‚ â”‚ +        r"""Bi-Quadratic Lagrange quadrilateral - shape functions."""
â”‚ â”‚ +
â”‚ â”‚ +        return self._lagrange.function(rs)[self._permute]
â”‚ â”‚  
â”‚ â”‚ -        return self._lagrange.function(rst)[self._permute]
â”‚ â”‚ +    def gradient(self, rs):
â”‚ â”‚ +        r"""Bi-Quadratic Lagrange quadrilateral - gradient of shape functions.
â”‚ â”‚  
â”‚ â”‚ -    def gradient(self, rst):
â”‚ â”‚ -        "quadratic quad gradient of shape functions"
â”‚ â”‚ +        Arguments
â”‚ â”‚ +        ---------
â”‚ â”‚ +        rs : ndarray
â”‚ â”‚ +            Point as coordinate vector for gradient of shape function evaluation
â”‚ â”‚ +
â”‚ â”‚ +        Returns
â”‚ â”‚ +        -------
â”‚ â”‚ +        ndarray
â”‚ â”‚ +            Gradient of shape functions evaluated at given location
â”‚ â”‚ +        """
â”‚ â”‚  
â”‚ â”‚ -        return self._lagrange.gradient(rst)[self._permute, :]
â”‚ â”‚ +        return self._lagrange.gradient(rs)[self._permute, :]
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_tetra.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_tetra.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/element/_triangle.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/element/_triangle.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/math/_field.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/math/_field.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/math/_math.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/math/_math.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/math/_spatial.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/math/_spatial.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/math/_tensor.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/math/_tensor.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -22,19 +22,15 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ -
â”‚ â”‚ -try:
â”‚ â”‚ -    from einsumt import einsumt
â”‚ â”‚ -except:
â”‚ â”‚ -    from numpy import einsum as einsumt
â”‚ â”‚ +from einsumt import einsumt
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def identity(A=None, dim=None, shape=None):
â”‚ â”‚      "Identity according to matrix A with optional specified dim."
â”‚ â”‚      if A is not None:
â”‚ â”‚          dimA, g, e = A.shape[-3:]
â”‚ â”‚          if dim is None:
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_curve.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_curve.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_helpers.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_helpers.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -91,20 +91,20 @@
â”‚ â”‚          # deformation gradient
â”‚ â”‚          self.F = field.extract()
â”‚ â”‚  
â”‚ â”‚          # cell-values of the internal pressure and volume-ratio fields
â”‚ â”‚          self.p = np.zeros(field.region.mesh.ncells)
â”‚ â”‚          self.J = np.ones(field.region.mesh.ncells)
â”‚ â”‚  
â”‚ â”‚ -    def h(self, parallel=False, jit=False):
â”‚ â”‚ +    def h(self, parallel=False):
â”‚ â”‚          "Integrated shape-function gradient w.r.t. the deformed coordinates `x`."
â”‚ â”‚  
â”‚ â”‚          return IntegralFormMixed(
â”‚ â”‚              fun=self.dJdF(self.F), v=self.field, dV=self.field.region.dV
â”‚ â”‚ -        ).integrate(parallel=parallel, jit=jit)[0]
â”‚ â”‚ +        ).integrate(parallel=parallel)[0]
â”‚ â”‚  
â”‚ â”‚      def v(self):
â”‚ â”‚          "Cell volumes of the deformed configuration."
â”‚ â”‚          dV = self.field.region.dV
â”‚ â”‚          if isinstance(self.field[0], FieldAxisymmetric):
â”‚ â”‚              R = self.field[0].radius
â”‚ â”‚              dA = self.field.region.dV
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_job.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_job.py
â”‚ â”‚â”„ Files 5% similar despite different names
â”‚ â”‚ @@ -21,14 +21,16 @@
â”‚ â”‚  GNU General Public License for more details.
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚ +from platform import architecture, machine, platform
â”‚ â”‚ +
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  from ..__about__ import __version__ as version
â”‚ â”‚  from ..math import dot, eigh, eigvalsh, tovoigt, transpose
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def displacement(substep):
â”‚ â”‚ @@ -100,15 +102,15 @@
â”‚ â”‚   _______  _______  ___      __   __  _______  _______ 
â”‚ â”‚  |       ||       ||   |    |  | |  ||       ||       |
â”‚ â”‚  |    ___||    ___||   |    |  | |  ||    _  ||    ___|
â”‚ â”‚  |   |___ |   |___ |   |    |  |_|  ||   |_| ||   |___ 
â”‚ â”‚  |    ___||    ___||   |___ |       ||    ___||    ___|
â”‚ â”‚  |   |    |   |___ |       ||       ||   |    |   |___ 
â”‚ â”‚  |___|    |_______||_______||_______||___|    |_______|
â”‚ â”‚ -FElupe Version {version}
â”‚ â”‚ +FElupe Version {version} ({platform(terse=True)} {machine()} {architecture()[0]})
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚              print("Run Job")
â”‚ â”‚              print("=======\n")
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_multipoint.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_multipoint.py
â”‚ â”‚â”„ Files 22% similar despite different names
â”‚ â”‚ @@ -22,133 +22,142 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ -import sparse
â”‚ â”‚ +from scipy.sparse import eye, lil_matrix
â”‚ â”‚  
â”‚ â”‚  from ._helpers import Assemble, Results
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class MultiPointConstraint:
â”‚ â”‚      def __init__(
â”‚ â”‚          self, field, points, centerpoint, skip=(False, False, False), multiplier=1e3
â”‚ â”‚      ):
â”‚ â”‚          "RBE2 Multi-point-constraint."
â”‚ â”‚          self.field = field
â”‚ â”‚          self.mesh = field.region.mesh
â”‚ â”‚ -        self.points = points
â”‚ â”‚ +        self.points = np.asarray(points)
â”‚ â”‚          self.centerpoint = centerpoint
â”‚ â”‚          self.mask = ~np.array(skip, dtype=bool)[: self.mesh.dim]
â”‚ â”‚          self.axes = np.arange(self.mesh.dim)[self.mask]
â”‚ â”‚          self.multiplier = multiplier
â”‚ â”‚  
â”‚ â”‚          self.results = Results(stress=False, elasticity=False)
â”‚ â”‚          self.assemble = Assemble(vector=self._vector, matrix=self._matrix)
â”‚ â”‚  
â”‚ â”‚ -    def _vector(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False):
â”‚ â”‚          "Calculate vector of residuals with RBE2 contributions."
â”‚ â”‚ +
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚ -        f = self.field.fields[0]
â”‚ â”‚ -        r = sparse.DOK(shape=(self.mesh.npoints, self.mesh.dim))
â”‚ â”‚ -        c = self.centerpoint
â”‚ â”‚ -        for t in self.points:
â”‚ â”‚ -            for d in self.axes:
â”‚ â”‚ -                N = self.multiplier * (-f.values[t, d] + f.values[c, d])
â”‚ â”‚ -                r[t, d] = -N
â”‚ â”‚ -                r[c, d] += N
â”‚ â”‚ -        self.results.force = sparse.COO(r).reshape((-1, 1)).tocsr()
â”‚ â”‚ +
â”‚ â”‚ +        u = self.field.fields[0].values
â”‚ â”‚ +        N = self.multiplier * (-u[self.points] + u[self.centerpoint])
â”‚ â”‚ +        N[:, ~self.mask] = 0
â”‚ â”‚ +
â”‚ â”‚ +        r = lil_matrix(u.shape)
â”‚ â”‚ +        r[self.points] = -N
â”‚ â”‚ +        r[self.centerpoint] = N.sum(axis=0)
â”‚ â”‚ +
â”‚ â”‚ +        self.results.force = r.reshape(-1, 1).tocsr()
â”‚ â”‚          return self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False):
â”‚ â”‚          "Calculate stiffness with RBE2 contributions."
â”‚ â”‚ +
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚ -        L = sparse.DOK(
â”‚ â”‚ -            shape=(self.mesh.npoints, self.mesh.dim, self.mesh.npoints, self.mesh.dim)
â”‚ â”‚ -        )
â”‚ â”‚ -        c = self.centerpoint
â”‚ â”‚ -        for t in self.points:
â”‚ â”‚ -            for d in self.axes:
â”‚ â”‚ -                L[t, d, t, d] = self.multiplier
â”‚ â”‚ -                L[t, d, c, d] = -self.multiplier
â”‚ â”‚ -                L[c, d, t, d] = -self.multiplier
â”‚ â”‚ -                L[c, d, c, d] += self.multiplier
â”‚ â”‚ -        self.results.stiffness = (
â”‚ â”‚ -            sparse.COO(L)
â”‚ â”‚ -            .reshape(
â”‚ â”‚ -                (self.mesh.npoints * self.mesh.dim, self.mesh.npoints * self.mesh.dim)
â”‚ â”‚ -            )
â”‚ â”‚ -            .tocsr()
â”‚ â”‚ -        )
â”‚ â”‚ +
â”‚ â”‚ +        indices = np.arange(self.mesh.ndof).reshape(self.mesh.points.shape)
â”‚ â”‚ +        td = [indices[self.points.reshape(-1, 1), ax].ravel() for ax in self.axes]
â”‚ â”‚ +        cd = [indices[self.centerpoint, ax].ravel() for ax in self.axes]
â”‚ â”‚ +
â”‚ â”‚ +        L = lil_matrix((self.mesh.ndof, self.mesh.ndof))
â”‚ â”‚ +
â”‚ â”‚ +        for t, c in zip(td, cd):
â”‚ â”‚ +
â”‚ â”‚ +            L[t.reshape(-1, 1), t] = eye(len(t)) * self.multiplier
â”‚ â”‚ +            L[t.reshape(-1, 1), c] = -self.multiplier
â”‚ â”‚ +            L[c.reshape(-1, 1), t] = -self.multiplier
â”‚ â”‚ +            L[c.reshape(-1, 1), c] = eye(len(c)) * self.multiplier * len(self.points)
â”‚ â”‚ +
â”‚ â”‚ +        self.results.stiffness = L.tocsr()
â”‚ â”‚          return self.results.stiffness
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class MultiPointContact:
â”‚ â”‚      def __init__(
â”‚ â”‚          self, field, points, centerpoint, skip=(False, False, False), multiplier=1e6
â”‚ â”‚      ):
â”‚ â”‚          "RBE2 Multi-point-bolt-constraint."
â”‚ â”‚          self.field = field
â”‚ â”‚          self.mesh = field.region.mesh
â”‚ â”‚ -        self.points = points
â”‚ â”‚ +        self.points = np.asarray(points)
â”‚ â”‚          self.centerpoint = centerpoint
â”‚ â”‚          self.mask = ~np.array(skip, dtype=bool)[: self.mesh.dim]
â”‚ â”‚          self.axes = np.arange(self.mesh.dim)[self.mask]
â”‚ â”‚          self.multiplier = multiplier
â”‚ â”‚  
â”‚ â”‚          self.results = Results(stress=False, elasticity=False)
â”‚ â”‚          self.assemble = Assemble(vector=self._vector, matrix=self._matrix)
â”‚ â”‚  
â”‚ â”‚ -    def _vector(self, field=None):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False):
â”‚ â”‚          "Calculate vector of residuals with RBE2 contributions."
â”‚ â”‚ +
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚ -        f = self.field.fields[0]
â”‚ â”‚ -        r = sparse.DOK(shape=(self.mesh.npoints, self.mesh.dim))
â”‚ â”‚ -        c = self.centerpoint
â”‚ â”‚ -        for t in self.points:
â”‚ â”‚ -            for d in self.axes:
â”‚ â”‚ -                Xc = self.mesh.points[c, d]
â”‚ â”‚ -                Xt = self.mesh.points[t, d]
â”‚ â”‚ -                xc = f.values[c, d] + Xc
â”‚ â”‚ -                xt = f.values[t, d] + Xt
â”‚ â”‚ -                if np.sign(-Xt + Xc) != np.sign(-xt + xc):
â”‚ â”‚ -                    n = -xt + xc
â”‚ â”‚ -                    r[t, d] = -self.multiplier * n
â”‚ â”‚ -                    r[c, d] += self.multiplier * n
â”‚ â”‚ -        self.results.force = sparse.COO(r).reshape((-1, 1)).tocsr()
â”‚ â”‚ +
â”‚ â”‚ +        u = self.field.fields[0].values
â”‚ â”‚ +
â”‚ â”‚ +        Xc = self.mesh.points[self.centerpoint]
â”‚ â”‚ +        Xt = self.mesh.points[self.points]
â”‚ â”‚ +
â”‚ â”‚ +        xc = u[self.centerpoint] + Xc
â”‚ â”‚ +        xt = u[self.points] + Xt
â”‚ â”‚ +
â”‚ â”‚ +        mask = np.sign(-Xt + Xc) == np.sign(-xt + xc)
â”‚ â”‚ +        mask[:, ~self.mask] = True
â”‚ â”‚ +        n = -xt + xc
â”‚ â”‚ +        n[mask] = 0
â”‚ â”‚ +
â”‚ â”‚ +        r = lil_matrix(u.shape)
â”‚ â”‚ +        r[self.points] = -self.multiplier * n
â”‚ â”‚ +        r[self.centerpoint] = self.multiplier * n.sum(axis=0)
â”‚ â”‚ +
â”‚ â”‚ +        self.results.force = r.reshape(-1, 1).tocsr()
â”‚ â”‚          return self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(self, field=None):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False):
â”‚ â”‚          "Calculate stiffness with RBE2 contributions."
â”‚ â”‚ +
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚ -        f = self.field.fields[0]
â”‚ â”‚ -        L = sparse.DOK(
â”‚ â”‚ -            shape=(self.mesh.npoints, self.mesh.dim, self.mesh.npoints, self.mesh.dim)
â”‚ â”‚ -        )
â”‚ â”‚ -        c = self.centerpoint
â”‚ â”‚ -        for t in self.points:
â”‚ â”‚ -            for d in self.axes:
â”‚ â”‚ -                Xc = self.mesh.points[c, d]
â”‚ â”‚ -                Xt = self.mesh.points[t, d]
â”‚ â”‚ -                xc = f.values[c, d] + Xc
â”‚ â”‚ -                xt = f.values[t, d] + Xt
â”‚ â”‚ -                # n = 0
â”‚ â”‚ -                if np.sign(-Xt + Xc) != np.sign(-xt + xc):
â”‚ â”‚ -                    # n = -xt + xc
â”‚ â”‚ -                    L[t, d, t, d] = self.multiplier
â”‚ â”‚ -                    L[t, d, c, d] = -self.multiplier
â”‚ â”‚ -                    L[c, d, t, d] = -self.multiplier
â”‚ â”‚ -                    L[c, d, c, d] += self.multiplier
â”‚ â”‚ -        self.results.stiffness = (
â”‚ â”‚ -            sparse.COO(L)
â”‚ â”‚ -            .reshape(
â”‚ â”‚ -                (self.mesh.npoints * self.mesh.dim, self.mesh.npoints * self.mesh.dim)
â”‚ â”‚ -            )
â”‚ â”‚ -            .tocsr()
â”‚ â”‚ -        )
â”‚ â”‚ +
â”‚ â”‚ +        u = self.field.fields[0].values
â”‚ â”‚ +
â”‚ â”‚ +        Xc = self.mesh.points[self.centerpoint]
â”‚ â”‚ +        Xt = self.mesh.points[self.points]
â”‚ â”‚ +
â”‚ â”‚ +        xc = u[self.centerpoint] + Xc
â”‚ â”‚ +        xt = u[self.points] + Xt
â”‚ â”‚ +
â”‚ â”‚ +        mask = np.sign(-Xt + Xc) != np.sign(-xt + xc)
â”‚ â”‚ +        masks = [mask[:, ax] for ax in self.axes]
â”‚ â”‚ +
â”‚ â”‚ +        indices = np.arange(self.mesh.ndof).reshape(self.mesh.points.shape)
â”‚ â”‚ +        td = [indices[self.points.reshape(-1, 1), ax].ravel() for ax in self.axes]
â”‚ â”‚ +        cd = [indices[self.centerpoint, ax].ravel() for ax in self.axes]
â”‚ â”‚ +
â”‚ â”‚ +        L = lil_matrix((self.mesh.ndof, self.mesh.ndof))
â”‚ â”‚ +
â”‚ â”‚ +        for t, c, m in zip(td, cd, masks):
â”‚ â”‚ +
â”‚ â”‚ +            L[t[m].reshape(-1, 1), t[m]] = eye(len(t[m])) * self.multiplier
â”‚ â”‚ +            L[t[m].reshape(-1, 1), c] = -self.multiplier
â”‚ â”‚ +            L[c.reshape(-1, 1), t[m]] = -self.multiplier
â”‚ â”‚ +            L[c.reshape(-1, 1), c] = eye(len(c)) * self.multiplier * len(self.points[m])
â”‚ â”‚ +
â”‚ â”‚ +        self.results.stiffness = L.tocsr()
â”‚ â”‚          return self.results.stiffness
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_pointload.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_pointload.py
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -50,15 +50,15 @@
â”‚ â”‚          self.results = Results()
â”‚ â”‚          self.assemble = Assemble(vector=self._vector, matrix=self._matrix)
â”‚ â”‚  
â”‚ â”‚      def update(self, values):
â”‚ â”‚  
â”‚ â”‚          self.__init__(self.field, self.points, values, self.apply_on, self.axisymmetric)
â”‚ â”‚  
â”‚ â”‚ -    def _vector(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          force = [np.zeros_like(f.values) for f in self.field.fields]
â”‚ â”‚          force[self.apply_on][self.points] += self.values
â”‚ â”‚  
â”‚ â”‚ @@ -69,15 +69,15 @@
â”‚ â”‚  
â”‚ â”‚          self.results.force = csr_matrix(
â”‚ â”‚              np.concatenate([f.ravel() for f in force]).reshape(-1, 1)
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          return -self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          n = np.sum(self.field.fieldsizes)
â”‚ â”‚          self.results.stiffness = csr_matrix(([0], ([0], [0])), shape=(n, n))
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_solidbody.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_solidbody.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -64,45 +64,41 @@
â”‚ â”‚              kirchhoff_stress=self._kirchhoff_stress,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          self._area_change = AreaChange()
â”‚ â”‚  
â”‚ â”‚          self._form = IntegralFormMixed
â”‚ â”‚  
â”‚ â”‚ -    def _vector(
â”‚ â”‚ -        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False, items=None, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          self.results.stress = self._gradient(field, args=args, kwargs=kwargs)
â”‚ â”‚          self.results.force = self._form(
â”‚ â”‚              fun=self.results.stress[slice(items)],
â”‚ â”‚              v=self.field,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚ -        ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          return self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(
â”‚ â”‚ -        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False, items=None, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          self.results.elasticity = self._hessian(field, args=args, kwargs=kwargs)
â”‚ â”‚  
â”‚ â”‚          self.results.stiffness = self._form(
â”‚ â”‚              fun=self.results.elasticity[slice(items)],
â”‚ â”‚              v=self.field,
â”‚ â”‚              u=self.field,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚ -        ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          return self.results.stiffness
â”‚ â”‚  
â”‚ â”‚      def _extract(self, field):
â”‚ â”‚  
â”‚ â”‚          self.field = field
â”‚ â”‚          self.results.kinematics = self.field.extract()
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_solidbody_gravity.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_solidbody_gravity.py
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -46,36 +46,36 @@
â”‚ â”‚          self.results.gravity = np.array(gravity)
â”‚ â”‚          self.results.density = density
â”‚ â”‚  
â”‚ â”‚      def update(self, gravity):
â”‚ â”‚  
â”‚ â”‚          self.__init__(self.field, gravity, self.results.density)
â”‚ â”‚  
â”‚ â”‚ -    def _vector(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          # copy and take only the first (displacement) field of the container
â”‚ â”‚          f = self.field.copy()
â”‚ â”‚          f.fields = f.fields[0:1]
â”‚ â”‚  
â”‚ â”‚          self.results.force = self._form(
â”‚ â”‚              fun=[self.results.density * self.results.gravity.reshape(-1, 1, 1)],
â”‚ â”‚              v=f,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚              grad_v=[False],
â”‚ â”‚ -        ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          if len(self.field) > 1:
â”‚ â”‚              self.results.force.resize(np.sum(self.field.fieldsizes), 1)
â”‚ â”‚  
â”‚ â”‚          return -self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(self, field=None, parallel=False, jit=False):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚              self.field = field
â”‚ â”‚  
â”‚ â”‚          n = np.sum(self.field.fieldsizes)
â”‚ â”‚          self.results.stiffness = csr_matrix(([0], ([0], [0])), shape=(n, n))
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_solidbody_incompressible.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_solidbody_incompressible.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -107,72 +107,65 @@
â”‚ â”‚          self.evaluate = Evaluate(
â”‚ â”‚              gradient=self._gradient,
â”‚ â”‚              hessian=self._hessian,
â”‚ â”‚              cauchy_stress=self._cauchy_stress,
â”‚ â”‚              kirchhoff_stress=self._kirchhoff_stress,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚ -    def _vector(
â”‚ â”‚ -        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _vector(self, field=None, parallel=False, items=None, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          self.results.stress = self._gradient(
â”‚ â”‚ -            field, parallel=parallel, jit=jit, args=args, kwargs=kwargs
â”‚ â”‚ +            field, parallel=parallel, args=args, kwargs=kwargs
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          form = self._form(
â”‚ â”‚              fun=self.results.stress,
â”‚ â”‚              v=self.field,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚ -        h = self.results.state.h(parallel=parallel, jit=jit)
â”‚ â”‚ +        h = self.results.state.h(parallel=parallel)
â”‚ â”‚          v = self.results.state.v()
â”‚ â”‚          p = self.results.state.p
â”‚ â”‚  
â”‚ â”‚          values = [
â”‚ â”‚ -            form.integrate(parallel=parallel, jit=jit)[0]
â”‚ â”‚ +            form.integrate(parallel=parallel)[0]
â”‚ â”‚              + h * (self.bulk * (v / self.V - 1) - p)
â”‚ â”‚          ]
â”‚ â”‚  
â”‚ â”‚          self.results.force = form.assemble(values=values)
â”‚ â”‚  
â”‚ â”‚          return self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(
â”‚ â”‚ -        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _matrix(self, field=None, parallel=False, items=None, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          self.results.elasticity = self._hessian(
â”‚ â”‚ -            field, parallel=parallel, jit=jit, args=args, kwargs=kwargs
â”‚ â”‚ +            field, parallel=parallel, args=args, kwargs=kwargs
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          form = self._form(
â”‚ â”‚              fun=self.results.elasticity,
â”‚ â”‚              v=self.field,
â”‚ â”‚              u=self.field,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚ -        h = self.results.state.h(parallel=parallel, jit=jit)
â”‚ â”‚ +        h = self.results.state.h(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚ -        values = [
â”‚ â”‚ -            form.integrate(parallel=parallel, jit=jit)[0]
â”‚ â”‚ -            + self.bulk / self.V * dya(h, h)
â”‚ â”‚ -        ]
â”‚ â”‚ +        values = [form.integrate(parallel=parallel)[0] + self.bulk / self.V * dya(h, h)]
â”‚ â”‚  
â”‚ â”‚          self.results.stiffness = form.assemble(values=values)
â”‚ â”‚  
â”‚ â”‚          return self.results.stiffness
â”‚ â”‚  
â”‚ â”‚ -    def _extract(self, field, parallel=False, jit=False):
â”‚ â”‚ +    def _extract(self, field, parallel=False):
â”‚ â”‚  
â”‚ â”‚          u = field[0].values
â”‚ â”‚          u0 = self.results.state.u
â”‚ â”‚ -        h = self.results.state.h(parallel=parallel, jit=jit)
â”‚ â”‚ +        h = self.results.state.h(parallel=parallel)
â”‚ â”‚          v = self.results.state.v()
â”‚ â”‚          J = self.results.state.J
â”‚ â”‚          p = self.results.state.p
â”‚ â”‚  
â”‚ â”‚          du = (u - u0)[field.region.mesh.cells].transpose([1, 2, 0])
â”‚ â”‚  
â”‚ â”‚          # change of state variables due to change of displacement field
â”‚ â”‚ @@ -185,36 +178,36 @@
â”‚ â”‚          # update state variables
â”‚ â”‚          self.results.state.p = p + dp
â”‚ â”‚          self.results.state.J = J + dJ
â”‚ â”‚          self.results.state.u = u
â”‚ â”‚  
â”‚ â”‚          return self.results.kinematics
â”‚ â”‚  
â”‚ â”‚ -    def _gradient(self, field=None, parallel=False, jit=False, args=(), kwargs={}):
â”‚ â”‚ +    def _gradient(self, field=None, parallel=False, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚ -            self.results.kinematics = self._extract(field, parallel=parallel, jit=jit)
â”‚ â”‚ +            self.results.kinematics = self._extract(field, parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          dJdF = self._area_change.function
â”‚ â”‚          F = self.results.kinematics[0]
â”‚ â”‚          statevars = self.results.statevars
â”‚ â”‚  
â”‚ â”‚          p = self.results.state.p
â”‚ â”‚  
â”‚ â”‚          gradient = self.umat.gradient([F, statevars], *args, **kwargs)
â”‚ â”‚  
â”‚ â”‚          self.results.stress = [gradient[0] + p * dJdF([F])[0]]
â”‚ â”‚          self.results._statevars = gradient[-1]
â”‚ â”‚  
â”‚ â”‚          return self.results.stress
â”‚ â”‚  
â”‚ â”‚ -    def _hessian(self, field=None, parallel=False, jit=False, args=(), kwargs={}):
â”‚ â”‚ +    def _hessian(self, field=None, parallel=False, args=(), kwargs={}):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚ -            self.results.kinematics = self._extract(field, parallel=parallel, jit=jit)
â”‚ â”‚ +            self.results.kinematics = self._extract(field, parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          d2JdF2 = self._area_change.gradient
â”‚ â”‚          F = self.results.kinematics[0]
â”‚ â”‚          statevars = self.results.statevars
â”‚ â”‚          p = self.results.state.p
â”‚ â”‚  
â”‚ â”‚          self.results.elasticity = [
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_solidbody_pressure.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_solidbody_pressure.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -56,17 +56,15 @@
â”‚ â”‚      def _extract(self, field):
â”‚ â”‚  
â”‚ â”‚          self.field = field
â”‚ â”‚          self.results.kinematics = self.field.extract()
â”‚ â”‚  
â”‚ â”‚          return self.results.kinematics
â”‚ â”‚  
â”‚ â”‚ -    def _vector(
â”‚ â”‚ -        self, field=None, pressure=None, parallel=False, jit=False, resize=None
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _vector(self, field=None, pressure=None, parallel=False, resize=None):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚  
â”‚ â”‚              self._update(field)
â”‚ â”‚              self.results.kinematics = self._extract(self.field)
â”‚ â”‚  
â”‚ â”‚          fun = self._area_change.function(
â”‚ â”‚ @@ -78,24 +76,22 @@
â”‚ â”‚          if pressure is not None:
â”‚ â”‚              self.results.pressure = pressure
â”‚ â”‚  
â”‚ â”‚          fun[0] *= self.results.pressure
â”‚ â”‚  
â”‚ â”‚          self.results.force = IntegralFormMixed(
â”‚ â”‚              fun=fun, v=self.field, dV=self.field.region.dV, grad_v=[False]
â”‚ â”‚ -        ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          if resize is not None:
â”‚ â”‚              self.results.force.resize(*resize.shape)
â”‚ â”‚  
â”‚ â”‚          return self.results.force
â”‚ â”‚  
â”‚ â”‚ -    def _matrix(
â”‚ â”‚ -        self, field=None, pressure=None, parallel=False, jit=False, resize=None
â”‚ â”‚ -    ):
â”‚ â”‚ +    def _matrix(self, field=None, pressure=None, parallel=False, resize=None):
â”‚ â”‚  
â”‚ â”‚          if field is not None:
â”‚ â”‚  
â”‚ â”‚              self._update(field)
â”‚ â”‚              self.results.kinematics = self._extract(self.field)
â”‚ â”‚  
â”‚ â”‚          fun = self._area_change.gradient(
â”‚ â”‚ @@ -112,15 +108,15 @@
â”‚ â”‚          self.results.stiffness = IntegralFormMixed(
â”‚ â”‚              fun=fun,
â”‚ â”‚              v=self.field,
â”‚ â”‚              u=self.field,
â”‚ â”‚              dV=self.field.region.dV,
â”‚ â”‚              grad_v=[False],
â”‚ â”‚              grad_u=[True],
â”‚ â”‚ -        ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚          if resize is not None:
â”‚ â”‚              self.results.stiffness.resize(*resize.shape)
â”‚ â”‚  
â”‚ â”‚          return self.results.stiffness
â”‚ â”‚  
â”‚ â”‚      def _update(self, other_field, field=None):
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mechanics/_step.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mechanics/_step.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/__init__.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/__init__.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -20,14 +20,15 @@
â”‚ â”‚      RectangleArbitraryOrderQuad,
â”‚ â”‚  )
â”‚ â”‚  from ._mesh import Mesh
â”‚ â”‚  from ._read import read
â”‚ â”‚  from ._tools import (
â”‚ â”‚      concatenate,
â”‚ â”‚      expand,
â”‚ â”‚ +    flip,
â”‚ â”‚      mirror,
â”‚ â”‚      revolve,
â”‚ â”‚      rotate,
â”‚ â”‚      runouts,
â”‚ â”‚      sweep,
â”‚ â”‚      triangulate,
â”‚ â”‚  )
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_base.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_base.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_container.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_container.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_convert.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_convert.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -23,16 +23,16 @@
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚ +from ._discrete_geometry import DiscreteGeometry
â”‚ â”‚  from ._helpers import mesh_or_data
â”‚ â”‚ -from ._mesh import Mesh
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  @mesh_or_data
â”‚ â”‚  def convert(
â”‚ â”‚      points,
â”‚ â”‚      cells,
â”‚ â”‚      cell_type,
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_geometry.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_geometry.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_helpers.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_helpers.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -23,42 +23,43 @@
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  from functools import wraps
â”‚ â”‚  
â”‚ â”‚ -from ._mesh import Mesh
â”‚ â”‚ -
â”‚ â”‚  
â”‚ â”‚  def mesh_or_data(meshfun):
â”‚ â”‚ -    """If a ``Mesh`` is passed to a mesh function, extract ``points`` and
â”‚ â”‚ -    ``cells`` arrays along with the ``cell_type`` and return a ``Mesh``
â”‚ â”‚ +    """If a ``DiscreteGeometry`` is passed to a mesh function, extract ``points`` and
â”‚ â”‚ +    ``cells`` arrays along with the ``cell_type`` and return a ``DiscreteGeometry``
â”‚ â”‚      as a result."""
â”‚ â”‚  
â”‚ â”‚      @wraps(meshfun)
â”‚ â”‚      def mesh_or_points_cells_type(*args, **kwargs):
â”‚ â”‚  
â”‚ â”‚          # init mesh flag
â”‚ â”‚          is_mesh = False
â”‚ â”‚  
â”‚ â”‚          # check if unnamed args are passed
â”‚ â”‚          if len(args) > 0:
â”‚ â”‚  
â”‚ â”‚ -            # meshfun(Mesh)
â”‚ â”‚ -            if isinstance(args[0], Mesh):
â”‚ â”‚ +            # meshfun(DiscreteGeometry)
â”‚ â”‚ +            if hasattr(args[0], "__mesh__"):
â”‚ â”‚  
â”‚ â”‚                  # set mesh flag
â”‚ â”‚                  is_mesh = True
â”‚ â”‚  
â”‚ â”‚                  # get points, cells and cell_type
â”‚ â”‚                  points = args[0].points
â”‚ â”‚                  cells = args[0].cells
â”‚ â”‚                  cell_type = args[0].cell_type
â”‚ â”‚  
â”‚ â”‚ +                # get mesh class
â”‚ â”‚ +                Mesh = args[0].__mesh__
â”‚ â”‚ +
â”‚ â”‚                  # remove Mesh from args
â”‚ â”‚                  args = args[1:]
â”‚ â”‚  
â”‚ â”‚          if not is_mesh:
â”‚ â”‚  
â”‚ â”‚              # meshfun(points:ndarray, cells:ndarray, cell_type:str)
â”‚ â”‚              if "points" in kwargs.keys():
â”‚ â”‚ @@ -100,15 +101,15 @@
â”‚ â”‚                  cells = args[1]
â”‚ â”‚                  cell_type = args[2]
â”‚ â”‚                  args = args[3:]
â”‚ â”‚  
â”‚ â”‚          # call mesh manipulation function
â”‚ â”‚          points, cells, cell_type = meshfun(points, cells, cell_type, *args, **kwargs)
â”‚ â”‚  
â”‚ â”‚ -        # return a Mesh if a Mesh was passed
â”‚ â”‚ +        # return a DiscreteGeometry if a DiscreteGeometry was passed
â”‚ â”‚          if is_mesh:
â”‚ â”‚              return Mesh(points=points, cells=cells, cell_type=cell_type)
â”‚ â”‚  
â”‚ â”‚          else:
â”‚ â”‚              # or (points, cells, cell_type) if arrays were given
â”‚ â”‚              return points, cells, cell_type
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_read.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_read.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -21,14 +21,16 @@
â”‚ â”‚  GNU General Public License for more details.
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚ +import numpy as np
â”‚ â”‚ +
â”‚ â”‚  from ._container import MeshContainer
â”‚ â”‚  from ._mesh import Mesh
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def read(
â”‚ â”‚      filename, file_format=None, cellblock=None, dim=None, merge=False, decimals=None
â”‚ â”‚  ):
â”‚ â”‚ @@ -47,10 +49,13 @@
â”‚ â”‚          cellblock = slice(None)
â”‚ â”‚  
â”‚ â”‚      cells = m.cells[cellblock]
â”‚ â”‚  
â”‚ â”‚      if not isinstance(cells, list):
â”‚ â”‚          cells = [cells]
â”‚ â”‚  
â”‚ â”‚ -    meshes = [Mesh(points, c.data, c.type) for c in cells]
â”‚ â”‚ +    if len(cells) > 0:
â”‚ â”‚ +        meshes = [Mesh(points, c.data, c.type) for c in cells]
â”‚ â”‚ +    else:
â”‚ â”‚ +        meshes = [Mesh(points, np.zeros((0, 0), dtype=int), None)]
â”‚ â”‚  
â”‚ â”‚      return MeshContainer(meshes, merge=merge, decimals=decimals)
â”‚ â”‚   --- felupe-6.4.0/src/felupe/mesh/_tools.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/mesh/_tools.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -25,15 +25,14 @@
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  from ..math import rotation_matrix
â”‚ â”‚  from ._helpers import mesh_or_data
â”‚ â”‚ -from ._mesh import Mesh
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  @mesh_or_data
â”‚ â”‚  def expand(points, cells, cell_type, n=11, z=1):
â”‚ â”‚      """Expand a 1d-Line to a 2d-Quad or a 2d-Quad to a 3d-Hexahedron Mesh.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚ @@ -77,15 +76,15 @@
â”‚ â”‚          "quad": ("hexahedron", slice(None, None, None)),
â”‚ â”‚      }[cell_type]
â”‚ â”‚  
â”‚ â”‚      # init new padded points array
â”‚ â”‚      p = np.pad(points, ((0, 0), (0, 1)))
â”‚ â”‚  
â”‚ â”‚      # generate new points array for every thickness expansion ``h``
â”‚ â”‚ -    if isinstance(z, int) or isinstance(z, float):
â”‚ â”‚ +    if np.isscalar(z):
â”‚ â”‚          points_z = np.linspace(0, z, n)
â”‚ â”‚      else:
â”‚ â”‚          points_z = z
â”‚ â”‚          n = len(z)
â”‚ â”‚  
â”‚ â”‚      points_new = np.vstack([p + np.array([*zeros, h]) for h in points_z])
â”‚ â”‚  
â”‚ â”‚ @@ -178,15 +177,15 @@
â”‚ â”‚  
â”‚ â”‚      # set new cell-type and the appropriate slice
â”‚ â”‚      cell_type_new, sl = {
â”‚ â”‚          "line": ("quad", slice(None, None, -1)),
â”‚ â”‚          "quad": ("hexahedron", slice(None, None, None)),
â”‚ â”‚      }[cell_type]
â”‚ â”‚  
â”‚ â”‚ -    if isinstance(phi, int) or isinstance(phi, float):
â”‚ â”‚ +    if np.isscalar(phi):
â”‚ â”‚          points_phi = np.linspace(0, phi, n)
â”‚ â”‚      else:
â”‚ â”‚          points_phi = phi
â”‚ â”‚          n = len(points_phi)
â”‚ â”‚  
â”‚ â”‚      if abs(points_phi[-1]) > 360:
â”‚ â”‚          raise ValueError("phi must be within |phi| <= 360 degree.")
â”‚ â”‚ @@ -256,14 +255,62 @@
â”‚ â”‚      for i, j in zip(find, replace):
â”‚ â”‚          cells_new[cells == i] = j
â”‚ â”‚  
â”‚ â”‚      return points_new, cells_new, cell_type
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  @mesh_or_data
â”‚ â”‚ +def flip(points, cells, cell_type, mask=None):
â”‚ â”‚ +    """Ensure positive cell volumes for `tria`, `tetra`, `quad` and
â”‚ â”‚ +    `hexahedron` cell types.
â”‚ â”‚ +
â”‚ â”‚ +    Parameters
â”‚ â”‚ +    ----------
â”‚ â”‚ +    points : list or ndarray
â”‚ â”‚ +        Original point coordinates.
â”‚ â”‚ +    cells : list or ndarray
â”‚ â”‚ +        Original point-connectivity of cells.
â”‚ â”‚ +    cell_type : str
â”‚ â”‚ +        A string in VTK-convention that specifies the cell type.
â”‚ â”‚ +    mask: list or ndarray, optional
â”‚ â”‚ +        Boolean mask for selected cells to flip.
â”‚ â”‚ +
â”‚ â”‚ +    Returns
â”‚ â”‚ +    -------
â”‚ â”‚ +    points : ndarray
â”‚ â”‚ +        Point coordinates.
â”‚ â”‚ +    cells : ndarray
â”‚ â”‚ +        Modified point-connectivity of cells.
â”‚ â”‚ +    cell_type : str or None
â”‚ â”‚ +        A string in VTK-convention that specifies the cell type.
â”‚ â”‚ +
â”‚ â”‚ +    """
â”‚ â”‚ +
â”‚ â”‚ +    if mask is None:
â”‚ â”‚ +        mask = slice(None)
â”‚ â”‚ +    else:
â”‚ â”‚ +        mask = np.where(mask)[0].reshape(-1, 1)
â”‚ â”‚ +
â”‚ â”‚ +    faces_to_flip = {
â”‚ â”‚ +        "line": ([0, 1],),
â”‚ â”‚ +        "triangle": ([0, 1, 2],),
â”‚ â”‚ +        "tetra": ([0, 1, 2],),
â”‚ â”‚ +        "quad": ([0, 1, 2, 3],),
â”‚ â”‚ +        "hexahedron": ([0, 1, 2, 3], [4, 5, 6, 7]),
â”‚ â”‚ +    }[cell_type]
â”‚ â”‚ +
â”‚ â”‚ +    cells_new = cells.copy()
â”‚ â”‚ +
â”‚ â”‚ +    for face in faces_to_flip:
â”‚ â”‚ +        cells_new[:, face] = cells[:, face[::-1]]
â”‚ â”‚ +
â”‚ â”‚ +    return points, cells_new, cell_type
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚ +@mesh_or_data
â”‚ â”‚  def mirror(
â”‚ â”‚      points, cells, cell_type, normal=[1, 0, 0], centerpoint=[0, 0, 0], axis=None
â”‚ â”‚  ):
â”‚ â”‚      """Mirror points by plane normal and ensure positive cell volumes for
â”‚ â”‚      `tria`, `tetra`, `quad` and `hexahedron` cell types.
â”‚ â”‚  
â”‚ â”‚      Parameters
â”‚ â”‚ @@ -309,33 +356,22 @@
â”‚ â”‚  
â”‚ â”‚      centerpoint = np.array(centerpoint, dtype=float)[:dim]
â”‚ â”‚  
â”‚ â”‚      points_new = points - np.einsum(
â”‚ â”‚          "i, k, ...k -> ...i", 2 * normal, normal, (points - centerpoint)
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚ -    faces_to_flip = {
â”‚ â”‚ -        "line": ([0, 1],),
â”‚ â”‚ -        "triangle": ([0, 1, 2],),
â”‚ â”‚ -        "tetra": ([0, 1, 2],),
â”‚ â”‚ -        "quad": ([0, 1, 2, 3],),
â”‚ â”‚ -        "hexahedron": ([0, 1, 2, 3], [4, 5, 6, 7]),
â”‚ â”‚ -    }[cell_type]
â”‚ â”‚ -
â”‚ â”‚ -    cells_new = cells.copy()
â”‚ â”‚ -
â”‚ â”‚ -    for face in faces_to_flip:
â”‚ â”‚ -        cells_new[:, face] = cells[:, face[::-1]]
â”‚ â”‚ -
â”‚ â”‚ -    return points_new, cells_new, cell_type
â”‚ â”‚ +    return flip(points_new, cells, cell_type, mask=None)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def concatenate(meshes):
â”‚ â”‚      "Join a sequence of meshes with identical cell types."
â”‚ â”‚  
â”‚ â”‚ +    Mesh = meshes[0].__mesh__
â”‚ â”‚ +
â”‚ â”‚      points = np.vstack([mesh.points for mesh in meshes])
â”‚ â”‚      offsets = np.cumsum(np.insert([mesh.npoints for mesh in meshes][:-1], 0, 0))
â”‚ â”‚      cells = np.vstack([offset + mesh.cells for offset, mesh in zip(offsets, meshes)])
â”‚ â”‚      mesh = Mesh(points=points, cells=cells, cell_type=meshes[0].cell_type)
â”‚ â”‚  
â”‚ â”‚      return mesh
â”‚ â”‚   --- felupe-6.4.0/src/felupe/quadrature/_base.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/quadrature/_base.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/quadrature/_gausslegendre.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/quadrature/_gausslegendre.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/quadrature/_tetra.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/quadrature/_tetra.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/quadrature/_triangle.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/quadrature/_triangle.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/region/_region.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/region/_region.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -21,14 +21,16 @@
â”‚ â”‚  GNU General Public License for more details.
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚ +import warnings
â”‚ â”‚ +
â”‚ â”‚  import numpy as np
â”‚ â”‚  
â”‚ â”‚  from ..math import det, inv
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Region:
â”‚ â”‚      r"""
â”‚ â”‚ @@ -106,10 +108,17 @@
â”‚ â”‚  
â”‚ â”‚              # inverse of dXdr
â”‚ â”‚              self.drdX = inv(self.dXdr)
â”‚ â”‚  
â”‚ â”‚              # numeric **differential volume element**
â”‚ â”‚              self.dV = det(self.dXdr) * self.quadrature.weights.reshape(-1, 1)
â”‚ â”‚  
â”‚ â”‚ +            # check for negative **differential volume elements**
â”‚ â”‚ +            if np.any(self.dV < 0):
â”‚ â”‚ +                cells_negative_volume = np.where(np.any(self.dV < 0, axis=0))[0]
â”‚ â”‚ +                warnings.warn(
â”‚ â”‚ +                    f"Negative volumes in Region for cells \n {cells_negative_volume}\n Try ``mesh.flip(np.any(region.dV < 0, axis=0))`` and re-create the region."
â”‚ â”‚ +                )
â”‚ â”‚ +
â”‚ â”‚              # Partial derivative of element shape function
â”‚ â”‚              # w.r.t. undeformed coordinates
â”‚ â”‚              self.dhdX = np.einsum("aIpc,IJpc->aJpc", self.dhdr, self.drdX)
â”‚ â”‚   --- felupe-6.4.0/src/felupe/region/_templates.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/region/_templates.py
â”‚ â”‚â”„ Files 14% similar despite different names
â”‚ â”‚ @@ -133,14 +133,66 @@
â”‚ â”‚              grad=grad,
â”‚ â”‚              only_surface=only_surface,
â”‚ â”‚              mask=mask,
â”‚ â”‚              ensure_3d=ensure_3d,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ +class RegionQuadraticQuadBoundary(RegionBoundary):
â”‚ â”‚ +    "A boundary region with a quadratic quad element."
â”‚ â”‚ +
â”‚ â”‚ +    def __init__(
â”‚ â”‚ +        self,
â”‚ â”‚ +        mesh,
â”‚ â”‚ +        quadrature=GaussLegendreBoundary(order=2, dim=2),
â”‚ â”‚ +        grad=True,
â”‚ â”‚ +        only_surface=True,
â”‚ â”‚ +        mask=None,
â”‚ â”‚ +        ensure_3d=False,
â”‚ â”‚ +    ):
â”‚ â”‚ +
â”‚ â”‚ +        element = QuadraticQuad()
â”‚ â”‚ +
â”‚ â”‚ +        super().__init__(
â”‚ â”‚ +            mesh,
â”‚ â”‚ +            element,
â”‚ â”‚ +            quadrature,
â”‚ â”‚ +            grad=grad,
â”‚ â”‚ +            only_surface=only_surface,
â”‚ â”‚ +            mask=mask,
â”‚ â”‚ +            ensure_3d=ensure_3d,
â”‚ â”‚ +        )
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚ +class RegionBiQuadraticQuadBoundary(RegionBoundary):
â”‚ â”‚ +    "A boundary region with a bi-quadratic quad element."
â”‚ â”‚ +
â”‚ â”‚ +    def __init__(
â”‚ â”‚ +        self,
â”‚ â”‚ +        mesh,
â”‚ â”‚ +        quadrature=GaussLegendreBoundary(order=2, dim=2),
â”‚ â”‚ +        grad=True,
â”‚ â”‚ +        only_surface=True,
â”‚ â”‚ +        mask=None,
â”‚ â”‚ +        ensure_3d=False,
â”‚ â”‚ +    ):
â”‚ â”‚ +
â”‚ â”‚ +        element = BiQuadraticQuad()
â”‚ â”‚ +
â”‚ â”‚ +        super().__init__(
â”‚ â”‚ +            mesh,
â”‚ â”‚ +            element,
â”‚ â”‚ +            quadrature,
â”‚ â”‚ +            grad=grad,
â”‚ â”‚ +            only_surface=only_surface,
â”‚ â”‚ +            mask=mask,
â”‚ â”‚ +            ensure_3d=ensure_3d,
â”‚ â”‚ +        )
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚  class RegionConstantHexahedron(Region):
â”‚ â”‚      "A region with a constant hexahedron element."
â”‚ â”‚  
â”‚ â”‚      def __init__(
â”‚ â”‚          self,
â”‚ â”‚          mesh,
â”‚ â”‚          quadrature=GaussLegendre(order=1, dim=3),
â”‚ â”‚ @@ -203,23 +255,59 @@
â”‚ â”‚  
â”‚ â”‚      def __init__(self, mesh, quadrature=GaussLegendre(order=2, dim=3), grad=True):
â”‚ â”‚  
â”‚ â”‚          element = QuadraticHexahedron()
â”‚ â”‚          super().__init__(mesh, element, quadrature, grad=grad)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ +class RegionQuadraticHexahedronBoundary(RegionBoundary):
â”‚ â”‚ +    "A boundary region with a (serendipity) quadratic hexahedron element."
â”‚ â”‚ +
â”‚ â”‚ +    def __init__(
â”‚ â”‚ +        self,
â”‚ â”‚ +        mesh,
â”‚ â”‚ +        quadrature=GaussLegendreBoundary(order=2, dim=3),
â”‚ â”‚ +        grad=True,
â”‚ â”‚ +        only_surface=True,
â”‚ â”‚ +        mask=None,
â”‚ â”‚ +    ):
â”‚ â”‚ +
â”‚ â”‚ +        element = QuadraticHexahedron()
â”‚ â”‚ +        super().__init__(
â”‚ â”‚ +            mesh, element, quadrature, grad=grad, only_surface=only_surface, mask=mask
â”‚ â”‚ +        )
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚  class RegionTriQuadraticHexahedron(Region):
â”‚ â”‚      "A region with a tri-quadratic (lagrange) hexahedron element."
â”‚ â”‚  
â”‚ â”‚      def __init__(self, mesh, quadrature=GaussLegendre(order=2, dim=3), grad=True):
â”‚ â”‚  
â”‚ â”‚          element = TriQuadraticHexahedron()
â”‚ â”‚          super().__init__(mesh, element, quadrature, grad=grad)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ +class RegionTriQuadraticHexahedronBoundary(RegionBoundary):
â”‚ â”‚ +    "A boundary region with a tri-quadratic (lagrange) hexahedron element."
â”‚ â”‚ +
â”‚ â”‚ +    def __init__(
â”‚ â”‚ +        self,
â”‚ â”‚ +        mesh,
â”‚ â”‚ +        quadrature=GaussLegendreBoundary(order=2, dim=3),
â”‚ â”‚ +        grad=True,
â”‚ â”‚ +        only_surface=True,
â”‚ â”‚ +        mask=None,
â”‚ â”‚ +    ):
â”‚ â”‚ +
â”‚ â”‚ +        element = TriQuadraticHexahedron()
â”‚ â”‚ +        super().__init__(
â”‚ â”‚ +            mesh, element, quadrature, grad=grad, only_surface=only_surface, mask=mask
â”‚ â”‚ +        )
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚  class RegionLagrange(Region):
â”‚ â”‚      "A region with an arbitrary order lagrange element."
â”‚ â”‚  
â”‚ â”‚      def __init__(self, mesh, order, dim, quadrature=None, grad=True):
â”‚ â”‚  
â”‚ â”‚          if quadrature is None:
â”‚ â”‚              quadrature = GaussLegendre(order=order, dim=dim, permute=False)
â”‚ â”‚   --- felupe-6.4.0/src/felupe/solve/_solve.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/solve/_solve.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe/tools/_check.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/tools/_post.py
â”‚ â”‚â”„ Files 24% similar despite different names
â”‚ â”‚ @@ -22,40 +22,40 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ +from scipy.interpolate import interp1d
â”‚ â”‚ +from scipy.sparse import issparse
â”‚ â”‚  
â”‚ â”‚ -from ..math import norm
â”‚ â”‚  
â”‚ â”‚ +def force(field, r, boundary):
â”‚ â”‚ +    if issparse(r):
â”‚ â”‚ +        r = r.toarray()
â”‚ â”‚ +    return (
â”‚ â”‚ +        ((np.split(r, field.offsets)[0]).reshape(-1, field[0].dim))[boundary.points]
â”‚ â”‚ +    ).sum(0)
â”‚ â”‚  
â”‚ â”‚ -def check(dfields, fields, f, dof1, dof0, tol_f=1e-3, tol_x=1e-3, verbose=1):
â”‚ â”‚ -    "Check if solution dfields is valid."
â”‚ â”‚  
â”‚ â”‚ -    fields = fields.fields
â”‚ â”‚ +def moment(field, r, boundary, point=np.zeros(3)):
â”‚ â”‚ +    if issparse(r):
â”‚ â”‚ +        r = r.toarray()
â”‚ â”‚ +    point = point.reshape(1, 3)
â”‚ â”‚  
â”‚ â”‚ -    x = fields[0]
â”‚ â”‚ -    dx = dfields[0]
â”‚ â”‚ +    indices = np.array([(1, 2), (2, 0), (0, 1)])
â”‚ â”‚  
â”‚ â”‚ -    # get reference values of "f" and "x"
â”‚ â”‚ -    ref_f = 1 if np.linalg.norm(f[dof0]) == 0 else np.linalg.norm(f[dof0])
â”‚ â”‚ -    ref_x = 1 if np.linalg.norm(x[dof0]) == 0 else np.linalg.norm(x[dof0])
â”‚ â”‚ +    displacements = field[0].values
â”‚ â”‚ +    force = (np.split(r, field.offsets)[0]).reshape(-1, 3)
â”‚ â”‚  
â”‚ â”‚ -    norm_f = np.linalg.norm(f[dof1[dof1 < len(dx)]]) / ref_f
â”‚ â”‚ -    norm_x = np.linalg.norm(dx.ravel()[dof1[dof1 < len(dx)]]) / ref_x
â”‚ â”‚ +    d = ((point + displacements) - point)[boundary.points]
â”‚ â”‚ +    f = force[boundary.points]
â”‚ â”‚  
â”‚ â”‚ -    norm_dfields = norm(dfields[1:])
â”‚ â”‚ +    return np.array([(f[:, i] * d[:, i[::-1]]).sum() for i in indices])
â”‚ â”‚  
â”‚ â”‚ -    if verbose:
â”‚ â”‚ -        info_r = f"|r|={norm_f:1.3e} |u|={norm_x:1.3e}"
â”‚ â”‚ -        info_f = [f"(|Î´{2+i}|={norm_f:1.3e})" for i, norm_f in enumerate(norm_dfields)]
â”‚ â”‚  
â”‚ â”‚ -        print(" ".join([info_r, *info_f]))
â”‚ â”‚ -
â”‚ â”‚ -    if norm_f < tol_f and norm_x < tol_x:
â”‚ â”‚ -        success = True
â”‚ â”‚ -    else:
â”‚ â”‚ -        success = False
â”‚ â”‚ -
â”‚ â”‚ -    return success
â”‚ â”‚ +def curve(x, y):
â”‚ â”‚ +    kind = [None, "linear", "quadratic", "cubic"][min(len(y), 4) - 1]
â”‚ â”‚ +    f = interp1d(x[: len(y)], y, kind=kind)
â”‚ â”‚ +    xx = np.linspace(x[0], x[: len(y)][-1])
â”‚ â”‚ +    return np.array([x[: len(y)], y]), np.array([xx, f(xx)])
â”‚ â”‚ â”œâ”€â”€ encoding
â”‚ â”‚ â”‚ @@ -1 +1 @@
â”‚ â”‚ â”‚ -utf-8
â”‚ â”‚ â”‚ +us-ascii
â”‚ â”‚   --- felupe-6.4.0/src/felupe/tools/_newton.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/tools/_newton.py
â”‚ â”‚â”„ Files 9% similar despite different names
â”‚ â”‚ @@ -43,19 +43,19 @@
â”‚ â”‚          self.x = x
â”‚ â”‚          self.fun = fun
â”‚ â”‚          self.jac = jac
â”‚ â”‚          self.success = success
â”‚ â”‚          self.iterations = iterations
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def fun_items(items, x, parallel=False, jit=False):
â”‚ â”‚ +def fun_items(items, x, parallel=False):
â”‚ â”‚      "Force residuals from assembly of equilibrium (weak form)."
â”‚ â”‚  
â”‚ â”‚      # init keyword arguments
â”‚ â”‚ -    kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +    kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚      # link field of items with global field
â”‚ â”‚      [item.field.link(x) for item in items]
â”‚ â”‚  
â”‚ â”‚      # init vector with shape from global field
â”‚ â”‚      shape = (np.sum(x.fieldsizes), 1)
â”‚ â”‚      vector = csr_matrix(shape)
â”‚ â”‚ @@ -71,19 +71,19 @@
â”‚ â”‚  
â”‚ â”‚          # add vector
â”‚ â”‚          vector += r
â”‚ â”‚  
â”‚ â”‚      return vector.toarray()[:, 0]
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def jac_items(items, x, parallel=False, jit=False):
â”‚ â”‚ +def jac_items(items, x, parallel=False):
â”‚ â”‚      "Tangent stiffness matrix from assembly of linearized equilibrium."
â”‚ â”‚  
â”‚ â”‚      # init keyword arguments
â”‚ â”‚ -    kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +    kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚      # init matrix with shape from global field
â”‚ â”‚      shape = (np.sum(x.fieldsizes), np.sum(x.fieldsizes))
â”‚ â”‚      matrix = csr_matrix(shape)
â”‚ â”‚  
â”‚ â”‚      for body in items:
â”‚ â”‚  
â”‚ â”‚ @@ -96,39 +96,39 @@
â”‚ â”‚  
â”‚ â”‚          # add matrix
â”‚ â”‚          matrix += K
â”‚ â”‚  
â”‚ â”‚      return matrix
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def fun(x, umat, parallel=False, jit=False, grad=True, add_identity=True, sym=False):
â”‚ â”‚ +def fun(x, umat, parallel=False, grad=True, add_identity=True, sym=False):
â”‚ â”‚      "Force residuals from assembly of equilibrium (weak form)."
â”‚ â”‚  
â”‚ â”‚      return (
â”‚ â”‚          IntegralFormMixed(
â”‚ â”‚              fun=umat.gradient(x.extract(grad=grad, add_identity=add_identity, sym=sym))[
â”‚ â”‚                  :-1
â”‚ â”‚              ],
â”‚ â”‚              v=x,
â”‚ â”‚              dV=x.region.dV,
â”‚ â”‚          )
â”‚ â”‚ -        .assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +        .assemble(parallel=parallel)
â”‚ â”‚          .toarray()[:, 0]
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def jac(x, umat, parallel=False, jit=False, grad=True, add_identity=True, sym=False):
â”‚ â”‚ +def jac(x, umat, parallel=False, grad=True, add_identity=True, sym=False):
â”‚ â”‚      "Tangent stiffness matrix from assembly of linearized equilibrium."
â”‚ â”‚  
â”‚ â”‚      return IntegralFormMixed(
â”‚ â”‚          fun=umat.hessian(x.extract(grad=grad, add_identity=add_identity, sym=sym)),
â”‚ â”‚          v=x,
â”‚ â”‚          dV=x.region.dV,
â”‚ â”‚          u=x,
â”‚ â”‚ -    ).assemble(parallel=parallel, jit=jit)
â”‚ â”‚ +    ).assemble(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def solve(A, b, x, dof1, dof0, offsets=None, ext0=None, solver=spsolve):
â”‚ â”‚      "Solve partitioned system."
â”‚ â”‚  
â”‚ â”‚      system = fesolve.partition(x, A, dof1, dof0, -b)
â”‚ â”‚      dx = fesolve.solve(*system, ext0, solver=solver)
â”‚ â”‚ @@ -145,15 +145,15 @@
â”‚ â”‚      if dof1 is None:
â”‚ â”‚          dof1 = slice(None)
â”‚ â”‚  
â”‚ â”‚      if dof0 is None:
â”‚ â”‚          dof0 = slice(0, 0)
â”‚ â”‚  
â”‚ â”‚      fnorm = sumnorm(f[dof1]) / (eps + sumnorm(f[dof0]))
â”‚ â”‚ -    success = fnorm < ftol  # and xnorm < xtol
â”‚ â”‚ +    success = fnorm < ftol and xnorm < xtol
â”‚ â”‚  
â”‚ â”‚      if success and items is not None:
â”‚ â”‚          for item in items:
â”‚ â”‚              [item.results.update_statevars() for item in items]
â”‚ â”‚  
â”‚ â”‚      return xnorm, fnorm, success
â”‚ â”‚  
â”‚ â”‚ @@ -170,26 +170,21 @@
â”‚ â”‚      jac=jac,
â”‚ â”‚      solve=solve,
â”‚ â”‚      maxiter=16,
â”‚ â”‚      update=update,
â”‚ â”‚      check=check,
â”‚ â”‚      args=(),
â”‚ â”‚      kwargs={},
â”‚ â”‚ -    kwargs_solve=None,
â”‚ â”‚ -    kwargs_check=None,
â”‚ â”‚      tol=np.sqrt(np.finfo(float).eps),
â”‚ â”‚ -    umat=None,
â”‚ â”‚      items=None,
â”‚ â”‚      dof1=None,
â”‚ â”‚      dof0=None,
â”‚ â”‚      ext0=None,
â”‚ â”‚      solver=spsolve,
â”‚ â”‚ -    export_jac=False,
â”‚ â”‚      verbose=True,
â”‚ â”‚ -    timing=True,
â”‚ â”‚  ):
â”‚ â”‚      """
â”‚ â”‚      General-purpose Newton-Rhapson algorithm
â”‚ â”‚  
â”‚ â”‚      (Nonlinear) equilibrium equations `f`, as a function `f(x)` of the
â”‚ â”‚      unknowns `x`, are solved by linearization of `f` at given unknowns `x0`.
â”‚ â”‚  
â”‚ â”‚ @@ -211,33 +206,27 @@
â”‚ â”‚  
â”‚ â”‚           x = xn + dx                                       (6)
â”‚ â”‚  
â”‚ â”‚      Eq.(5) and Eq.(6) are repeated until `check(dx, x, f)` returns `True`.
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    if timing:
â”‚ â”‚ -        time_start = perf_counter()
â”‚ â”‚ +    if verbose:
â”‚ â”‚ +        runtime = [perf_counter()]
â”‚ â”‚  
â”‚ â”‚      if x0 is not None:
â”‚ â”‚          # take x0
â”‚ â”‚          x = x0
â”‚ â”‚  
â”‚ â”‚      else:
â”‚ â”‚          # obtain field of first body
â”‚ â”‚          x = items[0].field
â”‚ â”‚  
â”‚ â”‚ -    if umat is not None:
â”‚ â”‚ -        kwargs["umat"] = umat
â”‚ â”‚ -
â”‚ â”‚ -    if kwargs_solve is None:
â”‚ â”‚ -        kwargs_solve = {}
â”‚ â”‚ -
â”‚ â”‚ -    if kwargs_check is None:
â”‚ â”‚ -        kwargs_check = {}
â”‚ â”‚ +    kwargs_solve = {}
â”‚ â”‚ +    sig = inspect.signature(solve)
â”‚ â”‚  
â”‚ â”‚      # pre-evaluate function at given unknowns "x"
â”‚ â”‚      if items is not None:
â”‚ â”‚          f = fun_items(items, x, *args, **kwargs)
â”‚ â”‚      else:
â”‚ â”‚          f = fun(x, *args, **kwargs)
â”‚ â”‚  
â”‚ â”‚ @@ -254,59 +243,60 @@
â”‚ â”‚  
â”‚ â”‚          # evaluate jacobian at unknowns "x"
â”‚ â”‚          if items is not None:
â”‚ â”‚              K = jac_items(items, x, *args, **kwargs)
â”‚ â”‚          else:
â”‚ â”‚              K = jac(x, *args, **kwargs)
â”‚ â”‚  
â”‚ â”‚ -        # solve linear system and update solution
â”‚ â”‚ -        sig = inspect.signature(solve)
â”‚ â”‚ -
â”‚ â”‚ +        # create keyword-arguments for solving the linear system
â”‚ â”‚          keys = ["x", "dof1", "dof0", "ext0", "solver"]
â”‚ â”‚          values = [x, dof1, dof0, ext0, solver]
â”‚ â”‚  
â”‚ â”‚          for key, value in zip(keys, values):
â”‚ â”‚  
â”‚ â”‚              if key in sig.parameters:
â”‚ â”‚                  kwargs_solve[key] = value
â”‚ â”‚  
â”‚ â”‚ +        # solve linear system and update solution
â”‚ â”‚ +        if verbose:
â”‚ â”‚ +            soltime = [perf_counter()]
â”‚ â”‚ +
â”‚ â”‚          dx = solve(K, -f, **kwargs_solve)
â”‚ â”‚ +
â”‚ â”‚ +        if verbose:
â”‚ â”‚ +            soltime.append(perf_counter())
â”‚ â”‚ +
â”‚ â”‚          x = update(x, dx)
â”‚ â”‚  
â”‚ â”‚          # evaluate function at unknowns "x"
â”‚ â”‚          if items is not None:
â”‚ â”‚              f = fun_items(items, x, *args, **kwargs)
â”‚ â”‚          else:
â”‚ â”‚              f = fun(x, *args, **kwargs)
â”‚ â”‚  
â”‚ â”‚          # check success of solution
â”‚ â”‚          xnorm, fnorm, success = check(
â”‚ â”‚ -            dx, x, f, tol, tol, dof1, dof0, items, **kwargs_check
â”‚ â”‚ +            dx=dx, x=x, f=f, xtol=np.inf, ftol=tol, dof1=dof1, dof0=dof0, items=items
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          if verbose:
â”‚ â”‚              print("|%2d | %1.3e | %1.3e |" % (1 + iteration, fnorm, xnorm))
â”‚ â”‚  
â”‚ â”‚          if success:
â”‚ â”‚ -            if verbose and not timing:
â”‚ â”‚ -                print("\nSolution converged in %d iterations.\n" % (iteration + 1))
â”‚ â”‚              break
â”‚ â”‚  
â”‚ â”‚          if np.any(np.isnan([xnorm, fnorm])):
â”‚ â”‚              raise ValueError("Norm of unknowns is NaN.")
â”‚ â”‚  
â”‚ â”‚      if 1 + iteration == maxiter and not success:
â”‚ â”‚          raise ValueError("Maximum number of iterations reached (not converged).\n")
â”‚ â”‚  
â”‚ â”‚      Res = Result(x=x, fun=f, success=success, iterations=1 + iteration)
â”‚ â”‚  
â”‚ â”‚ -    if export_jac:
â”‚ â”‚ -        Res.jac = K
â”‚ â”‚ -
â”‚ â”‚ -    if verbose and timing:
â”‚ â”‚ -        time_finish = perf_counter()
â”‚ â”‚ +    if verbose:
â”‚ â”‚ +        runtime.append(perf_counter())
â”‚ â”‚          print(
â”‚ â”‚ -            "\nSolution converged in %d iterations within %1.4g seconds.\n"
â”‚ â”‚ -            % (iteration + 1, time_finish - time_start)
â”‚ â”‚ +            "\nConverged in %d iterations (Assembly: %1.4g s, Solve: %1.4g s).\n"
â”‚ â”‚ +            % (iteration + 1, np.diff(runtime) - np.diff(soltime), np.diff(soltime))
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      return Res
â”‚ â”‚   --- felupe-6.4.0/src/felupe/tools/_post.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/tools/_solve.py
â”‚ â”‚â”„ Files 22% similar despite different names
â”‚ â”‚ @@ -22,40 +22,16 @@
â”‚ â”‚  
â”‚ â”‚  You should have received a copy of the GNU General Public License
â”‚ â”‚  along with Felupe.  If not, see <http://www.gnu.org/licenses/>.
â”‚ â”‚  
â”‚ â”‚  """
â”‚ â”‚  
â”‚ â”‚  import numpy as np
â”‚ â”‚ -from scipy.interpolate import interp1d
â”‚ â”‚ -from scipy.sparse import issparse
â”‚ â”‚  
â”‚ â”‚ +from .. import solve as solvetools
â”‚ â”‚  
â”‚ â”‚ -def force(field, r, boundary):
â”‚ â”‚ -    if issparse(r):
â”‚ â”‚ -        r = r.toarray()
â”‚ â”‚ -    return (
â”‚ â”‚ -        ((np.split(r, field.offsets)[0]).reshape(-1, field[0].dim))[boundary.points]
â”‚ â”‚ -    ).sum(0)
â”‚ â”‚  
â”‚ â”‚ -
â”‚ â”‚ -def moment(field, r, boundary, point=np.zeros(3)):
â”‚ â”‚ -    if issparse(r):
â”‚ â”‚ -        r = r.toarray()
â”‚ â”‚ -    point = point.reshape(1, 3)
â”‚ â”‚ -
â”‚ â”‚ -    indices = np.array([(1, 2), (2, 0), (0, 1)])
â”‚ â”‚ -
â”‚ â”‚ -    displacements = field[0].values
â”‚ â”‚ -    force = (np.split(r, field.offsets)[0]).reshape(-1, 3)
â”‚ â”‚ -
â”‚ â”‚ -    d = ((point + displacements) - point)[boundary.points]
â”‚ â”‚ -    f = force[boundary.points]
â”‚ â”‚ -
â”‚ â”‚ -    return np.array([(f[:, i] * d[:, i[::-1]]).sum() for i in indices])
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚ -def curve(x, y):
â”‚ â”‚ -    kind = [None, "linear", "quadratic", "cubic"][min(len(y), 4) - 1]
â”‚ â”‚ -    f = interp1d(x[: len(y)], y, kind=kind)
â”‚ â”‚ -    xx = np.linspace(x[0], x[: len(y)][-1])
â”‚ â”‚ -    return np.array([x[: len(y)], y]), np.array([xx, f(xx)])
â”‚ â”‚ +def solve(K, f, field, dof0, dof1, offsets, ext0):
â”‚ â”‚ +    "Solve linear equation system K dx = b"
â”‚ â”‚ +    system = solvetools.partition(field, K, dof1, dof0, -f)
â”‚ â”‚ +    dfields = np.split(solvetools.solve(*system, ext0), offsets)
â”‚ â”‚ +    return dfields
â”‚ â”‚   --- felupe-6.4.0/src/felupe/tools/_project.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/tools/_project.py
â”‚ â”‚â”„ Files 24% similar despite different names
â”‚ â”‚ @@ -81,66 +81,80 @@
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def project(values, region, average=True, mean=False):
â”‚ â”‚      """Projection (and optionally averaging) of scalar or vectorial values
â”‚ â”‚      at quadrature points to mesh-points.
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    # 1d-reshaped values
â”‚ â”‚ -    dim = int(np.product(values.shape[:-2]))
â”‚ â”‚ +    dim = values.shape[:-2]
â”‚ â”‚ +    size = int(np.product(dim))
â”‚ â”‚      weights = region.quadrature.weights
â”‚ â”‚  
â”‚ â”‚ +    # transpose values
â”‚ â”‚ +    idx = np.arange(len(values.shape))
â”‚ â”‚ +    idx[: len(dim)] = idx[: len(dim)][::-1]
â”‚ â”‚ +    values = values.transpose(idx)
â”‚ â”‚ +
â”‚ â”‚      if mean:
â”‚ â”‚  
â”‚ â”‚          # evaluate how often the values must be repeated to match the number
â”‚ â”‚          # of element-points
â”‚ â”‚          reps = np.ones(len(values.shape), dtype=int)
â”‚ â”‚          reps[-2] = len(region.element.points)
â”‚ â”‚  
â”‚ â”‚          # np.average(keepdims=True) requires numpy >= 1.23.0
â”‚ â”‚ -        values = np.tile(
â”‚ â”‚ -            np.average(values, axis=-2, weights=weights),
â”‚ â”‚ -            reps=reps,
â”‚ â”‚ -        )
â”‚ â”‚ +        values = np.average(values, axis=-2, weights=weights)
â”‚ â”‚  
â”‚ â”‚          # workaround for np.average(keepdims=True)
â”‚ â”‚          shape = values.shape
â”‚ â”‚          shape = np.insert(shape, -1, 1)
â”‚ â”‚          values = values.reshape(*shape)
â”‚ â”‚  
â”‚ â”‚ -    u = values.T.reshape(-1, dim)
â”‚ â”‚ +        # broadcast averaged values to match the number of element-points
â”‚ â”‚ +        values = np.broadcast_to(values, shape=np.broadcast_shapes(shape, reps))
â”‚ â”‚ +
â”‚ â”‚ +    # reshape from (shape, nint.points, nelements) to 1d-values
â”‚ â”‚ +    u = values.T.reshape(-1, size)
â”‚ â”‚  
â”‚ â”‚ -    # disconnected mesh
â”‚ â”‚ +    # disconnect the mesh
â”‚ â”‚      m = region.mesh.disconnect()
â”‚ â”‚  
â”‚ â”‚      if mean:
â”‚ â”‚          # region on disconnected mesh with original quadrature scheme
â”‚ â”‚ +        # a single-point quadrature would be sufficient
â”‚ â”‚ +        # but would require additional (not available) informations
â”‚ â”‚          r = Region(m, region.element, region.quadrature, grad=False)
â”‚ â”‚      else:
â”‚ â”‚          # region on disconnected mesh with inverse quadrature scheme
â”‚ â”‚          r = Region(m, region.element, region.quadrature.inv(), grad=False)
â”‚ â”‚  
â”‚ â”‚      # field for values on disconnected mesh; project values to mesh-points
â”‚ â”‚ -    f = Field(r, dim=dim, values=u)
â”‚ â”‚ +    f = Field(r, dim=size, values=u)
â”‚ â”‚      v = f.interpolate()
â”‚ â”‚  
â”‚ â”‚      if mean:
â”‚ â”‚ -        v = np.tile(
â”‚ â”‚ -            np.average(v, axis=-2, weights=weights).reshape(dim, 1, -1), reps=reps
â”‚ â”‚ -        )
â”‚ â”‚ +
â”‚ â”‚ +        # due to the usage of the original quadrature scheme the averaging must be
â”‚ â”‚ +        # applied again
â”‚ â”‚ +        # np.average(keepdims=True) requires numpy >= 1.23.0
â”‚ â”‚ +        v = np.average(v, axis=-2, weights=weights).reshape(size, 1, -1)
â”‚ â”‚ +
â”‚ â”‚ +        # broadcast averaged values to match the number of element-points
â”‚ â”‚ +        shape = np.array([*v.shape[:-2], len(region.element.points), v.shape[-1]])
â”‚ â”‚ +        v = np.broadcast_to(v, shape=shape)
â”‚ â”‚  
â”‚ â”‚      if average:
â”‚ â”‚  
â”‚ â”‚          # create dummy field for values on original mesh
â”‚ â”‚          # (used for calculation of sparse-matrix indices)
â”‚ â”‚ -        g = Field(region, dim=dim)
â”‚ â”‚ +        g = Field(region, dim=size)
â”‚ â”‚  
â”‚ â”‚          # average values
â”‚ â”‚          w = sparsematrix(
â”‚ â”‚ -            (v.T.ravel(), g.indices.ai), shape=(dim * region.mesh.npoints, 1)
â”‚ â”‚ -        ).toarray().reshape(-1, dim) / region.mesh.cells_per_point.reshape(-1, 1)
â”‚ â”‚ +            (v.T.ravel(), g.indices.ai), shape=(size * region.mesh.npoints, 1)
â”‚ â”‚ +        ).toarray().reshape(-1, size) / region.mesh.cells_per_point.reshape(-1, 1)
â”‚ â”‚  
â”‚ â”‚      else:
â”‚ â”‚  
â”‚ â”‚ -        w = v.reshape(-1, dim)
â”‚ â”‚ +        w = v.T.reshape(-1, size)
â”‚ â”‚  
â”‚ â”‚      return w
â”‚ â”‚   --- felupe-6.4.0/src/felupe/tools/_save.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe/tools/_save.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/src/felupe.egg-info/PKG-INFO
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe.egg-info/PKG-INFO
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: felupe
â”‚ â”‚ -Version: 6.4.0
â”‚ â”‚ +Version: 7.0.0
â”‚ â”‚  Summary: Finite Element Analysis
â”‚ â”‚  Author: Andreas Dutzler
â”‚ â”‚  Author-email: a.dutzler@gmail.com
â”‚ â”‚  License: GNU GENERAL PUBLIC LICENSE
â”‚ â”‚                                 Version 3, 29 June 2007
â”‚ â”‚          
â”‚ â”‚           Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
â”‚ â”‚ @@ -690,38 +690,39 @@
â”‚ â”‚  Classifier: Operating System :: OS Independent
â”‚ â”‚  Classifier: Programming Language :: Python
â”‚ â”‚  Classifier: Programming Language :: Python :: 3
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.7
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.8
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.9
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.10
â”‚ â”‚ +Classifier: Programming Language :: Python :: 3.11
â”‚ â”‚  Classifier: Topic :: Scientific/Engineering
â”‚ â”‚  Classifier: Topic :: Scientific/Engineering :: Mathematics
â”‚ â”‚  Classifier: Topic :: Utilities
â”‚ â”‚  Requires-Python: >=3.7
â”‚ â”‚  Description-Content-Type: text/markdown
â”‚ â”‚  Provides-Extra: all
â”‚ â”‚  License-File: LICENSE
â”‚ â”‚  
â”‚ â”‚ -# FElupe - Finite Element Analysis
â”‚ â”‚ +# ğŸ” FElupe - Finite Element Analysis
â”‚ â”‚  
â”‚ â”‚  [![PyPI version shields.io](https://img.shields.io/pypi/v/felupe.svg)](https://pypi.python.org/pypi/felupe/) [![Documentation Status](https://readthedocs.org/projects/felupe/badge/?version=latest)](https://felupe.readthedocs.io/en/latest/?badge=latest) [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) ![Made with love in Graz (Austria)](https://img.shields.io/badge/Made%20with%20%E2%9D%A4%EF%B8%8F%20in-Graz%20(Austria)-0c674a) [![codecov](https://codecov.io/gh/adtzlr/felupe/branch/main/graph/badge.svg?token=J2QP6Y6LVH)](https://codecov.io/gh/adtzlr/felupe) [![DOI](https://zenodo.org/badge/360657894.svg)](https://zenodo.org/badge/latestdoi/360657894) ![Codestyle black](https://img.shields.io/badge/code%20style-black-black) ![GitHub Repo stars](https://img.shields.io/github/stars/adtzlr/felupe?logo=github) ![PyPI - Downloads](https://img.shields.io/pypi/dm/felupe)
â”‚ â”‚  
â”‚ â”‚ -<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" width="220px"/>
â”‚ â”‚ +<img src="https://raw.githubusercontent.com/adtzlr/felupe/main/docs/_static/logo_light.svg" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604246-5a416081-6777-4f33-afdf-efdb51338722.png" height="120px"/> <img src="https://user-images.githubusercontent.com/5793153/230604587-42e3e339-e08c-4cc8-8000-f7046a8d95df.png" height="120px"/>
â”‚ â”‚  
â”‚ â”‚  FElupe is a Python 3.7+ finite element analysis package focussing on the formulation and numerical solution of nonlinear problems in continuum mechanics of solid bodies. Its name is a combination of FE (finite element) and the german word *Lupe* (magnifying glass) as a synonym for getting an insight how a finite element analysis code looks like under the hood.
â”‚ â”‚  
â”‚ â”‚  # Installation
â”‚ â”‚  Install Python, fire up a terminal and run
â”‚ â”‚  
â”‚ â”‚  ```shell
â”‚ â”‚  pip install felupe[all]
â”‚ â”‚  ```
â”‚ â”‚  
â”‚ â”‚ -where `[all]` installs all optional dependencies. By default, FElupe only depends on `numpy` and `scipy`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`einsumt`, `h5py`, `meshio`, `numba`, `sparse` and `tensortrax`).
â”‚ â”‚ +where `[all]` installs all optional dependencies. By default, FElupe depends on `numpy`, `scipy` and `einsumt`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies (`h5py`, `meshio` and `tensortrax`).
â”‚ â”‚  
â”‚ â”‚  # Getting Started
â”‚ â”‚  A quarter model of a solid cube with hyperelastic material behaviour is subjected to a uniaxial elongation applied at a clamped end-face. This involves the creation of a mesh, a region as well as a displacement field (encapsulated in a field container). Furthermore, the boundary conditions are created by a template for a uniaxial loadcase. An isotropic pseudo-elastic Ogden-Roxburgh Mullins-softening model formulation in combination with an isotropic hyperelastic Neo-Hookean material formulation is applied on a nearly-incompressible solid body. A step generates the consecutive substep-movements of a given boundary condition. The step is further added to a list of steps of a job (here, a characteristic-curve job is used). During evaluation, each substep of each step is solved by an iterative Newton-Rhapson procedure. The solution is exported after each completed substep as a time-series XDMF file. For more details beside this high-level code snippet, please have a look at the [documentation](https://felupe.readthedocs.io/en/latest/?badge=latest).
â”‚ â”‚  
â”‚ â”‚  ```python
â”‚ â”‚  import felupe as fem
â”‚ â”‚ â”œâ”€â”€ encoding
â”‚ â”‚ â”‚ @@ -1 +1 @@
â”‚ â”‚ â”‚ -us-ascii
â”‚ â”‚ â”‚ +utf-8
â”‚ â”‚   --- felupe-6.4.0/src/felupe.egg-info/SOURCES.txt
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/src/felupe.egg-info/SOURCES.txt
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -60,14 +60,15 @@
â”‚ â”‚  src/felupe/mechanics/_solidbody_incompressible.py
â”‚ â”‚  src/felupe/mechanics/_solidbody_pressure.py
â”‚ â”‚  src/felupe/mechanics/_step.py
â”‚ â”‚  src/felupe/mesh/__init__.py
â”‚ â”‚  src/felupe/mesh/_base.py
â”‚ â”‚  src/felupe/mesh/_container.py
â”‚ â”‚  src/felupe/mesh/_convert.py
â”‚ â”‚ +src/felupe/mesh/_discrete_geometry.py
â”‚ â”‚  src/felupe/mesh/_geometry.py
â”‚ â”‚  src/felupe/mesh/_helpers.py
â”‚ â”‚  src/felupe/mesh/_mesh.py
â”‚ â”‚  src/felupe/mesh/_read.py
â”‚ â”‚  src/felupe/mesh/_tools.py
â”‚ â”‚  src/felupe/quadrature/__init__.py
â”‚ â”‚  src/felupe/quadrature/_base.py
â”‚ â”‚ @@ -77,15 +78,14 @@
â”‚ â”‚  src/felupe/region/__init__.py
â”‚ â”‚  src/felupe/region/_boundary.py
â”‚ â”‚  src/felupe/region/_region.py
â”‚ â”‚  src/felupe/region/_templates.py
â”‚ â”‚  src/felupe/solve/__init__.py
â”‚ â”‚  src/felupe/solve/_solve.py
â”‚ â”‚  src/felupe/tools/__init__.py
â”‚ â”‚ -src/felupe/tools/_check.py
â”‚ â”‚  src/felupe/tools/_newton.py
â”‚ â”‚  src/felupe/tools/_post.py
â”‚ â”‚  src/felupe/tools/_project.py
â”‚ â”‚  src/felupe/tools/_save.py
â”‚ â”‚  src/felupe/tools/_solve.py
â”‚ â”‚  tests/test_basis.py
â”‚ â”‚  tests/test_bilinearform.py
â”‚ â”‚   --- felupe-6.4.0/tests/test_basis.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_basis.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_bilinearform.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_bilinearform.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_composite.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_composite.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_constitution.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_constitution.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_dof.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_dof.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_element.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_element.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_field.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_field.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_form.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_form.py
â”‚ â”‚â”„ Files 23% similar despite different names
â”‚ â”‚ @@ -132,179 +132,165 @@
â”‚ â”‚  
â”‚ â”‚  def test_axi():
â”‚ â”‚  
â”‚ â”‚      r, u, P, A = pre_axi()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ +        L = fe.IntegralForm(P, u, r.dV)
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚ -            L = fe.IntegralForm(P, u, r.dV)
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚  
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚  
â”‚ â”‚ -            b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +        a = fe.IntegralForm(A, u, r.dV, u, grad_v=[True], grad_u=[True])
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚  
â”‚ â”‚ -            a = fe.IntegralForm(A, u, r.dV, u, grad_v=[True], grad_u=[True])
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚  
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ -
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_linearform():
â”‚ â”‚  
â”‚ â”‚      r, u, p, P, A = pre()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(P, u, r.dV, grad_v=[True])
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(p.extract(grad=False), p, r.dV, grad_v=[False])
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ +        L = fe.IntegralForm(P, u, r.dV, grad_v=[True])
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +
â”‚ â”‚ +        L = fe.IntegralForm(p.extract(grad=False), p, r.dV, grad_v=[False])
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_linearform_broadcast():
â”‚ â”‚  
â”‚ â”‚      r, u, p, P, A = pre_broadcast()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(P, u, r.dV, grad_v=[True])
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(p.extract(grad=False), p, r.dV, grad_v=[False])
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ +        L = fe.IntegralForm(P, u, r.dV, grad_v=[True])
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.ndof, 1)
â”‚ â”‚ +
â”‚ â”‚ +        L = fe.IntegralForm(p.extract(grad=False), p, r.dV, grad_v=[False])
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert b.shape == (r.mesh.npoints, 1)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_bilinearform():
â”‚ â”‚  
â”‚ â”‚      r, u, p, P, A = pre()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(A, u, r.dV, u)
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(P, u, r.dV, p, [True], [False])
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ +        a = fe.IntegralForm(A, u, r.dV, u)
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ +
â”‚ â”‚ +        a = fe.IntegralForm(P, u, r.dV, p, [True], [False])
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_bilinearform_broadcast():
â”‚ â”‚  
â”‚ â”‚      r, u, p, P, A = pre_broadcast()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(A, u, r.dV, u, [True], [True])
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(P, u, r.dV, p, [True], [False])
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ -
â”‚ â”‚ -            q = p.extract(grad=False)
â”‚ â”‚ -            f = fe.math.dya(q, q, mode=1)
â”‚ â”‚ -            a = fe.IntegralForm(f, p, r.dV, p, [False], [False])
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.npoints, r.mesh.npoints)
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            assert K.shape == (r.mesh.npoints, r.mesh.npoints)
â”‚ â”‚ +        a = fe.IntegralForm(A, u, r.dV, u, [True], [True])
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.ndof)
â”‚ â”‚ +
â”‚ â”‚ +        a = fe.IntegralForm(P, u, r.dV, p, [True], [False])
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.ndof, r.mesh.npoints)
â”‚ â”‚ +
â”‚ â”‚ +        q = p.extract(grad=False)
â”‚ â”‚ +        f = fe.math.dya(q, q, mode=1)
â”‚ â”‚ +        a = fe.IntegralForm(f, p, r.dV, p, [False], [False])
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.npoints, r.mesh.npoints)
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +        assert K.shape == (r.mesh.npoints, r.mesh.npoints)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_mixed():
â”‚ â”‚  
â”‚ â”‚      r, v, f, A = pre_mixed()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(A, v, r.dV, v)
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -
â”‚ â”‚ -            z = r.mesh.ndof + 2 * r.mesh.npoints
â”‚ â”‚ -            assert K.shape == (z, z)
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(f, v, r.dV)
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ +        a = fe.IntegralForm(A, v, r.dV, v)
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +
â”‚ â”‚ +        z = r.mesh.ndof + 2 * r.mesh.npoints
â”‚ â”‚ +        assert K.shape == (z, z)
â”‚ â”‚ +
â”‚ â”‚ +        L = fe.IntegralForm(f, v, r.dV)
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚  
â”‚ â”‚ -            assert b.shape == (z, 1)
â”‚ â”‚ +        assert b.shape == (z, 1)
â”‚ â”‚  
â”‚ â”‚      r, v, f, A = pre_axi_mixed()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚ -
â”‚ â”‚ -            a = fe.IntegralForm(A, v, r.dV, v)
â”‚ â”‚ -            y = a.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            K = a.assemble(y, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            K = a.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -
â”‚ â”‚ -            z = r.mesh.ndof + 2 * r.mesh.npoints
â”‚ â”‚ -            assert K.shape == (z, z)
â”‚ â”‚ -
â”‚ â”‚ -            L = fe.IntegralForm(f, v, r.dV)
â”‚ â”‚ -            x = L.integrate(parallel=parallel, jit=jit)
â”‚ â”‚ -            b = L.assemble(x, parallel=parallel, jit=jit).toarray()
â”‚ â”‚ -            b = L.assemble(parallel=parallel, jit=jit).toarray()
â”‚ â”‚ +        a = fe.IntegralForm(A, v, r.dV, v)
â”‚ â”‚ +        y = a.integrate(parallel=parallel)
â”‚ â”‚ +        K = a.assemble(y, parallel=parallel).toarray()
â”‚ â”‚ +        K = a.assemble(parallel=parallel).toarray()
â”‚ â”‚ +
â”‚ â”‚ +        z = r.mesh.ndof + 2 * r.mesh.npoints
â”‚ â”‚ +        assert K.shape == (z, z)
â”‚ â”‚ +
â”‚ â”‚ +        L = fe.IntegralForm(f, v, r.dV)
â”‚ â”‚ +        x = L.integrate(parallel=parallel)
â”‚ â”‚ +        b = L.assemble(x, parallel=parallel).toarray()
â”‚ â”‚ +        b = L.assemble(parallel=parallel).toarray()
â”‚ â”‚  
â”‚ â”‚ -            assert b.shape == (z, 1)
â”‚ â”‚ +        assert b.shape == (z, 1)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  if __name__ == "__main__":
â”‚ â”‚      test_linearform()
â”‚ â”‚      test_linearform_broadcast()
â”‚ â”‚      test_bilinearform()
â”‚ â”‚      test_bilinearform_broadcast()
â”‚ â”‚   --- felupe-6.4.0/tests/test_job.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_job.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_math.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_math.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_mechanics.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_mechanics.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -163,57 +163,56 @@
â”‚ â”‚  
â”‚ â”‚  def test_solidbody():
â”‚ â”‚  
â”‚ â”‚      umat, u = pre(dim=3)
â”‚ â”‚      b = fe.SolidBody(umat=umat, field=u, statevars=np.ones(5))
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -            kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +        kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚ -            r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ -            assert r1.shape == (81, 1)
â”‚ â”‚ +        r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ +        assert r1.shape == (81, 1)
â”‚ â”‚  
â”‚ â”‚ -            r1b = b.results.force
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r1b.toarray())
â”‚ â”‚ +        r1b = b.results.force
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r1b.toarray())
â”‚ â”‚  
â”‚ â”‚ -            r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ +        r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            assert K1.shape == (81, 81)
â”‚ â”‚ +        K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        assert K1.shape == (81, 81)
â”‚ â”‚  
â”‚ â”‚ -            K1b = b.results.stiffness
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K1b.toarray())
â”‚ â”‚ +        K1b = b.results.stiffness
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K1b.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ +        K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            P1 = b.results.stress
â”‚ â”‚ -            P2 = b.evaluate.gradient()
â”‚ â”‚ -            P2 = b.evaluate.gradient(u)
â”‚ â”‚ -            assert np.allclose(P1, P2)
â”‚ â”‚ +        P1 = b.results.stress
â”‚ â”‚ +        P2 = b.evaluate.gradient()
â”‚ â”‚ +        P2 = b.evaluate.gradient(u)
â”‚ â”‚ +        assert np.allclose(P1, P2)
â”‚ â”‚  
â”‚ â”‚ -            A1 = b.results.elasticity
â”‚ â”‚ -            A2 = b.evaluate.hessian()
â”‚ â”‚ -            A2 = b.evaluate.hessian(u)
â”‚ â”‚ -            assert np.allclose(A1, A2)
â”‚ â”‚ +        A1 = b.results.elasticity
â”‚ â”‚ +        A2 = b.evaluate.hessian()
â”‚ â”‚ +        A2 = b.evaluate.hessian(u)
â”‚ â”‚ +        assert np.allclose(A1, A2)
â”‚ â”‚  
â”‚ â”‚ -            F1 = b.results.kinematics
â”‚ â”‚ -            F2 = b._extract(u)
â”‚ â”‚ -            assert np.allclose(F1, F2)
â”‚ â”‚ +        F1 = b.results.kinematics
â”‚ â”‚ +        F2 = b._extract(u)
â”‚ â”‚ +        assert np.allclose(F1, F2)
â”‚ â”‚  
â”‚ â”‚ -            s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ -            s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ -            assert np.allclose(s1, s2)
â”‚ â”‚ +        s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ +        s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ +        assert np.allclose(s1, s2)
â”‚ â”‚  
â”‚ â”‚ -            t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ -            t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ -            assert np.allclose(t1, t2)
â”‚ â”‚ +        t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ +        t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ +        assert np.allclose(t1, t2)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_solidbody_incompressible():
â”‚ â”‚  
â”‚ â”‚      umat, u = pre(dim=3, bulk=None)
â”‚ â”‚      b = fe.SolidBodyNearlyIncompressible(
â”‚ â”‚          umat=umat, field=u, bulk=5000, statevars=np.ones(5)
â”‚ â”‚ @@ -221,217 +220,213 @@
â”‚ â”‚  
â”‚ â”‚      umat = fe.OgdenRoxburgh(fe.NeoHooke(mu=1), r=3, m=1, beta=0)
â”‚ â”‚      b = fe.SolidBodyNearlyIncompressible(
â”‚ â”‚          umat=umat, field=u, bulk=5000, state=fe.StateNearlyIncompressible(u)
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -            kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +        kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚ -            r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ -            assert r1.shape == (81, 1)
â”‚ â”‚ +        r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ +        assert r1.shape == (81, 1)
â”‚ â”‚  
â”‚ â”‚ -            r1b = b.results.force
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r1b.toarray())
â”‚ â”‚ +        r1b = b.results.force
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r1b.toarray())
â”‚ â”‚  
â”‚ â”‚ -            r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ +        r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            assert K1.shape == (81, 81)
â”‚ â”‚ +        K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        assert K1.shape == (81, 81)
â”‚ â”‚  
â”‚ â”‚ -            K1b = b.results.stiffness
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K1b.toarray())
â”‚ â”‚ +        K1b = b.results.stiffness
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K1b.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ +        K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            P1 = b.results.stress
â”‚ â”‚ -            P2 = b.evaluate.gradient()
â”‚ â”‚ -            P2 = b.evaluate.gradient(u)
â”‚ â”‚ -            assert np.allclose(P1, P2)
â”‚ â”‚ +        P1 = b.results.stress
â”‚ â”‚ +        P2 = b.evaluate.gradient()
â”‚ â”‚ +        P2 = b.evaluate.gradient(u)
â”‚ â”‚ +        assert np.allclose(P1, P2)
â”‚ â”‚  
â”‚ â”‚ -            A1 = b.results.elasticity
â”‚ â”‚ -            A2 = b.evaluate.hessian()
â”‚ â”‚ -            A2 = b.evaluate.hessian(u)
â”‚ â”‚ -            assert np.allclose(A1, A2)
â”‚ â”‚ +        A1 = b.results.elasticity
â”‚ â”‚ +        A2 = b.evaluate.hessian()
â”‚ â”‚ +        A2 = b.evaluate.hessian(u)
â”‚ â”‚ +        assert np.allclose(A1, A2)
â”‚ â”‚  
â”‚ â”‚ -            F1 = b.results.kinematics
â”‚ â”‚ -            F2 = b._extract(u)
â”‚ â”‚ -            assert np.allclose(F1, F2)
â”‚ â”‚ +        F1 = b.results.kinematics
â”‚ â”‚ +        F2 = b._extract(u)
â”‚ â”‚ +        assert np.allclose(F1, F2)
â”‚ â”‚  
â”‚ â”‚ -            s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ -            s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ -            assert np.allclose(s1, s2)
â”‚ â”‚ +        s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ +        s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ +        assert np.allclose(s1, s2)
â”‚ â”‚  
â”‚ â”‚ -            t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ -            t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ -            assert np.allclose(t1, t2)
â”‚ â”‚ +        t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ +        t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ +        assert np.allclose(t1, t2)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_solidbody_axi():
â”‚ â”‚  
â”‚ â”‚      umat, u = pre_axi(bulk=None)
â”‚ â”‚      b = fe.SolidBodyNearlyIncompressible(umat=umat, field=u, bulk=5000)
â”‚ â”‚      b = fe.SolidBodyNearlyIncompressible(
â”‚ â”‚          umat=umat, field=u, bulk=5000, state=fe.StateNearlyIncompressible(u)
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -            kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +        kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚ -            r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ -            assert r1.shape == (18, 1)
â”‚ â”‚ +        r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ +        assert r1.shape == (18, 1)
â”‚ â”‚  
â”‚ â”‚ -            r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ +        r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            assert K1.shape == (18, 18)
â”‚ â”‚ +        K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        assert K1.shape == (18, 18)
â”‚ â”‚  
â”‚ â”‚ -            K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ +        K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            P1 = b.results.stress
â”‚ â”‚ -            P2 = b.evaluate.gradient()
â”‚ â”‚ -            P2 = b.evaluate.gradient(u)
â”‚ â”‚ -            assert np.allclose(P1, P2)
â”‚ â”‚ +        P1 = b.results.stress
â”‚ â”‚ +        P2 = b.evaluate.gradient()
â”‚ â”‚ +        P2 = b.evaluate.gradient(u)
â”‚ â”‚ +        assert np.allclose(P1, P2)
â”‚ â”‚  
â”‚ â”‚ -            A1 = b.results.elasticity
â”‚ â”‚ -            A2 = b.evaluate.hessian()
â”‚ â”‚ -            A2 = b.evaluate.hessian(u)
â”‚ â”‚ -            assert np.allclose(A1, A2)
â”‚ â”‚ +        A1 = b.results.elasticity
â”‚ â”‚ +        A2 = b.evaluate.hessian()
â”‚ â”‚ +        A2 = b.evaluate.hessian(u)
â”‚ â”‚ +        assert np.allclose(A1, A2)
â”‚ â”‚  
â”‚ â”‚ -            F1 = b.results.kinematics
â”‚ â”‚ -            F2 = b._extract(u)
â”‚ â”‚ -            assert np.allclose(F1, F2)
â”‚ â”‚ +        F1 = b.results.kinematics
â”‚ â”‚ +        F2 = b._extract(u)
â”‚ â”‚ +        assert np.allclose(F1, F2)
â”‚ â”‚  
â”‚ â”‚ -            s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ -            s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ -            assert np.allclose(s1, s2)
â”‚ â”‚ +        s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ +        s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ +        assert np.allclose(s1, s2)
â”‚ â”‚  
â”‚ â”‚ -            t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ -            t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ -            assert np.allclose(t1, t2)
â”‚ â”‚ +        t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ +        t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ +        assert np.allclose(t1, t2)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_solidbody_axi_incompressible():
â”‚ â”‚  
â”‚ â”‚      umat, u = pre_axi()
â”‚ â”‚      b = fe.SolidBody(umat=umat, field=u)
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -            kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +        kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚ -            r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ -            assert r1.shape == (18, 1)
â”‚ â”‚ +        r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ +        assert r1.shape == (18, 1)
â”‚ â”‚  
â”‚ â”‚ -            r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ +        r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            assert K1.shape == (18, 18)
â”‚ â”‚ +        K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        assert K1.shape == (18, 18)
â”‚ â”‚  
â”‚ â”‚ -            K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ +        K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚  
â”‚ â”‚ -            P1 = b.results.stress
â”‚ â”‚ -            P2 = b.evaluate.gradient()
â”‚ â”‚ -            P2 = b.evaluate.gradient(u)
â”‚ â”‚ -            assert np.allclose(P1, P2)
â”‚ â”‚ +        P1 = b.results.stress
â”‚ â”‚ +        P2 = b.evaluate.gradient()
â”‚ â”‚ +        P2 = b.evaluate.gradient(u)
â”‚ â”‚ +        assert np.allclose(P1, P2)
â”‚ â”‚  
â”‚ â”‚ -            A1 = b.results.elasticity
â”‚ â”‚ -            A2 = b.evaluate.hessian()
â”‚ â”‚ -            A2 = b.evaluate.hessian(u)
â”‚ â”‚ -            assert np.allclose(A1, A2)
â”‚ â”‚ +        A1 = b.results.elasticity
â”‚ â”‚ +        A2 = b.evaluate.hessian()
â”‚ â”‚ +        A2 = b.evaluate.hessian(u)
â”‚ â”‚ +        assert np.allclose(A1, A2)
â”‚ â”‚  
â”‚ â”‚ -            F1 = b.results.kinematics
â”‚ â”‚ -            F2 = b._extract(u)
â”‚ â”‚ -            assert np.allclose(F1, F2)
â”‚ â”‚ +        F1 = b.results.kinematics
â”‚ â”‚ +        F2 = b._extract(u)
â”‚ â”‚ +        assert np.allclose(F1, F2)
â”‚ â”‚  
â”‚ â”‚ -            s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ -            s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ -            assert np.allclose(s1, s2)
â”‚ â”‚ +        s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ +        s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ +        assert np.allclose(s1, s2)
â”‚ â”‚  
â”‚ â”‚ -            t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ -            t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ -            assert np.allclose(t1, t2)
â”‚ â”‚ +        t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ +        t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ +        assert np.allclose(t1, t2)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_solidbody_mixed():
â”‚ â”‚  
â”‚ â”‚      umat, u = pre_mixed(dim=3)
â”‚ â”‚      b = fe.SolidBody(umat=umat, field=u)
â”‚ â”‚      g = fe.SolidBodyGravity(field=u, gravity=[9810, 0, 0], density=7.85e-9)
â”‚ â”‚  
â”‚ â”‚      g.assemble.vector()
â”‚ â”‚  
â”‚ â”‚      for parallel in [False, True]:
â”‚ â”‚ -        for jit in [False, True]:
â”‚ â”‚  
â”‚ â”‚ -            kwargs = {"parallel": parallel, "jit": jit}
â”‚ â”‚ +        kwargs = {"parallel": parallel}
â”‚ â”‚  
â”‚ â”‚ -            r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ -            r1 = b.assemble.vector(u, items=3, **kwargs)
â”‚ â”‚ -            assert r1.shape == (97, 1)
â”‚ â”‚ -
â”‚ â”‚ -            r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ -            assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ -
â”‚ â”‚ -            K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            K1 = b.assemble.matrix(u, items=6, **kwargs)
â”‚ â”‚ -            assert K1.shape == (97, 97)
â”‚ â”‚ -
â”‚ â”‚ -            K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ -
â”‚ â”‚ -            P1 = b.results.stress
â”‚ â”‚ -            P2 = b.evaluate.gradient()
â”‚ â”‚ -            P2 = b.evaluate.gradient(u)
â”‚ â”‚ -            for p1, p2 in zip(P1, P2):
â”‚ â”‚ -                assert np.allclose(p1, p2)
â”‚ â”‚ -
â”‚ â”‚ -            A1 = b.results.elasticity
â”‚ â”‚ -            A2 = b.evaluate.hessian()
â”‚ â”‚ -            A2 = b.evaluate.hessian(u)
â”‚ â”‚ -            for a1, a2 in zip(A1, A2):
â”‚ â”‚ -                assert np.allclose(a1, a2)
â”‚ â”‚ -
â”‚ â”‚ -            F1 = b.results.kinematics
â”‚ â”‚ -            F2 = b._extract(u)
â”‚ â”‚ -            for f1, f2 in zip(F1, F2):
â”‚ â”‚ -                assert np.allclose(f1, f2)
â”‚ â”‚ -
â”‚ â”‚ -            s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ -            s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ -            assert np.allclose(s1, s2)
â”‚ â”‚ -
â”‚ â”‚ -            t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ -            t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ -            assert np.allclose(t1, t2)
â”‚ â”‚ -
â”‚ â”‚ -            rg1 = g.assemble.vector(u, **kwargs)
â”‚ â”‚ -            assert rg1.shape == (97, 1)
â”‚ â”‚ -
â”‚ â”‚ -            Kg1 = g.assemble.matrix(u, **kwargs)
â”‚ â”‚ -            assert Kg1.shape == (97, 97)
â”‚ â”‚ -
â”‚ â”‚ -            rg2 = g.assemble.vector(**kwargs)
â”‚ â”‚ -            assert rg1.shape == (97, 1)
â”‚ â”‚ -            assert np.allclose(rg1.toarray(), rg2.toarray())
â”‚ â”‚ -
â”‚ â”‚ -            Kg2 = g.assemble.matrix(**kwargs)
â”‚ â”‚ -            assert Kg1.shape == (97, 97)
â”‚ â”‚ -            assert np.allclose(Kg1.toarray(), Kg2.toarray())
â”‚ â”‚ +        r1 = b.assemble.vector(u, **kwargs)
â”‚ â”‚ +        r1 = b.assemble.vector(u, items=3, **kwargs)
â”‚ â”‚ +        assert r1.shape == (97, 1)
â”‚ â”‚ +
â”‚ â”‚ +        r2 = b.assemble.vector(**kwargs)
â”‚ â”‚ +        assert np.allclose(r1.toarray(), r2.toarray())
â”‚ â”‚ +
â”‚ â”‚ +        K1 = b.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        K1 = b.assemble.matrix(u, items=6, **kwargs)
â”‚ â”‚ +        assert K1.shape == (97, 97)
â”‚ â”‚ +
â”‚ â”‚ +        K2 = b.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert np.allclose(K1.toarray(), K2.toarray())
â”‚ â”‚ +
â”‚ â”‚ +        P1 = b.results.stress
â”‚ â”‚ +        P2 = b.evaluate.gradient()
â”‚ â”‚ +        P2 = b.evaluate.gradient(u)
â”‚ â”‚ +        for p1, p2 in zip(P1, P2):
â”‚ â”‚ +            assert np.allclose(p1, p2)
â”‚ â”‚ +
â”‚ â”‚ +        A1 = b.results.elasticity
â”‚ â”‚ +        A2 = b.evaluate.hessian()
â”‚ â”‚ +        A2 = b.evaluate.hessian(u)
â”‚ â”‚ +        for a1, a2 in zip(A1, A2):
â”‚ â”‚ +            assert np.allclose(a1, a2)
â”‚ â”‚ +
â”‚ â”‚ +        F1 = b.results.kinematics
â”‚ â”‚ +        F2 = b._extract(u)
â”‚ â”‚ +        for f1, f2 in zip(F1, F2):
â”‚ â”‚ +            assert np.allclose(f1, f2)
â”‚ â”‚ +
â”‚ â”‚ +        s1 = b.evaluate.cauchy_stress()
â”‚ â”‚ +        s2 = b.evaluate.cauchy_stress(u)
â”‚ â”‚ +        assert np.allclose(s1, s2)
â”‚ â”‚ +
â”‚ â”‚ +        t1 = b.evaluate.kirchhoff_stress()
â”‚ â”‚ +        t2 = b.evaluate.kirchhoff_stress(u)
â”‚ â”‚ +        assert np.allclose(t1, t2)
â”‚ â”‚ +
â”‚ â”‚ +        rg1 = g.assemble.vector(u, **kwargs)
â”‚ â”‚ +        assert rg1.shape == (97, 1)
â”‚ â”‚ +
â”‚ â”‚ +        Kg1 = g.assemble.matrix(u, **kwargs)
â”‚ â”‚ +        assert Kg1.shape == (97, 97)
â”‚ â”‚ +
â”‚ â”‚ +        rg2 = g.assemble.vector(**kwargs)
â”‚ â”‚ +        assert rg1.shape == (97, 1)
â”‚ â”‚ +        assert np.allclose(rg1.toarray(), rg2.toarray())
â”‚ â”‚ +
â”‚ â”‚ +        Kg2 = g.assemble.matrix(**kwargs)
â”‚ â”‚ +        assert Kg1.shape == (97, 97)
â”‚ â”‚ +        assert np.allclose(Kg1.toarray(), Kg2.toarray())
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_load():
â”‚ â”‚  
â”‚ â”‚      for axi in [False, True]:
â”‚ â”‚  
â”‚ â”‚          if axi:
â”‚ â”‚   --- felupe-6.4.0/tests/test_mesh.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_mesh.py
â”‚ â”‚â”„ Files 4% similar despite different names
â”‚ â”‚ @@ -48,14 +48,15 @@
â”‚ â”‚  
â”‚ â”‚      assert n.cell_type == "my-fancy-cell-type"
â”‚ â”‚  
â”‚ â”‚      fe.mesh.convert(m, order=0)
â”‚ â”‚      fe.mesh.convert(m, order=0, calc_points=True)
â”‚ â”‚      fe.mesh.convert(m, order=2)
â”‚ â”‚      fe.mesh.convert(m, order=2, calc_midfaces=True)
â”‚ â”‚ +    m.convert(order=2)
â”‚ â”‚  
â”‚ â”‚      m = fe.Mesh(
â”‚ â”‚          points=np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]),
â”‚ â”‚          cells=np.array([[0, 1, 2, 3]]),
â”‚ â”‚          cell_type="tetra",
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚ @@ -65,14 +66,15 @@
â”‚ â”‚      fe.mesh.convert(m, order=2, calc_midfaces=True)
â”‚ â”‚  
â”‚ â”‚      m = fe.mesh.Line(n=5)
â”‚ â”‚      assert m.points.shape == (5, 1)
â”‚ â”‚      assert m.cells.shape == (4, 2)
â”‚ â”‚  
â”‚ â”‚      mr = fe.mesh.revolve(m, n=11, phi=180, axis=2)
â”‚ â”‚ +    mr = m.revolve(n=11, phi=180, axis=2)
â”‚ â”‚      assert mr.ncells == 4 * 10
â”‚ â”‚  
â”‚ â”‚      m = fe.Rectangle(a=(-1.2, -2), b=(2, 3.1), n=(4, 9))
â”‚ â”‚      assert m.points.shape == (4 * 9, 2)
â”‚ â”‚      assert m.cells.shape == (3 * 8, 4)
â”‚ â”‚  
â”‚ â”‚      fe.mesh.convert(m, order=0)
â”‚ â”‚ @@ -101,14 +103,15 @@
â”‚ â”‚          fe.mesh.revolve(m.points, m.cells, m.cell_type, n=11, phi=361, axis=0)
â”‚ â”‚  
â”‚ â”‚      fe.mesh.expand(m.points, m.cells, m.cell_type)
â”‚ â”‚      fe.mesh.expand(m.points, m.cells, cell_type=m.cell_type)
â”‚ â”‚      fe.mesh.expand(m.points, cells=m.cells, cell_type=m.cell_type)
â”‚ â”‚      fe.mesh.expand(points=m.points, cells=m.cells, cell_type=m.cell_type)
â”‚ â”‚      fe.mesh.expand(m)
â”‚ â”‚ +    m.expand()
â”‚ â”‚  
â”‚ â”‚      me1 = fe.mesh.expand(m, n=3, z=1)
â”‚ â”‚      me2 = fe.mesh.expand(m, n=3, z=1.0)
â”‚ â”‚      me3 = fe.mesh.expand(m, z=np.linspace(0, 1, 3))
â”‚ â”‚  
â”‚ â”‚      assert np.allclose(me1.points, me2.points)
â”‚ â”‚      assert np.allclose(me2.points, me3.points)
â”‚ â”‚ @@ -121,19 +124,23 @@
â”‚ â”‚  
â”‚ â”‚      with pytest.raises(KeyError):
â”‚ â”‚          fe.mesh.expand(m.points, m.cells, m.cell_type)
â”‚ â”‚  
â”‚ â”‚      with pytest.raises(KeyError):
â”‚ â”‚          fe.mesh.revolve(m.points, m.cells, m.cell_type)
â”‚ â”‚  
â”‚ â”‚ +    m.flip()
â”‚ â”‚ +    fe.mesh.flip(m, mask=[0, 1])
â”‚ â”‚ +
â”‚ â”‚      fe.mesh.convert(m, order=2, calc_midfaces=True, calc_midvolumes=True)
â”‚ â”‚  
â”‚ â”‚      fe.mesh.rotate(m, angle_deg=10, axis=0, center=None)
â”‚ â”‚      fe.mesh.rotate(m.points, m.cells, m.cell_type, angle_deg=10, axis=0, center=None)
â”‚ â”‚      fe.mesh.rotate(m, angle_deg=10, axis=1, center=[0, 0, 0])
â”‚ â”‚ +    m.rotate(angle_deg=10, axis=0, center=None)
â”‚ â”‚  
â”‚ â”‚      fe.mesh.CubeArbitraryOrderHexahedron()
â”‚ â”‚      fe.mesh.RectangleArbitraryOrderQuad()
â”‚ â”‚  
â”‚ â”‚      m = fe.Rectangle(n=5)
â”‚ â”‚      m.points = np.vstack((m.points, [10, 10]))
â”‚ â”‚      assert m.points.shape == (26, 2)
â”‚ â”‚ @@ -146,14 +153,15 @@
â”‚ â”‚      m_dg = m.disconnect(points_per_cell=2, calc_points=False)
â”‚ â”‚      assert np.allclose(m_dg.points, 0)
â”‚ â”‚      assert m_dg.npoints == m.ncells * 2
â”‚ â”‚      assert m_dg.cell_type is None
â”‚ â”‚  
â”‚ â”‚      fe.mesh.sweep(m)
â”‚ â”‚      fe.mesh.sweep(m.points, m.cells, m.cell_type, decimals=4)
â”‚ â”‚ +    m.sweep()
â”‚ â”‚  
â”‚ â”‚      m.as_meshio(point_data={"data": m.points}, cell_data={"cell_data": [m.cells[:, 0]]})
â”‚ â”‚      m.save()
â”‚ â”‚  
â”‚ â”‚      m.cell_type = None
â”‚ â”‚      with pytest.raises(Exception):
â”‚ â”‚          m.save()
â”‚ â”‚ @@ -172,14 +180,15 @@
â”‚ â”‚      ]:
â”‚ â”‚          axis = kwargs["axis"]
â”‚ â”‚  
â”‚ â”‚          if axis is None or axis < 1:
â”‚ â”‚              m = fe.mesh.Line()
â”‚ â”‚              r = fe.Region(m, fe.Line(), fe.GaussLegendre(1, 1))
â”‚ â”‚              n = fe.mesh.mirror(m, **kwargs)
â”‚ â”‚ +            n = m.mirror(**kwargs)
â”‚ â”‚              s = fe.Region(n, fe.Line(), fe.GaussLegendre(1, 1))
â”‚ â”‚              assert np.isclose(r.dV.sum(), s.dV.sum())
â”‚ â”‚  
â”‚ â”‚          if axis is None or axis < 2:
â”‚ â”‚              m = fe.Rectangle()
â”‚ â”‚              r = fe.RegionQuad(m)
â”‚ â”‚              n = fe.mesh.mirror(m, **kwargs)
â”‚ â”‚ @@ -218,14 +227,15 @@
â”‚ â”‚          s = fe.RegionTetra(n)
â”‚ â”‚          assert np.isclose(r.dV.sum(), s.dV.sum())
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_triangulate():
â”‚ â”‚      m = fe.Rectangle(n=3)
â”‚ â”‚      n = fe.mesh.triangulate(m)
â”‚ â”‚ +    n = m.triangulate()
â”‚ â”‚  
â”‚ â”‚      rm = fe.RegionQuad(m)
â”‚ â”‚      rn = fe.RegionTriangle(n)
â”‚ â”‚  
â”‚ â”‚      assert np.isclose(rm.dV.sum(), rn.dV.sum())
â”‚ â”‚  
â”‚ â”‚      for mode in [0, 3]:
â”‚ â”‚ @@ -240,14 +250,15 @@
â”‚ â”‚      with pytest.raises(NotImplementedError):
â”‚ â”‚          n = fe.mesh.triangulate(m, mode=-1)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_runouts():
â”‚ â”‚      m = fe.Rectangle(n=3)
â”‚ â”‚  
â”‚ â”‚ +    n = m.add_runouts(values=[0.0], axis=0, centerpoint=[0, 0])
â”‚ â”‚      n = fe.mesh.runouts(m, values=[0.0], axis=0, centerpoint=[0, 0])
â”‚ â”‚      assert n.points[:, 1].max() == m.points[:, 1].max()
â”‚ â”‚  
â”‚ â”‚      n = fe.mesh.runouts(m, values=[0.1], axis=0, centerpoint=[0, 0])
â”‚ â”‚      assert n.points[:, 1].max() == m.points[:, 1].max() * 1.1
â”‚ â”‚  
â”‚ â”‚      mask = np.zeros(m.npoints, dtype=bool)
â”‚ â”‚ @@ -330,17 +341,53 @@
â”‚ â”‚      mesh = fe.mesh.read(filename=filename, dim=None)[0]
â”‚ â”‚      assert mesh.dim == 3
â”‚ â”‚  
â”‚ â”‚      mesh = fe.mesh.read(filename=filename, cellblock=0)[0]
â”‚ â”‚      assert mesh.dim == 3
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ +def test_read_nocells(filename="tests/mesh_no-cells.bdf"):
â”‚ â”‚ +    mesh = fe.mesh.read(filename=filename, dim=2)
â”‚ â”‚ +    assert mesh[0].dim == 2
â”‚ â”‚ +    assert mesh[0].ncells == 0
â”‚ â”‚ +    assert mesh[0].cells.shape == (0, 0)
â”‚ â”‚ +
â”‚ â”‚ +    mesh = fe.mesh.read(filename=filename, dim=None)
â”‚ â”‚ +    assert mesh[0].dim == 3
â”‚ â”‚ +    assert mesh[0].ncells == 0
â”‚ â”‚ +    assert mesh[0].cells.shape == (0, 0)
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚ +def test_mesh_methods():
â”‚ â”‚ +    mesh = fe.Cube()
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.collect_edges()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.collect_faces()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.collect_volumes()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.add_midpoints_edges()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.add_midpoints_faces()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +    m = mesh.add_midpoints_volumes()
â”‚ â”‚ +    assert isinstance(m, fe.Mesh)
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚  if __name__ == "__main__":
â”‚ â”‚      test_meshes()
â”‚ â”‚      test_mirror()
â”‚ â”‚      test_triangulate()
â”‚ â”‚      test_runouts()
â”‚ â”‚      test_concatenate()
â”‚ â”‚      test_grid()
â”‚ â”‚      test_grid_1d()
â”‚ â”‚      test_container()
â”‚ â”‚      test_read(filename="mesh.bdf")
â”‚ â”‚ +    test_mesh_methods()
â”‚ â”‚ +    test_read_nocells(filename="mesh_no-cells.bdf")
â”‚ â”‚   --- felupe-6.4.0/tests/test_planestrain.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_planestrain.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_quadrature.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_quadrature.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_readme.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_readme.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_region.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_region.py
â”‚ â”‚â”„ Files 6% similar despite different names
â”‚ â”‚ @@ -39,18 +39,22 @@
â”‚ â”‚      r = fe.RegionQuadBoundary(mesh, ensure_3d=True)
â”‚ â”‚      r = fe.RegionConstantQuad(mesh)
â”‚ â”‚  
â”‚ â”‚      mesh2 = fe.mesh.convert(mesh, 2, True, False, False)
â”‚ â”‚      r = fe.RegionQuadraticQuad(mesh2)
â”‚ â”‚      f = fe.FieldsMixed(r)
â”‚ â”‚  
â”‚ â”‚ +    r = fe.RegionQuadraticQuadBoundary(mesh2, ensure_3d=True)
â”‚ â”‚ +
â”‚ â”‚      mesh3 = fe.mesh.convert(mesh, 2, True, True, False)
â”‚ â”‚      r = fe.RegionBiQuadraticQuad(mesh3)
â”‚ â”‚      f = fe.FieldsMixed(r)
â”‚ â”‚  
â”‚ â”‚ +    r = fe.RegionBiQuadraticQuadBoundary(mesh3)
â”‚ â”‚ +
â”‚ â”‚      mesh.cell_type = "some_fancy_cell_type"
â”‚ â”‚      with pytest.raises(NotImplementedError):
â”‚ â”‚          r = fe.RegionBoundary(mesh, fe.Quad(), fe.GaussLegendreBoundary(order=1, dim=2))
â”‚ â”‚  
â”‚ â”‚      mesh = fe.Cube()
â”‚ â”‚      r = fe.RegionHexahedron(mesh)
â”‚ â”‚      r = fe.RegionHexahedronBoundary(mesh)
â”‚ â”‚ @@ -64,18 +68,22 @@
â”‚ â”‚  
â”‚ â”‚      r = fe.RegionConstantHexahedron(mesh)
â”‚ â”‚  
â”‚ â”‚      mesh2 = fe.mesh.convert(mesh, 2, True, False, False)
â”‚ â”‚      r = fe.RegionQuadraticHexahedron(mesh2)
â”‚ â”‚      f = fe.FieldsMixed(r)
â”‚ â”‚  
â”‚ â”‚ +    r = fe.RegionQuadraticHexahedronBoundary(mesh2)
â”‚ â”‚ +
â”‚ â”‚      mesh3 = fe.mesh.convert(mesh, 2, True, True, True)
â”‚ â”‚      r = fe.RegionTriQuadraticHexahedron(mesh3)
â”‚ â”‚      f = fe.FieldsMixed(r)
â”‚ â”‚  
â”‚ â”‚ +    r = fe.RegionTriQuadraticHexahedronBoundary(mesh3)
â”‚ â”‚ +
â”‚ â”‚      triangle = fe.Triangle()
â”‚ â”‚      points = triangle.points
â”‚ â”‚      cells = np.arange(3).reshape(1, -1)
â”‚ â”‚      mesh = fe.Mesh(points, cells, "triangle")
â”‚ â”‚      r = fe.RegionTriangle(mesh)
â”‚ â”‚  
â”‚ â”‚      mesh2 = fe.mesh.convert(mesh, 2, True, False, False)
â”‚ â”‚   --- felupe-6.4.0/tests/test_solve.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_solve.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- felupe-6.4.0/tests/test_tools.py
â”‚ â”œâ”€â”€ +++ felupe-7.0.0/tests/test_tools.py
â”‚ â”‚â”„ Files 10% similar despite different names
â”‚ â”‚ @@ -40,15 +40,15 @@
â”‚ â”‚      J = fe.Field(r, values=1)
â”‚ â”‚  
â”‚ â”‚      f = fe.FieldContainer((u, p, J))
â”‚ â”‚  
â”‚ â”‚      return r, f, (u, p, J)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def test_solve_check():
â”‚ â”‚ +def test_solve():
â”‚ â”‚  
â”‚ â”‚      r, _, (u, p, J) = pre()
â”‚ â”‚      f = fe.FieldContainer([u])
â”‚ â”‚  
â”‚ â”‚      W = fe.constitution.NeoHooke(1, 3)
â”‚ â”‚  
â”‚ â”‚      F = f.extract()
â”‚ â”‚ @@ -63,17 +63,14 @@
â”‚ â”‚  
â”‚ â”‚      b = L.assemble().toarray()[:, 0]
â”‚ â”‚      A = a.assemble()
â”‚ â”‚  
â”‚ â”‚      dx = fe.tools.solve(A, b, f, dof0, dof1, f.offsets, ext0)
â”‚ â”‚      assert dx[0].shape == f[0].values.ravel().shape
â”‚ â”‚  
â”‚ â”‚ -    fe.tools.check(dx, f, b, dof1, dof0, verbose=0)
â”‚ â”‚ -    fe.tools.check(dx, f, b, dof1, dof0, verbose=1)
â”‚ â”‚ -
â”‚ â”‚      fe.tools.save(r, f)
â”‚ â”‚      fe.tools.save(r, f, r=b)
â”‚ â”‚      fe.tools.save(
â”‚ â”‚          r,
â”‚ â”‚          f,
â”‚ â”‚          r=b,
â”‚ â”‚          gradient=W.gradient(F),
â”‚ â”‚ @@ -94,15 +91,15 @@
â”‚ â”‚      cauchy = fe.tools.project(fe.math.tovoigt(s), region=r, average=False)
â”‚ â”‚      assert cauchy.shape == (r.mesh.cells.size, 6)
â”‚ â”‚  
â”‚ â”‚      cauchy = fe.tools.project(fe.math.tovoigt(s), region=r, mean=True)
â”‚ â”‚      assert cauchy.shape == (r.mesh.npoints, 6)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def test_solve_mixed_check():
â”‚ â”‚ +def test_solve_mixed():
â”‚ â”‚  
â”‚ â”‚      r, f, fields = pre()
â”‚ â”‚      u = fields[0]
â”‚ â”‚  
â”‚ â”‚      f = fe.FieldContainer(fields)
â”‚ â”‚  
â”‚ â”‚      F, p, J = f.extract()
â”‚ â”‚ @@ -125,17 +122,14 @@
â”‚ â”‚  
â”‚ â”‚      dx = fe.tools.solve(A, b, f, dof0, dof1, f.offsets, ext0)
â”‚ â”‚  
â”‚ â”‚      assert dx[0].shape == u.values.ravel().shape
â”‚ â”‚      assert dx[1].shape == fields[1].values.ravel().shape
â”‚ â”‚      assert dx[2].shape == fields[2].values.ravel().shape
â”‚ â”‚  
â”‚ â”‚ -    fe.tools.check(dx, f, b, dof1, dof0, verbose=0)
â”‚ â”‚ -    fe.tools.check(dx, f, b, dof1, dof0, verbose=1)
â”‚ â”‚ -
â”‚ â”‚      fe.tools.save(r, f)
â”‚ â”‚      fe.tools.save(r, f, r=b)
â”‚ â”‚      fe.tools.save(
â”‚ â”‚          r,
â”‚ â”‚          f,
â”‚ â”‚          r=b,
â”‚ â”‚          gradient=W_mixed.gradient([F, p, J]),
â”‚ â”‚ @@ -154,19 +148,15 @@
â”‚ â”‚  
â”‚ â”‚      def jac(x):
â”‚ â”‚          return np.array([2 * (x - 3)])
â”‚ â”‚  
â”‚ â”‚      x0 = np.array([3.1])
â”‚ â”‚  
â”‚ â”‚      res = fe.tools.newtonrhapson(
â”‚ â”‚ -        x0, fun, jac, solve=np.linalg.solve, maxiter=32, verbose=True, timing=False
â”‚ â”‚ -    )
â”‚ â”‚ -
â”‚ â”‚ -    res = fe.tools.newtonrhapson(
â”‚ â”‚ -        x0, fun, jac, solve=np.linalg.solve, maxiter=32, verbose=True, timing=True
â”‚ â”‚ +        x0, fun, jac, solve=np.linalg.solve, maxiter=32, verbose=True
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚      assert abs(res.fun) < 1e-6
â”‚ â”‚      assert np.isclose(res.x, 3, rtol=1e-2)
â”‚ â”‚  
â”‚ â”‚      with pytest.raises(ValueError):
â”‚ â”‚          res = fe.tools.newtonrhapson(
â”‚ â”‚ @@ -187,21 +177,19 @@
â”‚ â”‚      displacement = fe.Field(region, dim=3)
â”‚ â”‚      field = fe.FieldContainer([displacement])
â”‚ â”‚      boundaries, loadcase = fe.dof.uniaxial(field, move=0.2, clamped=True)
â”‚ â”‚  
â”‚ â”‚      # define the constitutive material behavior
â”‚ â”‚      umat = fe.NeoHooke(mu=1.0, bulk=2.0)
â”‚ â”‚  
â”‚ â”‚ -    for kwargs in [{"parallel": True}, {"jit": True}]:
â”‚ â”‚ +    for kwargs in [{"parallel": True, "umat": umat}]:
â”‚ â”‚  
â”‚ â”‚          # newton-rhapson procedure
â”‚ â”‚          res = fe.newtonrhapson(
â”‚ â”‚              field,
â”‚ â”‚ -            umat=umat,
â”‚ â”‚ -            timing=True,
â”‚ â”‚              verbose=True,
â”‚ â”‚              kwargs=kwargs,
â”‚ â”‚              **loadcase,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_newton_plane():
â”‚ â”‚ @@ -216,31 +204,27 @@
â”‚ â”‚  
â”‚ â”‚      # define the constitutive material behavior
â”‚ â”‚      umat = fe.LinearElasticPlaneStress(E=1.0, nu=0.3)
â”‚ â”‚  
â”‚ â”‚      # newton-rhapson procedure
â”‚ â”‚      res = fe.newtonrhapson(
â”‚ â”‚          field,
â”‚ â”‚ -        umat=umat,
â”‚ â”‚ -        timing=True,
â”‚ â”‚          verbose=True,
â”‚ â”‚ -        kwargs={},
â”‚ â”‚ +        kwargs=dict(umat=umat),
â”‚ â”‚          **loadcase,
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚      # define the constitutive material behavior
â”‚ â”‚      umat = fe.LinearElasticPlaneStrain(E=1.0, nu=0.3)
â”‚ â”‚  
â”‚ â”‚      # newton-rhapson procedure
â”‚ â”‚      res = fe.newtonrhapson(
â”‚ â”‚          field,
â”‚ â”‚ -        umat=umat,
â”‚ â”‚ -        timing=True,
â”‚ â”‚          verbose=True,
â”‚ â”‚ -        kwargs={},
â”‚ â”‚ +        kwargs=dict(umat=umat),
â”‚ â”‚          **loadcase,
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_newton_linearelastic():
â”‚ â”‚  
â”‚ â”‚      # create a hexahedron-region on a cube
â”‚ â”‚ @@ -253,18 +237,16 @@
â”‚ â”‚  
â”‚ â”‚      # define the constitutive material behavior
â”‚ â”‚      umat = fe.LinearElastic(E=1.0, nu=0.3)
â”‚ â”‚  
â”‚ â”‚      # newton-rhapson procedure
â”‚ â”‚      res = fe.newtonrhapson(
â”‚ â”‚          field,
â”‚ â”‚ -        umat=umat,
â”‚ â”‚ -        timing=True,
â”‚ â”‚          verbose=True,
â”‚ â”‚ -        kwargs={"grad": True, "sym": True, "add_identity": False},
â”‚ â”‚ +        kwargs={"umat": umat, "grad": True, "sym": True, "add_identity": False},
â”‚ â”‚          **loadcase,
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_newton_mixed():
â”‚ â”‚  
â”‚ â”‚      # create a hexahedron-region on a cube
â”‚ â”‚ @@ -286,15 +268,15 @@
â”‚ â”‚      F = field.extract(grad=True, sym=False, add_identity=True)
â”‚ â”‚  
â”‚ â”‚      # define the constitutive material behavior
â”‚ â”‚      nh = fe.NeoHooke(mu=1.0, bulk=2.0)
â”‚ â”‚      umat = fe.ThreeFieldVariation(nh)
â”‚ â”‚  
â”‚ â”‚      # newton-rhapson procedure
â”‚ â”‚ -    res = fe.newtonrhapson(x0=field, umat=umat, kwargs={}, **loadcase)
â”‚ â”‚ +    res = fe.newtonrhapson(x0=field, kwargs=dict(umat=umat), **loadcase)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def test_newton_body():
â”‚ â”‚  
â”‚ â”‚      # create a hexahedron-region on a cube
â”‚ â”‚      mesh = fe.Cube(n=6)
â”‚ â”‚      region = fe.RegionHexahedron(mesh)
â”‚ â”‚ @@ -323,15 +305,15 @@
â”‚ â”‚          items=[body, bodyp],
â”‚ â”‚          kwargs={},
â”‚ â”‚          **loadcase,
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  if __name__ == "__main__":
â”‚ â”‚ -    test_solve_check()
â”‚ â”‚ -    test_solve_mixed_check()
â”‚ â”‚ +    test_solve()
â”‚ â”‚ +    test_solve_mixed()
â”‚ â”‚      test_newton_simple()
â”‚ â”‚      test_newton()
â”‚ â”‚      test_newton_mixed()
â”‚ â”‚      test_newton_plane()
â”‚ â”‚      test_newton_linearelastic()
â”‚ â”‚      test_newton_body()
