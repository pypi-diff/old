--- tmp/flytekit-1.5.0b0.tar.gz
+++ tmp/flytekit-1.5.0b1.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "flytekit-1.5.0b0.tar", last modified: Tue Mar 21 00:09:40 2023, max compression
│ +gzip compressed data, was "flytekit-1.5.0b1.tar", last modified: Wed Mar 29 18:58:29 2023, max compression
│   --- flytekit-1.5.0b0.tar
├── +++ flytekit-1.5.0b1.tar
│ ├── file list
│ │ @@ -1,236 +1,239 @@
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    11341 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/LICENSE
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/MANIFEST.in
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4266 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3367 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/README.md
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.232287 flytekit-1.5.0b0/flytekit/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7713 2023-03-21 00:09:39.000000 flytekit-1.5.0b0/flytekit/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.232287 flytekit-1.5.0b0/flytekit/bin/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/bin/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    23060 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/bin/entrypoint.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.232287 flytekit-1.5.0b0/flytekit/clients/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      335 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.232287 flytekit-1.5.0b0/flytekit/clients/auth/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    13377 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/auth_client.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8481 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/authenticator.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      411 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/default_html.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      277 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/exceptions.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2015 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth/keyring.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7596 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/auth_helper.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    50555 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/friendly.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.236287 flytekit-1.5.0b0/flytekit/clients/grpc_utils/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/grpc_utils/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3045 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/grpc_utils/auth_interceptor.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/grpc_utils/wrap_exception_interceptor.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2868 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/helpers.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    28007 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clients/raw.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.236287 flytekit-1.5.0b0/flytekit/clis/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.236287 flytekit-1.5.0b0/flytekit/clis/flyte_cli/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/flyte_cli/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      336 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/flyte_cli/example.config
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    81942 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/flyte_cli/main.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5900 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/helpers.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.236287 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5247 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/backfill.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      774 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/constants.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/helpers.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1316 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/init.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      381 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/local_cache.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4330 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/package.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4669 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/pyflyte.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5916 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/register.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    26375 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/run.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7550 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/clis/sdk_in_container/serialize.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.236287 flytekit-1.5.0b0/flytekit/configuration/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    35134 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/configuration/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1281 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/configuration/default_images.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      536 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/configuration/feature_flags.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    10571 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/configuration/file.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7253 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/configuration/internal.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/core/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      793 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/annotation.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2946 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/base_sql_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    30288 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/base_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5580 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/checkpointer.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1631 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/class_based_resolver.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    21259 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/condition.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1424 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/constants.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5039 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/container_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    35576 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/context_manager.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    12823 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/data_persistence.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      914 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/docstring.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2539 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/dynamic_workflow_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8257 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/gate.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      504 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/hash.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    19383 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    20508 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/launch_plan.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2806 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/local_cache.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    12813 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/map_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2052 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/mock_stats.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6344 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/node.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8156 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/node_creation.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5173 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/notification.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      705 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/pod_template.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    44698 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/promise.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    16306 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/python_auto_container.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    12399 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/python_customized_container_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    14498 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/python_function_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2260 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/reference.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    10836 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/reference_entity.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2979 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/resources.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8401 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/schedule.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8445 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/shim_task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    13627 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2496 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/testing.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      435 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/tracked_abc.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     9689 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/tracker.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    72988 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/type_engine.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      724 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/type_helpers.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7936 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/utils.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    37299 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/core/workflow.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/deck/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      256 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/deck/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4532 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/deck/deck.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/deck/html/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/deck/html/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3749 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/deck/html/template.html
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/deck/renderer.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/exceptions/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/exceptions/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      328 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/exceptions/base.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8741 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/exceptions/scopes.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1579 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/exceptions/system.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3028 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/exceptions/user.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extend/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1446 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extend/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extras/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1695 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/cloud_pickle_resolver.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extras/pytorch/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      895 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/pytorch/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5156 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/pytorch/checkpoint.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3619 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/pytorch/native.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extras/sklearn/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      660 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/sklearn/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2792 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/sklearn/native.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extras/sqlite3/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      228 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/sqlite3/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5217 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/sqlite3/task.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.240287 flytekit-1.5.0b0/flytekit/extras/tasks/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      225 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/tasks/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    15166 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/tasks/shell.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/extras/tensorflow/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      981 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/tensorflow/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7665 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/extras/tensorflow/record.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/interaction/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interaction/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1595 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interaction/parse_stdin.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/interfaces/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6441 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/cli_identifiers.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1118 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/random.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/interfaces/stats/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      208 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/stats/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5068 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/stats/client.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3062 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/interfaces/stats/taggable.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2683 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/loggers.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/models/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.244287 flytekit-1.5.0b0/flytekit/models/admin/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/admin/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2054 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/admin/common.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5597 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/admin/task_execution.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4307 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/admin/workflow.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1371 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/annotation.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3843 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/array_job.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    13514 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/common.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/models/core/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2561 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/catalog.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6056 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/compiler.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6918 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/condition.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2512 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/errors.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7152 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/execution.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7549 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/identifier.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2058 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/types.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    32176 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/core/workflow.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3293 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/documentation.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3938 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/dynamic_job.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    25252 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/execution.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3890 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/filters.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7179 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    14502 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/launch_plan.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    28383 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/literals.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    11777 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/matchable_resource.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2749 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/named_entity.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    10667 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/node_execution.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2009 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/presto.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/project.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4558 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/qubole.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5149 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/schedule.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6531 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/security.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    32222 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/task.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    15680 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/types.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1581 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/models/workflow_closure.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/remote/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2328 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3905 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/backfill.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    30445 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/entities.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     7896 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/executions.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      340 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/interface.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     2169 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/lazy_entity.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    82965 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/remote.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3648 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/remote/remote_callable.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/testing/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      572 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/testing/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/tools/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4576 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/fast_registration.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4355 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/ignore.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1492 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/module_loader.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    10719 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/repo.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4635 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/script_mode.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5956 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/serialize_helpers.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/subprocess.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    32130 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/tools/translator.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/__init__.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/directory/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1219 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/directory/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    19282 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/directory/types.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/file/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4699 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/file/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    23604 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/file/file.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/numpy/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)       43 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/numpy/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3585 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/numpy/ndarray.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/pickle/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      220 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/pickle/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3703 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/pickle/pickle.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/schema/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      266 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/schema/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    18287 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/schema/types.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5424 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/schema/types_pandas.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit/types/structured/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1097 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/structured/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     5923 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/structured/basic_dfs.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4251 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/structured/bigquery.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    44333 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit/types/structured/structured_dataset.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.232287 flytekit-1.5.0b0/flytekit.egg-info/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     4266 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     6176 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      319 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/entry_points.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      838 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/requires.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        9 2023-03-21 00:09:40.000000 flytekit-1.5.0b0/flytekit.egg-info/top_level.txt
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-21 00:09:40.248287 flytekit-1.5.0b0/flytekit_scripts/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      138 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit_scripts/Readme.rst
│ │ --rwxr-xr-x   0 runner    (1001) docker     (123)     3006 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit_scripts/flytekit_build_image.sh
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      221 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/flytekit_scripts/flytekit_venv
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      379 2023-03-21 00:09:29.000000 flytekit-1.5.0b0/pyproject.toml
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      416 2023-03-21 00:09:40.252287 flytekit-1.5.0b0/setup.cfg
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     3623 2023-03-21 00:09:39.000000 flytekit-1.5.0b0/setup.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    11341 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/LICENSE
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/MANIFEST.in
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4266 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3367 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/README.md
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.956222 flytekit-1.5.0b1/flytekit/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7713 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.956222 flytekit-1.5.0b1/flytekit/bin/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/bin/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    22767 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/bin/entrypoint.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clients/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      335 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clients/auth/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    13495 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/auth_client.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     9094 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/authenticator.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      411 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/default_html.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      420 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/exceptions.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2059 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/keyring.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5204 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth/token_client.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7893 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/auth_helper.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    50555 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/friendly.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clients/grpc_utils/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/grpc_utils/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3045 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/grpc_utils/auth_interceptor.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/grpc_utils/wrap_exception_interceptor.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2868 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/helpers.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    28007 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clients/raw.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clis/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clis/flyte_cli/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/flyte_cli/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      336 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/flyte_cli/example.config
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    81942 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/flyte_cli/main.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5900 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/helpers.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5247 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/backfill.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      774 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/constants.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/helpers.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1316 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/init.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      381 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/local_cache.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4330 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/package.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4669 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/pyflyte.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5916 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/register.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    26375 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/run.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7550 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/serialize.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/clis/sdk_in_container/utils.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.960222 flytekit-1.5.0b1/flytekit/configuration/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    35294 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/configuration/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1385 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/configuration/default_images.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      536 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/configuration/feature_flags.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    10571 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/configuration/file.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7253 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/configuration/internal.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/core/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      793 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/annotation.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2946 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/base_sql_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    30288 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/base_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5580 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/checkpointer.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1631 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/class_based_resolver.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    21259 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/condition.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1424 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/constants.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6561 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/container_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    35576 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/context_manager.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    12823 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/data_persistence.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      914 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/docstring.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2539 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/dynamic_workflow_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8257 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/gate.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      504 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/hash.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    20645 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    20508 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/launch_plan.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2806 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/local_cache.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    17148 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/map_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2052 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/mock_stats.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6344 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/node.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8156 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/node_creation.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5173 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/notification.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/pod_template.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    44698 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/promise.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    13548 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/python_auto_container.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    12399 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/python_customized_container_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    14498 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/python_function_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2260 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/reference.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    10836 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/reference_entity.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2979 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/resources.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8401 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/schedule.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8445 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/shim_task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    13627 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2496 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/testing.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      435 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/tracked_abc.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     9689 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/tracker.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    72988 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/type_engine.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      724 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/type_helpers.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    10581 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/utils.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    37299 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/core/workflow.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/deck/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      256 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/deck/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4532 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/deck/deck.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/deck/html/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/deck/html/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3749 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/deck/html/template.html
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/deck/renderer.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/exceptions/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/exceptions/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      328 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/exceptions/base.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     8741 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/exceptions/scopes.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1579 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/exceptions/system.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3028 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/exceptions/user.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extend/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1446 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extend/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extras/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1695 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/cloud_pickle_resolver.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extras/pytorch/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      895 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/pytorch/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5156 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/pytorch/checkpoint.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3619 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/pytorch/native.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extras/sklearn/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      660 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/sklearn/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2792 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/sklearn/native.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extras/sqlite3/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      228 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/sqlite3/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5217 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/sqlite3/task.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.964222 flytekit-1.5.0b1/flytekit/extras/tasks/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      225 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/tasks/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    15166 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/tasks/shell.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/extras/tensorflow/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1058 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/tensorflow/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2763 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/tensorflow/model.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7664 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/extras/tensorflow/record.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/interaction/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interaction/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1595 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interaction/parse_stdin.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/interfaces/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6441 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/cli_identifiers.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1118 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/random.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/interfaces/stats/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      208 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/stats/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5068 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/stats/client.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3062 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/interfaces/stats/taggable.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2683 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/loggers.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/models/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/models/admin/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/admin/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2054 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/admin/common.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5597 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/admin/task_execution.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4307 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/admin/workflow.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1371 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/annotation.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3843 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/array_job.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    13514 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/common.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.968222 flytekit-1.5.0b1/flytekit/models/core/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2561 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/catalog.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6056 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/compiler.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6918 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/condition.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2512 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/errors.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7152 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/execution.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7549 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/identifier.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2058 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/types.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    32176 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/core/workflow.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3293 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/documentation.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3938 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/dynamic_job.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    25252 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/execution.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3890 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/filters.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7179 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    14502 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/launch_plan.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    28383 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/literals.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    11777 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/matchable_resource.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2749 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/named_entity.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    10667 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/node_execution.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2009 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/presto.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/project.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4558 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/qubole.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5149 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/schedule.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6531 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/security.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    32711 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/task.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    15680 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/types.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1581 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/models/workflow_closure.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/remote/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2328 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3905 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/backfill.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    30445 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/entities.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     7896 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/executions.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      340 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/interface.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     2169 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/lazy_entity.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    82798 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/remote.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3648 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/remote/remote_callable.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/testing/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      572 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/testing/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/tools/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4576 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/fast_registration.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4355 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/ignore.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1492 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/module_loader.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    10719 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/repo.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5638 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/script_mode.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5956 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/serialize_helpers.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/subprocess.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    32227 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/tools/translator.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/__init__.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/directory/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1219 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/directory/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    19282 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/directory/types.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/file/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4699 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/file/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    23852 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/file/file.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/numpy/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       43 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/numpy/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3585 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/numpy/ndarray.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/pickle/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      220 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/pickle/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3703 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/pickle/pickle.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/schema/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      266 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/schema/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    18377 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/schema/types.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5424 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/schema/types_pandas.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit/types/structured/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1097 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/structured/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     5923 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/structured/basic_dfs.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4251 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/structured/bigquery.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    44333 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit/types/structured/structured_dataset.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.956222 flytekit-1.5.0b1/flytekit.egg-info/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     4266 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     6290 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      319 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/entry_points.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      832 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/requires.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        9 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/flytekit.egg-info/top_level.txt
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/flytekit_scripts/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      138 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit_scripts/Readme.rst
│ │ +-rwxr-xr-x   0 runner    (1001) docker     (123)     3006 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit_scripts/flytekit_build_image.sh
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      221 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/flytekit_scripts/flytekit_venv
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      379 2023-03-29 18:58:20.000000 flytekit-1.5.0b1/pyproject.toml
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      416 2023-03-29 18:58:29.972222 flytekit-1.5.0b1/setup.cfg
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     3470 2023-03-29 18:58:29.000000 flytekit-1.5.0b1/setup.py
│ │   --- flytekit-1.5.0b0/LICENSE
│ ├── +++ flytekit-1.5.0b1/LICENSE
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/MANIFEST.in
│ ├── +++ flytekit-1.5.0b1/MANIFEST.in
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/PKG-INFO
│ ├── +++ flytekit-1.5.0b1/PKG-INFO
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: flytekit
│ │ -Version: 1.5.0b0
│ │ +Version: 1.5.0b1
│ │  Summary: Flyte SDK for Python
│ │  Home-page: https://github.com/flyteorg/flytekit
│ │  Maintainer: Flyte Contributors
│ │  Maintainer-email: admin@flyte.org
│ │  License: apache2
│ │  Classifier: Intended Audience :: Science/Research
│ │  Classifier: Intended Audience :: Developers
│ │ @@ -13,15 +13,15 @@
│ │  Classifier: Programming Language :: Python :: 3.9
│ │  Classifier: Programming Language :: Python :: 3.10
│ │  Classifier: Topic :: Scientific/Engineering
│ │  Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
│ │  Classifier: Topic :: Software Development
│ │  Classifier: Topic :: Software Development :: Libraries
│ │  Classifier: Topic :: Software Development :: Libraries :: Python Modules
│ │ -Requires-Python: >=3.8,<3.11
│ │ +Requires-Python: >=3.8,<3.12
│ │  Description-Content-Type: text/markdown
│ │  License-File: LICENSE
│ │  
│ │  <p align="center">
│ │      <img src="https://raw.githubusercontent.com/flyteorg/static-resources/main/common/flyte_circle_gradient_1_4x4.png" alt="Flyte Logo" width="100">
│ │  </p>
│ │  <h1 align="center">
│ │ ├── html2text {}
│ │ │ @@ -1,19 +1,19 @@
│ │ │ -Metadata-Version: 2.1 Name: flytekit Version: 1.5.0b0 Summary: Flyte SDK for
│ │ │ +Metadata-Version: 2.1 Name: flytekit Version: 1.5.0b1 Summary: Flyte SDK for
│ │ │  Python Home-page: https://github.com/flyteorg/flytekit Maintainer: Flyte
│ │ │  Contributors Maintainer-email: admin@flyte.org License: apache2 Classifier:
│ │ │  Intended Audience :: Science/Research Classifier: Intended Audience ::
│ │ │  Developers Classifier: License :: OSI Approved :: Apache Software License
│ │ │  Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
│ │ │  Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
│ │ │  Classifier: Topic :: Scientific/Engineering Classifier: Topic :: Scientific/
│ │ │  Engineering :: Artificial Intelligence Classifier: Topic :: Software
│ │ │  Development Classifier: Topic :: Software Development :: Libraries Classifier:
│ │ │  Topic :: Software Development :: Libraries :: Python Modules Requires-Python:
│ │ │ ->=3.8,<3.11 Description-Content-Type: text/markdown License-File: LICENSE
│ │ │ +>=3.8,<3.12 Description-Content-Type: text/markdown License-File: LICENSE
│ │ │                                   [Flyte Logo]
│ │ │                           ****** Flytekit Python ******
│ │ │              Flytekit Python is the Python SDK built on top of Flyte
│ │ │                     **** Plugins  Â·  Contribution_Guide ****
│ │ │  [![PyPI version fury.io](https://badge.fury.io/py/flytekit.svg)](https://
│ │ │  pypi.python.org/pypi/flytekit/) [![PyPI download day](https://img.shields.io/
│ │ │  pypi/dd/flytekit.svg)](https://pypi.python.org/pypi/flytekit/) [![PyPI download
│ │   --- flytekit-1.5.0b0/README.md
│ ├── +++ flytekit-1.5.0b1/README.md
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/__init__.py
│ │┄ Files 0% similar despite different names
│ │ @@ -233,15 +233,15 @@
│ │  from flytekit.types.structured.structured_dataset import (
│ │      StructuredDataset,
│ │      StructuredDatasetFormat,
│ │      StructuredDatasetTransformerEngine,
│ │      StructuredDatasetType,
│ │  )
│ │  
│ │ -__version__ = "1.5.0b0"
│ │ +__version__ = "1.5.0b1"
│ │  
│ │  
│ │  def current_context() -> ExecutionParameters:
│ │      """
│ │      Use this method to get a handle of specific parameters available in a flyte task.
│ │  
│ │      Usage
│ │   --- flytekit-1.5.0b0/flytekit/bin/entrypoint.py
│ ├── +++ flytekit-1.5.0b1/flytekit/bin/entrypoint.py
│ │┄ Files 4% similar despite different names
│ │ @@ -6,28 +6,27 @@
│ │  import tempfile
│ │  import traceback as _traceback
│ │  from typing import List, Optional
│ │  
│ │  import click as _click
│ │  from flyteidl.core import literals_pb2 as _literals_pb2
│ │  
│ │ -from flytekit import PythonFunctionTask
│ │  from flytekit.configuration import (
│ │      SERIALIZED_CONTEXT_ENV_VAR,
│ │      FastSerializationSettings,
│ │      SerializationSettings,
│ │      StatsConfig,
│ │  )
│ │  from flytekit.core import constants as _constants
│ │  from flytekit.core import utils
│ │  from flytekit.core.base_task import IgnoreOutputs, PythonTask
│ │  from flytekit.core.checkpointer import SyncCheckpoint
│ │  from flytekit.core.context_manager import ExecutionParameters, ExecutionState, FlyteContext, FlyteContextManager
│ │  from flytekit.core.data_persistence import FileAccessProvider
│ │ -from flytekit.core.map_task import MapPythonTask
│ │ +from flytekit.core.map_task import MapTaskResolver
│ │  from flytekit.core.promise import VoidPromise
│ │  from flytekit.exceptions import scopes as _scoped_exceptions
│ │  from flytekit.exceptions import scopes as _scopes
│ │  from flytekit.interfaces.stats.taggable import get_stats as _get_stats
│ │  from flytekit.loggers import entrypoint_logger as logger
│ │  from flytekit.loggers import user_space_logger
│ │  from flytekit.models import dynamic_job as _dynamic_job
│ │ @@ -387,20 +386,16 @@
│ │      """
│ │      if len(resolver_args) < 1:
│ │          raise Exception(f"Resolver args cannot be <1, got {resolver_args}")
│ │  
│ │      with setup_execution(
│ │          raw_output_data_prefix, checkpoint_path, prev_checkpoint, dynamic_addl_distro, dynamic_dest_dir
│ │      ) as ctx:
│ │ -        resolver_obj = load_object_from_module(resolver)
│ │ -        # Use the resolver to load the actual task object
│ │ -        _task_def = resolver_obj.load_task(loader_args=resolver_args)
│ │ -        if not isinstance(_task_def, PythonFunctionTask):
│ │ -            raise Exception("Map tasks cannot be run with instance tasks.")
│ │ -        map_task = MapPythonTask(_task_def, max_concurrency)
│ │ +        mtr = MapTaskResolver()
│ │ +        map_task = mtr.load_task(loader_args=resolver_args, max_concurrency=max_concurrency)
│ │  
│ │          task_index = _compute_array_job_index()
│ │          output_prefix = os.path.join(output_prefix, str(task_index))
│ │  
│ │          if test:
│ │              logger.info(
│ │                  f"Test detected, returning. Inputs: {inputs} Computed task index: {task_index} "
│ │   --- flytekit-1.5.0b0/flytekit/clients/auth/auth_client.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/auth/auth_client.py
│ │┄ Files 2% similar despite different names
│ │ @@ -265,17 +265,19 @@
│ │          """
│ │          response_body = auth_token_resp.json()
│ │          refresh_token = None
│ │          if "access_token" not in response_body:
│ │              raise ValueError('Expected "access_token" in response from oauth server')
│ │          if "refresh_token" in response_body:
│ │              refresh_token = response_body["refresh_token"]
│ │ +        if "expires_in" in response_body:
│ │ +            expires_in = response_body["expires_in"]
│ │          access_token = response_body["access_token"]
│ │  
│ │ -        return Credentials(access_token, refresh_token, self._endpoint)
│ │ +        return Credentials(access_token, refresh_token, self._endpoint, expires_in=expires_in)
│ │  
│ │      def _request_access_token(self, auth_code) -> Credentials:
│ │          if self._state != auth_code.state:
│ │              raise ValueError(f"Unexpected state parameter [{auth_code.state}] passed")
│ │          self._params.update(
│ │              {
│ │                  "code": auth_code.code,
│ │   --- flytekit-1.5.0b0/flytekit/clients/auth/authenticator.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/auth/authenticator.py
│ │┄ Files 14% similar despite different names
│ │ @@ -1,16 +1,14 @@
│ │ -import base64
│ │  import logging
│ │  import subprocess
│ │  import typing
│ │  from abc import abstractmethod
│ │  from dataclasses import dataclass
│ │  
│ │ -import requests
│ │ -
│ │ +from . import token_client
│ │  from .auth_client import AuthorizationClient
│ │  from .exceptions import AccessTokenNotFoundError, AuthenticationError
│ │  from .keyring import Credentials, KeyringStore
│ │  
│ │  
│ │  @dataclass
│ │  class ClientConfig:
│ │ @@ -18,14 +16,15 @@
│ │      Client Configuration that is needed by the authenticator
│ │      """
│ │  
│ │      token_endpoint: str
│ │      authorization_endpoint: str
│ │      redirect_uri: str
│ │      client_id: str
│ │ +    device_authorization_endpoint: typing.Optional[str] = None
│ │      scopes: typing.List[str] = None
│ │      header_key: str = "authorization"
│ │  
│ │  
│ │  class ClientConfigStore(object):
│ │      """
│ │      Client Config store retrieve client config. this can be done in multiple ways
│ │ @@ -151,85 +150,92 @@
│ │  
│ │  
│ │  class ClientCredentialsAuthenticator(Authenticator):
│ │      """
│ │      This Authenticator uses ClientId and ClientSecret to authenticate
│ │      """
│ │  
│ │ -    _utf_8 = "utf-8"
│ │ -
│ │      def __init__(
│ │          self,
│ │          endpoint: str,
│ │          client_id: str,
│ │          client_secret: str,
│ │          cfg_store: ClientConfigStore,
│ │ -        header_key: str = None,
│ │ +        header_key: typing.Optional[str] = None,
│ │ +        scopes: typing.Optional[typing.List[str]] = None,
│ │      ):
│ │          if not client_id or not client_secret:
│ │              raise ValueError("Client ID and Client SECRET both are required.")
│ │          cfg = cfg_store.get_client_config()
│ │          self._token_endpoint = cfg.token_endpoint
│ │ -        self._scopes = cfg.scopes
│ │ +        # Use scopes from `flytekit.configuration.PlatformConfig` if passed
│ │ +        self._scopes = scopes or cfg.scopes
│ │          self._client_id = client_id
│ │          self._client_secret = client_secret
│ │          super().__init__(endpoint, cfg.header_key or header_key)
│ │  
│ │ -    @staticmethod
│ │ -    def get_token(token_endpoint: str, authorization_header: str, scopes: typing.List[str]) -> typing.Tuple[str, int]:
│ │ -        """
│ │ -        :rtype: (Text,Int) The first element is the access token retrieved from the IDP, the second is the expiration
│ │ -                in seconds
│ │ -        """
│ │ -        headers = {
│ │ -            "Authorization": authorization_header,
│ │ -            "Cache-Control": "no-cache",
│ │ -            "Accept": "application/json",
│ │ -            "Content-Type": "application/x-www-form-urlencoded",
│ │ -        }
│ │ -        body = {
│ │ -            "grant_type": "client_credentials",
│ │ -        }
│ │ -        if scopes is not None:
│ │ -            body["scope"] = ",".join(scopes)
│ │ -        response = requests.post(token_endpoint, data=body, headers=headers)
│ │ -        if response.status_code != 200:
│ │ -            logging.error("Non-200 ({}) received from IDP: {}".format(response.status_code, response.text))
│ │ -            raise AuthenticationError("Non-200 received from IDP")
│ │ -
│ │ -        response = response.json()
│ │ -        return response["access_token"], response["expires_in"]
│ │ -
│ │ -    @staticmethod
│ │ -    def get_basic_authorization_header(client_id: str, client_secret: str) -> str:
│ │ -        """
│ │ -        This function transforms the client id and the client secret into a header that conforms with http basic auth.
│ │ -        It joins the id and the secret with a : then base64 encodes it, then adds the appropriate text
│ │ -
│ │ -        :param client_id: str
│ │ -        :param client_secret: str
│ │ -        :rtype: str
│ │ -        """
│ │ -        concated = "{}:{}".format(client_id, client_secret)
│ │ -        return "Basic {}".format(
│ │ -            base64.b64encode(concated.encode(ClientCredentialsAuthenticator._utf_8)).decode(
│ │ -                ClientCredentialsAuthenticator._utf_8
│ │ -            )
│ │ -        )
│ │ -
│ │      def refresh_credentials(self):
│ │          """
│ │          This function is used by the _handle_rpc_error() decorator, depending on the AUTH_MODE config object. This handler
│ │          is meant for SDK use-cases of auth (like pyflyte, or when users call SDK functions that require access to Admin,
│ │          like when waiting for another workflow to complete from within a task). This function uses basic auth, which means
│ │          the credentials for basic auth must be present from wherever this code is running.
│ │  
│ │          """
│ │          token_endpoint = self._token_endpoint
│ │          scopes = self._scopes
│ │  
│ │          # Note that unlike the Pkce flow, the client ID does not come from Admin.
│ │          logging.debug(f"Basic authorization flow with client id {self._client_id} scope {scopes}")
│ │ -        authorization_header = self.get_basic_authorization_header(self._client_id, self._client_secret)
│ │ -        token, expires_in = self.get_token(token_endpoint, authorization_header, scopes)
│ │ +        authorization_header = token_client.get_basic_authorization_header(self._client_id, self._client_secret)
│ │ +        token, expires_in = token_client.get_token(token_endpoint, scopes, authorization_header)
│ │          logging.info("Retrieved new token, expires in {}".format(expires_in))
│ │          self._creds = Credentials(token)
│ │ +
│ │ +
│ │ +class DeviceCodeAuthenticator(Authenticator):
│ │ +    """
│ │ +    This Authenticator implements the Device Code authorization flow useful for headless user authentication.
│ │ +
│ │ +    Examples described
│ │ +    - https://developer.okta.com/docs/guides/device-authorization-grant/main/
│ │ +    - https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow#device-flow
│ │ +    """
│ │ +
│ │ +    def __init__(
│ │ +        self,
│ │ +        endpoint: str,
│ │ +        cfg_store: ClientConfigStore,
│ │ +        header_key: typing.Optional[str] = None,
│ │ +        audience: typing.Optional[str] = None,
│ │ +    ):
│ │ +        self._audience = audience
│ │ +        cfg = cfg_store.get_client_config()
│ │ +        self._client_id = cfg.client_id
│ │ +        self._device_auth_endpoint = cfg.device_authorization_endpoint
│ │ +        self._scope = cfg.scopes
│ │ +        self._token_endpoint = cfg.token_endpoint
│ │ +        if self._device_auth_endpoint is None:
│ │ +            raise AuthenticationError(
│ │ +                "Device Authentication is not available on the Flyte backend / authentication server"
│ │ +            )
│ │ +        super().__init__(
│ │ +            endpoint=endpoint, header_key=header_key or cfg.header_key, credentials=KeyringStore.retrieve(endpoint)
│ │ +        )
│ │ +
│ │ +    def refresh_credentials(self):
│ │ +        resp = token_client.get_device_code(self._device_auth_endpoint, self._client_id, self._audience, self._scope)
│ │ +        print(
│ │ +            f"""
│ │ +To Authenticate navigate in a browser to the following URL: {resp.verification_uri} and enter code: {resp.user_code}
│ │ +OR copy paste the following URL: {resp.verification_uri_complete}
│ │ +        """
│ │ +        )
│ │ +        try:
│ │ +            # Currently the refresh token is not retreived. We may want to add support for refreshTokens so that
│ │ +            # access tokens can be refreshed for once authenticated machines
│ │ +            token, expires_in = token_client.poll_token_endpoint(resp, self._token_endpoint, client_id=self._client_id)
│ │ +            self._creds = Credentials(access_token=token, expires_in=expires_in, for_endpoint=self._endpoint)
│ │ +            KeyringStore.store(self._creds)
│ │ +        except Exception:
│ │ +            KeyringStore.delete(self._endpoint)
│ │ +            raise
│ │   --- flytekit-1.5.0b0/flytekit/clients/auth/keyring.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/auth/keyring.py
│ │┄ Files 2% similar despite different names
│ │ @@ -11,14 +11,15 @@
│ │      """
│ │      Stores the credentials together
│ │      """
│ │  
│ │      access_token: str
│ │      refresh_token: str = "na"
│ │      for_endpoint: str = "flyte-default"
│ │ +    expires_in: typing.Optional[int] = None
│ │  
│ │  
│ │  class KeyringStore:
│ │      """
│ │      Methods to access Keyring Store.
│ │      """
│ │   --- flytekit-1.5.0b0/flytekit/clients/auth_helper.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/auth_helper.py
│ │┄ Files 2% similar despite different names
│ │ @@ -8,14 +8,15 @@
│ │  
│ │  from flytekit.clients.auth.authenticator import (
│ │      Authenticator,
│ │      ClientConfig,
│ │      ClientConfigStore,
│ │      ClientCredentialsAuthenticator,
│ │      CommandAuthenticator,
│ │ +    DeviceCodeAuthenticator,
│ │      PKCEAuthenticator,
│ │  )
│ │  from flytekit.clients.grpc_utils.auth_interceptor import AuthUnaryInterceptor
│ │  from flytekit.clients.grpc_utils.wrap_exception_interceptor import RetryExceptionWrapperInterceptor
│ │  from flytekit.configuration import AuthType, PlatformConfig
│ │  
│ │  
│ │ @@ -37,14 +38,15 @@
│ │          return ClientConfig(
│ │              token_endpoint=oauth2_metadata.token_endpoint,
│ │              authorization_endpoint=oauth2_metadata.authorization_endpoint,
│ │              redirect_uri=public_client_config.redirect_uri,
│ │              client_id=public_client_config.client_id,
│ │              scopes=public_client_config.scopes,
│ │              header_key=public_client_config.authorization_metadata_key or None,
│ │ +            device_authorization_endpoint=oauth2_metadata.device_authorization_endpoint,
│ │          )
│ │  
│ │  
│ │  def get_authenticator(cfg: PlatformConfig, cfg_store: ClientConfigStore) -> Authenticator:
│ │      """
│ │      Returns a new authenticator based on the platform config.
│ │      """
│ │ @@ -65,23 +67,26 @@
│ │          return PKCEAuthenticator(cfg.endpoint, cfg_store, verify=verify)
│ │      elif cfg_auth == AuthType.BASIC or cfg_auth == AuthType.CLIENT_CREDENTIALS or cfg_auth == AuthType.CLIENTSECRET:
│ │          return ClientCredentialsAuthenticator(
│ │              endpoint=cfg.endpoint,
│ │              client_id=cfg.client_id,
│ │              client_secret=cfg.client_credentials_secret,
│ │              cfg_store=cfg_store,
│ │ +            scopes=cfg.scopes,
│ │          )
│ │      elif cfg_auth == AuthType.EXTERNAL_PROCESS or cfg_auth == AuthType.EXTERNALCOMMAND:
│ │          client_cfg = None
│ │          if cfg_store:
│ │              client_cfg = cfg_store.get_client_config()
│ │          return CommandAuthenticator(
│ │              command=cfg.command,
│ │              header_key=client_cfg.header_key if client_cfg else None,
│ │          )
│ │ +    elif cfg_auth == AuthType.DEVICEFLOW:
│ │ +        return DeviceCodeAuthenticator(endpoint=cfg.endpoint, cfg_store=cfg_store, audience=cfg.audience)
│ │      else:
│ │          raise ValueError(
│ │              f"Invalid auth mode [{cfg_auth}] specified." f"Please update the creds config to use a valid value"
│ │          )
│ │  
│ │  
│ │  def upgrade_channel_to_authenticated(cfg: PlatformConfig, in_channel: grpc.Channel) -> grpc.Channel:
│ │   --- flytekit-1.5.0b0/flytekit/clients/friendly.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/friendly.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clients/grpc_utils/auth_interceptor.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/grpc_utils/auth_interceptor.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clients/grpc_utils/wrap_exception_interceptor.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/grpc_utils/wrap_exception_interceptor.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clients/helpers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/helpers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clients/raw.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clients/raw.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/flyte_cli/main.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/flyte_cli/main.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/helpers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/helpers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/backfill.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/backfill.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/constants.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/constants.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/helpers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/helpers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/init.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/init.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/package.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/package.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/pyflyte.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/pyflyte.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/register.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/register.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/run.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/run.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/clis/sdk_in_container/serialize.py
│ ├── +++ flytekit-1.5.0b1/flytekit/clis/sdk_in_container/serialize.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/configuration/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/configuration/__init__.py
│ │┄ Files 1% similar despite different names
│ │ @@ -340,14 +340,15 @@
│ │      CLIENT_CREDENTIALS = "client_credentials"
│ │      EXTERNAL_PROCESS = "external_process"
│ │      # The following values are copied from flyteidl's admin client to align the two code bases on the same enum values.
│ │      # The enum values above will continue to work.
│ │      CLIENTSECRET = "ClientSecret"
│ │      PKCE = "Pkce"
│ │      EXTERNALCOMMAND = "ExternalCommand"
│ │ +    DEVICEFLOW = "DeviceFlow"
│ │  
│ │  
│ │  @dataclass(init=True, repr=True, eq=True, frozen=True)
│ │  class PlatformConfig(object):
│ │      """
│ │      This object contains the settings to talk to a Flyte backend (the DNS location of your Admin server basically).
│ │  
│ │ @@ -372,14 +373,15 @@
│ │      ca_cert_file_path: typing.Optional[str] = None
│ │      console_endpoint: typing.Optional[str] = None
│ │      command: typing.Optional[typing.List[str]] = None
│ │      client_id: typing.Optional[str] = None
│ │      client_credentials_secret: typing.Optional[str] = None
│ │      scopes: List[str] = field(default_factory=list)
│ │      auth_mode: AuthType = AuthType.STANDARD
│ │ +    audience: typing.Optional[str] = None
│ │      rpc_retries: int = 3
│ │  
│ │      @classmethod
│ │      def auto(cls, config_file: typing.Optional[typing.Union[str, ConfigFile]] = None) -> PlatformConfig:
│ │          """
│ │          Reads from Config file, and overrides from Environment variables. Refer to ConfigEntry for details
│ │          :param config_file:
│ │ @@ -477,15 +479,15 @@
│ │          kwargs = {}
│ │          kwargs = set_if_exists(kwargs, "env_prefix", _internal.Secrets.ENV_PREFIX.read(config_file))
│ │          kwargs = set_if_exists(kwargs, "default_dir", _internal.Secrets.DEFAULT_DIR.read(config_file))
│ │          kwargs = set_if_exists(kwargs, "file_prefix", _internal.Secrets.FILE_PREFIX.read(config_file))
│ │          return SecretsConfig(**kwargs)
│ │  
│ │  
│ │ -@dataclass
│ │ +@dataclass(init=True, repr=True, eq=True, frozen=True)
│ │  class S3Config(object):
│ │      """
│ │      S3 specific configuration
│ │      """
│ │  
│ │      enable_debug: bool = False
│ │      endpoint: typing.Optional[str] = None
│ │ @@ -508,15 +510,15 @@
│ │          kwargs = set_if_exists(kwargs, "retries", _internal.AWS.RETRIES.read(config_file))
│ │          kwargs = set_if_exists(kwargs, "backoff", _internal.AWS.BACKOFF_SECONDS.read(config_file))
│ │          kwargs = set_if_exists(kwargs, "access_key_id", _internal.AWS.S3_ACCESS_KEY_ID.read(config_file))
│ │          kwargs = set_if_exists(kwargs, "secret_access_key", _internal.AWS.S3_SECRET_ACCESS_KEY.read(config_file))
│ │          return S3Config(**kwargs)
│ │  
│ │  
│ │ -@dataclass
│ │ +@dataclass(init=True, repr=True, eq=True, frozen=True)
│ │  class GCSConfig(object):
│ │      """
│ │      Any GCS specific configuration.
│ │      """
│ │  
│ │      gsutil_parallelism: bool = False
│ │   --- flytekit-1.5.0b0/flytekit/configuration/default_images.py
│ ├── +++ flytekit-1.5.0b1/flytekit/configuration/default_images.py
│ │┄ Files 8% similar despite different names
│ │ @@ -3,25 +3,27 @@
│ │  import typing
│ │  
│ │  
│ │  class PythonVersion(enum.Enum):
│ │      PYTHON_3_8 = (3, 8)
│ │      PYTHON_3_9 = (3, 9)
│ │      PYTHON_3_10 = (3, 10)
│ │ +    PYTHON_3_11 = (3, 11)
│ │  
│ │  
│ │  class DefaultImages(object):
│ │      """
│ │      We may want to load the default images from remote - maybe s3 location etc?
│ │      """
│ │  
│ │      _DEFAULT_IMAGE_PREFIXES = {
│ │          PythonVersion.PYTHON_3_8: "cr.flyte.org/flyteorg/flytekit:py3.8-",
│ │          PythonVersion.PYTHON_3_9: "cr.flyte.org/flyteorg/flytekit:py3.9-",
│ │          PythonVersion.PYTHON_3_10: "cr.flyte.org/flyteorg/flytekit:py3.10-",
│ │ +        PythonVersion.PYTHON_3_11: "cr.flyte.org/flyteorg/flytekit:py3.11-",
│ │      }
│ │  
│ │      @classmethod
│ │      def default_image(cls) -> str:
│ │          return cls.find_image_for()
│ │  
│ │      @classmethod
│ │ @@ -32,10 +34,11 @@
│ │  
│ │          if not __version__ or __version__ == "0.0.0+develop":
│ │              version_suffix = "latest"
│ │          else:
│ │              version_suffix = __version__
│ │          if python_version is None:
│ │              python_version = PythonVersion((sys.version_info.major, sys.version_info.minor))
│ │ +
│ │          return cls._DEFAULT_IMAGE_PREFIXES[python_version] + (
│ │              flytekit_version.replace("v", "") if flytekit_version else version_suffix
│ │          )
│ │   --- flytekit-1.5.0b0/flytekit/configuration/feature_flags.py
│ ├── +++ flytekit-1.5.0b1/flytekit/configuration/feature_flags.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/configuration/file.py
│ ├── +++ flytekit-1.5.0b1/flytekit/configuration/file.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/configuration/internal.py
│ ├── +++ flytekit-1.5.0b1/flytekit/configuration/internal.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/annotation.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/annotation.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/base_sql_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/base_sql_task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/base_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/base_task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/checkpointer.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/checkpointer.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/class_based_resolver.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/class_based_resolver.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/condition.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/condition.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/constants.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/constants.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/container_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/container_task.py
│ │┄ Files 25% similar despite different names
│ │ @@ -1,20 +1,22 @@
│ │  from enum import Enum
│ │  from typing import Any, Dict, List, Optional, Tuple, Type
│ │  
│ │  from flytekit.configuration import SerializationSettings
│ │  from flytekit.core.base_task import PythonTask, TaskMetadata
│ │  from flytekit.core.interface import Interface
│ │ +from flytekit.core.pod_template import PodTemplate
│ │  from flytekit.core.resources import Resources, ResourceSpec
│ │ -from flytekit.core.utils import _get_container_definition
│ │ +from flytekit.core.utils import _get_container_definition, _serialize_pod_spec
│ │  from flytekit.models import task as _task_model
│ │  from flytekit.models.security import Secret, SecurityContext
│ │  
│ │ +_PRIMARY_CONTAINER_NAME_FIELD = "primary_container_name"
│ │ +
│ │  
│ │ -# TODO: do we need pod_template here? Seems that it is a raw container not running in pods
│ │  class ContainerTask(PythonTask):
│ │      """
│ │      This is an intermediate class that represents Flyte Tasks that run a container at execution time. This is the vast
│ │      majority of tasks - the typical ``@task`` decorated tasks for instance all run a container. An example of
│ │      something that doesn't run a container would be something like the Athena SQL task.
│ │      """
│ │  
│ │ @@ -43,22 +45,29 @@
│ │          requests: Optional[Resources] = None,
│ │          limits: Optional[Resources] = None,
│ │          input_data_dir: Optional[str] = None,
│ │          output_data_dir: Optional[str] = None,
│ │          metadata_format: MetadataFormat = MetadataFormat.JSON,
│ │          io_strategy: Optional[IOStrategy] = None,
│ │          secret_requests: Optional[List[Secret]] = None,
│ │ +        pod_template: Optional[PodTemplate] = None,
│ │ +        pod_template_name: Optional[str] = None,
│ │          **kwargs,
│ │      ):
│ │          sec_ctx = None
│ │          if secret_requests:
│ │              for s in secret_requests:
│ │                  if not isinstance(s, Secret):
│ │                      raise AssertionError(f"Secret {s} should be of type flytekit.Secret, received {type(s)}")
│ │              sec_ctx = SecurityContext(secrets=secret_requests)
│ │ +
│ │ +        # pod_template_name overwrites the metadata.pod_template_name
│ │ +        metadata = metadata or TaskMetadata()
│ │ +        metadata.pod_template_name = pod_template_name
│ │ +
│ │          super().__init__(
│ │              task_type="raw-container",
│ │              name=name,
│ │              interface=Interface(inputs, outputs),
│ │              metadata=metadata,
│ │              task_config=None,
│ │              security_ctx=sec_ctx,
│ │ @@ -70,14 +79,15 @@
│ │          self._input_data_dir = input_data_dir
│ │          self._output_data_dir = output_data_dir
│ │          self._md_format = metadata_format
│ │          self._io_strategy = io_strategy
│ │          self._resources = ResourceSpec(
│ │              requests=requests if requests else Resources(), limits=limits if limits else Resources()
│ │          )
│ │ +        self.pod_template = pod_template
│ │  
│ │      @property
│ │      def resources(self) -> ResourceSpec:
│ │          return self._resources
│ │  
│ │      def execute(self, **kwargs) -> Any:
│ │          print(kwargs)
│ │ @@ -87,32 +97,59 @@
│ │          print(
│ │              f"\ndocker run --rm -v /tmp/inputs:{self._input_data_dir} -v /tmp/outputs:{self._output_data_dir} {env}"
│ │              f"{self._image} {self._cmd} {self._args}"
│ │          )
│ │          return None
│ │  
│ │      def get_container(self, settings: SerializationSettings) -> _task_model.Container:
│ │ +        # if pod_template is specified, return None here but in get_k8s_pod, return pod_template merged with container
│ │ +        if self.pod_template is not None:
│ │ +            return None
│ │ +
│ │ +        return self._get_container(settings)
│ │ +
│ │ +    def _get_data_loading_config(self) -> _task_model.DataLoadingConfig:
│ │ +        return _task_model.DataLoadingConfig(
│ │ +            input_path=self._input_data_dir,
│ │ +            output_path=self._output_data_dir,
│ │ +            format=self._md_format.value,
│ │ +            enabled=True,
│ │ +            io_strategy=self._io_strategy.value if self._io_strategy else None,
│ │ +        )
│ │ +
│ │ +    def _get_container(self, settings: SerializationSettings) -> _task_model.Container:
│ │          env = settings.env or {}
│ │          env = {**env, **self.environment} if self.environment else env
│ │          return _get_container_definition(
│ │              image=self._image,
│ │              command=self._cmd,
│ │              args=self._args,
│ │ -            data_loading_config=_task_model.DataLoadingConfig(
│ │ -                input_path=self._input_data_dir,
│ │ -                output_path=self._output_data_dir,
│ │ -                format=self._md_format.value,
│ │ -                enabled=True,
│ │ -                io_strategy=self._io_strategy.value if self._io_strategy else None,
│ │ -            ),
│ │ +            data_loading_config=self._get_data_loading_config(),
│ │              environment=env,
│ │              storage_request=self.resources.requests.storage,
│ │              ephemeral_storage_request=self.resources.requests.ephemeral_storage,
│ │              cpu_request=self.resources.requests.cpu,
│ │              gpu_request=self.resources.requests.gpu,
│ │              memory_request=self.resources.requests.mem,
│ │              storage_limit=self.resources.limits.storage,
│ │              ephemeral_storage_limit=self.resources.limits.ephemeral_storage,
│ │              cpu_limit=self.resources.limits.cpu,
│ │              gpu_limit=self.resources.limits.gpu,
│ │              memory_limit=self.resources.limits.mem,
│ │          )
│ │ +
│ │ +    def get_k8s_pod(self, settings: SerializationSettings) -> _task_model.K8sPod:
│ │ +        if self.pod_template is None:
│ │ +            return None
│ │ +        return _task_model.K8sPod(
│ │ +            pod_spec=_serialize_pod_spec(self.pod_template, self._get_container(settings)),
│ │ +            metadata=_task_model.K8sObjectMetadata(
│ │ +                labels=self.pod_template.labels,
│ │ +                annotations=self.pod_template.annotations,
│ │ +            ),
│ │ +            data_config=self._get_data_loading_config(),
│ │ +        )
│ │ +
│ │ +    def get_config(self, settings: SerializationSettings) -> Optional[Dict[str, str]]:
│ │ +        if self.pod_template is None:
│ │ +            return {}
│ │ +        return {_PRIMARY_CONTAINER_NAME_FIELD: self.pod_template.primary_container_name}
│ │   --- flytekit-1.5.0b0/flytekit/core/context_manager.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/context_manager.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/data_persistence.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/data_persistence.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/docstring.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/docstring.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/dynamic_workflow_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/dynamic_workflow_task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/gate.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/gate.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/interface.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/interface.py
│ │┄ Files 12% similar despite different names
│ │ @@ -17,14 +17,36 @@
│ │  from flytekit.models import interface as _interface_models
│ │  from flytekit.models.literals import Void
│ │  from flytekit.types.pickle import FlytePickle
│ │  
│ │  T = typing.TypeVar("T")
│ │  
│ │  
│ │ +def repr_kv(k: str, v: Union[Type, Tuple[Type, Any]]) -> str:
│ │ +    if isinstance(v, tuple):
│ │ +        if v[1]:
│ │ +            return f"{k}: {v[0]}={v[1]}"
│ │ +        return f"{k}: {v[0]}"
│ │ +    return f"{k}: {v}"
│ │ +
│ │ +
│ │ +def repr_type_signature(io: Union[Dict[str, Tuple[Type, Any]], Dict[str, Type]]) -> str:
│ │ +    """
│ │ +    Converts an inputs and outputs to a type signature
│ │ +    """
│ │ +    s = "("
│ │ +    i = 0
│ │ +    for k, v in io.items():
│ │ +        if i > 0:
│ │ +            s += ", "
│ │ +        s += repr_kv(k, v)
│ │ +        i = i + 1
│ │ +    return s + ")"
│ │ +
│ │ +
│ │  class Interface(object):
│ │      """
│ │      A Python native interface object, like inspect.signature but simpler.
│ │      """
│ │  
│ │      def __init__(
│ │          self,
│ │ @@ -53,15 +75,17 @@
│ │          self._outputs = outputs if outputs else {}  # type: ignore
│ │          self._output_tuple_name = output_tuple_name
│ │  
│ │          if outputs:
│ │              variables = [k for k in outputs.keys()]
│ │  
│ │              # TODO: This class is a duplicate of the one in create_task_outputs. Over time, we should move to this one.
│ │ -            class Output(collections.namedtuple(output_tuple_name or "DefaultNamedTupleOutput", variables)):  # type: ignore
│ │ +            class Output(  # type: ignore
│ │ +                collections.namedtuple(output_tuple_name or "DefaultNamedTupleOutput", variables)  # type: ignore
│ │ +            ):  # type: ignore
│ │                  """
│ │                  This class can be used in two different places. For multivariate-return entities this class is used
│ │                  to rewrap the outputs so that our with_overrides function can work.
│ │                  For manual node creation, it's used during local execution as something that can be dereferenced.
│ │                  See the create_node function for more information.
│ │                  """
│ │  
│ │ @@ -163,14 +187,20 @@
│ │          new_outputs = copy.copy(self._outputs)
│ │          for k, v in extra_outputs.items():
│ │              if k in new_outputs:
│ │                  raise ValueError(f"Output {k} cannot be added as it already exists in the interface")
│ │              new_outputs[k] = v
│ │          return Interface(self._inputs, new_outputs)
│ │  
│ │ +    def __str__(self):
│ │ +        return f"{repr_type_signature(self._inputs)} -> {repr_type_signature(self._outputs)}"
│ │ +
│ │ +    def __repr__(self):
│ │ +        return str(self)
│ │ +
│ │  
│ │  def transform_inputs_to_parameters(
│ │      ctx: context_manager.FlyteContext, interface: Interface
│ │  ) -> _interface_models.ParameterMap:
│ │      """
│ │      Transforms the given interface (with inputs) to a Parameter Map with defaults set
│ │      :param interface: the interface object
│ │ @@ -216,45 +246,54 @@
│ │          )
│ │  
│ │      inputs_map = transform_variable_map(interface.inputs, input_descriptions)
│ │      outputs_map = transform_variable_map(interface.outputs, output_descriptions)
│ │      return _interface_models.TypedInterface(inputs_map, outputs_map)
│ │  
│ │  
│ │ -def transform_types_to_list_of_type(m: Dict[str, type]) -> Dict[str, type]:
│ │ +def transform_types_to_list_of_type(m: Dict[str, type], bound_inputs: typing.Set[str]) -> Dict[str, type]:
│ │      """
│ │      Converts a given variables to be collections of their type. This is useful for array jobs / map style code.
│ │      It will create a collection of types even if any one these types is not a collection type
│ │      """
│ │      if m is None:
│ │          return {}
│ │  
│ │      all_types_are_collection = True
│ │      for k, v in m.items():
│ │ +        if k in bound_inputs:
│ │ +            # Skip the inputs that are bound. If they are bound, it does not matter if they are collection or
│ │ +            # singletons
│ │ +            continue
│ │          v_type = type(v)
│ │          if v_type != typing.List and v_type != list:
│ │              all_types_are_collection = False
│ │              break
│ │  
│ │      if all_types_are_collection:
│ │          return m
│ │  
│ │      om = {}
│ │      for k, v in m.items():
│ │ -        om[k] = typing.List[v]  # type: ignore
│ │ +        if k in bound_inputs:
│ │ +            om[k] = v
│ │ +        else:
│ │ +            om[k] = typing.List[v]  # type: ignore
│ │      return om  # type: ignore
│ │  
│ │  
│ │ -def transform_interface_to_list_interface(interface: Interface) -> Interface:
│ │ +def transform_interface_to_list_interface(interface: Interface, bound_inputs: typing.Set[str]) -> Interface:
│ │      """
│ │      Takes a single task interface and interpolates it to an array interface - to allow performing distributed python map
│ │      like functions
│ │ +    :param interface: Interface to be upgraded toa list interface
│ │ +    :param bound_inputs: fixed inputs that should not upgraded to a list and will be maintained as scalars.
│ │      """
│ │ -    map_inputs = transform_types_to_list_of_type(interface.inputs)
│ │ -    map_outputs = transform_types_to_list_of_type(interface.outputs)
│ │ +    map_inputs = transform_types_to_list_of_type(interface.inputs, bound_inputs)
│ │ +    map_outputs = transform_types_to_list_of_type(interface.outputs, set())
│ │  
│ │      return Interface(inputs=map_inputs, outputs=map_outputs)
│ │  
│ │  
│ │  def _change_unrecognized_type_to_pickle(t: Type[T]) -> typing.Union[Tuple[Type[T]], Type[T]]:
│ │      try:
│ │          if hasattr(t, "__origin__") and hasattr(t, "__args__"):
│ │ @@ -284,15 +323,14 @@
│ │      """
│ │      From the annotations on a task function that the user should have provided, and the output names they want to use
│ │      for each output parameter, construct the TypedInterface object
│ │  
│ │      For now the fancy object, maybe in the future a dumb object.
│ │  
│ │      """
│ │ -
│ │      type_hints = get_type_hints(fn, include_extras=True)
│ │      signature = inspect.signature(fn)
│ │      return_annotation = type_hints.get("return", None)
│ │  
│ │      outputs = extract_return_annotation(return_annotation)
│ │      for k, v in outputs.items():
│ │          outputs[k] = _change_unrecognized_type_to_pickle(v)  # type: ignore
│ │   --- flytekit-1.5.0b0/flytekit/core/launch_plan.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/launch_plan.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/local_cache.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/local_cache.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/map_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/python_function_task.py
│ │┄ Files 23% similar despite different names
│ │ @@ -1,274 +1,306 @@
│ │  """
│ │ -Flytekit map tasks specify how to run a single task across a list of inputs. Map tasks themselves are constructed with
│ │ -a reference task as well as run-time parameters that limit execution concurrency and failure tolerations.
│ │ +=========================================
│ │ +:mod:`flytekit.core.python_function_task`
│ │ +=========================================
│ │ +
│ │ +.. currentmodule:: flytekit.core.python_function_task
│ │ +
│ │ +.. autosummary::
│ │ +   :toctree: generated/
│ │ +
│ │ +   PythonFunctionTask
│ │ +   PythonInstanceTask
│ │ +
│ │  """
│ │  
│ │ -import os
│ │ -import typing
│ │ -from contextlib import contextmanager
│ │ -from itertools import count
│ │ -from typing import Any, Dict, List, Optional
│ │ -
│ │ -from flytekit.configuration import SerializationSettings
│ │ -from flytekit.core import tracker
│ │ -from flytekit.core.base_task import PythonTask
│ │ -from flytekit.core.constants import SdkTaskType
│ │ +
│ │ +from abc import ABC
│ │ +from collections import OrderedDict
│ │ +from enum import Enum
│ │ +from typing import Any, Callable, List, Optional, TypeVar, Union, cast
│ │ +
│ │ +from flytekit.core.base_task import Task, TaskResolverMixin
│ │  from flytekit.core.context_manager import ExecutionState, FlyteContext, FlyteContextManager
│ │ -from flytekit.core.interface import transform_interface_to_list_interface
│ │ -from flytekit.core.python_function_task import PythonFunctionTask
│ │ +from flytekit.core.docstring import Docstring
│ │ +from flytekit.core.interface import transform_function_to_interface
│ │ +from flytekit.core.promise import VoidPromise, translate_inputs_to_literals
│ │ +from flytekit.core.python_auto_container import PythonAutoContainerTask, default_task_resolver
│ │ +from flytekit.core.tracker import extract_task_module, is_functools_wrapped_module_level, isnested, istestfunction
│ │ +from flytekit.core.workflow import (
│ │ +    PythonFunctionWorkflow,
│ │ +    WorkflowFailurePolicy,
│ │ +    WorkflowMetadata,
│ │ +    WorkflowMetadataDefaults,
│ │ +)
│ │  from flytekit.exceptions import scopes as exception_scopes
│ │ -from flytekit.models.array_job import ArrayJob
│ │ -from flytekit.models.interface import Variable
│ │ -from flytekit.models.task import Container, K8sPod, Sql
│ │ +from flytekit.exceptions.user import FlyteValueException
│ │ +from flytekit.loggers import logger
│ │ +from flytekit.models import dynamic_job as _dynamic_job
│ │ +from flytekit.models import literals as _literal_models
│ │ +from flytekit.models import task as task_models
│ │ +from flytekit.models.admin import workflow as admin_workflow_models
│ │  
│ │ +T = TypeVar("T")
│ │  
│ │ -class MapPythonTask(PythonTask):
│ │ -    """
│ │ -    A MapPythonTask defines a :py:class:`flytekit.PythonTask` which specifies how to run
│ │ -    an inner :py:class:`flytekit.PythonFunctionTask` across a range of inputs in parallel.
│ │ -    TODO: support lambda functions
│ │ +
│ │ +class PythonInstanceTask(PythonAutoContainerTask[T], ABC):  # type: ignore
│ │      """
│ │ +    This class should be used as the base class for all Tasks that do not have a user defined function body, but have
│ │ +    a platform defined execute method. (Execute needs to be overridden). This base class ensures that the module loader
│ │ +    will invoke the right class automatically, by capturing the module name and variable in the module name.
│ │ +
│ │ +    .. code-block: python
│ │  
│ │ -    # To support multiple map tasks declared around identical python function tasks, we keep a global count of
│ │ -    # MapPythonTask instances to uniquely differentiate map task names for each declared instance.
│ │ -    _ids = count(0)
│ │ +        x = MyInstanceTask(name="x", .....)
│ │ +
│ │ +        # this can be invoked as
│ │ +        x(a=5) # depending on the interface of the defined task
│ │ +
│ │ +    """
│ │  
│ │      def __init__(
│ │          self,
│ │ -        python_function_task: PythonFunctionTask,
│ │ -        concurrency: Optional[int] = None,
│ │ -        min_success_ratio: Optional[float] = None,
│ │ +        name: str,
│ │ +        task_config: T,
│ │ +        task_type: str = "python-task",
│ │ +        task_resolver: Optional[TaskResolverMixin] = None,
│ │          **kwargs,
│ │      ):
│ │          """
│ │ -        :param python_function_task: This argument is implicitly passed and represents the repeatable function
│ │ -        :param concurrency: If specified, this limits the number of mapped tasks than can run in parallel to the given
│ │ -        batch size
│ │ -        :param min_success_ratio: If specified, this determines the minimum fraction of total jobs which can complete
│ │ -            successfully before terminating this task and marking it successful.
│ │ +        Please see class level documentation.
│ │          """
│ │ -        if len(python_function_task.python_interface.inputs.keys()) > 1:
│ │ -            raise ValueError("Map tasks only accept python function tasks with 0 or 1 inputs")
│ │ -
│ │ -        if len(python_function_task.python_interface.outputs.keys()) > 1:
│ │ -            raise ValueError("Map tasks only accept python function tasks with 0 or 1 outputs")
│ │ -
│ │ -        collection_interface = transform_interface_to_list_interface(python_function_task.python_interface)
│ │ -        instance = next(self._ids)
│ │ -        _, mod, f, _ = tracker.extract_task_module(python_function_task.task_function)
│ │ -        name = f"{mod}.mapper_{f}_{instance}"
│ │ -
│ │ -        self._cmd_prefix = None
│ │ -        self._run_task = python_function_task
│ │ -        self._max_concurrency = concurrency
│ │ -        self._min_success_ratio = min_success_ratio
│ │ -        self._array_task_interface = python_function_task.python_interface
│ │ -        if "metadata" not in kwargs and python_function_task.metadata:
│ │ -            kwargs["metadata"] = python_function_task.metadata
│ │ -        if "security_ctx" not in kwargs and python_function_task.security_context:
│ │ -            kwargs["security_ctx"] = python_function_task.security_context
│ │ -        super().__init__(
│ │ -            name=name,
│ │ -            interface=collection_interface,
│ │ -            task_type=SdkTaskType.CONTAINER_ARRAY_TASK,
│ │ -            task_config=None,
│ │ -            task_type_version=1,
│ │ -            **kwargs,
│ │ -        )
│ │ +        super().__init__(name=name, task_config=task_config, task_type=task_type, task_resolver=task_resolver, **kwargs)
│ │  
│ │ -    def get_command(self, settings: SerializationSettings) -> List[str]:
│ │ -        container_args = [
│ │ -            "pyflyte-map-execute",
│ │ -            "--inputs",
│ │ -            "{{.input}}",
│ │ -            "--output-prefix",
│ │ -            "{{.outputPrefix}}",
│ │ -            "--raw-output-data-prefix",
│ │ -            "{{.rawOutputDataPrefix}}",
│ │ -            "--checkpoint-path",
│ │ -            "{{.checkpointOutputPrefix}}",
│ │ -            "--prev-checkpoint",
│ │ -            "{{.prevCheckpointPrefix}}",
│ │ -            "--resolver",
│ │ -            self._run_task.task_resolver.location,
│ │ -            "--",
│ │ -            *self._run_task.task_resolver.loader_args(settings, self._run_task),
│ │ -        ]
│ │ -
│ │ -        if self._cmd_prefix:
│ │ -            return self._cmd_prefix + container_args
│ │ -        return container_args
│ │  
│ │ -    def set_command_prefix(self, cmd: typing.Optional[typing.List[str]]):
│ │ -        self._cmd_prefix = cmd  # type: ignore
│ │ +class PythonFunctionTask(PythonAutoContainerTask[T]):  # type: ignore
│ │ +    """
│ │ +    A Python Function task should be used as the base for all extensions that have a python function. It will
│ │ +    automatically detect interface of the python function and when serialized on the hosted Flyte platform handles the
│ │ +    writing execution command to execute the function
│ │  
│ │ -    @contextmanager
│ │ -    def prepare_target(self):
│ │ -        """
│ │ -        Alters the underlying run_task command to modify it for map task execution and then resets it after.
│ │ -        """
│ │ -        self._run_task.set_command_fn(self.get_command)
│ │ -        try:
│ │ -            yield
│ │ -        finally:
│ │ -            self._run_task.reset_command_fn()
│ │ -
│ │ -    def get_container(self, settings: SerializationSettings) -> Container:
│ │ -        with self.prepare_target():
│ │ -            return self._run_task.get_container(settings)
│ │ -
│ │ -    def get_k8s_pod(self, settings: SerializationSettings) -> K8sPod:
│ │ -        with self.prepare_target():
│ │ -            return self._run_task.get_k8s_pod(settings)
│ │ -
│ │ -    def get_sql(self, settings: SerializationSettings) -> Sql:
│ │ -        with self.prepare_target():
│ │ -            return self._run_task.get_sql(settings)
│ │ +    It is advised this task is used using the @task decorator as follows
│ │  
│ │ -    def get_custom(self, settings: SerializationSettings) -> Dict[str, Any]:
│ │ -        return ArrayJob(parallelism=self._max_concurrency, min_success_ratio=self._min_success_ratio).to_dict()
│ │ +    .. code-block: python
│ │  
│ │ -    def get_config(self, settings: SerializationSettings) -> Optional[Dict[str, str]]:
│ │ -        return self._run_task.get_config(settings)
│ │ +        @task
│ │ +        def my_func(a: int) -> str:
│ │ +           ...
│ │  
│ │ -    @property
│ │ -    def run_task(self) -> PythonFunctionTask:
│ │ -        return self._run_task
│ │ -
│ │ -    def execute(self, **kwargs) -> Any:
│ │ -        ctx = FlyteContextManager.current_context()
│ │ -        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.TASK_EXECUTION:
│ │ -            return self._execute_map_task(ctx, **kwargs)
│ │ +    In the above code, the name of the function, the module, and the interface (inputs = int and outputs = str) will be
│ │ +    auto detected.
│ │ +    """
│ │  
│ │ -        return self._raw_execute(**kwargs)
│ │ +    class ExecutionBehavior(Enum):
│ │ +        DEFAULT = 1
│ │ +        DYNAMIC = 2
│ │  
│ │ -    @staticmethod
│ │ -    def _compute_array_job_index() -> int:
│ │ -        """
│ │ -        Computes the absolute index of the current array job. This is determined by summing the compute-environment-specific
│ │ -        environment variable and the offset (if one's set). The offset will be set and used when the user request that the
│ │ -        job runs in a number of slots less than the size of the input.
│ │ +    def __init__(
│ │ +        self,
│ │ +        task_config: T,
│ │ +        task_function: Callable,
│ │ +        task_type="python-task",
│ │ +        ignore_input_vars: Optional[List[str]] = None,
│ │ +        execution_mode: ExecutionBehavior = ExecutionBehavior.DEFAULT,
│ │ +        task_resolver: Optional[TaskResolverMixin] = None,
│ │ +        **kwargs,
│ │ +    ):
│ │          """
│ │ -        return int(os.environ.get("BATCH_JOB_ARRAY_INDEX_OFFSET", "0")) + int(
│ │ -            os.environ.get(os.environ.get("BATCH_JOB_ARRAY_INDEX_VAR_NAME", "0"), "0")
│ │ +        :param T task_config: Configuration object for Task. Should be a unique type for that specific Task
│ │ +        :param Callable task_function: Python function that has type annotations and works for the task
│ │ +        :param Optional[List[str]] ignore_input_vars: When supplied, these input variables will be removed from the interface. This
│ │ +                                  can be used to inject some client side variables only. Prefer using ExecutionParams
│ │ +        :param Optional[ExecutionBehavior] execution_mode: Defines how the execution should behave, for example
│ │ +            executing normally or specially handling a dynamic case.
│ │ +        :param str task_type: String task type to be associated with this Task
│ │ +        """
│ │ +        if task_function is None:
│ │ +            raise ValueError("TaskFunction is a required parameter for PythonFunctionTask")
│ │ +        self._native_interface = transform_function_to_interface(task_function, Docstring(callable_=task_function))
│ │ +        mutated_interface = self._native_interface.remove_inputs(ignore_input_vars)
│ │ +        name, _, _, _ = extract_task_module(task_function)
│ │ +        super().__init__(
│ │ +            task_type=task_type,
│ │ +            name=name,
│ │ +            interface=mutated_interface,
│ │ +            task_config=task_config,
│ │ +            task_resolver=task_resolver,
│ │ +            **kwargs,
│ │          )
│ │  
│ │ +        if self._task_resolver is default_task_resolver:
│ │ +            # The default task resolver can't handle nested functions
│ │ +            # TODO: Consider moving this to a can_handle function or something inside the resolver itself.
│ │ +            if (
│ │ +                not istestfunction(func=task_function)
│ │ +                and isnested(func=task_function)
│ │ +                and not is_functools_wrapped_module_level(task_function)
│ │ +            ):
│ │ +                raise ValueError(
│ │ +                    "TaskFunction cannot be a nested/inner or local function. "
│ │ +                    "It should be accessible at a module level for Flyte to execute it. Test modules with "
│ │ +                    "names beginning with `test_` are allowed to have nested tasks. "
│ │ +                    "If you're decorating your task function with custom decorators, use functools.wraps "
│ │ +                    "or functools.update_wrapper on the function wrapper. "
│ │ +                    "Alternatively if you want to create your own tasks with custom behavior use the TaskResolverMixin"
│ │ +                )
│ │ +        self._task_function = task_function
│ │ +        self._execution_mode = execution_mode
│ │ +        self._wf = None  # For dynamic tasks
│ │ +
│ │      @property
│ │ -    def _outputs_interface(self) -> Dict[Any, Variable]:
│ │ -        """
│ │ -        We override this method from PythonTask because the dispatch_execute method uses this
│ │ -        interface to construct outputs. Each instance of an container_array task will however produce outputs
│ │ -        according to the underlying run_task interface and the array plugin handler will actually create a collection
│ │ -        from these individual outputs as the final output value.
│ │ -        """
│ │ +    def execution_mode(self) -> ExecutionBehavior:
│ │ +        return self._execution_mode
│ │  
│ │ -        ctx = FlyteContextManager.current_context()
│ │ -        if ctx.execution_state is not None and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_WORKFLOW_EXECUTION:
│ │ -            # In workflow execution mode we actually need to use the parent (mapper) task output interface.
│ │ -            return self.interface.outputs
│ │ -        return self._run_task.interface.outputs
│ │ +    @property
│ │ +    def task_function(self):
│ │ +        return self._task_function
│ │  
│ │ -    def get_type_for_output_var(self, k: str, v: Any) -> type:
│ │ +    def execute(self, **kwargs) -> Any:
│ │          """
│ │ -        We override this method from flytekit.core.base_task Task because the dispatch_execute method uses this
│ │ -        interface to construct outputs. Each instance of an container_array task will however produce outputs
│ │ -        according to the underlying run_task interface and the array plugin handler will actually create a collection
│ │ -        from these individual outputs as the final output value.
│ │ +        This method will be invoked to execute the task. If you do decide to override this method you must also
│ │ +        handle dynamic tasks or you will no longer be able to use the task as a dynamic task generator.
│ │          """
│ │ -        ctx = FlyteContextManager.current_context()
│ │ -        if ctx.execution_state is not None and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_WORKFLOW_EXECUTION:
│ │ -            # In workflow execution mode we actually need to use the parent (mapper) task output interface.
│ │ -            return self._python_interface.outputs[k]
│ │ -        return self._run_task._python_interface.outputs[k]
│ │ +        if self.execution_mode == self.ExecutionBehavior.DEFAULT:
│ │ +            return exception_scopes.user_entry_point(self._task_function)(**kwargs)
│ │ +        elif self.execution_mode == self.ExecutionBehavior.DYNAMIC:
│ │ +            return self.dynamic_execute(self._task_function, **kwargs)
│ │ +
│ │ +    def _create_and_cache_dynamic_workflow(self):
│ │ +        if self._wf is None:
│ │ +            workflow_meta = WorkflowMetadata(on_failure=WorkflowFailurePolicy.FAIL_IMMEDIATELY)
│ │ +            defaults = WorkflowMetadataDefaults(
│ │ +                interruptible=self.metadata.interruptible if self.metadata.interruptible is not None else False
│ │ +            )
│ │ +            self._wf = PythonFunctionWorkflow(self._task_function, metadata=workflow_meta, default_metadata=defaults)
│ │ +
│ │ +    def compile_into_workflow(
│ │ +        self, ctx: FlyteContext, task_function: Callable, **kwargs
│ │ +    ) -> Union[_dynamic_job.DynamicJobSpec, _literal_models.LiteralMap]:
│ │ +        """
│ │ +        In the case of dynamic workflows, this function will produce a workflow definition at execution time which will
│ │ +        then proceed to be executed.
│ │ +        """
│ │ +        # TODO: circular import
│ │ +        from flytekit.core.task import ReferenceTask
│ │ +
│ │ +        if not ctx.compilation_state:
│ │ +            cs = ctx.new_compilation_state(prefix="d")
│ │ +        else:
│ │ +            cs = ctx.compilation_state.with_params(prefix="d")
│ │ +
│ │ +        with FlyteContextManager.with_context(ctx.with_compilation_state(cs)):
│ │ +            # TODO: Resolve circular import
│ │ +            from flytekit.tools.translator import get_serializable
│ │ +
│ │ +            self._create_and_cache_dynamic_workflow()
│ │ +            cast(PythonFunctionWorkflow, self._wf).compile(**kwargs)
│ │ +
│ │ +            wf = self._wf
│ │ +            model_entities: OrderedDict = OrderedDict()
│ │ +            # See comment on reference entity checking a bit down below in this function.
│ │ +            # This is the only circular dependency between the translator.py module and the rest of the flytekit
│ │ +            # authoring experience.
│ │ +            workflow_spec: admin_workflow_models.WorkflowSpec = get_serializable(
│ │ +                model_entities, ctx.serialization_settings, wf
│ │ +            )
│ │ +
│ │ +            # If no nodes were produced, let's just return the strict outputs
│ │ +            if len(workflow_spec.template.nodes) == 0:
│ │ +                return _literal_models.LiteralMap(
│ │ +                    literals={
│ │ +                        binding.var: binding.binding.to_literal_model() for binding in workflow_spec.template.outputs
│ │ +                    }
│ │ +                )
│ │ +
│ │ +            # Gather underlying TaskTemplates that get referenced.
│ │ +            tts = []
│ │ +            for entity, model in model_entities.items():
│ │ +                # We only care about gathering tasks here. Launch plans are handled by
│ │ +                # propeller. Subworkflows should already be in the workflow spec.
│ │ +                if not isinstance(entity, Task) and not isinstance(entity, task_models.TaskSpec):
│ │ +                    continue
│ │ +
│ │ +                # We are currently not supporting reference tasks since these will
│ │ +                # require a network call to flyteadmin to populate the TaskTemplate
│ │ +                # model
│ │ +                if isinstance(entity, ReferenceTask):
│ │ +                    raise Exception("Reference tasks are currently unsupported within dynamic tasks")
│ │ +
│ │ +                if not isinstance(model, task_models.TaskSpec):
│ │ +                    raise TypeError(
│ │ +                        f"Unexpected type for serialized form of task. Expected {task_models.TaskSpec}, but got {type(model)}"
│ │ +                    )
│ │ +
│ │ +                # Store the valid task template so that we can pass it to the
│ │ +                # DynamicJobSpec later
│ │ +                tts.append(model.template)
│ │ +
│ │ +            dj_spec = _dynamic_job.DynamicJobSpec(
│ │ +                min_successes=len(workflow_spec.template.nodes),
│ │ +                tasks=tts,
│ │ +                nodes=workflow_spec.template.nodes,
│ │ +                outputs=workflow_spec.template.outputs,
│ │ +                subworkflows=workflow_spec.sub_workflows,
│ │ +            )
│ │ +
│ │ +            return dj_spec
│ │ +
│ │ +    def dynamic_execute(self, task_function: Callable, **kwargs) -> Any:
│ │ +        """
│ │ +        By the time this function is invoked, the local_execute function should have unwrapped the Promises and Flyte
│ │ +        literal wrappers so that the kwargs we are working with here are now Python native literal values. This
│ │ +        function is also expected to return Python native literal values.
│ │  
│ │ -    def _execute_map_task(self, _: FlyteContext, **kwargs) -> Any:
│ │ -        """
│ │ -        This is called during ExecutionState.Mode.TASK_EXECUTION executions, that is executions orchestrated by the
│ │ -        Flyte platform. Individual instances of the map task, aka array task jobs are passed the full set of inputs but
│ │ -        only produce a single output based on the map task (array task) instance. The array plugin handler will actually
│ │ -        create a collection from these individual outputs as the final map task output value.
│ │ -        """
│ │ -        task_index = self._compute_array_job_index()
│ │ -        map_task_inputs = {}
│ │ -        for k in self.interface.inputs.keys():
│ │ -            map_task_inputs[k] = kwargs[k][task_index]
│ │ -        return exception_scopes.user_entry_point(self._run_task.execute)(**map_task_inputs)
│ │ +        Since the user code within a dynamic task constitute a workflow, we have to first compile the workflow, and
│ │ +        then execute that workflow.
│ │  
│ │ -    def _raw_execute(self, **kwargs) -> Any:
│ │ -        """
│ │ -        This is called during locally run executions. Unlike array task execution on the Flyte platform, _raw_execute
│ │ -        produces the full output collection.
│ │ +        When running for real in production, the task would stop after the compilation step, and then create a file
│ │ +        representing that newly generated workflow, instead of executing it.
│ │          """
│ │ -        outputs_expected = True
│ │ -        if not self.interface.outputs:
│ │ -            outputs_expected = False
│ │ -        outputs = []
│ │ -
│ │ -        any_input_key = (
│ │ -            list(self._run_task.interface.inputs.keys())[0]
│ │ -            if self._run_task.interface.inputs.items() is not None
│ │ -            else None
│ │ -        )
│ │ -
│ │ -        for i in range(len(kwargs[any_input_key])):
│ │ -            single_instance_inputs = {}
│ │ -            for k in self.interface.inputs.keys():
│ │ -                single_instance_inputs[k] = kwargs[k][i]
│ │ -            o = exception_scopes.user_entry_point(self._run_task.execute)(**single_instance_inputs)
│ │ -            if outputs_expected:
│ │ -                outputs.append(o)
│ │ -
│ │ -        return outputs
│ │ -
│ │ -
│ │ -def map_task(task_function: PythonFunctionTask, concurrency: int = 0, min_success_ratio: float = 1.0, **kwargs):
│ │ -    """
│ │ -    Use a map task for parallelizable tasks that run across a list of an input type. A map task can be composed of
│ │ -    any individual :py:class:`flytekit.PythonFunctionTask`.
│ │ -
│ │ -    Invoke a map task with arguments using the :py:class:`list` version of the expected input.
│ │ -
│ │ -    Usage:
│ │ -
│ │ -    .. literalinclude:: ../../../tests/flytekit/unit/core/test_map_task.py
│ │ -       :start-after: # test_map_task_start
│ │ -       :end-before: # test_map_task_end
│ │ -       :language: python
│ │ -       :dedent: 4
│ │ -
│ │ -    At run time, the underlying map task will be run for every value in the input collection. Attributes
│ │ -    such as :py:class:`flytekit.TaskMetadata` and ``with_overrides`` are applied to individual instances
│ │ -    of the mapped task.
│ │ -
│ │ -    **Map Task Plugins**
│ │ -
│ │ -    There are two plugins to run maptasks that ship as part of flyteplugins:
│ │ -
│ │ -    1. K8s Array
│ │ -    2. `AWS batch <https://docs.flyte.org/en/latest/deployment/plugin_setup/aws/batch.html>`_
│ │ -
│ │ -    Enabling a plugin is controlled in the plugin configuration at `values-sandbox.yaml <https://github.com/flyteorg/flyte/blob/10cee9f139824512b6c5be1667d321bdbc8835fa/charts/flyte/values-sandbox.yaml#L152-L162>`_.
│ │ -
│ │ -    **K8s Array**
│ │ -
│ │ -    By default, the map task uses the ``K8s Array`` plugin. It executes array tasks by launching a pod for every instance in the array. It’s simple to use, has a straightforward implementation, and works out of the box.
│ │ -
│ │ -    **AWS batch**
│ │ -
│ │ -    Learn more about ``AWS batch`` setup configuration `here <https://docs.flyte.org/en/latest/deployment/plugin_setup/aws/batch.html#deployment-plugin-setup-aws-array>`_.
│ │ +        ctx = FlyteContextManager.current_context()
│ │ +        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_WORKFLOW_EXECUTION:
│ │ +            # The rest of this function mimics the local_execute of the workflow. We can't use the workflow
│ │ +            # local_execute directly though since that converts inputs into Promises.
│ │ +            logger.debug(f"Executing Dynamic workflow, using raw inputs {kwargs}")
│ │ +            self._create_and_cache_dynamic_workflow()
│ │ +            function_outputs = cast(PythonFunctionWorkflow, self._wf).execute(**kwargs)
│ │ +
│ │ +            if isinstance(function_outputs, VoidPromise) or function_outputs is None:
│ │ +                return VoidPromise(self.name)
│ │ +
│ │ +            if len(cast(PythonFunctionWorkflow, self._wf).python_interface.outputs) == 0:
│ │ +                raise FlyteValueException(function_outputs, "Interface output should've been VoidPromise or None.")
│ │ +
│ │ +            # TODO: This will need to be cleaned up when we revisit top-level tuple support.
│ │ +            expected_output_names = list(self.python_interface.outputs.keys())
│ │ +            if len(expected_output_names) == 1:
│ │ +                # Here we have to handle the fact that the wf could've been declared with a typing.NamedTuple of
│ │ +                # length one. That convention is used for naming outputs - and single-length-NamedTuples are
│ │ +                # particularly troublesome but elegant handling of them is not a high priority
│ │ +                # Again, we're using the output_tuple_name as a proxy.
│ │ +                if self.python_interface.output_tuple_name and isinstance(function_outputs, tuple):
│ │ +                    wf_outputs_as_map = {expected_output_names[0]: function_outputs[0]}
│ │ +                else:
│ │ +                    wf_outputs_as_map = {expected_output_names[0]: function_outputs}
│ │ +            else:
│ │ +                wf_outputs_as_map = {
│ │ +                    expected_output_names[i]: function_outputs[i] for i, _ in enumerate(function_outputs)
│ │ +                }
│ │ +
│ │ +            # In a normal workflow, we'd repackage the promises coming from tasks into new Promises matching the
│ │ +            # workflow's interface. For a dynamic workflow, just return the literal map.
│ │ +            wf_outputs_as_literal_dict = translate_inputs_to_literals(
│ │ +                ctx,
│ │ +                wf_outputs_as_map,
│ │ +                flyte_interface_types=self.interface.outputs,
│ │ +                native_types=self.python_interface.outputs,
│ │ +            )
│ │ +            return _literal_models.LiteralMap(literals=wf_outputs_as_literal_dict)
│ │  
│ │ -    A custom plugin can also be implemented to handle the task type.
│ │ +        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.TASK_EXECUTION:
│ │ +            return self.compile_into_workflow(ctx, task_function, **kwargs)
│ │  
│ │ -    :param task_function: This argument is implicitly passed and represents the repeatable function
│ │ -    :param concurrency: If specified, this limits the number of mapped tasks than can run in parallel to the given batch
│ │ -        size. If the size of the input exceeds the concurrency value, then multiple batches will be run serially until
│ │ -        all inputs are processed. If left unspecified, this means unbounded concurrency.
│ │ -    :param min_success_ratio: If specified, this determines the minimum fraction of total jobs which can complete
│ │ -        successfully before terminating this task and marking it successful.
│ │ +        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_TASK_EXECUTION:
│ │ +            return exception_scopes.user_entry_point(task_function)(**kwargs)
│ │  
│ │ -    """
│ │ -    if not isinstance(task_function, PythonFunctionTask):
│ │ -        raise ValueError(
│ │ -            f"Only Flyte python task types are supported in map tasks currently, received {type(task_function)}"
│ │ -        )
│ │ -    return MapPythonTask(task_function, concurrency=concurrency, min_success_ratio=min_success_ratio, **kwargs)
│ │ +        raise ValueError(f"Invalid execution provided, execution state: {ctx.execution_state}")
│ │ ├── encoding
│ │ │ @@ -1 +1 @@
│ │ │ -utf-8
│ │ │ +us-ascii
│ │   --- flytekit-1.5.0b0/flytekit/core/mock_stats.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/mock_stats.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/node.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/node.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/node_creation.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/node_creation.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/notification.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/notification.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/pod_template.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/pod_template.py
│ │┄ Files 11% similar despite different names
│ │ @@ -1,22 +1,22 @@
│ │ -from dataclasses import dataclass
│ │ +from dataclasses import dataclass, field
│ │  from typing import Dict, Optional
│ │  
│ │  from kubernetes.client.models import V1PodSpec
│ │  
│ │  from flytekit.exceptions import user as _user_exceptions
│ │  
│ │  PRIMARY_CONTAINER_DEFAULT_NAME = "primary"
│ │  
│ │  
│ │ -@dataclass
│ │ +@dataclass(init=True, repr=True, eq=True, frozen=True)
│ │  class PodTemplate(object):
│ │      """Custom PodTemplate specification for a Task."""
│ │  
│ │ -    pod_spec: V1PodSpec = V1PodSpec(containers=[])
│ │ +    pod_spec: V1PodSpec = field(default_factory=lambda: V1PodSpec(containers=[]))
│ │      primary_container_name: str = PRIMARY_CONTAINER_DEFAULT_NAME
│ │      labels: Optional[Dict[str, str]] = None
│ │      annotations: Optional[Dict[str, str]] = None
│ │  
│ │      def __post_init__(self):
│ │          if not self.primary_container_name:
│ │              raise _user_exceptions.FlyteValidationException("A primary container name cannot be undefined")
│ │   --- flytekit-1.5.0b0/flytekit/core/promise.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/promise.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/python_auto_container.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/python_auto_container.py
│ │┄ Files 15% similar despite different names
│ │ @@ -1,38 +1,30 @@
│ │  from __future__ import annotations
│ │  
│ │  import importlib
│ │  import re
│ │  from abc import ABC
│ │ -from typing import Any, Callable, Dict, List, Optional, TypeVar, cast
│ │ -
│ │ -from flyteidl.core import tasks_pb2 as _core_task
│ │ -from kubernetes.client import ApiClient
│ │ -from kubernetes.client.models import V1Container, V1EnvVar, V1ResourceRequirements
│ │ +from typing import Callable, Dict, List, Optional, TypeVar
│ │  
│ │  from flytekit.configuration import ImageConfig, SerializationSettings
│ │  from flytekit.core.base_task import PythonTask, TaskMetadata, TaskResolverMixin
│ │  from flytekit.core.context_manager import FlyteContextManager
│ │  from flytekit.core.pod_template import PodTemplate
│ │  from flytekit.core.resources import Resources, ResourceSpec
│ │  from flytekit.core.tracked_abc import FlyteTrackedABC
│ │  from flytekit.core.tracker import TrackedInstance, extract_task_module
│ │ -from flytekit.core.utils import _get_container_definition
│ │ +from flytekit.core.utils import _get_container_definition, _serialize_pod_spec
│ │  from flytekit.loggers import logger
│ │  from flytekit.models import task as _task_model
│ │  from flytekit.models.security import Secret, SecurityContext
│ │  
│ │  T = TypeVar("T")
│ │  _PRIMARY_CONTAINER_NAME_FIELD = "primary_container_name"
│ │  
│ │  
│ │ -def _sanitize_resource_name(resource: _task_model.Resources.ResourceEntry) -> str:
│ │ -    return _core_task.Resources.ResourceName.Name(resource.name).lower().replace("_", "-")
│ │ -
│ │ -
│ │  class PythonAutoContainerTask(PythonTask[T], ABC, metaclass=FlyteTrackedABC):
│ │      """
│ │      A Python AutoContainer task should be used as the base for all extensions that want the user's code to be in the
│ │      container and the container information to be automatically captured.
│ │      This base will auto configure the image and image version to be used for all its derivatives.
│ │  
│ │      If you are looking to extend, you might prefer to use ``PythonFunctionTask`` or ``PythonInstanceTask``
│ │ @@ -202,60 +194,19 @@
│ │              storage_limit=self.resources.limits.storage,
│ │              ephemeral_storage_limit=self.resources.limits.ephemeral_storage,
│ │              cpu_limit=self.resources.limits.cpu,
│ │              gpu_limit=self.resources.limits.gpu,
│ │              memory_limit=self.resources.limits.mem,
│ │          )
│ │  
│ │ -    def _serialize_pod_spec(self, settings: SerializationSettings) -> Dict[str, Any]:
│ │ -        containers = cast(PodTemplate, self.pod_template).pod_spec.containers
│ │ -        primary_exists = False
│ │ -
│ │ -        for container in containers:
│ │ -            if container.name == cast(PodTemplate, self.pod_template).primary_container_name:
│ │ -                primary_exists = True
│ │ -                break
│ │ -
│ │ -        if not primary_exists:
│ │ -            # insert a placeholder primary container if it is not defined in the pod spec.
│ │ -            containers.append(V1Container(name=cast(PodTemplate, self.pod_template).primary_container_name))
│ │ -        final_containers = []
│ │ -        for container in containers:
│ │ -            # In the case of the primary container, we overwrite specific container attributes
│ │ -            # with the default values used in the regular Python task.
│ │ -            # The attributes include: image, command, args, resource, and env (env is unioned)
│ │ -            if container.name == cast(PodTemplate, self.pod_template).primary_container_name:
│ │ -                sdk_default_container = self._get_container(settings)
│ │ -                container.image = sdk_default_container.image
│ │ -                # clear existing commands
│ │ -                container.command = sdk_default_container.command
│ │ -                # also clear existing args
│ │ -                container.args = sdk_default_container.args
│ │ -                limits, requests = {}, {}
│ │ -                for resource in sdk_default_container.resources.limits:
│ │ -                    limits[_sanitize_resource_name(resource)] = resource.value
│ │ -                for resource in sdk_default_container.resources.requests:
│ │ -                    requests[_sanitize_resource_name(resource)] = resource.value
│ │ -                resource_requirements = V1ResourceRequirements(limits=limits, requests=requests)
│ │ -                if len(limits) > 0 or len(requests) > 0:
│ │ -                    # Important! Only copy over resource requirements if they are non-empty.
│ │ -                    container.resources = resource_requirements
│ │ -                container.env = [V1EnvVar(name=key, value=val) for key, val in sdk_default_container.env.items()] + (
│ │ -                    container.env or []
│ │ -                )
│ │ -            final_containers.append(container)
│ │ -        cast(PodTemplate, self.pod_template).pod_spec.containers = final_containers
│ │ -
│ │ -        return ApiClient().sanitize_for_serialization(cast(PodTemplate, self.pod_template).pod_spec)
│ │ -
│ │      def get_k8s_pod(self, settings: SerializationSettings) -> _task_model.K8sPod:
│ │          if self.pod_template is None:
│ │              return None
│ │          return _task_model.K8sPod(
│ │ -            pod_spec=self._serialize_pod_spec(settings),
│ │ +            pod_spec=_serialize_pod_spec(self.pod_template, self._get_container(settings)),
│ │              metadata=_task_model.K8sObjectMetadata(
│ │                  labels=self.pod_template.labels,
│ │                  annotations=self.pod_template.annotations,
│ │              ),
│ │          )
│ │  
│ │      # need to call super in all its children tasks
│ │   --- flytekit-1.5.0b0/flytekit/core/python_customized_container_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/python_customized_container_task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/python_function_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/tasks/shell.py
│ │┄ Files 23% similar despite different names
│ │ @@ -1,306 +1,382 @@
│ │ -"""
│ │ -=========================================
│ │ -:mod:`flytekit.core.python_function_task`
│ │ -=========================================
│ │ -
│ │ -.. currentmodule:: flytekit.core.python_function_task
│ │ -
│ │ -.. autosummary::
│ │ -   :toctree: generated/
│ │ -
│ │ -   PythonFunctionTask
│ │ -   PythonInstanceTask
│ │ -
│ │ -"""
│ │ -
│ │ -
│ │ -from abc import ABC
│ │ -from collections import OrderedDict
│ │ -from enum import Enum
│ │ -from typing import Any, Callable, List, Optional, TypeVar, Union, cast
│ │ -
│ │ -from flytekit.core.base_task import Task, TaskResolverMixin
│ │ -from flytekit.core.context_manager import ExecutionState, FlyteContext, FlyteContextManager
│ │ -from flytekit.core.docstring import Docstring
│ │ -from flytekit.core.interface import transform_function_to_interface
│ │ -from flytekit.core.promise import VoidPromise, translate_inputs_to_literals
│ │ -from flytekit.core.python_auto_container import PythonAutoContainerTask, default_task_resolver
│ │ -from flytekit.core.tracker import extract_task_module, is_functools_wrapped_module_level, isnested, istestfunction
│ │ -from flytekit.core.workflow import (
│ │ -    PythonFunctionWorkflow,
│ │ -    WorkflowFailurePolicy,
│ │ -    WorkflowMetadata,
│ │ -    WorkflowMetadataDefaults,
│ │ -)
│ │ -from flytekit.exceptions import scopes as exception_scopes
│ │ -from flytekit.exceptions.user import FlyteValueException
│ │ +import datetime
│ │ +import os
│ │ +import string
│ │ +import subprocess
│ │ +import typing
│ │ +from dataclasses import dataclass
│ │ +
│ │ +import flytekit
│ │ +from flytekit.core.context_manager import ExecutionParameters
│ │ +from flytekit.core.interface import Interface
│ │ +from flytekit.core.python_function_task import PythonInstanceTask
│ │ +from flytekit.core.task import TaskPlugins
│ │  from flytekit.loggers import logger
│ │ -from flytekit.models import dynamic_job as _dynamic_job
│ │ -from flytekit.models import literals as _literal_models
│ │ -from flytekit.models import task as task_models
│ │ -from flytekit.models.admin import workflow as admin_workflow_models
│ │ +from flytekit.types.directory import FlyteDirectory
│ │ +from flytekit.types.file import FlyteFile
│ │  
│ │ -T = TypeVar("T")
│ │  
│ │ -
│ │ -class PythonInstanceTask(PythonAutoContainerTask[T], ABC):  # type: ignore
│ │ +@dataclass
│ │ +class OutputLocation:
│ │ +    """
│ │ +    Args:
│ │ +        var: str The name of the output variable
│ │ +        var_type: typing.Type The type of output variable
│ │ +        location: os.PathLike The location where this output variable will be written to or a regex that accepts input
│ │ +                  vars and generates the path. Of the form ``"{{ .inputs.v }}.tmp.md"``.
│ │ +                  This example for a given input v, at path `/tmp/abc.csv` will resolve to `/tmp/abc.csv.tmp.md`
│ │      """
│ │ -    This class should be used as the base class for all Tasks that do not have a user defined function body, but have
│ │ -    a platform defined execute method. (Execute needs to be overridden). This base class ensures that the module loader
│ │ -    will invoke the right class automatically, by capturing the module name and variable in the module name.
│ │  
│ │ -    .. code-block: python
│ │ +    var: str
│ │ +    var_type: typing.Type
│ │ +    location: typing.Union[os.PathLike, str]
│ │ +
│ │  
│ │ -        x = MyInstanceTask(name="x", .....)
│ │ +def _dummy_task_func():
│ │ +    """
│ │ +    A Fake function to satisfy the inner PythonTask requirements
│ │ +    """
│ │ +    return None
│ │  
│ │ -        # this can be invoked as
│ │ -        x(a=5) # depending on the interface of the defined task
│ │  
│ │ +class AttrDict(dict):
│ │ +    """
│ │ +    Convert a dictionary to an attribute style lookup. Do not use this in regular places, this is used for
│ │ +    namespacing inputs and outputs
│ │      """
│ │  
│ │ -    def __init__(
│ │ +    def __init__(self, *args, **kwargs):
│ │ +        super(AttrDict, self).__init__(*args, **kwargs)
│ │ +        self.__dict__ = self
│ │ +
│ │ +
│ │ +class _PythonFStringInterpolizer:
│ │ +    """A class for interpolating scripts that use python string.format syntax"""
│ │ +
│ │ +    class _Formatter(string.Formatter):
│ │ +        def format_field(self, value, format_spec):
│ │ +            """
│ │ +            Special cased return for the given value. Given the type returns the string version for
│ │ +            the type. Handles FlyteFile and FlyteDirectory specially.
│ │ +            Downloads and returns the downloaded filepath.
│ │ +            """
│ │ +            if isinstance(value, FlyteFile):
│ │ +                value.download()
│ │ +                return value.path
│ │ +            if isinstance(value, FlyteDirectory):
│ │ +                value.download()
│ │ +                return value.path
│ │ +            if isinstance(value, datetime.datetime):
│ │ +                return value.isoformat()
│ │ +            return super().format_field(value, format_spec)
│ │ +
│ │ +    def interpolate(
│ │          self,
│ │ -        name: str,
│ │ -        task_config: T,
│ │ -        task_type: str = "python-task",
│ │ -        task_resolver: Optional[TaskResolverMixin] = None,
│ │ -        **kwargs,
│ │ -    ):
│ │ +        tmpl: str,
│ │ +        inputs: typing.Optional[typing.Dict[str, str]] = None,
│ │ +        outputs: typing.Optional[typing.Dict[str, str]] = None,
│ │ +    ) -> str:
│ │          """
│ │ -        Please see class level documentation.
│ │ +        Interpolate python formatted string templates with variables from the input and output
│ │ +        argument dicts. The result is non destructive towards the given template string.
│ │          """
│ │ -        super().__init__(name=name, task_config=task_config, task_type=task_type, task_resolver=task_resolver, **kwargs)
│ │ +        inputs = inputs or {}
│ │ +        outputs = outputs or {}
│ │ +        inputs = AttrDict(inputs)
│ │ +        outputs = AttrDict(outputs)
│ │ +        consolidated_args = {
│ │ +            "inputs": inputs,
│ │ +            "outputs": outputs,
│ │ +            "ctx": flytekit.current_context(),
│ │ +        }
│ │ +        try:
│ │ +            return self._Formatter().format(tmpl, **consolidated_args)
│ │ +        except KeyError as e:
│ │ +            raise ValueError(f"Variable {e} in Query not found in inputs {consolidated_args.keys()}")
│ │  
│ │  
│ │ -class PythonFunctionTask(PythonAutoContainerTask[T]):  # type: ignore
│ │ -    """
│ │ -    A Python Function task should be used as the base for all extensions that have a python function. It will
│ │ -    automatically detect interface of the python function and when serialized on the hosted Flyte platform handles the
│ │ -    writing execution command to execute the function
│ │ +T = typing.TypeVar("T")
│ │  
│ │ -    It is advised this task is used using the @task decorator as follows
│ │  
│ │ -    .. code-block: python
│ │ -
│ │ -        @task
│ │ -        def my_func(a: int) -> str:
│ │ -           ...
│ │ -
│ │ -    In the above code, the name of the function, the module, and the interface (inputs = int and outputs = str) will be
│ │ -    auto detected.
│ │ -    """
│ │ -
│ │ -    class ExecutionBehavior(Enum):
│ │ -        DEFAULT = 1
│ │ -        DYNAMIC = 2
│ │ +class ShellTask(PythonInstanceTask[T]):
│ │ +    """ """
│ │  
│ │      def __init__(
│ │          self,
│ │ -        task_config: T,
│ │ -        task_function: Callable,
│ │ -        task_type="python-task",
│ │ -        ignore_input_vars: Optional[List[str]] = None,
│ │ -        execution_mode: ExecutionBehavior = ExecutionBehavior.DEFAULT,
│ │ -        task_resolver: Optional[TaskResolverMixin] = None,
│ │ +        name: str,
│ │ +        debug: bool = False,
│ │ +        script: typing.Optional[str] = None,
│ │ +        script_file: typing.Optional[str] = None,
│ │ +        task_config: T = None,
│ │ +        inputs: typing.Optional[typing.Dict[str, typing.Type]] = None,
│ │ +        output_locs: typing.Optional[typing.List[OutputLocation]] = None,
│ │          **kwargs,
│ │      ):
│ │          """
│ │ -        :param T task_config: Configuration object for Task. Should be a unique type for that specific Task
│ │ -        :param Callable task_function: Python function that has type annotations and works for the task
│ │ -        :param Optional[List[str]] ignore_input_vars: When supplied, these input variables will be removed from the interface. This
│ │ -                                  can be used to inject some client side variables only. Prefer using ExecutionParams
│ │ -        :param Optional[ExecutionBehavior] execution_mode: Defines how the execution should behave, for example
│ │ -            executing normally or specially handling a dynamic case.
│ │ -        :param str task_type: String task type to be associated with this Task
│ │ -        """
│ │ -        if task_function is None:
│ │ -            raise ValueError("TaskFunction is a required parameter for PythonFunctionTask")
│ │ -        self._native_interface = transform_function_to_interface(task_function, Docstring(callable_=task_function))
│ │ -        mutated_interface = self._native_interface.remove_inputs(ignore_input_vars)
│ │ -        name, _, _, _ = extract_task_module(task_function)
│ │ +        Args:
│ │ +            name: str Name of the Task. Should be unique in the project
│ │ +            debug: bool Print the generated script and other debugging information
│ │ +            script: The actual script specified as a string
│ │ +            script_file: A path to the file that contains the script (Only script or script_file) can be provided
│ │ +            task_config: T Configuration for the task, can be either a Pod (or coming soon, BatchJob) config
│ │ +            inputs: A Dictionary of input names to types
│ │ +            output_locs: A list of :py:class:`OutputLocations`
│ │ +            **kwargs: Other arguments that can be passed to
│ │ +                :py:class:`~flytekit.core.python_function_task.PythonInstanceTask`
│ │ +        """
│ │ +        if script and script_file:
│ │ +            raise ValueError("Only either of script or script_file can be provided")
│ │ +        if not script and not script_file:
│ │ +            raise ValueError("Either a script or script_file is needed")
│ │ +        if script_file:
│ │ +            if not os.path.exists(script_file):
│ │ +                raise ValueError(f"FileNotFound: the specified Script file at path {script_file} cannot be loaded")
│ │ +            script_file = os.path.abspath(script_file)
│ │ +
│ │ +        if task_config is not None:
│ │ +            fully_qualified_class_name = task_config.__module__ + "." + task_config.__class__.__name__
│ │ +            if not fully_qualified_class_name == "flytekitplugins.pod.task.Pod":
│ │ +                raise ValueError("TaskConfig can either be empty - indicating simple container task or a PodConfig.")
│ │ +
│ │ +        # Each instance of NotebookTask instantiates an underlying task with a dummy function that will only be used
│ │ +        # to run pre- and post- execute functions using the corresponding task plugin.
│ │ +        # We rename the function name here to ensure the generated task has a unique name and avoid duplicate task name
│ │ +        # errors.
│ │ +        # This seem like a hack. We should use a plugin_class that doesn't require a fake-function to make work.
│ │ +        plugin_class = TaskPlugins.find_pythontask_plugin(type(task_config))
│ │ +        self._config_task_instance = plugin_class(task_config=task_config, task_function=_dummy_task_func)
│ │ +        # Rename the internal task so that there are no conflicts at serialization time. Technically these internal
│ │ +        # tasks should not be serialized at all, but we don't currently have a mechanism for skipping Flyte entities
│ │ +        # at serialization time.
│ │ +        self._config_task_instance._name = f"_bash.{name}"
│ │ +        self._script = script
│ │ +        self._script_file = script_file
│ │ +        self._debug = debug
│ │ +        self._output_locs = output_locs if output_locs else []
│ │ +        self._interpolizer = _PythonFStringInterpolizer()
│ │ +        outputs = self._validate_output_locs()
│ │          super().__init__(
│ │ -            task_type=task_type,
│ │ -            name=name,
│ │ -            interface=mutated_interface,
│ │ -            task_config=task_config,
│ │ -            task_resolver=task_resolver,
│ │ +            name,
│ │ +            task_config,
│ │ +            task_type=self._config_task_instance.task_type,
│ │ +            interface=Interface(inputs=inputs, outputs=outputs),
│ │              **kwargs,
│ │          )
│ │  
│ │ -        if self._task_resolver is default_task_resolver:
│ │ -            # The default task resolver can't handle nested functions
│ │ -            # TODO: Consider moving this to a can_handle function or something inside the resolver itself.
│ │ -            if (
│ │ -                not istestfunction(func=task_function)
│ │ -                and isnested(func=task_function)
│ │ -                and not is_functools_wrapped_module_level(task_function)
│ │ -            ):
│ │ +    def _validate_output_locs(self) -> typing.Dict[str, typing.Type]:
│ │ +        outputs = {}
│ │ +        for v in self._output_locs:
│ │ +            if v is None:
│ │ +                raise ValueError("OutputLocation cannot be none")
│ │ +            if not isinstance(v, OutputLocation):
│ │ +                raise ValueError("Every output type should be an output location on the file-system")
│ │ +            if v.location is None:
│ │ +                raise ValueError(f"Output Location not provided for output var {v.var}")
│ │ +            if not issubclass(v.var_type, FlyteFile) and not issubclass(v.var_type, FlyteDirectory):
│ │                  raise ValueError(
│ │ -                    "TaskFunction cannot be a nested/inner or local function. "
│ │ -                    "It should be accessible at a module level for Flyte to execute it. Test modules with "
│ │ -                    "names beginning with `test_` are allowed to have nested tasks. "
│ │ -                    "If you're decorating your task function with custom decorators, use functools.wraps "
│ │ -                    "or functools.update_wrapper on the function wrapper. "
│ │ -                    "Alternatively if you want to create your own tasks with custom behavior use the TaskResolverMixin"
│ │ +                    "Currently only outputs of type FlyteFile/FlyteDirectory and their derived types are supported"
│ │                  )
│ │ -        self._task_function = task_function
│ │ -        self._execution_mode = execution_mode
│ │ -        self._wf = None  # For dynamic tasks
│ │ +            outputs[v.var] = v.var_type
│ │ +        return outputs
│ │  
│ │      @property
│ │ -    def execution_mode(self) -> ExecutionBehavior:
│ │ -        return self._execution_mode
│ │ +    def script(self) -> typing.Optional[str]:
│ │ +        return self._script
│ │  
│ │      @property
│ │ -    def task_function(self):
│ │ -        return self._task_function
│ │ +    def script_file(self) -> typing.Optional[os.PathLike]:
│ │ +        return self._script_file
│ │ +
│ │ +    def pre_execute(self, user_params: ExecutionParameters) -> ExecutionParameters:
│ │ +        return self._config_task_instance.pre_execute(user_params)
│ │  
│ │ -    def execute(self, **kwargs) -> Any:
│ │ +    def execute(self, **kwargs) -> typing.Any:
│ │          """
│ │ -        This method will be invoked to execute the task. If you do decide to override this method you must also
│ │ -        handle dynamic tasks or you will no longer be able to use the task as a dynamic task generator.
│ │ +        Executes the given script by substituting the inputs and outputs and extracts the outputs from the filesystem
│ │          """
│ │ -        if self.execution_mode == self.ExecutionBehavior.DEFAULT:
│ │ -            return exception_scopes.user_entry_point(self._task_function)(**kwargs)
│ │ -        elif self.execution_mode == self.ExecutionBehavior.DYNAMIC:
│ │ -            return self.dynamic_execute(self._task_function, **kwargs)
│ │ -
│ │ -    def _create_and_cache_dynamic_workflow(self):
│ │ -        if self._wf is None:
│ │ -            workflow_meta = WorkflowMetadata(on_failure=WorkflowFailurePolicy.FAIL_IMMEDIATELY)
│ │ -            defaults = WorkflowMetadataDefaults(
│ │ -                interruptible=self.metadata.interruptible if self.metadata.interruptible is not None else False
│ │ +        logger.info(f"Running shell script as type {self.task_type}")
│ │ +        if self.script_file:
│ │ +            with open(self.script_file) as f:
│ │ +                self._script = f.read()
│ │ +
│ │ +        outputs: typing.Dict[str, str] = {}
│ │ +        if self._output_locs:
│ │ +            for v in self._output_locs:
│ │ +                outputs[v.var] = self._interpolizer.interpolate(v.location, inputs=kwargs)
│ │ +
│ │ +        if os.name == "nt":
│ │ +            self._script = self._script.lstrip().rstrip().replace("\n", "&&")
│ │ +
│ │ +        gen_script = self._interpolizer.interpolate(self._script, inputs=kwargs, outputs=outputs)
│ │ +        if self._debug:
│ │ +            print("\n==============================================\n")
│ │ +            print(gen_script)
│ │ +            print("\n==============================================\n")
│ │ +
│ │ +        try:
│ │ +            subprocess.check_call(gen_script, shell=True)
│ │ +        except subprocess.CalledProcessError as e:
│ │ +            files = os.listdir(".")
│ │ +            fstr = "\n-".join(files)
│ │ +            logger.error(
│ │ +                f"Failed to Execute Script, return-code {e.returncode} \n"
│ │ +                f"StdErr: {e.stderr}\n"
│ │ +                f"StdOut: {e.stdout}\n"
│ │ +                f" Current directory contents: .\n-{fstr}"
│ │              )
│ │ -            self._wf = PythonFunctionWorkflow(self._task_function, metadata=workflow_meta, default_metadata=defaults)
│ │ +            raise
│ │  
│ │ -    def compile_into_workflow(
│ │ -        self, ctx: FlyteContext, task_function: Callable, **kwargs
│ │ -    ) -> Union[_dynamic_job.DynamicJobSpec, _literal_models.LiteralMap]:
│ │ -        """
│ │ -        In the case of dynamic workflows, this function will produce a workflow definition at execution time which will
│ │ -        then proceed to be executed.
│ │ -        """
│ │ -        # TODO: circular import
│ │ -        from flytekit.core.task import ReferenceTask
│ │ -
│ │ -        if not ctx.compilation_state:
│ │ -            cs = ctx.new_compilation_state(prefix="d")
│ │ -        else:
│ │ -            cs = ctx.compilation_state.with_params(prefix="d")
│ │ -
│ │ -        with FlyteContextManager.with_context(ctx.with_compilation_state(cs)):
│ │ -            # TODO: Resolve circular import
│ │ -            from flytekit.tools.translator import get_serializable
│ │ -
│ │ -            self._create_and_cache_dynamic_workflow()
│ │ -            cast(PythonFunctionWorkflow, self._wf).compile(**kwargs)
│ │ -
│ │ -            wf = self._wf
│ │ -            model_entities: OrderedDict = OrderedDict()
│ │ -            # See comment on reference entity checking a bit down below in this function.
│ │ -            # This is the only circular dependency between the translator.py module and the rest of the flytekit
│ │ -            # authoring experience.
│ │ -            workflow_spec: admin_workflow_models.WorkflowSpec = get_serializable(
│ │ -                model_entities, ctx.serialization_settings, wf
│ │ -            )
│ │ +        final_outputs = []
│ │ +        for v in self._output_locs:
│ │ +            if issubclass(v.var_type, FlyteFile):
│ │ +                final_outputs.append(FlyteFile(outputs[v.var]))
│ │ +            if issubclass(v.var_type, FlyteDirectory):
│ │ +                final_outputs.append(FlyteDirectory(outputs[v.var]))
│ │ +        if len(final_outputs) == 1:
│ │ +            return final_outputs[0]
│ │ +        if len(final_outputs) > 1:
│ │ +            return tuple(final_outputs)
│ │ +        return None
│ │  
│ │ -            # If no nodes were produced, let's just return the strict outputs
│ │ -            if len(workflow_spec.template.nodes) == 0:
│ │ -                return _literal_models.LiteralMap(
│ │ -                    literals={
│ │ -                        binding.var: binding.binding.to_literal_model() for binding in workflow_spec.template.outputs
│ │ -                    }
│ │ -                )
│ │ +    def post_execute(self, user_params: ExecutionParameters, rval: typing.Any) -> typing.Any:
│ │ +        return self._config_task_instance.post_execute(user_params, rval)
│ │  
│ │ -            # Gather underlying TaskTemplates that get referenced.
│ │ -            tts = []
│ │ -            for entity, model in model_entities.items():
│ │ -                # We only care about gathering tasks here. Launch plans are handled by
│ │ -                # propeller. Subworkflows should already be in the workflow spec.
│ │ -                if not isinstance(entity, Task) and not isinstance(entity, task_models.TaskSpec):
│ │ -                    continue
│ │ -
│ │ -                # We are currently not supporting reference tasks since these will
│ │ -                # require a network call to flyteadmin to populate the TaskTemplate
│ │ -                # model
│ │ -                if isinstance(entity, ReferenceTask):
│ │ -                    raise Exception("Reference tasks are currently unsupported within dynamic tasks")
│ │ -
│ │ -                if not isinstance(model, task_models.TaskSpec):
│ │ -                    raise TypeError(
│ │ -                        f"Unexpected type for serialized form of task. Expected {task_models.TaskSpec}, but got {type(model)}"
│ │ -                    )
│ │ -
│ │ -                # Store the valid task template so that we can pass it to the
│ │ -                # DynamicJobSpec later
│ │ -                tts.append(model.template)
│ │ -
│ │ -            dj_spec = _dynamic_job.DynamicJobSpec(
│ │ -                min_successes=len(workflow_spec.template.nodes),
│ │ -                tasks=tts,
│ │ -                nodes=workflow_spec.template.nodes,
│ │ -                outputs=workflow_spec.template.outputs,
│ │ -                subworkflows=workflow_spec.sub_workflows,
│ │ -            )
│ │  
│ │ -            return dj_spec
│ │ +class RawShellTask(ShellTask):
│ │ +    """ """
│ │ +
│ │ +    def __init__(
│ │ +        self,
│ │ +        name: str,
│ │ +        debug: bool = False,
│ │ +        script: typing.Optional[str] = None,
│ │ +        script_file: typing.Optional[str] = None,
│ │ +        task_config: T = None,
│ │ +        inputs: typing.Optional[typing.Dict[str, typing.Type]] = None,
│ │ +        output_locs: typing.Optional[typing.List[OutputLocation]] = None,
│ │ +        **kwargs,
│ │ +    ):
│ │ +        """
│ │ +        The `RawShellTask` is a minimal extension of the existing `ShellTask`. It's purpose is to support wrapping a
│ │ +        "raw" or "pure" shell script which needs to be executed with some environment variables set, and some arguments,
│ │ +        which may not be known until execution time.
│ │ +
│ │ +        This class is not meant to be instantiated into tasks by users, but used with the factory function
│ │ +        `get_raw_shell_task()`. An instance of this class will be returned with either user-specified or default
│ │ +        template. The template itself will export the desired environment variables, and subsequently execute the
│ │ +        desired "raw" script with the specified arguments.
│ │ +
│ │ +        .. note::
│ │ +            This means that within your workflow, you can dynamically control the env variables, arguments, and even the
│ │ +            actual script you want to run.
│ │ +
│ │ +        .. note::
│ │ +            The downside is that a dynamic workflow will be required. The "raw" script passed in at execution time must
│ │ +            be at the specified location.
│ │ +
│ │ +        These args are forwarded directly to the parent `ShellTask` constructor as behavior does not diverge
│ │ +        """
│ │ +        super().__init__(
│ │ +            name=name,
│ │ +            debug=debug,
│ │ +            script=script,
│ │ +            script_file=script_file,
│ │ +            task_config=task_config,
│ │ +            inputs=inputs,
│ │ +            output_locs=output_locs,
│ │ +            **kwargs,
│ │ +        )
│ │ +
│ │ +    def make_export_string_from_env_dict(self, d: typing.Dict[str, str]) -> str:
│ │ +        """
│ │ +        Utility function to convert a dictionary of desired environment variable key: value pairs into a string of
│ │ +        ```
│ │ +        export k1=v1
│ │ +        export k2=v2
│ │ +        ...
│ │ +        ```
│ │ +        """
│ │ +        items = []
│ │ +        for k, v in d.items():
│ │ +            items.append(f"export {k}={v}")
│ │ +        return "\n".join(items)
│ │  
│ │ -    def dynamic_execute(self, task_function: Callable, **kwargs) -> Any:
│ │ +    def execute(self, **kwargs) -> typing.Any:
│ │ +        """
│ │ +        Executes the given script by substituting the inputs and outputs and extracts the outputs from the filesystem
│ │          """
│ │ -        By the time this function is invoked, the local_execute function should have unwrapped the Promises and Flyte
│ │ -        literal wrappers so that the kwargs we are working with here are now Python native literal values. This
│ │ -        function is also expected to return Python native literal values.
│ │ -
│ │ -        Since the user code within a dynamic task constitute a workflow, we have to first compile the workflow, and
│ │ -        then execute that workflow.
│ │ -
│ │ -        When running for real in production, the task would stop after the compilation step, and then create a file
│ │ -        representing that newly generated workflow, instead of executing it.
│ │ -        """
│ │ -        ctx = FlyteContextManager.current_context()
│ │ -        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_WORKFLOW_EXECUTION:
│ │ -            # The rest of this function mimics the local_execute of the workflow. We can't use the workflow
│ │ -            # local_execute directly though since that converts inputs into Promises.
│ │ -            logger.debug(f"Executing Dynamic workflow, using raw inputs {kwargs}")
│ │ -            self._create_and_cache_dynamic_workflow()
│ │ -            function_outputs = cast(PythonFunctionWorkflow, self._wf).execute(**kwargs)
│ │ -
│ │ -            if isinstance(function_outputs, VoidPromise) or function_outputs is None:
│ │ -                return VoidPromise(self.name)
│ │ -
│ │ -            if len(cast(PythonFunctionWorkflow, self._wf).python_interface.outputs) == 0:
│ │ -                raise FlyteValueException(function_outputs, "Interface output should've been VoidPromise or None.")
│ │ -
│ │ -            # TODO: This will need to be cleaned up when we revisit top-level tuple support.
│ │ -            expected_output_names = list(self.python_interface.outputs.keys())
│ │ -            if len(expected_output_names) == 1:
│ │ -                # Here we have to handle the fact that the wf could've been declared with a typing.NamedTuple of
│ │ -                # length one. That convention is used for naming outputs - and single-length-NamedTuples are
│ │ -                # particularly troublesome but elegant handling of them is not a high priority
│ │ -                # Again, we're using the output_tuple_name as a proxy.
│ │ -                if self.python_interface.output_tuple_name and isinstance(function_outputs, tuple):
│ │ -                    wf_outputs_as_map = {expected_output_names[0]: function_outputs[0]}
│ │ -                else:
│ │ -                    wf_outputs_as_map = {expected_output_names[0]: function_outputs}
│ │ -            else:
│ │ -                wf_outputs_as_map = {
│ │ -                    expected_output_names[i]: function_outputs[i] for i, _ in enumerate(function_outputs)
│ │ -                }
│ │ -
│ │ -            # In a normal workflow, we'd repackage the promises coming from tasks into new Promises matching the
│ │ -            # workflow's interface. For a dynamic workflow, just return the literal map.
│ │ -            wf_outputs_as_literal_dict = translate_inputs_to_literals(
│ │ -                ctx,
│ │ -                wf_outputs_as_map,
│ │ -                flyte_interface_types=self.interface.outputs,
│ │ -                native_types=self.python_interface.outputs,
│ │ +        logger.info(f"Running shell script as type {self.task_type}")
│ │ +        if self.script_file:
│ │ +            with open(self.script_file) as f:
│ │ +                self._script = f.read()
│ │ +
│ │ +        outputs: typing.Dict[str, str] = {}
│ │ +        if self._output_locs:
│ │ +            for v in self._output_locs:
│ │ +                outputs[v.var] = self._interpolizer.interpolate(v.location, inputs=kwargs)
│ │ +
│ │ +        if os.name == "nt":
│ │ +            self._script = self._script.lstrip().rstrip().replace("\n", "&&")
│ │ +
│ │ +        if "env" in kwargs and isinstance(kwargs["env"], dict):
│ │ +            kwargs["export_env"] = self.make_export_string_from_env_dict(kwargs["env"])
│ │ +
│ │ +        gen_script = self._interpolizer.interpolate(self._script, inputs=kwargs, outputs=outputs)
│ │ +        if self._debug:
│ │ +            print("\n==============================================\n")
│ │ +            print(gen_script)
│ │ +            print("\n==============================================\n")
│ │ +
│ │ +        try:
│ │ +            subprocess.check_call(gen_script, shell=True)
│ │ +        except subprocess.CalledProcessError as e:
│ │ +            files = os.listdir(".")
│ │ +            fstr = "\n-".join(files)
│ │ +            logger.error(
│ │ +                f"Failed to Execute Script, return-code {e.returncode} \n"
│ │ +                f"StdErr: {e.stderr}\n"
│ │ +                f"StdOut: {e.stdout}\n"
│ │ +                f" Current directory contents: .\n-{fstr}"
│ │              )
│ │ -            return _literal_models.LiteralMap(literals=wf_outputs_as_literal_dict)
│ │ +            raise
│ │ +
│ │ +        final_outputs = []
│ │ +        for v in self._output_locs:
│ │ +            if issubclass(v.var_type, FlyteFile):
│ │ +                final_outputs.append(FlyteFile(outputs[v.var]))
│ │ +            if issubclass(v.var_type, FlyteDirectory):
│ │ +                final_outputs.append(FlyteDirectory(outputs[v.var]))
│ │ +        if len(final_outputs) == 1:
│ │ +            return final_outputs[0]
│ │ +        if len(final_outputs) > 1:
│ │ +            return tuple(final_outputs)
│ │ +        return None
│ │ +
│ │ +
│ │ +# The raw_shell_task is an instance of RawShellTask and wraps a 'pure' shell script
│ │ +# This utility function allows for the specification of env variables, arguments, and the actual script within the
│ │ +# workflow definition rather than at `RawShellTask` instantiation
│ │ +def get_raw_shell_task(name: str) -> RawShellTask:
│ │ +
│ │ +    return RawShellTask(
│ │ +        name=name,
│ │ +        debug=True,
│ │ +        inputs=flytekit.kwtypes(env=typing.Dict[str, str], script_args=str, script_file=str),
│ │ +        output_locs=[
│ │ +            OutputLocation(
│ │ +                var="out",
│ │ +                var_type=FlyteDirectory,
│ │ +                location="{ctx.working_directory}",
│ │ +            )
│ │ +        ],
│ │ +        script="""
│ │ +#!/bin/bash
│ │ +
│ │ +set -uex
│ │  
│ │ -        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.TASK_EXECUTION:
│ │ -            return self.compile_into_workflow(ctx, task_function, **kwargs)
│ │ +cd {ctx.working_directory}
│ │  
│ │ -        if ctx.execution_state and ctx.execution_state.mode == ExecutionState.Mode.LOCAL_TASK_EXECUTION:
│ │ -            return exception_scopes.user_entry_point(task_function)(**kwargs)
│ │ +{inputs.export_env}
│ │  
│ │ -        raise ValueError(f"Invalid execution provided, execution state: {ctx.execution_state}")
│ │ +bash {inputs.script_file} {inputs.script_args}
│ │ +""",
│ │ +    )
│ │   --- flytekit-1.5.0b0/flytekit/core/reference.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/reference.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/reference_entity.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/reference_entity.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/resources.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/resources.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/schedule.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/schedule.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/shim_task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/shim_task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/testing.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/testing.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/tracker.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/tracker.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/type_engine.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/type_engine.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/type_helpers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/type_helpers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/core/workflow.py
│ ├── +++ flytekit-1.5.0b1/flytekit/core/workflow.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/deck/deck.py
│ ├── +++ flytekit-1.5.0b1/flytekit/deck/deck.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/deck/html/template.html
│ ├── +++ flytekit-1.5.0b1/flytekit/deck/html/template.html
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/deck/renderer.py
│ ├── +++ flytekit-1.5.0b1/flytekit/deck/renderer.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/exceptions/scopes.py
│ ├── +++ flytekit-1.5.0b1/flytekit/exceptions/scopes.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/exceptions/system.py
│ ├── +++ flytekit-1.5.0b1/flytekit/exceptions/system.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/exceptions/user.py
│ ├── +++ flytekit-1.5.0b1/flytekit/exceptions/user.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extend/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extend/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/cloud_pickle_resolver.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/cloud_pickle_resolver.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/pytorch/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/pytorch/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/pytorch/checkpoint.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/pytorch/checkpoint.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/pytorch/native.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/pytorch/native.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/sklearn/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/sklearn/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/sklearn/native.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/sklearn/native.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/sqlite3/task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/sqlite3/task.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/extras/tensorflow/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/tensorflow/__init__.py
│ │┄ Files 6% similar despite different names
│ │ @@ -22,13 +22,14 @@
│ │      logger.warn(f"Unsupported version of tensorflow installed. Error message from protobuf library: {e}")
│ │      _tensorflow_installed = False
│ │  except (ImportError, OSError):
│ │      _tensorflow_installed = False
│ │  
│ │  
│ │  if _tensorflow_installed:
│ │ +    from .model import TensorFlowModelTransformer
│ │      from .record import TensorFlowRecordFileTransformer, TensorFlowRecordsDirTransformer
│ │  else:
│ │      logger.info(
│ │ -        "We won't register TensorFlowRecordFileTransformer and TensorFlowRecordsDirTransformer "
│ │ +        "We won't register TensorFlowRecordFileTransformer, TensorFlowRecordsDirTransformer and TensorFlowModelTransformer"
│ │          "because tensorflow is not installed."
│ │      )
│ │   --- flytekit-1.5.0b0/flytekit/extras/tensorflow/record.py
│ ├── +++ flytekit-1.5.0b1/flytekit/extras/tensorflow/record.py
│ │┄ Files 1% similar despite different names
│ │ @@ -155,15 +155,14 @@
│ │                  writer.write(val.SerializeToString())
│ │          ctx.file_access.upload_directory(local_dir, remote_path)
│ │          return Literal(scalar=Scalar(blob=Blob(metadata=meta, uri=remote_path)))
│ │  
│ │      def to_python_value(
│ │          self, ctx: FlyteContext, lv: Literal, expected_python_type: Type[TFRecordsDirectory]
│ │      ) -> TFRecordDatasetV2:
│ │ -
│ │          uri, metadata = extract_metadata_and_uri(lv, expected_python_type)
│ │          local_dir = ctx.file_access.get_random_local_directory()
│ │          ctx.file_access.get_data(uri, local_dir, is_multipart=True)
│ │          files = os.scandir(local_dir)
│ │          filenames = [os.path.join(local_dir, f.name) for f in files]
│ │          return tf.data.TFRecordDataset(
│ │              filenames=filenames,
│ │   --- flytekit-1.5.0b0/flytekit/interaction/parse_stdin.py
│ ├── +++ flytekit-1.5.0b1/flytekit/interaction/parse_stdin.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/interfaces/cli_identifiers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/interfaces/cli_identifiers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/interfaces/random.py
│ ├── +++ flytekit-1.5.0b1/flytekit/interfaces/random.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/interfaces/stats/client.py
│ ├── +++ flytekit-1.5.0b1/flytekit/interfaces/stats/client.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/interfaces/stats/taggable.py
│ ├── +++ flytekit-1.5.0b1/flytekit/interfaces/stats/taggable.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/loggers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/loggers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/admin/common.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/admin/common.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/admin/task_execution.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/admin/task_execution.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/admin/workflow.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/admin/workflow.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/annotation.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/annotation.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/array_job.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/array_job.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/common.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/common.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/catalog.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/catalog.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/compiler.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/compiler.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/condition.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/condition.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/errors.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/errors.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/execution.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/execution.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/identifier.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/identifier.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/types.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/types.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/core/workflow.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/core/workflow.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/documentation.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/documentation.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/dynamic_job.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/dynamic_job.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/execution.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/execution.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/filters.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/filters.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/interface.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/interface.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/launch_plan.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/launch_plan.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/literals.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/literals.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/matchable_resource.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/matchable_resource.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/named_entity.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/named_entity.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/node_execution.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/node_execution.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/presto.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/presto.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/project.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/project.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/qubole.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/qubole.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/schedule.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/schedule.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/security.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/security.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/task.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/task.py
│ │┄ Files 2% similar despite different names
│ │ @@ -864,40 +864,54 @@
│ │              annotations={k: v for k, v in pb2_object.annotations.items()}
│ │              if pb2_object.annotations is not None
│ │              else None,
│ │          )
│ │  
│ │  
│ │  class K8sPod(_common.FlyteIdlEntity):
│ │ -    def __init__(self, metadata: K8sObjectMetadata = None, pod_spec: typing.Dict[str, typing.Any] = None):
│ │ +    def __init__(
│ │ +        self,
│ │ +        metadata: K8sObjectMetadata = None,
│ │ +        pod_spec: typing.Dict[str, typing.Any] = None,
│ │ +        data_config: typing.Optional[DataLoadingConfig] = None,
│ │ +    ):
│ │          """
│ │          This defines a kubernetes pod target.  It will build the pod target during task execution
│ │          """
│ │          self._metadata = metadata
│ │          self._pod_spec = pod_spec
│ │ +        self._data_config = data_config
│ │  
│ │      @property
│ │      def metadata(self) -> K8sObjectMetadata:
│ │          return self._metadata
│ │  
│ │      @property
│ │      def pod_spec(self) -> typing.Dict[str, typing.Any]:
│ │          return self._pod_spec
│ │  
│ │ +    @property
│ │ +    def data_config(self) -> typing.Optional[DataLoadingConfig]:
│ │ +        return self._data_config
│ │ +
│ │      def to_flyte_idl(self) -> _core_task.K8sPod:
│ │          return _core_task.K8sPod(
│ │              metadata=self._metadata.to_flyte_idl(),
│ │              pod_spec=_json_format.Parse(_json.dumps(self.pod_spec), _struct.Struct()) if self.pod_spec else None,
│ │ +            data_config=self.data_config.to_flyte_idl() if self.data_config else None,
│ │          )
│ │  
│ │      @classmethod
│ │      def from_flyte_idl(cls, pb2_object: _core_task.K8sPod):
│ │          return cls(
│ │              metadata=K8sObjectMetadata.from_flyte_idl(pb2_object.metadata),
│ │              pod_spec=_json_format.MessageToDict(pb2_object.pod_spec) if pb2_object.HasField("pod_spec") else None,
│ │ +            data_config=DataLoadingConfig.from_flyte_idl(pb2_object.data_config)
│ │ +            if pb2_object.HasField("data_config")
│ │ +            else None,
│ │          )
│ │  
│ │  
│ │  class Sql(_common.FlyteIdlEntity):
│ │      class Dialect(object):
│ │          ANSI = 0
│ │          HIVE = 1
│ │   --- flytekit-1.5.0b0/flytekit/models/types.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/types.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/models/workflow_closure.py
│ ├── +++ flytekit-1.5.0b1/flytekit/models/workflow_closure.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/backfill.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/backfill.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/entities.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/entities.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/executions.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/executions.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/lazy_entity.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/lazy_entity.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/remote/remote.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/remote.py
│ │┄ Files 0% similar despite different names
│ │ @@ -3,15 +3,14 @@
│ │  with a Flyte backend in an interactive and programmatic way. This of this experience as kind of like the web UI
│ │  but in Python object form.
│ │  """
│ │  from __future__ import annotations
│ │  
│ │  import base64
│ │  import hashlib
│ │ -import importlib
│ │  import os
│ │  import pathlib
│ │  import tempfile
│ │  import time
│ │  import typing
│ │  import uuid
│ │  from base64 import b64encode
│ │ @@ -30,15 +29,14 @@
│ │  from flytekit.core import constants, utils
│ │  from flytekit.core.base_task import PythonTask
│ │  from flytekit.core.context_manager import FlyteContext, FlyteContextManager
│ │  from flytekit.core.data_persistence import FileAccessProvider
│ │  from flytekit.core.launch_plan import LaunchPlan
│ │  from flytekit.core.python_auto_container import PythonAutoContainerTask
│ │  from flytekit.core.reference_entity import ReferenceSpec
│ │ -from flytekit.core.tracker import get_full_module_path
│ │  from flytekit.core.type_engine import LiteralsResolver, TypeEngine
│ │  from flytekit.core.workflow import WorkflowBase
│ │  from flytekit.exceptions import user as user_exceptions
│ │  from flytekit.exceptions.user import (
│ │      FlyteEntityAlreadyExistsException,
│ │      FlyteEntityNotExistException,
│ │      FlyteValueException,
│ │ @@ -66,15 +64,15 @@
│ │  from flytekit.remote.backfill import create_backfill_workflow
│ │  from flytekit.remote.entities import FlyteLaunchPlan, FlyteNode, FlyteTask, FlyteTaskNode, FlyteWorkflow
│ │  from flytekit.remote.executions import FlyteNodeExecution, FlyteTaskExecution, FlyteWorkflowExecution
│ │  from flytekit.remote.interface import TypedInterface
│ │  from flytekit.remote.lazy_entity import LazyEntity
│ │  from flytekit.remote.remote_callable import RemoteEntity
│ │  from flytekit.tools.fast_registration import fast_package
│ │ -from flytekit.tools.script_mode import compress_single_script, hash_file
│ │ +from flytekit.tools.script_mode import compress_scripts, hash_file
│ │  from flytekit.tools.translator import (
│ │      FlyteControlPlaneEntity,
│ │      FlyteLocalEntity,
│ │      Options,
│ │      get_serializable,
│ │      get_serializable_launch_plan,
│ │  )
│ │ @@ -817,16 +815,15 @@
│ │          :return:
│ │          """
│ │          if image_config is None:
│ │              image_config = ImageConfig.auto_default_image()
│ │  
│ │          with tempfile.TemporaryDirectory() as tmp_dir:
│ │              archive_fname = pathlib.Path(os.path.join(tmp_dir, "script_mode.tar.gz"))
│ │ -            mod = importlib.import_module(module_name)
│ │ -            compress_single_script(source_path, str(archive_fname), get_full_module_path(mod, mod.__name__))
│ │ +            compress_scripts(source_path, str(archive_fname), module_name)
│ │              md5_bytes, upload_native_url = self._upload_file(
│ │                  archive_fname, project or self.default_project, domain or self.default_domain
│ │              )
│ │  
│ │          serialization_settings = SerializationSettings(
│ │              project=project,
│ │              domain=domain,
│ │   --- flytekit-1.5.0b0/flytekit/remote/remote_callable.py
│ ├── +++ flytekit-1.5.0b1/flytekit/remote/remote_callable.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/testing/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/testing/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/fast_registration.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/fast_registration.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/ignore.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/ignore.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/module_loader.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/module_loader.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/repo.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/repo.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/script_mode.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/script_mode.py
│ │┄ Files 22% similar despite different names
│ │ @@ -1,18 +1,23 @@
│ │  import gzip
│ │  import hashlib
│ │ +import importlib
│ │  import os
│ │  import shutil
│ │  import tarfile
│ │  import tempfile
│ │  import typing
│ │  from pathlib import Path
│ │  
│ │ +from flytekit import PythonFunctionTask
│ │ +from flytekit.core.tracker import get_full_module_path
│ │ +from flytekit.core.workflow import WorkflowBase
│ │  
│ │ -def compress_single_script(source_path: str, destination: str, full_module_name: str):
│ │ +
│ │ +def compress_scripts(source_path: str, destination: str, module_name: str):
│ │      """
│ │      Compresses the single script while maintaining the folder structure for that file.
│ │  
│ │      For example, given the follow file structure:
│ │      .
│ │      ├── flyte
│ │      │   ├── __init__.py
│ │ @@ -29,49 +34,74 @@
│ │      .
│ │      ├── flyte
│ │      │   ├── __init__.py
│ │      │   └── workflows
│ │      │       ├── example.py
│ │      │       └── __init__.py
│ │  
│ │ -    Note how `another_example.py` and `yet_another_example.py` were not copied to the destination.
│ │ +    Note: If `example.py` didn't import tasks or workflows from `another_example.py` and `yet_another_example.py`, these files were not copied to the destination..
│ │ +
│ │      """
│ │      with tempfile.TemporaryDirectory() as tmp_dir:
│ │          destination_path = os.path.join(tmp_dir, "code")
│ │ -        # This is the script relative path to the root of the project
│ │ -        script_relative_path = Path()
│ │ -        # For each package in pkgs, create a directory and copy the __init__.py in it.
│ │ -        # Skip the last package as that is the script file.
│ │ -        pkgs = full_module_name.split(".")
│ │ -        for p in pkgs[:-1]:
│ │ -            os.makedirs(os.path.join(destination_path, p))
│ │ -            source_path = os.path.join(source_path, p)
│ │ -            destination_path = os.path.join(destination_path, p)
│ │ -            script_relative_path = Path(script_relative_path, p)
│ │ -            init_file = Path(os.path.join(source_path, "__init__.py"))
│ │ -            if init_file.exists():
│ │ -                shutil.copy(init_file, Path(os.path.join(tmp_dir, "code", script_relative_path, "__init__.py")))
│ │ -
│ │ -        # Ensure destination path exists to cover the case of a single file and no modules.
│ │ -        os.makedirs(destination_path, exist_ok=True)
│ │ -        script_file = Path(source_path, f"{pkgs[-1]}.py")
│ │ -        script_file_destination = Path(destination_path, f"{pkgs[-1]}.py")
│ │ -        # Build the final script relative path and copy it to a known place.
│ │ -        shutil.copy(
│ │ -            script_file,
│ │ -            script_file_destination,
│ │ -        )
│ │ +
│ │ +        visited: typing.List[str] = []
│ │ +        copy_module_to_destination(source_path, destination_path, module_name, visited)
│ │          tar_path = os.path.join(tmp_dir, "tmp.tar")
│ │          with tarfile.open(tar_path, "w") as tar:
│ │              tar.add(os.path.join(tmp_dir, "code"), arcname="", filter=tar_strip_file_attributes)
│ │          with gzip.GzipFile(filename=destination, mode="wb", mtime=0) as gzipped:
│ │              with open(tar_path, "rb") as tar_file:
│ │                  gzipped.write(tar_file.read())
│ │  
│ │  
│ │ +def copy_module_to_destination(
│ │ +    original_source_path: str, original_destination_path: str, module_name: str, visited: typing.List[str]
│ │ +):
│ │ +    """
│ │ +    Copy the module (file) to the destination directory. If the module relative imports other modules, flytekit will
│ │ +    recursively copy them as well.
│ │ +    """
│ │ +    mod = importlib.import_module(module_name)
│ │ +    full_module_name = get_full_module_path(mod, mod.__name__)
│ │ +    if full_module_name in visited:
│ │ +        return
│ │ +    visited.append(full_module_name)
│ │ +
│ │ +    source_path = original_source_path
│ │ +    destination_path = original_destination_path
│ │ +    pkgs = full_module_name.split(".")
│ │ +
│ │ +    for p in pkgs[:-1]:
│ │ +        os.makedirs(os.path.join(destination_path, p), exist_ok=True)
│ │ +        destination_path = os.path.join(destination_path, p)
│ │ +        source_path = os.path.join(source_path, p)
│ │ +        init_file = Path(os.path.join(source_path, "__init__.py"))
│ │ +        if init_file.exists():
│ │ +            shutil.copy(init_file, Path(os.path.join(destination_path, "__init__.py")))
│ │ +
│ │ +    # Ensure destination path exists to cover the case of a single file and no modules.
│ │ +    os.makedirs(destination_path, exist_ok=True)
│ │ +    script_file = Path(source_path, f"{pkgs[-1]}.py")
│ │ +    script_file_destination = Path(destination_path, f"{pkgs[-1]}.py")
│ │ +    # Build the final script relative path and copy it to a known place.
│ │ +    shutil.copy(
│ │ +        script_file,
│ │ +        script_file_destination,
│ │ +    )
│ │ +
│ │ +    # Try to copy other files to destination if tasks or workflows aren't in the same file
│ │ +    for flyte_entity_name in mod.__dict__:
│ │ +        flyte_entity = mod.__dict__[flyte_entity_name]
│ │ +        if isinstance(flyte_entity, (PythonFunctionTask, WorkflowBase)) and flyte_entity.instantiated_in:
│ │ +            copy_module_to_destination(
│ │ +                original_source_path, original_destination_path, flyte_entity.instantiated_in, visited
│ │ +            )
│ │ +
│ │ +
│ │  # Takes in a TarInfo and returns the modified TarInfo:
│ │  # https://docs.python.org/3/library/tarfile.html#tarinfo-objects
│ │  # intented to be passed as a filter to tarfile.add
│ │  # https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.add
│ │  def tar_strip_file_attributes(tar_info: tarfile.TarInfo) -> tarfile.TarInfo:
│ │      # set time to epoch timestamp 0, aka 00:00:00 UTC on 1 January 1970
│ │      # note that when extracting this tarfile, this time will be shown as the modified date
│ │   --- flytekit-1.5.0b0/flytekit/tools/serialize_helpers.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/serialize_helpers.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/subprocess.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/subprocess.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/tools/translator.py
│ ├── +++ flytekit-1.5.0b1/flytekit/tools/translator.py
│ │┄ Files 1% similar despite different names
│ │ @@ -5,14 +5,15 @@
│ │  from typing import Callable, Dict, List, Optional, Tuple, Union
│ │  
│ │  from flytekit import PythonFunctionTask, SourceCode
│ │  from flytekit.configuration import SerializationSettings
│ │  from flytekit.core import constants as _common_constants
│ │  from flytekit.core.base_task import PythonTask
│ │  from flytekit.core.condition import BranchNode
│ │ +from flytekit.core.container_task import ContainerTask
│ │  from flytekit.core.gate import Gate
│ │  from flytekit.core.launch_plan import LaunchPlan, ReferenceLaunchPlan
│ │  from flytekit.core.map_task import MapPythonTask
│ │  from flytekit.core.node import Node
│ │  from flytekit.core.python_auto_container import PythonAutoContainerTask
│ │  from flytekit.core.reference_entity import ReferenceEntity, ReferenceSpec, ReferenceTemplate
│ │  from flytekit.core.task import ReferenceTask
│ │ @@ -185,15 +186,15 @@
│ │              # tasks that rely on user code defined in the container. This should be encapsulated by the auto container
│ │              # parent class
│ │              container._args = prefix_with_fast_execute(settings, container.args)
│ │  
│ │          # If the pod spec is not None, we have to get it again, because the one we retrieved above will be incorrect.
│ │          # The reason we have to call get_k8s_pod again, instead of just modifying the command in this file, is because
│ │          # the pod spec is a K8s library object, and we shouldn't be messing around with it in this file.
│ │ -        elif pod:
│ │ +        elif pod and not isinstance(entity, ContainerTask):
│ │              if isinstance(entity, MapPythonTask):
│ │                  entity.set_command_prefix(get_command_prefix_for_fast_execute(settings))
│ │                  pod = entity.get_k8s_pod(settings)
│ │              else:
│ │                  entity.set_command_fn(_fast_serialize_command_fn(settings, entity))
│ │                  pod = entity.get_k8s_pod(settings)
│ │                  entity.reset_command_fn()
│ │   --- flytekit-1.5.0b0/flytekit/types/directory/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/directory/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/directory/types.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/directory/types.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/file/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/file/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/file/file.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/file/file.py
│ │┄ Files 2% similar despite different names
│ │ @@ -4,14 +4,15 @@
│ │  import pathlib
│ │  import typing
│ │  from contextlib import contextmanager
│ │  from dataclasses import dataclass, field
│ │  
│ │  from dataclasses_json import config, dataclass_json
│ │  from marshmallow import fields
│ │ +from typing_extensions import Annotated, get_args, get_origin
│ │  
│ │  from flytekit.core.context_manager import FlyteContext, FlyteContextManager
│ │  from flytekit.core.type_engine import TypeEngine, TypeTransformer, TypeTransformerFailedError
│ │  from flytekit.loggers import logger
│ │  from flytekit.models.core.types import BlobType
│ │  from flytekit.models.literals import Blob, BlobMetadata, Literal, Scalar
│ │  from flytekit.models.types import LiteralType
│ │ @@ -331,14 +332,18 @@
│ │      ) -> Literal:
│ │          remote_path = None
│ │          should_upload = True
│ │  
│ │          if python_val is None:
│ │              raise TypeTransformerFailedError("None value cannot be converted to a file.")
│ │  
│ │ +        # Correctly handle `Annotated[FlyteFile, ...]` by extracting the origin type
│ │ +        if get_origin(python_type) is Annotated:
│ │ +            python_type = get_args(python_type)[0]
│ │ +
│ │          if not (python_type is os.PathLike or issubclass(python_type, FlyteFile)):
│ │              raise ValueError(f"Incorrect type {python_type}, must be either a FlyteFile or os.PathLike")
│ │  
│ │          # information used by all cases
│ │          meta = BlobMetadata(type=self._blob_type(format=FlyteFilePathTransformer.get_format(python_type)))
│ │  
│ │          if isinstance(python_val, FlyteFile):
│ │   --- flytekit-1.5.0b0/flytekit/types/numpy/ndarray.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/numpy/ndarray.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/pickle/pickle.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/pickle/pickle.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/schema/types.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/schema/types.py
│ │┄ Files 1% similar despite different names
│ │ @@ -182,15 +182,14 @@
│ │  @dataclass_json
│ │  @dataclass
│ │  class FlyteSchema(object):
│ │      remote_path: typing.Optional[str] = field(default=None, metadata=config(mm_field=fields.String()))
│ │      """
│ │      This is the main schema class that users should use.
│ │      """
│ │ -    logger.warning("FlyteSchema is deprecated, use Structured Dataset instead.")
│ │  
│ │      @classmethod
│ │      def columns(cls) -> typing.Dict[str, typing.Type]:
│ │          return {}
│ │  
│ │      @classmethod
│ │      def column_names(cls) -> typing.List[str]:
│ │ @@ -199,14 +198,15 @@
│ │      @classmethod
│ │      def format(cls) -> SchemaFormat:
│ │          return SchemaFormat.PARQUET
│ │  
│ │      def __class_getitem__(
│ │          cls, columns: typing.Dict[str, typing.Type], fmt: SchemaFormat = SchemaFormat.PARQUET
│ │      ) -> Type[FlyteSchema]:
│ │ +        logger.warning("FlyteSchema is deprecated, use Structured Dataset instead.")
│ │          if columns is None:
│ │              return FlyteSchema
│ │  
│ │          if not isinstance(columns, dict):
│ │              raise AssertionError(
│ │                  f"Columns should be specified as an ordered dict of column names and their types, received {type(columns)}"
│ │              )
│ │ @@ -236,14 +236,15 @@
│ │      def __init__(
│ │          self,
│ │          local_path: typing.Optional[str] = None,
│ │          remote_path: typing.Optional[str] = None,
│ │          supported_mode: SchemaOpenMode = SchemaOpenMode.WRITE,
│ │          downloader: typing.Optional[typing.Callable] = None,
│ │      ):
│ │ +        logger.warning("FlyteSchema is deprecated, use Structured Dataset instead.")
│ │          if supported_mode == SchemaOpenMode.READ and remote_path is None:
│ │              raise ValueError("To create a FlyteSchema in read mode, remote_path is required")
│ │          if (
│ │              supported_mode == SchemaOpenMode.WRITE
│ │              and local_path is None
│ │              and FlyteContextManager.current_context().file_access is None
│ │          ):
│ │ @@ -323,15 +324,15 @@
│ │          _np.int64: SchemaType.SchemaColumn.SchemaColumnType.INTEGER,
│ │          _np.uint32: SchemaType.SchemaColumn.SchemaColumnType.INTEGER,
│ │          _np.uint64: SchemaType.SchemaColumn.SchemaColumnType.INTEGER,
│ │          int: SchemaType.SchemaColumn.SchemaColumnType.INTEGER,
│ │          _np.float32: SchemaType.SchemaColumn.SchemaColumnType.FLOAT,
│ │          _np.float64: SchemaType.SchemaColumn.SchemaColumnType.FLOAT,
│ │          float: SchemaType.SchemaColumn.SchemaColumnType.FLOAT,
│ │ -        _np.bool: SchemaType.SchemaColumn.SchemaColumnType.BOOLEAN,  # type: ignore
│ │ +        _np.bool_: SchemaType.SchemaColumn.SchemaColumnType.BOOLEAN,  # type: ignore
│ │          bool: SchemaType.SchemaColumn.SchemaColumnType.BOOLEAN,
│ │          _np.datetime64: SchemaType.SchemaColumn.SchemaColumnType.DATETIME,
│ │          _datetime.datetime: SchemaType.SchemaColumn.SchemaColumnType.DATETIME,
│ │          _np.timedelta64: SchemaType.SchemaColumn.SchemaColumnType.DURATION,
│ │          _datetime.timedelta: SchemaType.SchemaColumn.SchemaColumnType.DURATION,
│ │          _np.string_: SchemaType.SchemaColumn.SchemaColumnType.STRING,
│ │          _np.str_: SchemaType.SchemaColumn.SchemaColumnType.STRING,
│ │   --- flytekit-1.5.0b0/flytekit/types/schema/types_pandas.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/schema/types_pandas.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/structured/__init__.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/structured/__init__.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/structured/basic_dfs.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/structured/basic_dfs.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/structured/bigquery.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/structured/bigquery.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit/types/structured/structured_dataset.py
│ ├── +++ flytekit-1.5.0b1/flytekit/types/structured/structured_dataset.py
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/flytekit.egg-info/PKG-INFO
│ ├── +++ flytekit-1.5.0b1/flytekit.egg-info/PKG-INFO
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: flytekit
│ │ -Version: 1.5.0b0
│ │ +Version: 1.5.0b1
│ │  Summary: Flyte SDK for Python
│ │  Home-page: https://github.com/flyteorg/flytekit
│ │  Maintainer: Flyte Contributors
│ │  Maintainer-email: admin@flyte.org
│ │  License: apache2
│ │  Classifier: Intended Audience :: Science/Research
│ │  Classifier: Intended Audience :: Developers
│ │ @@ -13,15 +13,15 @@
│ │  Classifier: Programming Language :: Python :: 3.9
│ │  Classifier: Programming Language :: Python :: 3.10
│ │  Classifier: Topic :: Scientific/Engineering
│ │  Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
│ │  Classifier: Topic :: Software Development
│ │  Classifier: Topic :: Software Development :: Libraries
│ │  Classifier: Topic :: Software Development :: Libraries :: Python Modules
│ │ -Requires-Python: >=3.8,<3.11
│ │ +Requires-Python: >=3.8,<3.12
│ │  Description-Content-Type: text/markdown
│ │  License-File: LICENSE
│ │  
│ │  <p align="center">
│ │      <img src="https://raw.githubusercontent.com/flyteorg/static-resources/main/common/flyte_circle_gradient_1_4x4.png" alt="Flyte Logo" width="100">
│ │  </p>
│ │  <h1 align="center">
│ │ ├── html2text {}
│ │ │ @@ -1,19 +1,19 @@
│ │ │ -Metadata-Version: 2.1 Name: flytekit Version: 1.5.0b0 Summary: Flyte SDK for
│ │ │ +Metadata-Version: 2.1 Name: flytekit Version: 1.5.0b1 Summary: Flyte SDK for
│ │ │  Python Home-page: https://github.com/flyteorg/flytekit Maintainer: Flyte
│ │ │  Contributors Maintainer-email: admin@flyte.org License: apache2 Classifier:
│ │ │  Intended Audience :: Science/Research Classifier: Intended Audience ::
│ │ │  Developers Classifier: License :: OSI Approved :: Apache Software License
│ │ │  Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
│ │ │  Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
│ │ │  Classifier: Topic :: Scientific/Engineering Classifier: Topic :: Scientific/
│ │ │  Engineering :: Artificial Intelligence Classifier: Topic :: Software
│ │ │  Development Classifier: Topic :: Software Development :: Libraries Classifier:
│ │ │  Topic :: Software Development :: Libraries :: Python Modules Requires-Python:
│ │ │ ->=3.8,<3.11 Description-Content-Type: text/markdown License-File: LICENSE
│ │ │ +>=3.8,<3.12 Description-Content-Type: text/markdown License-File: LICENSE
│ │ │                                   [Flyte Logo]
│ │ │                           ****** Flytekit Python ******
│ │ │              Flytekit Python is the Python SDK built on top of Flyte
│ │ │                     **** Plugins  Â·  Contribution_Guide ****
│ │ │  [![PyPI version fury.io](https://badge.fury.io/py/flytekit.svg)](https://
│ │ │  pypi.python.org/pypi/flytekit/) [![PyPI download day](https://img.shields.io/
│ │ │  pypi/dd/flytekit.svg)](https://pypi.python.org/pypi/flytekit/) [![PyPI download
│ │   --- flytekit-1.5.0b0/flytekit.egg-info/SOURCES.txt
│ ├── +++ flytekit-1.5.0b1/flytekit.egg-info/SOURCES.txt
│ │┄ Files 0% similar despite different names
│ │ @@ -21,14 +21,15 @@
│ │  flytekit/clients/raw.py
│ │  flytekit/clients/auth/__init__.py
│ │  flytekit/clients/auth/auth_client.py
│ │  flytekit/clients/auth/authenticator.py
│ │  flytekit/clients/auth/default_html.py
│ │  flytekit/clients/auth/exceptions.py
│ │  flytekit/clients/auth/keyring.py
│ │ +flytekit/clients/auth/token_client.py
│ │  flytekit/clients/grpc_utils/__init__.py
│ │  flytekit/clients/grpc_utils/auth_interceptor.py
│ │  flytekit/clients/grpc_utils/wrap_exception_interceptor.py
│ │  flytekit/clis/__init__.py
│ │  flytekit/clis/helpers.py
│ │  flytekit/clis/flyte_cli/__init__.py
│ │  flytekit/clis/flyte_cli/example.config
│ │ @@ -40,14 +41,15 @@
│ │  flytekit/clis/sdk_in_container/init.py
│ │  flytekit/clis/sdk_in_container/local_cache.py
│ │  flytekit/clis/sdk_in_container/package.py
│ │  flytekit/clis/sdk_in_container/pyflyte.py
│ │  flytekit/clis/sdk_in_container/register.py
│ │  flytekit/clis/sdk_in_container/run.py
│ │  flytekit/clis/sdk_in_container/serialize.py
│ │ +flytekit/clis/sdk_in_container/utils.py
│ │  flytekit/configuration/__init__.py
│ │  flytekit/configuration/default_images.py
│ │  flytekit/configuration/feature_flags.py
│ │  flytekit/configuration/file.py
│ │  flytekit/configuration/internal.py
│ │  flytekit/core/__init__.py
│ │  flytekit/core/annotation.py
│ │ @@ -109,14 +111,15 @@
│ │  flytekit/extras/sklearn/__init__.py
│ │  flytekit/extras/sklearn/native.py
│ │  flytekit/extras/sqlite3/__init__.py
│ │  flytekit/extras/sqlite3/task.py
│ │  flytekit/extras/tasks/__init__.py
│ │  flytekit/extras/tasks/shell.py
│ │  flytekit/extras/tensorflow/__init__.py
│ │ +flytekit/extras/tensorflow/model.py
│ │  flytekit/extras/tensorflow/record.py
│ │  flytekit/interaction/__init__.py
│ │  flytekit/interaction/parse_stdin.py
│ │  flytekit/interfaces/__init__.py
│ │  flytekit/interfaces/cli_identifiers.py
│ │  flytekit/interfaces/random.py
│ │  flytekit/interfaces/stats/__init__.py
│ │   --- flytekit-1.5.0b0/flytekit.egg-info/requires.txt
│ ├── +++ flytekit-1.5.0b1/flytekit.egg-info/requires.txt
│ │┄ Files 14% similar despite different names
│ │ @@ -1,9 +1,9 @@
│ │  googleapis-common-protos>=1.57
│ │ -flyteidl<1.4.0,>=1.3.5
│ │ +flyteidl<1.4.0,>=1.3.12
│ │  wheel<1.0.0,>=0.30.0
│ │  pandas<2.0.0,>=1.0.0
│ │  pyarrow<11.0.0,>=4.0.0
│ │  click<9.0,>=6.6
│ │  croniter<4.0.0,>=0.3.20
│ │  deprecated<2.0,>=1.0
│ │  docker<7.0.0,>=4.0.0
│ │ @@ -33,13 +33,13 @@
│ │  natsort>=7.0.1
│ │  docker-image-py>=0.1.10
│ │  typing_extensions
│ │  docstring-parser>=0.9.0
│ │  diskcache>=5.2.1
│ │  cloudpickle>=2.0.0
│ │  cookiecutter>=1.7.3
│ │ -numpy<1.24.0
│ │ +numpy
│ │  gitpython
│ │  kubernetes>=12.0.1
│ │  
│ │  [:python_version < "3.8.0"]
│ │  singledispatchmethod
│ │   --- flytekit-1.5.0b0/flytekit_scripts/flytekit_build_image.sh
│ ├── +++ flytekit-1.5.0b1/flytekit_scripts/flytekit_build_image.sh
│ │┄ Files identical despite different names
│ │   --- flytekit-1.5.0b0/setup.py
│ ├── +++ flytekit-1.5.0b1/setup.py
│ │┄ Files 10% similar despite different names
│ │ @@ -1,12 +1,12 @@
│ │  from setuptools import find_packages, setup  # noqa
│ │  
│ │  extras_require = {}
│ │  
│ │ -__version__ = "1.5.0b0"
│ │ +__version__ = "1.5.0b1"
│ │  
│ │  setup(
│ │      name="flytekit",
│ │      version=__version__,
│ │      maintainer="Flyte Contributors",
│ │      maintainer_email="admin@flyte.org",
│ │      packages=find_packages(
│ │ @@ -25,15 +25,15 @@
│ │              "pyflyte-map-execute=flytekit.bin.entrypoint:map_execute_task_cmd",
│ │              "pyflyte=flytekit.clis.sdk_in_container.pyflyte:main",
│ │              "flyte-cli=flytekit.clis.flyte_cli.main:_flyte_cli",
│ │          ]
│ │      },
│ │      install_requires=[
│ │          "googleapis-common-protos>=1.57",
│ │ -        "flyteidl>=1.3.5,<1.4.0",
│ │ +        "flyteidl>=1.3.12,<1.4.0",
│ │          "wheel>=0.30.0,<1.0.0",
│ │          "pandas>=1.0.0,<2.0.0",
│ │          "pyarrow>=4.0.0,<11.0.0",
│ │          "click>=6.6,<9.0",
│ │          "croniter>=0.3.20,<4.0.0",
│ │          "deprecated>=1.0,<2.0",
│ │          "docker>=4.0.0,<7.0.0",
│ │ @@ -66,28 +66,26 @@
│ │          "docker-image-py>=0.1.10",
│ │          "singledispatchmethod; python_version < '3.8.0'",
│ │          "typing_extensions",
│ │          "docstring-parser>=0.9.0",
│ │          "diskcache>=5.2.1",
│ │          "cloudpickle>=2.0.0",
│ │          "cookiecutter>=1.7.3",
│ │ -        # TODO: We should remove mentions to the deprecated numpy
│ │ -        # aliases. More details in https://github.com/flyteorg/flyte/issues/3166
│ │ -        "numpy<1.24.0",
│ │ +        "numpy",
│ │          "gitpython",
│ │          "kubernetes>=12.0.1",
│ │      ],
│ │      extras_require=extras_require,
│ │      scripts=[
│ │          "flytekit_scripts/flytekit_build_image.sh",
│ │          "flytekit_scripts/flytekit_venv",
│ │          "flytekit/bin/entrypoint.py",
│ │      ],
│ │      license="apache2",
│ │ -    python_requires=">=3.8,<3.11",
│ │ +    python_requires=">=3.8,<3.12",
│ │      classifiers=[
│ │          "Intended Audience :: Science/Research",
│ │          "Intended Audience :: Developers",
│ │          "License :: OSI Approved :: Apache Software License",
│ │          "Programming Language :: Python :: 3.8",
│ │          "Programming Language :: Python :: 3.9",
│ │          "Programming Language :: Python :: 3.10",
