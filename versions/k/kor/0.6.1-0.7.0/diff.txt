--- tmp/kor-0.6.1.tar.gz
+++ tmp/kor-0.7.0.tar.gz
â”œâ”€â”€ filetype from file(1)
â”‚ @@ -1 +1 @@
â”‚ -gzip compressed data, was "kor-0.6.1.tar", max compression
â”‚ +gzip compressed data, was "kor-0.7.0.tar", max compression
â”‚   --- kor-0.6.1.tar
â”œâ”€â”€ +++ kor-0.7.0.tar
â”‚ â”œâ”€â”€ file list
â”‚ â”‚ @@ -1,24 +1,24 @@
â”‚ â”‚ --rw-r--r--   0        0        0     1071 2023-04-04 17:58:16.932065 kor-0.6.1/LICENSE
â”‚ â”‚ --rw-r--r--   0        0        0     4273 2023-04-04 17:58:16.932065 kor-0.6.1/README.md
â”‚ â”‚ --rw-r--r--   0        0        0      632 2023-04-04 17:58:16.936065 kor-0.6.1/kor/__init__.py
â”‚ â”‚ --rw-r--r--   0        0        0     5123 2023-04-04 17:58:16.936065 kor-0.6.1/kor/adapters.py
â”‚ â”‚ --rw-r--r--   0        0        0      578 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/__init__.py
â”‚ â”‚ --rw-r--r--   0        0        0     4744 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/csv_data.py
â”‚ â”‚ --rw-r--r--   0        0        0     3513 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/encode.py
â”‚ â”‚ --rw-r--r--   0        0        0     2815 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/json_data.py
â”‚ â”‚ --rw-r--r--   0        0        0     2133 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/parser.py
â”‚ â”‚ --rw-r--r--   0        0        0     1515 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/typedefs.py
â”‚ â”‚ --rw-r--r--   0        0        0      514 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/utils.py
â”‚ â”‚ --rw-r--r--   0        0        0     6093 2023-04-04 17:58:16.936065 kor-0.6.1/kor/encoders/xml.py
â”‚ â”‚ --rw-r--r--   0        0        0     4103 2023-04-04 17:58:16.936065 kor-0.6.1/kor/examples.py
â”‚ â”‚ --rw-r--r--   0        0        0      225 2023-04-04 17:58:16.936065 kor-0.6.1/kor/exceptions.py
â”‚ â”‚ --rw-r--r--   0        0        0     2721 2023-04-04 17:58:16.936065 kor-0.6.1/kor/extraction.py
â”‚ â”‚ --rw-r--r--   0        0        0     9553 2023-04-04 17:58:16.936065 kor-0.6.1/kor/nodes.py
â”‚ â”‚ --rw-r--r--   0        0        0     5132 2023-04-04 17:58:16.936065 kor-0.6.1/kor/prompts.py
â”‚ â”‚ --rw-r--r--   0        0        0        0 2023-04-04 17:58:16.936065 kor-0.6.1/kor/py.typed
â”‚ â”‚ --rw-r--r--   0        0        0     4493 2023-04-04 17:58:16.936065 kor-0.6.1/kor/type_descriptors.py
â”‚ â”‚ --rw-r--r--   0        0        0     2055 2023-04-04 17:58:16.936065 kor-0.6.1/kor/validators.py
â”‚ â”‚ --rw-r--r--   0        0        0      181 2023-04-04 17:58:16.936065 kor-0.6.1/kor/version.py
â”‚ â”‚ --rw-r--r--   0        0        0     1935 2023-04-04 17:58:16.936065 kor-0.6.1/pyproject.toml
â”‚ â”‚ --rw-r--r--   0        0        0     5148 1970-01-01 00:00:00.000000 kor-0.6.1/setup.py
â”‚ â”‚ --rw-r--r--   0        0        0     4984 1970-01-01 00:00:00.000000 kor-0.6.1/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0        0        0     1071 2023-04-06 13:54:36.507368 kor-0.7.0/LICENSE
â”‚ â”‚ +-rw-r--r--   0        0        0     4273 2023-04-06 13:54:36.507368 kor-0.7.0/README.md
â”‚ â”‚ +-rw-r--r--   0        0        0      632 2023-04-06 13:54:36.511369 kor-0.7.0/kor/__init__.py
â”‚ â”‚ +-rw-r--r--   0        0        0     5123 2023-04-06 13:54:36.511369 kor-0.7.0/kor/adapters.py
â”‚ â”‚ +-rw-r--r--   0        0        0      578 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/__init__.py
â”‚ â”‚ +-rw-r--r--   0        0        0     4744 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/csv_data.py
â”‚ â”‚ +-rw-r--r--   0        0        0     3513 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/encode.py
â”‚ â”‚ +-rw-r--r--   0        0        0     2815 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/json_data.py
â”‚ â”‚ +-rw-r--r--   0        0        0     2133 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/parser.py
â”‚ â”‚ +-rw-r--r--   0        0        0     1515 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/typedefs.py
â”‚ â”‚ +-rw-r--r--   0        0        0      514 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/utils.py
â”‚ â”‚ +-rw-r--r--   0        0        0     6093 2023-04-06 13:54:36.511369 kor-0.7.0/kor/encoders/xml.py
â”‚ â”‚ +-rw-r--r--   0        0        0     4103 2023-04-06 13:54:36.511369 kor-0.7.0/kor/examples.py
â”‚ â”‚ +-rw-r--r--   0        0        0      225 2023-04-06 13:54:36.511369 kor-0.7.0/kor/exceptions.py
â”‚ â”‚ +-rw-r--r--   0        0        0     3261 2023-04-06 13:54:36.511369 kor-0.7.0/kor/extraction.py
â”‚ â”‚ +-rw-r--r--   0        0        0     6884 2023-04-06 13:54:36.511369 kor-0.7.0/kor/nodes.py
â”‚ â”‚ +-rw-r--r--   0        0        0     5756 2023-04-06 13:54:36.511369 kor-0.7.0/kor/prompts.py
â”‚ â”‚ +-rw-r--r--   0        0        0        0 2023-04-06 13:54:36.511369 kor-0.7.0/kor/py.typed
â”‚ â”‚ +-rw-r--r--   0        0        0     4493 2023-04-06 13:54:36.511369 kor-0.7.0/kor/type_descriptors.py
â”‚ â”‚ +-rw-r--r--   0        0        0     2055 2023-04-06 13:54:36.511369 kor-0.7.0/kor/validators.py
â”‚ â”‚ +-rw-r--r--   0        0        0      181 2023-04-06 13:54:36.511369 kor-0.7.0/kor/version.py
â”‚ â”‚ +-rw-r--r--   0        0        0     1935 2023-04-06 13:54:36.511369 kor-0.7.0/pyproject.toml
â”‚ â”‚ +-rw-r--r--   0        0        0     5148 1970-01-01 00:00:00.000000 kor-0.7.0/setup.py
â”‚ â”‚ +-rw-r--r--   0        0        0     4984 1970-01-01 00:00:00.000000 kor-0.7.0/PKG-INFO
â”‚ â”‚   --- kor-0.6.1/LICENSE
â”‚ â”œâ”€â”€ +++ kor-0.7.0/LICENSE
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/README.md
â”‚ â”œâ”€â”€ +++ kor-0.7.0/README.md
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/__init__.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/__init__.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/adapters.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/adapters.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/__init__.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/__init__.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/csv_data.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/csv_data.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/encode.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/encode.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/json_data.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/json_data.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/parser.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/parser.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/typedefs.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/typedefs.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/utils.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/utils.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/encoders/xml.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/encoders/xml.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/examples.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/examples.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/extraction.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/extraction.py
â”‚ â”‚â”„ Files 25% similar despite different names
â”‚ â”‚ @@ -1,9 +1,10 @@
â”‚ â”‚  from typing import Any, Optional, Type, Union
â”‚ â”‚  
â”‚ â”‚ +from langchain import PromptTemplate
â”‚ â”‚  from langchain.chains import LLMChain
â”‚ â”‚  from langchain.schema import BaseLanguageModel
â”‚ â”‚  
â”‚ â”‚  from kor.encoders import Encoder, InputFormatter, initialize_encoder
â”‚ â”‚  from kor.nodes import Object
â”‚ â”‚  from kor.prompts import create_langchain_prompt
â”‚ â”‚  from kor.type_descriptors import TypeDescriptor, initialize_type_descriptors
â”‚ â”‚ @@ -16,33 +17,39 @@
â”‚ â”‚      llm: BaseLanguageModel,
â”‚ â”‚      node: Object,
â”‚ â”‚      *,
â”‚ â”‚      encoder_or_encoder_class: Union[Type[Encoder], Encoder, str] = "csv",
â”‚ â”‚      type_descriptor: Union[TypeDescriptor, str] = "typescript",
â”‚ â”‚      validator: Optional[Validator] = None,
â”‚ â”‚      input_formatter: InputFormatter = None,
â”‚ â”‚ +    instruction_template: Optional[PromptTemplate] = None,
â”‚ â”‚      **encoder_kwargs: Any,
â”‚ â”‚  ) -> LLMChain:
â”‚ â”‚      """Create an extraction chain.
â”‚ â”‚      
â”‚ â”‚      Args:
â”‚ â”‚          llm: the language model used for extraction
â”‚ â”‚          node: the schematic description of what to extract from text
â”‚ â”‚          encoder_or_encoder_class: Either an encoder instance, an encoder class
â”‚ â”‚                                    or a string representing the encoder class
â”‚ â”‚          type_descriptor: either a TypeDescriptor or a string representing the type \
â”‚ â”‚                           descriptor name
â”‚ â”‚          validator: optional validator to use for validation
â”‚ â”‚          input_formatter: the formatter to use for encoding the input. Used for \
â”‚ â”‚                           both input examples and the text to be analyzed.
â”‚ â”‚ -                         
â”‚ â”‚              * `None`: use for single sentences or single paragraph, no formatting
â”‚ â”‚              * `triple_quotes`: for long text, surround input with \"\"\"
â”‚ â”‚              * `text_prefix`: for long text, triple_quote with `TEXT: ` prefix
â”‚ â”‚              * `Callable`: user provided function
â”‚ â”‚ +        instruction_template: optional prompt template to use, use to over-ride prompt
â”‚ â”‚ +             used for generating the instruction section of the prompt.
â”‚ â”‚ +             It accepts 2 optional input variables:
â”‚ â”‚ +             * "type_description": type description of the node (from TypeDescriptor)
â”‚ â”‚ +             * "format_instructions": information on how to format the output
â”‚ â”‚ +               (from Encoder)
â”‚ â”‚          encoder_kwargs: Keyword arguments to pass to the encoder class
â”‚ â”‚  
â”‚ â”‚      Returns:
â”‚ â”‚          A langchain chain
â”‚ â”‚          
â”‚ â”‚          
â”‚ â”‚      Examples:
â”‚ â”‚ @@ -62,11 +69,12 @@
â”‚ â”‚      type_descriptor_to_use = initialize_type_descriptors(type_descriptor)
â”‚ â”‚      return LLMChain(
â”‚ â”‚          llm=llm,
â”‚ â”‚          prompt=create_langchain_prompt(
â”‚ â”‚              node,
â”‚ â”‚              encoder,
â”‚ â”‚              type_descriptor_to_use,
â”‚ â”‚ -            validator,
â”‚ â”‚ +            validator=validator,
â”‚ â”‚ +            instruction_template=instruction_template,
â”‚ â”‚              input_formatter=input_formatter,
â”‚ â”‚          ),
â”‚ â”‚      )
â”‚ â”‚   --- kor-0.6.1/kor/nodes.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/nodes.py
â”‚ â”‚â”„ Files 22% similar despite different names
â”‚ â”‚ @@ -1,46 +1,36 @@
â”‚ â”‚  """Definitions of input elements."""
â”‚ â”‚  import abc
â”‚ â”‚  import copy
â”‚ â”‚ -import inspect
â”‚ â”‚ -import operator
â”‚ â”‚  import re
â”‚ â”‚  from typing import (
â”‚ â”‚      Any,
â”‚ â”‚      Generic,
â”‚ â”‚ -    List,
â”‚ â”‚      Mapping,
â”‚ â”‚      Optional,
â”‚ â”‚      Sequence,
â”‚ â”‚      Tuple,
â”‚ â”‚      TypeVar,
â”‚ â”‚      Union,
â”‚ â”‚  )
â”‚ â”‚  
â”‚ â”‚ +from pydantic import BaseModel, validator
â”‚ â”‚ +
â”‚ â”‚  # For now, limit what's allowed for identifiers.
â”‚ â”‚  # The main constraints
â”‚ â”‚  # 1) Relying on HTML parser to parse output
â”‚ â”‚  # 2) One of the type descriptors is TypeScript, so we want
â”‚ â”‚  #    to produce valid TypeScript identifiers.
â”‚ â”‚  # We can lift the constraints later if it becomes important,
â”‚ â”‚  # not worth the effort for a v0.
â”‚ â”‚  VALID_IDENTIFIER_PATTERN = re.compile(r"^[a-z_][0-9a-z_]*$")
â”‚ â”‚  
â”‚ â”‚  T = TypeVar("T")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def _get_all_slots(node: "AbstractSchemaNode") -> List[str]:
â”‚ â”‚ -    """Get a list of all slots."""
â”‚ â”‚ -    slots: List[str] = []
â”‚ â”‚ -    for class_ in inspect.getmro(type(node)):
â”‚ â”‚ -        if hasattr(class_, "__slots__"):
â”‚ â”‚ -            slots.extend(class_.__slots__)
â”‚ â”‚ -    return sorted(slots)
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚  # Visitor is defined here for now, to avoid circular imports.
â”‚ â”‚  class AbstractVisitor(Generic[T], abc.ABC):
â”‚ â”‚      """An abstract visitor."""
â”‚ â”‚  
â”‚ â”‚      def visit_text(self, node: "Text", **kwargs: Any) -> T:
â”‚ â”‚          """Visit text node."""
â”‚ â”‚          return self.visit_default(node, **kwargs)
â”‚ â”‚ @@ -62,39 +52,40 @@
â”‚ â”‚          return self.visit_default(node, **kwargs)
â”‚ â”‚  
â”‚ â”‚      def visit_default(self, node: "AbstractSchemaNode", **kwargs: Any) -> T:
â”‚ â”‚          """Default node implementation."""
â”‚ â”‚          raise NotImplementedError()
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -class AbstractSchemaNode(abc.ABC):
â”‚ â”‚ +class AbstractSchemaNode(BaseModel):
â”‚ â”‚      """Abstract schema node.
â”‚ â”‚  
â”‚ â”‚      Each node is expected to have a unique ID, and should
â”‚ â”‚      only use alphanumeric characters.
â”‚ â”‚  
â”‚ â”‚      The ID should be unique across all inputs that belong
â”‚ â”‚      to a given form.
â”‚ â”‚  
â”‚ â”‚      The description should describe what the node represents.
â”‚ â”‚      It is used during prompt generation.
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    __slots__ = "id", "description", "many"
â”‚ â”‚ -
â”‚ â”‚ -    def __init__(self, *, id: str, description: str = "", many: bool = False) -> None:
â”‚ â”‚ -        self.id = id
â”‚ â”‚ -        self.description = description
â”‚ â”‚ -        self.many = many
â”‚ â”‚ -
â”‚ â”‚ -        if not VALID_IDENTIFIER_PATTERN.match(self.id):
â”‚ â”‚ +    id: str
â”‚ â”‚ +    description: str = ""
â”‚ â”‚ +    many: bool = False
â”‚ â”‚ +
â”‚ â”‚ +    @validator("id")
â”‚ â”‚ +    def ensure_valid_uid(cls, uid: str) -> str:
â”‚ â”‚ +        """Validate that using a valid identifier."""
â”‚ â”‚ +        if not VALID_IDENTIFIER_PATTERN.match(uid):
â”‚ â”‚              raise ValueError(
â”‚ â”‚ -                f"`{self.id}` is not a valid identifier. "
â”‚ â”‚ -                "Please only use lower cased a-z, _ or the digits 0-9"
â”‚ â”‚ +                f"`{id}` is not a valid identifier. "
â”‚ â”‚ +                f"Please only use lower cased a-z, _ or the digits 0-9"
â”‚ â”‚              )
â”‚ â”‚ +        return uid
â”‚ â”‚  
â”‚ â”‚      @abc.abstractmethod
â”‚ â”‚      def accept(self, visitor: AbstractVisitor[T], **kwargs: Any) -> T:
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚          raise NotImplementedError()
â”‚ â”‚  
â”‚ â”‚      # Update return type to `Self` when bumping python version.
â”‚ â”‚ @@ -107,62 +98,34 @@
â”‚ â”‚          new_object = copy.copy(self)
â”‚ â”‚          if id:
â”‚ â”‚              new_object.id = id
â”‚ â”‚          if description:
â”‚ â”‚              new_object.description = description
â”‚ â”‚          return new_object
â”‚ â”‚  
â”‚ â”‚ -    def __repr__(self) -> str:
â”‚ â”‚ -        """Get representation of the node."""
â”‚ â”‚ -        return f"{type(self).__name__}({self.id})"
â”‚ â”‚ -
â”‚ â”‚ -    def __eq__(self: Any, other: Any) -> bool:
â”‚ â”‚ -        """Equality check"""
â”‚ â”‚ -        if not isinstance(self, AbstractSchemaNode):
â”‚ â”‚ -            raise AssertionError(f"Cannot compare {type(self)} with {type(other)}")
â”‚ â”‚ -        if type(self) != type(other):
â”‚ â”‚ -            return False
â”‚ â”‚ -
â”‚ â”‚ -        if _get_all_slots(self) == _get_all_slots(other):
â”‚ â”‚ -            attr_getters = [operator.attrgetter(attr) for attr in self.__slots__]
â”‚ â”‚ -            return all(getter(self) == getter(other) for getter in attr_getters)
â”‚ â”‚ -
â”‚ â”‚ -        return False
â”‚ â”‚ -
â”‚ â”‚  
â”‚ â”‚  class ExtractionSchemaNode(AbstractSchemaNode, abc.ABC):
â”‚ â”‚      """An abstract definition for inputs that involve extraction.
â”‚ â”‚  
â”‚ â”‚      An extraction input can be associated with extraction examples.
â”‚ â”‚  
â”‚ â”‚      An extraction example is a 2-tuple composed of a text segment and the expected
â”‚ â”‚      extraction.
â”‚ â”‚  
â”‚ â”‚      For example:
â”‚ â”‚  
â”‚ â”‚      .. code-block:: python
â”‚ â”‚ +
â”‚ â”‚          [
â”‚ â”‚              ("I bought this cookie for $10", "$10"),
â”‚ â”‚              ("Eggs cost twelve dollars", "twelve dollars"),
â”‚ â”‚          ]
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    __slots__ = ("examples",)
â”‚ â”‚ -
â”‚ â”‚ -    def __init__(
â”‚ â”‚ -        self,
â”‚ â”‚ -        *,
â”‚ â”‚ -        id: str,
â”‚ â”‚ -        description: str = "",
â”‚ â”‚ -        many: bool = False,
â”‚ â”‚ -        examples: Sequence[Tuple[str, Union[str, Sequence[str]]]] = tuple(),
â”‚ â”‚ -    ) -> None:
â”‚ â”‚ -        """Initialize for extraction input."""
â”‚ â”‚ -        super().__init__(id=id, description=description, many=many)
â”‚ â”‚ -        self.examples = examples
â”‚ â”‚ +    examples: Sequence[Tuple[str, Union[str, Sequence[str]]]] = tuple()
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Number(ExtractionSchemaNode):
â”‚ â”‚      """Built-in number input."""
â”‚ â”‚  
â”‚ â”‚      def accept(self, visitor: AbstractVisitor[T], **kwargs: Any) -> T:
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚ @@ -176,31 +139,15 @@
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚          return visitor.visit_text(self, **kwargs)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Option(AbstractSchemaNode):
â”‚ â”‚      """Built-in option input must be part of a selection input."""
â”‚ â”‚  
â”‚ â”‚ -    __slots__ = ("examples",)
â”‚ â”‚ -
â”‚ â”‚ -    def __init__(
â”‚ â”‚ -        self,
â”‚ â”‚ -        *,
â”‚ â”‚ -        id: str,
â”‚ â”‚ -        description: str = "",
â”‚ â”‚ -        many: bool = False,
â”‚ â”‚ -        examples: Sequence[str] = tuple(),
â”‚ â”‚ -    ) -> None:
â”‚ â”‚ -        """Initialize for extraction input."""
â”‚ â”‚ -        if many:
â”‚ â”‚ -            # TODO: Fix the type hierarchy so that `many` isn't provided to option.
â”‚ â”‚ -            raise ValueError("Option inputs cannot be many.")
â”‚ â”‚ -
â”‚ â”‚ -        super().__init__(id=id, description=description, many=many)
â”‚ â”‚ -        self.examples = examples
â”‚ â”‚ +    examples: Sequence[str] = tuple()
â”‚ â”‚  
â”‚ â”‚      def accept(self, visitor: AbstractVisitor[T], **kwargs: Any) -> T:
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚          return visitor.visit_option(self, **kwargs)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Selection(AbstractSchemaNode):
â”‚ â”‚ @@ -232,34 +179,17 @@
â”‚ â”‚              null_examples=[
â”‚ â”‚                  "I like flowers",
â”‚ â”‚              ],
â”‚ â”‚              many=False
â”‚ â”‚          )
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    __slots__ = "options", "examples", "null_examples"
â”‚ â”‚ -
â”‚ â”‚ -    def __init__(
â”‚ â”‚ -        self,
â”‚ â”‚ -        *,
â”‚ â”‚ -        id: str,
â”‚ â”‚ -        description: str = "",
â”‚ â”‚ -        many: bool = False,
â”‚ â”‚ -        options: Sequence[Option],
â”‚ â”‚ -        examples: Sequence[Tuple[str, Union[str, Sequence[str]]]] = tuple(),
â”‚ â”‚ -        null_examples: Sequence[str] = tuple(),
â”‚ â”‚ -    ) -> None:
â”‚ â”‚ -        """Initialize for extraction input."""
â”‚ â”‚ -        super().__init__(id=id, description=description, many=many)
â”‚ â”‚ -
â”‚ â”‚ -        if not options:
â”‚ â”‚ -            raise ValueError("Selection inputs must have at least one option.")
â”‚ â”‚ -        self.options = options
â”‚ â”‚ -        self.examples = examples
â”‚ â”‚ -        self.null_examples = null_examples
â”‚ â”‚ +    options: Sequence[Option]
â”‚ â”‚ +    examples: Sequence[Tuple[str, Union[str, Sequence[str]]]] = tuple()
â”‚ â”‚ +    null_examples: Sequence[str] = tuple()
â”‚ â”‚  
â”‚ â”‚      def accept(self, visitor: AbstractVisitor[T], **kwargs: Any) -> T:
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚          return visitor.visit_selection(self, **kwargs)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Object(AbstractSchemaNode):
â”‚ â”‚ @@ -285,30 +215,22 @@
â”‚ â”‚                      {"name": "Big Cookie", "price": "$10"}),
â”‚ â”‚                  ("Eggs cost twelve dollars", {}), # Not a cookie
â”‚ â”‚              ],
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚ -    __slots__ = ("attributes", "examples")
â”‚ â”‚ +    attributes: Sequence[Union[ExtractionSchemaNode, Selection, "Object"]]
â”‚ â”‚  
â”‚ â”‚ -    def __init__(
â”‚ â”‚ -        self,
â”‚ â”‚ -        *,
â”‚ â”‚ -        id: str,
â”‚ â”‚ -        description: str = "",
â”‚ â”‚ -        many: bool = False,
â”‚ â”‚ -        # All attributes but Option are OK.
â”‚ â”‚ -        # May could clean up the type system to simplify this.
â”‚ â”‚ -        attributes: Sequence[Union[ExtractionSchemaNode, Selection, "Object"]],
â”‚ â”‚ -        examples: Sequence[
â”‚ â”‚ -            Tuple[str, Mapping[str, Union[str, Sequence[str]]]]
â”‚ â”‚ -        ] = tuple(),
â”‚ â”‚ -    ) -> None:
â”‚ â”‚ -        """Initialize for extraction input."""
â”‚ â”‚ -        super().__init__(id=id, description=description, many=many)
â”‚ â”‚ -        self.attributes = attributes
â”‚ â”‚ -        self.examples = examples
â”‚ â”‚ +    examples: Sequence[
â”‚ â”‚ +        Tuple[
â”‚ â”‚ +            str,
â”‚ â”‚ +            Union[
â”‚ â”‚ +                Mapping[str, Any],
â”‚ â”‚ +                Sequence[Mapping[str, Any]],
â”‚ â”‚ +            ],
â”‚ â”‚ +        ]
â”‚ â”‚ +    ] = tuple()
â”‚ â”‚  
â”‚ â”‚      def accept(self, visitor: AbstractVisitor[T], **kwargs: Any) -> T:
â”‚ â”‚          """Accept a visitor."""
â”‚ â”‚          return visitor.visit_object(self, **kwargs)
â”‚ â”‚   --- kor-0.6.1/kor/prompts.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/prompts.py
â”‚ â”‚â”„ Files 22% similar despite different names
â”‚ â”‚ @@ -1,13 +1,14 @@
â”‚ â”‚  """Code to dynamically generate appropriate LLM prompts."""
â”‚ â”‚  from __future__ import annotations
â”‚ â”‚  
â”‚ â”‚  from typing import Any, List, Optional, Tuple
â”‚ â”‚  
â”‚ â”‚  from langchain import BasePromptTemplate
â”‚ â”‚ +from langchain.prompts import PromptTemplate
â”‚ â”‚  from langchain.schema import (
â”‚ â”‚      AIMessage,
â”‚ â”‚      BaseMessage,
â”‚ â”‚      HumanMessage,
â”‚ â”‚      PromptValue,
â”‚ â”‚      SystemMessage,
â”‚ â”‚  )
â”‚ â”‚ @@ -18,140 +19,157 @@
â”‚ â”‚  from kor.encoders.parser import KorParser
â”‚ â”‚  from kor.examples import generate_examples
â”‚ â”‚  from kor.nodes import Object
â”‚ â”‚  from kor.type_descriptors import TypeDescriptor
â”‚ â”‚  
â”‚ â”‚  from .validators import Validator
â”‚ â”‚  
â”‚ â”‚ +DEFAULT_INSTRUCTION_TEMPLATE = PromptTemplate(
â”‚ â”‚ +    input_variables=["type_description", "format_instructions"],
â”‚ â”‚ +    template=(
â”‚ â”‚ +        "Your goal is to extract structured information from the user's input that"
â”‚ â”‚ +        " matches the form described below. When extracting information please make"
â”‚ â”‚ +        " sure it matches the type information exactly. Do not add any attributes that"
â”‚ â”‚ +        " do not appear in the schema shown below.\n\n"
â”‚ â”‚ +        "{type_description}\n\n"
â”‚ â”‚ +        "{format_instructions}\n\n"
â”‚ â”‚ +    ),
â”‚ â”‚ +)
â”‚ â”‚ +
â”‚ â”‚  
â”‚ â”‚  class ExtractionPromptValue(PromptValue):
â”‚ â”‚      """Integration with langchain prompt format."""
â”‚ â”‚  
â”‚ â”‚ -    text: str
â”‚ â”‚ +    string: str
â”‚ â”‚ +    messages: List[BaseMessage]
â”‚ â”‚ +
â”‚ â”‚ +    class Config:
â”‚ â”‚ +        """Configuration for this pydantic object."""
â”‚ â”‚ +
â”‚ â”‚ +        extra = Extra.forbid
â”‚ â”‚ +        arbitrary_types_allowed = True
â”‚ â”‚ +
â”‚ â”‚ +    def to_string(self) -> str:
â”‚ â”‚ +        """Format the prompt to a string."""
â”‚ â”‚ +        return self.string
â”‚ â”‚ +
â”‚ â”‚ +    def to_messages(self) -> List[BaseMessage]:
â”‚ â”‚ +        """Get materialized messages."""
â”‚ â”‚ +        return self.messages
â”‚ â”‚ +
â”‚ â”‚ +
â”‚ â”‚ +class ExtractionPromptTemplate(BasePromptTemplate):
â”‚ â”‚ +    """Extraction prompt template."""
â”‚ â”‚ +
â”‚ â”‚      encoder: Encoder
â”‚ â”‚      node: Object
â”‚ â”‚      type_descriptor: TypeDescriptor
â”‚ â”‚      input_formatter: InputFormatter
â”‚ â”‚ -    prefix: str = (
â”‚ â”‚ -        "Your goal is to extract structured information from the user's input that"
â”‚ â”‚ -        " matches the form described below. When extracting information please make"
â”‚ â”‚ -        " sure it matches the type information exactly. Do not add any attributes that"
â”‚ â”‚ -        " do not appear in the schema shown below."
â”‚ â”‚ -    )
â”‚ â”‚ +    instruction_template: PromptTemplate
â”‚ â”‚  
â”‚ â”‚      class Config:
â”‚ â”‚          """Configuration for this pydantic object."""
â”‚ â”‚  
â”‚ â”‚          extra = Extra.forbid
â”‚ â”‚          arbitrary_types_allowed = True
â”‚ â”‚  
â”‚ â”‚ -    def get_formatted_text(self) -> str:
â”‚ â”‚ -        """Get the text encoded if needed."""
â”‚ â”‚ -        return format_text(self.text, input_formatter=self.input_formatter)
â”‚ â”‚ +    def format_prompt(  # type: ignore[override]
â”‚ â”‚ +        self,
â”‚ â”‚ +        text: str,
â”‚ â”‚ +    ) -> PromptValue:
â”‚ â”‚ +        """Format the prompt."""
â”‚ â”‚ +        text = format_text(text, input_formatter=self.input_formatter)
â”‚ â”‚ +        return ExtractionPromptValue(
â”‚ â”‚ +            string=self.to_string(text), messages=self.to_messages(text)
â”‚ â”‚ +        )
â”‚ â”‚  
â”‚ â”‚ -    def to_string(self) -> str:
â”‚ â”‚ +    def format(self, **kwargs: Any) -> str:
â”‚ â”‚ +        """Implementation of deprecated format method."""
â”‚ â”‚ +        raise NotImplementedError()
â”‚ â”‚ +
â”‚ â”‚ +    @property
â”‚ â”‚ +    def _prompt_type(self) -> str:
â”‚ â”‚ +        """Prompt type."""
â”‚ â”‚ +        return "ExtractionPromptTemplate"
â”‚ â”‚ +
â”‚ â”‚ +    def to_string(self, text: str) -> str:
â”‚ â”‚          """Format the template to a string."""
â”‚ â”‚ -        instruction_segment = self.generate_instruction_segment(self.node)
â”‚ â”‚ +        instruction_segment = self.format_instruction_segment(self.node)
â”‚ â”‚          encoded_examples = self.generate_encoded_examples(self.node)
â”‚ â”‚          formatted_examples: List[str] = []
â”‚ â”‚  
â”‚ â”‚          for in_example, output in encoded_examples:
â”‚ â”‚              formatted_examples.extend(
â”‚ â”‚                  [
â”‚ â”‚                      f"Input: {in_example}",
â”‚ â”‚                      f"Output: {output}",
â”‚ â”‚                  ]
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚ -        text = self.get_formatted_text()
â”‚ â”‚          formatted_examples.append(f"Input: {text}\nOutput:")
â”‚ â”‚          input_output_block = "\n".join(formatted_examples)
â”‚ â”‚          return f"{instruction_segment}\n\n{input_output_block}"
â”‚ â”‚  
â”‚ â”‚ -    def to_messages(self) -> List[BaseMessage]:
â”‚ â”‚ +    def to_messages(self, text: str) -> List[BaseMessage]:
â”‚ â”‚          """Format the template to chat messages."""
â”‚ â”‚ -        instruction_segment = self.generate_instruction_segment(self.node)
â”‚ â”‚ +        instruction_segment = self.format_instruction_segment(self.node)
â”‚ â”‚  
â”‚ â”‚          messages: List[BaseMessage] = [SystemMessage(content=instruction_segment)]
â”‚ â”‚          encoded_examples = self.generate_encoded_examples(self.node)
â”‚ â”‚  
â”‚ â”‚          for example_input, example_output in encoded_examples:
â”‚ â”‚              messages.extend(
â”‚ â”‚                  [
â”‚ â”‚                      HumanMessage(content=example_input),
â”‚ â”‚                      AIMessage(content=example_output),
â”‚ â”‚                  ]
â”‚ â”‚              )
â”‚ â”‚  
â”‚ â”‚ -        content = self.get_formatted_text()
â”‚ â”‚ -        messages.append(HumanMessage(content=content))
â”‚ â”‚ +        messages.append(HumanMessage(content=text))
â”‚ â”‚          return messages
â”‚ â”‚  
â”‚ â”‚      def generate_encoded_examples(self, node: Object) -> List[Tuple[str, str]]:
â”‚ â”‚          """Generate encoded examples."""
â”‚ â”‚          examples = generate_examples(node)
â”‚ â”‚          return encode_examples(
â”‚ â”‚              examples, self.encoder, input_formatter=self.input_formatter
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚ -    def generate_instruction_segment(self, node: Object) -> str:
â”‚ â”‚ +    def format_instruction_segment(self, node: Object) -> str:
â”‚ â”‚          """Generate the instruction segment of the extraction."""
â”‚ â”‚          type_description = self.type_descriptor.describe(node)
â”‚ â”‚ -        instruction_segment = self.encoder.get_instruction_segment()
â”‚ â”‚ -        return f"{self.prefix}\n\n{type_description}\n\n{instruction_segment}"
â”‚ â”‚ +        format_instructions = self.encoder.get_instruction_segment()
â”‚ â”‚ +        input_variables = self.instruction_template.input_variables
â”‚ â”‚  
â”‚ â”‚ +        formatting_kwargs = {}
â”‚ â”‚  
â”‚ â”‚ -class ExtractionPromptTemplate(BasePromptTemplate):
â”‚ â”‚ -    """Extraction prompt template."""
â”‚ â”‚ +        if "type_description" in input_variables:
â”‚ â”‚ +            formatting_kwargs["type_description"] = type_description
â”‚ â”‚  
â”‚ â”‚ -    encoder: Encoder
â”‚ â”‚ -    node: Object
â”‚ â”‚ -    type_descriptor: TypeDescriptor
â”‚ â”‚ -    input_formatter: InputFormatter
â”‚ â”‚ +        if "format_instructions" in input_variables:
â”‚ â”‚ +            formatting_kwargs["format_instructions"] = format_instructions
â”‚ â”‚  
â”‚ â”‚ -    class Config:
â”‚ â”‚ -        """Configuration for this pydantic object."""
â”‚ â”‚ -
â”‚ â”‚ -        extra = Extra.forbid
â”‚ â”‚ -        arbitrary_types_allowed = True
â”‚ â”‚ -
â”‚ â”‚ -    def format_prompt(  # type: ignore[override]
â”‚ â”‚ -        self, text: str, **kwargs: Any
â”‚ â”‚ -    ) -> PromptValue:
â”‚ â”‚ -        """Format the prompt."""
â”‚ â”‚ -        return ExtractionPromptValue(
â”‚ â”‚ -            text=text,
â”‚ â”‚ -            encoder=self.encoder,
â”‚ â”‚ -            node=self.node,
â”‚ â”‚ -            type_descriptor=self.type_descriptor,
â”‚ â”‚ -            input_formatter=self.input_formatter,
â”‚ â”‚ -        )
â”‚ â”‚ -
â”‚ â”‚ -    def format(self, **kwargs: Any) -> str:
â”‚ â”‚ -        """Implementation of deprecated format method."""
â”‚ â”‚ -        raise NotImplementedError()
â”‚ â”‚ -
â”‚ â”‚ -    @property
â”‚ â”‚ -    def _prompt_type(self) -> str:
â”‚ â”‚ -        """Prompt type."""
â”‚ â”‚ -        return "ExtractionPromptTemplate"
â”‚ â”‚ +        return self.instruction_template.format(**formatting_kwargs)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # PUBLIC API
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def create_langchain_prompt(
â”‚ â”‚      schema: Object,
â”‚ â”‚      encoder: Encoder,
â”‚ â”‚      type_descriptor: TypeDescriptor,
â”‚ â”‚ +    *,
â”‚ â”‚      validator: Optional[Validator] = None,
â”‚ â”‚      input_formatter: InputFormatter = None,
â”‚ â”‚ +    instruction_template: Optional[PromptTemplate] = None,
â”‚ â”‚  ) -> ExtractionPromptTemplate:
â”‚ â”‚      """Create a langchain style prompt with specified encoder."""
â”‚ â”‚      return ExtractionPromptTemplate(
â”‚ â”‚          input_variables=["text"],
â”‚ â”‚          output_parser=KorParser(encoder=encoder, validator=validator, schema_=schema),
â”‚ â”‚          encoder=encoder,
â”‚ â”‚          node=schema,
â”‚ â”‚          input_formatter=input_formatter,
â”‚ â”‚          type_descriptor=type_descriptor,
â”‚ â”‚ +        instruction_template=instruction_template or DEFAULT_INSTRUCTION_TEMPLATE,
â”‚ â”‚      )
â”‚ â”‚   --- kor-0.6.1/kor/type_descriptors.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/type_descriptors.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/kor/validators.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/kor/validators.py
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- kor-0.6.1/pyproject.toml
â”‚ â”œâ”€â”€ +++ kor-0.7.0/pyproject.toml
â”‚ â”‚â”„ Files 0% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  [tool.poetry]
â”‚ â”‚  name = "kor"
â”‚ â”‚ -version = "0.6.1"
â”‚ â”‚ +version = "0.7.0"
â”‚ â”‚  description = "Extract information with LLMs from text"
â”‚ â”‚  authors = ["Eugene Yurtsev <eyurtsev@gmail.com>"]
â”‚ â”‚  license = "MIT"
â”‚ â”‚  readme = "README.md"
â”‚ â”‚  repository = "https://www.github.com/eyurtsev/kor"
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.dependencies]
â”‚ â”‚   --- kor-0.6.1/setup.py
â”‚ â”œâ”€â”€ +++ kor-0.7.0/setup.py
â”‚ â”‚â”„ Files 0% similar despite different names
â”‚ â”‚ @@ -8,15 +8,15 @@
â”‚ â”‚  {'': ['*']}
â”‚ â”‚  
â”‚ â”‚  install_requires = \
â”‚ â”‚  ['langchain>=0.0.110', 'openai>=0.27,<0.28', 'pandas>=1.5.3,<2.0.0']
â”‚ â”‚  
â”‚ â”‚  setup_kwargs = {
â”‚ â”‚      'name': 'kor',
â”‚ â”‚ -    'version': '0.6.1',
â”‚ â”‚ +    'version': '0.7.0',
â”‚ â”‚      'description': 'Extract information with LLMs from text',
â”‚ â”‚      'long_description': '**âš  WARNING: Prototype with unstable API. ðŸš§**  \n\n[![Unit Tests](https://github.com/eyurtsev/kor/actions/workflows/test.yml/badge.svg?branch=main&event=push)](https://github.com/eyurtsev/kor/actions/workflows/test.yml)\n[![Test Docs](https://github.com/eyurtsev/kor/actions/workflows/doc_test.yaml/badge.svg?branch=main&event=push)](https://github.com/eyurtsev/kor/actions/workflows/doc_test.yaml)\n\n# Kor\n\n\nThis is a half-baked prototype that "helps" you extract structured data from text using LLMs ðŸ§©.\n\nSpecify the schema of what should be extracted and provide some examples.\n\nKor will generate a prompt, send it to the specified LLM and parse out the\noutput. \n\nYou might even get results back.\n\nSee [documentation](https://eyurtsev.github.io/kor/).\n\n## Version >=0.4.0\n\n* Integrated with langchain framework.\n* The code below uses Kor style schema, but you can also use [pydantic](https://eyurtsev.github.io/kor/validation.html).\n\n\n```python\n\n  from langchain.chat_models import ChatOpenAI\n  from kor import create_extraction_chain, Object, Text, Number\n\n  llm = ChatOpenAI(\n      model_name="gpt-3.5-turbo",\n      temperature=0,\n      max_tokens=2000,\n      frequency_penalty=0,\n      presence_penalty=0,\n      top_p=1.0,\n  )\n\n  schema = Object(\n    id="player",\n    description=(\n        "User is controling a music player to select songs, pause or start them or play"\n        " music by a particular artist."\n    ),\n    attributes=[\n        Text(\n            id="song",\n            description="User wants to play this song",\n            examples=[],\n            many=True,\n        ),\n        Text(\n            id="album",\n            description="User wants to play this album",\n            examples=[],\n            many=True,\n        ),\n        Text(\n            id="artist",\n            description="Music by the given artist",\n            examples=[("Songs by paul simon", "paul simon")],\n            many=True,\n        ),\n        Text(\n            id="action",\n            description="Action to take one of: `play`, `stop`, `next`, `previous`.",\n            examples=[\n                ("Please stop the music", "stop"),\n                ("play something", "play"),\n                ("play a song", "play"),\n                ("next song", "next"),\n            ],\n        ),\n    ],\n    many=False,\n)\n\n  chain = create_extraction_chain(llm, schema, encoder_or_encoder_class=\'json\')\n  chain.predict_and_parse(text="play songs by paul simon and led zeppelin and the doors")[\'data\']\n```\n\n```python\n  {\'player\': {\'artist\': [\'paul simon\', \'led zeppelin\', \'the doors\']}}\n```\n\n## Compatibility\n\n`Kor` is tested against python 3.8, 3.9, 3.10, 3.11.\n\n## Installaton \n\n```sh\npip install kor\n```\n\n## ðŸ’¡ Ideas\n\nIdeas of some things that could be done with Kor.\n\n* Extract data from text that matches an extraction schema.\n* Power an AI assistant with skills by precisely understanding a user request.\n* Provide natural language access to an existing API.\n\n## ðŸš§ Prototype\n\nPrototype! So the API is not expected to be stable!\n\n##  âœ¨ What does Kor excel at?  ðŸŒŸ \n\n* Making mistakes! Plenty of them!\n* Slow! It uses large prompts with examples, and works best with the larger slower LLMs.\n* Crashing for long enough pieces of text! Context length window could become\n  limiting when working with large forms or long text inputs.\n\nThe expectation is that as LLMs improve some of these issues will be mitigated.\n\n## Limtations\n\nNo limitations whatsoever. Do take a look at the section directly above as well\nas at the section about compatibility.\n\n## Potential Changes\n\n* Adding validators\n* Built-in components to quickly assemble schema with examples\n* Add routing layer to select appropriate extraction schema for a use case when\n  many schema exist\n\n## ðŸŽ¶ Why the name?\n\nFast to type and sufficiently unique.\n\n## Contributing\n\nIf you have any ideas or feature requests, please open an issue and share!\n\nSee [CONTRIBUTING.md](https://github.com/eyurtsev/kor/blob/main/CONTRIBUTING.md) for more information.\n\n## Other packages\n\nProbabilistically speaking this package is unlikely to work for your use case.\n\nSo here are some great alternatives:\n\n* [Promptify](https://github.com/promptslab/Promptify)\n* [MiniChain](https://srush.github.io/MiniChain/examples/stats/)\n',
â”‚ â”‚      'author': 'Eugene Yurtsev',
â”‚ â”‚      'author_email': 'eyurtsev@gmail.com',
â”‚ â”‚      'maintainer': 'None',
â”‚ â”‚      'maintainer_email': 'None',
â”‚ â”‚      'url': 'https://www.github.com/eyurtsev/kor',
â”‚ â”‚   --- kor-0.6.1/PKG-INFO
â”‚ â”œâ”€â”€ +++ kor-0.7.0/PKG-INFO
â”‚ â”‚â”„ Files 0% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: kor
â”‚ â”‚ -Version: 0.6.1
â”‚ â”‚ +Version: 0.7.0
â”‚ â”‚  Summary: Extract information with LLMs from text
â”‚ â”‚  Home-page: https://www.github.com/eyurtsev/kor
â”‚ â”‚  License: MIT
â”‚ â”‚  Author: Eugene Yurtsev
â”‚ â”‚  Author-email: eyurtsev@gmail.com
â”‚ â”‚  Requires-Python: >=3.8.1,<4.0.0
â”‚ â”‚  Classifier: License :: OSI Approved :: MIT License
